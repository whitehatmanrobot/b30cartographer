    if (WsbFileExists(pFileName)) {
            //
            // The file exists. Use it
            //
            fileThere = TRUE;
            pLoadName = pFileName;
        } else  {
                //
                // Look for the backup file
                //
                WsbTrace(OLESTR("WsbSafeLoad: trying .bak\n"));
                if (WsbFileExists(pBackupName)) {
                    //
                    // Use the backup file
                    //
                    // WsbLogEvent(WSB_MESSAGE_SAFELOAD_USING_BACKUP, 0, NULL, pFileName, NULL);
                    pLoadName = pBackupName;
                    fileThere = TRUE;
                    usingBackup= TRUE;
               } 
        }

        WsbAffirm(fileThere, WSB_E_NOTFOUND);
        //
        // The file exists so try to load from it
        //
        hr = pIPFile->Load(pLoadName, 0);

        if (SUCCEEDED(hr)) {
            //
            //  Load succeeded, release the file
            //
            WsbAffirmHr(pIWsbPersist->ReleaseFile());
            //
            // TO BE DONE: check if .bak file is out of date
            // and update it if so..
            // 
        } else if (!usingBackup) {
            WsbTrace(OLESTR("WsbSafeLoad: trying .bak\n"));
            if (WsbFileExists(pBackupName)) {
                WsbLogEvent(WSB_MESSAGE_SAFELOAD_USING_BACKUP, 0, NULL, pLoadName, WsbHrAsString(hr));
                //
                // Use the backup file
                //
                hrLoad = pIPFile->Load(pBackupName, 0);
                if (SUCCEEDED(hrLoad)) {
                    //  Load succeeded, release the file
                    WsbAffirmHr(pIWsbPersist->ReleaseFile());
                    //
                    // Now save the changes to the .col file to keep it in sync
                    //
                    hr = pIPFile->Save(pFileName, FALSE);

                    if (!SUCCEEDED(hr)) {
                        WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_SAVE, 0, NULL, pFileName, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }
                    //
                    // Commit and release .col file
                    //
                    WsbAffirmHr(pIWsbPersist->ReleaseFile());

                } else {
                    WsbLogEvent(WSB_MESSAGE_SAFELOAD_RECOVERY_FAILED, 0, NULL, pFileName, WsbHrAsString(hrLoad), NULL);
                    WsbThrow(hrLoad);
                }
            } else {
                WsbLogEvent(WSB_MESSAGE_SAFELOAD_RECOVERY_FAILED, 0, NULL, pFileName, NULL);
            }
        } else {
            WsbLogEvent(WSB_MESSAGE_SAFELOAD_RECOVERY_FAILED, 0, NULL, pFileName, WsbHrAsString(hr)); 
        }
    } WsbCatch(hr);

    if (pBackupName) {
        WsbFree(pBackupName);
    }

    WsbTraceOut(OLESTR("WsbSafeLoad"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    //  Restore tracing if we turned it off
    if (!TracePersistence) {
        WsbTraceThreadOn();
    }

    return(hr);
}

HRESULT
WsbSafeSave(
    IPersistFile* pIPFile
    )

/*++

Routine Description:

  Saves the object to a backup file and then replaces the objects Save file
  with the backup file.  Use with WsbSafeLoad

Arguments:

  pIPFile   - Pointer to the objects IPersistFile interface.

Return Value:

  S_OK      - Success
  E_...     - Some error.

--*/
{
    HRESULT        hr = S_OK;
    OLECHAR*       pBackupName = NULL;
    OLECHAR*       pFileName = NULL;
    BOOL           TracePersistence = FALSE;
    DWORD          file_attrs;

    //  Turn tracing off during save if it's not wanted
    if (g_pWsbTrace) {
        g_pWsbTrace->GetTraceSetting(WSB_TRACE_BIT_PERSISTENCE, &TracePersistence);
    }
    if (!TracePersistence) {
        WsbTraceThreadOff();
    }
    WsbTraceIn(OLESTR("WsbSafeSave"), OLESTR(""));

    try {
        CComPtr<IWsbPersistable> pIWsbPersist;

        //  Get the current Save file name
        WsbAffirmHr(pIPFile->GetCurFile(&pFileName));
        WsbTrace(OLESTR("WsbSafeSave: filename = <%ls>\n"), pFileName);

        //  Create name for backup file
        WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".bak"), &pBackupName));


        //  Make sure we have write access to the save file if it exists!
        if (WsbFileExists(pFileName)) {
            file_attrs = GetFileAttributes(pFileName);
            if (file_attrs & FILE_ATTRIBUTE_READONLY) {
               WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_ACCESS, 0, NULL, pFileName, NULL);
              WsbThrow(E_FAIL);
            }
        }

        //  Save data to save file
        hr = pIPFile->Save(pFileName, FALSE);
        if (!SUCCEEDED(hr)) {
            WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_SAVE, 0, NULL, pFileName, WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        //  Commit and release the save file
        WsbAffirmHr(pIPFile->QueryInterface(IID_IWsbPersistable,
                (void**)&pIWsbPersist));
        WsbAffirmHr(pIWsbPersist->ReleaseFile());

        //  Save data to .bak file
        //  Make sure we have write access to the save file if it exists!
        if (WsbFileExists(pBackupName)) {
            file_attrs = GetFileAttributes(pBackupName);
            if (file_attrs & FILE_ATTRIBUTE_READONLY) {
               WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_ACCESS, 0, NULL, pBackupName, NULL);
              WsbThrow(E_FAIL);
            }
        }
        hr = pIPFile->Save(pBackupName, FALSE);
        if (!SUCCEEDED(hr)) {
            WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_SAVE, 0, NULL, pBackupName, WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        //  Commit and release the .bak file
        WsbAffirmHr(pIWsbPersist->ReleaseFile());
    } WsbCatch(hr);

    if (pFileName) {
        WsbFree(pFileName);
    }
    if (pBackupName) {
        WsbFree(pBackupName);
    }

    WsbTraceOut(OLESTR("WsbSafeSave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    //  Restore tracing if we turned it off
    if (!TracePersistence) {
        WsbTraceThreadOn();
    }

    return(hr);
}


HRESULT WsbStreamToFile(
    HANDLE   hFile, 
    IStream* pStream,
    BOOL     AddCR
)
/*++

Routine Description:

  Copies text from a stream (which must have been created with CreateStreamOnHGlobal)
  to an open file (opened via CreateFile).  The text is assumed to be wide characters
  with no embedded wide-character nulls.  The text is converted to multibyte characters
  for output to the file.

  After the text is copied, the stream position is reset to the beggining.

Arguments:

  hFile      - Handle of output file.

  pStream    - Pointer to an IStream interface.

  AddCR      - Convert LF to CR-LF if TRUE.

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;
    const int         safe_size = 1024;
    static char       buf[safe_size + 16];
    static char       CRLF[3] = "\r\n";

    HGLOBAL           hMem = 0;        // Mem block for stream
    WCHAR*            addr = NULL;

    try {
        WCHAR             big_eof = 0;
        BOOL              doCRLF = FALSE;
        DWORD             err;
        DWORD             nbytes;
        int               nchars_todo;
        int               nchars_remaining;
        LARGE_INTEGER     seek_pos_zero;

        //  Make sure the text ends with a null
        WsbAffirmHr(pStream->Write(&big_eof, sizeof(WCHAR), NULL));

        //  Get the address of the memory block for the stream
        WsbAffirmHr(GetHGlobalFromStream(pStream, &hMem));
        addr = static_cast<WCHAR *>(GlobalLock(hMem));
        WsbAffirm(addr, E_HANDLE);

        //  Get the total number of chars. in the string
        nchars_remaining = wcslen(addr);

        //  Loop until all chars. are written
        while (nchars_remaining) {
            DWORD bytesWritten;

            if (nchars_remaining * sizeof(WCHAR) > safe_size) {
                nchars_todo = safe_size / sizeof(WCHAR);
            } else {
                nchars_todo = nchars_remaining;
            }

            //  Stop at LineFeed if we need to convert to CR-LF
            if (AddCR) {
                int    lf_todo;
                WCHAR* pLF;

                pLF = wcschr(addr, WCHAR('\n'));
                if (pLF) {
                    lf_todo = (int)(pLF - addr);
                    if (lf_todo < nchars_todo) {
                        nchars_todo = lf_todo;
                        doCRLF = TRUE;
                    }
                }
            }

            //  Output everything up to LF
            if (0 < nchars_todo) {
                nbytes = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, addr, nchars_todo, buf, 
                                safe_size, NULL, NULL);
                if (0 == nbytes) {
                    DWORD dwErr = GetLastError();          
                    hr = HRESULT_FROM_WIN32(dwErr);
                    WsbAffirmHr(hr);
                }                               

                if (!WriteFile(hFile, buf, nbytes, &bytesWritten, NULL)) {
                    err = GetLastError();
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                WsbAffirm(bytesWritten == nbytes, E_FAIL);
            }

            //  Output CR-LF in place of LF if needed
            if (doCRLF) {
                if (!WriteFile(hFile, CRLF, 2, &bytesWritten, NULL)) {
                    err = GetLastError();
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                WsbAffirm(bytesWritten == 2, E_FAIL);
                nchars_todo++;
                doCRLF = FALSE;
            }
            nchars_remaining -= nchars_todo;
            addr += nchars_todo;
        }

        seek_pos_zero.QuadPart = 0;
        WsbAffirmHr(pStream->Seek(seek_pos_zero, STREAM_SEEK_SET, NULL));

    } WsbCatch(hr);

    if (addr != NULL) {
        GlobalUnlock(hMem);
        addr = NULL;
    }

    return(hr);
}

// WsbFileExists - determine if a file exists or not
static BOOL WsbFileExists(OLECHAR* pFileName)
{
    BOOL                     doesExist = FALSE;
    DWORD                    file_attrs;

    WsbTraceIn(OLESTR("WsbFileExists"), OLESTR("%ls"), pFileName);

    file_attrs = GetFileAttributes(pFileName);
    if (0xffffffff != file_attrs)  {
        doesExist = TRUE;
    }

    WsbTraceOut(OLESTR("WsbFileExists"), OLESTR("%ls"), 
            WsbBoolAsString(doesExist));
    return(doesExist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbpstrg.cpp ===
#include "stdafx.h"

#include "wsb.h"
#include "wsbpstrg.h"

// {C03D4861-70D7-11d1-994F-0060976A546D}
static const GUID StringPtrGuid = 
{ 0xc03d4861, 0x70d7, 0x11d1, { 0x99, 0x4f, 0x0, 0x60, 0x97, 0x6a, 0x54, 0x6d } };


CComPtr<IMalloc>        CWsbStringPtr::m_pMalloc = 0;

CWsbStringPtr::CWsbStringPtr()
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
                
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

    } WsbCatch(hr);
}

CWsbStringPtr::CWsbStringPtr(const CHAR* pChar)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = pChar;

    } WsbCatch(hr);
}

CWsbStringPtr::CWsbStringPtr(const WCHAR* pWchar)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = pWchar;

    } WsbCatch(hr);
}


CWsbStringPtr::CWsbStringPtr(REFGUID rguid)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = rguid;

    } WsbCatch(hr);
}

CWsbStringPtr::CWsbStringPtr(const CWsbStringPtr& pString)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = pString;

    } WsbCatch(hr);
}

CWsbStringPtr::~CWsbStringPtr()
{
    WSB_OBJECT_SUB(StringPtrGuid, this);
    Free();
}

CWsbStringPtr::operator WCHAR*()
{
    return(m_pString);
}

WCHAR& CWsbStringPtr::operator *()
{
    _ASSERTE(0 != m_pString);
    return(*m_pString);
}

WCHAR** CWsbStringPtr::operator &()
{
    return(&m_pString);
}

WCHAR& CWsbStringPtr::operator [](const int i)
{
    _ASSERTE(0 != m_pString);
    return(m_pString[i]);
}

CWsbStringPtr& CWsbStringPtr::operator =(const CHAR* pChar)
{
    HRESULT     hr = S_OK;
    ULONG       length;
    int         count;

    try {
    
        // Are they setting it to something?
        if (0 != pChar) {
        
            // Otherwise, see if our current buffer is big enough.
            //
            // NOTE: With multibyte characters, we may be getting a bigger
            // buffer than we need, but the call to return the accurate
            // size is not ANSI.
            length = strlen(pChar);
            WsbAffirmHr(Realloc(length));
            WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

            // Copy the data (and convert to wide characters)
            count = mbstowcs(m_pString, pChar, length + 1);
            WsbAffirm((count != -1), E_FAIL);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}

CWsbStringPtr& CWsbStringPtr::operator =(const WCHAR* pWchar)
{
    HRESULT     hr = S_OK;
    ULONG       length;

    try {
    
        // Are they setting it to something?
        if (0 != pWchar) {
        
            // Otherwise, see if our current buffer is big enough.
            length = wcslen(pWchar);
            WsbAffirmHr(Realloc(length));

            // Copy the data (and convert to wide characters)
            wcscpy(m_pString, pWchar);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}

CWsbStringPtr& CWsbStringPtr::operator =(REFGUID rguid)
{
    HRESULT     hr = S_OK;
    OLECHAR*    tmpString = 0;

    try {
    
        // See if our current buffer is big enough.
        WsbAffirmHr(Realloc(WSB_GUID_STRING_SIZE));

        // Fill with the GUID in string format
        WsbAffirmHr(WsbStringFromGuid(rguid, m_pString));

    } WsbCatchAndDo(hr, 
        Free();
    );

    return(*this);
}

CWsbStringPtr& CWsbStringPtr::operator =(const CWsbStringPtr& pString)
{
    *this = pString.m_pString;

    return(*this);
}

BOOL CWsbStringPtr::operator !()
{
    return((0 == m_pString) ? TRUE : FALSE);
}

HRESULT CWsbStringPtr::Alloc(ULONG size)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 == m_pString, E_UNEXPECTED);
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        m_pString = (WCHAR*)WsbAlloc((size + 1) * sizeof(WCHAR));
        WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

        // Make sure we always have a valid string so bad things don't happen.
        *m_pString = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Append(const CHAR* pChar)
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString = pChar;

    hr = Append(tmpString);

    return(hr);
}

HRESULT CWsbStringPtr::Append(const WCHAR* pWchar)
{
    HRESULT         hr = S_OK;
    ULONG           length = 0;
    ULONG           appendLength;

    try {
    
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        appendLength = wcslen(pWchar);
        if (0 != appendLength) {

            // Make sure the buffer is big enough.
            if (0 != m_pString) {
                length = wcslen(m_pString);
            }

            WsbAffirmHr(Realloc(length + appendLength));

            // Append the string.
            wcscat(m_pString, pWchar);
        }
    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Append(const CWsbStringPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Append(pString.m_pString);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(CHAR** ppChar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppChar, 0);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(CHAR** ppChar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    CHAR*       tmpString = 0;

    try {
    
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        // Allocate a buffer big enough to hold their string.
        //
        // NOTE: With multibyte characters, we may be getting a bigger
        // buffer than we need, but the call to return the accurate
        // size is not ANSI.
        if (m_pString != 0) {
            length = wcstombs(0, m_pString, 0);
        }

        if (bufferSize == 0) {
            tmpString = (CHAR*) WsbRealloc(*ppChar, (length + 1) * sizeof(CHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);
            if (*ppChar == 0) {
                tmpString = (CHAR*)WsbAlloc((bufferSize + 1) * sizeof(CHAR));
            } else {
                tmpString = *ppChar;
            }
        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppChar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            WsbAffirm (-1 != wcstombs(*ppChar, m_pString, length + 1), E_FAIL);
        } else {
            **ppChar = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(WCHAR** ppWchar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppWchar, 0);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(WCHAR** ppWchar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    WCHAR*      tmpString = 0;

    try {
    
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            tmpString = (WCHAR*) WsbRealloc(*ppWchar, (length + 1) * sizeof(WCHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);
            if (*ppWchar == 0) {
                tmpString = (WCHAR*) WsbRealloc(*ppWchar, (bufferSize + 1) * sizeof(WCHAR));
            }

        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppWchar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            wcscpy(*ppWchar, m_pString);
        } else {
            **ppWchar = 0;
        }


    } WsbCatch(hr);

    return(hr);
}


HRESULT CWsbStringPtr::CopyTo(GUID * pguid)
{
    HRESULT     hr = S_OK;

    hr = WsbGuidFromString(m_pString, pguid);

    return(hr);
}

HRESULT CWsbStringPtr::CopyToBstr(BSTR* pBstr)
{
    HRESULT     hr = S_OK;

    hr = CopyToBstr(pBstr, 0);

    return(hr);
}

HRESULT CWsbStringPtr::CopyToBstr(BSTR* pBstr, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;

    try {
    
        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            if (0 == *pBstr) {
                *pBstr = WsbAllocString(m_pString);
            } else {
                WsbAffirm(WsbReallocString(pBstr, m_pString), E_OUTOFMEMORY);
            }
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);

            if (0 == pBstr) {
                *pBstr = WsbAllocStringLen(m_pString, bufferSize);
            } else {
                WsbAffirm(WsbReallocStringLen(pBstr, m_pString, bufferSize), E_OUTOFMEMORY);
            }
        }

        WsbAffirm(0 != pBstr, E_OUTOFMEMORY);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId)
{
    HRESULT         hr = S_FALSE;
    CWsbStringPtr   dest;

    try {
    
        WsbAssert(0 != pMatchId, E_POINTER);

        // Initialize the return value.
        *pMatchId = 0;

        // Check each resource string mention and see if it is the same as
        // the string provided.
        for (ULONG testId = startId; (testId < (startId + idsToCheck)) && (*pMatchId == 0); testId++) {

            WsbAffirmHr(dest.LoadFromRsc(_Module.m_hInst, testId));

            if (wcscmp(dest, m_pString) == 0) {
                *pMatchId = testId;
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Free(void)
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        if ((0 != m_pString) && (0 == m_givenSize)) {
            WsbFree(m_pString);
            m_pString = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::GetSize(ULONG* pSize)
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        if (0 == m_pString) {
            *pSize = 0;
        } else if (0 != m_givenSize) {
            *pSize = m_givenSize;
        } else {
            *pSize = (ULONG)(m_pMalloc->GetSize(m_pString) / sizeof(WCHAR) - 1);
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::GiveTo(WCHAR** ppWchar)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppWchar, E_POINTER);

        // Given them our string buffer, and forget about it.
        *ppWchar = m_pString;
        m_pString = 0;
        m_givenSize = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::LoadFromRsc(HINSTANCE instance, ULONG id)
{
    HRESULT     hr = S_OK;
    HRSRC       resource;
    ULONG       stringSize;

    try {

        // Find the resource requested. This requires converting the resource
        // identifier into a string.
        //
        // NOTE: Strings are not number individually, but in groups of 16!! This throws
        // off the latter size calculation, and some other strategy might be better
        // here (e.g. load to a fixed size and then allocate again if too small).
        resource = FindResource(instance, MAKEINTRESOURCE((id/16) + 1), RT_STRING);
        WsbAffirm(resource != 0, E_FAIL);

        // How big is the string?
        stringSize = SizeofResource(instance, resource);
        WsbAffirm(0 != stringSize, E_FAIL);
                  
        // Get the right sized buffer.
        WsbAffirmHr(Realloc(stringSize / sizeof(WCHAR)));

        // Load the string into the buffer.
        WsbAffirm(LoadString(instance, id, m_pString, (stringSize / sizeof(WCHAR)) + 1) != 0, E_FAIL);

    } WsbCatch(hr);

    return(hr);
}



HRESULT CWsbStringPtr::Prepend(const CHAR* pChar) {
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString = pChar;

    hr = Prepend(tmpString);

    return(hr);
}

HRESULT CWsbStringPtr::Prepend(const WCHAR* pWchar) {
    HRESULT         hr = S_OK;
    ULONG           length;
    ULONG           prependLength;
    ULONG           i, j;

    try {
    
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        prependLength = wcslen(pWchar);
        WsbAffirm(0 != prependLength, S_OK);

        if (0 != m_pString) {
            length = wcslen(m_pString);
        } else {
            // Prepend code will work as long as we have a null string and not a null pointer...
            // Next Realloc statement will make it happen...
            length = 0;
        }

        WsbAffirmHr(Realloc(length + prependLength));
        
        // First move the existing string down in the buffer.
        for (i = length + 1, j = length + prependLength; i > 0; i--, j--) {
            m_pString[j] = m_pString[i - 1];
        }

        // Now prepend the string (except for the null)
        for (i = 0; i < prependLength; i++) {
            m_pString[i] = pWchar[i];
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Prepend(const CWsbStringPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Prepend(pString.m_pString);

    return(hr);
}

HRESULT CWsbStringPtr::Realloc(ULONG size)
{
    HRESULT     hr = S_OK;
    WCHAR*      tmpString;
    ULONG       currentSize;
    BOOL        bigEnough = FALSE;

    try {
        
        // We want to try to get a buffer of the size indicated.
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);
 
        // If the buffer is already bigger than the size needed, then
        // don't do anything.
        if (0 != m_pString) {
            WsbAffirmHr(GetSize(&currentSize));
            if (currentSize >= size) {
                bigEnough = TRUE;
            }
        }

        // Reallocate the buffer if we need a bigger one.
        if (!bigEnough) {
            
            // If we were given this buffer, then we can't reallocate it.
            WsbAssert(0 == m_givenSize, E_UNEXPECTED);

            // If we have never allocated a buffer, then allocate it normally.
            if (0 == m_pString) {
                WsbAffirmHr(Alloc(size));
            } else {
                WsbAssert(m_pMalloc != 0, E_UNEXPECTED);
                tmpString = (WCHAR*) WsbRealloc(m_pString, (size + 1) * sizeof(WCHAR));
                WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
                m_pString = tmpString;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::TakeFrom(WCHAR* pWchar, ULONG bufferSize)
{
    HRESULT         hr = S_OK;

    try {
        
        // Clear out any previously "taken" string.
        if (0 != m_givenSize) {
            m_pString = 0;
            m_givenSize = 0;
        }

        // If the given buffer is null, then we are responsible for allocating it.
        if (0 == pWchar) {
            if (0 != bufferSize) {
                WsbAffirmHr(Realloc(bufferSize));
            }
        }
        
        // Otherwise, we need to get rid of any buffer we had and use the one indicated.
        else {
            if (0 != m_pString) {
                WsbAffirmHr(Free());
            }
            m_pString = pWchar;

            if (0 != bufferSize) {
                m_givenSize = bufferSize;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::VPrintf(const WCHAR* fmtString, va_list vaList)
{
    HRESULT         hr = S_OK;

    try {
        Realloc(WSB_TRACE_BUFF_SIZE);
        vswprintf (m_pString, fmtString, vaList);
            
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbshrt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbshrt.cpp

Abstract:

    This component is an object representations of the SHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbshrt.h"


HRESULT
CWsbShort::CompareToShort(
    IN SHORT value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbShort::CompareToShort

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbShort::CompareToShort"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbShort::CompareToShort"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbShort::CompareToIShort(
    IN IWsbShort* pShort,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbShort::CompareToIShort

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       value;

    WsbTraceIn(OLESTR("CWsbShort::CompareToIShort"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pShort, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pShort->GetShort(&value));
        hr = CompareToShort(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::CompareToIShort"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbShort::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbShort*  pShort;

    WsbTraceIn(OLESTR("CWsbShort::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbShort interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbShort, (void**) &pShort));
        hr = CompareToIShort(pShort, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::CompareTo"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbShort::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbShort::GetShort(
    OUT SHORT* pValue
    )

/*++

Implements:

  IWsbShort::GetShort

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::GetShort"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::GetShort"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbShort::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbShort;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbShort::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(SHORT);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbShort::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbShort::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbShort::SetShort(
    SHORT value
    )

/*++

Implements:

  IWsbShort::SetShort

--*/
{
    WsbTraceIn(OLESTR("CWsbShort::SetShort"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbShort::SetShort"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbShort::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbShort>      pShort1;
    CComPtr<IWsbShort>      pShort2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    SHORT                   value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbShort::Test"), OLESTR(""));

    try {

        // Get the pShort interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbShort*) this)->QueryInterface(IID_IWsbShort, (void**) &pShort1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pShort1->SetShort(32000));
                WsbAffirmHr(pShort1->GetShort(&value));
                WsbAssert(value == 32000, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbShort, NULL, CLSCTX_ALL, IID_IWsbShort, (void**) &pShort2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort2->GetShort(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(-767));
                    WsbAffirmHr(pShort2->SetShort(-767));
                    WsbAssert(pShort1->IsEqual(pShort2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(767));
                    WsbAffirmHr(pShort2->SetShort(-767));
                    WsbAssert(pShort1->IsEqual(pShort2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(-900));
                    WsbAffirmHr(pShort2->SetShort(-900));
                    WsbAssert((pShort1->CompareTo(pShort2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(-900));
                    WsbAffirmHr(pShort2->SetShort(-400));
                    WsbAssert((pShort1->CompareTo(pShort2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(15000));
                    WsbAffirmHr(pShort2->SetShort(10000));
                    WsbAssert((pShort1->CompareTo(pShort2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pShort2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pShort2->SetShort(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbShort.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pShort1->SetShort(-888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbShort.tst"), 0));
                        WsbAssert(pShort1->CompareToShort(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbregty.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbregty.cpp

Abstract:

    This is the implementation of registry access helper functions 
    and is a part of RsCommon.dll.

Author:

    Rohde Wakefield    [rohde]   05-Nov-1996

Revision History:

--*/

#include "stdafx.h"


HRESULT
WsbOpenRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  REGSAM sam,
    OUT HKEY * phKeyMachine,
    OUT HKEY * phKey
    )

/*++

Routine Description:

    Given a machine name and path, connect to obtain an HKEY
    that can be used to do registry work.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    sam - permission desired to registry key.

    phKeyMachine - return of HKEY to machine.

    phKey - return of HKEY to path.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

--*/

{
    WsbTraceIn ( L"WsbOpenRegistryKey",
        L"szMachine = '%ls', szPath = '%ls', sam = 0x%p, phKeyMachine = 0x%p, phKey = 0x%p",
        szMachine, szPath, sam, phKeyMachine, phKey );

    HRESULT hr = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != phKey, E_POINTER );
        WsbAssert ( 0 != phKeyMachine, E_POINTER );

        *phKey = *phKeyMachine = 0;
    
        WsbAffirmWin32 ( RegConnectRegistry ( (WCHAR*) szMachine, HKEY_LOCAL_MACHINE, phKeyMachine ) );

        WsbAffirmWin32 ( RegOpenKeyEx ( *phKeyMachine, szPath, 0, sam, phKey ) );


    } WsbCatchAndDo ( hr,

        //
        // Clean up from error
        //

        if ( phKeyMachine && *phKeyMachine ) {

            RegCloseKey ( *phKeyMachine );
            *phKeyMachine = 0;

        }

    ) // WsbCatchAndDo

    WsbTraceOut ( L"WsbOpenRegistryKey",
        L"HRESULT = %ls, *phKeyMachine = %ls, *phKey = %ls",
        WsbHrAsString ( hr ),
        WsbStringCopy ( WsbPtrToPtrAsString ( (void**)phKeyMachine ) ),
        WsbStringCopy ( WsbPtrToPtrAsString ( (void**)phKey ) ) );

    return ( hr );
}


HRESULT
WsbCloseRegistryKey (
    IN OUT HKEY * phKeyMachine,
    IN OUT HKEY * phKey
    )

/*++

Routine Description:

    As a companion to WsbOpenRegistryKey, close the given keys and zero
    their results.

Arguments:

    phKeyMachine - HKEY to machine.

    phKey - HKEY to path.

Return Value:

    S_OK - Success.

    E_POINTER - Invalid pointer passed in.

--*/

{
    WsbTraceIn ( L"WsbCloseRegistryKey",
        L"phKeyMachine = 0x%p, phKey = 0x%p", phKeyMachine, phKey );

    HRESULT hr = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != phKey, E_POINTER );
        WsbAssert ( 0 != phKeyMachine, E_POINTER );

        //
        // Clean up the keys
        //

        if ( *phKey ) {

            RegCloseKey ( *phKey );
            *phKey = 0;

        }

        if ( *phKeyMachine ) {

            RegCloseKey ( *phKeyMachine );
            *phKeyMachine = 0;

        }
    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbCloseRegistryKey",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbRemoveRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szKey
    )

/*++

Routine Description:

    This routine removes the value of a key as specified.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_FAIL - Failure occured setting the value.

    E_POINTER - invalid pointer passed in as parameter.

--*/

{
    WsbTraceIn ( L"WsbRemoveRegistryKey",
        L"szMachine = '%ls', szPath = '%ls', szKey = '%ls'",
        szMachine, szPath, szKey );

    HKEY hKeyMachine = 0,
         hKey        = 0;
    
    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        
        //
        // Open and delete the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE | DELETE, &hKeyMachine, &hKey ) );
        WsbAffirmWin32 ( RegDeleteKey ( hKey, szKey ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbRemoveRegistryKey",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbRemoveRegistryValue (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    )

/*++

Routine Description:

    This routine removes the value of a key as specified.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to remove.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_FAIL - Failure occured setting the value.

    E_POINTER - invalid pointer passed in as parameter.

--*/

{
    WsbTraceIn ( L"WsbRemoveRegistryValue",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls'",
        szMachine, szPath, szValue );

    HKEY hKeyMachine = 0,
         hKey        = 0;
    
    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != szValue, E_POINTER );
        
        //
        // Open and write the value in the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );
        WsbAffirmWin32 ( RegDeleteValue ( hKey, szValue ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbRemoveRegistryValue",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const BYTE *pData,
    IN  DWORD cbData
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is REG_BINARY.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    pData - Pointer to the data buffer to copy into value.

    cbData - Number of bytes to copy from pData.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_FAIL - Failure occured setting the value.

    E_POINTER - invalid pointer passed in as parameter.

--*/

{
    WsbTraceIn ( L"WsbSetRegistryValueData",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pData = 0x%p, cbData = %ld",
        szMachine, szPath, szValue, pData, cbData );

    HKEY hKeyMachine = 0,
         hKey        = 0;
    
    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != szValue, E_POINTER );
        
        //
        // Open and write the value in the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );
        WsbAffirmWin32 ( RegSetValueEx ( hKey, szValue, 0, REG_BINARY, pData, cbData ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbSetRegistryValueData",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT BYTE *pData,
    IN  DWORD cbData,
    OUT DWORD * pcbData OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the value of a key as specified. Type of
    the value must be REG_BINARY.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pData - Pointer to the data buffer to copy into value.

    cbData - Size in bytes of pData.

    pcbData - number of bytes filled in pData.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured getting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueData",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pData = 0x%p, cbData = %ld, pcbData = 0x%p",
        szMachine, szPath, szValue, pData, cbData, pcbData );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != szValue, E_POINTER );
        WsbAssert ( 0 != pData, E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );

        //
        // Set up temporary vars in case NULL passed for pcbData
        //
        DWORD dwType, cbData2;
        if ( !pcbData ) {

            pcbData = &cbData2;

        }

        //
        // Query for the REG_BINARY value
        //

        *pcbData = cbData;
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, pData, pcbData ) );

        WsbAffirm ( REG_BINARY == dwType, E_FAIL );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueData",
        L"HRESULT = %ls, *pcbData = %ls", WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pcbData ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const OLECHAR * szString,
    IN        DWORD     dwType
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is dwType (defaults to REG_SZ)

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    szString - The string to place in the value.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbSetRegistryValueString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', szString = '%ls'",
        szMachine, szPath, szValue, szString );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        WsbAssert ( 0 != szValue,   E_POINTER );
        WsbAssert ( 0 != szString,  E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );

        WsbAffirmWin32 ( RegSetValueEx ( hKey, szValue, 0, dwType, (BYTE*)szString, ( wcslen ( szString ) + 1 ) * sizeof ( OLECHAR ) ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbSetRegistryValueString",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    )

/*++

Routine Description:

    This routine get the value specified
    Type of the value must be REG_SZ or REG_EXPAND_SZ

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    szString - The string buffer to fill with the value.

    cSize - Size of szString in OLECAHR's.

    pcLength - Number of OLECHAR actually written (without L'\0').

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', szString = 0x%p, cSize = '%ld', pcLength = 0x%p",
        szMachine, szPath, szValue, szString, cSize, pcLength );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        WsbAssert ( 0 != szValue,   E_POINTER );
        WsbAssert ( 0 != szString,  E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );


        //
        // Temporary size vars in case pcLength is NULL
        //

        DWORD dwType, cbData2;
        if ( !pcLength ) {

            pcLength = &cbData2;

        }

        //
        // And do the query
        //

        *pcLength = (cSize - 1) * sizeof ( OLECHAR );
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, (BYTE*)szString, pcLength ) ) ;

        WsbAffirm ( (REG_SZ == dwType) || (REG_EXPAND_SZ == dwType), E_FAIL );

        //
        // return characters, not bytes
        //

        *pcLength = ( *pcLength / sizeof ( OLECHAR ) ) - 1;

        //
        // Ensure NULL termination if not already null terminated
        //
        if (szString[*pcLength] != L'\0') {
            szString[*pcLength] = L'\0';
            (*pcLength)++;
        }

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueString",
        L"HRESULT = %ls, szString = '%ls', *pcbLength = %ls",
        WsbHrAsString ( hr ), szString, WsbPtrToUlongAsString ( pcLength ) );

    return ( hr );
}

HRESULT
WsbGetRegistryValueMultiString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szMultiString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    )

/*++

Routine Description:

    This routine get the value specified
    Type of the value must be REG_MULTI_SZ

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    szMultiString - The string buffer to fill with the value.

    cSize - Size of szString in OLECAHR's.

    pcLength - Number of OLECHAR actually written (without L'\0').

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueMultiString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', szMultiString = 0x%p, cSize = '%ld', pcLength = 0x%p",
        szMachine, szPath, szValue, szMultiString, cSize, pcLength );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        WsbAssert ( 0 != szValue,   E_POINTER );
        WsbAssert ( 0 != szMultiString,  E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );


        //
        // Temporary size vars in case pcLength is NULL
        //

        DWORD dwType, cbData2;
        if ( !pcLength ) {

            pcLength = &cbData2;

        }

        //
        // And do the query
        //

        *pcLength = (cSize - 1) * sizeof ( OLECHAR );
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, (BYTE*)szMultiString, pcLength ) ) ;

        WsbAffirm ( REG_MULTI_SZ == dwType, E_FAIL );

        //
        // return characters, not bytes
        //

        *pcLength = ( *pcLength / sizeof ( OLECHAR ) ) - 1;

        //
        // Ensure NULL termination if not already null terminated
        //
        if (szMultiString[*pcLength] != L'\0') {
            szMultiString[*pcLength] = L'\0';
            (*pcLength)++;
        }

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueMultiString",
        L"HRESULT = %ls, *pcbLength = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pcLength ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     dw
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is REG_DWORD

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    dw - DWORD value to store.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbSetRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', dw = %lu [0x%p]",
        szMachine, szPath, szValue, dw, dw );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssertPointer( szPath );
        WsbAssertPointer( szValue );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );

        WsbAffirmWin32 ( RegSetValueEx ( hKey, szValue, 0, REG_DWORD, (BYTE*)&dw, sizeof( DWORD ) ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbSetRegistryValueDWORD",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueDWORD(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       DWORD *   pdw
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is REG_SZ or REG_EXPAND_SZ

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pdw - pointer to a DWORD to store value in.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pdw = 0x%p",
        szMachine, szPath, szValue, pdw );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssertPointer( szPath );
        WsbAssertPointer( szValue );
        WsbAssertPointer( pdw );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );


        //
        // And do the query
        //

        DWORD dwType, cbData = sizeof( DWORD );
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, (BYTE*)pdw, &cbData ) ) ;

        WsbAffirm( REG_DWORD == dwType, E_FAIL );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueDWORD",
        L"HRESULT = %ls, *pdw = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pdw ) );

    return ( hr );
}


HRESULT
WsbAddRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     adw
    )

/*++

Routine Description:

    This routine adds an amount to a  registry value.
    Type of the value must be REG_DWORD

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to increment

    adw - DWORD value to add.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbAddRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', adw = %lu",
        szMachine, szPath, szValue, adw);

    HRESULT hr    = S_OK;
    DWORD   value = 0;

    //  Get the old value
    hr = WsbGetRegistryValueDWORD(szMachine, szPath, szValue, &value);

    //  Add to value and replace
    if (S_OK == hr) {
        value += adw;
    } else {
        value = adw;
    }
    hr = WsbSetRegistryValueDWORD(szMachine, szPath, szValue, value);

    WsbTraceOut ( L"WsbAddRegistryValueDWORD",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbIncRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    )

/*++

Routine Description:

    This routine increments a registry value by one.
    Type of the value must be REG_DWORD

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to increment

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbIncRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls'",
        szMachine, szPath, szValue);

    HRESULT hr       = S_OK;

    hr = WsbAddRegistryValueDWORD(szMachine, szPath, szValue, 1);

    WsbTraceOut ( L"WsbIncRegistryValueDWORD",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbCheckIfRegistryKeyExists(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    )

/*++

Routine Description:

    This routine  check if the supplied key exists
    If the key already exists, S_OK is returned.
    If it needed to be created, S_FALSE is returned.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

Return Value:

    S_OK - Connection made, Key already exists.

    S_FALSE - Connection made, key did not exist but was created

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured creating the key.

--*/

{
    WsbTraceIn ( L"WsbCheckIfRegistryKeyExists",
        L"szMachine = '%ls', szPath = '%ls'", szMachine, szPath );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        
        //
        // Open the key
        //

        HRESULT resultOpen = WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey );

        //
        // If key could be opened, everything is fine - return S_OK
        //

        if ( SUCCEEDED ( resultOpen ) ) {
            hr = S_OK;
            WsbCloseRegistryKey ( &hKeyMachine, &hKey );
        } else {
            hr = S_FALSE;
        }

    } WsbCatch ( hr )


    WsbTraceOut ( L"WsbCheckIfRegistryKeyExists",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbEnsureRegistryKeyExists (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    )

/*++

Routine Description:

    This routine creates the key specified by szPath. Multiple 
    levels in the path can be missing and thus created. If the
    key already exists, S_OK is returned. If it needed to be
    created, S_FALSE is returned.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

Return Value:

    S_OK - Connection made, Key already exists.

    S_FALSE - Connection made, key did not exist but was created

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured creating the key.

--*/

{
    WsbTraceIn ( L"WsbEnsureRegistryKeyExists",
        L"szMachine = '%ls', szPath = '%ls'", szMachine, szPath );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        
        //
        // Open the key
        //

        HRESULT resultOpen = WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey );

        //
        // If key could be opened, everything is fine - return S_OK
        //

        if ( SUCCEEDED ( resultOpen ) ) {

            hr = S_OK;

        } else {

            //
            // Otherwise, we need to start at root and create missing portion
            //
            
            //
            // Create a copy of the string. Using WsbQuickString so we have
            // automatic freeing of memory
            //
            
            WsbQuickString copyString ( szPath );
            WCHAR * pSubKey = copyString;
            
            WsbAffirm ( 0 != pSubKey, E_OUTOFMEMORY );
            
            DWORD result, createResult;
            HKEY  hSubKey;

            WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, L"", KEY_CREATE_SUB_KEY, &hKeyMachine, &hKey ) );
            
            pSubKey = wcstok ( pSubKey, L"\\" );

            while ( 0 != pSubKey ) {
            
                //
                // Create the key. If it exists, RegCreateKeyEx returns 
                // REG_OPENED_EXISTING_KEY which is ok here.
                //

                createResult = 0;

                result = RegCreateKeyEx ( hKey, pSubKey, 0, L"", 
                    REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, 0, &hSubKey, &createResult );

                WsbAffirm ( ERROR_SUCCESS == result, E_FAIL );

                WsbAffirm (
                    ( REG_CREATED_NEW_KEY     == createResult ) ||
                    ( REG_OPENED_EXISTING_KEY == createResult), E_FAIL );
            
                //
                // And move this hkey to be the next parent
                //
            
                RegCloseKey ( hKey );
                hKey = hSubKey;
                hSubKey = 0;
            
                //
                // And finally, find next token
                //

                pSubKey = wcstok ( 0, L"\\" );

            };
            
            //
            // If we succeeded to this point, return S_FALSE
            // for successfull creation of path
            //
            
            hr = S_FALSE;
        }

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbEnsureRegistryKeyExists",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        ULONG     value
    )

/*++

Routine Description:

    This routine puts a ULONG value in the registry as a string value.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    value - ULONG value to store.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    HRESULT hr       = S_OK;

    WsbTraceIn ( L"WsbSetRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', value = %lu",
        szMachine, szPath, szValue, value );

    try {
        OLECHAR      dataString[100];

        WsbAffirmHr(WsbEnsureRegistryKeyExists(szMachine, szPath));
        wsprintf(dataString, OLESTR("%lu"), value);
        WsbAffirmHr(WsbSetRegistryValueString (szMachine, szPath, szValue,
                dataString, REG_SZ));
    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbSetRegistryValueUlongAsString",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueUlongAsString(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG *   pvalue
    )

/*++

Routine Description:

    This routine gets a string value from the registry and converts
    it to a ULONG value.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pvalue - pointer to a ULONG to store value in.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    HRESULT      hr = S_OK;

    WsbTraceIn ( L"WsbGetRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pvalue = 0x%p",
        szMachine, szPath, szValue, pvalue );

    try {
        OLECHAR      dataString[100];
        DWORD        sizeGot;
        OLECHAR *    stopString;

        WsbAssertPointer( pvalue );
        
        WsbAffirmHr(WsbGetRegistryValueString(szMachine, szPath, szValue,
                dataString, 100, &sizeGot));
        *pvalue  = wcstoul( dataString,  &stopString, 10 );

    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbGetRegistryValueUlongAsString",
        L"HRESULT = %ls, *pvalue = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pvalue ) );

    return ( hr );
}

HRESULT
WsbGetRegistryValueUlongAsMultiString(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG **  ppValues,
    OUT       ULONG *   pNumValues
    )

/*++

Routine Description:

    This routine gets a multi-string value from the registry and converts
    it to a vector of ULONG values.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    ppvalues - pointer to a ULONG * to alloacte and store the output vector in

    pNumValues - Number of items returned

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured getting the value.

--*/

{
    HRESULT      hr = S_OK;

    WsbTraceIn ( L"WsbGetRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls'",
        szMachine, szPath, szValue );

    try {
        OLECHAR      dataString[256];
        DWORD        sizeGot;
        OLECHAR *    stopString;

        WsbAssertPointer(ppValues);
        WsbAssertPointer(pNumValues);

        *pNumValues = 0;
        *ppValues = NULL;

        WsbAffirmHr(WsbGetRegistryValueMultiString(szMachine, szPath, szValue,
                dataString, 256, &sizeGot));

        // Build the output vector
        OLECHAR *currentString = dataString;
        int size = 10;
        if ((*currentString) != NULL) {
            // first alocation
            *ppValues = (ULONG *)WsbAlloc(size*sizeof(ULONG));
            WsbAffirm(*ppValues != 0, E_OUTOFMEMORY);
        } else {
            hr = E_FAIL;
        }

        while ((*currentString) != NULL) {
            (*ppValues)[*pNumValues]  = wcstoul( currentString,  &stopString, 10 );
            (*pNumValues)++;

            if (*pNumValues == size) {
                size += 10;
                ULONG* pTmp = (ULONG *)WsbRealloc(*ppValues, size*sizeof(ULONG));
                WsbAffirm(0 != pTmp, E_OUTOFMEMORY);
                *ppValues = pTmp;
            }

            currentString += wcslen(currentString);
            currentString ++;
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbGetRegistryValueUlongAsString",
        L"HRESULT = %ls, num values = %lu",
        WsbHrAsString ( hr ), *pNumValues );

    return ( hr );
}


HRESULT
WsbRegistryValueUlongAsString(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN OUT    ULONG *   pvalue
    )

/*++

Routine Description:

    If a registry string value is present, this routine gets it and converts
    it to a ULONG value.  If it is not present, this routine sets it to the
    supplied default value.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pvalue - In: default value , Out: pointer to a ULONG to store value.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    HRESULT      hr = S_OK;

    WsbTraceIn ( L"WsbRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pvalue = 0x%p",
        szMachine, szPath, szValue, pvalue );

    try {
        ULONG l_value;
        
        WsbAssertPointer( pvalue );
        
        if (S_OK == WsbGetRegistryValueUlongAsString(szMachine, szPath, szValue,
                &l_value)) {
            *pvalue = l_value;
        } else {
            WsbAffirmHr(WsbSetRegistryValueUlongAsString(szMachine, szPath, 
                    szValue, *pvalue));
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbRegistryValueUlongAsString",
        L"HRESULT = %ls, *pvalue = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pvalue ) );

    return ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbstrg.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbstrg.cpp

Abstract:

    This component is an object representations of the STRING standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbstrg.h"


HRESULT
CWsbString::CompareToString(
    IN OLECHAR* value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbString::CompareToString
    
--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbString::CompareToString"), OLESTR("value = <%ls>"), value);

    // Comapre the two strings, and do the null checking in case the clib
    // can't handle it. If there are two valid strings, then use this objects
    // isCaseDependent flag to determine how to compare the values.
    if (0 == value) {
        if (m_value == 0) {
            result = 0;
        } else {
            result = 1;
        }

    } else {
        if (m_value == 0) {
            result = -1;
        } else {
            if (m_isCaseDependent) {
                result = (SHORT)wcscmp(m_value, value);
            }
            else {
                result = (SHORT)_wcsicmp(m_value, value);
            }
        }
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (0 != pResult) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbString::CompareToString"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbString::CompareToIString(
    IN IWsbString* pString,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbString::CompareToIString
    
--*/
{
    HRESULT         hr = E_FAIL;
    CWsbStringPtr   value;

    WsbTraceIn(OLESTR("CWsbString::CompareToIString"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pString, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pString->GetString(&value, 0));
        hr = CompareToString(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::CompareToIString"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbString::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbString* pString;

    WsbTraceIn(OLESTR("CWsbString::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbString interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbString, (void**) &pString));

        hr = CompareToIString(pString, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbString::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_isCaseDependent = TRUE;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbString::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbString;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbString::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_value) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbString::GetString(
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IWsbString::GetString
    
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetString"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        WsbAffirmHr(m_value.CopyTo(pValue, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetString"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbString::GetStringAndCase(
    OUT OLECHAR** pValue,
    OUT BOOL* pIsCaseDependent,
    IN ULONG bufferSize
    )

/*++

Implements:

  IWsbString::GetStringAndCase

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetString"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(0 != pIsCaseDependent, E_POINTER);
        WsbAffirmHr(m_value.CopyTo(pValue, bufferSize));
        *pIsCaseDependent = m_isCaseDependent;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetString"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbString::IsCaseDependent(
    void
    )

/*++

Implements:

  IWsbString::IsCaseDependent

--*/
{
    WsbTraceIn(OLESTR("CWsbString::IsCaseDependent"), OLESTR(""));

    WsbTraceOut(OLESTR("CWsbString::IsCaseDependent"), OLESTR("isCaseDependent = <%ls>"), WsbBoolAsString(m_isCaseDependent));
  
    return(m_isCaseDependent ? S_OK : S_FALSE);
}


HRESULT
CWsbString::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // First get CaseDependent flag.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isCaseDependent));

        // Now get the string.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value, 0));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::Load"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(&m_value));

    return(hr);
}


HRESULT
CWsbString::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);
        
        // First save the  CaseDependent flag.
        WsbAffirmHr(WsbSaveToStream(pStream, m_isCaseDependent));

        // Now save the string.
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR*)m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbString::SetIsCaseDependent(
    BOOL isCaseDependent
    )

/*++

Implements:

  IWsbString::SetIsCaseDependent

--*/
{
    WsbTraceIn(OLESTR("CWsbString::SetIsCaseDependent"), OLESTR("value = <%ls>"), WsbBoolAsString(isCaseDependent));

    m_isDirty = TRUE;
    m_isCaseDependent = isCaseDependent;

    WsbTraceOut(OLESTR("CWsbString::SetIsCaseDependent"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbString::SetString(
    IN OLECHAR* value
    )

/*++

Implements:

  IWsbString::SetString

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::SetString"), OLESTR("value = <%ls>"), WsbPtrToStringAsString(&value));

    try {

        m_value = value;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::SetString"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbString::SetStringAndCase(
    IN OLECHAR* value,
    IN BOOL isCaseDependent
    )

/*++

Implements:

  IWsbString::SetStringAndCase

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::SetStringAndCase"), OLESTR("value = <%ls>, isCaseDependent = <%ls>"), WsbPtrToStringAsString(&value), WsbBoolAsString(isCaseDependent));

    try {

        m_value = value;
        m_isDirty = TRUE;
        m_isCaseDependent = isCaseDependent;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::SetStringAndCase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbString::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbString>     pString1;
    CComPtr<IWsbString>     pString2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    OLECHAR*                value = NULL;
    BOOL                    isCaseDependent;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbString::Test"), OLESTR(""));

    try {

        // Get the pString interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbString*) this)->QueryInterface(IID_IWsbString, (void**) &pString1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetString(OLESTR("Test Case")));
                WsbAffirmHr(pString1->GetString(&value, 0));
                WsbAssert(wcscmp(value, OLESTR("Test Case")) == 0, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Set the case dependence flag.
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetIsCaseDependent(FALSE));
                WsbAssert(pString1->IsCaseDependent() == S_FALSE, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
            
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetIsCaseDependent(TRUE));
                WsbAssert(pString1->IsCaseDependent() == S_OK, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Set Both string and case
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetStringAndCase(OLESTR("Both"), FALSE));
                WsbAffirmHr(pString1->GetStringAndCase(&value, &isCaseDependent, 0));
                WsbAssert((wcscmp(value, OLESTR("Both")) == 0) && (isCaseDependent == FALSE), E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbString, NULL, CLSCTX_ALL, IID_IWsbString, (void**) &pString2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pString2->GetStringAndCase(&value, &isCaseDependent, 0));
                    WsbAssert((wcscmp(value, OLESTR("")) == 0) && isCaseDependent, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HiJk"), FALSE));
                    WsbAssert(pString1->IsEqual(pString2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HIJK"), FALSE));
                    WsbAssert(pString1->IsEqual(pString2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), FALSE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAssert(pString1->IsEqual(pString2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), FALSE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HIJK"), TRUE));
                    WsbAssert(pString1->IsEqual(pString2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("HiJk")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("AABC"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("BBC"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("abcc"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("abcc"), FALSE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef STRG_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pString2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pString2->SetStringAndCase(OLESTR("The quick brown fox."), TRUE));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbString.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pString1->SetStringAndCase(OLESTR("jumped over the lazy dog."), FALSE));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbString.tst"), 0));
                        WsbAssert(pString1->CompareToString(OLESTR("The quick brown fox."), NULL) == S_OK, E_FAIL);
                        WsbAssert(pString1->IsCaseDependent() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    // If we used the temporary string buffer, then free it now.
    if (0 != value) {
        WsbFree(value);
    }

    WsbTraceOut(OLESTR("CWsbString::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbshrt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbshrt.h

Abstract:

    This component is an object representations of the SHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBSHORT_
#define _WSBSHORT_

/*++

Class Name:
    
    CWsbShort

Class Description:

    An object representations of the SHORT standard type. It
    is both persistable and collectable.

--*/

class CWsbShort : 
    public CWsbObject,
    public IWsbShort,
    public CComCoClass<CWsbShort,&CLSID_CWsbShort>
{
public:
    CWsbShort() {}
BEGIN_COM_MAP(CWsbShort)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbShort)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbShort)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbShort)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbShort
public:
    STDMETHOD(CompareToShort)(SHORT value, SHORT* pResult);
    STDMETHOD(CompareToIShort)(IWsbShort* pShort, SHORT* pResult);
    STDMETHOD(GetShort)(SHORT* pValue);
    STDMETHOD(SetShort)(SHORT value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    SHORT           m_value;
};

#endif // _WSBSHORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbsvc.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbSvc.cpp

Abstract:

    This is the implementation of service helper functions.

Author:

    Art Bragg      5/29/97

Revision History:

--*/


#include "stdafx.h"
#include "ntsecapi.h"

HRESULT
WsbCheckService(
    IN  const OLECHAR * Computer,
    IN  GUID            GuidApp
    )
/*++

Routine Description:

Arguments:

    computer - NULL if local computer
    guidApp - app id of the service to check.


Return Value:

    S_OK     - Success - service is running
    S_FALSE  - Success - service is not running
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // Get the service status
        //
        DWORD serviceState;
        WsbAffirmHr( WsbGetServiceStatus( Computer, GuidApp, &serviceState ) );

        //
        // Is the service running?
        //
        if( SERVICE_RUNNING != serviceState ) WsbThrow( S_FALSE );

    } WsbCatch( hr );

    return( hr );
}

HRESULT
WsbGetServiceStatus(
    IN  const OLECHAR   *Computer,
    IN  GUID            GuidApp,
    OUT DWORD           *ServiceStatus
    )
/*++

Routine Description:

Arguments:

    Computer - NULL if local computer
    GuidApp - app id of the service to check.
    ServiceStatus - status of the service


Return Value:

    S_OK     - Success - service is running
    S_FALSE  - Success - service is not running
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    SC_HANDLE hSCM = 0;
    SC_HANDLE hService = 0;
    SERVICE_STATUS serviceStatusStruct;
    try {

        //
        // Find the service in the registry
        //

        CWsbStringPtr regPath = L"SOFTWARE\\Classes\\AppID\\";
        regPath.Append( CWsbStringPtr( GuidApp ) );

        //
        // Get the name of the service
        //

        OLECHAR serviceName[WSB_MAX_SERVICE_NAME];
        WsbAffirmHr( WsbGetRegistryValueString( Computer, regPath, L"LocalService", serviceName, WSB_MAX_SERVICE_NAME, 0 ) );

        //
        // Setup the service to run under the account
        //

        hSCM = OpenSCManager( Computer, 0, GENERIC_READ );
        WsbAffirmStatus( 0 != hSCM );

        hService = OpenService( hSCM, serviceName, SERVICE_QUERY_STATUS );
        WsbAffirmStatus( 0 != hService );

        // Get the service status
        WsbAffirmStatus( QueryServiceStatus( hService, &serviceStatusStruct ) );

        *ServiceStatus = serviceStatusStruct.dwCurrentState;

    } WsbCatch( hr );

    if( hSCM )        CloseServiceHandle( hSCM );
    if( hService )    CloseServiceHandle( hService );

    return( hr );
}

HRESULT
WsbGetServiceName(
    IN  const OLECHAR   *computer,
    IN  GUID            guidApp,
    IN  DWORD           cSize,
    OUT OLECHAR         *serviceName
    )
/*++

Routine Description:

Arguments:

    computer - NULL if local computer
    guidApp - app id of the service whose name to get.


Return Value:

    S_OK     - Success 
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;
    try {

        //
        // Find the service in the registry
        //

        CWsbStringPtr regPath = L"SOFTWARE\\Classes\\AppID\\";
        regPath.Append( CWsbStringPtr( guidApp ) );

        //
        // Get the name of the service
        //

        WsbAffirmHr( WsbGetRegistryValueString( computer, regPath, L"LocalService", serviceName, cSize, 0 ) );

    } WsbCatch( hr );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbserv.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbSvc.cpp

Abstract:

    This is the implementation of common methods that the Remote Storage
    services should utilize.

Author:

    Cat Brant       [cbrant]    24-Sep-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsbServ.h"

HRESULT 
WsbPowerEventNtToHsm(
    IN  DWORD NtEvent, 
    OUT ULONG * pHsmEvent
    )
/*++

Routine Description:
              
    Convert a NT power event (PBT_APM*) into our state change event.

Arguments:

    NtEvent     - The PBT_APM* power event.

    pHsmEvent   - Pointer to HSM change state (combination of
            HSM_SYSTEM_STATE_* values)
              
Return Value:

    S_OK     - Succes
    

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("WsbPowerEventNtToHsm"), OLESTR(""));

    try {
        WsbAffirmPointer(pHsmEvent);

        *pHsmEvent = HSM_STATE_NONE;
        switch(NtEvent)
        {
            case PBT_APMQUERYSTANDBY:
            case PBT_APMQUERYSUSPEND:
            case PBT_APMSTANDBY:
            case PBT_APMSUSPEND:
                // Suspend operations
                *pHsmEvent = HSM_STATE_SUSPEND;
                break;
            case PBT_APMQUERYSTANDBYFAILED:
            case PBT_APMQUERYSUSPENDFAILED:
            case PBT_APMRESUMESTANDBY:
            case PBT_APMRESUMESUSPEND:
                // Resume operations
                *pHsmEvent = HSM_STATE_RESUME;
                break;
            default:
                break;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbPowerEventNtToHsm"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return( hr );
}

HRESULT
WsbServiceSafeInitialize(
    IN  IWsbServer *pServer,
    IN  BOOL        bVerifyId,
    IN  BOOL        bPrimaryId,
    OUT BOOL       *pWasCreated
    )
/*++

Routine Description:
              
    This function performs various checks to guarantee that the instance of
    the service matches the instance that created the existing persistence 
    files. If this is not the case, the function returns an HRESULT that 
    indicates where the mismatch occured.
    
    Each service keeps a GUID in the registry and each HSM server object keeps
    the same id in its persistence file.  
    During the initial start (no registry and no persistence file) this 
    function establishes this match.  Upon subsequent starts, this function 
    guarantees the match of these GUIDs.
    
    It is considered recoverable if the GUID does not exist in the registry 
    but the persistence file can be found and contains a GUID.  In this 
    situation, this function re-establishes the GUID in the registry.  However, 
    if the GUID is found in the registry and either the persistence file is not 
    found or the GUID in the persistence file does not match, this function 
    returns an HRESULT that should prevent the service from running.

    Note: Since one service may have several server objects with several persistency files, 
    there may be some exceptions to the above, according ot the input flags:
    1) bVerifyId sets whether to verify existence of service id in the Registry. Generally, 
       a service should call with the flag on only once (for the first persistency file loaded).
    2) bPrimaryId sets whether to use this server id as the Registry id. Eventually, this id 
       becomes the only id in the Registry and all persistency files. Generally,  service 
       should call with the flag on only once (for one of its persistency files).


Arguments:

    pServer     - pointer to the IWsbServer interface of the Remote Storage
                  service that is being started

    bVerifyId   - A flag for whether to verify existence of a file if id is found in the Registry

    bPrimaryId  - A flag for whether to force equivalence of id and whether to set Registry id according to file id

    pWasCreated - if non-NULL, set to TRUE if the persistence file was created.
                  (If FALSE and return value is S_OK, the file was read.)
              
Return Value:

    S_OK     - Success - service startup completed successfully
    

--*/
{
    HRESULT         hr = S_OK;
    GUID            regServerId = GUID_NULL;    // GUID of service in registry
    GUID            dbServerId  = GUID_NULL;    // GUID of service in database
    BOOL            foundRegId = FALSE;         // Found Service ID in registry
    BOOL            foundDbId  = FALSE;         // Found Service ID in database
    CWsbStringPtr   regName;                    // Registry Name for service
    CWsbStringPtr   dbName;                     // Persistable File name for service
    CComPtr<IPersistFile>  pServerPersist;      // Service's persistable interface


    WsbTraceIn(OLESTR("WsbServiceSafeInitialize"), OLESTR(""));

    if (pWasCreated) {
        *pWasCreated = FALSE;
    }

    try {
        //
        // Go to the registry and find the GUID for this service
        //
        //
        // Get the registry name for the service
        //
        try  {
            WsbAffirmHr(pServer->GetRegistryName(&regName, 0));
            WsbAffirmHr(WsbGetServiceId(regName, &regServerId));
            foundRegId = TRUE;
        } WsbCatchAndDo( hr, if (WSB_E_NOTFOUND == hr)  \
            {WsbLogEvent(WSB_MESSAGE_SERVICE_ID_NOT_REGISTERED, 0, NULL, regName, WsbHrAsString(hr), NULL); \
            hr = S_OK;};);
        WsbAffirmHr( hr );
        
        //
        // Locate the persistence file for this service and load it
        //
        // Get the path to the file and the IPersist Interface
        //
        try  {
            WsbAffirmHr(pServer->GetDbPathAndName(&dbName, 0));
            WsbAffirmHr(pServer->QueryInterface(IID_IPersistFile, (void **)&pServerPersist));
            hr = WsbSafeLoad(dbName, pServerPersist, FALSE);

            if (WSB_E_NOTFOUND == hr) {
                WsbThrow(hr);
            }
            //  Check the status from the read; WSB_E_NOTFOUND means that
            //  there was no persistence file found to read
            if (!SUCCEEDED(hr)) {
                WsbAffirmHr(pServer->Unload());
                WsbThrow(hr);
            }

            WsbAffirmHr(pServer->GetId(&dbServerId));
            foundDbId = TRUE;
        } WsbCatchAndDo( hr, if (WSB_E_NOTFOUND == hr)  \
            {WsbLogEvent(WSB_MESSAGE_DATABASES_NOT_FOUND, 0, NULL, regName, WsbHrAsString(hr), NULL); \
            hr = S_OK;};);
        WsbAffirmHr( hr );
        
        //
        // Now evaluate what we have
        //
        if (foundDbId == TRUE )  {
            //
            // Got the persistence file, see if things are OK
            if (foundRegId == TRUE)  {
                if (regServerId != dbServerId)  {
                    if (bPrimaryId) {
                        //
                        // BIG PROBLEM!!!!!  The running instance of the
                        // server and the persistence file do not match.
                        // Log a message, STOP the server!
                        //
                        hr = WSB_E_SERVICE_INSTANCE_MISMATCH;
                        WsbLogEvent(WSB_MESSAGE_SERVICE_INSTANCE_MISMATCH, 0, NULL, regName, WsbHrAsString(hr), NULL); 
                    } else {
                        //
                        // This may happen once after an upgrade, when the primary id doesn't match all ids:
                        // Just set the already found (primary) id, after next Save it will be set in all col files
                        //
                        WsbAffirmHr(pServer->SetId(regServerId));   
                    }
                } else  {
                    //
                    // Life is good, OK to start
                    //   
                }
            } else  {
                //
                // We have an ID from the persistence file but there isn't one in
                // the registry.  So add it to the registry (if it is the primary id) and go on.
                //
                if (bPrimaryId) {
                    WsbAffirmHr(WsbSetServiceId(regName, dbServerId));
                    WsbLogEvent(WSB_MESSAGE_SERVICE_ID_REGISTERED, 0, NULL, regName, WsbHrAsString(hr), NULL); 
                }
            }
        } else  {
            //
            // No persistence file was found!  
            //
            if (foundRegId == TRUE)  {
                if (bVerifyId) {
                    //
                    // BIG PROBLEM!!!!!  There is a registered instance
                    // ID but we can't find the file - this is bad.
                    // Log a  warning message
                    //
                    hr = WSB_E_SERVICE_MISSING_DATABASES;
                    WsbLogEvent(WSB_MESSAGE_SERVICE_MISSING_DATABASES, 0, NULL, regName, WsbHrAsString(hr), NULL); 

                    // 
                    // We continue and recreate the col files using the id we found 
                    // That way, truncated files could be recalled even if the original col
                    // files are completely lost for some reason.
                    //
                    hr = S_OK;
                } 
                //
                // Just create the persistence file and save the existing id in it
                // regServerId contains the found id
                //
                WsbAffirmHr(pServer->SetId(regServerId));   

                WsbAffirmHr(WsbSafeCreate(dbName, pServerPersist));
                if (pWasCreated) {
                    *pWasCreated = TRUE;
                }
                WsbLogEvent(WSB_MESSAGE_SERVICE_NEW_INSTALLATION, 0, NULL, regName, WsbHrAsString(hr), NULL); 

            } else  {
                //
                // No persistence file and no registry entry - must be a new 
                // installation.  So get a GUID, save it in the registry
                // and save it in the file.
                //
                WsbAffirmHr(WsbCreateServiceId(regName, &regServerId));
                WsbAffirmHr(pServer->SetId(regServerId));

                WsbAffirmHr(WsbSafeCreate(dbName, pServerPersist));
                if (pWasCreated) {
                    *pWasCreated = TRUE;
                }
                WsbAffirmHr(WsbConfirmServiceId(regName, regServerId));
                WsbLogEvent(WSB_MESSAGE_SERVICE_NEW_INSTALLATION, 0, NULL, regName, WsbHrAsString(hr), NULL); 
            }
        }
        
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("WsbServiceSafeInitialize"), OLESTR("hr = <%ls>, wasCreated= %ls"), 
            WsbHrAsString(hr), WsbPtrToBoolAsString(pWasCreated));
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbtrak.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbtrak.cpp

Abstract:

    Utility functions to keep track of run-time information.


Author:

    Ron White   [ronw]   5-Dec-1997

Revision History:

--*/

#include "stdafx.h"
#include "wsbguid.h"

#if defined(WSB_TRACK_MEMORY)

#define OBJECT_TABLE_SIZE       100
#define POINTER_DATA_CURRENT    0
#define POINTER_DATA_CUMULATIVE 2
#define POINTER_DATA_MAX        1
#define POINTER_DATA_SIZE       3
#define POINTER_LIST_SIZE       1000

typedef struct {
    GUID     guid;
    LONG     count;
    LONG     total_count;
    LONG     max_count;
} OBJECT_TABLE_ENTRY;

typedef struct {
    OLECHAR *  guid_string;
    OLECHAR *  name;
    GUID *     pGuid;
} OBJECT_NAME_ENTRY;

typedef struct {
    LONG        count;
    LONGLONG    size;
} POINTER_DATA_ENTRY;

typedef struct {
    const void *     addr;
    LONG             order;
    ULONG            size;
    int              index;   // Index into object table
    const char *     filename;
    int              linenum;
} POINTER_LIST_ENTRY;

//  Module data
#if defined(CRT_DEBUG_MEMORY)
static _CrtMemState        CrtMemState;
#endif

static OBJECT_TABLE_ENTRY  object_table[OBJECT_TABLE_SIZE];
static int                 object_table_count = 0;
static POINTER_DATA_ENTRY  pointer_data[POINTER_DATA_SIZE];
static BOOL                pointer_data_initialized = FALSE;
static POINTER_LIST_ENTRY  pointer_list[POINTER_LIST_SIZE];
static int                 pointer_list_count = 0;

static OBJECT_NAME_ENTRY object_name_table[] = {
    { L"{C03D4861-70D7-11d1-994F-0060976A546D}", L"CWsbStringPtr", NULL },
    { L"{C03D4862-70D7-11d1-994F-0060976A546D}", L"CWsbBstrPtr", NULL },
    { L"{A0FF1F42-237A-11D0-81BA-00A0C91180F2}", L"CWsbGuid", NULL },
    { L"{9C7D6F13-1562-11D0-81AC-00A0C91180F2}", L"CWsbOrderedCollection", NULL },
    { L"{46CE9EDE-447C-11D0-98FC-00A0C9058BF6}", L"CWsbDbKey", NULL },

    { L"{E707D9B2-4F89-11D0-81CC-00A0C91180F2}", L"CFsaServerNTFS", NULL },
    { L"{FCDC8671-7329-11d0-81DF-00A0C91180F2}", L"CFsaFilterNTFS", NULL },
    { L"{112981B3-1BA5-11D0-81B2-00A0C91180F2}", L"CFsaResourceNTFS", NULL },
    { L"{0B8B6F12-8B3A-11D0-990C-00A0C9058BF6}", L"CFsaPremigratedDb", NULL },
    { L"{14005FF1-8B4F-11d0-81E6-00A0C91180F2}", L"CFsaTruncatorNTFS", NULL },
    { L"{CECCB131-286D-11d1-993E-0060976A546D}", L"CFsaRecoveryRec", NULL },
    { L"{7CA819F2-8AAB-11D0-990C-00A0C9058BF6}", L"CFsaPremigratedRec", NULL },
    { L"{B2AD2931-84FD-11d0-81E4-00A0C91180F2}", L"CFsaFilterClientNTFS", NULL },
    { L"{F7860350-AA27-11d0-B16D-00A0C916F120}", L"CFsaPostIt", NULL },
    { L"{B2AD2932-84FD-11d0-81E4-00A0C91180F2}", L"CFsaFilterRecallNTFS", NULL },
    { L"{112981B2-1BA5-11D0-81B2-00A0C91180F2}", L"CFsaScanItemNTFS", NULL },

    { L"{7B22FF29-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmActionManage", NULL },
    { L"{D9E04211-14D7-11d1-9938-0060976A546D}", L"CHsmActionOnResourcePostValidate", NULL },
    { L"{D9E04212-14D7-11d1-9938-0060976A546D}", L"CHsmActionOnResourcePreValidate", NULL },
    { L"{7B22FF24-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmActionTruncate", NULL },
    { L"{D3AF5DB1-1DF8-11D0-81B6-00A0C91180F2}", L"CHsmActionUnmanage", NULL },
    { L"{7B22FF26-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmActionValidate", NULL },
    { L"{AD40235F-00FC-11D0-819C-00A0C91180F2}", L"CHsmCritAlways", NULL },
    { L"{CFB04622-1C9F-11D0-81B4-00A0C91180F2}", L"CHsmCritManageable", NULL },
    { L"{7B22FF2C-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmCritMigrated", NULL },
    { L"{7B22FF2D-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmCritPremigrated", NULL },
    { L"{AD402346-00FC-11D0-819C-00A0C91180F2}", L"CHsmJob", NULL },
    { L"{AD402364-00FC-11D0-819C-00a0C91180F2}", L"CHsmJobContext", NULL },
    { L"{AD40234B-00FC-11D0-819C-00a0C91180F2}", L"CHsmJobDef", NULL },
    { L"{B8E1CD21-81D3-11d0-81E4-00A0C91180F2}", L"CHsmJobWorkItem", NULL },
    { L"{AB939AD0-6D67-11d0-9E2E-00A0C916F120}", L"CHsmManagedResource", NULL },
    { L"{8448dd80-7614-11d0-9e33-00a0c916f120}", L"CHsmManagedResourceCollection", NULL },
    { L"{BEA60F8A-7EBA-11d0-81E4-00A0C91180F2}", L"CHsmPhase", NULL },
    { L"{AD402350-00FC-11D0-819C-00A0C91180F2}", L"CHsmPolicy", NULL },
    { L"{AD40235A-00FC-11D0-819C-00A0C91180F2}", L"CHsmRule", NULL },
    { L"{C2E29801-B1BA-11d0-81E9-00A0C91180F2}", L"CHsmRuleStack", NULL },
    { L"{2D1E3156-25DE-11D0-8073-00A0C905F098}", L"CHsmServer", NULL },
    { L"{BEA60F80-7EBA-11d0-81E4-00A0C91180F2}", L"CHsmSession", NULL },
    { L"{FF67BB34-8430-11d0-81E4-00A0C91180F2}", L"CHsmSessionTotals", NULL },
    { L"{61F0B790-82D9-11d0-9E35-00A0C916F120}", L"CHsmStoragePool", NULL },
    { L"{23E45B60-C598-11d0-B16F-00A0C916F120}", L"CHsmWorkItem", NULL },
    { L"{247DF540-C558-11d0-B16F-00A0C916F120}", L"CHsmWorkQueue", NULL },

    { L"{450024A3-47D0-11D0-9E1E-00A0C916F120}", L"CBagHole", NULL },
    { L"{B13FA473-4E1B-11D0-9E22-00A0C916F120}", L"CBagInfo", NULL },
    { L"{F0D7AFE0-9026-11d0-9E3B-00A0C916F120}", L"CMediaInfo", NULL },
    { L"{768AD5A4-40C8-11D0-9E17-00A0C916F120}", L"CSegDB", NULL },
    { L"{37F704E6-3EF9-11D0-9E17-00A0C916F120}", L"CSegRec", NULL },

    { L"{BD030C00-000B-11D0-D0DD-00A0C9190459}", L"CMemIo Class", NULL },
    { L"{BD040C00-000B-11D0-D0DD-00A0C9190459}", L"CNtTapeIo Class", NULL },
    { L"{BD050C00-000B-11D0-D0DD-00A0C9190459}", L"CNtFileIo Class", NULL },

    { L"{FE37FA04-3729-11D0-8CF4-00A0C9190459}", L"RmsCartridge Class", NULL },
    { L"{FE37FA07-3729-11D0-8CF4-00A0C9190459}", L"RmsMediumChanger Class", NULL },
    { L"{FE37FA12-3729-11D0-8CF4-00A0C9190459}", L"RmsClient Class", NULL },
    { L"{FE37FA03-3729-11D0-8CF4-00A0C9190459}", L"RmsDriveClass Class", NULL },
    { L"{FE37FA05-3729-11D0-8CF4-00A0C9190459}", L"RmsDrive Class", NULL },
    { L"{FE37FA08-3729-11D0-8CF4-00A0C9190459}", L"RmsIEPort Class", NULL },
    { L"{FE37FA02-3729-11D0-8CF4-00A0C9190459}", L"RmsLibrary Class", NULL },
    { L"{FE37FA09-3729-11D0-8CF4-00A0C9190459}", L"RmsMediaSet Class", NULL },
    { L"{FE37FA13-3729-11D0-8CF4-00A0C9190459}", L"RmsNTMS Class", NULL },
    { L"{FE37FA11-3729-11D0-8CF4-00A0C9190459}", L"RmsPartition Class", NULL },
    { L"{FE37FA10-3729-11D0-8CF4-00A0C9190459}", L"RmsRequest Class", NULL },
    { L"{FE37FA01-3729-11D0-8CF4-00A0C9190459}", L"RmsServer Class", NULL },
    { L"{FE37FA14-3729-11D0-8CF4-00A0C9190459}", L"RmsSink Class", NULL },
    { L"{FE37FA06-3729-11D0-8CF4-00A0C9190459}", L"RmsStorageSlot Class", NULL },
    { L"{FE37FA15-3729-11D0-8CF4-00A0C9190459}", L"RmsTemplate Class", NULL },

    { NULL, NULL, NULL  }
};

//  Local functions
static BOOL     AddPointer(const void* addr, ULONG size, int index, const char * filename,
        int linenum);
static OLECHAR* GuidToObjectName(const GUID& guid);
static BOOL     SubPointer(const void* addr, int index);


//  AddPointer - add a new pointer to the pointer list
//    Return FALSE on failure (list is full or pointer is already in list)
static BOOL AddPointer(const void* addr, ULONG size, int index, 
        const char * filename, int linenum)
{
    int    empty_slot = -1;
    int    i;
    BOOL   status = TRUE;

    if (!pointer_data_initialized) {
        pointer_data[POINTER_DATA_CURRENT].count = 0;
        pointer_data[POINTER_DATA_CURRENT].size = 0;
        pointer_data[POINTER_DATA_MAX].count = 0;
        pointer_data[POINTER_DATA_MAX].size = 0;
        pointer_data[POINTER_DATA_CUMULATIVE].count = 0;
        pointer_data[POINTER_DATA_CUMULATIVE].size = 0;
        pointer_data_initialized = TRUE;
    }

    for (i = 0; i < pointer_list_count; i++) {
        if (NULL == pointer_list[i].addr) {
            empty_slot = i;
        } else if (addr == pointer_list[i].addr) {
            WsbTraceAlways(OLESTR("AddPointer: address already in list: %lx (<%ls>, line: <%ld>\n"),
                    (ULONG)addr, (OLECHAR *)filename, index);
            status = FALSE;
            break;
        }
    }

    if (i == pointer_list_count) {
        //  Not in list.  Is the list full?
        if (-1 == empty_slot && POINTER_LIST_SIZE == pointer_list_count) {
            WsbTraceAlways(OLESTR("AddPointer: pointer list is full: %lx\n"),
                    (ULONG)addr);
            status = FALSE;
        } else if (-1 == empty_slot) {
            pointer_list_count++;
        } else {
            i = empty_slot;
        }
    }

    if (status) {
        pointer_list[i].addr = addr;
        pointer_list[i].size = size;
        pointer_list[i].index = index;
        pointer_list[i].filename = filename;
        pointer_list[i].linenum = linenum;
        pointer_data[POINTER_DATA_CURRENT].count++;
        pointer_data[POINTER_DATA_CURRENT].size += size;
        if (pointer_data[POINTER_DATA_CURRENT].count > pointer_data[POINTER_DATA_MAX].count) {
            pointer_data[POINTER_DATA_MAX].count = pointer_data[POINTER_DATA_CURRENT].count;
        }
        if (pointer_data[POINTER_DATA_CURRENT].size > pointer_data[POINTER_DATA_MAX].size) {
            pointer_data[POINTER_DATA_MAX].size = pointer_data[POINTER_DATA_CURRENT].size;
        }
        pointer_data[POINTER_DATA_CUMULATIVE].count++;
        pointer_data[POINTER_DATA_CUMULATIVE].size += size;
        pointer_list[i].order = pointer_data[POINTER_DATA_CUMULATIVE].count;
    }

    return(status);
}

//  GuidToObjectName - convert a guid to an object name
static OLECHAR* GuidToObjectName(const GUID& guid)
{
    HRESULT           hr = S_OK;
    int               i;
    OLECHAR *         name = NULL;

    try {
        //  Need to do conversions from string to Guid?
        if (NULL == object_name_table[0].pGuid) {
            i = 0;
            while (object_name_table[i].guid_string) {
                GUID * pg = new GUID;

                WsbAffirmHr(WsbGuidFromString(object_name_table[i].guid_string, 
                        pg));
                object_name_table[i].pGuid = pg;
                i++;
            }
        }

        //  See if this Guid is in the name table
        i = 0;
        while (object_name_table[i].guid_string) {
            if (guid == *object_name_table[i].pGuid) {
                name = object_name_table[i].name;
                break;
            }
            i++;
        }
    } WsbCatch(hr);

    return(name);
}

//  SubPointer - remove a pointer from the pointer list
//    Return FALSE on failure (pointer is not in list or index doesn't match)
static BOOL SubPointer(const void* addr, int index)
{
    int    i;
    BOOL   status = TRUE;

    for (i = 0; i < pointer_list_count; i++) {
        if (addr == pointer_list[i].addr) {
            break;
        }
    }

    if (i == pointer_list_count) {
        WsbTraceAlways(OLESTR("SubPointer: pointer not found in list: %lx\n"),
                (ULONG)addr);
        status = FALSE;
    } else if (index != pointer_list[i].index) {
        WsbTraceAlways(OLESTR("SubPointer: type index doesn't match for pointer: %lx\n"),
                 (ULONG)addr);
        WsbTraceAlways(OLESTR(", original type index = %d, new type index = %d\n"),
                pointer_list[i].index, index);
        status = FALSE;
    }

    if (status) {
        pointer_list[i].addr = NULL;
        pointer_data[POINTER_DATA_CURRENT].count--;
        pointer_data[POINTER_DATA_CURRENT].size -= pointer_list[i].size;
    }

    return(status);
}



HRESULT WsbObjectAdd(
    const GUID &   guid,
    const void *   addr
)
/*++

Routine Description:

    Add another object to the object table

Arguments:

  guid       - Guid for the object type

  addr       - Memory address of object

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

#if defined(CRT_DEBUG_MEMORY)
    //  Set CRT debug flag
    static BOOL first = TRUE;
    if (first) {
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );

        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

        // Set the new state for the flag
        _CrtSetDbgFlag( tmpFlag );  
    }
#endif

    try {
        int  i;

        //  Reserve the first entry for non-objects and table overflow
        if (0 == object_table_count) {
            object_table[0].guid = GUID_NULL;
            object_table[0].count = 0;
            object_table[0].total_count = 0;
            object_table[0].max_count = 0;
            object_table_count = 1;
        }

        //  Check in object type is already in table
        for (i = 0; i < object_table_count; i++) {
            if (guid == object_table[i].guid) break;
        }
        
        //  Add a new entry if not (and there is room)
        if (i == object_table_count && i < OBJECT_TABLE_SIZE) {
        // WsbTraceAlways(OLESTR("WsbObjectAdd: new object, guid = %ls\n"),
        //    WsbGuidAsString(guid));
#if defined(CRT_DEBUG_MEMORY)
        WsbTraceAlways(OLESTR("WsbObjectAdd: _CrtCheckMemory = %ls\n"),
            WsbBoolAsString(_CrtCheckMemory()));
#endif
            object_table[i].guid = guid;
            object_table[i].count = 0;
            object_table[i].total_count = 0;
            object_table[i].max_count = 0;
            object_table_count++;
        } else if (OBJECT_TABLE_SIZE == i) {
            //  Use the first entry for everything else
            i = 0;
        }
        object_table[i].count++;
        object_table[i].total_count++;
        if (object_table[i].count > object_table[i].max_count) {
            object_table[i].max_count = object_table[i].count;
        }

        //  Add to pointer list
        AddPointer(addr, 0, i, NULL, 0);

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbObjectSub(
    const GUID &   guid,
    const void *   addr
)
/*++

Routine Description:

    Subtract an object from the object table

Arguments:

  guid       - Guid for the object type

  addr       - Memory address of object

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

    try {
        int  i;

        //  Find the object type in table
        for (i = 0; i < object_table_count; i++) {
            if (guid == object_table[i].guid) {
                //  Allow count to go negative since this could indicate a problem
                object_table[i].count--;

                //  Remove from pointer list
                SubPointer(addr, i);
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbObjectTracePointers(
    ULONG flags
)
/*++

Routine Description:

    Dump the pointer list information to the trace file.

Arguments:

  flags  - WSB_OTP_ flags 

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

    try {
        int   i;
        OLECHAR string[300];

        //  Dump the current sequence number
        if (flags & WSB_OTP_SEQUENCE) {
            WsbTraceAlways(OLESTR("WsbObjectTracePointers: current sequence number = %ld\n"),
                    pointer_data[POINTER_DATA_CUMULATIVE].count);
        }

        //  Dump statistics
        if (flags & WSB_OTP_STATISTICS) {
            WsbTraceAlways(OLESTR("WsbObjectTracePointers: count, size\n"));
            WsbTraceAlways(OLESTR("  Current    %8ld %12ls\n"), 
                    pointer_data[POINTER_DATA_CURRENT].count,
                    WsbLonglongAsString(pointer_data[POINTER_DATA_CURRENT].size));
            WsbTraceAlways(OLESTR("  Maximum    %8ld %12ls\n"), 
                    pointer_data[POINTER_DATA_MAX].count,
                    WsbLonglongAsString(pointer_data[POINTER_DATA_MAX].size));
            WsbTraceAlways(OLESTR("  Cumulative %8ld %12ls\n"), 
                    pointer_data[POINTER_DATA_CUMULATIVE].count,
                    WsbLonglongAsString(pointer_data[POINTER_DATA_CUMULATIVE].size));
        }

        //  Dump non-NULL pointers
        if (flags & WSB_OTP_ALLOCATED) {
            WsbTraceAlways(OLESTR("WsbObjectTracePointers: allocated memory list (addr, size, order, name/GUID/file):\n"));
            for (i = 0; i < pointer_list_count; i++) {
                if (pointer_list[i].addr) {
                    GUID         guid = GUID_NULL;
                    int          index;
                    OLECHAR *    name = NULL;
                    OLECHAR *    pstr = NULL;

                    index = pointer_list[i].index;
                    if (index > 0 && index < object_table_count) {
                        guid = object_table[index].guid;
                        name = GuidToObjectName(guid);
                    }
                    if (0 == index) {
                        wsprintf(string, OLESTR("%hs(%d)"), pointer_list[i].filename,
                                pointer_list[i].linenum);
                        pstr = string;
                    } else if (name) {
                        pstr = name;
                    } else {
                        wcscpy(string, WsbGuidAsString(guid));
                        pstr = string;
                    }
                    WsbTraceAlways(OLESTR("  %8lx %8ld %8ld %ls\n"), pointer_list[i].addr,
                            pointer_list[i].size, pointer_list[i].order, pstr);
                }
            }
        }

#if defined(CRT_DEBUG_MEMORY)
        WsbTraceAlways(OLESTR("WsbObjectTrace: calling _CrtMemCheckpoint\n"));
        _CrtMemCheckpoint(&CrtMemState);
        WsbTraceAlways(OLESTR("WsbObjectTrace: MemState.lHighWaterCount = %ld, TotalCount = %ld\n"),
                        CrtMemState.lHighWaterCount, CrtMemState.lTotalCount);
        WsbTraceAlways(OLESTR("WsbObjectTrace: MemState.blocks count & size\n"));
        WsbTraceAlways(OLESTR("  FREE   %4ld %6ld\n"), CrtMemState.lCounts[_FREE_BLOCK],
                CrtMemState.lSizes[_FREE_BLOCK]);
        WsbTraceAlways(OLESTR("  NORMAL %4ld %6ld\n"), CrtMemState.lCounts[_NORMAL_BLOCK],
                CrtMemState.lSizes[_NORMAL_BLOCK]);
        WsbTraceAlways(OLESTR("  CRT    %4ld %6ld\n"), CrtMemState.lCounts[_CRT_BLOCK],
                CrtMemState.lSizes[_CRT_BLOCK]);
        WsbTraceAlways(OLESTR("  IGNORE %4ld %6ld\n"), CrtMemState.lCounts[_IGNORE_BLOCK],
                CrtMemState.lSizes[_IGNORE_BLOCK]);
        WsbTraceAlways(OLESTR("  CLIENT %4ld %6ld\n"), CrtMemState.lCounts[_CLIENT_BLOCK],
                CrtMemState.lSizes[_CLIENT_BLOCK]);

//        WsbTraceAlways(OLESTR("WsbObjectTrace: calling _CrtMemDumpStatistics\n"));
//        _CrtMemDumpStatistics(&CrtMemState);
//        _CrtDumpMemoryLeaks();
#endif

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbObjectTraceTypes(
    void
)
/*++

Routine Description:

    Dump the object table information to the trace file.

Arguments:

  None.

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

    try {
        int  i;

        WsbTraceAlways(OLESTR("WsbObjectTraceTypes: object table (GUID, total count, max count, current count, name):\n"));
        //  Find the object type in table
        for (i = 0; i < object_table_count; i++) {
            OLECHAR *    name;

            name = GuidToObjectName(object_table[i].guid);
            WsbTraceAlways(OLESTR("  %ls %6ld %5ld %5ld  %ls\n"), WsbGuidAsString(object_table[i].guid),
                    object_table[i].total_count, object_table[i].max_count, 
                    object_table[i].count, (name ? name : OLESTR("")));
        }

    } WsbCatch(hr);

    return(hr);
}


LPVOID WsbMemAlloc(ULONG cb, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for CoTaskAlloc.

--*/
{
    LPVOID p;

    p = CoTaskMemAlloc(cb);
    if (p) {
        AddPointer(p, cb, 0, filename, linenum);
    }
    return(p);
}


void   WsbMemFree(LPVOID pv, const char *, int)
/*++

Routine Description:

    Debug tracking replacement for CoTaskFree.

--*/
{
    if (pv) {
        SubPointer(pv, 0);
    }
    CoTaskMemFree(pv);
}


LPVOID WsbMemRealloc(LPVOID pv, ULONG cb, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for CoTaskRealloc.

--*/
{
    LPVOID p;

    p = CoTaskMemRealloc(pv, cb);
    if (p) {
        if (pv) {
            SubPointer(pv, 0);
        }
        AddPointer(p, cb, 0, filename, linenum);
    }
    return(p);
}


BSTR    WsbSysAllocString(const OLECHAR FAR * sz, 
        const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysAllocString

--*/
{
    BSTR b;

    b = SysAllocString(sz);
    if (b) {
        AddPointer(b, SysStringByteLen(b), 0, filename, linenum);
    }
    return(b);
}


BSTR    WsbSysAllocStringLen(const OLECHAR FAR * sz, 
        unsigned int cc, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysAllocStringLen

--*/
{
    BSTR b;

    b = SysAllocStringLen(sz, cc);
    if (b) {
        AddPointer(b, SysStringByteLen(b), 0, filename, linenum);
    }
    return(b);
}


void WsbSysFreeString(BSTR bs, const char *, int)
/*++

Routine Description:

    Debug tracking replacement for SysFreeString

--*/
{
    if (bs) {
        SubPointer(bs, 0);
    }
    SysFreeString(bs);
}


HRESULT WsbSysReallocString(BSTR FAR * pb, const OLECHAR FAR * sz, 
        const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysReallocString

--*/
{
    HRESULT hr;

    if (*pb) {
        SubPointer(*pb, 0);
    }
    hr = SysReAllocString(pb, sz);
    if (*pb) {
        AddPointer(*pb, SysStringByteLen(*pb), 0, filename, linenum);
    }
    return(hr);
}


HRESULT WsbSysReallocStringLen(BSTR FAR * pb, 
        const OLECHAR FAR * sz, unsigned int cc, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysStringLen

--*/
{
    HRESULT hr;

    if (*pb) {
        SubPointer(*pb, 0);
    }
    hr = SysReAllocStringLen(pb, sz, cc);
    if (*pb) {
        AddPointer(*pb, SysStringByteLen(*pb), 0, filename, linenum);
    }
    return(hr);
}

#endif // WSB_TRACK_MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbtrc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbtrc.cpp

Abstract:

    This component is a trace object.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

    Brian Dodd      [brian]      09-May-1996  - Added event logging

--*/

#include "stdafx.h"
#include "time.h"

#undef WsbThrow
#define WsbThrow(hr)                    throw(hr)
#include "wsbtrc.h"

// Local data
static WCHAR message[1024];  // Space for formatting a message


HRESULT 
CWsbTrace::FinalConstruct( 
    void 
    )
/*++

Implements:

    IWsbTrace::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
    try  {
        // Set up global values     
        g_pWsbTrace = 0;
        g_WsbTraceModules = WSB_TRACE_BIT_NONE;

        // Establish Base object
        WsbAffirmHr(CComObjectRoot::FinalConstruct() );

        // Initialize member data
        m_TraceOn = FALSE;
        m_TraceSettings = WSB_TRACE_BIT_NONE;
        m_TraceFileName = OLESTR("");
        m_TraceOutput = WSB_TRACE_OUT_NONE;
        m_CommitEachEntry = FALSE;
        m_TimeStamp = FALSE;
        m_TraceCount = FALSE;
        m_TraceThreadId = FALSE;
        m_TraceFilePointer = INVALID_HANDLE_VALUE;
        m_WrapMode = FALSE;
        m_RegistrySetting = OLESTR("");
        m_TraceEntryExit = g_WsbTraceEntryExit;
        m_LogLevel = g_WsbLogLevel;
        m_TraceFileCopyName = OLESTR("");
        m_TraceMultipleFilePattern = OLESTR("");
        m_TraceMultipleFileCount = 0;
        m_TraceCountHandle = NULL;
        m_pTraceCountGlobal = NULL; 
    
    } WsbCatch( hr );
    
    
    return( hr );
}       


void 
CWsbTrace::FinalRelease( 
    void 
    )
/*++

Implements:

    IWsbTrace::FinalRelease

--*/
{
    HRESULT     hr = S_OK;
    
    // Stop Trace
    StopTrace();

    // Free base class    
    //
    CComObjectRoot::FinalRelease( );
}       


HRESULT 
CWsbTrace::StartTrace( 
    void 
    )
/*++

Implements:

  IWsbTrace::StartTrace

--*/
{
    HRESULT     hr = S_OK;

    try  {

        if (g_pWsbTrace == 0)  {
            //
            // Set global variable for quick checking
            //
            WsbAffirmHr(((IUnknown*)(IWsbTrace *)this)->QueryInterface(IID_IWsbTrace, (void**) &g_pWsbTrace));
            //
            // We don't want the reference count bumped for this global so release it here.
            g_pWsbTrace->Release();
        }


        //
        // Get hold of the trace count
        //
        if (m_pTraceCountGlobal == NULL) {

            m_pTraceCountGlobal = &g_WsbTraceCount;

            m_TraceCountHandle = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                   NULL,
                                                   PAGE_READWRITE,
                                                   0,
                                                   sizeof(ULONG),
                                                   L"Global\\RemoteStorageTraceCountPrivate"
                                                  );
           if (m_TraceCountHandle == NULL) {
                 if (GetLastError() == ERROR_ALREADY_EXISTS) {
                     //  
                     // Already open, just get hold of the mapping
                     //
                    m_TraceCountHandle = OpenFileMapping(FILE_MAP_WRITE,
                                                         FALSE,
                                                         L"Global\\RemoteStorageTraceCountPrivate");
                 }  else {
                   swprintf( message, OLESTR("CWsbTrace::StartTrace: CreateFileMapping failed %d\n"),   GetLastError());
                    g_pWsbTrace->Print(message);
                }
           }           

           if (m_TraceCountHandle != NULL) {
                m_pTraceCountGlobal = (PLONG) MapViewOfFile(m_TraceCountHandle,
                                                            FILE_MAP_WRITE,
                                                            0,
                                                            0,
                                                            sizeof(ULONG));
                if (!m_pTraceCountGlobal) {
                     CloseHandle(m_TraceCountHandle);
                     m_pTraceCountGlobal = &g_WsbTraceCount;
                     m_TraceCountHandle = NULL;
                     swprintf( message, OLESTR("CWsbTrace::StartTrace: MapViewOfFile failed %d\n"),   GetLastError());
                     g_pWsbTrace->Print(message);
                }
           }  
        }
        
        //
        // Set local variable to remember the state 
        //
        m_TraceOn = TRUE;

        //
        //  If there is a file name defined and file tracing is on
        //  Create/open the trace file.
        //
        try  {
            
            if ((m_TraceOutput & WSB_TRACE_OUT_FILE)  &&
                    (wcslen(m_TraceFileName) != 0) ) {
                DWORD  attributes;
                DWORD  bytesReturned;
                USHORT inBuffer = COMPRESSION_FORMAT_DEFAULT;
                DWORD  last_error = 0;

                //
                // If the main file is open, close it.
                //
                if (INVALID_HANDLE_VALUE != m_TraceFilePointer)  {
                     CloseHandle(m_TraceFilePointer);
                     m_TraceFilePointer = INVALID_HANDLE_VALUE;
                }

                //  Adjust the file name (for multiple trace files)
                AdjustFileNames();

                //
                // If there is a copy file specified, copy to it
                //
                if (m_TraceOutput & WSB_TRACE_OUT_FILE_COPY) {
                    if (!MoveFileEx(m_TraceFileName, m_TraceFileCopyName, 
                        (MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))) {
                        
                        // If copy fails, keep going
                        last_error = GetLastError();
                        swprintf( message, OLESTR("CWsbTrace::StartTrace: MoveFileEx failed:%ld\r\n"), 
                                last_error);
                        g_pWsbTrace->Print(message);
                    }
                }

                //  Open/create the trace file                
                if (m_CommitEachEntry) {
                    attributes = FILE_FLAG_WRITE_THROUGH;
                } else {
                    attributes = FILE_ATTRIBUTE_NORMAL;
                }
                m_TraceFilePointer = CreateFile(m_TraceFileName, 
                        GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                        CREATE_ALWAYS, attributes, NULL);
                if (INVALID_HANDLE_VALUE == m_TraceFilePointer) {
                    last_error = GetLastError();
                    swprintf( message, OLESTR("CWsbTrace::StartTrace: CreateFile failed:%ld\r\n"), 
                            last_error);
                    g_pWsbTrace->Print(message);
                    WsbThrow(E_FAIL);
                }

                //  Make the trace file compressed (if possible)
                if (0 == DeviceIoControl(m_TraceFilePointer, FSCTL_SET_COMPRESSION, 
                        &inBuffer, sizeof(inBuffer), 0, 0, &bytesReturned, 0)) {
                    // Failed to make file compressed -- not a fatal error
                    last_error = GetLastError();
                    swprintf( message, 
                            OLESTR("CWsbTrace::StartTrace: DeviceIoControl(COMPRESSION) failed:%ld\r\n"), 
                            last_error);
                    g_pWsbTrace->Print(message);
                }
            }
        } WsbCatch( hr );

        swprintf( message, OLESTR("Trace Started (%d-%ls)\r\n"), 
                VER_PRODUCTBUILD, RsBuildVersionAsString(RS_BUILD_VERSION));
        WsbAffirmHr(g_pWsbTrace->Print(message));
        
    }  WsbCatch (hr); 
    
    
    return(hr);
}       
    

HRESULT  
CWsbTrace::StopTrace( 
    void 
    )
/*++

Implements:

  IWsbTrace::StopTrace

--*/
{
    HRESULT     hr = S_OK;

    try  {
        
        //
        // Set global variable for quick checking
        //          
        if (g_pWsbTrace != 0) {
            g_pWsbTrace->Print(OLESTR("Trace Stopped\r\n"));
            //
            // Don't release here.
            //
            //g_pWsbTrace->Release();
            g_pWsbTrace = 0;
        }
        
        //
        // Set local variable to remember the state 
        //
        m_TraceOn = FALSE;
        
        //
        // Close the file handle
        //
        if (m_TraceFilePointer != INVALID_HANDLE_VALUE) {
            CloseHandle(m_TraceFilePointer);
            m_TraceFilePointer = INVALID_HANDLE_VALUE;
        }

        if (m_TraceCountHandle != NULL) {
            BOOL b;

            CloseHandle(m_TraceCountHandle);
            m_TraceCountHandle = NULL;
            //
            // We should have a macro to assert without 
            // throwing HR's
            // After one is added, a good assert here would be:
            // ASSERT(m_pTraceCountGlobal != NULL);
            //
            b = UnmapViewOfFile(m_pTraceCountGlobal);
            //
            // And another here would be:
            // ASSERT(b);
            //
            m_pTraceCountGlobal = NULL;
        }
        
    }  WsbCatch (hr); 

    return(hr);
}       


HRESULT 
CWsbTrace::AdjustFileNames( 
    void
    )
/*++

Routine Description:

    Make sure trace flags are set correctly and parse file names if we
    haven't already.  If we're doing multiple trace files (instead of 
    wrapping), adjust the trace and copy file names.

Arguments:

    None.

Return Value:

    S_OK - Success

--*/
{
    HRESULT         hr = S_OK;

    try  {
        //  If we haven't yet, parse file names & set flags.
        if (!(m_TraceOutput & WSB_TRACE_OUT_FLAGS_SET)) {
            OLECHAR       *pc_original;
            OLECHAR       *pc_bslash;
            CWsbStringPtr str_temp(m_TraceFileName);

            //  Reset flags & file info
            m_TraceOutput &= ~WSB_TRACE_OUT_MULTIPLE_FILES;
            m_TraceOutput &= ~WSB_TRACE_OUT_FILE_COPY;
            m_TraceFileDir = "";
            m_TraceMultipleFilePattern = "";
            m_TraceFileCopyDir = "";

            //  Parse the trace file name.  One or more '*'s means we should 
            //  do multiple trace files.  The number of '*'s indicates 
            //  how many digits to use for the file count.  Separate the
            //  directory from the file name.
            pc_bslash = wcsrchr(str_temp, OLECHAR('\\'));

            if (pc_bslash) {

                *pc_bslash = OLECHAR('\0');

                //  Get the trace directory
                m_TraceFileDir = str_temp;
                m_TraceFileDir.Append("\\");

                //  Point to the file name (which may contain a pattern)
                pc_bslash++;
            } else {
                //  No directory specified
                pc_bslash = static_cast<OLECHAR *>(str_temp);
            }

            //  Get the file name
            m_TraceMultipleFilePattern = pc_bslash;

            //  Look for '*'s in the file name
            pc_original = wcschr(pc_bslash, OLECHAR('*'));

            //  Convert a file pattern for use in sprintf
            if (pc_original) {
                OLECHAR       format[16];
                OLECHAR       *pc_copy;
                int           star_count = 0;

                //  Count *'s
                while (OLECHAR('*') == *pc_original) {
                    star_count++;
                    pc_original++;
                }

                //  Create file name pattern: replace '*'s with printf
                //  type format specification (e.g. "%3.3d")
                pc_copy = wcschr(m_TraceMultipleFilePattern, OLECHAR('*'));
                WsbAffirm(pc_copy, E_FAIL);
                *pc_copy = OLECHAR('\0');

                swprintf(format, OLESTR("%%%d.%dd"), star_count, star_count);
                m_TraceMultipleFilePattern.Append(format);
                m_TraceMultipleFilePattern.Append(pc_original);

                //  Set multiple flag
                m_TraceOutput |= WSB_TRACE_OUT_MULTIPLE_FILES;
            }

            //  If we're doing file copies, set the flag.
            if (wcslen(m_TraceFileCopyName)) {
                m_TraceOutput |= WSB_TRACE_OUT_FILE_COPY;

                //  Get the copy directory
                str_temp = m_TraceFileCopyName;
                pc_bslash = wcsrchr(str_temp, OLECHAR('\\'));
                if (pc_bslash) {
                    *pc_bslash = OLECHAR('\0');
                    m_TraceFileCopyDir = str_temp;
                    m_TraceFileCopyDir.Append("\\");

                    //  Point to the copy file name
                    pc_bslash++;
                } else {
                    pc_bslash = static_cast<OLECHAR *>(str_temp);
                }

                //  If we're not doing multiple trace files, make sure
                //  we have a copy file name.  (If we are doing multiple
                //  trace files, the copy file name is create below.)
                if (!(m_TraceOutput & WSB_TRACE_OUT_MULTIPLE_FILES) &&
                        0 == wcslen(pc_bslash)) {
                    m_TraceFileCopyName = m_TraceFileCopyDir;
                    m_TraceFileCopyName.Append(m_TraceMultipleFilePattern);
                }
            }

            //  Increment file count and indicate flags are set
            m_TraceMultipleFileCount++;
            m_TraceOutput |= WSB_TRACE_OUT_FLAGS_SET;
        }

        //  If we have a file pattern, create the new actual file names
        if (m_TraceOutput & WSB_TRACE_OUT_MULTIPLE_FILES) {
            OLECHAR newName[256];

            //  Create the file name from the pattern and the file count
            wsprintf(newName, m_TraceMultipleFilePattern, 
                    m_TraceMultipleFileCount);

            //  Combine trace directory and file name
            m_TraceFileName = m_TraceFileDir;
            m_TraceFileName.Append(newName);

            //  Create a new trace file copy name also
            if (m_TraceOutput & WSB_TRACE_OUT_FILE_COPY) {
                m_TraceFileCopyName = m_TraceFileCopyDir;
                m_TraceFileCopyName.Append(newName);
            }
        }    
    } WsbCatch( hr );
    
    return( hr );
}       
    

HRESULT  
CWsbTrace::SetTraceOn(  
    LONGLONG traceElement 
    )
/*++

Implements:

  IWsbTrace::SetTraceOn

--*/
{
    HRESULT     hr = S_OK;
    
    //
    // Turn on the global trace bits for easy checking
    //
    g_WsbTraceModules = g_WsbTraceModules | traceElement;
    
    //
    // Turn on the local trace bits
    //
    m_TraceSettings = g_WsbTraceModules;
    
    return( hr );
}       
    

HRESULT  
CWsbTrace::SetTraceOff( 
    LONGLONG traceElement 
    )
/*++

Implements:

  IWsbTrace::SetTraceOff

--*/
{
    HRESULT     hr = S_OK;
    //
    // Turn off the global trace bits for easy checking
    //
    g_WsbTraceModules = g_WsbTraceModules & (~traceElement);
    
    //
    // Turn on the local trace bits
    //
    m_TraceSettings = g_WsbTraceModules;
    
    return( hr );
}       

HRESULT  
CWsbTrace::GetTraceSettings( 
    LONGLONG *pTraceElements 
    )
/*++

Implements:

  IWsbTrace::GetTraceSettings

--*/
{
    HRESULT     hr = S_OK;
    
    try 
    {
        WsbAffirm(pTraceElements != 0, E_POINTER);
        *pTraceElements = g_WsbTraceModules;
        
    } WsbCatch( hr );
    
    return( hr );
}       
    

HRESULT  
CWsbTrace::GetTraceSetting( 
    LONGLONG traceElement, 
    BOOL     *pOn )
/*++

Implements:

  IWsbTrace::GetTraceSetting

--*/
{
    HRESULT     hr = S_OK;
    
    //
    // Find the bit and return TRUE if it is set,
    // otherwise return FALSE
    //
    try 
    {
        WsbAffirm(pOn != 0, E_POINTER);
        *pOn = FALSE;
        if ((g_WsbTraceModules & traceElement) == traceElement)  {
            *pOn = TRUE;
        }
    } WsbCatch( hr );
    
    return( hr );
}       

HRESULT  
CWsbTrace::DirectOutput( 
    ULONG output 
    )
/*++

Implements:

  IWsbTrace::DirectOutput

--*/
{
    HRESULT     hr = S_OK;
    
    m_TraceOutput = output;
    
    return( hr );
}       

HRESULT  
CWsbTrace::SetTraceFileControls( 
    OLECHAR     *pTraceFileName,
    BOOL        commitEachEntry,
    LONGLONG    maxTraceFileSize,
    OLECHAR     *pTraceFileCopyName 
    )
/*++

Implements:

  IWsbTrace::SetTraceFileControls

--*/
{
    HRESULT     hr = S_OK;
    try  {
        if (pTraceFileName)  {
            m_TraceFileName = pTraceFileName;
            m_TraceOutput &= ~WSB_TRACE_OUT_FLAGS_SET;
        }
        m_CommitEachEntry = commitEachEntry;
        m_MaxTraceFileSize = maxTraceFileSize;
        if (pTraceFileCopyName)  {
            m_TraceFileCopyName = pTraceFileCopyName;
            m_TraceOutput &= ~WSB_TRACE_OUT_FLAGS_SET;
        }
    
    } WsbCatch( hr );
    
    
    return( hr );
}       


HRESULT  
CWsbTrace::GetTraceFileControls( 
    OLECHAR     **ppTraceFileName,
    BOOL        *pCommitEachEntry,
    LONGLONG    *pMaxTraceFileSize,
    OLECHAR     **ppTraceFileCopyName
    )
/*++

Implements:

  IWsbTrace::GetTraceFileControls

--*/
{
    HRESULT     hr = S_OK;
    
    try  {
        if (ppTraceFileName) {
            CWsbStringPtr fileName;

            fileName = m_TraceFileName;
            fileName.GiveTo(ppTraceFileName);
        }

        if (pCommitEachEntry) {
            *pCommitEachEntry = m_CommitEachEntry;
        }

        if (pMaxTraceFileSize) {
            *pMaxTraceFileSize = m_MaxTraceFileSize;
        }
        
        if (ppTraceFileCopyName) {
            CWsbStringPtr fileCopyName;

            fileCopyName = m_TraceFileCopyName;
            fileCopyName.GiveTo(ppTraceFileCopyName);
        }
        
    } WsbCatch( hr );
    
    return( hr );
}       


HRESULT 
CWsbTrace::Print( 
    OLECHAR *traceString
    )
/*++

Implements:

  IWsbTrace::Print

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   outString;
    DWORD           threadId;
    OLECHAR         tmpString[50];

    try  {
        //
        // Add the timeStamp if it is requested
        //
        
        if (m_TimeStamp) {
            SYSTEMTIME      stime;

            GetLocalTime(&stime);
            swprintf(tmpString, OLESTR("%2.02u/%2.02u %2.2u:%2.2u:%2.2u.%3.3u "),
                    stime.wMonth, stime.wDay,
                    stime.wHour, stime.wMinute,
                    stime.wSecond, stime.wMilliseconds); 

            outString.Append(tmpString);
            outString.Append(" ");
        }     
        
        //
        // Add the trace count if requested
        //
        if (m_TraceCount) {
            OLECHAR         tmpString[50];

            swprintf(tmpString, OLESTR("%8.8lX"), *(m_pTraceCountGlobal));
            outString.Append(tmpString);
            InterlockedIncrement(m_pTraceCountGlobal);
            outString.Append(" ");
        }    

        //
        // Add the thread ID if requested
        //
        if (m_TraceThreadId) {
            threadId = GetCurrentThreadId();
            if (threadId < 0x0000FFFF) {
                swprintf(tmpString, OLESTR("%4.4lX"), threadId);
            } else  {
                swprintf(tmpString, OLESTR("%8.8lX"), threadId);
            }
            
            outString.Append(tmpString);
            outString.Append(" ");
        }
        
        outString.Append(traceString);
        //
        // Make sure no one else writes when we do
        //               
        Lock();
        try {
            if ((m_TraceOutput & WSB_TRACE_OUT_DEBUG_SCREEN) == WSB_TRACE_OUT_DEBUG_SCREEN)  {
                //
                // Write to debug console
                //
                OutputDebugString(outString);
            }
            if ((m_TraceOutput & WSB_TRACE_OUT_STDOUT) == WSB_TRACE_OUT_STDOUT)  {
                //
                // Write the string to the local console
                //
                wprintf(L"%ls", (WCHAR *) outString);
            }
            if ((m_TraceOutput & WSB_TRACE_OUT_FILE) == WSB_TRACE_OUT_FILE)  {
                //
                // Make sure the file exists, etc. 
                //
                if (m_TraceFilePointer != INVALID_HANDLE_VALUE) {
                    //
                    // Write the string to the trace file
                    //
                    WsbAffirmHr(Write(outString));
                    
                    //
                    // See if we have used our space
                    //
                    WsbAffirmHr(WrapTraceFile());
                }
            }
        } WsbCatch( hr );

        Unlock();
    
    } WsbCatch( hr );
    
    return( hr );
}       


HRESULT 
CWsbTrace::WrapTraceFile( 
    void
    )
/*++

Implements:

  IWsbTrace::WrapTraceFile

--*/
{
    HRESULT         hr = S_OK;
    static BOOL     stopping = FALSE;
    
    try  {
        LARGE_INTEGER offset;

        //
        // Find out where we are writing to the file
        //
        offset.HighPart = 0;
        offset.LowPart = SetFilePointer(m_TraceFilePointer, 0, &offset.HighPart, FILE_CURRENT);
        WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);

        //
        // See if we are past the max size desired
        //
        if (!stopping && offset.QuadPart >= m_MaxTraceFileSize) {

            // If we are doing multiple files, close this one and
            // open a new one
            if (m_TraceOutput & WSB_TRACE_OUT_MULTIPLE_FILES) {
                
                // Close the current trace file
                stopping = TRUE;
                StopTrace();

                // Increment the file count
                m_TraceMultipleFileCount++;

                // Create a new trace file
                StartTrace();
                stopping = FALSE;

            // otherwise go into wrap mode
            } else {
                // We have gone too far so start back at the top and indicating we are wrapping.
                offset.HighPart = 0;
                offset.LowPart = SetFilePointer(m_TraceFilePointer, 0, &offset.HighPart, FILE_BEGIN);
                WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);
                m_WrapMode = TRUE;
            }
        }

        if (m_WrapMode) {
            // Save where we are in the file
            offset.LowPart = SetFilePointer(m_TraceFilePointer, 0, &offset.HighPart, FILE_CURRENT);
            WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);
            
            // Write the wrap line
            WsbAffirmHr(Write(OLESTR("!!! TRACE WRAPPED !!!\r\n")));

            /* Go back to offset before wrap line saved                         */
            offset.LowPart = SetFilePointer(m_TraceFilePointer, offset.LowPart, 
                    &offset.HighPart, FILE_BEGIN);
            WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);
            
        }

    } WsbCatch( hr );
    
    return( hr );
}       

HRESULT  
CWsbTrace::SetOutputFormat( 
    BOOL    timeStamp,
    BOOL    traceCount,
    BOOL    traceThreadId
    )
/*++

Implements:

  IWsbTrace::SetOutputFormat

--*/
{
    HRESULT     hr = S_OK;
    try  {
        m_TimeStamp = timeStamp;
        m_TraceCount = traceCount;
        m_TraceThreadId = traceThreadId;
    
    } WsbCatch( hr );
    
    
    return( hr );
}       

HRESULT  
CWsbTrace::GetOutputFormat( 
    BOOL    *pTimeStamp,
    BOOL    *pTraceCount,
    BOOL    *pTraceThreadId
    )
/*++

Implements:

  IWsbTrace::GetOutputFormat

--*/
{
    HRESULT     hr = S_OK;
    try  {
        WsbAffirm(0 != pTimeStamp, E_POINTER);
        WsbAffirm(0 != pTraceCount, E_POINTER);
        WsbAffirm(0 != pTraceThreadId, E_POINTER);
        *pTimeStamp = m_TimeStamp;
        *pTraceCount = m_TraceCount;
        *pTraceThreadId = m_TraceThreadId;
    } WsbCatch( hr );
    
    
    return( hr );
}       

HRESULT 
CWsbTrace::GetRegistryEntry( 
    OLECHAR **pRegistryEntry 
    )
/*++

Implements:

  IWsbTrace::GetRegistryEntry

--*/
{
    HRESULT     hr = S_OK;

    try  {
        WsbAffirm(0 != pRegistryEntry, E_POINTER);

        CWsbStringPtr   entry;
        entry = m_RegistrySetting;
        WsbAffirmHr(entry.GiveTo(pRegistryEntry));
    } WsbCatch( hr );
    
    
    return( hr );
}       

HRESULT 
CWsbTrace::SetRegistryEntry( 
    OLECHAR *registryEntry 
    )
/*++

Implements:

  IWsbTrace::SetRegistryEntry

--*/
{
    HRESULT     hr = S_OK;

    m_RegistrySetting = registryEntry;
    
    return( hr );
}       

HRESULT 
CWsbTrace::LoadFromRegistry( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadFromRegistry

--*/
{
    HRESULT     hr = S_OK;

    try {
        if (wcslen(m_RegistrySetting) > 0) {
            WsbAffirmHr(WsbEnsureRegistryKeyExists (NULL, m_RegistrySetting));
            WsbAffirmHr(LoadFileSettings());
            WsbAffirmHr(LoadTraceSettings());
            WsbAffirmHr(LoadOutputDestinations());
            WsbAffirmHr(LoadFormat());
            WsbAffirmHr(LoadStart());
        } else  {
         hr = E_FAIL;
        }
    } WsbCatch( hr );

    
    return( hr );
}       


HRESULT 
CWsbTrace::LoadFileSettings( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadFileSettings

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD           sizeGot;
        OLECHAR         dataString[512];
        OLECHAR         *stopString;
        CWsbStringPtr   l_TraceFileName=L"Trace";
        LONGLONG        l_TraceFileSize=0;
        BOOL            l_TraceCommit=FALSE;
        CWsbStringPtr   l_TraceFileCopyName;

        //
        // Get the values
        //
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_NAME,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            l_TraceFileName = dataString;
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_MAX_SIZE,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            l_TraceFileSize = wcstoul( dataString,  &stopString, 10 );
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_COMMIT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            if (0 == wcstoul(dataString,  &stopString, 10)) {
                l_TraceCommit = FALSE;
            } else {
                l_TraceCommit = TRUE;
            }
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_COPY_NAME,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            l_TraceFileCopyName = dataString;
        }
        
        hr = S_OK;
        WsbAffirmHr(SetTraceFileControls(l_TraceFileName, l_TraceCommit, 
                l_TraceFileSize, l_TraceFileCopyName));

    } WsbCatch( hr );

    
    return( hr );
}       

HRESULT 
CWsbTrace::LoadTraceSettings( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadTraceSettings

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD           sizeGot;
        OLECHAR         dataString[100];
        OLECHAR         *stopString;
        BOOL            value = FALSE;
        LONG            number = 0;
        LONGLONG        l_TraceSettings = WSB_TRACE_BIT_NONE;
        BOOL            l_TraceEntryExit = TRUE;
        WORD            w_LogLevel = WSB_LOG_LEVEL_DEFAULT;
        BOOL            b_SnapShotOn = FALSE;
        WORD            w_SnapShotLevel = 0; 
        CWsbStringPtr   p_SnapShotPath = L"SnapShotPath";
        BOOL            b_SnapShotResetTrace = FALSE;
        

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_PLATFORM,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_PLATFORM;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_RMS,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_RMS;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_SEG,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_SEG;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_META,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_META;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMENG,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMENG;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMSERV,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMSERV;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_JOB,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_JOB;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMTSKMGR,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMTSKMGR;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_FSA,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_FSA;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATAMIGRATER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATAMIGRATER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATARECALLER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATARECALLER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATAVERIFIER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATAVERIFIER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_UI,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_UI;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_ENTRY_EXIT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value == FALSE)  {
                l_TraceEntryExit = FALSE;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATAMOVER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATAMOVER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMCONN,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMCONN;
            }
        }
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_IDB,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_IDB;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_COPYMEDIA,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_COPYMEDIA;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_PERSISTENCE,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_PERSISTENCE;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_LEVEL,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            w_LogLevel = (WORD)wcstoul( dataString,  &stopString, 10 ); // No conversion returns zero!
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_ON,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            b_SnapShotOn = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_LEVEL,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            w_SnapShotLevel = (WORD) wcstoul( dataString,  &stopString, 10 );
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_PATH,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            p_SnapShotPath = dataString;
        }
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_RESET_TRACE,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            b_SnapShotResetTrace = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }
        hr = S_OK;
        WsbAffirmHr(SetTraceSettings(l_TraceSettings));
        WsbAffirmHr(SetTraceEntryExit(l_TraceEntryExit));
        WsbAffirmHr(SetLogLevel(w_LogLevel));
        WsbAffirmHr(SetLogSnapShot(b_SnapShotOn, w_SnapShotLevel, 
                                   p_SnapShotPath, b_SnapShotResetTrace ));

    } WsbCatch( hr );

    return( hr );
}       

HRESULT 
CWsbTrace::LoadOutputDestinations( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadOutputDestinations

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        BOOL    value = FALSE;
        ULONG   l_TraceOutput = WSB_TRACE_OUT_NONE;

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TO_STDOUT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceOutput = l_TraceOutput | WSB_TRACE_OUT_STDOUT;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TO_DEBUG,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceOutput = l_TraceOutput | WSB_TRACE_OUT_DEBUG_SCREEN;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TO_FILE,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceOutput = l_TraceOutput | WSB_TRACE_OUT_FILE;
            }

        }

        hr = S_OK;
        WsbAffirmHr(DirectOutput(l_TraceOutput));

    } WsbCatch( hr );

    
    return( hr );
}       

HRESULT 
CWsbTrace::LoadFormat( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadFormat

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        BOOL    countValue = FALSE;
        BOOL    timeValue = FALSE;
        BOOL    threadValue = FALSE;

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_COUNT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            countValue = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TIMESTAMP,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            timeValue = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_THREADID,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            threadValue = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }

        hr = S_OK;
        WsbAffirmHr(SetOutputFormat(timeValue, countValue, threadValue));
    } WsbCatch( hr );

    
    return( hr );
}       

HRESULT 
CWsbTrace::SetTraceEntryExit( 
    BOOL traceEntryExit
    )
/*++

Implements:

  IWsbTrace::SetTraceEntryExit

--*/
{
    HRESULT     hr = S_OK;

    g_WsbTraceEntryExit = traceEntryExit;
    m_TraceEntryExit = traceEntryExit;

    
    return( hr );
}       

HRESULT 
CWsbTrace::GetTraceEntryExit( 
    BOOL *pTraceEntryExit
    )
/*++

Implements:

  IWsbTrace::GetTraceEntryExit

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pTraceEntryExit, E_POINTER);
        *pTraceEntryExit = m_TraceEntryExit;
    } WsbCatch( hr );

    
    return( hr );
}


HRESULT 
CWsbTrace::SetLogLevel( 
    WORD logLevel
    )
/*++

Implements:

  IWsbTrace::SetLogLevel

--*/
{
    HRESULT     hr = S_OK;

    g_WsbLogLevel = logLevel;
    m_LogLevel = logLevel;

    
    return( hr );
}


HRESULT 
CWsbTrace::GetLogLevel( 
    WORD *pLogLevel
    )
/*++

Implements:

  IWsbTrace::GetLogLevel

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pLogLevel, E_POINTER);
        *pLogLevel = m_LogLevel;
    } WsbCatch( hr );

    
    return( hr );
}   


HRESULT 
CWsbTrace::SetLogSnapShot( 
    BOOL            on,
    WORD            level,
    OLECHAR         *snapShotPath,
    BOOL            resetTrace
    )
/*++

Implements:

  IWsbTrace::SetLogSnapShot

--*/
{
    HRESULT     hr = S_OK;

    g_WsbLogSnapShotOn = on;
    g_WsbLogSnapShotLevel = level;
    if (snapShotPath != 0)  {
        wcscpy(g_pWsbLogSnapShotPath, snapShotPath);
    }
    g_WsbLogSnapShotResetTrace = resetTrace;
    
    return( hr );
}


HRESULT 
CWsbTrace::GetLogSnapShot( 
    BOOL            *pOn,
    WORD            *pLevel,
    OLECHAR         **pSnapShotPath,
    BOOL            *pResetTrace
    )
/*++

Implements:

  IWsbTrace::GetLogSnapShot

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pOn, E_POINTER);
        WsbAssert(0 != pLevel, E_POINTER);
        WsbAssert(0 != pSnapShotPath, E_POINTER);
        WsbAssert(0 != pResetTrace, E_POINTER);
        
        *pOn = g_WsbLogSnapShotOn;
        
        CWsbStringPtr path;
        path = g_pWsbLogSnapShotPath;
        path.GiveTo(pSnapShotPath);
        
        *pLevel = g_WsbLogSnapShotLevel;
        *pResetTrace = g_WsbLogSnapShotResetTrace;
        
        
    } WsbCatch( hr );

    
    return( hr );
}   


HRESULT 
CWsbTrace::LoadStart( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadStart

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        BOOL    value = FALSE;

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_ON,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                StartTrace();               
            } else  {
                StopTrace();
            }
        }

        hr = S_OK;
    } WsbCatch( hr );

    
    return( hr );
}       


//  Write - write a WCHAR string to the output file as multibyte chars.
HRESULT 
CWsbTrace::Write( 
    OLECHAR *pString
    )
{
    HRESULT         hr = S_OK;
    const int       safe_size = 1024;
    static char     buf[safe_size + 16];

    try  {
        int nbytes;
        int nchars_todo;
        int nchars_remaining;
        OLECHAR *pSource;
        OLECHAR *pTest;
        BOOL needToAddReturn = FALSE;
        CWsbStringPtr   endOfLine("\r\n");

        //  Get the total number of chars. in the string
        pSource = pString;
        nchars_remaining = wcslen(pSource);
        pTest = (pString + nchars_remaining - 1);
        //
        // Make sure that if this is a terminating line
        // that it is a \r\n termination not just a
        // \n.
        //
        if (*pTest == '\n') {
            pTest--;
            if (*pTest != '\r')  {
                needToAddReturn = TRUE;
                nchars_remaining--;
            }
        }

        //  Loop until all chars. are written
        while (nchars_remaining) {
            DWORD bytesWritten;

            if (nchars_remaining * sizeof(OLECHAR) > safe_size) {
                nchars_todo = safe_size / sizeof(OLECHAR);
            } else {
                nchars_todo = nchars_remaining;
            }

            //  Convert characters from wide to narrow
            do {
                nbytes = wcstombs(buf, pSource, nchars_todo);
                if (nbytes <= 0) {

                    // Hit a bad character; try fewer characters
                    nchars_todo /= 2;
                    if (0 == nchars_todo) {

                        // Skip the next character
                        nchars_todo = 1;
                        nbytes = 1;
                        buf[0] = '?';
                    }
                }
            } while (nbytes <= 0);

            WsbAffirm(WriteFile(m_TraceFilePointer, buf, nbytes, 
                    &bytesWritten, NULL), E_FAIL);
            WsbAffirm(static_cast<int>(bytesWritten) == nbytes, E_FAIL);
            nchars_remaining -= nchars_todo;
            pSource += nchars_todo;
        }
        
        if (needToAddReturn)  {
            DWORD bytesWritten;

            nbytes = wcstombs(buf, (OLECHAR *)endOfLine, 2);
            WsbAffirm(nbytes > 0, E_FAIL);
            WsbAffirm(WriteFile(m_TraceFilePointer, buf, nbytes, 
                    &bytesWritten, NULL), E_FAIL);
            WsbAffirm(static_cast<int>(bytesWritten) == nbytes, E_FAIL);
            
        }
    
    } WsbCatch( hr );
    
    return( hr );
}       


HRESULT  
CWsbTrace::SetTraceSettings( 
    LONGLONG traceElements 
    )
/*++

Implements:

  IWsbTrace::SetTraceSettings

--*/
{
    HRESULT     hr = S_OK;
    
    try 
    {
        
        g_WsbTraceModules = traceElements;
        m_TraceSettings = g_WsbTraceModules;
        
    } WsbCatch( hr );
    
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbtrace.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbTrace.cpp

Abstract:

    These functions are used to provide an ability to trace the flow
    of the application for debugging purposes.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

    Brian Dodd      [brian]      09-May-1996  - Added event logging

--*/

#include "stdafx.h"
#include "stdio.h"
#include "aclapi.h"

#undef WsbThrow
#define WsbThrow(hr)                    throw(hr)

#define WSB_INDENT_STRING       OLESTR("  ")
#define WSB_APP_EVENT_LOG       OLESTR("\\System32\\config\\AppEvent.evt")
#define WSB_APP_EVENT_LOG_BKUP  OLESTR("\\System32\\config\\AppEvent.bkp")
#define WSB_APP_EVENT_LOG_NAME  OLESTR("\\AppEvent.evt")
#define WSB_SYS_EVENT_LOG       OLESTR("\\System32\\config\\SysEvent.evt")
#define WSB_SYS_EVENT_LOG_BKUP  OLESTR("\\System32\\config\\SysEvent.bkp")
#define WSB_SYS_EVENT_LOG_NAME  OLESTR("\\SysEvent.evt")
#define WSB_RS_TRACE_FILES      OLESTR("Trace\\*.*")
#define WSB_RS_TRACE_PATH       OLESTR("Trace\\")

#define BOGUS_TLS_INDEX         0xFFFFFFFF

// Per-thread data:
typedef struct {
    ULONG TraceOffCount;  // Trace only if this is zero
    LONG  IndentLevel;
    char *LogModule;
    DWORD LogModuleLine;
    DWORD LogNTBuild;
    DWORD LogRSBuild;
} THREAD_DATA;

static DWORD TlsIndex = BOGUS_TLS_INDEX; // Per-thread data index

// The globals that control the tracing
LONGLONG            g_WsbTraceModules = WSB_TRACE_BIT_NONE;
IWsbTrace           *g_pWsbTrace = 0;
BOOL                g_WsbTraceEntryExit = TRUE;

// The globals that control the event logging and printing
WORD                g_WsbLogLevel = WSB_LOG_LEVEL_DEFAULT;
BOOL                g_WsbLogSnapShotOn = FALSE;
WORD                g_WsbLogSnapShotLevel = 0;
OLECHAR             g_pWsbLogSnapShotPath[250];
BOOL                g_WsbLogSnapShotResetTrace = FALSE;
WORD                g_WsbPrintLevel = WSB_LOG_LEVEL_DEFAULT;

//
// WsbTraceCount is a running count of the trace output count: normally we
// use the shared count among the processes, but if we can't get access to
// the shared var., we use this
//
LONG g_WsbTraceCount = 0;

// Helper function
static HRESULT OutputTraceString(ULONG indentLevel, OLECHAR* introString, 
        OLECHAR* format, va_list vaList);
static HRESULT GetThreadDataPointer(THREAD_DATA** ppTD);
static void SnapShotTraceAndEvent(  SYSTEMTIME      stime   );



void 
WsbTraceInit( 
    void 
    )

/*++

Routine Description:

    Initialize this trace module

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  Get an index for the thread local storage
    TlsIndex = TlsAlloc();
}


void 
WsbTraceCleanupThread( 
    void 
    )

/*++

Routine Description:

    Cleanup information for this thread (which is going away)

Arguments:

    None.

Return Value:

    None.

--*/
{
    THREAD_DATA* pThreadData = NULL;

    if (BOGUS_TLS_INDEX != TlsIndex) {
        pThreadData = static_cast<THREAD_DATA*>(TlsGetValue(TlsIndex));
        if (pThreadData) {
            WsbFree(pThreadData);
            TlsSetValue(TlsIndex, NULL);
        }
    }
}


void
WsbTraceEnter(
    OLECHAR* methodName,
    OLECHAR* argString,
    ...
    )

/*++

Routine Description:

    This routine prints out trace information indicating that the
    method specified has been entered, and the values of its arguements
    (if supplied).

Arguments:

    methodName  - The name of the method that was entered.

    argString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    OLECHAR         tmpString[WSB_TRACE_BUFF_SIZE];
    va_list         vaList;

    try  {
        THREAD_DATA* pThreadData = NULL;

        WsbAffirmHr(GetThreadDataPointer(&pThreadData));

        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);
        WsbAffirm(0 == pThreadData->TraceOffCount, S_OK);

        // Identify the function.
        swprintf(tmpString, OLESTR("Enter <%ls> :  "), methodName);

        // Format & print out
        va_start(vaList, argString);
        WsbAffirmHr(OutputTraceString(pThreadData->IndentLevel, tmpString,
            argString, vaList));
        va_end(vaList);

        // Increment the indentation level
        pThreadData->IndentLevel++;

    } WsbCatch (hr);
}


void
WsbTraceExit(
    OLECHAR* methodName,
    OLECHAR* argString,
    ...
    )

/*++

Routine Description:

    This routine prints out trace information indicating that the
    method specified has been exitted, and the values it is returning
    (if supplied).

Arguments:

    methodName  - The name of the method that was exitted.

    argString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    OLECHAR         tmpString[WSB_TRACE_BUFF_SIZE];
    va_list         vaList;

    try  {
        THREAD_DATA* pThreadData = NULL;

        WsbAffirmHr(GetThreadDataPointer(&pThreadData));

        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);
        WsbAffirm(0 == pThreadData->TraceOffCount, S_OK);

        // Decrement the indentation level.
        if (pThreadData->IndentLevel > 0) {
            pThreadData->IndentLevel--;
        } else {
            g_pWsbTrace->Print(OLESTR("WARNING: Badly matched TraceIn/TraceOut\r\n"));
        }

        // Identify the function.
        swprintf(tmpString, OLESTR("Exit  <%ls> :  "), methodName);

        // Format & print out
        va_start(vaList, argString);
        WsbAffirmHr(OutputTraceString(pThreadData->IndentLevel, tmpString,
            argString, vaList));
        va_end(vaList);
        
    } WsbCatch( hr );
}


void
WsbTracef(
    OLECHAR* argString,
    ...
    )

/*++

Routine Description:

    This routine prints out trace information from a printf style string.
    A carriage return should be add to the format string if desired.

Arguments:

    argString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    va_list         vaList;

    try  {
        THREAD_DATA* pThreadData = NULL;

        WsbAffirmHr(GetThreadDataPointer(&pThreadData));

        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);
        WsbAffirm(0 == pThreadData->TraceOffCount, S_OK);

        // Format & print out
        va_start(vaList, argString);
        WsbAffirmHr(OutputTraceString(pThreadData->IndentLevel, NULL,
            argString, vaList));
        va_end(vaList);
        
    }  WsbCatch (hr);

}


void
WsbSetEventInfo(
    char *fileName,
    DWORD lineNo,
    DWORD ntBuild,
    DWORD rsBuild 
    )

/*++

Routine Description:

    This routine sets information used in logging events.

Arguments:

    fileName - The name of the module that logged the event.
    lineNo   - The source line number of the statement that logged the event
    ntBuild  - The NT Build version
    rsBuild  - The RS Build version

Return Value:

    None.

Notes:

    ntBuild, and rsBuild are passed in with each call to get the build version for
    the modules actually logging the event.

--*/
{
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        pThreadData->LogModule = fileName;
        pThreadData->LogModuleLine = lineNo;
        pThreadData->LogNTBuild = ntBuild;
        pThreadData->LogRSBuild = rsBuild;
    }
}


void
WsbTraceAndLogEvent(
    DWORD       eventId,
    DWORD       dataSize,
    LPVOID      data,
    ...
    )

/*++

Routine Description:

    This routine writes a message into the system event log.  The message
    is also written to the application trace file.  

Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;

    try  {

        va_list         vaList;

        va_start(vaList, data);
        WsbTraceAndLogEventV( eventId, dataSize, data, &vaList );
        va_end(vaList);

    }
    WsbCatch( hr );

}


void
WsbTraceAndLogEventV(
    DWORD       eventId,
    DWORD       dataSize,
    LPVOID      data,
    va_list *   inserts
    )

/*++

Routine Description:

    This routine writes a message into the system event log.  The message
    is also written to the application trace file.  The file name and line number is appended 
    to the log data, if any.


Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    inserts    - An array of message inserts that are merged with the message description
                   specified by eventId.  The number of inserts must match the number
                   specified by the message description.  The last insert must be NULL,
                   to indicate the end of the insert list.

Return Value:

    None.

--*/
{

    HRESULT         hr = S_OK;
    char            *newData = NULL, *fileName;
    DWORD           newDataSize=0;
    OLECHAR **      logString=0;
    WORD            count=0;
    SYSTEMTIME      stime;


    try  {

        WsbAssertPointer( inserts );

        WORD            logType;
        const OLECHAR * facilityName = 0;
        WORD            category = 0;
        va_list         vaList;
        BOOL            bLog;
        BOOL            bSnapShot;
        THREAD_DATA*    pThreadData = NULL;


        // Get space for the passed in data plus the file and line number.  If we fail to allocate
        // memory for this we just log the data they passed in (without file and line)
        GetThreadDataPointer(&pThreadData);
        if (pThreadData) {
            fileName = strrchr(pThreadData->LogModule, '\\');
        } else {
            fileName = NULL;
        }
        if (fileName) {
            fileName++;     // Point at just the source file name (no path)

            int len = strlen(fileName);

            newData = (char *) malloc(dataSize + len + 128);
            if (newData) {
                if (data) {
                    memcpy(newData, data, dataSize);
                }
                // Align the record data on even 8 byte boundary for viewing
                len = (len>8) ? 16 : 8;
                sprintf(&newData[dataSize], "%-*.*s@%7luNt%6luRs%6.6ls", len,
                        len, fileName, pThreadData->LogModuleLine, pThreadData->LogNTBuild, 
                        RsBuildVersionAsString(pThreadData->LogRSBuild)  );
                newDataSize = dataSize + strlen(&newData[dataSize]);
            }
        }

        //
        // Determine type of event
        //

        switch ( eventId & 0xc0000000 ) {
        case ERROR_SEVERITY_INFORMATIONAL:
            logType = EVENTLOG_INFORMATION_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_INFORMATION) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_INFORMATION) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_WARNING:
            logType = EVENTLOG_WARNING_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_WARNING) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_WARNING) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_ERROR:
            logType = EVENTLOG_ERROR_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_ERROR) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_ERROR) ? TRUE : FALSE;
            break;
        default:
            logType = EVENTLOG_INFORMATION_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_COMMENT) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_COMMENT) ? TRUE : FALSE;
            break;
        }

        WsbAffirm ( bLog, S_OK );

        WsbTracef(OLESTR("\r\n"));
        WsbTracef(OLESTR("!!!!! EVENT !!!!! - File: %hs @ Line: %d (%lu-%ls)\r\n"), 
                (pThreadData ? pThreadData->LogModule : ""), 
                (pThreadData ? pThreadData->LogModuleLine : 0), 
                (pThreadData ? pThreadData->LogNTBuild : 0), 
                RsBuildVersionAsString((pThreadData ? pThreadData->LogRSBuild : 0)) );

        //
        // Determine source facility and category of message
        //

        switch ( HRESULT_FACILITY( eventId ) ) {

        case WSB_FACILITY_PLATFORM:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_PLATFORM;
            break;

        case WSB_FACILITY_RMS:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_RMS;
            break;

        case WSB_FACILITY_HSMENG:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_HSMENG;
            break;

        case WSB_FACILITY_JOB:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_JOB;
            break;

        case WSB_FACILITY_HSMTSKMGR:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_HSMTSKMGR;
            break;

        case WSB_FACILITY_FSA:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_FSA;
            break;

        case WSB_FACILITY_GUI:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_GUI;
            break;

        case WSB_FACILITY_MOVER:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_MOVER;
            break;

        case WSB_FACILITY_LAUNCH:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_LAUNCH;
            break;

        case WSB_FACILITY_USERLINK:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_USERLINK;
            break;

        case WSB_FACILITY_TEST:
            facilityName = WSB_FACILITY_TEST_NAME;
            category = WSB_CATEGORY_TEST;
            break;

        case HRESULT_FACILITY(FACILITY_NT_BIT):
            facilityName = WSB_FACILITY_NTDLL_NAME;
            eventId &= ~FACILITY_NT_BIT;
            break;
            
        default:
            facilityName = WSB_FACILITY_NTDLL_NAME;
            break;
        }

        //
        // Trace the message
        //

        if ( g_pWsbTrace ) {

            if ( facilityName ) {

                OLECHAR * messageText = 0;

                // NOTE: Positional parameters in the inserts are not processed.  These
                //       are done by ReportEvent() only.

                vaList = *inserts;
                HMODULE hModule;

                hModule = LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );
                if (hModule) {
                    FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                   hModule,
                                   eventId,
                                   MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                   (LPTSTR) &messageText,
                                   0,
                                   &vaList );

                    if ( messageText ) {
                        WsbTracef( OLESTR("%ls"), messageText );  // Format messages come with \n
                        LocalFree( messageText );
                     } else {
                        WsbTracef( OLESTR("!!!!! EVENT !!!!! - Message <0x%08lx> could not be translated.\r\n"), eventId );
                     }
                     FreeLibrary(hModule);
                
                } else {
                        WsbTracef( OLESTR("!!!!! EVENT !!!!! - Could not load facility name DLL %ls. \r\n"), facilityName);
                }
           } else {
               WsbTracef( OLESTR("!!!!! EVENT !!!!! - Message File for <0x%08lx> could not be found.\r\n"), eventId );
           }
           if ( data && dataSize > 0 )
               WsbTraceBufferAsBytes( dataSize, data );
        }

        // Prepare arguments for ReportEvent

        // First count the number of arguments
        vaList = *inserts;
        for( count = 0; (va_arg( vaList, OLECHAR *)) != NULL; count++ );

        if ( count ) {
            OLECHAR*        tmpArg;

            // Allocate a array to hold the string arguments.

            //
            // IMPORTANT NOTE:  Don't try anything fancy here.  va_list is different
            //                  on various platforms.  We'll need to build the string
            //                  argument required by ReportEvent (too bad ReportEvent
            //                  doesn't take va_list like FormatMessage does.
            //
            logString = (OLECHAR **)malloc( count*sizeof(OLECHAR *) );
            WsbAffirmAlloc( logString );

            // load in the strings
            vaList = *inserts;
            for( count = 0; (tmpArg = va_arg( vaList, OLECHAR *)) != NULL; count++ ) {
                logString[count] = tmpArg;
            }
        }

        // Get a handle to the event source
        HANDLE hEventSource = RegisterEventSource(NULL, WSB_LOG_SOURCE_NAME );
        
        // Get the time in case we need to snap shot this event's logs and traces
        GetLocalTime(&stime);
        
        if (hEventSource != NULL) {
            // Write to event log
            DWORD recordDataSize = (newData) ? newDataSize : dataSize;
            LPVOID recordData = (newData) ? newData : data;
            
            if ( ReportEvent(hEventSource, logType, category, eventId, NULL, count, recordDataSize, (LPCTSTR *)&logString[0], recordData) ) {
                WsbTracef( OLESTR("!!!!! EVENT !!!!! - Event <0x%08lx> was logged.\r\n"), eventId );
                WsbTracef( OLESTR("\r\n") );
            } else {
                WsbTracef( OLESTR("!!!!! EVENT !!!!! - Event <0x%08lx> could not be logged due to the following error: %ls\r\n"), eventId, WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())) );
                WsbTracef( OLESTR("\r\n") );
            }
            DeregisterEventSource(hEventSource);
        }
        
        try  {
            HRESULT hr2 = S_OK;
            // 
            // See if we are to take a snap shot of the event and trace logs when an event of this level is logged.
            //
            if ( (TRUE == bSnapShot) &&
                 (TRUE == g_WsbLogSnapShotOn) )  {
                    SnapShotTraceAndEvent(stime);
            }
        } WsbCatchAndDo(hr, hr=S_OK; );
        
    } WsbCatch( hr );

    if (newData) {
        free(newData);
    }

    if (logString) {
        free(logString);
    }

}


const OLECHAR*
WsbBoolAsString(
    BOOL boolean
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. TRUE, FALSE) for
    the value of the boolean supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    boolean     - A boolean value.

Return Value:

    A string representation of the value of the boolean.

--*/
{
    return(boolean ? OLESTR("TRUE") : OLESTR("FALSE"));
}


const OLECHAR*
WsbLongAsString(
    LONG inLong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    long supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    long        - A long value

Return Value:

    A string representation of the value of the GUID.

--*/
{
    static OLECHAR  defaultString[40];
    swprintf( defaultString, OLESTR("%ld"), inLong );
    return(defaultString);
}


const OLECHAR*
WsbFiletimeAsString(
    IN BOOL isRelative,
    IN FILETIME time
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    FILETIME supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    isRelatice  - A boolean that indicates whether the time is absolute (e.g 1/1/1987 ...)
                  or relative (e.g. 1 hour).

    time        - A FILETIME.

Return Value:

    A string representation of the value of the FILETIME.

--*/
{
    static OLECHAR  defaultString[80];
    OLECHAR*        tmpString = 0;
    HRESULT         hr;

    hr = WsbFTtoWCS(isRelative, time, &tmpString, sizeof(defaultString));
    if (hr == S_OK) {
        wcscpy(defaultString, tmpString);
    } else {
        wcscpy(defaultString, L"BADFILETIME");
    }
    WsbFree(tmpString);

    return(defaultString);
}


const OLECHAR*
WsbGuidAsString(
    GUID guid
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    GUID supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    guid        - A GUID.

Return Value:

    A string representation of the value of the GUID.

--*/
{
    static OLECHAR  defaultString[40];
    swprintf( defaultString, OLESTR("{%.8x-%.4x-%.4hx-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"),
        guid.Data1, (UINT)guid.Data2, (UINT)guid.Data3,
        (UINT) guid.Data4[0], (UINT) guid.Data4[1], 
        (UINT) guid.Data4[2], (UINT) guid.Data4[3], (UINT) guid.Data4[4], 
        (UINT) guid.Data4[5], (UINT) guid.Data4[6], (UINT) guid.Data4[7]);

    return(defaultString);
}

HRESULT 
WsbSafeGuidAsString(
    GUID guid,
    CWsbStringPtr &strOut
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    GUID supplied.
    
    NOTE: This is a MT-safe version of WsbGuidAsString which doesn't use 
    static memory

Arguments:

    guid        - A GUID.
    strOut      - Output string

Return Value:

    status (S_OK or E_OUTOFMEMORY)

--*/
{
    HRESULT hr = S_OK;

    strOut.Free();

    strOut = guid;
    if ((WCHAR *)strOut == 0)
        hr = E_OUTOFMEMORY;

    return hr;
}


const OLECHAR*
WsbHrAsString(
    HRESULT hr
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. S_OK, E_POINTER) for
    the value of the HRESULT supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    hr      - An HRESULT.

Return Value:

    A string representation of the value of the HRESULT.

--*/
{
    const OLECHAR *returnString = 0;
    const OLECHAR *facilityName = 0;
    const DWORD cSize = 1024;
    DWORD stringSize = (cSize - 20);
    static OLECHAR defaultString[cSize];
    DWORD   lastError;
    
    // Handle a few special cases which are not in the message table resource
    switch ( hr ) {

    case S_OK:
        returnString = OLESTR("Ok");        // This overloads Win32 NO_ERROR.
        break;

    case S_FALSE:
        returnString = OLESTR("False");     // This overloads Win32 ERROR_INVALID_FUNCTION
        break;

    default:
        break;
    }

    if ( 0 == returnString ) {

        returnString = defaultString;

        swprintf( defaultString, OLESTR("0x%08lx"), hr );

        //
        // First, try getting the message from the system 
        //
        if ( 0 == FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 hr,
                                 MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                 defaultString,
                                 stringSize,
                                 NULL ) ) {

            lastError = GetLastError();     // For debugging

            // Next, try the module executing this code.

            if ( 0 == FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                     NULL,
                                     hr,
                                     MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                     defaultString,
                                     stringSize,
                                     NULL ) ) {

                lastError = GetLastError();     // For debugging

                // Finally, try to identify the module based on the facility code

                switch ( HRESULT_FACILITY( hr ) ) {
                case WSB_FACILITY_PLATFORM:
                case WSB_FACILITY_RMS:
                case WSB_FACILITY_HSMENG:
                case WSB_FACILITY_JOB:
                case WSB_FACILITY_HSMTSKMGR:
                case WSB_FACILITY_FSA:
                case WSB_FACILITY_GUI:
                case WSB_FACILITY_MOVER:
                case WSB_FACILITY_LAUNCH:
                case WSB_FACILITY_USERLINK:
                    facilityName = WSB_FACILITY_PLATFORM_NAME;
                    break;

                case WSB_FACILITY_TEST:
                    facilityName = WSB_FACILITY_TEST_NAME;
                    break;

                case HRESULT_FACILITY(FACILITY_NT_BIT):
                    facilityName = WSB_FACILITY_NTDLL_NAME;
                    hr &= ~FACILITY_NT_BIT;
                    break;

                default:
                    facilityName = WSB_FACILITY_NTDLL_NAME;
                    break;
                }

                if ( facilityName ) {
                    HMODULE hModule;

                    hModule = LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );
                    if (hModule) {
                        FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                       hModule,
                                       hr,
                                       MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                       defaultString,
                                       stringSize,
                                       NULL );
                        FreeLibrary(hModule);
                    } else {
                        WsbTracef( OLESTR("!!!!! EVENT !!!!! - Could not load facility name DLL %ls. \r\n"), facilityName);
                    }
                } 
            }
        }

        //
        // remove trailing \r\n ( this makes things nice for tracing and asserts )
        //
        if ( defaultString[ wcslen(defaultString)-1 ] == OLESTR('\n') ) {

            defaultString[ wcslen(defaultString)-1 ] = OLESTR('\0');

            if ( defaultString[ wcslen(defaultString)-1 ] == OLESTR('\r') ) {

                defaultString[ wcslen(defaultString)-1 ] = OLESTR('\0');
                swprintf( &defaultString[ wcslen(defaultString) ], OLESTR(" (0x%08lx)"), hr );

            }
        }
    }

    return ( returnString );
}


const OLECHAR*
WsbLonglongAsString(
    LONGLONG llong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    LONGLONG supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    llong - A LONGLONG value.

Return Value:

    A string representation of the value.

--*/
{
    static OLECHAR  defaultString[128];
    OLECHAR* ptr = &defaultString[0];
    
    WsbLLtoWCS(llong, &ptr, 128);
    return(defaultString);
}



const OLECHAR*
WsbStringAsString(
    OLECHAR* pStr
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    String supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    pStr - A string value.

Return Value:

    A string representation of the value.

--*/
{
    OLECHAR*        returnString;

    if (0 == pStr) {
        returnString = OLESTR("NULL");
    } else {
        returnString = pStr;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToBoolAsString(
    BOOL* pBool
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a BOOL supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pBool       - A pointer to a BOOL or NULL.

Return Value:

    A string representation of the value of the BOOL or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pBool) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbBoolAsString(*pBool);
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToFiletimeAsString(
    IN BOOL isRelative,
    IN FILETIME *pTime
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    FILETIME supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    iselatice  - A boolean that indicates whether the time is absolute (e.g 1/1/1987 ...)
                  or relative (e.g. 1 hour).

    pTime       - A pointer to a FILETIME.

Return Value:

    A string representation of the value of the FILETIME.

--*/
{
    OLECHAR*        returnString;

    if (0 == pTime) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbFiletimeAsString(isRelative, *pTime);
    }

    return(returnString);
}

const OLECHAR*
WsbPtrToGuidAsString(
    GUID* pGuid
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a GUID supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pGuid       - A pointer to a GUID or NULL.

Return Value:

    A string representation of the value of the GUID or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pGuid) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbGuidAsString(*pGuid);
    }

    return(returnString);
}

HRESULT 
WsbSafePtrToGuidAsString(
    GUID* pGuid,
    CWsbStringPtr &strOut
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a GUID supplied.
    
    NOTE: This is a MT-safe version of WsbGuidAsString which doesn't use 
    static memory

Arguments:

    pGuid       - A pointer to a GUID or NULL.
    strOut      - Output string

Return Value:

    status (S_OK or E_OUTOFMEMORY)

--*/
{
    HRESULT hr = S_OK;

    if (0 == pGuid) {
        strOut = OLESTR("NULL");
        if ((WCHAR *)strOut == 0)
            hr = E_OUTOFMEMORY;
    } else {
        hr = WsbSafeGuidAsString(*pGuid, strOut);
    }

    return hr;
}


const OLECHAR*
WsbPtrToHrAsString(
    HRESULT * pHr
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a HRESULT supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pHr     - A pointer to an HRESULT.

Return Value:

    A string representation of the value of the HRESULT.


--*/
{
    OLECHAR*        returnString;

    if (0 == pHr) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbHrAsString(*pHr);
    }

    return(returnString);
}

const OLECHAR*
WsbPtrToLonglongAsString(
    LONGLONG* pLlong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a LONGLONG supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pLonglong   - A pointer to a LONGLONG or NULL.

Return Value:

    A string representation of the value of the LONGLONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pLlong) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbLonglongAsString(*pLlong);
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToLongAsString(
    LONG* pLong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a LONG supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pLong       - A pointer to a LONG or NULL.

Return Value:

    A string representation of the value of the LONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pLong) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%ld"), *pLong);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToShortAsString(
    SHORT* pShort
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a SHORT supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pShort      - A pointer to a SHORT or NULL.

Return Value:

    A string representation of the value of the SHORT or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pShort) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%d"), *pShort);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToByteAsString(
    BYTE* pByte
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a BYTE supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pByte       - A pointer to a BYTE or NULL.

Return Value:

    A string representation of the value of the BYTE or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pByte) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%d"), *pByte);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToStringAsString(
    OLECHAR** pString
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a string supplied.
    
    NOTE: This method does not support localization ofthe strings.

Arguments

    pString     - A pointer to a OLECHAR* or NULL.

Return Value:

    The string or "NULL" if the pointer was null.

--*/
{
    OLECHAR*        returnString;

    if( (0 == pString) || (0 == *pString) ) {
        returnString = OLESTR("NULL");
    } else {
        returnString = *pString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToUliAsString(
    ULARGE_INTEGER* pUli
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a ULARGE_INTEGER supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUli        - A pointer to a ULARGE_INTEGER or NULL.

Return Value:

    A string representation of the value of the ULARGE_INTEGER or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pUli) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbLonglongAsString( pUli->QuadPart );
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToUlongAsString(
    ULONG* pUlong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a ULONG supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUlong      - A pointer to a ULONG or NULL.

Return Value:

    A string representation of the value of the ULONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pUlong) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%lu"), *pUlong);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToUshortAsString(
    USHORT* pUshort
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a USHORT supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUshort     - A pointer to a USHORT or NULL.

Return Value:

    A string representation of the value of the USHORT or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pUshort) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%u"), *pUshort);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToPtrAsString(
    void** ppVoid
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a ULONG supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUlong      - A pointer to a ULONG or NULL.

Return Value:

    A string representation of the value of the ULONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == ppVoid) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("0x%p"), *ppVoid);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbAbbreviatePath(
    const OLECHAR* path,
    USHORT   length
    )

/*++

Routine Description:

    This routine condenses a path from it's original length to the requested
    length by chopping out it's middle characters
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    path        - A pointer to the path
    length      - The condensed path length including the \0

Return Value:

    A string representation of the value of the BYTE or "NULL" if the
    pointer was null.  This function also returns "NULL" if the length is less
    than 4 bytes.

--*/
{
    HRESULT                 hr = S_OK;
    OLECHAR*                returnString;
    static CWsbStringPtr    tmpString;

    returnString = OLESTR("ERROR");
    try  {
        //
        // Check to see if we have anything to work with
        //
        if ((0 == path) || (length < 4)) {
            returnString = OLESTR("NULL");
        } else {
            // 
            // Get enough space for the return
            //
            USHORT pathlen;
            pathlen = (USHORT)wcslen(path);
            hr = tmpString.Realloc(length);
            if (S_OK != hr)  {
                returnString = OLESTR("No memory");
                WsbAffirmHr(hr);
            }
            
            if (pathlen < length) {
                swprintf(tmpString, OLESTR("%s"), path);
            } else  {
                USHORT partlength = (USHORT) ( (length - 4) / 2 );
                wcsncpy(tmpString, path, partlength);
                tmpString[(int) partlength] = L'\0';
                wcscat(tmpString, OLESTR("..."));
                wcscat(tmpString, &(path[pathlen - partlength]));
            }
            returnString = tmpString;
        }
    }  WsbCatch(hr);

    return(returnString);
}


void WsbTraceBufferAsBytes(
    DWORD size,
    LPVOID data
    )
/*++

Routine Description:

    This routine traces an arbitrary size buffer of bytes in hex and asci.

    A similar routine could be written trace a buffer in words.

Arguments:

    size        - The size of buffer to trace.
    data        - The data to trace.

Return Value:

    None.

--*/
{
    HRESULT hr = S_OK;

    try {
        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);

        // Make sure we have something to trace
        WsbAssertPointer( data );

        CWsbStringPtr   traceString;
        char            *output;
        unsigned char   *bufferP = (unsigned char *)data;

        // IMPORTANT NOTE: Changing these may mean the last line processing need to be changed.
        char *beginAsci = "   [";
        char *endAsci   = "]";
        char *charFmt   = "%02x";
        char *addFmt    = "%04x:";
        char *between8  = "   ";
        char *between4  = "  ";

        char noPrintChar = 0x2e;

        const int ll = 16; // IMPORTANT NOTE: line length, a multiple of 8 - if this changes, the last line processing needs to be fixed.

        int lineCount = 0;

        output = (char *)malloc( (/*address*/6+/*data*/(ll*3)+/*asci*/4+ll+3/*between*/+7+1)*sizeof(char) );
        WsbAffirmAlloc( output );

        if ( size > 0 ) {
            unsigned long i, ii, j, k;
            long repeat;
            unsigned char c;

            for ( i = 0; i < size; i++ ) {
                if ( (0 == i % ll) && (i != 0) ) {
                    // print asci interpretation
                    sprintf( output, beginAsci );
                    traceString.Append(output);
                    for ( j = 0; j < ll; j++ ) {
                        c = bufferP[i-ll+j];
                        if ( c < ' ' || c > '~' ) {
                            c = noPrintChar;
                        }
                        sprintf( output, "%c", c );
                        traceString.Append(output);
                    }
                    sprintf( output, endAsci );
                    traceString.Append(output);
                    WsbTracef( OLESTR("%ls\n"), (WCHAR *) traceString );
                    lineCount++;
                    // now check if the next line is the same as the one just printed
                    repeat = 0;
                    ii = i;
                    while ( (0 == memcmp( &bufferP[ii-ll], &bufferP[ii], ll )) && (ii+ll < size) ) {
                        repeat++;
                        ii += ll;
                    }
                    if ( repeat > 1 ) {
                        sprintf( output, "        previous line repeats %ld times", repeat);
                        traceString = output;
                        WsbTracef( OLESTR("%ls\n"), (WCHAR *) traceString );
                        lineCount++;
                        i = ii;
                    }
                }
                if ( 0 == i % ll ) {
                    // print address
                    sprintf( output, addFmt, i );
                    traceString = output;
                }

                // add alignment spacing
                if ( (0 == (i + 8) % ll) ) {
                    sprintf( output, between8 );
                    traceString.Append(output);
                }
                else if ( 0 == i % 4 ) {
                    sprintf( output, between4 );
                    traceString.Append(output);
                }
                else {
                    sprintf( output, " " );
                    traceString.Append(output);
                }
                // print byte in hex
                sprintf( output, charFmt, bufferP[i] );
                traceString.Append(output);
            }

            // handle the last line; i allways > 0 here
            // NOTE: This is only good for upto 16 chars per line.
            if ( i % ll ) {
                k = (ll - (i % ll)) * 3 + ( (i % ll) < 5 ? 1 : 0 )+ ( (i % ll) < 9 ? 2 : 0 )+ ( (i % ll) < 13 ? 1 : 0 );
                for ( j = 0; j < k ; j++ ) {
                    sprintf( output, " ");
                    traceString.Append(output);
                }
            }
            k = (i % ll) ? (i % ll) : ll ;
            sprintf( output, beginAsci );
            traceString.Append(output);
            for ( j = 0; j < k; j++ ) {
                c = bufferP[i-k+j];
                if ( c < ' ' || c > '~' ) {
                    c = noPrintChar;
                }
                sprintf( output, "%c", c );
                traceString.Append(output);
            }
            sprintf( output, endAsci); lineCount++;
            traceString.Append(output);
            WsbTracef( OLESTR("%ls\n"), (WCHAR *) traceString );
        }

    }
    WsbCatch( hr );
}


void 
WsbTraceTerminate( 
    void 
    )

/*++

Routine Description:

    Terminate (cleanup) this module because the process is ending

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (BOGUS_TLS_INDEX != TlsIndex) {
        TlsFree(TlsIndex);
        TlsIndex = BOGUS_TLS_INDEX;
    }
}


ULONG 
WsbTraceThreadOff( 
    void 
    )

/*++

Routine Description:

    Increment the trace-off count for this thread

Arguments:

    None.

Return Value:

    The final trace-off count.

--*/
{
    ULONG count = 0;
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        count = ++(pThreadData->TraceOffCount);
    }
    return(count);
}


ULONG 
WsbTraceThreadOffCount( 
    void 
    )

/*++

Routine Description:

    Return the current trace-off count for this thread

Arguments:

    None.

Return Value:

    The current trace-off count.

--*/
{
    ULONG count = 0;
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        count = pThreadData->TraceOffCount;
    }
    return(count);
}


ULONG 
WsbTraceThreadOn( 
    void 
    )

/*++

Routine Description:

    Decrement the trace-off count for this thread

Arguments:

    None.

Return Value:

    The final trace-off count.

--*/
{
    ULONG count = 0;
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        if (0 < pThreadData->TraceOffCount) {
            pThreadData->TraceOffCount--;
        }
        count = pThreadData->TraceOffCount;
    }
    return(count);
}


static HRESULT 
OutputTraceString(
    IN ULONG indentLevel, 
    IN OLECHAR* introString, 
    IN OLECHAR* format,
    IN va_list vaList
)

/*++

Routine Description:

    Build and output the trace string.

Arguments:

    indentLevel - Count of indentation strings to output

    introString - String to add before variable list

    vaList      - Variable list to format

Return Value:

    The data pointer.

--*/
{
    HRESULT         hr = S_OK;
    OLECHAR         traceString[WSB_TRACE_BUFF_SIZE];

    try  {
        LONG  incSize;
        LONG  traceSize = 0;

        // Initialize the string
        swprintf(traceString, OLESTR(""));
        
        // Add indentation
        incSize = wcslen(WSB_INDENT_STRING);
        for(ULONG level = 0; level < indentLevel; level++) {
            if ((traceSize + incSize) < WSB_TRACE_BUFF_SIZE) {
                wcscat(traceString, WSB_INDENT_STRING);
                traceSize += incSize;
            }
        }

        // Add the intro string
        if (introString) {
            incSize = wcslen(introString);
        } else {
            incSize = 0;
        }
        if (incSize && ((traceSize + incSize) < WSB_TRACE_BUFF_SIZE)) {
            wcscat(traceString, introString);
            traceSize += incSize;
        }

        // Format the arguments (leave room for EOL and EOS)
        incSize = _vsnwprintf(&traceString[traceSize], 
                (WSB_TRACE_BUFF_SIZE - traceSize - 3), format, vaList);
        if (incSize < 0) {
            // This means we filled the buffer and would have overflowed
            // Need to add EOS
            traceString[WSB_TRACE_BUFF_SIZE - 3] = OLECHAR('\0');
            traceSize = WSB_TRACE_BUFF_SIZE - 3;
        } else {
            traceSize += incSize;
        }

        // Add EOL if needed
        if (introString) {
            wcscat(&traceString[traceSize], OLESTR("\r\n"));
        }
        
        WsbAffirmHr(g_pWsbTrace->Print(traceString));

    } WsbCatch (hr);

    return(hr);
}



static HRESULT
GetThreadDataPointer(
    OUT THREAD_DATA** ppTD
    )

/*++

Routine Description:

    Return a pointer to the data specific to the current thread.  This
    function will allocate space for the thread data (and initialize it)
    if needed.

Arguments:

    ppTD  - Pointer to pointer to thread data.

Return Value:

    The data pointer.

--*/
{
    HRESULT      hr = E_FAIL;
    THREAD_DATA* pThreadData = NULL;

    //  Make sure the TLS index is valid
    if (BOGUS_TLS_INDEX != TlsIndex) {

        //  Try to get the data pointer for this thread
        pThreadData = static_cast<THREAD_DATA*>(TlsGetValue(TlsIndex));

        if (pThreadData) {
            hr = S_OK;
        } else {
            //  Allocate data for this thread yet
            pThreadData = static_cast<THREAD_DATA*>(WsbAlloc(sizeof(THREAD_DATA)));
            if (pThreadData) {
                if (TlsSetValue(TlsIndex, pThreadData)) {
                    //  Initialize the data for this thread
                    pThreadData->TraceOffCount = 0;
                    pThreadData->IndentLevel = 0;
                    pThreadData->LogModule = NULL;
                    pThreadData->LogModuleLine = 0;
                    pThreadData->LogNTBuild = 0;
                    pThreadData->LogRSBuild = 0;
                    hr = S_OK;
                } else {
                    //  TlsSetValue failed!
                    WsbFree(pThreadData);
                    pThreadData = NULL;
                }
            }
        }
    }

    *ppTD = pThreadData;

    return(hr);
}


static void
SnapShotTraceAndEvent(
    SYSTEMTIME      stime
    )

/*++

Routine Description:

    This routine saves the trace files and event logs

Arguments:


Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;

    PSID pSystemSID = NULL;
    PSID pAdminSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
#define     TRACE_MUTEX_NUM_ACE      2
    EXPLICIT_ACCESS ea[TRACE_MUTEX_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;

    try  {

        OLECHAR                         dataString[256];
        OLECHAR                         tmpString[50];
        OLECHAR                         mutexName[50] = L"WsbTraceSnapShotMutex";
        DWORD                           sizeGot;
        HANDLE                          mutexHandle = INVALID_HANDLE_VALUE;

        //
        // The level is one to snap shot and snap shot is on.  Now make sure there is a
        // path specified where we are to copy the logs
        // 
        WsbAffirm(0 != g_pWsbLogSnapShotPath, E_POINTER);
        WsbAffirm(0 != wcslen(g_pWsbLogSnapShotPath), E_POINTER);

        //
        // Get the system root string from the registry
        //
        WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, dataString, 256, &sizeGot));

        CWsbStringPtr   snapShotSubDir;
        CWsbStringPtr   snapShotFile;
        snapShotSubDir = g_pWsbLogSnapShotPath;
        //
        // Make sure there is a "\" at the end of the path
        //
        int len;
        len = wcslen(snapShotSubDir);
        if (snapShotSubDir[len] != '\\')  {
            snapShotSubDir.Append(L"\\");
        }

        // Build the path to the subdirectory that will contain the logs from the input path
        // and the time of the event.
        swprintf(tmpString, OLESTR("%2.02u.%2.02u-%2.2u.%2.2u.%2.2u.%3.3u"),
                stime.wMonth, stime.wDay,
                stime.wHour, stime.wMinute,
                stime.wSecond, stime.wMilliseconds); 
        snapShotSubDir.Append(tmpString);
        
        //
        // Make sure the subdirectory can be created
        //
        WsbAffirmHr(WsbCreateAllDirectories(snapShotSubDir));

        //
        // Create SD that allows access only to local-system and admin
        //  (All RSS process that may be tracing must run as LocalSystem or Admin)
        //
        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * TRACE_MUTEX_NUM_ACE);

        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS,
                             0, 0, 0, 0, 0, 0,
                             &pAdminSID) );
        ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.pMultipleTrustee = NULL;
        ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName  = (LPTSTR) pAdminSID;

        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                             SECURITY_LOCAL_SYSTEM_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pSystemSID) );
        ea[1].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[1].Trustee.pMultipleTrustee = NULL;
        ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[1].Trustee.ptstrName  = (LPTSTR) pSystemSID;

        WsbAffirmNoError(SetEntriesInAcl(TRACE_MUTEX_NUM_ACE, ea, NULL, &pACL));

        pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
        WsbAffirmPointer(pSD);
        WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
        WsbAffirmStatus(SetSecurityDescriptorDacl(
                            pSD, 
                            TRUE,     // fDaclPresent flag   
                            pACL, 
                            FALSE));   // not a default DACL 

        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;

//
//      We need to synchronize around the creating of the 
//      event backup files and copying them.  Since all three
//      services will access this code, use a mutex to 
//      synchronize them.
        mutexHandle = CreateMutex(&sa, TRUE, mutexName);
        if (mutexHandle)  {
            //
            // Copy the event logs
            // First back them up and then copy the backup file.
            //
            HANDLE eventLogHandle = INVALID_HANDLE_VALUE;
            try  {
                CWsbStringPtr computerName;
                CWsbStringPtr logName;
                
                WsbAffirmHr( WsbGetComputerName( computerName ) );
                
                //
                // Open the application event log and back it up
                //
                logName = dataString;
                logName.Append(WSB_APP_EVENT_LOG);
                eventLogHandle = OpenEventLog((LPCTSTR)computerName, (LPCTSTR)logName);
                if (INVALID_HANDLE_VALUE != eventLogHandle)  {
                    logName = dataString;
                    logName.Append(WSB_APP_EVENT_LOG_BKUP);
                    DeleteFile(logName);
                    WsbAffirmStatus(BackupEventLog(eventLogHandle, (LPCTSTR)logName));
                    WsbAffirmStatus(CloseEventLog(eventLogHandle));
                    snapShotFile = snapShotSubDir;
                    snapShotFile.Append(WSB_APP_EVENT_LOG_NAME);
                    //
                    // Now copy the backup file
                    //
                    WsbAffirmStatus(CopyFile(logName, snapShotFile, FALSE));
                }
                
                //
                // Open the system event log and back it up
                //
                logName = dataString;
                logName.Append(WSB_SYS_EVENT_LOG);
                eventLogHandle = OpenEventLog((LPCTSTR)computerName, (LPCTSTR)logName);
                if (INVALID_HANDLE_VALUE != eventLogHandle)  {
                    logName = dataString;
                    logName.Append(WSB_SYS_EVENT_LOG_BKUP);
                    DeleteFile(logName);
                    WsbAffirmStatus(BackupEventLog(eventLogHandle, (LPCTSTR)logName));
                    WsbAffirmStatus(CloseEventLog(eventLogHandle));
                    snapShotFile = snapShotSubDir;
                    snapShotFile.Append(WSB_SYS_EVENT_LOG_NAME);
                    //
                    // Now copy the backup file
                    //
                    WsbAffirmStatus(CopyFile(logName, snapShotFile, FALSE));
                }
                
                
            } WsbCatchAndDo(hr,if (INVALID_HANDLE_VALUE != eventLogHandle)  {
                CloseEventLog(eventLogHandle);}; hr = S_OK; );
            (void)ReleaseMutex(mutexHandle);
        }

        // 
        // Copy the trace files if there are any
        //
        try  {
            WIN32_FIND_DATA findData;
            HANDLE          handle;
            CWsbStringPtr   traceFile;
            CWsbStringPtr   searchString;
            BOOL            foundFile;
            //               
            // Find the file(s)
            //
            WsbAffirmHr(WsbGetMetaDataPath(searchString));
            searchString.Append(WSB_RS_TRACE_FILES);
            handle = FindFirstFile(searchString, &findData);
            snapShotFile = snapShotSubDir;
            snapShotFile.Append(L"\\");
            WsbAffirmHr(WsbGetMetaDataPath(traceFile));
            traceFile.Append(WSB_RS_TRACE_PATH);
            WsbAffirmHr(snapShotFile.Append((OLECHAR *)(findData.cFileName)));
            WsbAffirmHr(traceFile.Append((OLECHAR *)(findData.cFileName)));

            // If we found a file, then remember the scan handle and
            // return the scan item.  
            foundFile = TRUE;
            while ((INVALID_HANDLE_VALUE != handle) && (foundFile == TRUE))  {
                if ((FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes) != FILE_ATTRIBUTE_DIRECTORY) {
                    WsbAffirmStatus(CopyFile(traceFile, snapShotFile, FALSE));
                }    
                foundFile = FindNextFile(handle, &findData);
                snapShotFile = snapShotSubDir;
                snapShotFile.Append(L"\\");
                WsbAffirmHr(WsbGetMetaDataPath(traceFile));
                traceFile.Append(WSB_RS_TRACE_PATH);
                WsbAffirmHr(snapShotFile.Append((OLECHAR *)(findData.cFileName)));
                WsbAffirmHr(traceFile.Append((OLECHAR *)(findData.cFileName)));
            }
            
        } WsbCatchAndDo(hr, hr = S_OK; );
    }
    WsbCatch( hr );

    if (pAdminSID) {
        FreeSid(pAdminSID);
    }
    if (pSystemSID) {
        FreeSid(pSystemSID);
    }
    if (pACL) {
        LocalFree(pACL);
    }
    if (pSD) {
        WsbFree(pSD);
    }

}

#include "winnls.h"
#include "resource.h"

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen);

const int pwOrders[] = {IDS_WSB_BYTES, IDS_WSB_ORDERKB, IDS_WSB_ORDERMB,
                          IDS_WSB_ORDERGB, IDS_WSB_ORDERTB, IDS_WSB_ORDERPB, IDS_WSB_ORDEREB};


HRESULT WsbShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
/*++

Routine Description:

    Converts numbers into sort formats
        532     -> 523 bytes
        1340    -> 1.3KB
        23506   -> 23.5KB
                -> 2.4MB
                -> 5.2GB

Arguments:

Return Value:

Note:

    This code is cloned from MS source /shell/shelldll/util.c - AHB

--*/
{

    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];
    HMODULE hModule;

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, 10);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = (TCHAR)( TEXT('0') + 3 - wLen );
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    hModule = LoadLibraryEx(WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hModule) {
        LoadString(hModule,
                  pwOrders[i], 
                  szOrder, 
                  ARRAYSIZE(szOrder));
        wsprintf(szBuf, szOrder, (LPTSTR)szTemp);
        FreeLibrary(hModule);
    }

    return S_OK;
}


LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen)
/*++

Routine Description:

    Takes a DWORD add commas etc to it and puts the result in the buffer

Arguments:

Return Value:

Note:

    This code is cloned from MS source /shell/shelldll/util.c - AHB

--*/
{
    TCHAR  szTemp[20];  // more than enough for a DWORD
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = _tcstol(szSep, NULL, 10);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, nResLen) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

void
WsbTraceAndPrint(
    DWORD       eventId,
    ...
    )

/*++

Routine Description:

    This routine writes a message into standard output.  The message
    is also written to the application trace file.  

Arguments:

    eventId    - The message Id to log.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;

    try  {
        va_list         vaList;

        va_start(vaList, eventId);
        WsbTraceAndPrintV(eventId, &vaList );
        va_end(vaList);

    } WsbCatch( hr );
}


void
WsbTraceAndPrintV(
    DWORD       eventId,
    va_list *   inserts
    )

/*++

Routine Description:

    This routine writes a message into standard output.  The message
    is also written to the application trace file.  

Arguments:

    eventId    - The message Id to log.
    inserts    - An array of message inserts that are merged with the message description
                   specified by eventId.  The number of inserts must match the number
                   specified by the message description.  The last insert must be NULL,
                   to indicate the end of the insert list.

Return Value:

    None.

--*/
{

    HRESULT         hr = S_OK;

    char *pszMultiByte = NULL;

    try  {

        WsbAssertPointer( inserts );

        const OLECHAR * facilityName = 0;
        BOOL            bPrint;
        OLECHAR * messageText = 0;

        //
        // Determine type of event
        //
        switch ( eventId & 0xc0000000 ) {
        case ERROR_SEVERITY_INFORMATIONAL:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_INFORMATION) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_WARNING:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_WARNING) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_ERROR:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_ERROR) ? TRUE : FALSE;
            break;
        default:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_COMMENT) ? TRUE : FALSE;
            break;
        }

        WsbAffirm (bPrint, S_OK);

        //
        // Determine source facility of message
        //
        switch ( HRESULT_FACILITY( eventId ) ) {

        case WSB_FACILITY_PLATFORM:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_RMS:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_HSMENG:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_JOB:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_HSMTSKMGR:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_FSA:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_GUI:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_MOVER:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_LAUNCH:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_USERLINK:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_CLI:
            facilityName = WSB_FACILITY_CLI_NAME;
            break;

        case WSB_FACILITY_TEST:
            facilityName = WSB_FACILITY_TEST_NAME;
            break;

        case HRESULT_FACILITY(FACILITY_NT_BIT):
            facilityName = WSB_FACILITY_NTDLL_NAME;
            eventId &= ~FACILITY_NT_BIT;
            break;
            
        default:
            facilityName = WSB_FACILITY_NTDLL_NAME;
            break;
        }

        if ( facilityName ) {

            HMODULE hModule;

            hModule = LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );

            if (hModule) {
            // 
            // Load and format the message
            //
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           hModule,
                           eventId,
                           MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                           (LPTSTR) &messageText,
                           0,
                           inserts);

            if ( messageText ) {
                //
                // Print the message (Format messages come with \n)
                // Use the WriteConsole/WriteFile to output messages for localiztion support
                //

                // Get console handle
                DWORD       fdwMode, dwBytesWritten;
                HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE); 
                WsbAffirmHandle(hOutput);

                // Check to see if it's a console handle or not
                // If the user redirected to a file or used a pipe, we need to use different APIs for writing
                if( (GetFileType(hOutput) & FILE_TYPE_CHAR) && GetConsoleMode(hOutput, &fdwMode) ) {
                    // Console
                    WsbAffirmStatus(WriteConsoleW(hOutput, messageText, (DWORD)wcslen(messageText), &dwBytesWritten, NULL));
                } else {
                    // Not a console

                    // Get number of chars required for the translation and alloate
                    int nCharCount = WideCharToMultiByte(GetConsoleOutputCP(), 0, messageText, -1, 0, 0, 0, 0);
                    if (nCharCount == 0) {
                        WsbAffirmWin32(GetLastError());
                    }

                    pszMultiByte = (char *)WsbAlloc(nCharCount);

                    // Translate and write, avoid writing the terminating null
                    nCharCount = WideCharToMultiByte(GetConsoleOutputCP(), 0, messageText, -1, pszMultiByte, nCharCount, 0, 0);
                    if (nCharCount == 0) {
                        WsbAffirmWin32(GetLastError());
                    }

                    WsbAffirmStatus(WriteFile(hOutput, pszMultiByte, nCharCount-1, &dwBytesWritten, 0));

                    // Buffer is freed at the end of this functiob to cover for an error case
                }

                //
                // Trace the message
                //
                if ( g_pWsbTrace ) {
                    WsbTracef( OLESTR("!!!!! PRINT - Event <0x%08lx> is printed\n"), eventId );
                    WsbTracef( OLESTR("%ls"), messageText );  // Format messages come with \n
                }

                LocalFree( messageText );

            } else {
                if ( g_pWsbTrace ) {
                    WsbTracef( OLESTR("!!!!! PRINT !!!!! - Message <0x%08lx> could not be translated.\r\n"), eventId );
                }
            }
            FreeLibrary(hModule);
          }  else {
             WsbTracef( OLESTR("!!!!! EVENT !!!!! - Could not load facility name DLL %ls. \r\n"), facilityName);
          }
        } else {
            if ( g_pWsbTrace ) {
                WsbTracef( OLESTR("!!!!! PRINT !!!!! - Message File for <0x%08lx> could not be found.\r\n"), eventId );
            }
        }

    } WsbCatch( hr );

    if (pszMultiByte != NULL) {
        WsbFree(pszMultiByte);
        pszMultiByte = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbushrt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbushrt.h

Abstract:

    This component is an object representations of the USHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBUSHRT_
#define _WSBUSHRT_

/*++

Class Name:
    
    CWsbUshort

Class Description:

    An object representations of the USHORT standard type. It
    is both persistable and collectable.

--*/

class CWsbUshort : 
    public CWsbObject,
    public IWsbUshort,
    public CComCoClass<CWsbUshort,&CLSID_CWsbUshort>
{
public:
    CWsbUshort() {}
BEGIN_COM_MAP(CWsbUshort)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbUshort)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbUshort)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbUshort)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbUshort
public:
    STDMETHOD(CompareToUshort)(USHORT value, SHORT* pResult);
    STDMETHOD(CompareToIUshort)(IWsbUshort* pUshort, SHORT* pResult);
    STDMETHOD(GetUshort)(USHORT* pValue);
    STDMETHOD(SetUshort)(USHORT value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    USHORT          m_value;
};

#endif // _WSBUSHRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbulong.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbulong.cpp

Abstract:

    This component is an object representations of the ULONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbulong.h"


HRESULT
CWsbUlong::CompareToUlong(
    IN ULONG value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUlong::CompareToUlong
    
--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbUlong::CompareToUlong"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbUlong::CompareToUlong"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbUlong::CompareToIUlong(
    IN IWsbUlong* pUlong,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUlong::CompareToIUlong

--*/
{
    HRESULT     hr = E_FAIL;
    ULONG       value;

    WsbTraceIn(OLESTR("CWsbUlong::CompareToIUlong"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUlong, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pUlong->GetUlong(&value));
        hr = CompareToUlong(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::CompareToIUlong"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUlong::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbUlong*  pUlong;

    WsbTraceIn(OLESTR("CWsbUlong::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbUlong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbUlong, (void**) &pUlong));
        hr = CompareToIUlong(pUlong, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUlong::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbUlong::GetUlong(
    OUT ULONG* pValue
    )

/*++

Implements:

  IWsbUlong::GetUlong

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::GetUlong"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::GetUlong"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbUlong::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbUlong;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbUlong::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(ULONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbUlong::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbUlong::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbUlong::SetUlong(
    ULONG value
    )

/*++

Implements:

  IWsbUlong::SetUlong

--*/
{
    WsbTraceIn(OLESTR("CWsbUlong::SetUlong"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbUlong::SetUlong"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbUlong::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbUlong>      pUlong1;
    CComPtr<IWsbUlong>      pUlong2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    ULONG                   value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbUlong::Test"), OLESTR(""));

    try {

        // Get the pUlong interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbUlong*) this)->QueryInterface(IID_IWsbUlong, (void**) &pUlong1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pUlong1->SetUlong(0xffffffff));
                WsbAffirmHr(pUlong1->GetUlong(&value));
                WsbAssert(value == 0xffffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbUlong, NULL, CLSCTX_ALL, IID_IWsbUlong, (void**) &pUlong2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong2->GetUlong(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(767));
                    WsbAffirmHr(pUlong2->SetUlong(767));
                    WsbAssert(pUlong1->IsEqual(pUlong2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(767));
                    WsbAffirmHr(pUlong2->SetUlong(65000));
                    WsbAssert(pUlong1->IsEqual(pUlong2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(900));
                    WsbAffirmHr(pUlong2->SetUlong(900));
                    WsbAssert((pUlong1->CompareTo(pUlong2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(500));
                    WsbAffirmHr(pUlong2->SetUlong(1000));
                    WsbAssert((pUlong1->CompareTo(pUlong2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(75000));
                    WsbAffirmHr(pUlong2->SetUlong(20000));
                    WsbAssert((pUlong1->CompareTo(pUlong2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pUlong2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUlong2->SetUlong(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbUlong.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUlong1->SetUlong(888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbUlong.tst"), 0));
                        WsbAssert(pUlong1->CompareToUlong(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbulong.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbulong.h

Abstract:

    This component is an object representations of the ULONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBULONG_
#define _WSBULONG_

/*++

Class Name:
    
    CWsbUlong

Class Description:

    An object representations of the ULONG standard type. It
    is both persistable and collectable.

--*/

class CWsbUlong : 
    public CWsbObject,
    public IWsbUlong,
    public CComCoClass<CWsbUlong,&CLSID_CWsbUlong>
{
public:
    CWsbUlong() {}
BEGIN_COM_MAP(CWsbUlong)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbUlong)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbUlong)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbUlong)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbUlong
public:
    STDMETHOD(CompareToUlong)(ULONG value, SHORT* pResult);
    STDMETHOD(CompareToIUlong)(IWsbUlong* pUlong, SHORT* pResult);
    STDMETHOD(GetUlong)(ULONG* pValue);
    STDMETHOD(SetUlong)(ULONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    ULONG           m_value;
};

#endif // _WSBULONG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbushrt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbushrt.cpp

Abstract:

    This component is an object representations of the USHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbushrt.h"


HRESULT
CWsbUshort::CompareToUshort(
    IN USHORT value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUshort::CompareToUshort

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbUshort::CompareToUshort"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbUshort::CompareToUshort"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbUshort::CompareToIUshort(
    IN IWsbUshort* pUshort,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUshort::CompareToIShort

--*/
{
    HRESULT     hr = E_FAIL;
    USHORT      value;

    WsbTraceIn(OLESTR("CWsbUshort::CompareToIUshort"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUshort, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pUshort->GetUshort(&value));
        hr = CompareToUshort(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::CompareToIUshort"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUshort::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbUshort* pUshort;

    WsbTraceIn(OLESTR("CWsbUshort::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbUshort interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbUshort, (void**) &pUshort));
        hr = CompareToIUshort(pUshort, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUshort::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbUshort::GetUshort(
    OUT USHORT* pValue
    )

/*++

Implements:

  IWsbUshort::GetUshort

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::GetUshort"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::GetUshort"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbUshort::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbUshort;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbUshort::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(USHORT);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbUshort::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbUshort::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbUshort::SetUshort(
    USHORT value
    )

/*++

Implements:

  IWsbUshort::SetUshort

--*/
{
    WsbTraceIn(OLESTR("CWsbUshort::SetUshort"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbUshort::SetUshort"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbUshort::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbUshort>     pUshort1;
    CComPtr<IWsbUshort>     pUshort2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    USHORT                  value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbUshort::Test"), OLESTR(""));

    try {

        // Get the pUshort interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbUshort*) this)->QueryInterface(IID_IWsbUshort, (void**) &pUshort1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pUshort1->SetUshort(65000));
                WsbAffirmHr(pUshort1->GetUshort(&value));
                WsbAssert(value == 65000, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbUshort, NULL, CLSCTX_ALL, IID_IWsbUshort, (void**) &pUshort2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort2->GetUshort(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(767));
                    WsbAffirmHr(pUshort2->SetUshort(767));
                    WsbAssert(pUshort1->IsEqual(pUshort2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(767));
                    WsbAffirmHr(pUshort2->SetUshort(167));
                    WsbAssert(pUshort1->IsEqual(pUshort2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(900));
                    WsbAffirmHr(pUshort2->SetUshort(900));
                    WsbAssert((pUshort1->CompareTo(pUshort2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(900));
                    WsbAffirmHr(pUshort2->SetUshort(1400));
                    WsbAssert((pUshort1->CompareTo(pUshort2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(15000));
                    WsbAffirmHr(pUshort2->SetUshort(10000));
                    WsbAssert((pUshort1->CompareTo(pUshort2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pUshort2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUshort2->SetUshort(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbUshort.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUshort1->SetUshort(888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbUshort.tst"), 0));
                        WsbAssert(pUshort1->CompareToUshort(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbvar.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbvar.cpp

Abstract:

    This class is a wrapper for the VARIANT structure, providing
    conversion and cleanup automatically. Current supported types
    for conversion are OLECHAR * (BSTR), IUnknown / IDispatch, and
    GUID. GUIDs are represented internally as strings.

Author:

    Rohde Wakefield          [rohde]   21-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"


//
// OLECHAR (wide-character) methods
//

CWsbVariant::CWsbVariant ( const OLECHAR * string )
{
    Init ( );

    if ( 0 != ( bstrVal = WsbAllocString ( string ) ) )
        vt = VT_BSTR;
}

CWsbVariant & CWsbVariant::operator = ( const OLECHAR * string )
{
    Clear ( );

    if ( 0 != ( bstrVal = WsbAllocString ( string ) ) )
        vt = VT_BSTR;

    return ( *this );
}

CWsbVariant::operator OLECHAR * ( )
{
    if ( VT_BSTR != vt )
        VariantChangeType ( this, this, 0, VT_BSTR );

    return ( VT_BSTR == vt ) ? bstrVal : 0;
}


//
// COM Interface methods
//

CWsbVariant::CWsbVariant ( IUnknown * pUnk )
{
    Init ( );

    if ( 0 != pUnk ) {

        punkVal = pUnk;
        punkVal->AddRef ( );
        vt = VT_UNKNOWN;

    }
}

CWsbVariant::CWsbVariant ( IDispatch * pDisp )
{
    Init ( );

    if ( 0 != pDisp ) {

        pdispVal = pDisp;
        pdispVal->AddRef ( );
        vt = VT_DISPATCH;

    }
}

CWsbVariant::operator IUnknown * ( )
{
    //
    // Ok to return IDispatch as IUnknown since it
    // derives from IUnknown
    //

    if ( IsInterface ( ) )
        return punkVal;

    return 0;
}

CWsbVariant::operator IDispatch * ( )
{
    if ( IsDispatch ( ) ) {

        return pdispVal;

    }

    if ( IsInterface ( ) ) {

        IDispatch * pDisp;
        if ( SUCCEEDED ( punkVal->QueryInterface ( IID_IDispatch, (void**)&pDisp ) ) ) {

            punkVal->Release ( );
            pdispVal = pDisp;
            vt = VT_DISPATCH;

            return ( pdispVal );
        }

    }

    return 0;
}

CWsbVariant & CWsbVariant::operator = ( IUnknown * pUnk )
{
    Clear ( );

    vt = VT_UNKNOWN;

    punkVal = pUnk;
    punkVal->AddRef ( );

    return ( *this );
}

CWsbVariant & CWsbVariant::operator = ( IDispatch * pDisp )
{
    Clear ( );

    vt = VT_DISPATCH;

    pdispVal = pDisp;
    pdispVal->AddRef ( );

    return ( *this );
}


//
// Methods to work with GUIDs
//

CWsbVariant::CWsbVariant ( REFGUID rguid )
{
    Init ( );

    *this = rguid;
}

CWsbVariant & CWsbVariant::operator = ( REFGUID rguid )
{
    Clear ( );

    if ( 0 != ( bstrVal = WsbAllocStringLen( 0, WSB_GUID_STRING_SIZE ) ) ) {

        if ( SUCCEEDED ( WsbStringFromGuid ( rguid, bstrVal ) ) ) {

            vt = VT_BSTR;

        }

    }

    return ( *this );
}

CWsbVariant::operator GUID ()
{
    
    GUID guid;

    WsbGuidFromString ( (const OLECHAR *)*this, &guid ); 

    return guid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbusn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbUsn.cpp

Abstract:

    Functions to manipulate the USN journal and USN records on a file

Author:

    Rick Winter [rick]  11-17-97

Revision History:

--*/

#include "stdafx.h"

#define HSM_FILE_CHANGED  (USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION | USN_REASON_FILE_DELETE)

//  Local functions
static HANDLE OpenVol(OLECHAR* volName);



HRESULT
WsbCheckUsnJournalForChanges(
    OLECHAR*    volName,
    ULONGLONG   fileUsnJournalId,
    LONGLONG    FileId,
    LONGLONG    StartUsn,
    LONGLONG    StopUsn,
    BOOL*       pChanged
    )  

/*++

Routine Description:

    Check the USN Journal for changes to the unnamed data stream for this
    file between the given USNs.

Arguments:

    volName  -  Volume name

    FileId   -  File ID of file

    StartUsn -  USN to start at in journal

    StopUsn  -  USN to stop at in journal

    pChanged -  Pointer to result: TRUE for change

Return Value:

    S_OK   - success

--*/
{
    ULONGLONG               Buffer[1024];
    HRESULT                 hr = S_OK;
    IO_STATUS_BLOCK         Iosb;
    USN                     NextUsn;
    NTSTATUS                Status;
    READ_USN_JOURNAL_DATA   ReadUsnJournalData;
    DWORD                   ReturnedByteCount;
    ULONGLONG               usnId;
    PUSN_RECORD             pUsnRecord;
    HANDLE                  volHandle = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("WsbCheckUsnJournalForChanges"), 
            OLESTR("volName = %ls, FileId = %I64x, StartUsn = %I64d, StopUsn = %I64d"),
            volName, FileId, StartUsn, StopUsn);

    try {
        WsbAffirmPointer(pChanged);
        *pChanged = FALSE;
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);

        //  Get the journal ID
        WsbAffirmHr(WsbGetUsnJournalId(volName, &usnId));

        // If we got a non-zero journal id, cpmare to the current one and fail if they are not equal
        if ((fileUsnJournalId != 0) && (fileUsnJournalId != usnId)) {
            WsbTraceAlways(
                OLESTR("WsbCheckUsnJournalForChanges: Current Usn journal id %I64x doesn't match file Usn journal id %I64x\n"),
                usnId, fileUsnJournalId);
            WsbThrow(E_FAIL);
        }

        //  Set up read info
        NextUsn = StartUsn;
        ReadUsnJournalData.UsnJournalID = usnId;
        ReadUsnJournalData.ReasonMask = HSM_FILE_CHANGED;
        ReadUsnJournalData.ReturnOnlyOnClose = TRUE;
        ReadUsnJournalData.Timeout = 0;          // ????
        ReadUsnJournalData.BytesToWaitFor = 0;   // ??????

        //  Loop through journal entries
        while (!*pChanged) {

            ReadUsnJournalData.StartUsn = NextUsn;
            Status = NtFsControlFile( volHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &Iosb,
                                      FSCTL_READ_USN_JOURNAL,
                                      &ReadUsnJournalData,
                                      sizeof(ReadUsnJournalData),
                                      &Buffer,
                                      sizeof(Buffer) );

            if (NT_SUCCESS(Status)) {
                Status = Iosb.Status;
            }

            if (Status == STATUS_JOURNAL_ENTRY_DELETED)  {
                WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: StartUsn has been deleted\n"));
            }
            WsbAffirmNtStatus(Status);

            ReturnedByteCount = (DWORD)Iosb.Information;
            WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: bytes read = %u\n"), ReturnedByteCount);

            //  Get the next USN start point & and the first
            //  journal entry
            NextUsn = *(USN *)&Buffer;
            pUsnRecord = (PUSN_RECORD)((PCHAR)&Buffer + sizeof(USN));
            ReturnedByteCount -= sizeof(USN);

            //  Make sure we actually got some entries
            if (0 == ReturnedByteCount) {
                WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: no entries, exiting loop\n"), ReturnedByteCount);
                break;
            }

            //  Loop over entries in this buffer
            while (ReturnedByteCount != 0) {
                WsbAffirm(pUsnRecord->RecordLength <= ReturnedByteCount, E_FAIL);

                //  Skip the first record and check for match on File Id
                //  (Also skip entries that we created)
                if (pUsnRecord->Usn > StartUsn && 
                        USN_SOURCE_DATA_MANAGEMENT != pUsnRecord->SourceInfo &&
                        pUsnRecord->FileReferenceNumber == static_cast<ULONGLONG>(FileId)) {
                    WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: found change record\n"));
                    WsbTrace(OLESTR( "    Reason: %08lx\n"), pUsnRecord->Reason);
                    *pChanged = TRUE;
                    break;
                } else if (pUsnRecord->Usn == StartUsn) {
                    // This check is done to make sure the journal is valid - 
                    // StartUsn record must refer to the file in question
                    if (pUsnRecord->FileReferenceNumber != static_cast<ULONGLONG>(FileId)) {
                        WsbTraceAlways(
                            OLESTR("WsbCheckUsnJournalForChanges: StartUsn %I64d for FileId %I64x doesn't match usn journal FileId %I64x\n"),
                            StartUsn, FileId, pUsnRecord->FileReferenceNumber);
                        WsbThrow(E_FAIL);
                    }
                }

                ReturnedByteCount -= pUsnRecord->RecordLength;
                pUsnRecord = (PUSN_RECORD)((PCHAR)pUsnRecord + pUsnRecord->RecordLength);
            }

            //  Make sure we're making progress
            WsbAffirm(NextUsn > ReadUsnJournalData.StartUsn, E_FAIL);

        }


    } WsbCatch( hr );

    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    WsbTraceOut(OLESTR("WsbCheckUsnJournalForChanges"), OLESTR("Hr = <%ls>, Changed = %ls"),
            WsbHrAsString(hr), WsbBoolAsString(*pChanged));

    return( hr );
}


HRESULT
WsbGetUsnFromFileHandle(
    IN  HANDLE    hFile,
    IN  BOOL      ForceClose,
    OUT LONGLONG* pFileUsn
    )

/*++

Routine Description:

    Get the current USN Journal number for the open file.

Arguments:

    hFile    - Handle to the open file

    pFileUsn - Pointer to File USN to be returned.

Return Value:

    S_OK   - success

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("WsbGetUsnFromFileHandle"), OLESTR(""));

    try {
        char                      buffer[4096];
        IO_STATUS_BLOCK           IoStatusBlock;
        PUSN_RECORD               pUsnInfo;

        WsbAffirm(pFileUsn, E_POINTER);
        *pFileUsn = 0;

        if (TRUE == ForceClose)  {
            //  Get the internal information
            WsbAffirmNtStatus(NtFsControlFile( hFile,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       FSCTL_WRITE_USN_CLOSE_RECORD,
                                       NULL,
                                       0,
                                       buffer,
                                       sizeof(buffer)));
        }

        //  Get the internal information
        WsbAffirmNtStatus(NtFsControlFile( hFile,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_READ_FILE_USN_DATA,
                                   NULL,
                                   0,
                                   buffer,
                                   sizeof(buffer)));

        pUsnInfo = (PUSN_RECORD) buffer;

        WsbTrace(OLESTR("WsbGetUsnFromFileHandle, Usn record version number is %u\n"),
            pUsnInfo->MajorVersion);

        //  Check the version
        WsbAffirm(pUsnInfo->MajorVersion == 2, WSB_E_INVALID_DATA);

        //  Get the USN
        *pFileUsn = pUsnInfo->Usn;

    } WsbCatchAndDo(hr,
        WsbTrace(OLESTR("WsbGetUsnFromFileHandle, GetLastError = %lx\n"),
            GetLastError());
    );

    WsbTraceOut(OLESTR("WsbGetUsnFromFileHandle"), OLESTR("Hr = <%ls>, FileUsn = %I64d"),
            WsbHrAsString(hr), *pFileUsn);

    return(hr);
}


HRESULT
WsbMarkUsnSource(
    HANDLE          changeHandle,
    OLECHAR*        volName
    )  

/*++

Routine Description:

    Mark the source of file changes for this handle as data management.  This lets
    others, such as content indexing, know that the changes do not affect file content.

Arguments:

    changeHandle    - Handle to the open file

    volName         - Volume name (d:\)

Return Value:

    S_OK   - success

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    NTSTATUS            ntStatus;
    MARK_HANDLE_INFO    sInfo;
    IO_STATUS_BLOCK     IoStatusBlock;

    try {
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);

        sInfo.UsnSourceInfo = USN_SOURCE_DATA_MANAGEMENT;
        sInfo.VolumeHandle = volHandle;
        sInfo.HandleInfo = 0;
        ntStatus = NtFsControlFile( changeHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_MARK_HANDLE,
                                   &sInfo,
                                   sizeof(MARK_HANDLE_INFO),
                                   NULL,
                                   0);

        WsbAffirmNtStatus(ntStatus);

        CloseHandle(volHandle);
        volHandle = INVALID_HANDLE_VALUE;

    } WsbCatch( hr );


    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    return( hr );
}



HRESULT
WsbCreateUsnJournal(
    OLECHAR*        volName,
    ULONGLONG       usnSize
    )  

/*++

Routine Description:

    Create the USN journal for the given volume.

Arguments:

    volName -   Volume name (d:\)

    usnSize -   Max size of journal

Return Value:

    S_OK   - success


--*/
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    NTSTATUS            ntStatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    CREATE_USN_JOURNAL_DATA CreateUsnJournalData;

    WsbTraceIn(OLESTR("WsbCreateUsnJournal"), OLESTR("volName = %ls, Size = %I64d"),
            volName, usnSize);

    try {
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);

        CreateUsnJournalData.MaximumSize = usnSize;
        CreateUsnJournalData.AllocationDelta = usnSize / 32;

        ntStatus = NtFsControlFile( volHandle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        FSCTL_CREATE_USN_JOURNAL,
                                        &CreateUsnJournalData,
                                        sizeof(CreateUsnJournalData),
                                        NULL,
                                        0);
        WsbTrace(OLESTR("WsbCreateUsnJournal: ntStatus = %lx, iosb.Status = %lx\n"),
                ntStatus, IoStatusBlock.Status);

        if (STATUS_DISK_FULL == ntStatus) {
            WsbThrow(WSB_E_USNJ_CREATE_DISK_FULL);
        } else if (!NT_SUCCESS(ntStatus)) {
            WsbThrow(WSB_E_USNJ_CREATE);
        }

        WsbAffirmNtStatus(ntStatus);

    } WsbCatch( hr );


    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    WsbTraceOut(OLESTR("WsbCreateUsnJournal"), OLESTR("Hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}




HRESULT
WsbGetUsnJournalId(
    OLECHAR*        volName,
    ULONGLONG*      usnId
    )  

/*++

Routine Description:

    Get the current USN Journal ID

Arguments:

    volName -   Volume name (d:\)

    usnId   -   Id is returned here.

Return Value:

    S_OK   - success

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    NTSTATUS            ntStatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    USN_JOURNAL_DATA    usnData;

    WsbTraceIn(OLESTR("WsbGetUsnJournalId"), OLESTR("volName = %ls"), volName);

    try {
        WsbAffirmPointer(usnId);
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);
                
        *usnId = (ULONGLONG) 0;
        ntStatus = NtFsControlFile( volHandle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        FSCTL_QUERY_USN_JOURNAL,
                                        NULL,
                                        0,
                                        &usnData,
                                        sizeof(usnData));

        WsbTrace(OLESTR("WsbGetUsnJournalId: ntStatus = %lx, iosb.Status = %lx\n"),
                ntStatus, IoStatusBlock.Status);

        if (STATUS_JOURNAL_NOT_ACTIVE == ntStatus) {
            WsbThrow(WSB_E_NOTFOUND);
        }

        WsbAffirmNtStatus(ntStatus);
        
        *usnId = usnData.UsnJournalID;

    } WsbCatch( hr );


    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    WsbTraceOut(OLESTR("WsbGetUsnJournalId"), OLESTR("Hr = <%ls>, id = %I64x"),
            WsbHrAsString(hr), *usnId);

    return( hr );
}


//  Local functions
static HANDLE OpenVol(OLECHAR* volName)
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    CWsbStringPtr       name;
    WCHAR               *vPtr;

    try {
        name = volName;

        if (name == NULL) {
            WsbThrow(E_OUTOFMEMORY);
        }

        if (name[1] == L':') {
            swprintf((OLECHAR*) name, L"%2.2s", volName);
        } else {
            //
            // Must be a volume without a drive letter
            // Move to end of PNPVolumeName...

            vPtr = name;
            vPtr = wcsrchr(vPtr, L'\\');
            if (NULL != vPtr) {
                *vPtr = L'\0';
            }
        }

        WsbAffirmHr(name.Prepend(OLESTR("\\\\.\\")));
        WsbAffirmHandle(volHandle = CreateFile( name,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL ));

    } WsbCatchAndDo( hr,

        if (INVALID_HANDLE_VALUE != volHandle) {
            CloseHandle(volHandle);
        }
        volHandle = INVALID_HANDLE_VALUE;
    )
    return(volHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\cachesup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CacheSup.c

Abstract:

    This module provides an interface with the cache manager.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"
#include <ntdddisk.h>
#include <NtIoLogc.h>
#include <elfmsg.h>

//
//  The debug trace level
//

#define Dbg                             (DEBUG_TRACE_CACHE_SUP)

//
//  Following is used to generate a sequence number when the cache manager
//  gives us a page of zeroes.  Otherwise all of the sequence numbers will
//  be 1.
//

USHORT LfsUsaSeqNumber;

LARGE_INTEGER LiMinus1 = {(ULONG)-1,-1};


BOOLEAN
LfsIsRestartPageHeaderValid (
    IN LONGLONG FileOffset,
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    OUT PBOOLEAN LogPacked
    );

BOOLEAN
LfsIsRestartAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked
    );

BOOLEAN
LfsIsClientAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked,
    IN BOOLEAN UsaError
    );

VOID
LfsFindFirstIo (
    IN PLFCB Lfcb,
    IN LSN TargetLsn,
    IN BOOLEAN RestartLsn,
    IN PLBCB FirstLbcb,
    OUT PLBCB *NextLbcb,
    OUT PLONGLONG FileOffset,
    OUT PBOOLEAN ContainsLastEntry,
    OUT PBOOLEAN LfsRestart,
    OUT PBOOLEAN UseTailCopy,
    OUT PULONG IoBlocks
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsCopyReadLogRecord)
#pragma alloc_text(PAGE, LfsFindFirstIo)
#pragma alloc_text(PAGE, LfsIsClientAreaValid)
#pragma alloc_text(PAGE, LfsIsRestartAreaValid)
#pragma alloc_text(PAGE, LfsIsRestartPageHeaderValid)
#pragma alloc_text(PAGE, LfsPinOrMapData)
#pragma alloc_text(PAGE, LfsPinOrMapLogRecordHeader)
#pragma alloc_text(PAGE, LfsReadRestart)
#endif


NTSTATUS
LfsPinOrMapData (
    IN PLFCB Lfcb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN PinData,
    IN BOOLEAN AllowErrors,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PVOID *Buffer,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine will pin or map a portion of the log file.

Arguments:

    Lfcb - This is the file control block for the log file.

    FileOffset - This is the offset of the log page to pin.

    Length - This is the length of the data to access.

    PinData - Boolean indicating if we are to pin or map this data.

    AllowErrors - This boolean indicates whether we should raise on an
        I/O error or return on an I/O error.

    IgnoreUsaErrors - Boolean indicating whether we will raise on Usa
        errors.

    UsaError - Address to store whether the Usa had an error.

    Buffer - This is the address to store the address of the data.

    Bcb - This is the Bcb for this operation.

Return Value:

    NTSTATUS - The result of the I/O.

--*/

{
    volatile NTSTATUS Status;
    ULONG Signature;
    BOOLEAN Result = FALSE;

    Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsPinReadLogPage:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "FileOffset (Low)  -> %08lx\n", FileOffset.HighPart );
    DebugTrace(  0, Dbg, "FileOffset (High) -> %08lx\n", FileOffset.LowPart );
    DebugTrace(  0, Dbg, "Length            -> %08lx\n", Length );
    DebugTrace(  0, Dbg, "PinData           -> %04x\n", PinData );
    DebugTrace(  0, Dbg, "AllowErrors       -> %08x\n", AllowErrors );
    DebugTrace(  0, Dbg, "IgnoreUsaErrors   -> %04x\n", IgnoreUsaErrors );

    if (FileOffset + Length > Lfcb->FileSize) {
        ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Use a try-except to catch cache manager errors.
        //

        try {

            //
            //  We call the cache to perform the work.
            //

            if (PinData) {

                Result = CcPinRead( Lfcb->FileObject,
                                    (PLARGE_INTEGER)&FileOffset,
                                    Length,
                                    TRUE,
                                    Bcb,
                                    Buffer );

            } else {

                Result = CcMapData( Lfcb->FileObject,
                                    (PLARGE_INTEGER)&FileOffset,
                                    Length,
                                    TRUE,
                                    Bcb,
                                    Buffer );
            }

            //
            //  Capture the signature now while we are within the
            //  exception filter.
            //

            Signature = *((PULONG) *Buffer);

        } except( LfsExceptionFilter( GetExceptionInformation() )) {

            Status = GetExceptionCode();
            if (Result) {
                CcUnpinData( *Bcb );
                *Bcb = NULL;
            }
        }

        *UsaError = FALSE;

        //
        //  If an error occurred, we raise the status.
        //

        if (!NT_SUCCESS( Status )) {

            if (!AllowErrors) {

                DebugTrace( 0, Dbg, "Read on log page failed -> %08lx\n", Status );
                ExRaiseStatus( Status );
            }

            //
            //  Check that the update sequence array for this
            //  page is valid.
            //

        } else if (Signature == LFS_SIGNATURE_BAD_USA_ULONG) {

            //
            //  If we don't allow errors, raise an error status.
            //

            if (!IgnoreUsaErrors) {

                DebugTrace( 0, Dbg, "Usa error on log page\n", 0 );
                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            *UsaError = TRUE;
        }

    } finally {

        DebugUnwind( LfsPinOrMapData );

        DebugTrace(  0, Dbg, "Buffer    -> %08lx\n", *Buffer );
        DebugTrace(  0, Dbg, "Bcb       -> %08lx\n", *Bcb );

        DebugTrace( -1, Dbg, "LfsPinOrMapData:  Exit -> %08lx\n", Status );
    }

    return Status;
}


VOID
LfsPinOrMapLogRecordHeader (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN BOOLEAN PinData,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PLFS_RECORD_HEADER *RecordHeader,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine will pin or map a log record for read access.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lsn - This is the Lsn whose header should be pinned.

    PinData - Boolean indicating if we are to pin or map this data.

    IgnoreUsaErrors - Boolean indicating whether we will raise on Usa
        errors.

    UsaError - Address to store whether the Usa had an error.

    RecordHeader - This is the address to store the address of the pinned data.

    Bcb - This is the Bcb for this pin operation.

Return Value:

    None.

--*/

{
    PLFS_RECORD_PAGE_HEADER LogPageHeader;
    LONGLONG LogPage;
    ULONG PageOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsPinOrMapLogRecordHeader:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb       -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lsn (Low)  -> %08lx\n", Lsn.HighPart );
    DebugTrace(  0, Dbg, "Lsn (High) -> %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "PinData           -> %04x\n", PinData );
    DebugTrace(  0, Dbg, "IgnoreUsaErrors   -> %04x\n", IgnoreUsaErrors );

    //
    //  Compute the log page and the offset of the log record header
    //  in the log page.
    //

    LfsTruncateLsnToLogPage( Lfcb, Lsn, &LogPage );
    PageOffset = LfsLsnToPageOffset( Lfcb, Lsn );

    //
    //  Call the cache manager to pin the page.
    //

    LfsPinOrMapData( Lfcb,
                     LogPage,
                     (ULONG)Lfcb->LogPageSize,
                     PinData,
                     FALSE,
                     IgnoreUsaErrors,
                     UsaError,
                     (PVOID *) &LogPageHeader,
                     Bcb );

    //
    //  The actual offset we need is at PageOffset from the start of the page.
    //

    *RecordHeader = Add2Ptr( LogPageHeader, PageOffset, PLFS_RECORD_HEADER );

    DebugTrace(  0, Dbg, "Record Header -> %08lx\n", *RecordHeader );
    DebugTrace(  0, Dbg, "Bcb           -> %08lx\n", *Bcb );

    DebugTrace( -1, Dbg, "LfsPinOrMapLogRecordHeader:  Exit\n", 0 );

    return;
}


VOID
LfsCopyReadLogRecord (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    This routines copies a log record from the file to a buffer.  The log
    record may span several log pages and may even wrap in the file.

Arguments:

    Lfcb - A pointer to the control block for the log file.

    RecordHeader - Pointer to the log record header for this log record.

    Buffer - Pointer to the buffer to store the log record.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;
    BOOLEAN UsaError;

    PLFS_RECORD_PAGE_HEADER PageHeader;

    LONGLONG LogPageFileOffset;
    ULONG LogPageOffset;

    ULONG RemainingTransferBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCopyReadLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb           -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RecordHeader   -> %08lx\n", RecordHeader );
    DebugTrace(  0, Dbg, "Buffer         -> %08lx\n", Buffer );

    //
    //  We find the file offset of the log page containing the start of
    //  this log record, the offset within the page to start the transfer from,
    //  the number of bytes to transfer on this page and the starting
    //  position in the buffer to begin the transfer to.
    //

    LfsTruncateLsnToLogPage( Lfcb, RecordHeader->ThisLsn, &LogPageFileOffset );
    LogPageOffset = LfsLsnToPageOffset( Lfcb, RecordHeader->ThisLsn ) + Lfcb->RecordHeaderLength;

    RemainingTransferBytes = RecordHeader->ClientDataLength;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  While there are more bytes to transfer, we continue to attempt to
        //  perform the read.
        //

        while (TRUE) {

            ULONG RemainingPageBytes;

            BOOLEAN Wrapped;

            RemainingPageBytes = (ULONG)Lfcb->LogPageSize - LogPageOffset;

            //
            //  We compute the number of bytes to read from this log page and
            //  call the cache package to perform the transfer.
            //

            if (RemainingTransferBytes <= RemainingPageBytes) {

                RemainingPageBytes = RemainingTransferBytes;
            }

            RemainingTransferBytes -= RemainingPageBytes;

            //
            //  Unpin any previous buffer.
            //

            if (Bcb != NULL) {

                CcUnpinData( Bcb );
                Bcb = NULL;
            }

            LfsPinOrMapData( Lfcb,
                             LogPageFileOffset,
                             (ULONG)Lfcb->LogPageSize,
                             FALSE,
                             FALSE,
                             TRUE,
                             &UsaError,
                             (PVOID *) &PageHeader,
                             &Bcb );

            //
            //  The last Lsn on this page better be greater or equal to the Lsn we
            //  are copying.
            //

            if ( PageHeader->Copy.LastLsn.QuadPart < RecordHeader->ThisLsn.QuadPart ) {

                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            RtlCopyMemory( Buffer,
                           Add2Ptr( PageHeader, LogPageOffset, PVOID ),
                           RemainingPageBytes );

            //
            //  If there are no more bytes to transfer, we exit the loop.
            //

            if (RemainingTransferBytes == 0) {

                //
                //  Our log record better not span this page.
                //

                if (!FlagOn( PageHeader->Flags, LOG_PAGE_LOG_RECORD_END )

                    || (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
                        && ( RecordHeader->ThisLsn.QuadPart > PageHeader->Header.Packed.LastEndLsn.QuadPart ))) {

                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                }

                break;
            }

            //
            //  If the page header indicates that the log record ended on this page,
            //  this is a disk corrupt condition.  For a packed page it means
            //  that the last Lsn and the last Ending Lsn are the same.
            //

            if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

                //
                //  If there is no spanning log record this is an error.
                //

                if (( PageHeader->Copy.LastLsn.QuadPart == PageHeader->Header.Packed.LastEndLsn.QuadPart )

                    || ( RecordHeader->ThisLsn.QuadPart > PageHeader->Copy.LastLsn.QuadPart )) {

                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                }

                //
                //  For an unpacked page it simply means that the page
                //  contains the end of a log record.
                //

            } else if (FlagOn( PageHeader->Flags, LOG_PAGE_LOG_RECORD_END )) {

                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            //
            //  We find the start of the next log page and the offset within
            //  that page to start transferring bytes.
            //

            LfsNextLogPageOffset( Lfcb,
                                  LogPageFileOffset,
                                  &LogPageFileOffset,
                                  &Wrapped );

            LogPageOffset = (ULONG)Lfcb->LogPageDataOffset;

            //
            //  We also adjust our pointer in the user's buffer to transfer
            //  the next block to.
            //

            Buffer = Add2Ptr( Buffer, RemainingPageBytes, PVOID );
        }

    } finally {

        //
        //  Unpin any previous buffer.
        //

        if (Bcb != NULL) {

            CcUnpinData( Bcb );
            Bcb = NULL;
        }

        DebugTrace( -1, Dbg, "LfsCopyReadLogRecord:  Exit\n", 0 );
    }

    return;
}


VOID
LfsFlushLfcb (
    IN PLFCB Lfcb,
    IN LSN TargetLsn,
    IN BOOLEAN RestartLsn
    )

/*++

Routine Description:

    This routine is called to flush the current Lbcbs in on the Lfcb
    work queue.  It will flush up to the I/O which contains the desired
    TargetLsn.  It should be called with LfsIoState already set - this will be cleared
    on finish. At periodic points the sync event will be pulsed to wake up waiter threads

Arguments:

    Lfcb - This is the file control block for the log file.

    TargetLsn - This is the Lsn which is needed to be flushed to disk.
                if it is greater than the current lsn everything will get flushed
                
    Restart - if true the target lsn is an lfs restart pseudo lsn                

Return Value:

    None.

--*/

{
    PLBCB FirstLbcb;
    PLBCB ThisLbcb;
    PLBCB NextLbcb;

    PLBCB TargetLbcb;
    PULONG Signature;

    LONGLONG FileOffset;
    ULONG Length;

    BOOLEAN ValidLastLsn = FALSE;

    BOOLEAN ContainsLastEntry = FALSE;
    BOOLEAN LfsRestart;
    BOOLEAN UseTailCopy;
    
    ULONG IoBlocks;
    ULONG NewLfcbFlags = 0;

    PBCB MapPageBcb = NULL;

    LSN LastLsn;

    IO_STATUS_BLOCK Iosb;

    PBCB PageBcb = NULL;
    NTSTATUS FailedFlushStatus = STATUS_SUCCESS;
    LONGLONG FailedFlushOffset;

    KEVENT Event;

    PLFS_WAITER LfsWaiter;

    BOOLEAN OwnedExclusive;

    DebugTrace( +1, Dbg, "LfsFlushLfcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT(!(BooleanFlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    OwnedExclusive = ExIsResourceAcquiredExclusiveLite( &Lfcb->Sync->Resource );

    try {

        //
        //  If there are no elements on the list, we are done.
        //

        if (IsListEmpty( &Lfcb->LbcbWorkque )) {
            leave;
        }

        KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

        //
        //  Convert max lsn to the last lsn currently on the list - current lsn will
        //  not change since we hold the lfcb at least shared at this point and writers
        //  need it exclusive
        //  

        if (TargetLsn.QuadPart > Lfcb->RestartArea->CurrentLsn.QuadPart) {

            ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbWorkque.Blink,
                                          LBCB,
                                          WorkqueLinks );

            TargetLsn.QuadPart = ThisLbcb->LastLsn.QuadPart;
            RestartLsn = (BOOLEAN) LfsLbcbIsRestart( ThisLbcb );
        }


        //
        //  Remember the first Lbcb in the list.
        //

        FirstLbcb = CONTAINING_RECORD( Lfcb->LbcbWorkque.Flink,
                                       LBCB,
                                       WorkqueLinks );

        ASSERT( FirstLbcb != NULL );

        //
        //  We continue looping and performing I/o for as long as possible.
        //

        while (!ContainsLastEntry) {

            ASSERT( FirstLbcb != NULL );


            //
            //  Find the block of Lbcb's that make up the first I/O, remembering
            //  how many there are.  Also remember if this I/O contains the
            //  last element on the list when we were called.
            //

            LfsFindFirstIo( Lfcb,
                            TargetLsn,
                            RestartLsn,
                            FirstLbcb,
                            &NextLbcb,
                            &FileOffset,
                            &ContainsLastEntry,
                            &LfsRestart,
                            &UseTailCopy,
                            &IoBlocks );

            Length = IoBlocks * (ULONG) Lfcb->LogPageSize;
            if (UseTailCopy) {

                TargetLbcb = Lfcb->ActiveTail;
                Lfcb->ActiveTail = Lfcb->PrevTail;
                Lfcb->PrevTail = TargetLbcb;

                FileOffset = TargetLbcb->FileOffset;

            } else {

                TargetLbcb = FirstLbcb;
            }

            //
            //  Give up the Lfcb unless we are looking at an active page.
            //

            if (!UseTailCopy) {

                LfsReleaseLfcb( Lfcb );
            }

            //
            //  If this I/O involves the Lfs restart area, write it to the
            //  cache pages.
            //

            if (LfsRestart) {

                PLFS_RESTART_PAGE_HEADER RestartPage;

                ASSERT( !UseTailCopy && IoBlocks == 1);

                //
                //  Build the partial mdl to describe this lfs restart page from the permanently
                //  mapped piece of the log
                //

                RestartPage = Add2Ptr( Lfcb->LogHeadBuffer, FileOffset, PLFS_RESTART_PAGE_HEADER );
                IoBuildPartialMdl( Lfcb->LogHeadMdl, Lfcb->LogHeadPartialMdl, RestartPage, (ULONG)Lfcb->LogPageSize );

                //
                //  Initialize the restart page header.
                //

                Signature = (PULONG) &RestartPage->MultiSectorHeader.Signature;

                *Signature = LFS_SIGNATURE_RESTART_PAGE_ULONG;
                RestartPage->ChkDskLsn = LfsLi0;

                RestartPage->MultiSectorHeader.UpdateSequenceArrayOffset
                = Lfcb->RestartUsaOffset;

                RestartPage->MultiSectorHeader.UpdateSequenceArraySize
                = Lfcb->UsaArraySize;

                //
                //  Maintain the illusion that all systems have log page == system page
                //  on disk so we can migrate disks between different platforms
                //

                RestartPage->SystemPageSize = (ULONG)Lfcb->LogPageSize;
                RestartPage->LogPageSize = (ULONG)Lfcb->LogPageSize;

                RestartPage->RestartOffset = (USHORT) Lfcb->RestartDataOffset;
                RestartPage->MajorVersion = Lfcb->MajorVersion;
                RestartPage->MinorVersion = Lfcb->MinorVersion;

                //
                //  If the Lfcb indicates that the file has wrapped, then clear the
                //  first pass flag in the restart area.
                //

                if (FlagOn( Lfcb->Flags, LFCB_LOG_WRAPPED )) {

                    ClearFlag( ((PLFS_RESTART_AREA) FirstLbcb->PageHeader)->Flags, RESTART_SINGLE_PAGE_IO );
                    SetFlag( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO );
                }

                //
                //  Write the page header into the page and mark the page dirty.
                //

                RtlCopyMemory( Add2Ptr( RestartPage, Lfcb->RestartDataOffset, PVOID ),
                               FirstLbcb->PageHeader,
                               (ULONG)FirstLbcb->Length );

                LastLsn = FirstLbcb->LastLsn;
                ValidLastLsn = TRUE;

#ifdef LFS_CLUSTER_CHECK
                //
                //  Update the Lsn range on the disk.
                //

                *(Add2Ptr( RestartPage, 0xe00 - sizeof( ULONG ), PULONG )) = Lfcb->LsnRangeIndex + 1;
                *(Add2Ptr( RestartPage, 0xe00 + (sizeof( LSN ) * Lfcb->LsnRangeIndex * 2), PLSN )) = Lfcb->LsnAtMount;
                *(Add2Ptr( RestartPage, 0xe00 + (sizeof( LSN ) * (Lfcb->LsnRangeIndex * 2 + 1)), PLSN )) = Lfcb->LastFlushedLsn;

#endif
                //
                //  Use a system page size as the length we need to flush.
                //

                Length = (ULONG)Lfcb->LogPageSize;

                //
                //  Otherwise these are log record pages
                //

            } else {

                PLFS_RECORD_PAGE_HEADER RecordPageHeader;
                ULONG Count;

                //
                //  Mark the last Lsn fields for the page headers and each
                //  page's position in the transfer.  Also unpin all of the
                //  log pages.
                //


                ASSERT( UseTailCopy || FirstLbcb->FileOffset == FileOffset );

                ThisLbcb = FirstLbcb;

                for (Count=1; Count <= IoBlocks; Count++) {

                    if (UseTailCopy) {

                        //
                        //  Build the partial mdl to describe the tail (pin/pong) page
                        //  from the permanently mapped section of the log
                        //

                        RecordPageHeader = Add2Ptr( Lfcb->LogHeadBuffer, TargetLbcb->FileOffset, PLFS_RECORD_PAGE_HEADER );
                        IoBuildPartialMdl( Lfcb->LogHeadMdl, Lfcb->LogHeadPartialMdl, RecordPageHeader, (ULONG)Lfcb->LogPageSize );

                        //
                        //  Store the file offset of the real page in the header.
                        //  Also set the flag indicating the page is a tail copy.
                        //

                        RtlCopyMemory( RecordPageHeader,
                                       ThisLbcb->PageHeader,
                                       (ULONG)Lfcb->LogPageSize );

                        RecordPageHeader->Copy.FileOffset = ThisLbcb->FileOffset;

                    } else {

                        PUSHORT SeqNumber;

                        RecordPageHeader = (PLFS_RECORD_PAGE_HEADER) ThisLbcb->PageHeader;

                        //
                        //  If the sequence number is zero then this is probably a
                        //  page of zeroes produced by the cache manager.  In order
                        //  to insure that we don't have the same sequence number
                        //  on each page we will seed the sequence number.
                        //

                        SeqNumber = Add2Ptr( RecordPageHeader,
                                             Lfcb->LogRecordUsaOffset,
                                             PUSHORT );

                        if (*SeqNumber == 0) {

                            *SeqNumber = LfsUsaSeqNumber;
                            LfsUsaSeqNumber += 1;
                        }
                    }

                    //
                    //  We update all of fields as yet not updated.
                    //

                    RecordPageHeader->PagePosition = (USHORT) Count;
                    RecordPageHeader->PageCount = (USHORT) IoBlocks;

                    //
                    //  We set up the update sequence array for this structure.
                    //

                    Signature = (PULONG) &RecordPageHeader->MultiSectorHeader.Signature;
                    *Signature = LFS_SIGNATURE_RECORD_PAGE_ULONG;

                    RecordPageHeader->MultiSectorHeader.UpdateSequenceArrayOffset = Lfcb->LogRecordUsaOffset;
                    RecordPageHeader->MultiSectorHeader.UpdateSequenceArraySize = Lfcb->UsaArraySize;

                    //
                    //  Make sure the modified bit gets set in the pfn database.  The
                    //  cache manager should do this even for files we told him not to
                    //  lazy write.
                    //

                    if (!UseTailCopy) {

                        CcSetDirtyPinnedData( ThisLbcb->LogPageBcb, NULL );

                        //
                        //  We unpin any buffers pinned on this page.
                        //

                        CcUnpinDataForThread( ThisLbcb->LogPageBcb, ThisLbcb->ResourceThread );
                        ThisLbcb->LogPageBcb = NULL;
                    }

                    //
                    //  Remember the last lsn and its length if this is the final
                    //  page of an Lsn.
                    //

                    if (FlagOn( ThisLbcb->Flags, LOG_PAGE_LOG_RECORD_END )) {

                        LastLsn = ThisLbcb->LastEndLsn;
                        ValidLastLsn = TRUE;
                    }

                    //
                    //  Otherwise move to the next entry.
                    //

                    ThisLbcb = CONTAINING_RECORD( ThisLbcb->WorkqueLinks.Flink,
                                                  LBCB,
                                                  WorkqueLinks );
                }
            }

            //
            //  Remember the range we are flushing and find the second half of a page
            //  if necessary.
            //

            Lfcb->UserWriteData->FileOffset = FileOffset;
            Lfcb->UserWriteData->Length = Length;

            //
            //  For the loghead pages (2 lfs restart pages and 2 ping pong pages
            //  explicitly flush them down using the partial mdl we built
            //  The regular cc logic w/ UserWriteData  that pares the write down
            //  to the correct offsets works here as well
            //

            if (LfsRestart || UseTailCopy) {

                NTSTATUS Status;

                ASSERT( IoBlocks == 1 );

                //
                //  We can release the lfcb now that we've finished using the active page
                //  

                if (UseTailCopy) {
                    LfsReleaseLfcb( Lfcb );
                }

                Status = IoSynchronousPageWrite( Lfcb->FileObject,
                                                 Lfcb->LogHeadPartialMdl,
                                                 (PLARGE_INTEGER)&FileOffset,
                                                 &Event,
                                                 &Iosb );

                if (Status == STATUS_PENDING) {
                    Status = KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
                }

                if (!NT_SUCCESS( Status ) || !NT_SUCCESS( Iosb.Status)) {

                    //
                    //  Record status if we haven't failed already and continue on
                    //

                    if (NT_SUCCESS( FailedFlushStatus )) {
                        if (!NT_SUCCESS( Status )) {
                            FailedFlushStatus = Status;
                        } else if (!NT_SUCCESS( Iosb.Status )) {
                            FailedFlushStatus = Iosb.Status;
                        }
                        FailedFlushOffset = FileOffset;

#ifdef LFS_CLUSTER_CHECK
                        //
                        //  Remember this to figure out naggin cluster problems.
                        //

                        if ((Status == STATUS_DEVICE_OFF_LINE) ||
                            (Iosb.Status == STATUS_DEVICE_OFF_LINE)) {

                            SetFlag( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN );
                        }

                        //
                        //  Remember all errors.
                        //

                        SetFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
#endif
                    }

#ifdef LFS_CLUSTER_CHECK
                } else if (Iosb.Information != 0) {

                    //
                    //  Once OFFLINE, always OFFLINE.
                    //

                    ASSERT( !FlagOn( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN ));

                    //
                    //  Catch the first write after a failed IO.
                    //

                    if (LfsTestBreakOnAnyError &&
                        FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED )) {

                        ASSERT( !LfsTestBreakOnAnyError ||
                                !FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED ));

                        ClearFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
                    }
#endif
                }

            } else {

                //
                //  This is a normal log page so flush through the cache
                //

                CcFlushCache( Lfcb->FileObject->SectionObjectPointer,
                              (PLARGE_INTEGER)&FileOffset,
                              Length,
                              &Iosb );

                if (!NT_SUCCESS( Iosb.Status )) {

                    LONG BytesRemaining = (LONG) Length;

                    //
                    //  If we get an error then try each individual page.
                    //

                    while (BytesRemaining > 0) {

                        //
                        //  Remember the range we are flushing and find the second half of a page
                        //  if necessary.
                        //

                        ASSERT( Length >= Lfcb->LogPageSize );

                        Lfcb->UserWriteData->FileOffset = FileOffset;
                        Lfcb->UserWriteData->Length = (ULONG)Lfcb->LogPageSize;

                        CcFlushCache( Lfcb->FileObject->SectionObjectPointer,
                                      (PLARGE_INTEGER)&FileOffset,
                                      (ULONG)Lfcb->LogPageSize,
                                      &Iosb );

                        if (!NT_SUCCESS( Iosb.Status )) {

                            if (NT_SUCCESS( FailedFlushStatus )) {
                                FailedFlushStatus = Iosb.Status;
                                FailedFlushOffset = FileOffset;
#ifdef LFS_CLUSTER_CHECK
                                //
                                //  Remember this to figure out naggin cluster problems.
                                //

                                if (FailedFlushStatus == STATUS_DEVICE_OFF_LINE) {

                                    SetFlag( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN );
                                }

                                //
                                //  Remember all errors.
                                //

                                SetFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
#endif
                            }
#ifdef LFS_CLUSTER_CHECK
                        } else if (Iosb.Information != 0) {

                            //
                            //  Once OFFLINE, always OFFLINE.
                            //

                            ASSERT( !FlagOn( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN ));

                            //
                            //  Catch the first write after a failed IO.
                            //

                            if (LfsTestBreakOnAnyError &&
                                FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED )) {

                                ASSERT( !LfsTestBreakOnAnyError ||
                                        !FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED ));

                                ClearFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
                            }
#endif
                        }
                        BytesRemaining -= (LONG)Lfcb->LogPageSize;
                        FileOffset = FileOffset + Lfcb->LogPageSize;
                    }
                }
            }

            //
            //  Reacquire the Lfcb at the original state to modify fields within it 
            //
            
            if (OwnedExclusive) {
                LfsAcquireLfcbExclusive( Lfcb );
            } else {
                LfsAcquireLfcbShared( Lfcb );
            }

            //
            //  Update the last flushed Lsn value if its valid
            //

            if (ValidLastLsn) {

                //
                //  Acquire synchronization to change the field
                //  

                ExAcquireFastMutexUnsafe( &Lfcb->Sync->Mutex );
                if (LfsRestart) {
                    Lfcb->LastFlushedRestartLsn = LastLsn;
                } else {
                    Lfcb->LastFlushedLsn = LastLsn;
                }

                //
                //   And also wake any waiters who have been satisfied
                //  

                LfsWaiter = (PLFS_WAITER)Lfcb->WaiterList.Flink;

                while ((PVOID)LfsWaiter != &Lfcb->WaiterList) {

                    if (LastLsn.QuadPart > LfsWaiter->Lsn.QuadPart ) {

                        RemoveEntryList( &LfsWaiter->Waiters );
                        KeSetEvent( &LfsWaiter->Event, 0, FALSE );

                        LfsWaiter = (PLFS_WAITER)Lfcb->WaiterList.Flink;
                    } else {
                        break;
                    }
                }
                ExReleaseFastMutexUnsafe( &Lfcb->Sync->Mutex );
            }

            if (LfsRestart) {

                //
                //  Clear any neccessary flags on a successful operation.
                //

                if (NT_SUCCESS( FailedFlushStatus )) {

                    ClearFlag( Lfcb->Flags, NewLfcbFlags );
                    NewLfcbFlags = 0;
                }

                //
                //  If this is the first write of a restart area and we have
                //  updated the LogOpenCount then update the field in the Lfcb.
                //

                if (NT_SUCCESS( Iosb.Status ) &&
                    (Lfcb->CurrentOpenLogCount != ((PLFS_RESTART_AREA) FirstLbcb->PageHeader)->RestartOpenLogCount)) {

                    Lfcb->CurrentOpenLogCount = ((PLFS_RESTART_AREA) FirstLbcb->PageHeader)->RestartOpenLogCount;
                }
            }

            //
            //  Walk through all the Lbcb's we flushed, deallocating the Lbcbs.
            //

            if (!UseTailCopy) {

                PLBCB TempLbcb;

                for (ThisLbcb = FirstLbcb; IoBlocks > 0; IoBlocks -= 1) {

                    //
                    //  Remember the next entry on the list.
                    //

                    TempLbcb = CONTAINING_RECORD( ThisLbcb->WorkqueLinks.Flink,
                                                  LBCB,
                                                  WorkqueLinks );

                    //
                    //  Remove it from the LbcbWorkque queue.
                    //

                    RemoveEntryList( &ThisLbcb->WorkqueLinks );

                    //
                    //  Deallocate the structure.
                    //

                    LfsDeallocateLbcb( Lfcb, ThisLbcb );
                    ThisLbcb = TempLbcb;
                }
            }

            //
            //  Remember the starting Lbcb for the next I/O.
            //

            FirstLbcb = NextLbcb;
        }

    } finally {

        PLFCB_SYNC Sync = Lfcb->Sync;

        DebugUnwind( LfsFlushLfcb );

        //
        //  I expect that we must at least own the lfcb shared at this point to
        //  modify its fields
        // 

        ASSERT( ExIsResourceAcquiredSharedLite( &Sync->Resource ) );

        //
        //  Show that there is no Io in progress. Preset the event but with wait == true sinc
        //  ownership of the event is indicated but the LfsIoState.
        //  This leaves us with the dispatcher db locked so the whole operation is atomic 
        //  until we call delay execution thread
        //

        ExAcquireFastMutexUnsafe(  &Lfcb->Sync->Mutex );
        
        Lfcb->LfsIoThread = 0;
        Sync->LfsIoState = LfsNoIoInProgress;

        //
        //  Wake up any waiters that have been satified + 1 additional if there is one
        //  who can continue flushing
        //  

        LfsWaiter = (PLFS_WAITER)Lfcb->WaiterList.Flink;

        while ((PVOID)LfsWaiter != &Lfcb->WaiterList ) {

            LastLsn.QuadPart = max( Lfcb->LastFlushedLsn.QuadPart, Lfcb->LastFlushedRestartLsn.QuadPart );
            
            if (LastLsn.QuadPart >= LfsWaiter->Lsn.QuadPart) {

                RemoveEntryList( &LfsWaiter->Waiters );
                KeSetEvent( &LfsWaiter->Event, 0, FALSE );
            
            } else {
                
                RemoveEntryList( &LfsWaiter->Waiters );
                KeSetEvent( &LfsWaiter->Event, 0, FALSE );
                break;
            }

            LfsWaiter = (PLFS_WAITER)Lfcb->WaiterList.Flink;
        }

        ExReleaseFastMutexUnsafe(  &Lfcb->Sync->Mutex );

        //
        //  Make sure we didn't leave any pages pinned.
        //

        if (PageBcb != NULL) {

            CcUnpinData( PageBcb );
        }

        DebugTrace( -1, Dbg, "LfsFlushLfcb:  Exit\n", 0 );
    }

    //
    //  If the Io failed at some point, we log the error in the eventlog if possible
    //  and note it in the lfs restart area
    //

    if (!NT_SUCCESS( FailedFlushStatus )) {

        PIO_ERROR_LOG_PACKET ErrorLogEntry;

        //
        //  Note failure in restart area - acquire synchronization to access lastflushedlsn
        //

        ExAcquireFastMutexUnsafe(  &Lfcb->Sync->Mutex );

        Lfcb->RestartArea->LastFailedFlushOffset = FailedFlushOffset;
        Lfcb->RestartArea->LastFailedFlushStatus = FailedFlushStatus;
        Lfcb->RestartArea->LastFailedFlushLsn = Lfcb->LastFlushedLsn;

        ExReleaseFastMutexUnsafe(  &Lfcb->Sync->Mutex );

        if (Lfcb->ErrorLogPacket != NULL) {
            ErrorLogEntry = Lfcb->ErrorLogPacket;
            Lfcb->ErrorLogPacket = NULL;
        } else {
            ErrorLogEntry = IoAllocateErrorLogEntry( Lfcb->FileObject->DeviceObject, ERROR_LOG_MAXIMUM_SIZE );
        }

        if (ErrorLogEntry != NULL) {
            ErrorLogEntry->EventCategory = ELF_CATEGORY_DISK;
            ErrorLogEntry->ErrorCode = IO_WARNING_LOG_FLUSH_FAILED;
            ErrorLogEntry->FinalStatus = FailedFlushStatus;

            IoWriteErrorLogEntry( ErrorLogEntry );
        }
    }

    //
    //  Try to preallocate another log packet if we don't have one already
    //

    if (Lfcb->ErrorLogPacket == NULL) {
        Lfcb->ErrorLogPacket = IoAllocateErrorLogEntry( Lfcb->FileObject->DeviceObject, ERROR_LOG_MAXIMUM_SIZE );
    }

    return;
}


BOOLEAN
LfsReadRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN BOOLEAN FirstRestart,
    OUT PLONGLONG RestartPageOffset,
    OUT PLFS_RESTART_PAGE_HEADER *RestartPage,
    OUT PBCB *RestartPageBcb,
    OUT PBOOLEAN ChkdskWasRun,
    OUT PBOOLEAN ValidPage,
    OUT PBOOLEAN UninitializedFile,
    OUT PBOOLEAN LogPacked,
    OUT PLSN LastLsn
    )

/*++

Routine Description:

    This routine will walk through 512 blocks of the file looking for a
    valid restart page header.  It will stop the first time we find
    a valid page header.

Arguments:

    Lfcb - This is the Lfcb for the log file.

    FileSize - Size in bytes for the log file.

    FirstRestart - Indicates if we are looking for the first valid
        restart area.

    RestartPageOffset - This is the location to store the offset in the
        file where the log page was found.

    RestartPage - This is the location to store the address of the
        pinned restart page.

    RestartPageBcb - This is the location to store the Bcb for this
        cache pin operation.

    ChkdskWasRun - Address to store whether checkdisk was run on this volume.

    ValidPage - Address to store whether there was valid data on this page.

    UninitializedFile - Address to store whether this is an uninitialized
        log file.  Return value only valid if for the first restart area.

    LogPacked - Address to store whether the log file is packed.

    LastLsn - Address to store the last Lsn for this restart page.  It will be the
        chkdsk value if checkdisk was run.  Otherwise it is the LastFlushedLsn
        for this restart page.

Return Value:

    BOOLEAN - TRUE if a restart area was found, FALSE otherwise.

--*/

{
    ULONG FileOffsetIncrement;
    LONGLONG FileOffset;

    PLFS_RESTART_AREA RestartArea;

    NTSTATUS Status;

    PLFS_RESTART_PAGE_HEADER ThisPage;
    PBCB ThisPageBcb = NULL;

    BOOLEAN FoundRestart = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadRestart:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb   -> %08lx\n", Lfcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    *UninitializedFile = TRUE;
    *ValidPage = FALSE;
    *ChkdskWasRun = FALSE;
    *LogPacked = FALSE;

    try {

        //
        //  Determine which restart area we are looking for.
        //

        if (FirstRestart) {

            FileOffset = 0;
            FileOffsetIncrement = SEQUENCE_NUMBER_STRIDE;

        } else {

            FileOffset = SEQUENCE_NUMBER_STRIDE;
            FileOffsetIncrement = 0;
        }

        //
        //  We loop up to 16 pages  until we succeed, pin a log record page
        //  or exhaust the number of possible tries.
        //

        while ( FileOffset < min( FileSize, 16 * PAGE_SIZE )) {

            ULONG Signature;
            BOOLEAN UsaError;

            if (ThisPageBcb != NULL) {

                CcUnpinData( ThisPageBcb );
                ThisPageBcb = NULL;
            }

            //
            //  Attempt to pin a page header at the current offset.
            //

            Status = LfsPinOrMapData( Lfcb,
                                      FileOffset,
                                      SEQUENCE_NUMBER_STRIDE,
                                      TRUE,
                                      TRUE,
                                      TRUE,
                                      &UsaError,
                                      (PVOID *)&ThisPage,
                                      &ThisPageBcb );

            //
            //
            //  If we succeeded, we look at the 4 byte signature.
            //

            if (NT_SUCCESS( Status )) {

                Signature = *((PULONG) &ThisPage->MultiSectorHeader.Signature);

                //
                //  If the signature is a log record page, we will exit.
                //

                if (Signature == LFS_SIGNATURE_RECORD_PAGE_ULONG) {

                    *UninitializedFile = FALSE;
                    break;
                }

                //
                //  Continue analyzing the page if the signature is chkdsk or
                //  a restart page.
                //

                if (Signature == LFS_SIGNATURE_MODIFIED_ULONG || 
                    Signature == LFS_SIGNATURE_RESTART_PAGE_ULONG) {

                    *UninitializedFile = FALSE;

                    //
                    //  Remember where we found this page.
                    //

                    *RestartPageOffset = FileOffset;

                    //
                    //  Let's check the restart area if this is a valid page.
                    //

                    if (LfsIsRestartPageHeaderValid( FileOffset,
                                                     ThisPage,
                                                     LogPacked )

                        && LfsIsRestartAreaValid( ThisPage, *LogPacked )) {

                        //
                        //  We have a valid restart page header and restart area.
                        //  If chkdsk was run or we have no clients then
                        //  we have no more checking to do.
                        //

                        RestartArea = Add2Ptr( ThisPage,
                                               ThisPage->RestartOffset,
                                               PLFS_RESTART_AREA );

                        if (Signature == LFS_SIGNATURE_RESTART_PAGE_ULONG
                            && RestartArea->ClientInUseList != LFS_NO_CLIENT) {

                            //
                            //  Pin the entire restart area if we didn't have an earlier
                            //

                            CcUnpinData( ThisPageBcb );
                            ThisPageBcb = NULL;

                            Status = LfsPinOrMapData( Lfcb,
                                                      FileOffset,
                                                      ThisPage->SystemPageSize,
                                                      TRUE,
                                                      TRUE,
                                                      TRUE,
                                                      &UsaError,
                                                      (PVOID *)&ThisPage,
                                                      &ThisPageBcb );

                            if (NT_SUCCESS( Status )
                                && LfsIsClientAreaValid( ThisPage, *LogPacked, UsaError )) {

                                *ValidPage = TRUE;

                                RestartArea = Add2Ptr( ThisPage,
                                                       ThisPage->RestartOffset,
                                                       PLFS_RESTART_AREA );
                            }

                        } else {

                            *ValidPage = TRUE;
                        }
                    }

                    //
                    //  If chkdsk was run then update the caller's values and return.
                    //

                    if (Signature == LFS_SIGNATURE_MODIFIED_ULONG) {

                        *ChkdskWasRun = TRUE;

                        *LastLsn = ThisPage->ChkDskLsn;

                        FoundRestart = TRUE;

                        *RestartPageBcb = ThisPageBcb;
                        *RestartPage = ThisPage;

                        ThisPageBcb = NULL;
                        break;
                    }

                    //
                    //  If we have a valid page then copy the values we need from it.
                    //

                    if (*ValidPage) {

                        *LastLsn = RestartArea->CurrentLsn;

                        FoundRestart = TRUE;

                        *RestartPageBcb = ThisPageBcb;
                        *RestartPage = ThisPage;

                        ThisPageBcb = NULL;
                        break;
                    }

                    //
                    //  Remember if the signature does not indicate uninitialized file.
                    //

                } else if (Signature != LFS_SIGNATURE_UNINITIALIZED_ULONG) {

                    *UninitializedFile = FALSE;
                }
            }

            //
            //  Move to the next possible log page.
            //

            FileOffset = FileOffset << 1;

            (ULONG)FileOffset += FileOffsetIncrement;

            FileOffsetIncrement = 0;
        }

    } finally {

        DebugUnwind( LfsReadRestart );

        //
        //  Unpin the log pages if pinned.
        //

        if (ThisPageBcb != NULL) {

            CcUnpinData( ThisPageBcb );
        }

        DebugTrace(  0, Dbg, "RestartPageAddress (Low)  -> %08lx\n", RestartPageAddress->LowPart );
        DebugTrace(  0, Dbg, "RestartPageAddress (High) -> %08lx\n", RestartPageAddress->HighPart );
        DebugTrace(  0, Dbg, "FirstRestartPage          -> %08lx\n", *FirstRestartPage );
        DebugTrace( -1, Dbg, "LfsReadRestart:  Exit\n", 0 );
    }

    return FoundRestart;
}


//
//  Local support routine
//

BOOLEAN
LfsIsRestartPageHeaderValid (
    IN LONGLONG FileOffset,
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    OUT PBOOLEAN LogPacked
    )

/*++

Routine Description:

    This routine is called to verify that the candidate for a restart page
    has no corrupt values in the page header.  It verifies that the restart and
    system page size have only one bit set and are at least the value of
    the update sequence array stride.

Arguments:

    FileOffset - This is the offset in the file of the restart area to examine.
        If this offset is not 0, then it should match the system page size.

    PageHeader - This is the page to examine.

    LogPacked - Address to store whether the log file is packed.

Return Value:

    BOOLEAN - TRUE if there is no corruption in the pool header values.
              FALSE otherwise.

--*/

{
    ULONG SystemPage;
    ULONG LogPageSize;
    ULONG Mask;
    ULONG BitCount;

    USHORT EndOfUsa;

    PAGED_CODE();

    *LogPacked = FALSE;

    //
    //  Copy the values from the page header into the local variables.
    //

    SystemPage = PageHeader->SystemPageSize;
    LogPageSize = PageHeader->LogPageSize;

    //
    //  The system page and log page sizes must be greater or equal to the
    //  update sequence stride.
    //

    if (SystemPage < SEQUENCE_NUMBER_STRIDE
        || LogPageSize < SEQUENCE_NUMBER_STRIDE) {

        return FALSE;
    }

    //
    //  Now we check that the Log page and system page are multiples of two.
    //  They should only have a single bit set.
    //

    for (Mask = 1, BitCount = 0; Mask != 0; Mask = Mask << 1) {

        if (Mask & LogPageSize) {

            BitCount += 1;
        }
    }

    //
    //  If the bit count isn't 1, return false.
    //

    if (BitCount != 1) {

        return FALSE;
    }

    //
    //  Now do the system page size.
    //

    for (Mask = 1, BitCount = 0; Mask != 0; Mask = Mask << 1) {

        if (Mask & SystemPage) {

            BitCount += 1;
        }
    }

    //
    //  If the bit count isn't 1, return false.
    //

    if (BitCount != 1) {

        return FALSE;
    }

    //
    //  Check that if the file offset isn't 0, it is the system page size.
    //

    if (( FileOffset != 0 )
        && ((ULONG)FileOffset != SystemPage)) {

        return FALSE;
    }

    //
    //  We only support major version numbers 0.x and 1.x
    //
    //  Version number beyond 1.0 mean the log file is packed.
    //

    if (PageHeader->MajorVersion != 0
        && PageHeader->MajorVersion != 1) {

        return FALSE;
    }

    //
    //  Check that the restart area offset is within the system page and that
    //  the restart length field will fit within the system page size.
    //

    if (QuadAlign( PageHeader->RestartOffset ) != PageHeader->RestartOffset
        || PageHeader->RestartOffset > (USHORT) PageHeader->SystemPageSize) {

        return FALSE;
    }

    //
    //  Check that the restart offset will lie beyond the Usa Array for this page.
    //

    EndOfUsa = (USHORT) (UpdateSequenceArraySize( PageHeader->SystemPageSize )
                         * sizeof( UPDATE_SEQUENCE_NUMBER ));

    EndOfUsa += PageHeader->MultiSectorHeader.UpdateSequenceArrayOffset;

    if (PageHeader->RestartOffset < EndOfUsa) {

        return FALSE;
    }

    //
    //  Check if the log pages are packed.
    //

    if (PageHeader->MajorVersion == 1
        && PageHeader->MinorVersion > 0) {

        *LogPacked = TRUE;
    }

    //
    //  Otherwise the page header is valid.
    //

    return TRUE;
}


//
//  Local support routine
//

BOOLEAN
LfsIsRestartAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked
    )

/*++

Routine Description:

    This routine is called to verify that the restart area attached to the
    log page header is valid.  The restart values must be contained within
    the first Usa stride of the file.  This is so we can restart successfully
    after chkdsk.

Arguments:

    PageHeader - This is the page to examine.

    LogPacked - Indicates if the log file is packed.

Return Value:

    BOOLEAN - TRUE if there is no corruption in the restart area values.
              FALSE otherwise.

--*/

{
    PLFS_RESTART_AREA RestartArea;
    ULONG OffsetInRestart;
    ULONG SeqNumberBits;

    LONGLONG FileSize;

    PAGED_CODE();

    //
    //  The basic part of the restart area must fit into the first stride of
    //  the page.  This will allow chkdsk to work even if there are Usa errors.
    //

    OffsetInRestart = FIELD_OFFSET( LFS_RESTART_AREA, FileSize );

    if ((PageHeader->RestartOffset + OffsetInRestart) > FIRST_STRIDE) {

        return FALSE;
    }

    RestartArea = Add2Ptr( PageHeader, PageHeader->RestartOffset, PLFS_RESTART_AREA );

    //
    //  Everything in the restart area except the actual client array must also
    //  be in the first stride.  If the structure is packed, then we can use
    //  a field in the restart area for the client offset.
    //

    if (LogPacked) {

        OffsetInRestart = RestartArea->ClientArrayOffset;

    } else {

        //
        //  We shouldn't see any of the older disks now.
        //

        OffsetInRestart = FIELD_OFFSET( LFS_OLD_RESTART_AREA, LogClientArray );
    }

    if (QuadAlign( OffsetInRestart ) != OffsetInRestart
        || (PageHeader->RestartOffset + OffsetInRestart) > FIRST_STRIDE) {

        return FALSE;
    }

    //
    //  The full size of the restart area must fit in the system page specified by
    //  the page header.  We compute the size of the restart area by calculating
    //  the space needed by all clients.  We also check the given size of the
    //  restart area.
    //

    OffsetInRestart += (RestartArea->LogClients * sizeof( LFS_CLIENT_RECORD ));

    if (OffsetInRestart > PageHeader->SystemPageSize ) {

        return FALSE;
    }

    //
    //  If the log is packed, then check the restart length field and whether
    //  the entire restart area is contained in that length.
    //

    if (LogPacked
        && ((ULONG) (PageHeader->RestartOffset + RestartArea->RestartAreaLength) > PageHeader->SystemPageSize
            || OffsetInRestart > RestartArea->RestartAreaLength)) {

        return FALSE;
    }

    //
    //  As a final check make sure that the in use list and the free list are either
    //  empty or point to a valid client.
    //

    if ((RestartArea->ClientFreeList != LFS_NO_CLIENT
         && RestartArea->ClientFreeList >= RestartArea->LogClients)

        || (RestartArea->ClientInUseList != LFS_NO_CLIENT
            && RestartArea->ClientInUseList >= RestartArea->LogClients)) {

        return FALSE;
    }

    //
    //  Make sure the sequence number bits match the log file size.
    //

    FileSize = RestartArea->FileSize;

    for (SeqNumberBits = 0;
        ( FileSize != 0 );
        SeqNumberBits += 1,
        FileSize = ((ULONGLONG)(FileSize)) >> 1 ) {
    }

    SeqNumberBits = (sizeof( LSN ) * 8) + 3 - SeqNumberBits;

    if (SeqNumberBits != RestartArea->SeqNumberBits) {

        return FALSE;
    }

    //
    //  We will check the fields that apply only to a packed log file.
    //

    if (LogPacked) {

        //
        //  The log page data offset and record header length must be
        //  quad-aligned.
        //

        if ((QuadAlign( RestartArea->LogPageDataOffset ) != RestartArea->LogPageDataOffset ) ||
            (QuadAlign( RestartArea->RecordHeaderLength ) != RestartArea->RecordHeaderLength )) {

            return FALSE;
        }
    }

    return TRUE;
}


//
//  Local support routine
//

BOOLEAN
LfsIsClientAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked,
    IN BOOLEAN UsaError
    )

/*++

Routine Description:

    This routine is called to verify that the client array is valid.  We test
    if the client lists are correctly chained.  If the entire restart area is
    within the first Usa stride, we will ignore any Usa errors.

Arguments:

    PageHeader - This is the page to examine.

    LogPacked - Indicates if the log file is packed.

    UsaError - There was a Usa error in reading the full page.

Return Value:

    BOOLEAN - TRUE if there is no corruption in client array values.
              FALSE otherwise.

--*/

{
    PLFS_RESTART_AREA RestartArea;
    USHORT ThisClientIndex;
    USHORT ClientCount;

    PLFS_CLIENT_RECORD ClientArray;
    PLFS_CLIENT_RECORD ThisClient;

    ULONG LoopCount;

    PAGED_CODE();

    RestartArea = Add2Ptr( PageHeader, PageHeader->RestartOffset, PLFS_RESTART_AREA );

    //
    //  If there was a Usa error and the restart area isn't contained in the
    //  first Usa stride, then we have an error.
    //

    if (UsaError
        && (RestartArea->RestartAreaLength + PageHeader->RestartOffset) > FIRST_STRIDE) {

        return FALSE;
    }

    //
    //  Find the start of the client array.
    //

    if (LogPacked) {

        ClientArray = Add2Ptr( RestartArea,
                               RestartArea->ClientArrayOffset,
                               PLFS_CLIENT_RECORD );

    } else {

        //
        //  Handle the case where the offset of the client array is fixed.
        //

        ClientArray = Add2Ptr( RestartArea,
                               FIELD_OFFSET( LFS_OLD_RESTART_AREA,
                                             LogClientArray ),
                               PLFS_CLIENT_RECORD );
    }

    //
    //  Start with the free list.  Check that all the clients are valid and
    //  that there isn't a cycle.  Do the in-use list on the second pass.
    //

    ThisClientIndex = RestartArea->ClientFreeList;

    LoopCount = 2;

    do {

        BOOLEAN FirstClient;

        FirstClient = TRUE;

        ClientCount = RestartArea->LogClients;

        while (ThisClientIndex != LFS_NO_CLIENT) {

            //
            //  If the client count is zero then we must have hit a loop.
            //  If the client index is greater or equal to the log client
            //  count then the list is corrupt.
            //

            if (ClientCount == 0
                || ThisClientIndex >= RestartArea->LogClients) {

                return FALSE;
            }

            ClientCount -= 1;

            ThisClient = ClientArray + ThisClientIndex;
            ThisClientIndex = ThisClient->NextClient;

            //
            //  If this is the first client, then the previous value
            //  should indicate no client.
            //

            if (FirstClient) {

                FirstClient = FALSE;

                if (ThisClient->PrevClient != LFS_NO_CLIENT) {

                    return FALSE;
                }
            }
        }

        ThisClientIndex = RestartArea->ClientInUseList;

    } while (--LoopCount);

    //
    //  The client list is valid.
    //

    return TRUE;
}


//
//  Local support routine.
//

VOID
LfsFindFirstIo (
    IN PLFCB Lfcb,
    IN LSN TargetLsn,
    IN BOOLEAN RestartLsn,
    IN PLBCB FirstLbcb,
    OUT PLBCB *NextLbcb,
    OUT PLONGLONG FileOffset,
    OUT PBOOLEAN ContainsLastEntry,
    OUT PBOOLEAN LfsRestart,
    OUT PBOOLEAN UseTailCopy,
    OUT PULONG IoBlocks
    )

/*++

Routine Description:

    This routine walks through the linked Lbcb's for a Lfcb and groups
    as many of them as can be grouped into a single I/O transfer.
    It updates pointers to indicate the file offset and length of the
    transfer, whether the I/O includes a particular Lbcb, whether the
    transfer is a restart area or a log record page and the number of
    Lbcb's included in the transfer.  We only flush a single log page
    if we are passing through the file for the first time.

Arguments:

    Lfcb - This is the file control block for the log file.

    TargetLsn - This is the Lsn that the caller wants to have included in
        the transfer.
        
    RestartLsn - whether the target lsn is a restart lsn        

    FirstLbcb - This is the first Lbcb to look at in the list.

    NextLbcb - This is the Lbcb to look at first on the next call to this
        routine.

    FileOffset - Supplies the address where we store the offset in the
        log file of this transfer.

    ContainsLastEntry - Supplies the address where we store whether this
        I/O includes the 'LastEntry' Lbcb.

    LfsRestart - Supplies the address where we store whether this transfer
        is a Lfs restart area.

    UseTailCopy - Supplies the address where we store whether we should
        use of page for a copy of the end of the log file.

    IoBlocks - Supplies the address where we store the number of Lbcb's
        for this transfer.

Return Value:

    None.

--*/

{

    ULONG MaxFlushCount = LFS_MAX_FLUSH_COUNT;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindFirstIo:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );

    //
    //  Initialize the file offset, length and io blocks values.
    //  Also assume the last entry is not contained here.
    //  Also assume we have no next Lbcb.
    //

    *FileOffset = FirstLbcb->FileOffset;
    *IoBlocks = 1;

    *LfsRestart = FALSE;
    *UseTailCopy = FALSE;

    *NextLbcb = NULL;

    //
    //  Check if we have found the desired Lsn in a non restart page.  We reject the match
    //  if the Lbcb indicates that we should flush the copy first. Also if this is a restart
    //  page the target the target should be one and vice versa
    //

    if ((FirstLbcb->LastEndLsn.QuadPart >= TargetLsn.QuadPart) &&
        !FlagOn( FirstLbcb->LbcbFlags, LBCB_FLUSH_COPY ) &&

        ((!RestartLsn && !LfsLbcbIsRestart( FirstLbcb ) &&
         (FlagOn( FirstLbcb->Flags, LOG_PAGE_LOG_RECORD_END ))) ||

         (RestartLsn && LfsLbcbIsRestart( FirstLbcb )))) {

        *ContainsLastEntry = TRUE;

    } else {

        *ContainsLastEntry = FALSE;
    }

    //
    //  Check if this is a restart block or if we are passing through the log
    //  file for the first time or if this Lbcb is still in the active queue.
    //  If not, then group as many of the Lbcb's as can be part of a single Io.
    //

    if (LfsLbcbIsRestart( FirstLbcb )) {

        *LfsRestart = TRUE;

#ifdef BENL_DBG
        //
        //  if one is ever on the active queue will use the code at the bottom to remove it
        //

        ASSERT( !FlagOn( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE ) );
#endif

    } else if (FlagOn( FirstLbcb->LbcbFlags, LBCB_FLUSH_COPY)) {
        
        //
        //  Only packed logs - reuse the tail which cause us to need to flush a copy
        //  

        ASSERT( FlagOn( Lfcb->Flags, LFCB_PACK_LOG ) );

        //
        //  This is going to be a tail copy and we will restart with same lbcb
        //  and remove the flag so its normal next time
        //  

        *UseTailCopy = TRUE;
        *NextLbcb = FirstLbcb;
        ClearFlag( FirstLbcb->LbcbFlags, LBCB_FLUSH_COPY );

    } else if (FlagOn( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE ) &&
               FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        //
        //   This is a normal tail copy since its still active
        //  

        *UseTailCopy = TRUE;


    } else if (FlagOn( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO )) {

        PLBCB EndOfPageLbcb = NULL;
        ULONG EndOfPageIoBlocks;

        //
        //  If we are not supporting a packed log file and this Lbcb is from
        //  the active queue, we need to check that losing the tail of the page
        //  will not swallow up any of our reserved space. 
        //
        
        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {
        
            LONGLONG CurrentAvail;
            LONGLONG UnusedBytes;

            //
            //  ISSUE: old code only removed the selected element from the active queue
            //  we'll remove any we hit before the selected lsn
            //  
        
            //
            //  Find the unused bytes.
            //
        
            UnusedBytes = 0;
        
            LfsCurrentAvailSpace( Lfcb,
                                  &CurrentAvail,
                                  (PULONG)&UnusedBytes );
        
            CurrentAvail = CurrentAvail - Lfcb->TotalUndoCommitment;
        
            if (UnusedBytes > CurrentAvail) {
        
                DebugTrace( -1, Dbg, "Have to preserve these bytes for possible aborts\n", 0 );
        
                ExRaiseStatus( STATUS_LOG_FILE_FULL );
            }
        
            //
            //  We want to make sure we don't write any more data into this
            //  page.  Remove this from the active queue.
            //
        
            RemoveEntryList( &FirstLbcb->ActiveLinks );
            ClearFlag( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
        } 

        //
        //  We loop until there are no more blocks or they aren't
        //  contiguous in the file or we have found an entry on the
        //  active queue or we found an entry where we want to explicitly
        //  flush a copy first.
        //

        while ((FirstLbcb->WorkqueLinks.Flink != &Lfcb->LbcbWorkque) &&
               !FlagOn( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE ) &&
               *IoBlocks < MaxFlushCount) {


            LONGLONG ExpectedFileOffset;
            PLBCB TempLbcb;

            //
            //  Get the next Lbcb.
            //

            TempLbcb = CONTAINING_RECORD( FirstLbcb->WorkqueLinks.Flink,
                                          LBCB,
                                          WorkqueLinks );

            //
            //  Break out of the loop if the file offset is not the
            //  expected value or the next entry is on the active queue.
            //

            ExpectedFileOffset = FirstLbcb->FileOffset + Lfcb->LogPageSize;

            //
            //  We want to stop at this point if the next Lbcb is not
            //  the expected offset or we are packing the log file and
            //  the next Lbcb is on the active queue or we want to write
            //  a copy of the data before this page goes out.
            //

            if ((TempLbcb->FileOffset != ExpectedFileOffset) ||
                (FlagOn( Lfcb->Flags, LFCB_PACK_LOG ) &&
                 FlagOn( TempLbcb->LbcbFlags, LBCB_FLUSH_COPY | LBCB_ON_ACTIVE_QUEUE))) {

                //
                //  Use the Lbcb at the end of a page if possible.
                //

                if (EndOfPageLbcb != NULL) {

                    FirstLbcb = EndOfPageLbcb;
                    *IoBlocks = EndOfPageIoBlocks;
                }

                break;
            }

            //
            //  We can add this to our I/o.  Increment the Io blocks
            //  and length of the transfer.  Also check if this entry
            //  contains the Last Entry specified by the caller.
            //

            *IoBlocks += 1;

            if (FlagOn( TempLbcb->Flags, LOG_PAGE_LOG_RECORD_END ) &&
                (TempLbcb->LastEndLsn.QuadPart >= TargetLsn.QuadPart) &&
                !RestartLsn) {

                *ContainsLastEntry = TRUE;
            }

            //
            //  Check if this Lbcb is at the end of a system page.
            //

            if (*ContainsLastEntry &&
                (PAGE_SIZE != (ULONG) Lfcb->LogPageSize) &&
                !FlagOn( ((ULONG) TempLbcb->FileOffset + (ULONG) Lfcb->LogPageSize),
                         PAGE_SIZE - 1 )) {

                EndOfPageLbcb = TempLbcb;
                EndOfPageIoBlocks = *IoBlocks;
            }

            //
            //  Use this entry as the current entry.
            //

            FirstLbcb = TempLbcb;
        }
    }

    //
    //  If the current Lbcb is on the active queue and we aren't using
    //  a tail copy, then remove this from the active queue.  If this
    //  not our target and removing this will cause us to swallow up
    //  part of our reserved quota then back up one Lbcb.
    //

    if (!(*UseTailCopy) && FlagOn( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE )) {

        if (Lfcb->CurrentAvailable < Lfcb->TotalUndoCommitment) {

            //
            //  Move back one file record.
            //

            *IoBlocks -= 1;
            *NextLbcb = FirstLbcb;

            //
            //  Otherwise remove it from the active queue.
            //

        } else {

            ClearFlag( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
            RemoveEntryList( &FirstLbcb->ActiveLinks );
        }
    }

    //
    //  If we haven't found the Lbcb to restart from we will just use the
    //  next Lbcb after the last one found.
    //

    if ((*NextLbcb == NULL) && (FirstLbcb->WorkqueLinks.Flink != &Lfcb->LbcbWorkque)) {

        *NextLbcb = CONTAINING_RECORD( FirstLbcb->WorkqueLinks.Flink,
                                       LBCB,
                                       WorkqueLinks );
    }

    ASSERT( *ContainsLastEntry || (*NextLbcb != NULL) );

    DebugTrace(  0, Dbg, "File Offset (Low)     -> %08lx\n", FileOffset->LowPart );
    DebugTrace(  0, Dbg, "File Offset (High)    -> %08lx\n", FileOffset->HighPart );
    DebugTrace(  0, Dbg, "Contains Last Entry   -> %08x\n", *ContainsLastEntry );
    DebugTrace(  0, Dbg, "LfsRestart            -> %08x\n", *LfsRestart );
    DebugTrace(  0, Dbg, "IoBlocks              -> %08lx\n", *IoBlocks );
    DebugTrace( -1, Dbg, "LfsFindFirstIo:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lbcbsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LbcbSup.c

Abstract:

    This module provides support for manipulating log buffer control blocks.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LBCB_SUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFlushToLsnPriv)
#pragma alloc_text(PAGE, LfsGetLbcb)
#endif

extern LARGE_INTEGER LiMinus1;


VOID
LfsFlushToLsnPriv (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN BOOLEAN RestartLsn
    )

/*++

Routine Description:

    This routine is the worker routine which performs the work of flushing
    a particular Lsn to disk.  This routine is always called with the
    Lfcb acquired.  This routines makes no guarantee about whether the Lfcb
    is acquired on exit.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lsn - This is the Lsn to flush to disk.
    
    RestartLsn - whether this lsn is a lfs restart lsn

Return Value:

    None.

--*/

{
    LSN FlushedLsn;
    volatile LARGE_INTEGER StartTime;
    LFS_WAITER LfsWaiter;
    BOOLEAN OwnedExclusive;
    BOOLEAN Flush;
    
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFlushLbcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb      -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lbcb      -> %08lx\n", Lbcb );

    KeQueryTickCount( &StartTime );

    //
    //  Convert max lsn to the current lsn which will  not change since we hold the 
    //  lfcb at least shared at this point and writers need it exclusive
    //  We do not care if the log progresses beyond this point
    //  

    if (!RestartLsn && (Lsn.QuadPart > Lfcb->RestartArea->CurrentLsn.QuadPart)) {

        Lsn = Lfcb->RestartArea->CurrentLsn;
    }

    //
    //  Init a wait entry - this is a lightweight operation
    // 

    KeInitializeEvent( &LfsWaiter.Event, SynchronizationEvent, FALSE );
    LfsWaiter.Lsn.QuadPart = Lsn.QuadPart;

    //
    //  We loop here until the desired Lsn has made it to disk.
    //  If we are able to do the I/O, we will perform it.
    //

    OwnedExclusive = ExIsResourceAcquiredExclusiveLite( &Lfcb->Sync->Resource );

    while (TRUE) {

        Flush = FALSE;

        ExAcquireFastMutexUnsafe(  &Lfcb->Sync->Mutex );

        if (RestartLsn) {
            FlushedLsn = Lfcb->LastFlushedRestartLsn;
        } else {
            FlushedLsn = Lfcb->LastFlushedLsn;
        }

        //
        //  Check if we still need to flush or can immediately return
        //

        if (Lsn.QuadPart <= FlushedLsn.QuadPart) {
            
            ExReleaseFastMutexUnsafe(  &Lfcb->Sync->Mutex );
            break;
        } 

        if (Lfcb->Sync->LfsIoState == LfsNoIoInProgress) {
        
            Lfcb->Sync->LfsIoState = LfsClientThreadIo;
            Lfcb->LfsIoThread = ExGetCurrentResourceThread();
            Flush = TRUE;
        
        } else {

            PLFS_WAITER TempWaiter = (PLFS_WAITER)Lfcb->WaiterList.Flink;

            //
            //  Insert the wait entry in the sorted list of waiters -
            //  find its place first
            //  

            while ((PVOID)TempWaiter != &Lfcb->WaiterList) {

                if (TempWaiter->Lsn.QuadPart > Lsn.QuadPart) {
                    break;
                }
                TempWaiter = (PLFS_WAITER)TempWaiter->Waiters.Flink;
            }

            InsertTailList( &TempWaiter->Waiters, &LfsWaiter.Waiters );

        }
        ExReleaseFastMutexUnsafe(  &Lfcb->Sync->Mutex );

        //
        //
        //  If we can do the Io, call down to flush the Lfcb.
        //

        if (Flush) {
            LfsFlushLfcb( Lfcb, Lsn, RestartLsn );
            break;
        } 

        //
        //  Otherwise we release the Lfcb and immediately wait on the event.
        //
        
        InterlockedIncrement( &Lfcb->Waiters );
        LfsReleaseLfcb( Lfcb );

        KeWaitForSingleObject( &LfsWaiter.Event, 
                               Executive, 
                               KernelMode, 
                               FALSE, 
                               NULL );

        if (OwnedExclusive) {
            LfsAcquireLfcbExclusive( Lfcb );
        } else {
            LfsAcquireLfcbShared( Lfcb );
        }
        InterlockedDecrement( &Lfcb->Waiters );
    } 

    DebugTrace( -1, Dbg, "LfsFlushToLsnPriv:  Exit\n", 0 );
    return;
}


PLBCB
LfsGetLbcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This routine is called to add a Lbcb to the active queue.

Arguments:

    Lfcb - This is the file control block for the log file.
    
Return Value:

    PLBCB - Pointer to the Lbcb allocated.

--*/

{
    PLBCB Lbcb = NULL;
    PVOID PageHeader;
    PBCB PageHeaderBcb = NULL;

    BOOLEAN WrappedOrUsaError;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsGetLbcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb      -> %08lx\n", Lfcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Pin the desired record page.
        //

        LfsPreparePinWriteData( Lfcb,
                                Lfcb->NextLogPage,
                                (ULONG)Lfcb->LogPageSize,
                                FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL ),
                                &PageHeader,
                                &PageHeaderBcb );

#ifdef LFS_CLUSTER_CHECK
        //
        //  Check the page to see if there is already data on this page with the current sequence
        //  number.  Useful to track cases where ntfs didn't find the correct end of the log or
        //  where the cluster service has the volume mounted twice.
        //

        if (LfsTestCheckLbcb &&
            *((PULONG) PageHeader) == LFS_SIGNATURE_RECORD_PAGE_ULONG) {

            LSN LastLsn = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Copy.LastLsn;

            //
            //  This is not an exhaustive test but should be sufficient to catch the typical case.
            //

            ASSERT( FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL ) ||
                    (LfsLsnToSeqNumber( Lfcb, LastLsn ) < (ULONGLONG) Lfcb->SeqNumber) ||
                    (Lfcb->NextLogPage == Lfcb->FirstLogPage) );
        }
#endif

        //
        //  Put our signature into the page so we won't fail if we
        //  see a previous 'BAAD' signature.
        //

        *((PULONG) PageHeader) = LFS_SIGNATURE_RECORD_PAGE_ULONG;

        //
        //  Now allocate an Lbcb.
        //

        LfsAllocateLbcb( Lfcb, &Lbcb );

        //
        //  If we are at the beginning of the file we test that the
        //  sequence number won't wrap to 0.
        //

        if (!FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL )
            && ( Lfcb->NextLogPage == Lfcb->FirstLogPage )) {

            Lfcb->SeqNumber = Lfcb->SeqNumber + 1;

            //
            //  If the sequence number is going from 0 to 1, then
            //  this is the first time the log file has wrapped.  We want
            //  to remember this because it means that we can now do
            //  large spiral writes.
            //

            if (Int64ShllMod32( Lfcb->SeqNumber, Lfcb->FileDataBits ) == 0) {

                DebugTrace( 0, Dbg, "Log sequence number about to wrap:  Lfcb -> %08lx\n", Lfcb );
                KeBugCheckEx( FILE_SYSTEM, 4, 0, 0, 0 );
            }

            //
            //  If this number is greater or equal to  the wrap sequence number in
            //  the Lfcb, set the wrap flag in the Lbcb.
            //

            if (!FlagOn( Lfcb->Flags, LFCB_LOG_WRAPPED )
                && ( Lfcb->SeqNumber >= Lfcb->SeqNumberForWrap )) {

                SetFlag( Lbcb->LbcbFlags, LBCB_LOG_WRAPPED );
                SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
            }
        }

        //
        //  Now initialize the rest of the Lbcb fields.
        //

        Lbcb->FileOffset = Lfcb->NextLogPage;
        Lbcb->SeqNumber = Lfcb->SeqNumber;
        Lbcb->BufferOffset = Lfcb->LogPageDataOffset;

        //
        //  Store the next page in the Lfcb.
        //

        LfsNextLogPageOffset( Lfcb,
                              Lfcb->NextLogPage,
                              &Lfcb->NextLogPage,
                              &WrappedOrUsaError );

        Lbcb->Length = Lfcb->LogPageSize;
        Lbcb->PageHeader = PageHeader;
        Lbcb->LogPageBcb = PageHeaderBcb;

        Lbcb->ResourceThread = ExGetCurrentResourceThread();
        Lbcb->ResourceThread = (ERESOURCE_THREAD) ((ULONG) Lbcb->ResourceThread | 3);

        //
        //  If we are reusing a previous page then set a flag in
        //  the Lbcb to indicate that we should flush a copy
        //  first.
        //

        if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

            SetFlag( Lbcb->LbcbFlags, LBCB_FLUSH_COPY );
            ClearFlag( Lfcb->Flags, LFCB_REUSE_TAIL );

            (ULONG)Lbcb->BufferOffset = Lfcb->ReusePageOffset;

            Lbcb->Flags = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Flags;
            Lbcb->LastLsn = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Copy.LastLsn;
            Lbcb->LastEndLsn = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Header.Packed.LastEndLsn;
        }

        //
        //  Put the Lbcb on the active queue
        //

        InsertTailList( &Lfcb->LbcbActive, &Lbcb->ActiveLinks );

        SetFlag( Lbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

        //
        //  Now that we have succeeded, set the owner thread to Thread + 1 so the resource
        //  package will know not to peek in this thread.  It may be deallocated before
        //  we release the Bcb during flush.
        //

        CcSetBcbOwnerPointer( Lbcb->LogPageBcb, (PVOID) Lbcb->ResourceThread );

    } finally {

        DebugUnwind( LfsGetLbcb );

        //
        //  If an error occurred, we need to clean up any blocks which
        //  have not been added to the active queue.
        //

        if (AbnormalTermination()) {

            if (Lbcb != NULL) {

                LfsDeallocateLbcb( Lfcb, Lbcb );
                Lbcb = NULL;
            }

            //
            //  Unpin the system page if pinned.
            //

            if (PageHeaderBcb != NULL) {

                CcUnpinData( PageHeaderBcb );
            }
        }

        DebugTrace( -1, Dbg, "LfsGetLbcb:  Exit\n", 0 );
    }

    return Lbcb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbvol.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbvol.cpp

Abstract:

    Definitions for volume support routines

Author:

    Ran Kalach [rankala] 27, January 2000

Revision History:

--*/


#include <stdafx.h>
#include <wsbvol.h>

// Internal functions
static HRESULT FindMountPoint(IN PWSTR enumName, IN PWSTR volumeName, OUT PWSTR firstMountPoint, IN ULONG maxSize);

HRESULT
WsbGetFirstMountPoint(
    IN PWSTR volumeName, 
    OUT PWSTR firstMountPoint, 
    IN ULONG maxSize
)

/*++

Routine Description:

    Find one Mount Point path (if exists) for the given volume

Arguments:

    volumeName      - The volume name to search mount path for. 
                      It should have the \\?\volume{GUID}\  format
    firstMountPoint - Buffer for the output mount point path
    maxSize         - Buffer size

Return Value:

    S_OK            - If at least one Mount Point is found

--*/
{
    HRESULT                     hr = S_FALSE;
    WCHAR                       name[10];
    UCHAR                       driveLetter;

    WCHAR                       tempName[MAX_PATH];
    WCHAR                       driveName[10];
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;
    IO_STATUS_BLOCK             StatusBlock;
    HANDLE                      hDrive = NULL ;
    NTSTATUS                    status;

    WsbTraceIn(OLESTR("WsbGetFirstMountPoint"), OLESTR("volume name = <%ls>"), volumeName);

    name[1] = ':';
    name[2] = '\\';
    name[3] = 0;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[5] = ':';
    driveName[6] = 0;

    for (driveLetter = L'C'; driveLetter <= L'Z'; driveLetter++) {
        name[0] = driveLetter;

        // Exclude network drives
        if (! GetVolumeNameForVolumeMountPoint(name, tempName, MAX_PATH)) {
            continue;
        }

        // Verify that the drive is not removable or floppy, 
        //  this is required to avoid popups when the drive is empty
        driveName[4] = driveLetter;
        hDrive = CreateFile(driveName,
                        FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);
        if (hDrive == INVALID_HANDLE_VALUE) {
            // Can't open it - won't search on it
            WsbTrace(OLESTR("WsbGetFirstMountPoint: Could not open volume %ls, status = %lu - Skipping it!\n"), driveName, GetLastError());
            continue;
        }

        status = NtQueryVolumeInformationFile(hDrive,
                        &StatusBlock,
                        (PVOID) &DeviceInfo,
                        sizeof(FILE_FS_DEVICE_INFORMATION),
                        FileFsDeviceInformation);
        if (!NT_SUCCESS(status)) {
            // Can't query it - won't search on it
            WsbTrace(OLESTR("WsbGetFirstMountPoint: Could not query information for volume %ls, status = %ld - Skipping it!\n"), driveName, (LONG)status);
            CloseHandle(hDrive);
            continue;
        }

        if ((DeviceInfo.Characteristics & FILE_FLOPPY_DISKETTE) || (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA)) { 
            // Skip removable/floppy drives
            WsbTrace(OLESTR("WsbGetFirstMountPoint: Skipping removable/floppy volume %ls\n"), driveName);
            CloseHandle(hDrive);
            continue;
        }
        CloseHandle(hDrive);
        WsbTrace(OLESTR("WsbGetFirstMountPoint: Checking mount points on volume %ls\n"), driveName);

        // Check mount points on drive
        hr = FindMountPoint(name, volumeName, firstMountPoint, maxSize);
        if (S_OK == hr) {
            // Looking for only one mount point
            break;
        }
    }

    WsbTraceOut(OLESTR("WsbGetFirstMountPoint"), OLESTR("hr = <%ls> mount point = <%ls>"), WsbHrAsString(hr), firstMountPoint);

    return hr;
}

HRESULT
FindMountPoint(
    IN PWSTR enumName, 
    IN PWSTR volumeName, 
    OUT PWSTR firstMountPoint, 
    IN ULONG maxSize
)

/*++

Routine Description:

    Find one Mount Point path (if exists) for the given volume on the given enumeration-volume

Arguments:

    enumName        - Volume to enumerate, i.e. search for a mount point on it 
                      which corresponds to the given volume
    volumeName      - The volume name to search mount path for. 
                      It should have the \\?\volume{GUID}\  format
    firstMountPoint - Buffer for the output mount point path
    maxSize         - Buffer size

Comments:
    Avoid the standard HSM try-catch paradigm for performance, especially since this
    function is recursive

Return Value:

    S_OK            - if at least one Mount Point is found
    S_FALSE         - Otherwise

--*/
{
    HANDLE  hEnum;
    WCHAR   *enumVolumeName = NULL;
    WCHAR   *volumeMountPoint = NULL;
    WCHAR   *mountPointPath = NULL;

    WCHAR   c1, c2;
    WCHAR   *linkName1 = NULL;
    WCHAR   *linkName2 = NULL;

    HRESULT hr = S_OK;

    enumVolumeName = (WCHAR*)WsbAlloc(MAX_PATH * sizeof(WCHAR));
    if (NULL == enumVolumeName) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    volumeMountPoint = (WCHAR*)WsbAlloc(maxSize * sizeof(WCHAR));
    if (NULL == volumeMountPoint) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    mountPointPath = (WCHAR*)WsbAlloc((maxSize + wcslen(enumName)) * sizeof(WCHAR));
    if (NULL == mountPointPath) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (! GetVolumeNameForVolumeMountPoint(enumName, enumVolumeName, MAX_PATH)) {
        DWORD dwErr = GetLastError();               
        hr = HRESULT_FROM_WIN32(dwErr);    
        goto exit;
    }

    if (!wcscmp(enumVolumeName, volumeName)) {
        // The volume to enumerate on is the one we are looking for
        wcscpy(firstMountPoint, enumName);
        hr = S_OK;
        goto exit;
    } else {
        linkName1 = (WCHAR*)WsbAlloc((maxSize * 2) * sizeof(WCHAR));
        if (NULL == linkName1) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        linkName2 = (WCHAR*)WsbAlloc((maxSize * 2) * sizeof(WCHAR));
        if (NULL == linkName1) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        c1 = enumVolumeName[48];
        c2 = volumeName[48];
        enumVolumeName[48] = 0;
        volumeName[48] = 0;

        if (QueryDosDevice(&enumVolumeName[4], linkName1, maxSize*2) &&
            QueryDosDevice(&volumeName[4], linkName2, maxSize*2)) {
    
            if (!wcscmp(linkName1, linkName2)) {
                wcscpy(firstMountPoint, enumName);
                enumVolumeName[48] = c1;
                volumeName[48] = c2;
                hr = S_OK;
                goto exit;
            }
        }

        enumVolumeName[48] = c1;
        volumeName[48] = c2;
    }

    hEnum = FindFirstVolumeMountPoint(enumVolumeName, volumeMountPoint, maxSize);
    if (hEnum == INVALID_HANDLE_VALUE) {
        hr = S_FALSE;
        goto exit;
    }

    for (;;) {
        wcscpy(mountPointPath, enumName);
        wcscat(mountPointPath, volumeMountPoint);

        // Enumerate on the mount path we found
        hr = FindMountPoint(mountPointPath, volumeName, firstMountPoint, maxSize);
        if (S_OK == hr) {
            // Found one mount point path, no need to continue
            FindVolumeMountPointClose(hEnum);
            goto exit;
        }

        if (! FindNextVolumeMountPoint(hEnum, volumeMountPoint, maxSize)) {
            FindVolumeMountPointClose(hEnum);
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    if (enumVolumeName) {
        WsbFree(enumVolumeName);
    }
    if (volumeMountPoint) {
        WsbFree(volumeMountPoint);
    }
    if (mountPointPath) {
        WsbFree(mountPointPath);
    }
    if (linkName1) {
        WsbFree(linkName1);
    }
    if (linkName2) {
        WsbFree(linkName2);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lfsdisk.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsDisk.h

Abstract:

    This module defines the on-disk structures present in the log file.

Author:

    Brian Andrew    [BrianAn]   13-June-1991

Revision History:

IMPORTANT NOTE:

    The Log File Service will by used on systems that require that on-disk
    structures guarantee the natural alignment of all arithmetic quantities
    up to and including quad-word (64-bit) numbers.  Therefore, all Lfs
    on-disk structures are quad-word aligned, etc.

--*/

#ifndef _LFSDISK_
#define _LFSDISK_

#define MINIMUM_LFS_PAGES               0x00000030
#define MINIMUM_LFS_CLIENTS             1

//
//  The following macros are used to set and query with respect to the
//  update sequence arrays.
//

#define UpdateSequenceStructureSize( MSH )              \
    ((((PMULTI_SECTOR_HEADER) (MSH))->UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE)

#define UpdateSequenceArraySize( STRUCT_SIZE )          \
    ((STRUCT_SIZE) / SEQUENCE_NUMBER_STRIDE + 1)

#define FIRST_STRIDE                                    \
    (SEQUENCE_NUMBER_STRIDE - sizeof( UPDATE_SEQUENCE_NUMBER ))


//
//  Log client ID.  This is used to uniquely identify a client for a
//  particular log file.
//

typedef struct _LFS_CLIENT_ID {

    USHORT SeqNumber;
    USHORT ClientIndex;

} LFS_CLIENT_ID, *PLFS_CLIENT_ID;


//
//  Log Record Header.  This is the header that begins every Log Record in
//  the log file.
//

typedef struct _LFS_RECORD_HEADER {

    //
    //  Log File Sequence Number of this log record.
    //

    LSN ThisLsn;

    //
    //  The following fields are used to back link Lsn's.  The ClientPrevious
    //  and ClientUndoNextLsn fields are used by a client to link his log
    //  records.
    //

    LSN ClientPreviousLsn;
    LSN ClientUndoNextLsn;

    //
    //  The following field is the size of data area for this record.  The
    //  log record header will be padded if necessary to fill to a 64-bit
    //  boundary, so the client data will begin on a 64-bit boundary to
    //  insure that all of his data is 64-bit aligned.  The below value
    //  has not been padded to 64 bits however.
    //

    ULONG ClientDataLength;

    //
    //  Client ID.  This identifies the owner of this log record.  The owner
    //  is uniquely identified by his offset in the client array and the
    //  sequence number associated with that client record.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  This the Log Record type.  This could be a commit protocol record,
    //  a client restart area or a client update record.
    //

    LFS_RECORD_TYPE RecordType;

    //
    //  Transaction ID.  This is used externally by a client (Transaction
    //  Manager) to group log file entries.
    //

    TRANSACTION_ID TransactionId;

    //
    //  Log record flags.
    //

    USHORT Flags;

    //
    //  Alignment field.
    //

    USHORT AlignWord;

} LFS_RECORD_HEADER, *PLFS_RECORD_HEADER;

#define LOG_RECORD_MULTI_PAGE           (0x0001)

#define LFS_RECORD_HEADER_SIZE          QuadAlign( sizeof( LFS_RECORD_HEADER ))


//
//  Following are the version specific fields in the record page header.
//

typedef struct _LFS_UNPACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    //
    //  Reserved.  The following array is reserved for possible future use.
    //

    USHORT Reserved;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_UNPACKED_RECORD_PAGE, *PLFS_UNPACKED_RECORD_PAGE;

typedef struct _LFS_PACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    ULONG DWordAlign;

    //
    //  The following is the Lsn for the last log record which ends on the page.
    //

    LSN LastEndLsn;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_PACKED_RECORD_PAGE, *PLFS_PACKED_RECORD_PAGE;


//
//  Log Record Page Header.  This structure is present at the beginning of each
//  log file page in the client record section.
//

typedef struct _LFS_RECORD_PAGE_HEADER {

    //
    //  Cache multisector protection header.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;

    union {

        //
        //  Highest Lsn in this log file page.  This field is only for
        //  regular log pages.
        //

        LSN LastLsn;

        //
        //  Log file offset.  This is for the tail copies and indicates the
        //  location in the file where the original lays.  In this case the
        //  LastLsn field above can be obtained from the last ending Lsn
        //  field in the PACKED_RECORD_PAGE structure.
        //

        LONGLONG FileOffset;

    } Copy;

    //
    //  Page Header Flags.  These are the same flags that are stored in the
    //  Lbcb->Flags field.
    //
    //      LOG_PAGE_LOG_RECORD_END     -   Page contains the end of a log record
    //

    ULONG Flags;

    //
    //  I/O Page Position.  The following fields are used to determine
    //  where this log page resides within a Lfs I/O transfer.
    //

    USHORT PageCount;
    USHORT PagePosition;

    //
    //  The following is the difference between version 1.1 and earlier.
    //

    union {

        LFS_UNPACKED_RECORD_PAGE Unpacked;
        LFS_PACKED_RECORD_PAGE Packed;

    } Header;

} LFS_RECORD_PAGE_HEADER, *PLFS_RECORD_PAGE_HEADER;

#define LOG_PAGE_LOG_RECORD_END             (0x00000001)

#define LFS_UNPACKED_RECORD_PAGE_HEADER_SIZE        (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Unpacked.UpdateSequenceArray )     \
)

#define LFS_PACKED_RECORD_PAGE_HEADER_SIZE          (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Packed.UpdateSequenceArray )       \
)


//
//  Log Restart Page Header.  This structure is at the head of the restart
//  areas in a log file.
//

typedef struct _LFS_RESTART_PAGE_HEADER {

    //
    //  Cache multisector protection header.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;

    //
    //  This is the last Lsn found by checkdisk for this volume.
    //

    LSN ChkDskLsn;

    //
    //  System page size.  This is the page size of the system which
    //  initialized the log file.  Unless the log file has been gracefully
    //  shutdown (there are no clients with restart areas), it is a fatal
    //  error to attempt to write to a log file on a system with a differen
    //  page size.
    //

    ULONG SystemPageSize;

    //
    //  Log Page Size.  This is the log page size used for this log file.
    //  The entire Lfs restart area must fit on a single log page.
    //

    ULONG LogPageSize;

    //
    //  Lfs restart area offset.  This is the offset from the start of this
    //  structure to the Lfs restart area.
    //

    USHORT RestartOffset;

    //
    //  The indicates major and minor versions.  Note that the pre-release versions
    //  have -1 in both positions.  Major version 0 indicates the transition
    //  from Beta to USA support.
    //
    //      Major Version
    //
    //          -1      Beta Version
    //           0      Transition
    //           1      Update sequence support.
    //

    SHORT MinorVersion;
    SHORT MajorVersion;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_RESTART_PAGE_HEADER, *PLFS_RESTART_PAGE_HEADER;

#define LFS_RESTART_PAGE_HEADER_SIZE    (                           \
    FIELD_OFFSET( LFS_RESTART_PAGE_HEADER, UpdateSequenceArray )    \
)

//
//  Id strings for the page headers.
//

#define LFS_SIGNATURE_RESTART_PAGE          "RSTR"
#define LFS_SIGNATURE_RESTART_PAGE_ULONG    0x52545352
#define LFS_SIGNATURE_RECORD_PAGE           "RCRD"
#define LFS_SIGNATURE_RECORD_PAGE_ULONG     0x44524352
#define LFS_SIGNATURE_BAD_USA               "BAAD"
#define LFS_SIGNATURE_BAD_USA_ULONG         0x44414142
#define LFS_SIGNATURE_MODIFIED              "CHKD"
#define LFS_SIGNATURE_MODIFIED_ULONG        0x444b4843
#define LFS_SIGNATURE_UNINITIALIZED         "\377\377\377\377"
#define LFS_SIGNATURE_UNINITIALIZED_ULONG   0xffffffff


//
//  Log Client Record.  A log client record exists for each client user of
//  the log file.  One of these is in each Lfs restart area.
//

#define LFS_NO_CLIENT                           0xffff
#define LFS_CLIENT_NAME_MAX                     64

typedef struct _LFS_CLIENT_RECORD {

    //
    //  Oldest Lsn.  This is the oldest Lsn that this client requires to
    //  be in the log file.
    //

    LSN OldestLsn;

    //
    //  Client Restart Lsn.  This is the Lsn of the latest client restart
    //  area written to the disk.  A reserved Lsn will indicate that no
    //  restart area exists for this client.
    //

    LSN ClientRestartLsn;

    //
    //
    //  Previous/Next client area.  These are the indexes into an array of
    //  Log Client Records for the previous and next client records.
    //

    USHORT PrevClient;
    USHORT NextClient;

    //
    //  Sequence Number.  Incremented whenever this record is reused.  This
    //  will happen whenever a client opens (reopens) the log file and has
    //  no current restart area.

    USHORT SeqNumber;

    //
    //  Alignment field.
    //

    USHORT AlignWord;

    //
    //  Align the entire record.
    //

    ULONG AlignDWord;

    //
    //  The following fields are used to describe the client name.  A client
    //  name consists of at most 32 Unicode character (64 bytes).  The Log
    //  file service will treat client names as case sensitive.
    //

    ULONG ClientNameLength;

    WCHAR ClientName[LFS_CLIENT_NAME_MAX];

} LFS_CLIENT_RECORD, *PLFS_CLIENT_RECORD;


//
//  Lfs Restart Area.  Two copies of these will exist at the beginning of the
//  log file.
//

typedef struct _LFS_RESTART_AREA {

    //
    //  Current Lsn.  This is periodic snapshot of the current logical end of
    //  log file to facilitate restart.
    //

    LSN CurrentLsn;

    //
    //  Number of Clients.  This is the maximum number of clients supported
    //  for this log file.
    //

    USHORT LogClients;

    //
    //  The following are indexes into the client record arrays.  The client
    //  records are linked into two lists.  A free list of client records and
    //  an in-use list of records.
    //

    USHORT ClientFreeList;
    USHORT ClientInUseList;

    //
    //  Flag field.
    //
    //      RESTART_SINGLE_PAGE_IO      All log pages written 1 by 1
    //      LFS_CLEAN_SHUTDOWN
    //

    USHORT Flags;

    //
    //  The following is the number of bits to use for the sequence number.
    //

    ULONG SeqNumberBits;

    //
    //  Length of this restart area.
    //

    USHORT RestartAreaLength;

    //
    //  Offset from the start of this structure to the client array.
    //  Ignored in versions prior to 1.1
    //

    USHORT ClientArrayOffset;

    //
    //  Usable log file size.  We will stop sharing the value in the page header.
    //

    LONGLONG FileSize;

    //
    //  DataLength of last Lsn.  This doesn't include the length of
    //  the Lfs header.
    //

    ULONG LastLsnDataLength;

    //
    //  The following apply to log pages.  This is the log page data offset and
    //  the length of the log record header.  Ignored in versions prior to 1.1
    //

    USHORT RecordHeaderLength;
    USHORT LogPageDataOffset;

    //
    //  Log file open count.  Used to determine if there has been a change to the disk.
    //

    ULONG RestartOpenLogCount;

    //
    //   Track log flush failures
    // 
    
    ULONG LastFailedFlushStatus;
    LONGLONG LastFailedFlushOffset;
    LSN LastFailedFlushLsn;

    //
    //  Keep this structure quadword aligned.
    //

    //
    //  Client data.
    //

    LFS_CLIENT_RECORD LogClientArray[1];

} LFS_RESTART_AREA, *PLFS_RESTART_AREA;

#define RESTART_SINGLE_PAGE_IO              (0x0001)
#define LFS_CLEAN_SHUTDOWN                  (0x0002)

#define LFS_RESTART_AREA_SIZE       (FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray ))

//
//  Remember the old size of the restart area when accessing older disks.
//

typedef struct _LFS_OLD_RESTART_AREA {

    //
    //  Current Lsn.  This is periodic snapshot of the current logical end of
    //  log file to facilitate restart.
    //

    LSN CurrentLsn;

    //
    //  Number of Clients.  This is the maximum number of clients supported
    //  for this log file.
    //

    USHORT LogClients;

    //
    //  The following are indexes into the client record arrays.  The client
    //  records are linked into two lists.  A free list of client records and
    //  an in-use list of records.
    //

    USHORT ClientFreeList;
    USHORT ClientInUseList;

    //
    //  Flag field.
    //
    //      RESTART_SINGLE_PAGE_IO      All log pages written 1 by 1
    //

    USHORT Flags;

    //
    //  The following is the number of bits to use for the sequence number.
    //

    ULONG SeqNumberBits;

    //
    //  Length of this restart area.
    //

    USHORT RestartAreaLength;

    //
    //  Offset from the start of this structure to the client array.
    //  Ignored in versions prior to 1.1
    //

    USHORT ClientArrayOffset;

    //
    //  Usable log file size.  We will stop sharing the value in the page header.
    //

    LONGLONG FileSize;

    //
    //  DataLength of last Lsn.  This doesn't include the length of
    //  the Lfs header.
    //

    ULONG LastLsnDataLength;

    //
    //  The following apply to log pages.  This is the log page data offset and
    //  the length of the log record header.  Ignored in versions prior to 1.1
    //

    USHORT RecordHeaderLength;
    USHORT LogPageDataOffset;

    //
    //  Client data.
    //

    LFS_CLIENT_RECORD LogClientArray[1];

} LFS_OLD_RESTART_AREA, *PLFS_OLD_RESTART_AREA;
#endif // _LFSDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lfsdata.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LfsData.c

Abstract:

    This module declares the global data used by the Logging File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

//
//  The global Lfs data record
//

LFS_DATA LfsData;

//
//  Various large integer constants.
//

LARGE_INTEGER LfsLi0 = {0x00000000, 0x00000000};
LARGE_INTEGER LfsLi1 = {0x00000001, 0x00000000};

//
//  The following Lsn will never occur in a file, it is used to indicate
//  a non-lsn.
//

LSN LfsZeroLsn = {0x00000000, 0x00000000};

#ifdef LFSDBG

LONG LfsDebugTraceLevel = 0x0000000F;
LONG LfsDebugTraceIndent = 0;

#endif // LFSDBG

#ifdef LFS_CLUSTER_CHECK

//
//  Check for gaps in the log.
//

BOOLEAN LfsTestBreakOnAnyError = TRUE;
BOOLEAN LfsTestCheckLbcb = TRUE;
#endif


LONG
LfsExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It indicates that we should handle
    the exception or bug check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

#ifdef NTFS_RESTART
    ASSERT( (ExceptionCode != STATUS_DISK_CORRUPT_ERROR) &&
            (ExceptionCode != STATUS_FILE_CORRUPT_ERROR) );
#endif

    //if (ExceptionCode != STATUS_LOG_FILE_FULL) {
    //
    //    DbgPrint("Status not LOGFILE FULL, ExceptionPointers = %08lx\n", ExceptionPointer);
    //    DbgBreakPoint();
    //}

    if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_CONTINUE_SEARCH;

    } else {

        return EXCEPTION_EXECUTE_HANDLER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lfsdata.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsData.c

Abstract:

    This module declares the global data used by the Log File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#ifndef _LFSDATA_
#define _LFSDATA_

//
//  The global Lfs data record
//

extern LFS_DATA LfsData;

//
//  Various large integer constants.
//

#define LfsMaximumFileSize (0x0000000100000000)

extern LARGE_INTEGER LfsLi0;
extern LARGE_INTEGER LfsLi1;

//
//  The following Lsn is used as a starting point in the file.
//

extern LSN LfsStartingLsn;

#ifdef LFS_CLUSTER_CHECK

//
//  Check for gaps in the log.
//

extern BOOLEAN LfsTestBreakOnAnyError;
extern BOOLEAN LfsTestCheckLbcb;
#endif

//
//  Turn on pseudo-asserts if NTFS_FREE_ASSERTS is defined.
//

#if !DBG
#ifdef NTFS_FREE_ASSERTS
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)        if (!(exp)) { extern PBOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s\n",__FILE__,__LINE__,#exp); if (*KdDebuggerEnabled) { DbgBreakPoint(); } }
#define ASSERTMSG(msg,exp) if (!(exp)) { extern PBOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp); if (*KdDebuggerEnabled) { DbgBreakPoint(); } }
#endif
#endif

//
//  The global Lfs debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004      Catch exceptions before completing Irp
//      0x00000008      Unwinding during error conditions
//
//      0x00000010      Lfs initialization
//      0x00000020      Lfs query log records
//      0x00000040      Lfs write log records
//      0x00000080      Lfs registry routines
//
//      0x00000100      Lfs worker thread routines
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000      Log page support routines
//      0x00002000      Lsn support routines
//      0x00004000      Miscellaneous support routines
//      0x00008000      Support routines for cache operations
//
//      0x00010000      Structure support routines
//      0x00020000      Verify/validate support routines
//      0x00040000      Synchronization routines
//      0x00080000      Log buffer support routines
//
//      0x00100000      Support routines for manipulating log records
//      0x00200000      Support routines for manipulation lfs restart areas
//      0x00400000      Support routines for client restart operations
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000
//      0x08000000
//
//      0x10000000
//      0x20000000
//      0x40000000
//      0x80000000
//

#ifdef LFSDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_UNWIND               (0x00000008)
#define DEBUG_TRACE_INITIALIZATION       (0x00000010)
#define DEBUG_TRACE_QUERY                (0x00000020)
#define DEBUG_TRACE_WRITE                (0x00000040)
#define DEBUG_TRACE_RESTART              (0x00000080)
#define DEBUG_TRACE_REGISTRY             (0x00000100)
#define DEBUG_TRACE_WORKER               (0x00000200)
#define DEBUG_TRACE_0x00000400           (0x00000400)
#define DEBUG_TRACE_0x00000800           (0x00000800)
#define DEBUG_TRACE_LOG_PAGE_SUP         (0x00001000)
#define DEBUG_TRACE_LSN_SUP              (0x00002000)
#define DEBUG_TRACE_MISC_SUP             (0x00004000)
#define DEBUG_TRACE_CACHE_SUP            (0x00008000)
#define DEBUG_TRACE_STRUC_SUP            (0x00010000)
#define DEBUG_TRACE_VERIFY_SUP           (0x00020000)
#define DEBUG_TRACE_SYNCH_SUP            (0x00040000)
#define DEBUG_TRACE_LBCB_SUP             (0x00080000)
#define DEBUG_TRACE_LOG_RECORD_SUP       (0x00100000)
#define DEBUG_TRACE_RESTART_SUP          (0x00200000)
#define DEBUG_TRACE_0x00400000           (0x00400000)
#define DEBUG_TRACE_0x00800000           (0x00800000)
#define DEBUG_TRACE_0x01000000           (0x01000000)
#define DEBUG_TRACE_0x02000000           (0x02000000)
#define DEBUG_TRACE_0x04000000           (0x04000000)
#define DEBUG_TRACE_0x08000000           (0x08000000)
#define DEBUG_TRACE_0x10000000           (0x10000000)
#define DEBUG_TRACE_0x20000000           (0x20000000)
#define DEBUG_TRACE_0x40000000           (0x40000000)
#define DEBUG_TRACE_0x80000000           (0x80000000)

extern LONG LfsDebugTraceLevel;
extern LONG LfsDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                      \
    LONG _i;                                                \
    if (((LEVEL) == 0) || (LfsDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        if ((INDENT) < 0) {                                 \
            LfsDebugTraceIndent += (INDENT);                \
        }                                                   \
        if (LfsDebugTraceIndent < 0) {                      \
            LfsDebugTraceIndent = 0;                        \
        }                                                   \
        for (_i = 0; _i < LfsDebugTraceIndent; _i += 1) {   \
            DbgPrint(" ");                                  \
        }                                                   \
        DbgPrint(X,Y);                                      \
        if ((INDENT) > 0) {                                 \
            LfsDebugTraceIndent += (INDENT);                \
        }                                                   \
    }                                                       \
}

#define DebugDump(STR,LEVEL,PTR) {                          \
    ULONG _i;                                               \
    VOID LfsDump();                                         \
    if (((LEVEL) == 0) || (LfsDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        DbgPrint(STR);                                      \
        if (PTR != NULL) {LfsDump(PTR);}                    \
        DbgBreakPoint();                                    \
    }                                                       \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                             \
        DebugTrace(0, DEBUG_TRACE_UNWIND, #X ", Abnormal termination.\n", 0); \
    }                                                                         \
}

#define DebugDoit(X)                     {X;}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}
#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define DebugDoit(X)                     {NOTHING;}

#endif // LFSDBG

#endif // _LFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lfsprocs.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsProcs.h

Abstract:

    This module defines all of the globally used procedures in the Log
    File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#ifndef _LFSPROCS_
#define _LFSPROCS_

#include <ntifs.h>
#include <string.h>
#include <lfs.h>

#include "nodetype.h"
#include "LfsDisk.h"
#include "LfsStruc.h"
#include "LfsData.h"

//
//  Tag all of our allocations if tagging is turned on
//

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota

#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,' sfL')
#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,' sfL')

#define LfsAllocatePoolNoRaise(a,b)         ExAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define LfsAllocatePool(a,b)                ExAllocatePoolWithTag(((a) | POOL_RAISE_IF_ALLOCATION_FAILURE),(b),MODULE_POOL_TAG)
#define LfsFreePool(pv)                     ExFreePool(pv)

#ifndef INLINE
// definition of inline
#define INLINE __inline
#endif


//
//  The following routines provide an interface with the cache package.
//  They are contained in 'CacheSup.c'.
//

NTSTATUS
LfsPinOrMapData (
    IN PLFCB Lfcb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN PinData,
    IN BOOLEAN AllowErrors,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PVOID *Buffer,
    OUT PBCB *Bcb
    );

//
//  VOID
//  LfsPreparePinWriteData (
//      IN PLFCB Lfcb,
//      IN LONGLONG FileOffset,
//      IN ULONG Length,
//      IN LOGICAL ReadFromDisk,
//      OUT PVOID *Buffer,
//      OUT PBCB *Bcb
//      );
//

#ifdef LFS_CLUSTER_CHECK
#define LfsPreparePinWriteData(L,FO,LEN,R,BUF,B) {          \
    LONGLONG _LocalFileOffset = (FO);                       \
    CcPinRead( (L)->FileObject,                             \
               (PLARGE_INTEGER)&_LocalFileOffset,           \
               (LEN),                                       \
               TRUE,                                        \
               (B),                                         \
               (BUF) );                                     \
}
#else
#define LfsPreparePinWriteData(L,FO,LEN,R,BUF,B) {              \
    LONGLONG _LocalFileOffset = (FO);                           \
    if (R) {                                                    \
        CcPinRead( (L)->FileObject,                             \
                   (PLARGE_INTEGER)&_LocalFileOffset,           \
                   (LEN),                                       \
                   TRUE,                                        \
                   (B),                                         \
                   (BUF) );                                     \
    } else {                                                    \
        CcPreparePinWrite( (L)->FileObject,                     \
                           (PLARGE_INTEGER)&_LocalFileOffset,   \
                           (LEN),                               \
                           FALSE,                               \
                           TRUE,                                \
                           (B),                                 \
                           (BUF) );                             \
    }                                                           \
}
#endif

VOID
LfsPinOrMapLogRecordHeader (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN BOOLEAN PinData,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PLFS_RECORD_HEADER *RecordHeader,
    OUT PBCB *Bcb
    );

VOID
LfsCopyReadLogRecord (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PVOID Buffer
    );

VOID
LfsFlushLfcb (
    IN PLFCB Lfcb,
    IN LSN TargetLsn,
    IN BOOLEAN RestartLsn
    );

BOOLEAN
LfsReadRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN BOOLEAN FirstRestart,
    OUT PLONGLONG RestartPageOffset,
    OUT PLFS_RESTART_PAGE_HEADER *RestartPage,
    OUT PBCB *RestartPageBcb,
    OUT PBOOLEAN ChkdskWasRun,
    OUT PBOOLEAN ValidPage,
    OUT PBOOLEAN UninitializedFile,
    OUT PBOOLEAN LogPacked,
    OUT PLSN LastLsn
    );


//
//  The following routines manipulate buffer control blocks.  They are
//  contained in 'LbcbSup.c'
//

VOID
LfsFlushLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    );

VOID
LfsFlushToLsnPriv (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN BOOLEAN RestartLsn
    );

PLBCB
LfsGetLbcb (
    IN PLFCB Lfcb
    );


//
//  The following routines are in LfsData.c
//

LONG
LfsExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    );


//
//  Log page support routines.  The following routines manipulate and
//  modify log pages.  They are contained in 'LogPgSup.c'
//

//
//  VOID
//  LfsTruncateOffsetToLogPage (
//      IN PLFCB Lfcb,
//      IN LONGLONG LargeInt,
//      OUT PLONGLONG Result
//      );
//
//  ULONG
//  LfsLogPageOffset (
//      IN PLFCB Lfcb,
//      IN ULONG Integer
//      );
//

#define LfsTruncateOffsetToLogPage(LFCB,LI,OUTLI)       \
    *(OUTLI) = LI;                                      \
    *((PULONG)(OUTLI)) &= (LFCB)->LogPageInverseMask

#define LfsLogPageOffset(LFCB,INT)                      \
    (INT & (LFCB)->LogPageMask)

VOID
LfsNextLogPageOffset (
    IN PLFCB Lfcb,
    IN LONGLONG CurrentLogPageOffset,
    OUT PLONGLONG NextLogPageOffset,
    OUT PBOOLEAN Wrapped
    );

PVOID
LfsAllocateSpanningBuffer (
    IN PLFCB Lfcb,
    IN ULONG Length
    );

VOID
LfsFreeSpanningBuffer (
    IN PVOID Buffer
    );


//
//  The following routines provide support for dealing with log records.  They
//  are contained in 'LogRcSup.c'
//

BOOLEAN
LfsWriteLogRecordIntoLogPage (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN ClientUndoNextLsn OPTIONAL,
    IN LSN ClientPreviousLsn OPTIONAL,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk,
    OUT PLSN Lsn
    );


//
//  Lsn support routines.  The following routines provide support for
//  manipulating Lsn values.  They are contained in 'LsnSup.c'
//

//
//  LSN
//  LfsFileOffsetToLsn (
//      IN PLFCB Lfcb,
//      IN LONGLONG FileOffset,
//      IN LONGLONG SequenceNumber
//      );
//
//  BOOLEAN
//  LfsIsLsnInFile (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//
//  LSN
//  LfsComputeLsnFromLbcb (
//      IN PLFCB Lfcb,
//      IN PLBCB Lbcb
//      );
//
//  VOID
//  LfsTruncateLsnToLogPage (
//      IN PLFCB Lfcb,
//      IN LSN Lsn,
//      OUT PLONGLONG FileOffset
//      );
//
//  LONGLONG
//  LfsLsnToFileOffset (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//
//  LONGLONG
//  LfsLsnToSeqNumber (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//
//  ULONG
//  LfsLsnToPageOffset (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//

#define LfsFileOffsetToLsn(LFCB,FO,SN) (                                        \
    (((ULONGLONG)(FO)) >> 3) + Int64ShllMod32((SN), (LFCB)->FileDataBits)                                \
)

#define LfsIsLsnInFile(LFCB,LSN)                                                \
    (/*xxGeq*/( (LSN).QuadPart >= ((LFCB)->OldestLsn).QuadPart )                                          \
     && /*xxLeq*/( (LSN).QuadPart <= ((LFCB)->RestartArea->CurrentLsn).QuadPart ))

#define LfsComputeLsnFromLbcb(LFCB,LBCB) (                                              \
    LfsFileOffsetToLsn( LFCB,                                                           \
                        (LBCB)->FileOffset + (LBCB)->BufferOffset,    \
                        (LBCB)->SeqNumber )                                    \
)

#define LfsTruncateLsnToLogPage(LFCB,LSN,FO) {                                  \
    *(FO) = LfsLsnToFileOffset( LFCB, LSN );                                    \
    *((PULONG)(FO)) &= (LFCB)->LogPageInverseMask;                                \
}

#define LfsLsnToFileOffset(LFCB,LSN)                                            \
    /*xxShr*/( ((ULONGLONG)/*xxShl*/( (LSN).QuadPart << (LFCB)->SeqNumberBits )) >> ((LFCB)->SeqNumberBits - 3) )

#define LfsLsnToSeqNumber(LFCB,LSN)                                             \
    /*xxShr*/Int64ShrlMod32( ((ULONGLONG)(LSN).QuadPart), (LFCB)->FileDataBits )

#define LfsLsnToPageOffset(LFCB,LSN)                                            \
    LfsLogPageOffset( LFCB, (LSN).LowPart << 3 )

VOID
LfsLsnFinalOffset (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN ULONG DataLength,
    OUT PLONGLONG FinalOffset
    );

BOOLEAN
LfsFindNextLsn (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PLSN Lsn
    );


//
//  The following routines support the Lfs restart areas.  They are contained
//  in 'RstrtSup.c'
//

VOID
LfsWriteLfsRestart (
    IN PLFCB Lfcb,
    IN ULONG ThisRestartSize,
    IN BOOLEAN WaitForIo
    );

VOID
LfsFindOldestClientLsn (
    IN PLFS_RESTART_AREA RestartArea,
    IN PLFS_CLIENT_RECORD ClientArray,
    OUT PLSN OldestLsn
    );


//
//  The following routines are used for managing the structures allocated
//  by us.  They are contained in 'StrucSup.c'
//

PLFCB
LfsAllocateLfcb (
    IN ULONG LogPageSize,
    IN LONGLONG FileSize
    );


VOID
LfsDeallocateLfcb (
    IN PLFCB Lfcb,
    IN BOOLEAN CompleteTeardown
    );

VOID
LfsAllocateLbcb (
    IN PLFCB Lfcb,
    OUT PLBCB *Lbcb
    );

VOID
LfsDeallocateLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    );

VOID
LfsAllocateLeb (
    IN PLFCB Lfcb,
    OUT PLEB *NewLeb
    );

VOID
LfsDeallocateLeb (
    IN PLFCB Lfcb,
    IN PLEB Leb
    );

VOID
LfsReadPage (
    IN PLFCB Lfcb,
    IN PLARGE_INTEGER Offset,
    OUT PMDL *Mdl,
    OUT PVOID *Buffer
    );

//
//  VOID
//  LfsInitializeLeb (
//      IN PLEB Leb,
//      IN LFS_CLIENT_ID ClientId,
//      IN LFS_CONTEXT_MODE ContextMode
//      );
//
//
//  VOID
//  LfsAllocateLch (
//      OUT PLCH *Lch
//      );
//
//  VOID
//  LfsDeallocateLch (
//      IN PLCH Lch
//      );
//
//  VOID
//  LfsAllocateRestartArea (
//      OUT PLFS_RESTART_AREA *RestartArea,
//      ULONG Size
//      );
//
//  VOID
//  LfsDeallocateRestartArea (
//      IN PLFS_RESTART_AREA RestartArea
//      );
//
//  BOOLEAN
//  LfsLbcbIsRestart (
//      IN PLBCB Lbcb
//      );
//

#define LfsInitializeLeb(LEB,ID,MODE)                           \
    (LEB)->ClientId = ID;                                       \
    (LEB)->ContextMode = MODE


#define LfsAllocateLch(NEW)     {                               \
    *(NEW) = FsRtlAllocatePool( PagedPool, sizeof( LCH ));      \
    RtlZeroMemory( (*NEW), sizeof( LCH ));                      \
    (*(NEW))->NodeTypeCode = LFS_NTC_LCH;                       \
    (*(NEW))->NodeByteSize = sizeof( LCH );                     \
}

#define LfsDeallocateLch(LCH)                                   \
    ExFreePool( LCH )

#define LfsAllocateRestartArea(RS,SIZE)                         \
    *(RS) = FsRtlAllocatePool( PagedPool, (SIZE) );             \
    RtlZeroMemory( *(RS), (SIZE) )

#define LfsDeallocateRestartArea(RS)                            \
    ExFreePool( RS )

#define LfsLbcbIsRestart(LBCB)                                  \
    (FlagOn( (LBCB)->LbcbFlags, LBCB_RESTART_LBCB ))


//
//  The following routines provide synchronization support for the Lfs
//  shared structures.  They are contained in 'SyncSup.c'
//

//
//  VOID
//  LfsAcquireLfsData (
//      );
//
//  VOID
//  LfsReleaseLfsData (
//      );
//
//  VOID
//  LfsAcquireLfcb (
//      IN PLFCB Lfcb
//      );
//
//  VOID
//  LfsReleaseLfcb (
//      IN PLFCB Lfcb
//      );
//
//  VOID
//  LfsAcquireLchExclusive (
//      IN PLCH Lch
//      );
//    
//  VOID
//  LfsAcquireLchShared (
//      IN PLCH Lch
//      );
//
//  VOID
//  LfsReleaseLfcb (
//      IN PLCH Lch
//      );
//

#define LfsAcquireLfsData()                                 \
    ExAcquireFastMutex( &LfsData.LfsDataLock )

#define LfsReleaseLfsData()                                 \
    ExReleaseFastMutex( &LfsData.LfsDataLock )

#define LfsAcquireBufferLock()                              \
    ExAcquireFastMutex( &LfsData.BufferLock )

#define LfsReleaseBufferLock()                              \
    ExReleaseFastMutex( &LfsData.BufferLock )

#define LfsWaitForBufferNotification()                      \
    KeWaitForSingleObject( &LfsData.BufferNotification,     \
                           Executive,                       \
                           KernelMode,                      \
                           FALSE,                           \
                           NULL )

#define LfsNotifyBufferWaiters()                            \
    KeSetEvent( &LfsData.BufferNotification, 0, FALSE )

#define LfsBlockBufferWaiters()                             \
    KeClearEvent( &LfsData.BufferNotification )

INLINE
VOID
LfsAcquireLfcbExclusive (
    IN PLFCB Lfcb
    )
{
    ExAcquireResourceExclusiveLite( &Lfcb->Sync->Resource, TRUE );
}

INLINE
VOID
LfsAcquireLfcbShared (
    IN PLFCB Lfcb
    )
{
    ExAcquireResourceSharedLite( &Lfcb->Sync->Resource, TRUE );
}


INLINE
VOID
LfsReleaseLfcb (
    IN PLFCB Lfcb
    )
{
    //
    //  If the resource is owned either shared or exlcusive release it
    //  

    if (ExIsResourceAcquiredSharedLite( &Lfcb->Sync->Resource )) { 
        ExReleaseResourceLite( &Lfcb->Sync->Resource );
    }
}

INLINE
VOID
LfsAcquireLchExclusive (
    IN PLCH Lch
    )
{
    ExAcquireResourceExclusiveLite( &(Lch->Sync->Resource), TRUE );
}

INLINE
VOID
LfsAcquireLchShared (
    IN PLCH Lch
    )
{
    ExAcquireResourceSharedLite( &(Lch->Sync->Resource), TRUE );
}


INLINE
VOID
LfsReleaseLch (
    IN PLCH Lch
    )
{
    if (ExIsResourceAcquiredSharedLite( &Lch->Sync->Resource )) {
        ExReleaseResourceLite( &Lch->Sync->Resource );
    }
}



//
//  The following routines are used to check various structures for validity
//  and comparability.  They are contained in 'VerfySup.c'.
//

VOID
LfsCurrentAvailSpace (
    IN PLFCB Lfcb,
    OUT PLONGLONG CurrentAvailSpace,
    OUT PULONG CurrentPageBytes
    );

BOOLEAN
LfsVerifyLogSpaceAvail (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG RemainingLogBytes,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk
    );

VOID
LfsFindCurrentAvail (
    IN PLFCB Lfcb
    );

BOOLEAN
LfsCheckSubsequentLogPage (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_PAGE_HEADER RecordPageHeader,
    IN LONGLONG LogFileOffset,
    IN LONGLONG SequenceNumber
    );


//
//  VOID
//  LfsValidateLch (
//      IN PLCH Lch
//      );
//
//  VOID
//  LfsValidateClientId (
//      IN PLFCB Lfcb,
//      IN PLCH Lch
//      );
//
//  BOOLEAN
//  LfsVerifyClientLsnInRange (
//      IN PLFCB Lfcb,
//      IN PLFS_CLIENT_RECORD ClientRecord,
//      IN LSN Lsn
//      );
//
//  BOOLEAN
//  LfsClientIdMatch (
//      IN PLFS_CLIENT_ID ClientA,
//      IN PLFS_CLIENT_ID ClientB
//      )
//
//  VOID
//  LfsValidateLeb (
//      IN PLFS_CONTEXT_BLOCK Leb,
//      IN PLCH Lch
//      )
//

#define LfsValidateLch(LCH)                                     \
    if ((LCH) == NULL                                           \
        || (LCH)->NodeTypeCode != LFS_NTC_LCH                   \
        || ((LCH)->Lfcb != NULL                                 \
            && (LCH)->Lfcb->NodeTypeCode != LFS_NTC_LFCB)) {    \
                                                                \
        ExRaiseStatus( STATUS_ACCESS_DENIED );                  \
    }

#define LfsValidateClientId(LFCB,LCH)                                   \
    if ((LCH)->ClientId.ClientIndex >= (LFCB)->RestartArea->LogClients  \
        || (LCH)->ClientId.SeqNumber                                    \
           != Add2Ptr( Lfcb->ClientArray,                               \
                       (LCH)->ClientArrayByteOffset,                    \
                       PLFS_CLIENT_RECORD )->SeqNumber) {               \
        ExRaiseStatus( STATUS_ACCESS_DENIED );                          \
    }

#define LfsVerifyClientLsnInRange(LFCB,CLIENT,LSN)                      \
    (/*xxGeq*/( (LSN).QuadPart >= ((CLIENT)->OldestLsn).QuadPart )                                  \
     && /*xxLeq*/( (LSN).QuadPart <= ((LFCB)->RestartArea->CurrentLsn).QuadPart )                   \
     && /*xxNeqZero*/( (LSN).QuadPart != 0 ))

#define LfsClientIdMatch(CLIENT_A,CLIENT_B)                             \
    ((BOOLEAN) ((CLIENT_A)->SeqNumber == (CLIENT_B)->SeqNumber          \
                && (CLIENT_A)->ClientIndex == (CLIENT_B)->ClientIndex))

#define LfsValidateLeb(LEB,LCH)                                         \
    if (LEB == NULL                                                     \
        || (LEB)->NodeTypeCode != LFS_NTC_LEB                           \
        || !LfsClientIdMatch( &(LEB)->ClientId, &(LCH)->ClientId )) {   \
        ExRaiseStatus( STATUS_ACCESS_DENIED );                          \
    }


//
//  Miscellaneous support routines
//

//
//      ULONG
//      FlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      BOOLEAN
//      BooleanFlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  This macro will up a 64 bit value to the next quad align boundary.
//

#define LiQuadAlign(LI,OUT)   {         \
    *(OUT) = /*xxAdd*/( (LI) + 7 );       \
    *((PULONG)(OUT)) &= 0xfffffff8;       \
}

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((PUCHAR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#endif // _LFSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lfsstruc.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Log File Service.

Author:

    Brian Andrew    [BrianAn]   13-June-1991

Revision History:

--*/

#ifndef _LFSSTRUC_
#define _LFSSTRUC_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module


//
//  Log Enumeration Block.  A pointer to this structure is returned to the user
//  when a client is reading a particular set of log records from the log
//  file.
//

typedef struct _LEB {

    //
    //  The type and size of this record (must be LFS_NTC_LEB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Log record header.  This is the mapped log record header and bcb
    //  for the record header of the current Lsn.
    //

    struct _LFS_RECORD_HEADER *RecordHeader;
    PBCB RecordHeaderBcb;

    //
    //  Context Mode.  This is the mode governing the log record lookup.  We
    //  can look backwards via the ClientUndoNextLsn or ClientPreviousLsn.
    //  We can also look forwards by walking through all the log records and
    //  comparing ClientId fields.
    //

    LFS_CONTEXT_MODE ContextMode;

    //
    //  Client Id.  This is the client ID for the log records being returned.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  Log record pointer.  This is the address returned to the user as the
    //  log record referred to by CurrentLsn.  If we allocated a buffer to
    //  hold the record, we need to deallocate it as necessary.
    //
    //  This field is either the actual mapped log record or a pointer to
    //  an auxilary buffer allocated by the Lfs.
    //

    PVOID CurrentLogRecord;
    BOOLEAN AuxilaryBuffer;

} LEB, *PLEB;


//
//  Lfcb synchronization.  This is the synchronization structure used by the Lfcb.
//


typedef enum _LFS_IO_STATE {

    LfsNoIoInProgress = 0,
    LfsClientThreadIo

} LFS_IO_STATE;

typedef struct _LFCB_SYNC {

    //
    //  Principal Lfcb Resource.
    //

    ERESOURCE Resource;

    //
    //  User Count.  Number of clients using this structure.  We will deallocate
    //  when all clients are gone.
    //

    ULONG UserCount;

    //
    //  Mutant to guard Lcb spare list and last flushed lsn
    //

    FAST_MUTEX Mutex;

    //
    //  The enumerated type indicates if there is an active write for
    //  this log file and whether it is being done by an Lfs or
    //  client thread.
    //

    LFS_IO_STATE LfsIoState;

} LFCB_SYNC, *PLFCB_SYNC;


typedef struct _LFS_WAITER {

    //
    //  Link onto the lfcb waiter list
    //  

    LIST_ENTRY Waiters;

    //
    //  Event to signal when the lsn has been flushed to that point or no one 
    //  is left flushing
    //  
    
    KEVENT Event;
    LSN Lsn;

} LFS_WAITER, *PLFS_WAITER;


//
//  Log Client Structure.  The Lfs allocates one of these for each active
//  client.  The address of this structure will be returned to the user
//  as a log handle.
//

typedef struct _LCH {

    //
    //  The type and size of this record (must be LFS_NTC_LCH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Links for all the client handles on an Lfcb.
    //

    LIST_ENTRY LchLinks;

    //
    //  Log File Control Block.  This is the log file for this log handle.
    //

    struct _LFCB *Lfcb;

    //
    //  Client Id.  This refers to the client record for this client in the
    //  Lfs restart area.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  The following is the number of bytes this client has asked to
    //  have reserved in the log file.  It includes the space
    //  for the log record headers.
    //

    LONGLONG ClientUndoCommitment;

    //
    //  Byte offset in the client array.
    //

    ULONG ClientArrayByteOffset;

    //
    //  Pointer to the resource in the Lfcb.  We access the resource with
    //  this pointer for the times when the lfcb has been deleted.
    //

    PLFCB_SYNC Sync;

} LCH, *PLCH;


//
//  Log Buffer Control Block.  A buffer control block is associated with
//  each of the log buffers.  They are used to serialize access to the
//  log file.
//

typedef struct _LBCB {

    //
    //  The type and size of this record (must be LFS_NTC_LBCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Buffer Block Links.  These fields are used to link the buffer blocks
    //  together.
    //

    LIST_ENTRY WorkqueLinks;
    LIST_ENTRY ActiveLinks;

    //
    //  Log file position and length.  This is the location in the log file to write
    //  out this buffer.
    //

    LONGLONG FileOffset;
    LONGLONG Length;

    //
    //  Sequence number.  This is the sequence number for log records which
    //  begin on this page.
    //

    LONGLONG SeqNumber;

    //
    //  Next Offset.  This is the next offset to write a log record in the
    //  this log page.  Stored as a large integer to facilitate large
    //  integer operations.
    //

    LONGLONG BufferOffset;

    //
    //  Buffer.  This field points to the buffer containing the log page
    //  for this block.  For a log record page this is a pointer to
    //  a pinned cache buffer, for a log restart page, this is a pointer
    //  to an auxilary buffer.
    //

    PVOID PageHeader;

    //
    //  Bcb for Log Page Block.  This is the Bcb for the pinned data.
    //  If this buffer block describes an Lfs restart area, this field is NULL.
    //

    PBCB LogPageBcb;

    //
    //  Last Lsn.  This is the Lsn for the last log record on this page.  We delay
    //  writing it until the page is flushed, storing it here instead.
    //

    LSN LastLsn;

    //
    //  Last complete Lsn.  This is the Lsn for the last log record which ends
    //  on this page.
    //

    LSN LastEndLsn;

    //
    //  Page Flags.  These are the flags associated with this log page.
    //  We store them in the Lbcb until the page is written.  They flags
    //  to use are the same as in the log record page header.
    //
    //      LOG_PAGE_LOG_RECORD_END     -   Page contains the end of a log record
    //      LOG_PAGE_PACKED             -   Page contains packed log records
    //      LOG_PAGE_TAIL_COPY          -   Page is a copy of the log file end
    //

    ULONG Flags;

    //
    //  Lbcb flags.  These are flags used to describe this Lbcb.
    //
    //      LBCB_LOG_WRAPPED            -   Lbcb has wrapped the log file
    //      LBCB_ON_ACTIVE_QUEUE        -   Lbcb is on the active queue
    //      LBCB_NOT_EMPTY              -   Page has existing log record
    //      LBCB_FLUSH_COPY             -   Write copy of this page first
    //      LBCB_RESTART_LBCB           -   This Lbcb contains a restart page
    //

    ULONG LbcbFlags;

    //
    //  This is the thread which has locked the log page.
    //

    ERESOURCE_THREAD ResourceThread;

} LBCB, *PLBCB;

#define LBCB_LOG_WRAPPED                        (0x00000001)
#define LBCB_ON_ACTIVE_QUEUE                    (0x00000002)
#define LBCB_NOT_EMPTY                          (0x00000004)
#define LBCB_FLUSH_COPY                         (0x00000008)
#define LBCB_RESTART_LBCB                       (0x00000020)


//
//  Log file data.  This data structure is used on a per-log file basis.
//


typedef struct _LFCB {

    //
    //  The type and size of this record (must be LFS_NTC_LFCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Lfcb Links.  The following links the file control blocks to the
    //  global data structure.
    //

    LIST_ENTRY LfcbLinks;

    //
    //  Lch Links.  The following links all of the handles for the Lfcb.
    //

    LIST_ENTRY LchLinks;

    //
    //
    //  File Object.  This is the file object for the log file.
    //

    PFILE_OBJECT FileObject;

    //
    //  Log File Size.  This is the size of the log file.
    //  The second value is the size proposed by this open.
    //

    LONGLONG FileSize;

    //
    //  Log page size, masks and shift count to do multiplication and division
    //  of log pages.
    //

    LONGLONG  LogPageSize;
    ULONG LogPageMask;
    LONG LogPageInverseMask;
    ULONG LogPageShift;

    //
    //  First log page.  This is the offset in the file of the first
    //  log page with log records.
    //

    LONGLONG FirstLogPage;

    //
    //  Next log page offset.  This is the offset of the next log page to use.
    //  If we are reusing this page we store the offset to begin with.
    //

    LONGLONG NextLogPage;
    ULONG ReusePageOffset;

    //
    //  Data Offset.  This is the offset within a log page of the data that
    //  appears on that page.  This will be the actual restart data for
    //  an Lfs restart page, or the beginning of log record data for a log
    //  record page.
    //

    ULONG RestartDataOffset;
    LONGLONG LogPageDataOffset;

    //
    //  Data Size.  This is the amount of data that may be stored on a
    //  log page.  It is included here because it is frequently used.  It
    //  is simply the log page size minus the data offset.
    //

    ULONG RestartDataSize;
    LONGLONG LogPageDataSize;

    //
    //  Record header size.  This is the size to use for the record headers
    //  when reading the log file.
    //

    USHORT RecordHeaderLength;

    //
    //  Sequence number.  This is the number of times we have cycled through
    //  the log file.  The wrap sequence number is used to confirm that we
    //  have gone through the entire file at least once.  When we write a
    //  log record page for an Lsn with this sequence number, then we have
    //  cycled through the file.
    //

    LONGLONG SeqNumber;
    LONGLONG SeqNumberForWrap;
    ULONG SeqNumberBits;
    ULONG FileDataBits;

    //
    //  Buffer Block Links.  The following links the buffer blocks for this
    //  log file.
    //

    LIST_ENTRY LbcbWorkque;
    LIST_ENTRY LbcbActive;

    PLBCB ActiveTail;
    PLBCB PrevTail;

    //
    //  Current Restart Area.  The following is the in-memory image of the
    //  next restart area.  We also store a pointer to the client data
    //  array in the restart area.  The client array offset is from the start of
    //  the restart area.
    //

    PLFS_RESTART_AREA RestartArea;
    PLFS_CLIENT_RECORD ClientArray;
    USHORT ClientArrayOffset;
    USHORT ClientNameOffset;

    //
    //  Restart Area size.  This is the usable size of the restart area.
    //

    ULONG RestartAreaSize;
    USHORT LogClients;

    //
    //  Initial Restart area.  If true, then the in-memory restart area is to
    //  be written to the first position on the disk.
    //

    BOOLEAN InitialRestartArea;

    //
    //  The following is the earliest Lsn we will guarantee is still in the
    //  log file.
    //

    LSN OldestLsn;

    //
    //  The following is the file offset of the oldest Lsn in the system.
    //  We redundantly store it in this form since we will be constantly
    //  checking if a new log record will write over part of the file
    //  we are trying to maintain.
    //

    LONGLONG OldestLsnOffset;

    //
    //  Last Flushed Lsn.  The following is the last Lsn guaranteed to
    //  be flushed to the disk. The last restart lsn is the last pseudo restart lsn flushed
    //

    LSN LastFlushedLsn;
    LSN LastFlushedRestartLsn;

    //
    //
    //  The following fields are used to track current usage in the log file.
    //
    //      TotalAvailable - is the total number of bytes available for
    //          log records.  It is the number of log pages times the
    //          data size of each page.
    //
    //      TotalAvailInPages - is the total number of bytes in the log
    //          pages for log records.  This is TotalAvailable without
    //          subtracting the size of the page headers.
    //
    //      TotalUndoCommitment - is the number of bytes reserved for
    //          possible abort operations.  This includes space for
    //          log record headers as well.
    //
    //      MaxCurrentAvail - is the maximum available in all pages
    //          subtracting the page header and any reserved tail.
    //
    //      CurrentAvailable - is the total number of bytes available in
    //          unused pages in the log file.
    //
    //      ReservedLogPageSize - is the number of bytes on a page available
    //          for reservation.
    //

    LONGLONG TotalAvailable;
    LONGLONG TotalAvailInPages;
    LONGLONG TotalUndoCommitment;
    LONGLONG MaxCurrentAvail;
    LONGLONG CurrentAvailable;

    LONGLONG ReservedLogPageSize;

    //
    //  The following fields are used to store information about the
    //  update sequence arrays.
    //

    USHORT RestartUsaOffset;
    USHORT UsaArraySize;

    USHORT LogRecordUsaOffset;

    //
    //  Major and minor version numbers.
    //

    SHORT MajorVersion;
    SHORT MinorVersion;

    //
    //  Log File Flags.
    //
    //      LFCB_LOG_WRAPPED        -   We found an Lbcb which wraps the log file
    //      LFCB_MULTIPLE_PAGE_IO   -   Write multiple pages if possible
    //      LFCB_NO_LAST_LSN        -   There are no log records to return
    //      LFCB_PACK_LOG           -   Pack the records into the pages
    //      LFCB_REUSE_TAIL         -   We will be reusing the tail of the log file after restart
    //      LFCB_NO_OLDEST_LSN      -   There is no oldest page being reserved
    //

    ULONG Flags;

    //
    //  The following are the spare Lbcb's for the volume and a field with
    //  the count for these.
    //

    ULONG SpareLbcbCount;
    LIST_ENTRY SpareLbcbList;

    //
    //  The following are sparse LEB's to be used rather than having to allocate
    //  then when reading log records
    //

    ULONG SpareLebCount;
    LIST_ENTRY SpareLebList;

    //
    //  The following structure synchronizes access to this structure.
    //

    PLFCB_SYNC Sync;

    //
    //  Count of waiters wanting access to flush the Lfcb. List synchronized
    //  by the sync mutex of the waiters see LFS_WAITER 
    //

    ULONG Waiters;
    LIST_ENTRY WaiterList;

    //
    //  On-disk value for OpenLogCount.  This is the value we will stuff into
    //  the client handles.
    //

    ULONG CurrentOpenLogCount;

    //
    //  Maintain the flush range for this file.
    //

    PLFS_WRITE_DATA UserWriteData;

    ERESOURCE_THREAD LfsIoThread;

    //
    //  Buffer and mdls which hold down the first 4 pages at the head of the log
    //  this includes the lfs restart areas and the ping pong pages. The partial mdl
    //  is used to pin pieces of the total buffer
    //

    PMDL LogHeadMdl;
    PMDL LogHeadPartialMdl;
    PVOID LogHeadBuffer;

    //
    //  preallocated error log packet for use logging errors to the eventlog
    //

    PIO_ERROR_LOG_PACKET ErrorLogPacket;

#ifdef LFS_CLUSTER_CHECK
    LSN LsnAtMount;
    ULONG LsnRangeIndex;
#endif

    ULONG LfsRestartBias;

    //
    //  Embedded array with enough space for SYSTEM PAGE / LOG PAGE SIZE
    //  used to facilitate flushing partial system pages
    //

    PLBCB DirtyLbcb[0];

} LFCB, *PLFCB;

#define LFCB_LOG_WRAPPED                (0x00000001)
#define LFCB_MULTIPLE_PAGE_IO           (0x00000002)
#define LFCB_NO_LAST_LSN                (0x00000004)
#define LFCB_PACK_LOG                   (0x00000008)
#define LFCB_REUSE_TAIL                 (0x00000010)
#define LFCB_NO_OLDEST_LSN              (0x00000020)
#define LFCB_LOG_FILE_CORRUPT           (0x00000040)
#define LFCB_FINAL_SHUTDOWN             (0x00000080)
#define LFCB_READ_FIRST_RESTART         (0x00000100)
#define LFCB_READ_SECOND_RESTART        (0x00000200)
#define LFCB_READ_ONLY                  (0x00000400)

#ifdef LFS_CLUSTER_CHECK
#define LFCB_DEVICE_OFFLINE_SEEN        (0x80000000)
#define LFCB_FLUSH_FAILED               (0x40000000)
#endif

#define LFCB_RESERVE_LBCB_COUNT         (5)
#define LFCB_MAX_LBCB_COUNT             (25)

#define LFCB_RESERVE_LEB_COUNT          (5)
#define LFCB_MAX_LEB_COUNT              (25)


//
//  Global Log Data.  The following structure has only one instance and
//  maintains global information for the entire logging service.
//

typedef struct _LFS_DATA {

    //
    //  The type and size of this record (must be LFS_NTC_DATA)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field links all of the Log File Control Blocks for
    //  the logging system.
    //

    LIST_ENTRY LfcbLinks;

    //
    //  Flag field.
    //

    ULONG Flags;

    //
    //  The following mutex controls access to this structure.
    //

    FAST_MUTEX LfsDataLock;

    //
    //  Allocated buffers for reading spanning log records in low memory case.
    //  Flags indicate which buffers owned.
    //      LFS_BUFFER1_OWNED
    //      LFS_BUFFER2_OWNED
    //

    PVOID Buffer1;
    PVOID Buffer2;
    ERESOURCE_THREAD BufferOwner;
    ULONG BufferFlags;

    FAST_MUTEX BufferLock;
    KEVENT BufferNotification;

} LFS_DATA, *PLFS_DATA;

#define LFS_DATA_INIT_FAILED                (0x00000001)
#define LFS_DATA_INITIALIZED                (0x00000002)

#define LFS_BUFFER1_OWNED                   (0x00000001)
#define LFS_BUFFER2_OWNED                   (0x00000002)

#define LFS_BUFFER_SIZE                     (0x10000)

#define LFS_MAX_FLUSH_COUNT  VACB_MAPPING_GRANULARITY / LFS_DEFAULT_LOG_PAGE_SIZE

#endif // _LFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lsnsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LsnSup.c

Abstract:

    This module implements support for manipulating Lsn's.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LSN_SUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFindNextLsn)
#pragma alloc_text(PAGE, LfsLsnFinalOffset)
#endif


VOID
LfsLsnFinalOffset (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN ULONG DataLength,
    OUT PLONGLONG FinalOffset
    )

/*++

Routine Description:

    This routine will compute the final offset of the last byte of the log
    record.  It does this by computing how many bytes are on the current
    page and then computing how many more pages will be needed.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lsn - This is the log record being considered.

    DataLength - This is the length of the data for this log record.  We will add the
        header length here.

    FinalOffset - Address to store the result.

Return Value:

    None.

--*/

{
    ULONG RemainingPageBytes;
    ULONG PageOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsLsnFinalOffset:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          ->  %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lsn (Low)     ->  %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)    ->  %08lx\n", Lsn.HighPart );
    DebugTrace(  0, Dbg, "DataLength    ->  %08lx\n", DataLength );

    //
    //  We compute the starting log page file offset, the number of bytes
    //  remaining in the current log page and the position on this page
    //  before any data bytes.
    //

    LfsTruncateLsnToLogPage( Lfcb, Lsn, FinalOffset );

    PageOffset = LfsLsnToPageOffset( Lfcb, Lsn );

    RemainingPageBytes = (ULONG)Lfcb->LogPageSize - PageOffset;

    PageOffset -= 1;

    //
    //  Add the length of the header.
    //

    DataLength += Lfcb->RecordHeaderLength;

    //
    //  If this Lsn is contained in this log page we are done.
    //  Otherwise we need to walk through several log pages.
    //

    if (DataLength > RemainingPageBytes) {

        DataLength -= RemainingPageBytes;

        RemainingPageBytes = (ULONG)Lfcb->LogPageDataSize;

        PageOffset = (ULONG)Lfcb->LogPageDataOffset - 1;

        while (TRUE) {

            BOOLEAN Wrapped;

            LfsNextLogPageOffset( Lfcb, *FinalOffset, FinalOffset, &Wrapped );

            //
            //  We are done if the remaining bytes fit on this page.
            //

            if (DataLength <= RemainingPageBytes) {

                break;
            }

            DataLength -= RemainingPageBytes;
        }
    }

    //
    //  We add the remaining bytes to our starting position on this page
    //  and then add that value to the file offset of this log page.
    //

    *(PULONG)FinalOffset += (DataLength + PageOffset);

    DebugTrace(  0, Dbg, "FinalOffset (Low)     ->  %08lx\n", LogPageFileOffset.LowPart );
    DebugTrace(  0, Dbg, "FinalOffset (High)    ->  %08lx\n", LogPageFileOffset.HighPart );
    DebugTrace( -1, Dbg, "LfsLsnFinalOffset:  Exit\n", 0 );

    return;
}


BOOLEAN
LfsFindNextLsn (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine takes as a starting point the log record header of an
    Lsn in the log file.  It searches for the next Lsn in the file and
    returns that value in the 'Lsn' argument.  The boolean return value
    indicates whether there is another Lsn in the file.

Arguments:

    Lfcb - This is the file control block for the log file.

    RecordHeader - This is the log record for the Lsn starting point.

    Lsn - This supplies the address to store the next Lsn, if found.

Return Value:

    BOOLEAN - Indicates whether the next Lsn was found.

--*/

{
    BOOLEAN FoundNextLsn;

    LONGLONG LsnOffset;
    LONGLONG EndOfLogRecord;
    LONGLONG LogHeaderOffset;

    LONGLONG SequenceNumber;

    PLFS_RECORD_PAGE_HEADER LogRecordPage;
    PBCB LogRecordPageBcb;
    BOOLEAN UsaError;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindNextLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Record Header -> %08lx\n", RecordHeader );

    LogRecordPageBcb = NULL;
    FoundNextLsn = FALSE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Find the file offset of the log page which contains the end
        //  of the log record for this Lsn.
        //

        LsnOffset = LfsLsnToFileOffset( Lfcb, RecordHeader->ThisLsn );

        LfsLsnFinalOffset( Lfcb,
                           RecordHeader->ThisLsn,
                           RecordHeader->ClientDataLength,
                           &EndOfLogRecord );

        LfsTruncateOffsetToLogPage( Lfcb, EndOfLogRecord, &LogHeaderOffset );

        //
        //  Remember the sequence number for this page.
        //

        SequenceNumber = LfsLsnToSeqNumber( Lfcb, RecordHeader->ThisLsn );

        //
        //  Remember if we wrapped.
        //

        if ( EndOfLogRecord <= LsnOffset ) {                                                                           //**** xxLeq( EndOfLogRecord, LsnOffset )

            SequenceNumber = SequenceNumber + 1;                                                                       //**** xxAdd( SequenceNumber, LfsLi1 );
        }

        //
        //  Pin the log page header for this page.
        //

        LfsPinOrMapData( Lfcb,
                         LogHeaderOffset,
                         (ULONG)Lfcb->LogPageSize,
                         FALSE,
                         FALSE,
                         FALSE,
                         &UsaError,
                         (PVOID *)&LogRecordPage,
                         &LogRecordPageBcb );

        //
        //  If the Lsn we were given was not the last Lsn on this page, then
        //  the starting offset for the next Lsn is on a quad word boundary
        //  following the last file offset for the current Lsn.  Otherwise
        //  the file offset is the start of the data on the next page.
        //

        if ( RecordHeader->ThisLsn.QuadPart == LogRecordPage->Copy.LastLsn.QuadPart ) {                                //**** xxEql( RecordHeader->ThisLsn, LogRecordPage->Copy.LastLsn )

            BOOLEAN Wrapped;

            LfsNextLogPageOffset( Lfcb,
                                  LogHeaderOffset,
                                  &LogHeaderOffset,
                                  &Wrapped );

            LsnOffset = LogHeaderOffset + Lfcb->LogPageDataOffset;                                                     //**** xxAdd( LogHeaderOffset, Lfcb->LogPageDataOffset );

            //
            //  If we wrapped, we need to increment the sequence number.
            //

            if (Wrapped) {

                SequenceNumber = SequenceNumber + 1;                                                                   //**** xxAdd( SequenceNumber, LfsLi1 );
            }

        } else {

            LiQuadAlign( EndOfLogRecord, &LsnOffset );
        }

        //
        //  Compute the Lsn based on the file offset and the sequence count.
        //

        Lsn->QuadPart = LfsFileOffsetToLsn( Lfcb, LsnOffset, SequenceNumber );

        //
        //  If this Lsn is within the legal range for the file, we return TRUE.
        //  Otherwise FALSE indicates that there are no more Lsn's.
        //

        if (LfsIsLsnInFile( Lfcb, *Lsn )) {

            FoundNextLsn = TRUE;
        }

    } finally {

        DebugUnwind( LfsFindNextLsn );

        //
        //  Unpin the log page header if held.
        //

        if (LogRecordPageBcb != NULL) {

            CcUnpinData( LogRecordPageBcb );
        }

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsFindNextLsn:  Exit -> %08x\n", FoundNextLsn );
    }

    return FoundNextLsn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\nodetype.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                       ((NODE_TYPE_CODE)0x0000)

#define LFS_NTC_LEB                         ((NODE_TYPE_CODE)0x800)
#define LFS_NTC_LCH                         ((NODE_TYPE_CODE)0x801)
#define LFS_NTC_LBCB                        ((NODE_TYPE_CODE)0x802)
#define LFS_NTC_LFCB                        ((NODE_TYPE_CODE)0x803)
#define LFS_NTC_DATA                        ((NODE_TYPE_CODE)0x804)

typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\logpgsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LogPgSup.c

Abstract:

    This module implements support for manipulating log pages.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOG_PAGE_SUP)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('PsfL')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsAllocateSpanningBuffer)
#pragma alloc_text(PAGE, LfsFreeSpanningBuffer)
#pragma alloc_text(PAGE, LfsNextLogPageOffset)
#endif


VOID
LfsNextLogPageOffset (
    IN PLFCB Lfcb,
    IN LONGLONG CurrentLogPageOffset,
    OUT PLONGLONG NextLogPageOffset,
    OUT PBOOLEAN Wrapped
    )

/*++

Routine Description:

    This routine will compute the offset in the log file of the next log
    page.

Arguments:

    Lfcb - This is the file control block for the log file.

    CurrentLogPageOffset - This is the file offset of the current log page.

    NextLogPageOffset - Address to store the next log page to use.

    Wrapped - This is a pointer to a boolean variable that, if present,
              we use to indicate whether we wrapped in the log file.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsNextLogPageOffset:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                          ->  %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "CurrentLogPageOffset (Low)    ->  %08lx\n", CurrentLogPageOffset.LowPart );
    DebugTrace(  0, Dbg, "CurrentLogPageOffset (High)   ->  %08lx\n", CurrentLogPageOffset.HighPart );
    DebugTrace(  0, Dbg, "Wrapped                       ->  %08lx\n", Wrapped );

    //
    //  We add the log page size to the current log offset.
    //

    LfsTruncateOffsetToLogPage( Lfcb, CurrentLogPageOffset, &CurrentLogPageOffset );
    *NextLogPageOffset = CurrentLogPageOffset + Lfcb->LogPageSize;                                                     //**** xxAdd( CurrentLogPageOffset, Lfcb->LogPageSize );

    //
    //  If the result is larger than the file, we use the first page offset
    //  in the file.
    //

    if ( *NextLogPageOffset >= Lfcb->FileSize ) {                                                                      //**** xxGeq( *NextLogPageOffset, Lfcb->FileSize )

        *NextLogPageOffset = Lfcb->FirstLogPage;

        *Wrapped = TRUE;

    } else {

        *Wrapped = FALSE;
    }

    DebugTrace(  0, Dbg, "NextLogPageOffset (Low)    ->  %08lx\n", NextLogPageOffset->LowPart );
    DebugTrace(  0, Dbg, "NextLogPageOffset (High)   ->  %08lx\n", NextLogPageOffset->HighPart );
    DebugTrace(  0, Dbg, "Wrapped                    ->  %08x\n", *Wrapped );
    DebugTrace( -1, Dbg, "LfsNextLogPageOffset:  Exit\n", 0 );

    return;
}


PVOID
LfsAllocateSpanningBuffer (
    IN PLFCB Lfcb,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called to allocate a spare buffer to read a file record
    which spans a log page.  We will first try to allocate one.  If that
    fails we will use one of the existing spare buffers.  If that fails then
    we will raise.

Arguments:

    Lfcb - This is the file control block for the log file.

    Length - Length of the buffer required.

Return Value:

    PVOID - Pointer to the buffer to use for reading the log record.
        May be either from pool or from the auxilary buffer pool.

--*/

{
    PVOID NewBuffer = NULL;
    ERESOURCE_THREAD Thread;
    BOOLEAN Wait = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsAllocateSpanningBuffer:  Entered\n", 0 );

    //
    //  Loop while we don't have a buffer.  First try to get our reserved buffer
    //  without waiting.  Then try to allocate a buffer.  Finally wait for the reserved
    //  buffer as the final alternative.
    //

    do {

        //
        //  Skip the reserved buffer if the request is larger than we can read into it.
        //

        if (Length <= LFS_BUFFER_SIZE) {

            //
            //  If this thread already owns one buffer it can get the second directly.
            //

            Thread = ExGetCurrentResourceThread();

            if (Thread == LfsData.BufferOwner) {

                if (!FlagOn( LfsData.BufferFlags, LFS_BUFFER1_OWNED )) {

                    SetFlag( LfsData.BufferFlags, LFS_BUFFER1_OWNED );
                    NewBuffer = LfsData.Buffer1;
                    break;

                } else if (!FlagOn( LfsData.BufferFlags, LFS_BUFFER2_OWNED )) {

                    SetFlag( LfsData.BufferFlags, LFS_BUFFER2_OWNED );
                    NewBuffer = LfsData.Buffer2;
                    break;

                } else if (Wait) {

                    //
                    //  This shouldn't happen but handle anyway.
                    //

                    DebugTrace( -1, Dbg, "LfsAllocateSpanningBuffer:  Exit\n", 0 );
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

            //
            //  Otherwise acquire the buffer lock and check the state of the buffers.
            //

            } else {

                BOOLEAN LfcbOwned = TRUE;

                while (TRUE) {

                    LfsAcquireBufferLock();

                    //
                    //  Check to see if the buffers are available.  No
                    //  need to drop the Lfcb in the typical case.
                    //

                    if (LfsData.BufferOwner == (ERESOURCE_THREAD) NULL) {

                        ASSERT( !FlagOn( LfsData.BufferFlags, LFS_BUFFER1_OWNED | LFS_BUFFER2_OWNED ));
                        NewBuffer = LfsData.Buffer1;
                        LfsData.BufferOwner = Thread;
                        SetFlag( LfsData.BufferFlags, LFS_BUFFER1_OWNED );
                        LfsBlockBufferWaiters();
                        
                        //
                        //  Reacquire the Lfcb if needed.
                        //

                        if (!LfcbOwned) { 

                            LfsAcquireLfcbExclusive( Lfcb );
                        }

                        //
                        //  Break out.
                        //

                        LfsReleaseBufferLock();
                        break;
                    }

                    //
                    //  Release the Lfcb and wait on the notification for the buffers.
                    //

                    if (Wait) {

                        if (LfcbOwned) { 
                            LfsReleaseLfcb( Lfcb );
                            LfcbOwned = FALSE;
                        }

                        LfsReleaseBufferLock();
                        LfsWaitForBufferNotification();

                    } else {

                        //
                        //  Go ahead and try to allocate a buffer from pool next.
                        //

                        LfsReleaseBufferLock();
                        break;
                    }
                }
            }

        //
        //  Raise if we already tried the allocate path.
        //

        } else if (Wait) {

            DebugTrace( -1, Dbg, "LfsAllocateSpanningBuffer:  Exit\n", 0 );
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Try pool if we didn't get a buffer above.
        //

        if (NewBuffer == NULL) {

            //
            //  Try pool next but don't let this fail on pool allocation.
            //

            NewBuffer = LfsAllocatePoolNoRaise( PagedPool, Length );
        }

        //
        //  Wait on the next pass through the loop.
        //

        Wait = TRUE;

    } while (NewBuffer == NULL);

    DebugTrace( -1, Dbg, "LfsAllocateSpanningBuffer:  Exit\n", 0 );
    return NewBuffer;
}

VOID
LfsFreeSpanningBuffer (
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine is called to free a buffer used to read a log record
    which spans pages.  We will check if it is one of our special buffers
    and deal with synchronization in that case.

Arguments:

    Buffer - Buffer to free.

Return Value:

    None.

--*/

{
    ERESOURCE_THREAD Thread;
    ULONG BufferFlag;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFreeSpanningBuffer:  Entered\n", 0 );

    //
    //  Check if either buffer1 or buffer2 are being freed.
    //

    if (Buffer == LfsData.Buffer1) {

        BufferFlag = LFS_BUFFER1_OWNED;
        goto ReservedBuffers;

    } else if (Buffer == LfsData.Buffer2) {

        BufferFlag = LFS_BUFFER2_OWNED;

ReservedBuffers:

        //
        //  Acquire the buffer lock and clear the correct flag.
        //

        LfsAcquireBufferLock();
        ClearFlag( LfsData.BufferFlags, BufferFlag );

        //
        //  If no buffers owned then signal the waiters.
        //

        if (!FlagOn( LfsData.BufferFlags, LFS_BUFFER1_OWNED | LFS_BUFFER2_OWNED )) {

            LfsData.BufferOwner = (ERESOURCE_THREAD) NULL;
            LfsNotifyBufferWaiters();
        }

        LfsReleaseBufferLock();

    } else {

        //
        //  Simply free the buffer.
        //

        LfsFreePool( Buffer );
    }

    DebugTrace( -1, Dbg, "LfsFreeSpanningBuffer:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\querylog.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    QueryLog.c

Abstract:

    This module implements the user routines which query for log records
    in a log file.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_QUERY)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('QsfL')

VOID
LfsFindLogRecord (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    IN LSN Lsn,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    );

BOOLEAN
LfsFindClientNextLsn (
    IN PLFCB Lfcb,
    IN PLEB Leb,
    OUT PLSN Lsn
    );

BOOLEAN
LfsSearchForwardByClient (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    OUT PLSN Lsn
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFindClientNextLsn)
#pragma alloc_text(PAGE, LfsFindLogRecord)
#pragma alloc_text(PAGE, LfsQueryLastLsn)
#pragma alloc_text(PAGE, LfsReadLogRecord)
#pragma alloc_text(PAGE, LfsReadNextLogRecord)
#pragma alloc_text(PAGE, LfsSearchForwardByClient)
#pragma alloc_text(PAGE, LfsTerminateLogQuery)
#endif


VOID
LfsReadLogRecord (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN FirstLsn,
    IN LFS_CONTEXT_MODE ContextMode,
    OUT PLFS_LOG_CONTEXT Context,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine initiates the query operation.  It returns the log record
    in question and a context structure used by the Lfs to return related
    log records.  The caller specifies what mode of query to use.  He may
    walk backwards through the file by Undo records or all records for
    this client linked through the previous Lsn fields.  He may also look
    forwards through the file for all records for the issuing client.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    FirstLsn - Starting record for this query operation.

    ContextMode - Method of query.

    Context - Supplies the address to store a pointer to the Lfs created
              context structure.

    RecordType - Supplies the address to store the record type of this
                 log record.

    TransactionId - Supplies the address to store the transaction Id of
                    this log record.

    UndoNextLsn - Supplies the address to store the Undo Next Lsn for this
                  log record.

    PreviousLsn - Supplies the address to store the Previous Lsn for this
                  log record.

    BufferLength - This is the length of the log data.

    Buffer - This is a pointer to the start of the log data.

Return Value:

    None

--*/

{
    PLFS_CLIENT_RECORD ClientRecord;

    PLCH Lch;

    PLFCB Lfcb;

    PLEB Leb = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "First Lsn (Low)   -> %08lx\n", FirstLsn.LowPart );
    DebugTrace(  0, Dbg, "First Lsn (High)  -> %08lx\n", FirstLsn.HighPart );
    DebugTrace(  0, Dbg, "Context Mode      -> %08lx\n", ContextMode );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the context mode is valid.
    //

    switch (ContextMode) {

    case LfsContextUndoNext :
    case LfsContextPrevious :
    case LfsContextForward :

        break;

    default:

        DebugTrace( 0, Dbg, "Invalid context mode -> %08x\n", ContextMode );
        ExRaiseStatus( STATUS_INVALID_PARAMETER );
    }

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-except to catch errors.
    //

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Check that the given Lsn is in the legal range for this client.
        //

        ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                Lch->ClientArrayByteOffset,
                                PLFS_CLIENT_RECORD );

        if (!LfsVerifyClientLsnInRange( Lfcb, ClientRecord, FirstLsn )) {

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  We can give up the Lfcb as we know the Lsn is within the file.
        //

        LfsReleaseLch( Lch );

        //
        //  Allocate and initialize an enumeration structure.
        //

        LfsAllocateLeb( Lfcb, &Leb );

        LfsInitializeLeb( Leb,
                          Lch->ClientId,
                          ContextMode );

        //
        //  Find the log record indicated by the given Lsn.
        //

        LfsFindLogRecord( Lfcb,
                          Leb,
                          FirstLsn,
                          RecordType,
                          TransactionId,
                          UndoNextLsn,
                          PreviousLsn,
                          BufferLength,
                          Buffer );

        //
        //  Update the client's arguments.
        //

        *Context = Leb;
        Leb = NULL;

    } finally {

        DebugUnwind( LfsReadLogRecord );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        //
        //  Deallocate the enumeration block if an error occurred.
        //

        if (Leb != NULL) {

            LfsDeallocateLeb( Lfcb, Leb );
        }

        DebugTrace(  0, Dbg, "Context       -> %08lx\n", *Context );
        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", *Buffer );
        DebugTrace( -1, Dbg, "LfsReadLogRecord:  Exit\n", 0 );
    }

    return;
}


BOOLEAN
LfsReadNextLogRecord (
    IN LFS_LOG_HANDLE LogHandle,
    IN OUT LFS_LOG_CONTEXT Context,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PLSN Lsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called to continue a query operation.  The Lfs uses
    private information stored in the enumeration structure to determine the
    next log record to return to the caller.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Context - Supplies the address to store a pointer to the Lfs created
              enumeration structure.

    Lsn - Lsn for this log record.

    RecordType - Supplies the address to store the record type of this
                 log record.

    TransactionId - Supplies the address to store the transaction Id of
                    this log record.

    UndoNextLsn - Supplies the address to store the Undo Next Lsn for this
                  log record.

    PreviousLsn - Supplies the address to store the Previous Lsn for this
                  log record.

    BufferLength - This is the length of the log data.

    Buffer - This is a pointer to the start of the log data.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    PLEB Leb;

    BOOLEAN FoundNextLsn;

    BOOLEAN UnwindRememberLebFields;
    PBCB UnwindRecordHeaderBcb;
    PLFS_RECORD_HEADER UnwindRecordHeader;
    PVOID UnwindCurrentLogRecord;
    BOOLEAN UnwindAuxilaryBuffer;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadNextLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Context       -> %08lx\n", Context );

    FoundNextLsn = FALSE;

    UnwindRememberLebFields = FALSE;

    Lch = (PLCH) LogHandle;
    Leb = (PLEB) Context;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Check that the enumeration structure is valid.
        //

        LfsValidateLeb( Leb, Lch );

        //
        //  Remember any enumeration fields to be overwritten.
        //

        UnwindRememberLebFields = TRUE;

        UnwindRecordHeaderBcb = Leb->RecordHeaderBcb;
        Leb->RecordHeaderBcb = NULL;

        UnwindRecordHeader = Leb->RecordHeader;
        UnwindCurrentLogRecord = Leb->CurrentLogRecord;

        UnwindAuxilaryBuffer = Leb->AuxilaryBuffer;
        Leb->AuxilaryBuffer = FALSE;

        //
        //  Find the next Lsn number based on the current Lsn number in
        //  the enumeration block.
        //

        if (LfsFindClientNextLsn( Lfcb, Leb, Lsn )) {

            //
            //  We can give up the Lfcb as we know the Lsn is within the file.
            //

            LfsReleaseLfcb( Lfcb );

            //
            //  Cleanup the enumeration block so we can do the next search.
            //

            Leb->CurrentLogRecord = NULL;
            Leb->AuxilaryBuffer = FALSE;

            //
            //  Perform the work of getting the log record.
            //

            LfsFindLogRecord( Lfcb,
                              Leb,
                              *Lsn,
                              RecordType,
                              TransactionId,
                              UndoNextLsn,
                              PreviousLsn,
                              BufferLength,
                              Buffer );

            FoundNextLsn = TRUE;
        }

    } finally {

        DebugUnwind( LfsReadNextLogRecord );

        //
        //  If we exited due to an error, we have to restore the enumeration
        //  block.
        //

        if (UnwindRememberLebFields) {

            if (AbnormalTermination()) {

                //
                //  If the record header in the enumeration block is not
                //  the same as we started with.  Then we unpin that
                //  data.
                //

                if (Leb->RecordHeaderBcb != NULL) {

                    CcUnpinData( Leb->RecordHeaderBcb );

                }

                if (Leb->CurrentLogRecord != NULL
                    && Leb->AuxilaryBuffer == TRUE) {

                    LfsFreeSpanningBuffer( Leb->CurrentLogRecord );
                }

                Leb->RecordHeaderBcb = UnwindRecordHeaderBcb;
                Leb->RecordHeader = UnwindRecordHeader;
                Leb->CurrentLogRecord = UnwindCurrentLogRecord;
                Leb->AuxilaryBuffer = UnwindAuxilaryBuffer;

            //
            //  Otherwise, if we have successfully found the next Lsn,
            //  we free up any resources being held from the previous search.
            //

            } else if (FoundNextLsn ) {

                if (UnwindRecordHeaderBcb != NULL) {

                    CcUnpinData( UnwindRecordHeaderBcb );
                }

                if (UnwindCurrentLogRecord != NULL
                    && UnwindAuxilaryBuffer == TRUE) {

                    LfsFreeSpanningBuffer( UnwindCurrentLogRecord );
                }

            //
            //  Restore the Bcb and auxilary buffer field for the final
            //  cleanup.
            //

            } else {

                if (UnwindRecordHeaderBcb != NULL) {

                    if (Leb->RecordHeaderBcb != NULL) {

                        CcUnpinData( UnwindRecordHeaderBcb );

                    } else {

                        Leb->RecordHeaderBcb = UnwindRecordHeaderBcb;
                    }
                }

                if (UnwindAuxilaryBuffer) {

                    if (Leb->CurrentLogRecord == UnwindCurrentLogRecord) {

                        Leb->AuxilaryBuffer = TRUE;

                    } else {

                        LfsFreeSpanningBuffer( UnwindCurrentLogRecord );
                    }
                }
            }
        }

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", *Buffer );
        DebugTrace( -1, Dbg, "LfsReadNextLogRecord:  Exit\n", 0 );
    }
    return FoundNextLsn;
}


VOID
LfsTerminateLogQuery (
    IN LFS_LOG_HANDLE LogHandle,
    IN LFS_LOG_CONTEXT Context
    )

/*++

Routine Description:

    This routine is called when a client has completed his query operation
    and wishes to deallocate any resources acquired by the Lfs to
    perform the log file query.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Context - Supplies the address to store a pointer to the Lfs created
              enumeration structure.

Return Value:

    None

--*/

{
    PLCH Lch;
    PLEB Leb;

    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsTerminateLogQuery:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Context       -> %08lx\n", Context );

    Lch = (PLCH) LogHandle;
    Leb = (PLEB) Context;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            try_return( NOTHING );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Check that the enumeration structure is valid.
        //

        LfsValidateLeb( Leb, Lch );

        //
        //  Deallocate the enumeration block.
        //

        LfsDeallocateLeb( Lfcb, Leb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( LfsTerminateLogQuery );

        //
        //  Release the Lfcb if acquired.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsTerminateLogQuery:  Exit\n", 0 );
    }

    return;
}


LSN
LfsQueryLastLsn (
    IN LFS_LOG_HANDLE LogHandle
    )

/*++

Routine Description:

    This routine will return the most recent Lsn for this log record.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

Return Value:

    LSN - This is the last Lsn assigned in this log file.

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    LSN LastLsn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsQueryLastLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Copy the last Lsn out of the Lfcb.  If the last Lsn is
        //  does not correspond to a log record, we will return the
        //  zero Lsn.
        //

        if (FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN )) {

            LastLsn = LfsZeroLsn;

        } else {

            LastLsn = Lfcb->RestartArea->CurrentLsn;
        }

    } finally {

        DebugUnwind( LfsQueryLastLsn );

        //
        //  Release the Lfcb if acquired.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Last Lsn (Low)    -> %08lx\n", LastLsn.LowPart );
        DebugTrace(  0, Dbg, "Last Lsn (High)   -> %08lx\n", LastLsn.HighPart );
        DebugTrace( -1, Dbg, "LfsQueryLastLsn:  Exit\n", 0 );
    }

    return LastLsn;
}


//
//  Local support routine.
//

VOID
LfsFindLogRecord (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    IN LSN Lsn,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called recover a log record for a client.

Arguments:

    Lfcb - Log file control block for this file.

    Leb - Pointer to the enumeration block to update.

    Lsn - This is the Lsn for the log record.

    RecordType - Supplies the address to store the record type of this
                 log record.

    TransactionId - Supplies the address to store the transaction Id of
                    this log record.

    UndoNextLsn - Supplies the address to store the Undo Next Lsn for this
                  log record.

    PreviousLsn - Supplies the address to store the Previous Lsn for this
                  log record.

    BufferLength - Pointer to address to store the length in bytes of the
                   log record.

    Buffer - Pointer to store the address where the log record data begins.

Return Value:

    None

--*/

{
    PCHAR NewBuffer;
    BOOLEAN UsaError;
    LONGLONG LogRecordLength;
    ULONG PageOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Enumeration Block -> %08lx\n", Leb );
    DebugTrace(  0, Dbg, "Lsn (Low)         -> %08lx\n", Lsn.LowPart );

    NewBuffer = NULL;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Map the record header for this Lsn if we haven't already.
        //

        if (Leb->RecordHeader == NULL) {

            LfsPinOrMapLogRecordHeader( Lfcb,
                                        Lsn,
                                        FALSE,
                                        FALSE,
                                        &UsaError,
                                        &Leb->RecordHeader,
                                        &Leb->RecordHeaderBcb );
        }

        //
        //  We now have the log record desired.  If the Lsn in the
        //  log record doesn't match the desired Lsn then the disk is
        //  corrupt.
        //

        if ( Lsn.QuadPart != Leb->RecordHeader->ThisLsn.QuadPart ) {                                                   //**** xxNeq( Lsn, Leb->RecordHeader->ThisLsn )

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  Check that the length field isn't greater than the total available space
        //  in the log file.
        //

        LogRecordLength = Leb->RecordHeader->ClientDataLength + Lfcb->RecordHeaderLength;                              //**** xxFromUlong( Leb->RecordHeader->ClientDataLength + Lfcb->RecordHeaderLength );

        if ( LogRecordLength >= Lfcb->TotalAvailable ) {                                                               //**** xxGeq( LogRecordLength, Lfcb->TotalAvailable )

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  If the entire log record is on this log page, put a pointer to
        //  the log record in the enumeration block.
        //

        if (!FlagOn( Leb->RecordHeader->Flags, LOG_RECORD_MULTI_PAGE )) {

            //
            //  If client size indicates that we have to go beyond the end of the current
            //  page, we raise an error.
            //

            PageOffset = LfsLsnToPageOffset( Lfcb, Lsn );

            if ((PageOffset + Leb->RecordHeader->ClientDataLength + Lfcb->RecordHeaderLength)
                > (ULONG)Lfcb->LogPageSize) {

                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            Leb->CurrentLogRecord = Add2Ptr( Leb->RecordHeader, LFS_RECORD_HEADER_SIZE, PVOID );
            Leb->AuxilaryBuffer = FALSE;

        //
        //  Else we copy the data and remember that we allocated a buffer.
        //

        } else {

            NewBuffer = LfsAllocateSpanningBuffer( Lfcb, Leb->RecordHeader->ClientDataLength );

            //
            //  Copy the data into the buffer returned.
            //

            LfsCopyReadLogRecord( Lfcb,
                                  Leb->RecordHeader,
                                  NewBuffer );

            Leb->CurrentLogRecord = NewBuffer;

            Leb->AuxilaryBuffer = TRUE;

            NewBuffer = NULL;
        }

        //
        //  We need to update the caller's parameters and the enumeration block.
        //

        *RecordType = Leb->RecordHeader->RecordType;
        *TransactionId = Leb->RecordHeader->TransactionId;

        *UndoNextLsn = Leb->RecordHeader->ClientUndoNextLsn;
        *PreviousLsn = Leb->RecordHeader->ClientPreviousLsn;

        *Buffer = Leb->CurrentLogRecord;
        *BufferLength = Leb->RecordHeader->ClientDataLength;

    } finally {

        DebugUnwind( LfsFindLogRecord );

        //
        //  If an error occurred we unpin the record header and the log
        //  We also free the buffer if allocated by us.
        //

        if (NewBuffer != NULL) {

            LfsFreeSpanningBuffer( NewBuffer );
        }

        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", *Buffer );
        DebugTrace( -1, Dbg, "LfsFindLogRecord:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine.
//

BOOLEAN
LfsFindClientNextLsn (
    IN PLFCB Lfcb,
    IN PLEB Leb,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine will attempt to find the next Lsn to return to a client
    based on the context mode.

Arguments:

    Lfcb - File control block for this log file.

    Leb - Pointer to the enumeration block for this query operation.

    Lsn - Pointer to store the Lsn found (if any)

Return Value:

    BOOLEAN - TRUE if an Lsn is found, FALSE otherwise.

--*/

{
    LSN NextLsn;
    BOOLEAN NextLsnFound;

    PLFS_CLIENT_RECORD ClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindClientNextLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Leb  -> %08lx\n", Leb );

    ClientRecord = Lfcb->ClientArray + Leb->ClientId.ClientIndex;

    //
    //  The enumeration block has the last Lsn returned.  If the user wanted
    //  one of the Lsn's in that log header then our job is simple.
    //

    switch (Leb->ContextMode) {

    case LfsContextUndoNext:
    case LfsContextPrevious:

        NextLsn = (Leb->ContextMode == LfsContextUndoNext
                   ? Leb->RecordHeader->ClientUndoNextLsn
                   : Leb->RecordHeader->ClientPreviousLsn);

        if ( NextLsn.QuadPart == 0 ) {                                                                                 //**** xxEqlZero( NextLsn )

            NextLsnFound = FALSE;

        } else if (LfsVerifyClientLsnInRange( Lfcb, ClientRecord, NextLsn )) {

            BOOLEAN UsaError;

            LfsPinOrMapLogRecordHeader( Lfcb,
                                        NextLsn,
                                        FALSE,
                                        FALSE,
                                        &UsaError,
                                        &Leb->RecordHeader,
                                        &Leb->RecordHeaderBcb );

            NextLsnFound = TRUE;

        } else {

            NextLsnFound = FALSE;
        }

        break;

    case LfsContextForward:

        //
        //  We search forward for the next log record for this client.
        //

        NextLsnFound = LfsSearchForwardByClient( Lfcb, Leb, &NextLsn );
        break;

    default:

        NextLsnFound = FALSE;
        break;
    }

    if (NextLsnFound) {

        *Lsn = NextLsn;
    }

    DebugTrace(  0, Dbg, "NextLsn (Low)     -> %08lx\n", NextLsn.LowPart );
    DebugTrace(  0, Dbg, "NextLsn (High)    -> %08lx\n", NextLsn.HighPart );
    DebugTrace( -1, Dbg, "LfsFindClientNextLsn:  Exit -> %08x\n", NextLsnFound );

    return NextLsnFound;
}


//
//  Local support routine.
//

BOOLEAN
LfsSearchForwardByClient (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine will attempt to find the next Lsn for this client by searching
    forward in the file, looking for a match.

Arguments:

    Lfcb - Pointer to the file control block for this log file.

    Leb - Pointer to the enumeration block for this query operation.

    Lsn - Points to the location to store the next Lsn if found.

Return Value:

    BOOLEAN - TRUE if another Lsn for this client is found.  FALSE otherwise.

--*/

{
    PLFS_RECORD_HEADER CurrentRecordHeader;
    PBCB CurrentBcb;

    BOOLEAN FoundNextLsn;

    LSN CurrentLsn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsSearchForwardByClient:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Leb  -> %08lx\n", Leb );

    //
    //  The log record header is in the log enumeration
    //  block.  We set the current Bcb to NULL so that we don't
    //  unpin the log record in the enumeration block until we're sure
    //  of success.
    //

    CurrentRecordHeader = Leb->RecordHeader;

    CurrentBcb = NULL;

    //
    //  We use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We assume we won't find another Lsn.
        //

        FoundNextLsn = FALSE;

        //
        //  Loop as long as another Lsn can be found.
        //

        while (LfsFindNextLsn( Lfcb, CurrentRecordHeader, &CurrentLsn )) {

            BOOLEAN UsaError;

            //
            //  Unpin the previous log record header.
            //

            if (CurrentBcb != NULL) {

                CcUnpinData( CurrentBcb );
                CurrentBcb = NULL;
            }

            //
            //  Pin the log record header for this Lsn.
            //

            LfsPinOrMapLogRecordHeader( Lfcb,
                                        CurrentLsn,
                                        FALSE,
                                        FALSE,
                                        &UsaError,
                                        &CurrentRecordHeader,
                                        &CurrentBcb );

            //
            //  If the client values match, then we update the
            //  enumeration block and exit.
            //

            if (LfsClientIdMatch( &CurrentRecordHeader->ClientId,
                                  &Leb->ClientId )
                && CurrentRecordHeader->RecordType == LfsClientRecord) {

                //
                //  We remember this one.
                //

                Leb->RecordHeader = CurrentRecordHeader;
                Leb->RecordHeaderBcb = CurrentBcb;

                CurrentBcb = NULL;
                FoundNextLsn = TRUE;

                *Lsn = CurrentLsn;
                break;
            }
        }

    } finally {

        DebugUnwind( LfsSearchForwardByClient );

        //
        //  Unpin any log record headers still pinned for no reason.
        //

        if (CurrentBcb != NULL) {

            CcUnpinData( CurrentBcb );
        }

        DebugTrace(  0, Dbg, "NextLsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "NextLsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsSearchForwardByClient:  Exit -> %08x\n", FoundNextLsn );
    }

    return FoundNextLsn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\registry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

    This module implements the routines which clients use to register
    themselves with the Log File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_REGISTRY)
#define MODULE_POOL_TAG ('rsfL')

PLFCB
LfsRestartLogFile (
    IN PFILE_OBJECT LogFile,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_WRITE_DATA WriteData
    );

VOID
LfsNormalizeBasicLogFile (
    IN OUT PLONGLONG FileSize,
    IN OUT PULONG LogPageSize,
    IN OUT PUSHORT LogClients,
    IN BOOLEAN UseDefaultLogPage
    );

VOID
LfsUpdateLfcbFromPgHeader (
    IN PLFCB Lfcb,
    IN ULONG LogPageSize,
    IN SHORT MajorVersion,
    IN SHORT MinorVersion,
    IN BOOLEAN PackLog
    );

VOID
LfsUpdateLfcbFromNoRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN LSN LastLsn,
    IN ULONG LogClients,
    IN ULONG OpenLogCount,
    IN BOOLEAN LogFileWrapped,
    IN BOOLEAN UseMultiplePageIo
    );

VOID
LfsUpdateLfcbFromRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN PLFS_RESTART_AREA RestartArea,
    IN USHORT RestartOffset
    );

VOID
LfsUpdateRestartAreaFromLfcb (
    IN PLFCB Lfcb,
    IN PLFS_RESTART_AREA RestartArea
    );

VOID
LfsInitializeLogFilePriv (
    IN PLFCB Lfcb,
    IN BOOLEAN ForceRestartToDisk,
    IN ULONG RestartAreaSize,
    IN LONGLONG StartOffsetForClear,
    IN BOOLEAN ClearLogFile
    );

VOID
LfsFindLastLsn (
    IN OUT PLFCB Lfcb
    );

VOID
LfsFlushLogPage (
    IN PLFCB Lfcb,
    PVOID LogPage,
    IN LONGLONG FileOffset,
    OUT PBCB *Bcb
    );

VOID
LfsRemoveClientFromList (
    IN PLFS_CLIENT_RECORD ClientArray,
    IN PLFS_CLIENT_RECORD ClientRecord,
    IN PUSHORT ListHead
    );

VOID
LfsAddClientToList (
    IN PLFS_CLIENT_RECORD ClientArray,
    IN USHORT ClientIndex,
    IN PUSHORT ListHead
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsAddClientToList)
#pragma alloc_text(PAGE, LfsCheckSubsequentLogPage)
#pragma alloc_text(PAGE, LfsCloseLogFile)
#pragma alloc_text(PAGE, LfsDeleteLogHandle)
#pragma alloc_text(PAGE, LfsFindLastLsn)
#pragma alloc_text(PAGE, LfsFlushLogPage)
#pragma alloc_text(PAGE, LfsInitializeLogFilePriv)
#pragma alloc_text(PAGE, LfsNormalizeBasicLogFile)
#pragma alloc_text(PAGE, LfsOpenLogFile)
#pragma alloc_text(PAGE, LfsReadLogFileInformation)
#pragma alloc_text(PAGE, LfsRemoveClientFromList)
#pragma alloc_text(PAGE, LfsResetUndoTotal)
#pragma alloc_text(PAGE, LfsRestartLogFile)
#pragma alloc_text(PAGE, LfsUpdateLfcbFromRestart)
#pragma alloc_text(PAGE, LfsUpdateLfcbFromNoRestart)
#pragma alloc_text(PAGE, LfsUpdateLfcbFromPgHeader)
#pragma alloc_text(PAGE, LfsUpdateRestartAreaFromLfcb)
#pragma alloc_text(PAGE, LfsVerifyLogFile)
#endif


ULONG
LfsOpenLogFile (
    IN PFILE_OBJECT LogFile,
    IN UNICODE_STRING ClientName,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_LOG_HANDLE LogHandle,
    OUT PLFS_WRITE_DATA WriteData
    )

/*++

Routine Description:

    This routine is called when a client wishes to register with logging
    service.  This can be a reregistration (i.e. restart after a crash)
    or an initial registration.  There can be no other active clients
    with the same name.  The Log Handle returned is then used for any
    subsequent access by this client.

    If an Lfs restart has not been done on the log file, it will be done
    at this time.

Arguments:

    LogFile - A file object for a file previously initialized for use
              as a log file.

    ClientName - This unicode string is used to uniquely identify clients
                 of the logging service.  A case-sensitive comparison is
                 used to check this name against active clients of the
                 log file.

    MaximumClients - The maximum number of clients if the log file has
                     never been initialized.

    LogPageSize - This is the recommeded size for the log page.

    FileSize - This is the size of the log file.

    LfsInfo - On entry, indicates the log file state the user may
        know about.  On exit, indicates the log file state that Lfs
        knows about.  This is a conduit for Lfs to communicate with its
        clients.

    LogHandle - The address to store the identifier the logging service
                will use to identify this client in all other Lfs calls.

    WriteData - Pointer to WRITE_DATA in caller's data structure.

Return Value:

    ULONG - Amount to add to reservation value for header for log record.

--*/

{
    PLIST_ENTRY Link;
    PLFCB ThisLfcb = NULL;
    PLFCB NewLfcb = NULL;

    USHORT ThisClient;
    PLFS_CLIENT_RECORD ClientRecord;

    PLCH Lch = NULL;

    ULONG ReservedHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsOpenLogFile:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log File          -> %08lx\n", LogFile );
    DebugTrace(  0, Dbg, "Client Name       -> %08lx\n", &ClientName );
    DebugTrace(  0, Dbg, "Maximum Clients   -> %04x\n", MaximumClients );
    DebugTrace(  0, Dbg, "Log Page Size     -> %08lx\n", LogPageSize );
    DebugTrace(  0, Dbg, "File Size (Low)   -> %08lx\n", FileSize.LowPart );
    DebugTrace(  0, Dbg, "File Size (High)  -> %08lx\n", FileSize.HighPart );

    //
    //  Check that the client name length is a legal length.
    //

    if (ClientName.Length > LFS_CLIENT_NAME_MAX) {

        DebugTrace(  0, Dbg, "Illegal name length for client\n", 0 );
        DebugTrace( -1, Dbg, "LfsOpenLogFile:  Exit\n", 0 );
        ExRaiseStatus( STATUS_INVALID_PARAMETER );
    }


    //
    //  Aqcuire the global data.
    //

    LfsAcquireLfsData();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Walk through the list searching for this file object.
        //

        Link = LfsData.LfcbLinks.Flink;

        while (Link != &LfsData.LfcbLinks) {

            ThisLfcb = CONTAINING_RECORD( Link, LFCB, LfcbLinks );

            if (ThisLfcb->FileObject == LogFile) {

                DebugTrace( 0, Dbg, "Found matching log file\n", 0 );
                break;
            }

            Link = Link->Flink;
        }

        //
        //  If the log file doesn't exist, create an Lfcb and perform an
        //  Lfs restart.
        //

        if (Link == &LfsData.LfcbLinks) {

            //
            //  Call the Cache Manager to disable read ahead and write behind;
            //  we flush the log file explicitly.
            //

            CcSetAdditionalCacheAttributes( LogFile, TRUE, TRUE );

            //
            //  Perform Lfs restart on this file object.
            //

            ThisLfcb = NewLfcb = LfsRestartLogFile( LogFile,
                                                    MaximumClients,
                                                    LogPageSize,
                                                    FileSize,
                                                    LfsInfo,
                                                    WriteData );

            //
            //  Insert this Lfcb into the global list.
            //

            InsertHeadList( &LfsData.LfcbLinks, &ThisLfcb->LfcbLinks );
        }

        //
        //  At this point we have the log file control block for the file
        //  object given us.  We first check whether the log file is fatally
        //  corrupt.
        //

        if (FlagOn( ThisLfcb->Flags, LFCB_LOG_FILE_CORRUPT )) {

            //
            //  We leave the in-memory data alone and raise an error if
            //  anyone attempts to access this file.
            //

            DebugTrace( 0, Dbg, "The Lfcb is corrupt\n", 0 );
            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  Search through and look for a client match.
        //

        ThisClient = ThisLfcb->RestartArea->ClientInUseList;

        while (ThisClient != LFS_NO_CLIENT) {

            ClientRecord = ThisLfcb->ClientArray + ThisClient;

            if (ClientRecord->ClientNameLength == (ULONG) ClientName.Length
                && RtlCompareMemory( ClientRecord->ClientName,
                                     ClientName.Buffer,
                                     ClientName.Length ) == (ULONG) ClientName.Length) {

                DebugTrace( 0, Dbg, "Matching client name found\n", 0 );
                break;
            }

            ThisClient = ClientRecord->NextClient;
        }

        //
        //  Allocate an Lch structure and link it into the Lfcb.
        //

        LfsAllocateLch( &Lch );
        InsertTailList( &ThisLfcb->LchLinks, &Lch->LchLinks );

        //
        //  Initialize the client handle with the data from the Lfcb.
        //

        Lch->Lfcb = ThisLfcb;
        Lch->Sync = ThisLfcb->Sync;
        Lch->Sync->UserCount += 1;

        //
        //  If a match isn't found, take a client block off the free list
        //  if available.
        //

        if (ThisClient == LFS_NO_CLIENT) {

            //
            //  Raise an error status if out of client blocks.
            //

            ThisClient = ThisLfcb->RestartArea->ClientFreeList;

            if (ThisClient == LFS_NO_CLIENT) {

                DebugTrace( 0, Dbg, "No free client records available\n", 0 );
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  Initialize the client block.
            //

            ClientRecord = ThisLfcb->ClientArray + ThisClient;

            LfsRemoveClientFromList( ThisLfcb->ClientArray,
                                     ClientRecord,
                                     &ThisLfcb->RestartArea->ClientFreeList );

            ClientRecord->ClientRestartLsn = LfsZeroLsn;
            ClientRecord->OldestLsn = ThisLfcb->OldestLsn;
            ClientRecord->ClientNameLength = ClientName.Length;
            RtlCopyMemory( ClientRecord->ClientName,
                           ClientName.Buffer,
                           ClientName.Length );

            //
            //  Add it to the in use list.
            //

            LfsAddClientToList( ThisLfcb->ClientArray,
                                ThisClient,
                                &ThisLfcb->RestartArea->ClientInUseList );
        }

        //
        //  Update the client handle with the client block information.
        //

        Lch->ClientId.SeqNumber = ClientRecord->SeqNumber;
        Lch->ClientId.ClientIndex = ThisClient;

        Lch->ClientArrayByteOffset = PtrOffset( ThisLfcb->ClientArray,
                                                ClientRecord );

        *LogHandle = (LFS_LOG_HANDLE) Lch;

    } finally {

        DebugUnwind( LfsOpenLogFile );

        //
        //  If the Lfcb has been acquired, we release it now.
        //

        if (ThisLfcb != NULL) {

            //
            //  Pass information back to our caller for the number
            //  of bytes to add to the reserved amount for a
            //  log header.
            //

            ReservedHeader = ThisLfcb->RecordHeaderLength;
            if (FlagOn( ThisLfcb->Flags, LFCB_PACK_LOG )) {

                ReservedHeader *= 2;
            }

            LfsReleaseLfcb( ThisLfcb );
        }

        //
        //  If there is an error then deallocate the Lch and any new Lfcb.
        //

        if (AbnormalTermination()) {

            if (Lch != NULL) {

                LfsDeallocateLch( Lch );
                ThisLfcb->Sync->UserCount -= 1;
            }

            if (NewLfcb != NULL) {

                LfsDeallocateLfcb( NewLfcb, TRUE );
            }
        }

        //
        //  Always free the global.
        //

        LfsReleaseLfsData();

        DebugTrace(  0, Dbg, "Log Handle    -> %08ln\n", *LogHandle );
        DebugTrace( -1, Dbg, "LfsOpenLogFile:  Exit\n", 0 );
    }

    return ReservedHeader;
}


VOID
LfsCloseLogFile (
    IN LFS_LOG_HANDLE LogHandle
    )

/*++

Routine Description:

    This routine is called when a client detaches itself from the log
    file.  On return, all prior references to this client in the log
    file are inaccessible.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

Return Value:

    None

--*/

{
    volatile NTSTATUS Status = STATUS_SUCCESS;

    PLCH Lch;

    PLFCB Lfcb;

    USHORT ClientIndex;
    PLFS_CLIENT_RECORD ClientRecord;

    LFS_WAITER LfsWaiter;

    BOOLEAN FlushRestart;
    BOOLEAN ExitLoop;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCloseLogFile:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "LogHandle  ->  %08lx\n", LogHandle );

    Lch = (PLCH) LogHandle;

    //
    //  Enclose this in a loop.  We will loop as long as there are waiters or there is an IO
    //  in progress.
    //

    while (TRUE) {

        //
        //  Always assume we exit the loop.
        //

        ExitLoop = TRUE;

        //
        //  Check that the structure is a valid log handle structure.
        //

        LfsValidateLch( Lch );

        //
        //  Protect this entry point with a try-except.
        //

        try {

            //
            //  Use a try-finally to facilitate cleanup.
            //

            //
            //  Acquire the global data block and the log file control block.
            //

            LfsAcquireLfsData();

            try {

                PLBCB ThisLbcb;

                LfsAcquireLchExclusive( Lch );

                Lfcb = Lch->Lfcb;

                //
                //  If the Log file has been closed then return immediately.
                //

                if (Lfcb == NULL) {

                    try_return( NOTHING );
                }

                //
                //  Check that there are no waiters or IO in progress before proceeding.
                //

                if ((Lfcb->Waiters != 0) ||
                    (Lfcb->Sync->LfsIoState != LfsNoIoInProgress)) {

                    //
                    //  setup notification for the wait completion
                    //

                    KeInitializeEvent( &LfsWaiter.Event, SynchronizationEvent, FALSE );
                    LfsWaiter.Lsn.QuadPart = MAXLONGLONG;
                    InsertTailList( &Lfcb->WaiterList, &LfsWaiter.Waiters );

                    ExitLoop = FALSE;
                    Lfcb->Waiters += 1;
                    try_return( NOTHING );
                }

                //
                //  Check that the client Id is valid.
                //

                LfsValidateClientId( Lfcb, Lch );

                ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                        Lch->ClientArrayByteOffset,
                                        PLFS_CLIENT_RECORD );

                //
                //  Remember if this client wrote a restart area.
                //

                FlushRestart = (BOOLEAN) ( LfsZeroLsn.QuadPart != ClientRecord->ClientRestartLsn.QuadPart );

                //
                //  Set the flag to indicate we are at the final close.
                //

                SetFlag( Lfcb->Flags, LFCB_FINAL_SHUTDOWN );

                //
                //  Walk through the active queue and remove any Lbcb's with
                //  data from that queue.  That will allow them to get out to disk.
                //

                while (!IsListEmpty( &Lfcb->LbcbActive )) {

                    ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                                  LBCB,
                                                  ActiveLinks );

                    RemoveEntryList( &ThisLbcb->ActiveLinks );
                    ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

                    //
                    //  If this page has some new entries, allow it to
                    //  be flushed to disk elsewhere.  Otherwise deallocate it
                    //  here. We set LBCB_NOT_EMPTY when we first put data into
                    //  the page and add it to  the workqueue.
                    //

                    if (!FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

                        ASSERT( NULL == ThisLbcb->WorkqueLinks.Flink );

                        if (ThisLbcb->LogPageBcb != NULL) {

                            CcUnpinDataForThread( ThisLbcb->LogPageBcb,
                                                  ThisLbcb->ResourceThread );
                        }

                        LfsDeallocateLbcb( Lfcb, ThisLbcb );
                    }
                }

                //
                //  It's possible that we have the two restart areas in the workque.
                //  They can be removed and the memory deallocated if we have no
                //  more clients.
                //
                //  We skip this action if the there is Io in progress or the user
                //  had a restart area.
                //

                if ((Lfcb->Sync->LfsIoState == LfsNoIoInProgress) && !FlushRestart) {

                    PLIST_ENTRY Links;

                    //
                    //  Now walk through the workque list looking for a non-restart
                    //  entry.
                    //

                    Links = Lfcb->LbcbWorkque.Flink;

                    //
                    //  We don't expect to see any workitems queued on readonly volumes.
                    //

                    ASSERT( !BooleanFlagOn( Lfcb->Flags, LFCB_READ_ONLY ) ||
                             (Links == &Lfcb->LbcbWorkque) );

                    while (Links != &Lfcb->LbcbWorkque) {

                        ThisLbcb = CONTAINING_RECORD( Links,
                                                      LBCB,
                                                      WorkqueLinks );

                        //
                        //  If this is not a restart area, we exit and remember that
                        //  we need to flush the restart areas.
                        //

                        if (!LfsLbcbIsRestart( ThisLbcb )) {

                            FlushRestart = TRUE;
                            break;
                        }

                        Links = Links->Flink;
                    }

                    //
                    //  If we are still not to flush the restart areas remove
                    //  all of the restart areas from the queue.
                    //

                    if (!FlushRestart) {

                        while (!IsListEmpty( &Lfcb->LbcbWorkque)) {

                            ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbWorkque.Blink,
                                                          LBCB,
                                                          WorkqueLinks );

                            RemoveEntryList( &ThisLbcb->WorkqueLinks );
                            LfsDeallocateLbcb( Lfcb, ThisLbcb );
                        }
                    }

                } else {

                    FlushRestart = TRUE;
                }

                //
                //  Flush the new restart area if we need to.
                //

                if (FlushRestart && (!FlagOn( Lfcb->Flags, LFCB_READ_ONLY ))) {

#ifdef BENL_DBG
                    KdPrint(( "Set clean flag lfcb %x\n", Lfcb ));
#endif
                    SetFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

                    LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
                    LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
                }
#ifdef SUPW_DBG
                if (FlushRestart && FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {
                    DbgPrint("INFO: Not writing restart areas in CloseLog for READONLY lfcb %8lx (ok)\n", Lfcb);
                }
#endif

                //
                //  Clear the Lfcb pointer in the client handle.
                //

                Lch->Lfcb = NULL;
                RemoveEntryList( &Lch->LchLinks );

                //
                //  If there are no active clients, we can remove this log file
                //  control block from the active queue.
                //

                RemoveEntryList( &Lfcb->LfcbLinks );
                LfsDeallocateLfcb( Lfcb, FALSE );


            try_exit:  NOTHING;
            } finally {

                DebugUnwind( LfsCloseLogFile );

                //
                //   Release the log file control block if held.
                //

                LfsReleaseLch( Lch );

                //
                //  Release the global data block if held.
                //

                LfsReleaseLfsData();

                DebugTrace( -1, Dbg, "LfsCloseLogFile:  Exit\n", 0 );
            }

        } except (LfsExceptionFilter( GetExceptionInformation() )) {

            Status = GetExceptionCode();
        }

        //
        //  Test if we want to exit the loop now.
        //

        if (ExitLoop) { break; }

        //
        //  Wait for the io to complete.
        //

        KeWaitForSingleObject( &LfsWaiter.Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        LfsAcquireLfcbExclusive( Lfcb );
        Lfcb->Waiters -= 1;
        LfsReleaseLfcb( Lfcb );
    }

    //
    //  We always let this operation succeed.
    //

    return;
}

VOID
LfsDeleteLogHandle (
    IN LFS_LOG_HANDLE LogHandle
    )

/*++

Routine Description:

    This routine is called when a client is tearing down the last of
    his volume structures.  There will be no more references to this
    handle.  If it is the last handle for the log file then we will
    deallocate the Sync structure as well.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

Return Value:

    None

--*/

{
    PLCH Lch;

    PAGED_CODE();

    //
    //  If the log handle is null then return immediately.
    //

    Lch = (PLCH) LogHandle;

    if ((Lch == NULL) ||
        (Lch->NodeTypeCode != LFS_NTC_LCH)) {

        return;
    }

    //
    //  Ignore all errors from now on.
    //

    try {

        LfsAcquireLchExclusive( Lch );

        Lch->Sync->UserCount -= 1;

        //
        //  If we are the last user then deallocate the sync structure.
        //

        if (Lch->Sync->UserCount == 0) {

            ExDeleteResourceLite( &Lch->Sync->Resource );
            ExFreePool( Lch->Sync );
            Lch->Sync = NULL;
            if (Lch->Lfcb) {
                Lch->Lfcb->Sync = NULL;
            }

        } else {

            LfsReleaseLch( Lch );
        }

        LfsDeallocateLch( Lch );

    } except (LfsExceptionFilter( GetExceptionInformation() )) {

        NOTHING;
    }

    return;
}


VOID
LfsReadLogFileInformation (
    IN LFS_LOG_HANDLE LogHandle,
    IN PLOG_FILE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine returns information about the current state of the log
    file, primarily to aid the client perform its checkpoint processing.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Buffer - Pointer to buffer to return the log file information.

    Length - On input this is the length of the user's buffer.  On output,
             it is the amount of data stored by the Lfs in the buffer.

Return Value:

    None

--*/

{
    PLCH Lch;
    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadLogFileInformation:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", Buffer );
    DebugTrace(  0, Dbg, "Length        -> %08lx\n", *Length );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then return immediately.
        //

        if (Lfcb == NULL) {

            try_return( *Length = 0 );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  The buffer better be large enough.
        //

        if (*Length >= sizeof( LOG_FILE_INFORMATION )) {

            PLOG_FILE_INFORMATION Information;
            LONGLONG CurrentAvail;
            ULONG UnusedBytes;

            LfsCurrentAvailSpace( Lfcb,
                                  &CurrentAvail,
                                  &UnusedBytes );

            //
            //  Cast a pointer to the buffer and fill in the
            //  data.
            //

            Information = (PLOG_FILE_INFORMATION) Buffer;

            Information->TotalAvailable = Lfcb->TotalAvailable;
            Information->CurrentAvailable =  CurrentAvail;
            Information->TotalUndoCommitment = Lfcb->TotalUndoCommitment;
            Information->ClientUndoCommitment = Lch->ClientUndoCommitment;

            //
            //  Acquire mutex to guard last flushed lsn access
            //

            ExAcquireFastMutexUnsafe( &Lfcb->Sync->Mutex );
            Information->OldestLsn = Lfcb->OldestLsn;
            Information->LastFlushedLsn.QuadPart = Lfcb->LastFlushedLsn.QuadPart;
            Information->LastLsn = Lfcb->RestartArea->CurrentLsn;
            ExReleaseFastMutexUnsafe( &Lfcb->Sync->Mutex );

            *Length = sizeof( LOG_FILE_INFORMATION );

        } else {

            *Length = 0;
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( LfsReadLogFileInformation );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsReadLogFileInformation:  Exit\n", 0 );
    }

    return;
}


BOOLEAN
LfsVerifyLogFile (
    IN LFS_LOG_HANDLE LogHandle,
    IN PVOID LogFileHeader,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called by a client to verify that the volume has not been removed
    from the system and then reattached.  We will verify the log file open count on
    disk matches the value in the user's handle.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    LogFileHeader - Pointer to start of log file.

    Length - Number bytes returned with the read.

Return Value:

    BOOLEAN - TRUE if the log file has not been altered externally, FALSE if we
        fail for any reason.

--*/

{
    BOOLEAN ValidLogFile = FALSE;
    PLCH Lch;
    PLFCB Lfcb;

    PLFS_RESTART_PAGE_HEADER RestartPage = LogFileHeader;

    PAGED_CODE();

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    if ((Lch == NULL) ||
        (Lch->NodeTypeCode != LFS_NTC_LCH) ||
        ((Lch->Lfcb != NULL) &&
         (Lch->Lfcb->NodeTypeCode != LFS_NTC_LFCB))) {

        return FALSE;
    }

    //
    //  Acquire the log file control block for this log file.
    //

    LfsAcquireLchExclusive( Lch );
    Lfcb = Lch->Lfcb;

    //
    //  If the Log file has been closed then return immediately.
    //

    if (Lfcb == NULL) {

        LfsReleaseLch( Lch );
        return FALSE;
    }

    //
    //  Check that we have at least one page and that the page is valid.
    //

    if ((Length >= (ULONG) Lfcb->LogPageSize) &&
        (*((PULONG) RestartPage) == LFS_SIGNATURE_RESTART_PAGE_ULONG) &&
        ((RestartPage->RestartOffset + sizeof( LFS_RESTART_AREA )) < (ULONG) Lfcb->LogPageSize) &&
        ((Add2Ptr( RestartPage, RestartPage->RestartOffset, PLFS_RESTART_AREA ))->RestartOpenLogCount == Lfcb->CurrentOpenLogCount)) {

        ValidLogFile = TRUE;
    }

    LfsReleaseLfcb( Lfcb );
    return ValidLogFile;
}


VOID
LfsResetUndoTotal (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberRecords,
    IN LONG ResetTotal
    )

/*++

Routine Description:

    This routine is called to adjust the undo commitment for this client.
    If the reset total is positive, then we absolutely set the
    reserve value for the client using this as the basis.  If the value
    is negative, we will adjust the current value for the client.

    To adjust the values in the Lfcb, we first return the Undo commitment
    in the handle and then adjust by the values passed in.

    To adjust the value in the client handle, we simply set it if
    the reset value is positive, adjust it if the value is negative.

    For a packed log file we just reserve the space requested.  We
    have already taken into account the loss of the tail of each page.
    For an unpacked log file we double each value.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    NumberRecords - This is the number of records we should assume the
                    reset total covers.  We allow an Lfs header for
                    each one.

    ResetTotal - This is the amount to adjust (or set) the undo
                 commitment.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    LONGLONG AdjustedUndoTotal;
    LONG LfsHeaderBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsResetUndoTotal:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Number Records    -> %08lx\n", NumberRecords );
    DebugTrace(  0, Dbg, "ResetTotal        -> %08lx\n", ResetTotal );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Compute the adjusted reset total.  Start by computing the
        //  bytes needed for the Lfs log headers.  Add (or subtract) this
        //  from the reset total and multiply by 2 (only if not packing the
        //  log).
        //

        LfsHeaderBytes = NumberRecords * Lfcb->RecordHeaderLength;
        LfsHeaderBytes *= 2;

        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

            ResetTotal *= 2;
        }

        //
        //  If the reset total is positive, add the header bytes.
        //

        if (ResetTotal > 0) {

            //
            //  Subtract the client's current value from the TotalUndo
            //  commit if he is setting his value exactly.
            //

            Lfcb->TotalUndoCommitment = Lfcb->TotalUndoCommitment - Lch->ClientUndoCommitment;

            //
            //  We can clear the values in the user's handle at this
            //  time.
            //

            Lch->ClientUndoCommitment = 0;


            ResetTotal += LfsHeaderBytes;

        //
        //  Otherwise subtract the value for the header bytes.
        //

        } else {

            ResetTotal -= LfsHeaderBytes;
        }

        //
        //  Now we adjust the Lfcb and Lch values by the adjustment amount.
        //

        AdjustedUndoTotal = ResetTotal;

        Lfcb->TotalUndoCommitment = Lfcb->TotalUndoCommitment + AdjustedUndoTotal;

        Lch->ClientUndoCommitment = Lch->ClientUndoCommitment + AdjustedUndoTotal;

    } finally {

        DebugUnwind( LfsResetUndoTotal );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsResetUndoTotal:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine.
//

PLFCB
LfsRestartLogFile (
    IN PFILE_OBJECT LogFile,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_WRITE_DATA WriteData
    )

/*++

Routine Description:

    This routine is called to process an existing log file when it opened
    for the first time on a running system.  We walk through the beginning
    of the file looking for a valid restart area.  Once we have a restart
    area, we can find the next restart area and determine which is the
    most recent.  The data in the restart area will tell us if the system
    has been gracefully shutdown and whether the log file in its current
    state can run on the current system.

    If the file is usable, we perform any necessary initialization on the
    file to prepare it for operation.

Arguments:

    LogFile - This is the file to use as a log file.

    MaximumClients - This is the maximum number of clients that will be
                     active in the log file at any one time.

    LogPageSize - If specified (not 0), this is the recommended size of
                  the log page.  Lfs will use this as a guide in
                  determining the log page size.

    FileSize - This is the available size of the log file.

    LfsInfo - On entry, indicates the log file state the user may
        know about.  On exit, indicates the log file state that Lfs
        knows about.  This is a conduit for Lfs to communicate with its
        clients.

    WriteData - Pointer to WRITE_DATA in caller's data structure.

Return Value:

    PLFCB - A pointer to an initialized Lfcb to use for
                              this log file.

--*/

{
    PLFCB ThisLfcb = NULL;
    PLFS_RESTART_AREA RestartArea = NULL;
    PLFS_RESTART_AREA DiskRestartArea;

    BOOLEAN UninitializedFile;

    LONGLONG OriginalFileSize = FileSize;
    LONGLONG FirstRestartOffset;
    PLFS_RESTART_PAGE_HEADER FirstRestartPage;
    BOOLEAN FirstChkdskWasRun;
    BOOLEAN FirstValidPage;
    BOOLEAN FirstLogPacked;
    LSN FirstRestartLastLsn;

    PBCB FirstRestartPageBcb = NULL;
    PBCB SecondRestartPageBcb = NULL;

    //
    //  By default pack any new logs
    //

    BOOLEAN PackLogFile = TRUE;
    BOOLEAN UseDefaultLogPage = FALSE;
    LARGE_INTEGER CurrentTime;

    BOOLEAN ForceRestartToDisk = FALSE;
    BOOLEAN ClearLogFile = FALSE;
    LONGLONG StartOffsetForClear = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsRestartLogFile:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "LogFile    -> %08lx\n", LogFile );
    DebugTrace(  0, Dbg, "Maximum Clients   -> %04x\n", MaximumClients );
    DebugTrace(  0, Dbg, "Log Page Size     -> %08lx\n", LogPageSize );
    DebugTrace(  0, Dbg, "File Size (Low)   -> %08lx\n", FileSize.LowPart );
    DebugTrace(  0, Dbg, "File Size (High)  -> %08lx\n", FileSize.HighPart );
    DebugTrace(  0, Dbg, "Pack Log           -> %04x\n", *LfsInfo );

    //
    //  Remember if we are to pack the log file.  Once a log file has
    //  been packed we will attempt to keep it that way.
    //

    ASSERT( LfsInfo->LfsClientInfo >= LfsPackLog );


    if (LogPageSize == 0) {
        UseDefaultLogPage = TRUE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Normalize the values passed in with this call.
        //

        LfsNormalizeBasicLogFile( &FileSize,
                                  &LogPageSize,
                                  &MaximumClients,
                                  UseDefaultLogPage );

        //
        //  Allocate an Lfcb to use for this file.
        //

        ThisLfcb = LfsAllocateLfcb( LogPageSize, FileSize );

        //
        //  Acquire the Lfcb and store it in the global queue.
        //

        LfsAcquireLfcbExclusive( ThisLfcb );

        //
        //  Remember this log file in the Lfcb.
        //

        ThisLfcb->FileObject = LogFile;

        SetFlag( ThisLfcb->Flags,
                 (LFCB_READ_FIRST_RESTART |
                  LFCB_READ_SECOND_RESTART) );

        if (LfsInfo->ReadOnly) {

            SetFlag( ThisLfcb->Flags, LFCB_READ_ONLY );
        }

        //
        //  Look for a restart area on the disk.
        //

        if (!LfsInfo->BadRestart &&
            LfsReadRestart( ThisLfcb,
                            FileSize,
                            TRUE,
                            &FirstRestartOffset,
                            &FirstRestartPage,
                            &FirstRestartPageBcb,
                            &FirstChkdskWasRun,
                            &FirstValidPage,
                            &UninitializedFile,
                            &FirstLogPacked,
                            &FirstRestartLastLsn )) {

            BOOLEAN DoubleRestart;

            LONGLONG SecondRestartOffset;
            PLFS_RESTART_PAGE_HEADER SecondRestartPage;
            BOOLEAN SecondChkdskWasRun;
            BOOLEAN SecondValidPage;
            BOOLEAN SecondLogPacked;
            LSN SecondRestartLastLsn;

            //
            //  If the restart offset above wasn't zero then we
            //  won't look for a second restart.
            //

            if (FirstRestartOffset == 0) {

                ClearFlag( ThisLfcb->Flags, LFCB_READ_FIRST_RESTART );

                DoubleRestart = LfsReadRestart( ThisLfcb,
                                                FileSize,
                                                FALSE,
                                                &SecondRestartOffset,
                                                &SecondRestartPage,
                                                &SecondRestartPageBcb,
                                                &SecondChkdskWasRun,
                                                &SecondValidPage,
                                                &UninitializedFile,
                                                &SecondLogPacked,
                                                &SecondRestartLastLsn );

                if (DoubleRestart) {

                    ClearFlag( ThisLfcb->Flags, LFCB_READ_SECOND_RESTART );
                }

            } else {

                ClearFlag( ThisLfcb->Flags, LFCB_READ_SECOND_RESTART );
                DoubleRestart = FALSE;
            }

            //
            //  Determine which restart area to use.
            //

            if (DoubleRestart && (SecondRestartLastLsn.QuadPart > FirstRestartLastLsn.QuadPart)) {

                BOOLEAN UseSecondPage = TRUE;
                PULONG SecondPage;
                PBCB SecondPageBcb = NULL;
                BOOLEAN UsaError;

                //
                //  In a very strange case we could have crashed on a system with
                //  a different page size and then run chkdsk on the new system.
                //  The second restart page may not have the chkdsk signature in
                //  that case but could have a higher final Lsn.
                //  We want to ignore the second restart area in that case.
                //

                if (FirstChkdskWasRun &&
                    (SecondRestartOffset != PAGE_SIZE)) {

                    if (NT_SUCCESS( LfsPinOrMapData( ThisLfcb,
                                                     PAGE_SIZE,
                                                     PAGE_SIZE,
                                                     FALSE,
                                                     TRUE,
                                                     TRUE,
                                                     &UsaError,
                                                     &SecondPage,
                                                     &SecondPageBcb )) &&
                        (*SecondPage == LFS_SIGNATURE_MODIFIED_ULONG)) {

                        UseSecondPage = FALSE;
                    }

                    if (SecondPageBcb != NULL) {

                        CcUnpinData( SecondPageBcb );
                    }
                }

                if (UseSecondPage) {

                    FirstRestartOffset = SecondRestartOffset;
                    FirstRestartPage = SecondRestartPage;
                    FirstChkdskWasRun = SecondChkdskWasRun;
                    FirstValidPage = SecondValidPage;
                    FirstLogPacked = SecondLogPacked;
                    FirstRestartLastLsn = SecondRestartLastLsn;
                }
            }

#ifdef LFS_CLUSTER_CHECK
            //
            //  Capture the current position out of the page.
            //

            ThisLfcb->LsnRangeIndex = *(Add2Ptr( FirstRestartPage, 0xe00 - sizeof( ULONG ), PULONG ));

            if (ThisLfcb->LsnRangeIndex >= 0x20) {

                ThisLfcb->LsnRangeIndex = 0;
            }
#endif
            //
            //  If the restart area is at offset 0, we want to write
            //  the second restart area out first.
            //

            if (FirstRestartOffset != 0) {

                ThisLfcb->InitialRestartArea = TRUE;
            }

            //
            //  If we have a valid page then grab a pointer to the restart area.
            //

            if (FirstValidPage) {

                DiskRestartArea = Add2Ptr( FirstRestartPage, FirstRestartPage->RestartOffset, PLFS_RESTART_AREA );
            }

            //
            //  If checkdisk was run or there are no active clients,
            //  then we will begin at the start of the log file.
            //

            if (FirstChkdskWasRun ||
                (DiskRestartArea->ClientInUseList == LFS_NO_CLIENT)) {

                //
                //  Default version is 1.1.
                //

                SHORT MajorVersion = 1;
                SHORT MinorVersion = 1;

                BOOLEAN LogFileWrapped = FALSE;
                BOOLEAN UseMultiplePageIo = FALSE;

                //
                //  We want to do a complete initialization
                //

                ForceRestartToDisk = TRUE;
                ClearLogFile = TRUE;
                StartOffsetForClear = LogPageSize * 2;

                //
                //  Do some checks based on whether we have a valid log page.
                //

                if (FirstValidPage) {

                    CurrentTime.LowPart = DiskRestartArea->RestartOpenLogCount;

                    //
                    //  If the restart page size isn't changing then we want to
                    //  check how much work we need to do.
                    //

                    if (LogPageSize == FirstRestartPage->SystemPageSize) {

                        //
                        //  If the file size is changing we want to remember
                        //  at which point we want to start clearing the file.
                        //

                        if (FileSize > DiskRestartArea->FileSize) {

                            StartOffsetForClear = DiskRestartArea->FileSize;

                        } else {

                            if (!FlagOn( DiskRestartArea->Flags, RESTART_SINGLE_PAGE_IO )) {

                                UseMultiplePageIo = TRUE;
                                LogFileWrapped = TRUE;
                            }

                            //
                            //  If the page is valid we don't need to clear the log
                            //  file or force the data to disk.
                            //

                            ForceRestartToDisk = FALSE;
                            ClearLogFile = FALSE;
                        }
                    }

                } else {

                    KeQuerySystemTime( &CurrentTime );
                }

                //
                //  Initialize our Lfcb for the current log page values.
                //

                LfsUpdateLfcbFromPgHeader( ThisLfcb,
                                           LogPageSize,
                                           MajorVersion,
                                           MinorVersion,
                                           PackLogFile );

                LfsUpdateLfcbFromNoRestart( ThisLfcb,
                                            FileSize,
                                            FirstRestartLastLsn,
                                            MaximumClients,
                                            CurrentTime.LowPart,
                                            LogFileWrapped,
                                            UseMultiplePageIo );

                LfsAllocateRestartArea( &RestartArea, ThisLfcb->RestartDataSize );

                LfsUpdateRestartAreaFromLfcb( ThisLfcb, RestartArea );

                ThisLfcb->RestartArea = RestartArea;
                ThisLfcb->ClientArray = Add2Ptr( RestartArea,
                                                 ThisLfcb->ClientArrayOffset,
                                                 PLFS_CLIENT_RECORD );
                RestartArea = NULL;

                //
                //  Unpin any pages pinned here.
                //

                if (FirstRestartPageBcb != NULL) {

                    CcUnpinData( FirstRestartPageBcb );
                    FirstRestartPageBcb = NULL;
                }

                if (SecondRestartPageBcb != NULL) {

                    CcUnpinData( SecondRestartPageBcb );
                    SecondRestartPageBcb = NULL;
                }

                //
                //  Now update the caller's WRITE_DATA structure.
                //

                ThisLfcb->UserWriteData = WriteData;
                WriteData->LfsStructureSize = LogPageSize;
                WriteData->Lfcb = ThisLfcb;

                //
                //  If we are doing a read only mount and we need to
                //  write restart areas to disk, we are hosed.
                //

                if (LfsInfo->ReadOnly && ForceRestartToDisk) {

                    ASSERTMSG("INFO: ReadOnly Mount, Cant write restart. Raising\n", FALSE);
                    ExRaiseStatus( STATUS_MEDIA_WRITE_PROTECTED );
                }

            //
            //  If the log page or the system page sizes have changed,
            //  we can't use the log file.  We must use the system
            //  page size instead of the default size if there is not
            //  a clean shutdown.
            //

            } else {

                if (LogPageSize != FirstRestartPage->SystemPageSize) {

                    FileSize = OriginalFileSize;
                    LfsNormalizeBasicLogFile( &FileSize,
                                              &LogPageSize,
                                              &MaximumClients,
                                              (BOOLEAN) (FirstRestartPage->SystemPageSize == LFS_DEFAULT_LOG_PAGE_SIZE) );
                }

                if ((LogPageSize != FirstRestartPage->SystemPageSize) ||
                    (LogPageSize != FirstRestartPage->LogPageSize)) {

                    DebugTrace( 0, Dbg, "Page size mismatch\n", 0 );
                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );

                //
                //  Otherwise we have a restart area to deal with.
                //

                } else {

                    //
                    //  We preserve the packed status from the disk.
                    //

                    PackLogFile = FirstLogPacked;

                    //
                    //  Update the Lfcb from the values in the restart area
                    //  page header and the active restart page.
                    //

                    LfsUpdateLfcbFromPgHeader( ThisLfcb,
                                               LogPageSize,
                                               FirstRestartPage->MajorVersion,
                                               FirstRestartPage->MinorVersion,
                                               FirstLogPacked );

                    LfsUpdateLfcbFromRestart( ThisLfcb,
                                              FileSize,
                                              DiskRestartArea,
                                              FirstRestartPage->RestartOffset );

                    //
                    //  Now allocate a restart area.
                    //

                    LfsAllocateRestartArea( &RestartArea, ThisLfcb->RestartDataSize );

                    //
                    //  We may need to grow the restart area to allow room for the open
                    //  log file count.
                    //

                    if (ThisLfcb->ClientArrayOffset == FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray )) {

                        RtlCopyMemory( RestartArea, DiskRestartArea, ThisLfcb->RestartAreaSize );

                    } else {

                        //
                        //  Copy the start of the restart area over.
                        //

                        RtlCopyMemory( RestartArea, DiskRestartArea, ThisLfcb->ClientArrayOffset );

                        //
                        //  Now copy over the client data to its new location.
                        //

                        RtlCopyMemory( RestartArea->LogClientArray,
                                       Add2Ptr( DiskRestartArea, ThisLfcb->ClientArrayOffset, PVOID ),
                                       DiskRestartArea->RestartAreaLength - ThisLfcb->ClientArrayOffset );

                        //
                        //  Update the system open count.
                        //

                        KeQuerySystemTime( &CurrentTime );

                        ThisLfcb->CurrentOpenLogCount =
                        RestartArea->RestartOpenLogCount = CurrentTime.LowPart;

                        //
                        //  Now update the numbers in the Lfcb and restart area.
                        //

                        ThisLfcb->ClientArrayOffset = FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray );
                        ThisLfcb->RestartAreaSize = ThisLfcb->ClientArrayOffset
                                                    + (sizeof( LFS_CLIENT_RECORD ) * ThisLfcb->LogClients );

                        RestartArea->ClientArrayOffset = ThisLfcb->ClientArrayOffset;
                        RestartArea->RestartAreaLength = (USHORT) ThisLfcb->RestartAreaSize;
                    }

                    //
                    //  clear the clean shutdown flag from on disk
                    //

                    ClearFlag( RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

                    //
                    //  Update the log file open count.
                    //

                    RestartArea->RestartOpenLogCount += 1;

                    ThisLfcb->RestartArea = RestartArea;

                    ThisLfcb->ClientArray = Add2Ptr( RestartArea, ThisLfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );
                    RestartArea = NULL;

                    //
                    //  Unpin any pages pinned here.
                    //

                    if (FirstRestartPageBcb != NULL) {

                        CcUnpinData( FirstRestartPageBcb );
                        FirstRestartPageBcb = NULL;
                    }

                    if (SecondRestartPageBcb != NULL) {

                        CcUnpinData( SecondRestartPageBcb );
                        SecondRestartPageBcb = NULL;
                    }

                    //
                    //  update the caller's WRITE_DATA structure before finding
                    //  last LSN which may flush a log page.
                    //

                    ThisLfcb->UserWriteData = WriteData;
                    WriteData->LfsStructureSize = LogPageSize;
                    WriteData->Lfcb = ThisLfcb;

                    //
                    //  Now we need to walk through looking for the last
                    //  Lsn.
                    //

                    LfsFindLastLsn( ThisLfcb );

                    //
                    //  Recalculate the available pages in the Lfcb.
                    //

                    LfsFindCurrentAvail( ThisLfcb );

                    //
                    //  Remember which restart area to write out first.
                    //

                    if (FirstRestartOffset != 0) {

                        ThisLfcb->InitialRestartArea = TRUE;
                    }
                }
            }

#ifdef LFS_CLUSTER_CHECK

            if (FirstValidPage) {

                //
                //  Copy the tail of the page to the restart area.
                //

                RtlCopyMemory( Add2Ptr( ThisLfcb->RestartArea,
                                        0xe00 - sizeof( ULONG ) - ThisLfcb->RestartDataOffset,
                                        PVOID ),
                               Add2Ptr( FirstRestartPage,
                                        0xe00 - sizeof( ULONG ),
                                        PVOID ),
                               0x200 + sizeof( ULONG ));

                DiskRestartArea = Add2Ptr( FirstRestartPage, FirstRestartPage->RestartOffset, PLFS_RESTART_AREA );
            }
#endif

        //
        //  If the file is uninitialized, we will initialized it with new
        //  restart areas.  We can move to version 1.0 where we use
        //  update sequence array support but don't have to force the values
        //  to disk.
        //

        } else {

            //
            //  Need to determine if we are in a bad restart state.
            //  If not, treat the file as if it is not initialized.
            //

            if (!LfsInfo->BadRestart && !UninitializedFile) {

                //
                //  We didn't find a restart area but the file is not initialized.
                //  This is a corrupt disk.
                //

                DebugTrace( 0, Dbg, "Log file has no restart area\n", 0 );
                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            //
            //  We need to fail the mount if the media is readonly.
            //

            if (LfsInfo->ReadOnly) {

                ExRaiseStatus( STATUS_MEDIA_WRITE_PROTECTED );
            }

            //
            //  If we are here due to bad restart, we need to wipe the log
            //  completely so as not to confuse LfsFindLastLsn on next reboot.
            //

            if (LfsInfo->BadRestart) {

                ForceRestartToDisk = TRUE;
                ClearLogFile = TRUE;
                StartOffsetForClear = LogPageSize * 2;
            }

            //
            //  We go to a packed system if possible.
            //

            LfsUpdateLfcbFromPgHeader( ThisLfcb,
                                       LogPageSize,
                                       1,
                                       1,
                                       PackLogFile );

            KeQuerySystemTime( &CurrentTime );
            LfsUpdateLfcbFromNoRestart( ThisLfcb,
                                        FileSize,
                                        LfsLi0,
                                        MaximumClients,
                                        CurrentTime.LowPart,
                                        FALSE,
                                        TRUE );

            LfsAllocateRestartArea( &RestartArea, ThisLfcb->RestartDataSize );

            LfsUpdateRestartAreaFromLfcb( ThisLfcb, RestartArea );

            ThisLfcb->RestartArea = RestartArea;
            ThisLfcb->ClientArray = Add2Ptr( RestartArea, ThisLfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );

            ThisLfcb->InitialRestartArea = TRUE;
            RestartArea = NULL;

            //
            //  update the caller's WRITE_DATA structure.
            //

            ThisLfcb->UserWriteData = WriteData;
            WriteData->LfsStructureSize = LogPageSize;
            WriteData->Lfcb = ThisLfcb;
        }

        //
        //  Common initialization for all cases - If we're readonly we don't do any preallocations
        //  that are only used for the write paths (like error logs for write failures)
        //

        if (!LfsInfo->ReadOnly) {

            //
            //  Allocate buffer for the first 4 pages - this includes the 2 restart pages and the 2
            //  ping - pong pages
            //

            ThisLfcb->LogHeadBuffer = LfsAllocatePool( NonPagedPool, (ULONG)(ThisLfcb->LogPageSize * 4) );
            ThisLfcb->LogHeadMdl = IoAllocateMdl( ThisLfcb->LogHeadBuffer,
                                                  (ULONG)(ThisLfcb->LogPageSize * 4),
                                                  FALSE,
                                                  FALSE,
                                                  NULL );

            if (ThisLfcb->LogHeadMdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            ThisLfcb->LogHeadPartialMdl = IoAllocateMdl( ThisLfcb->LogHeadBuffer,
                                                  (ULONG)(ThisLfcb->LogPageSize),
                                                  FALSE,
                                                  FALSE,
                                                  NULL );

            if (ThisLfcb->LogHeadPartialMdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmBuildMdlForNonPagedPool( ThisLfcb->LogHeadMdl );

            ThisLfcb->ErrorLogPacket = IoAllocateErrorLogEntry( ThisLfcb->FileObject->DeviceObject,  ERROR_LOG_MAXIMUM_SIZE );

            //
            //  Put both restart areas in the queue to be flushed but don't
            //  force them to disk.
            //

            LfsInitializeLogFilePriv( ThisLfcb,
                                      ForceRestartToDisk,
                                      ThisLfcb->RestartDataSize,
                                      StartOffsetForClear,
                                      ClearLogFile );
        }

    } finally {

        DebugUnwind( LfsRestartLogFile );

        //
        //  Free the Lfcb if allocated.
        //

        if (ThisLfcb != NULL) {

            LfsReleaseLfcb( ThisLfcb );

            //
            //  Free the Lfcb and Restart areas in the event of an error.
            //

            if (AbnormalTermination()) {

                LfsDeallocateLfcb( ThisLfcb, TRUE );

                if (RestartArea != NULL) {

                    LfsDeallocateRestartArea( RestartArea );
                }
            }
        }

        if (FirstRestartPageBcb != NULL) {

            CcUnpinData( FirstRestartPageBcb );
        }

        if (SecondRestartPageBcb != NULL) {

            CcUnpinData( SecondRestartPageBcb );
        }

        DebugTrace( -1, Dbg, "LfsRestartLogFile:  Exit\n", 0 );
    }

    //
    //  Indicate whether the log is packed.
    //

    if (PackLogFile && (LfsInfo->LfsClientInfo < LfsPackLog)) {

        LfsInfo->LfsClientInfo = LfsPackLog;
    }

#ifdef LFS_CLUSTER_CHECK
    ThisLfcb->LsnAtMount = ThisLfcb->LastFlushedLsn;
#endif

    return ThisLfcb;
}


//
//  Local support routine
//

VOID
LfsNormalizeBasicLogFile (
    IN OUT PLONGLONG FileSize,
    IN OUT PULONG LogPageSize,
    IN OUT PUSHORT LogClients,
    IN BOOLEAN UseDefaultLogPage
    )

/*++

Routine Description:

    This routine is called to normalize the values which describe the
    log file.  It will make the log page a multiple of the system page.
    Finally we make sure the file size ends on a log page boundary.

    On input all of the parameters have the requested values, on return
    they have the values to use.

Arguments:

    FileSize - Stated size of the log file.

    LogPageSize - Suggested size for the log page.

    LogClients - Requested number of log clients.

    UseDefaultLogPage - Indicates if we should use the hardwired log page size or base
        it on the system page size.

Return Value:

    None.

--*/

{
    ULONG LocalLogPageSize;
    LONGLONG RestartPageBytes;
    LONGLONG LogPages;

    USHORT MaximumClients;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsNormalizeBasicLogFile:  Entered\n", 0 );

    if (!UseDefaultLogPage) {
        if (*LogPageSize == 0) {
            *LogPageSize = PAGE_SIZE;
        }
    } else {
        *LogPageSize = LFS_DEFAULT_LOG_PAGE_SIZE;
    }

    //
    //  If the log file is greater than the maximum log file size, we
    //  set the log file size to the maximum size.
    //

    if (*FileSize > LfsMaximumFileSize) {

        *FileSize = LfsMaximumFileSize;
    }

    //
    //  We round the file size down to a system page boundary.  This
    //  may also change if we allow non-system page sized log pages.
    //

    *(PULONG)FileSize &= ~(*LogPageSize - 1);

    //
    //  There better be at least 2 restart pages.
    //

    RestartPageBytes = 2 * *LogPageSize;

    if (*FileSize <= RestartPageBytes) {

        DebugTrace(  0, Dbg, "Log file is too small\n", 0 );
        DebugTrace( -1, Dbg, "LfsValidateBasicLogFile:  Abnormal Exit\n", 0 );

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Now compute the number of log pages.
    //

    LogPages = *FileSize - RestartPageBytes;
    LocalLogPageSize = *LogPageSize >> 1;

    while (LocalLogPageSize) {

        LocalLogPageSize = LocalLogPageSize >> 1;
        LogPages = ((ULONGLONG)(LogPages)) >> 1;
    }

    //
    //  If there aren't enough log pages then raise an error condition.
    //

    if (((PLARGE_INTEGER)&LogPages)->HighPart == 0
        && (ULONG)LogPages < MINIMUM_LFS_PAGES) {

        DebugTrace(  0, Dbg, "Not enough log pages -> %08lx\n", LogPages.LowPart );
        DebugTrace( -1, Dbg, "LfsValidateBasicLogFile:  Abnormal Exit\n", 0 );

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Now we compute the amount of space available for log clients.
    //  We will limit the clients to half of the restart system page.
    //

    MaximumClients = (USHORT) ((*LogPageSize / 2) / sizeof( LFS_CLIENT_RECORD ));

    if (*LogClients == 0) {

        *LogClients = 1;

    } else if (*LogClients > MaximumClients) {

        *LogClients = MaximumClients;
    }

    DebugTrace( -1, Dbg, "LfsNormalizeBasicLogFile:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
LfsUpdateLfcbFromPgHeader (
    IN PLFCB Lfcb,
    IN ULONG LogPageSize,
    IN SHORT MajorVersion,
    IN SHORT MinorVersion,
    IN BOOLEAN PackLog
    )

/*++

Routine Description:

    This routine updates the values in the Lfcb which depend on values in the
    restart page header.

Arguments:

    Lfcb - Log file control block to update.

    LogPageSize - Log page size to use.

    MajorVersion - Major version number for Lfs.

    MinorVersion - Minor version number for Lfs.

    PackLog - Indicates if we are packing the log file. This is the default for new logs

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateLfcbFromPgHeader:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "System Page Size  -> %08lx\n", SystemPageSize );
    DebugTrace(  0, Dbg, "Log Page Size     -> %08lx\n", LogPageSize );
    DebugTrace(  0, Dbg, "Major Version     -> %04x\n", MajorVersion );
    DebugTrace(  0, Dbg, "Minor Version     -> %04x\n", MinorVersion );

    //
    //  Do the same for the log pages.
    //

    Lfcb->LogPageSize = LogPageSize;
    Lfcb->LogPageMask = LogPageSize - 1;
    Lfcb->LogPageInverseMask = ~Lfcb->LogPageMask;

    Lfcb->LogPageShift = 0;

    while (TRUE) {

        LogPageSize = LogPageSize >> 1;

        if (LogPageSize == 0) {

            break;
        }

        Lfcb->LogPageShift += 1;
    }

    //
    //  If we are packing the log file then the first log page is page
    //  4 (in log pages).  Otherwise it is page 2.  Use the PackLog value to determine the
    //  Usa values.
    //


    if (PackLog) {

        Lfcb->FirstLogPage = Lfcb->LogPageSize << 2;
        Lfcb->LogRecordUsaOffset = (USHORT) LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
        SetFlag( Lfcb->Flags, LFCB_PACK_LOG );

    } else {

        Lfcb->FirstLogPage = Lfcb->LogPageSize << 1;
        Lfcb->LogRecordUsaOffset = (USHORT) LFS_UNPACKED_RECORD_PAGE_HEADER_SIZE;
    }

    //
    //  Remember the values for the version numbers.
    //

    Lfcb->MajorVersion = MajorVersion;
    Lfcb->MinorVersion = MinorVersion;

    //
    //  Compute the offsets for the update sequence arrays.
    //

    Lfcb->RestartUsaOffset = LFS_RESTART_PAGE_HEADER_SIZE;
    Lfcb->UsaArraySize = (USHORT) UpdateSequenceArraySize( (ULONG)Lfcb->LogPageSize );

    DebugTrace( -1, Dbg, "LfsUpdateLfcbFromPgHeader:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
LfsUpdateLfcbFromNoRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN LSN LastLsn,
    IN ULONG LogClients,
    IN ULONG OpenLogCount,
    IN BOOLEAN LogFileWrapped,
    IN BOOLEAN UseMultiplePageIo
    )

/*++

Routine Description:

    This routine updates the values in the Lfcb in cases when we don't have a
    restart area to use.

Arguments:

    Lfcb - Log file control block to update.

    FileSize - Log file size.  This is the usable size of the log file.  It has
        already been adjusted to the log page size.

    LastLsn - This is the last Lsn to use for the disk.

    LogClients - This is the number of clients supported.

    OpenLogCount - This is the current count of opens for this log file.

    LogFileWrapped - Indicates if the log file has wrapped.

    UseMultiplePageIo - Indicates if we should be using large i/o transfers.

Return Value:

    None.

--*/

{
    ULONG Count;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateLfcbFromNoRestart:  Entered\n", 0 );

    Lfcb->FileSize = FileSize;

    //
    //  We can compute the number of bits needed for the file size by shifting
    //  until the size is 0.  We then can subtract 3 bits to account for
    //  quadaligning all file offsets for log records.
    //

    for (Count = 0;
         ( FileSize != 0 );
         Count += 1,
         FileSize = ((ULONGLONG)(FileSize)) >> 1) {
    }

    Lfcb->FileDataBits = Count - 3;

    Lfcb->SeqNumberBits = (sizeof( LSN ) * 8) - Lfcb->FileDataBits;

    //
    //  We get a starting sequence number from the given Lsn.
    //  We add 2 to this for our starting sequence number.
    //

    Lfcb->SeqNumber = LfsLsnToSeqNumber( Lfcb, LastLsn ) + 2;

    Lfcb->SeqNumberForWrap = Lfcb->SeqNumber + 1;

    Lfcb->NextLogPage = Lfcb->FirstLogPage;

    SetFlag( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_NO_OLDEST_LSN );

    //
    //  The oldest Lsn is contructed from the sequence number.
    //

    Lfcb->OldestLsn.QuadPart = LfsFileOffsetToLsn( Lfcb, 0, Lfcb->SeqNumber );
    Lfcb->OldestLsnOffset = 0;

    Lfcb->LastFlushedLsn = Lfcb->OldestLsn;

    //
    //  Set the correct flags for the I/O and indicate if we have wrapped.
    //

    if (LogFileWrapped) {

        SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
    }

    if (UseMultiplePageIo) {

        SetFlag( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO );
    }

    //
    //  Compute the Log page values.
    //

    (ULONG)Lfcb->LogPageDataOffset = QuadAlign( Lfcb->LogRecordUsaOffset + (sizeof( UPDATE_SEQUENCE_NUMBER ) * Lfcb->UsaArraySize) );

    Lfcb->LogPageDataSize = Lfcb->LogPageSize - Lfcb->LogPageDataOffset;
    Lfcb->RecordHeaderLength = LFS_RECORD_HEADER_SIZE;

    if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        //
        //  Allocate the Lbcb for the tail of the packed log file.
        //

        LfsAllocateLbcb( Lfcb, &Lfcb->PrevTail );
        Lfcb->PrevTail->FileOffset = Lfcb->FirstLogPage - Lfcb->LogPageSize;

        LfsAllocateLbcb( Lfcb, &Lfcb->ActiveTail );
        Lfcb->ActiveTail->FileOffset = Lfcb->PrevTail->FileOffset - Lfcb->LogPageSize;

        //
        //  Remember the different page sizes for reservation.
        //

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize - Lfcb->RecordHeaderLength;

    } else {

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize;
    }

    //
    //  Compute the restart page values.
    //

    Lfcb->RestartDataOffset = QuadAlign( LFS_RESTART_PAGE_HEADER_SIZE + (sizeof( UPDATE_SEQUENCE_NUMBER ) * Lfcb->UsaArraySize) );

    Lfcb->RestartDataSize = (ULONG)Lfcb->LogPageSize - Lfcb->RestartDataOffset;

    Lfcb->LogClients = (USHORT) LogClients;

    Lfcb->ClientArrayOffset = FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray );

    Lfcb->RestartAreaSize = Lfcb->ClientArrayOffset
                            + (sizeof( LFS_CLIENT_RECORD ) * Lfcb->LogClients );

    Lfcb->CurrentOpenLogCount = OpenLogCount;

    //
    //  The total available log file space is the number of log file pages times
    //  the space available on each page.
    //

    Lfcb->TotalAvailInPages = Lfcb->FileSize - Lfcb->FirstLogPage;
    Lfcb->TotalAvailable = Int64ShrlMod32(((ULONGLONG)(Lfcb->TotalAvailInPages)), Lfcb->LogPageShift);

    //
    //  If the log file is packed we assume that we can't use the end of the
    //  page less than the file record size.  Then we won't need to reserve more
    //  than the caller asks for.
    //

    Lfcb->MaxCurrentAvail = Lfcb->TotalAvailable * (ULONG)Lfcb->ReservedLogPageSize;

    Lfcb->TotalAvailable = Lfcb->TotalAvailable * (ULONG)Lfcb->LogPageDataSize;

    Lfcb->CurrentAvailable = Lfcb->MaxCurrentAvail;

    DebugTrace( -1, Dbg, "LfsUpdateLfcbFromNoRestart:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsUpdateLfcbFromRestart (
    IN OUT PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN PLFS_RESTART_AREA RestartArea,
    IN USHORT RestartOffset
    )

/*++

Routine Description:

    This routine updates the values in the Lfcb based on data in the
    restart area.

Arguments:

    Lfcb - Log file control block to update.

    RestartArea - Restart area to use to update the Lfcb.

    RestartOffset - This is the offset to the restart area in the restart page.

Return Value:

    None.

--*/

{
    LONGLONG LsnFileOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateLfcbFromRestartArea:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RestartArea   -> %08lx\n", RestartArea );

    //
    //  Never set the filesize bigger than the actual filesize
    //  on clean shutdowns use the real size - on non clean shutdowns
    //  let the filesize shrink but not expand - we're stuck the the file data bits
    //  until the next boot when we can adjust it for the new size
    //

    if (FlagOn( RestartArea->Flags, LFS_CLEAN_SHUTDOWN)) {
        Lfcb->FileSize = FileSize;
    } else {
        Lfcb->FileSize = min( FileSize, RestartArea->FileSize );
    }

    //
    //  We get the sequence number bits from the restart area and compute the
    //  file data bits.
    //

    Lfcb->SeqNumberBits = RestartArea->SeqNumberBits;
    Lfcb->FileDataBits = (sizeof( LSN ) * 8) - Lfcb->SeqNumberBits;

    //
    //  We look at the last flushed Lsn to determine the current sequence count and
    //  the next log page to examine.
    //

    Lfcb->LastFlushedLsn = RestartArea->CurrentLsn;

    Lfcb->SeqNumber = LfsLsnToSeqNumber( Lfcb, Lfcb->LastFlushedLsn );
    Lfcb->SeqNumberForWrap = Lfcb->SeqNumber + 1;

    //
    //  The restart area size depends on the number of clients and whether the
    //  the file is packed.
    //

    Lfcb->LogClients = RestartArea->LogClients;

    //
    //  Compute the restart page values from the restart offset.
    //

    Lfcb->RestartDataOffset = RestartOffset;
    Lfcb->RestartDataSize = (ULONG)Lfcb->LogPageSize - RestartOffset;

    //
    //  For a packed log file we can find the following values in the restart
    //  area.  Otherwise we compute them from the current structure sizes.
    //

    if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        Lfcb->RecordHeaderLength = RestartArea->RecordHeaderLength;

        Lfcb->ClientArrayOffset = RestartArea->ClientArrayOffset;

        Lfcb->RestartAreaSize = RestartArea->RestartAreaLength;

        (ULONG)Lfcb->LogPageDataOffset = RestartArea->LogPageDataOffset;
        Lfcb->LogPageDataSize = Lfcb->LogPageSize - Lfcb->LogPageDataOffset;

        //
        //  For packed files we allocate the tail Lbcbs.
        //

        LfsAllocateLbcb( Lfcb, &Lfcb->PrevTail );
        Lfcb->PrevTail->FileOffset = Lfcb->FirstLogPage - Lfcb->LogPageSize;

        LfsAllocateLbcb( Lfcb, &Lfcb->ActiveTail );
        Lfcb->ActiveTail->FileOffset = Lfcb->PrevTail->FileOffset - Lfcb->LogPageSize;

        //
        //  Remember the different page sizes for reservation.
        //

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize - Lfcb->RecordHeaderLength;

    } else {

        Lfcb->RecordHeaderLength = LFS_RECORD_HEADER_SIZE;
        Lfcb->ClientArrayOffset = FIELD_OFFSET( LFS_OLD_RESTART_AREA, LogClientArray );

        Lfcb->RestartAreaSize = Lfcb->ClientArrayOffset
                                + (sizeof( LFS_CLIENT_RECORD ) * Lfcb->LogClients);

        (ULONG)Lfcb->LogPageDataOffset = QuadAlign( Lfcb->LogRecordUsaOffset + (sizeof( UPDATE_SEQUENCE_NUMBER ) * Lfcb->UsaArraySize) );

        Lfcb->LogPageDataSize = Lfcb->LogPageSize - Lfcb->LogPageDataOffset;

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize;
    }

    //
    //  If the current last flushed Lsn offset is before the first log page
    //  then this is a pseudo Lsn.
    //

    LsnFileOffset = LfsLsnToFileOffset( Lfcb, Lfcb->LastFlushedLsn );

    if ( LsnFileOffset < Lfcb->FirstLogPage ) {

        SetFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );
        Lfcb->NextLogPage = Lfcb->FirstLogPage;

    //
    //  Otherwise look at the last Lsn to determine where it ends in the file.
    //

    } else {

        LONGLONG LsnFinalOffset;
        BOOLEAN Wrapped;

        ULONG DataLength;
        ULONG RemainingPageBytes;

        DataLength = RestartArea->LastLsnDataLength;

        //
        //  Find the end of this log record.
        //

        LfsLsnFinalOffset( Lfcb,
                           Lfcb->LastFlushedLsn,
                           DataLength,
                           &LsnFinalOffset );

        //
        //  If we wrapped in the file then increment the sequence number.
        //

        if ( LsnFinalOffset <= LsnFileOffset ) {

            Lfcb->SeqNumber = 1 + Lfcb->SeqNumber;

            SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
        }

        //
        //  Now compute the next log page to use.  If we are packing the log file
        //  we will attempt to use the same page.
        //

        LfsTruncateOffsetToLogPage( Lfcb, LsnFinalOffset, &LsnFileOffset );

        RemainingPageBytes = (ULONG)Lfcb->LogPageSize
                             - ((((ULONG)LsnFinalOffset) & Lfcb->LogPageMask) + 1);

        //
        //  If we are packing the log file and we can fit another log record on the
        //  page, move back a page in the log file.
        //

        if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
            && (RemainingPageBytes >= Lfcb->RecordHeaderLength)) {

            SetFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
            Lfcb->NextLogPage = LsnFileOffset;
            Lfcb->ReusePageOffset = (ULONG)Lfcb->LogPageSize - RemainingPageBytes;

        } else {

            LfsNextLogPageOffset( Lfcb, LsnFileOffset, &Lfcb->NextLogPage, &Wrapped );
        }
    }

    //
    //  Find the oldest client Lsn.  Use the last flushed Lsn as a starting point.
    //

    Lfcb->OldestLsn = Lfcb->LastFlushedLsn;

    LfsFindOldestClientLsn( RestartArea,
                            Add2Ptr( RestartArea, Lfcb->ClientArrayOffset, PLFS_CLIENT_RECORD ),
                            &Lfcb->OldestLsn );

    Lfcb->OldestLsnOffset = LfsLsnToFileOffset( Lfcb, Lfcb->OldestLsn );

    //
    //  If there is no oldest client Lsn, then update the flag in the Lfcb.
    //

    if ( Lfcb->OldestLsnOffset < Lfcb->FirstLogPage ) {

        SetFlag( Lfcb->Flags, LFCB_NO_OLDEST_LSN );
    }

    //
    //  We need to determine the flags for the Lfcb.  These flags let us know
    //  if we wrapped in the file and if we are using multiple page I/O.
    //

    if (!FlagOn( RestartArea->Flags, RESTART_SINGLE_PAGE_IO )) {

        SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED | LFCB_MULTIPLE_PAGE_IO );
    }

    //
    //  Remember the current open log count from the disk.  We may be plucking random data out
    //  of the client area if the restart area hasn't been grown yet but we will detect that
    //  elsewhere.
    //

    Lfcb->CurrentOpenLogCount = RestartArea->RestartOpenLogCount;

    //
    //  The total available log file space is the number of log file pages times
    //  the space available on each page.
    //

    Lfcb->TotalAvailInPages = Lfcb->FileSize - Lfcb->FirstLogPage;

    Lfcb->TotalAvailable = Int64ShrlMod32(((ULONGLONG)(Lfcb->TotalAvailInPages)), Lfcb->LogPageShift);

    //
    //  If the log file is packed we assume that we can't use the end of the
    //  page less than the file record size.  Then we won't need to reserve more
    //  than the caller asks for.
    //

    Lfcb->MaxCurrentAvail = Lfcb->TotalAvailable * (ULONG)Lfcb->ReservedLogPageSize;

    Lfcb->TotalAvailable = Lfcb->TotalAvailable * (ULONG)Lfcb->LogPageDataSize;

    LfsFindCurrentAvail( Lfcb );

    DebugTrace( -1, Dbg, "LfsUpdateLfcbFromRestartArea:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
LfsUpdateRestartAreaFromLfcb (
    IN PLFCB Lfcb,
    IN PLFS_RESTART_AREA RestartArea
    )

/*++

Routine Description:

    This routine is called to update a restart area from the values stored
    in the Lfcb.  This is typically done in a case where we won't use
    any of the current values in the restart area.

Arguments:

    Lfcb - Log file control block.

    RestartArea - Restart area to update.

Return Value:

    None.

--*/

{
    PLFS_CLIENT_RECORD Client;
    USHORT ClientIndex;
    USHORT PrevClient = LFS_NO_CLIENT;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateRestartAreaFromLfcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );

    //
    //  We can copy most of the fields directly out of Lfcb.
    //

    RestartArea->CurrentLsn = Lfcb->LastFlushedLsn;
    RestartArea->LogClients = Lfcb->LogClients;

    if (!FlagOn( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO )) {

        SetFlag( RestartArea->Flags, RESTART_SINGLE_PAGE_IO );
    }

    RestartArea->SeqNumberBits = Lfcb->SeqNumberBits;

    RestartArea->FileSize = Lfcb->FileSize;
    RestartArea->LastLsnDataLength = 0;
    RestartArea->ClientArrayOffset = Lfcb->ClientArrayOffset;
    RestartArea->RestartAreaLength = (USHORT) Lfcb->RestartAreaSize;

    RestartArea->RecordHeaderLength = Lfcb->RecordHeaderLength;
    RestartArea->LogPageDataOffset = (USHORT)Lfcb->LogPageDataOffset;

    //
    //  We set the in use list as empty and the free list as containing
    //  all of the client entries.
    //

    RestartArea->ClientInUseList = LFS_NO_CLIENT;
    RestartArea->ClientFreeList = 0;

    for (ClientIndex = 1,
         Client = Add2Ptr( RestartArea, Lfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );
         ClientIndex < Lfcb->LogClients;
         ClientIndex += 1,
         Client++) {

        Client->PrevClient = PrevClient;
        Client->NextClient = ClientIndex;

        PrevClient = ClientIndex - 1;
    }

    //
    //  We're now at the last client.
    //

    Client->PrevClient = PrevClient;
    Client->NextClient = LFS_NO_CLIENT;

    //
    //  Use the current value out of the Lfcb to stamp this usage of the log file.
    //

    RestartArea->RestartOpenLogCount = Lfcb->CurrentOpenLogCount + 1;

    DebugTrace( -1, Dbg, "LfsUpdateRestartAreaFromLfcb:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsInitializeLogFilePriv (
    IN PLFCB Lfcb,
    IN BOOLEAN ForceRestartToDisk,
    IN ULONG RestartAreaSize,
    IN LONGLONG StartOffsetForClear,
    IN BOOLEAN ClearLogFile
    )

/*++

Routine Description:

    This routine is our internal routine for initializing a log file.
    This can be the case where we are updating the log file for
    update sequence array, or differing page size or new log file size.

Arguments:

    Lfcb - This is the Lfcb for this log file.  It should already have
        the version number information stored.

    ForceRestartToDisk - Indicates that we want to actually force restart
        areas to disk instead of simply queueing them to the start of the
        workqueue.

    RestartAreaSize - This is the size for the restart areas.  This may
        be larger than the size in the Lfcb because we may be clearing
        stale data out of the file.

    StartOffsetForClear - If we are clearing the file we want to uninitialize
        from this point.

    ClearLogFile - Indicates if we want to uninitialize the log file to
        remove stale data.  This is done specifically when changing
        system page sizes.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsInitializeLogFilePriv:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                  -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Force Restart         -> %04x\n", ForceRestartToDisk );
    DebugTrace(  0, Dbg, "RestartAreaSize       -> %08lx\n", RestartAreaSize );
    DebugTrace(  0, Dbg, "StartOffset (Low)     -> %08lx\n", StartOffsetForClear.LowPart );
    DebugTrace(  0, Dbg, "StartOffset (High)    -> %08lx\n", StartOffsetForClear.HighPart );
    DebugTrace(  0, Dbg, "Clear Log File        -> %04x\n", ClearLogFile );

    //
    //  We start by queueing the restart areas.
    //

    LfsWriteLfsRestart( Lfcb,
                        RestartAreaSize,
                        FALSE );

    LfsWriteLfsRestart( Lfcb,
                        RestartAreaSize,
                        ForceRestartToDisk );

    //
    //  If we are to clear the log file, we write all 0xff into the
    //  log pages beginning at the log page offset.
    //

    if (ClearLogFile) {

        PCHAR LogPage;
        PBCB LogPageBcb = NULL;

        try {

            while ( StartOffsetForClear < Lfcb->FileSize ) {

                BOOLEAN UsaError;

                //
                //  We'll do the best we can and ignore all errors.
                //

                if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                                 StartOffsetForClear,
                                                 (ULONG)Lfcb->LogPageSize,
                                                 TRUE,
                                                 FALSE,
                                                 TRUE,
                                                 &UsaError,
                                                 (PVOID *) &LogPage,
                                                 &LogPageBcb ))) {

                    RtlFillMemoryUlong( (PVOID)LogPage,
                                        (ULONG)Lfcb->LogPageSize,
                                        LFS_SIGNATURE_UNINITIALIZED_ULONG );

                    LfsFlushLogPage( Lfcb,
                                     LogPage,
                                     StartOffsetForClear,
                                     &LogPageBcb );

                    StartOffsetForClear = Lfcb->LogPageSize + StartOffsetForClear;
                }
            }

        } finally {

            if (LogPageBcb != NULL) {

                CcUnpinData( LogPageBcb );
            }
        }
    }

    DebugTrace( -1, Dbg, "LfsInitializeLogFilePriv:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsFindLastLsn (
    IN OUT PLFCB Lfcb
    )

/*++

Routine Description:

    This routine walks through the log pages for a file, searching for the
    last log page written to the file.  It updates the Lfcb and the current
    restart area as well.

    We proceed in the following manner.

        1 - Walk through and find all of the log pages successfully
            flushed to disk.  This search terminates when either we find
            an error or when we find a previous page on the disk.

        2 - For the error case above, we want to insure that the error found
            was due to a system crash and that there are no complete I/O
            transfers after the bad region.

        3 - We will look at the 2 pages with the tail copies if the log file
            is packed to check on pages with errors.

    At the end of this routine we will repair the log file by copying the tail
    copies back to their correct location in the log file.

Arguments:

    Lfcb - Log file control block for this log file.

Return Value:

    None.

--*/

{
    USHORT PageCount;
    USHORT PagePosition;

    LONGLONG CurrentLogPageOffset;
    LONGLONG NextLogPageOffset;

    LSN LastKnownLsn;

    BOOLEAN Wrapped;
    BOOLEAN WrappedLogFile = FALSE;

    LONGLONG ExpectedSeqNumber;

    LONGLONG FirstPartialIo;
    ULONG PartialIoCount = 0;

    PLFS_RECORD_PAGE_HEADER LogPageHeader;
    PBCB LogPageHeaderBcb = NULL;

    PLFS_RECORD_PAGE_HEADER TestPageHeader;
    PBCB TestPageHeaderBcb = NULL;

    LONGLONG FirstTailFileOffset;
    PLFS_RECORD_PAGE_HEADER FirstTailPage;
    LONGLONG FirstTailOffset = 0;
    PBCB FirstTailPageBcb = NULL;

    LONGLONG SecondTailFileOffset;
    PLFS_RECORD_PAGE_HEADER SecondTailPage;
    LONGLONG SecondTailOffset = 0;
    PBCB SecondTailPageBcb = NULL;

    PLFS_RECORD_PAGE_HEADER TailPage;

    BOOLEAN UsaError;
    BOOLEAN ReplacePage = FALSE;
    BOOLEAN ValidFile = FALSE;

    BOOLEAN InitialReusePage = FALSE;

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindLastLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb  -> %08lx\n", Lfcb );

    //
    //  The page count and page position are from the last page
    //  sucessfully read.  Initialize these to indicate the
    //  'previous' transfer was complete.
    //

    PageCount = 1;
    PagePosition = 1;

    //
    //  We have the current Lsn in the restart area.  This is the last
    //  Lsn on a log page.  We compute the next file offset and sequence
    //  number.
    //

    CurrentLogPageOffset = Lfcb->NextLogPage;

    //
    //  If the next log page is the first log page in the file and
    //  the last Lsn represented a log record, then remember that we
    //  have wrapped in the log file.
    //

    if ((CurrentLogPageOffset == Lfcb->FirstLogPage) &&
        !FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL )) {

        ExpectedSeqNumber = Lfcb->SeqNumber + 1;
        WrappedLogFile = TRUE;

    } else {

        ExpectedSeqNumber = Lfcb->SeqNumber;
    }

    //
    //  If we are going to try to reuse the tail of the last known
    //  page, then remember the last Lsn on this page.
    //

    if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

        LastKnownLsn = Lfcb->LastFlushedLsn;

        //
        //  There are some special conditions allowed for this page when
        //  we read it.  It could be either the first or last of the transfer.
        //  It may also have a tail copy.
        //

        InitialReusePage = TRUE;

    } else {

        LastKnownLsn = LfsLi0;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If this is a packed log file, let's pin the two tail copy pages.
        //

        if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

            //
            //  Start with the second page.
            //

            SecondTailFileOffset = Lfcb->FirstLogPage - Lfcb->LogPageSize;

            if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                             SecondTailFileOffset,
                                             (ULONG)Lfcb->LogPageSize,
                                             TRUE,
                                             TRUE,
                                             TRUE,
                                             &UsaError,
                                             &SecondTailPage,
                                             &SecondTailPageBcb ))) {

                //
                //  If this isn't a valid page then ignore it.
                //

                if (UsaError
                    || *((PULONG) &SecondTailPage->MultiSectorHeader.Signature) != LFS_SIGNATURE_RECORD_PAGE_ULONG) {

                    CcUnpinData( SecondTailPageBcb );
                    SecondTailPageBcb = SecondTailPage = NULL;

                } else {

                    SecondTailOffset = SecondTailPage->Copy.FileOffset;
                }

            } else if (SecondTailPageBcb != NULL) {

                CcUnpinData( SecondTailPageBcb );
                SecondTailPageBcb = SecondTailPage = NULL;
            }

            FirstTailFileOffset = SecondTailFileOffset - Lfcb->LogPageSize;

            //
            //  Now try the first.
            //

            if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                             FirstTailFileOffset,
                                             (ULONG)Lfcb->LogPageSize,
                                             TRUE,
                                             TRUE,
                                             TRUE,
                                             &UsaError,
                                             &FirstTailPage,
                                             &FirstTailPageBcb ))) {

                //
                //  If this isn't a valid page then ignore it.
                //

                if (UsaError
                    || *((PULONG) &FirstTailPage->MultiSectorHeader.Signature) != LFS_SIGNATURE_RECORD_PAGE_ULONG) {

                    CcUnpinData( FirstTailPageBcb );
                    FirstTailPageBcb = FirstTailPage = NULL;

                } else {

                    FirstTailOffset = FirstTailPage->Copy.FileOffset;
                }

            } else if (FirstTailPageBcb != NULL) {

                CcUnpinData( FirstTailPageBcb );
                FirstTailPageBcb = FirstTailPage = NULL;
            }
        }

        //
        //  We continue walking through the file, log page by log page looking
        //  for the end of the data transferred.  The loop below looks for
        //  a log page which contains the end of a log record.  Each time a
        //  log record is successfully read from the disk, we update our in-memory
        //  structures to reflect this.  We exit this loop when we are at a point
        //  where we don't want to find any subsequent pages.  This occurs when
        //
        //      - we get an I/O error reading a page
        //      - we get a Usa error reading a page
        //      - we have a tail copy with more recent data than contained on the page
        //

        while (TRUE) {

            LONGLONG ActualSeqNumber;
            TailPage = NULL;

            //
            //  Pin the next log page, allowing errors.
            //

            Status = LfsPinOrMapData( Lfcb,
                                      CurrentLogPageOffset,
                                      (ULONG)Lfcb->LogPageSize,
                                      TRUE,
                                      TRUE,
                                      TRUE,
                                      &UsaError,
                                      (PVOID *) &LogPageHeader,
                                      &LogPageHeaderBcb );

            //
            //  Compute the next log page offset in the file.
            //

            LfsNextLogPageOffset( Lfcb,
                                  CurrentLogPageOffset,
                                  &NextLogPageOffset,
                                  &Wrapped );

            //
            //  If we are at the expected first page of a transfer
            //  check to see if either tail copy is at this offset.
            //  If this page is the last page of a transfer, check
            //  if we wrote a subsequent tail copy.
            //

            if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG ) &&
                ((PageCount == PagePosition) ||
                 (PageCount == PagePosition + 1))) {

                //
                //  Check if the offset matches either the first or second
                //  tail copy.  It is possible it will match both.
                //

                if (CurrentLogPageOffset == FirstTailOffset) {

                    TailPage = FirstTailPage;
                }

                if (CurrentLogPageOffset == SecondTailOffset) {

                    //
                    //  If we already matched on the first page then
                    //  check the ending Lsn's.
                    //

                    if ((TailPage == NULL) ||
                        (SecondTailPage->Header.Packed.LastEndLsn.QuadPart >
                         FirstTailPage->Header.Packed.LastEndLsn.QuadPart )) {

                        TailPage = SecondTailPage;
                    }
                }

                //
                //  If we have a candidate for a tail copy, check and see if it is
                //  in the expected pass through the file.  For that to be true we
                //  must be at the first page of an I/O block. Also the last Lsn on the
                //  copy page must match the last known flushed Lsn or the sequence
                //  number on the page must be the expected sequence number.
                //

                if (TailPage) {

                    if (LastKnownLsn.QuadPart < TailPage->Header.Packed.LastEndLsn.QuadPart) {

                        ActualSeqNumber = LfsLsnToSeqNumber( Lfcb, TailPage->Header.Packed.LastEndLsn );

                        //
                        //  If the sequence number is not expected, then don't use the tail
                        //  copy.
                        //

                        if (ExpectedSeqNumber != ActualSeqNumber) {

                            TailPage = NULL;
                        }

                    //
                    //  If the last Lsn is greater than the one on this page
                    //  then forget this tail.
                    //

                    } else if (LastKnownLsn.QuadPart > TailPage->Header.Packed.LastEndLsn.QuadPart) {

                        TailPage = NULL;
                    }
                }
            }

            //
            //  If we have an error on the current page, we will break out of
            //  this loop.
            //

            if (!NT_SUCCESS( Status ) || UsaError) {

                break;
            }

            //
            //  If the last Lsn on this page doesn't match the previous
            //  known last Lsn and the sequence number is not expected
            //  we are done.
            //

            ActualSeqNumber = LfsLsnToSeqNumber( Lfcb,
                                                 LogPageHeader->Copy.LastLsn );

            if ((LastKnownLsn.QuadPart != LogPageHeader->Copy.LastLsn.QuadPart) &&
                (ActualSeqNumber != ExpectedSeqNumber)) {

                break;
            }

            //
            //  Check that the page position and page count values are correct.
            //  If this is the first page of a transfer the position must be
            //  1 and the count will be unknown.
            //

            if (PageCount == PagePosition) {

                //
                //  If the current page is the first page we are looking at
                //  and we are reusing this page then it can be either the
                //  first or last page of a transfer.  Otherwise it can only
                //  be the first.
                //

                if ((LogPageHeader->PagePosition != 1) &&
                    (!InitialReusePage ||
                     (LogPageHeader->PagePosition != LogPageHeader->PageCount))) {

                    break;
                }

            //
            //  The page position better be 1 more than the last page position
            //  and the page count better match.
            //

            } else if ((LogPageHeader->PageCount != PageCount) ||
                       (LogPageHeader->PagePosition != PagePosition + 1)) {

                break;
            }

            //
            //  We have a valid page in the file and may have a valid page in
            //  the tail copy area.  If the tail page was written after
            //  the page in the file then break out of the loop.
            //

            if (TailPage &&
                (TailPage->Header.Packed.LastEndLsn.QuadPart >= LogPageHeader->Copy.LastLsn.QuadPart)) {

                //
                //  Remember if we will replace the page.
                //

                ReplacePage = TRUE;
                break;
            }

            TailPage = NULL;

            //
            //  The log page is expected.  If this contains the end of
            //  some log record we can update some fields in the Lfcb.
            //

            if (FlagOn( LogPageHeader->Flags, LOG_PAGE_LOG_RECORD_END )) {

                //
                //  Since we have read this page we know the Lfcb sequence
                //  number is the same as our expected value.  We also
                //  assume we will not reuse the tail.
                //

                Lfcb->SeqNumber = ExpectedSeqNumber;
                ClearFlag( Lfcb->Flags, LFCB_REUSE_TAIL );

                if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

                    Lfcb->LastFlushedLsn = LogPageHeader->Header.Packed.LastEndLsn;

                    //
                    //  If there is room on this page for another header then
                    //  remember we want to reuse the page.
                    //

                    if (Lfcb->RecordHeaderLength <=
                        ((ULONG)Lfcb->LogPageSize - LogPageHeader->Header.Packed.NextRecordOffset )) {

                        SetFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
                        Lfcb->ReusePageOffset = LogPageHeader->Header.Packed.NextRecordOffset;
                    }

                } else {

                    Lfcb->LastFlushedLsn = LogPageHeader->Copy.LastLsn;
                }

                Lfcb->RestartArea->CurrentLsn = Lfcb->LastFlushedLsn;

                ClearFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );

                //
                //  If we may try to reuse the current page then use
                //  that as the next page offset.  Otherwise move to the
                //  next page in the file.
                //

                if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

                    Lfcb->NextLogPage = CurrentLogPageOffset;

                } else {

                    Lfcb->NextLogPage = NextLogPageOffset;
                }

                //
                //  If we wrapped the log file, then we set the bit indicating so.
                //

                if (WrappedLogFile) {

                    SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
                }
            }

            //
            //  Remember the last page count and position.  Also remember
            //  the last known lsn.
            //

            PageCount = LogPageHeader->PageCount;
            PagePosition = LogPageHeader->PagePosition;
            LastKnownLsn = LogPageHeader->Copy.LastLsn;

            //
            //  If we are wrapping to the beginning of the file then update
            //  the expected sequence number.
            //

            if (Wrapped) {

                ExpectedSeqNumber = ExpectedSeqNumber + 1;
                WrappedLogFile = TRUE;
            }

            CurrentLogPageOffset = NextLogPageOffset;

            //
            //  Unpin the last log page pinned.
            //

            CcUnpinData( LogPageHeaderBcb );
            LogPageHeaderBcb = NULL;

            InitialReusePage = FALSE;
        }

        //
        //  At this point we expect that there will be no more new pages in
        //  the log file.  We could have had an error of some sort on the most recent
        //  page or we may have found a tail copy for the current page.
        //  If the error occurred on the last Io to the file then
        //  this log file is useful.  Otherwise the log file can't be used.
        //

        //
        //  If we have a tail copy page then update the values in the
        //  Lfcb and restart area.
        //

        if (TailPage != NULL) {

            //
            //  Since we have read this page we know the Lfcb sequence
            //  number is the same as our expected value.
            //

            Lfcb->SeqNumber = ExpectedSeqNumber;

            Lfcb->LastFlushedLsn = TailPage->Header.Packed.LastEndLsn;

            Lfcb->RestartArea->CurrentLsn = Lfcb->LastFlushedLsn;

            ClearFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );

            //
            //  If there is room on this page for another header then
            //  remember we want to reuse the page.
            //

            if (((ULONG)Lfcb->LogPageSize - TailPage->Header.Packed.NextRecordOffset )
                >= Lfcb->RecordHeaderLength) {

                SetFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
                Lfcb->NextLogPage = CurrentLogPageOffset;
                Lfcb->ReusePageOffset = TailPage->Header.Packed.NextRecordOffset;

            } else {

                ClearFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
                Lfcb->NextLogPage = NextLogPageOffset;
            }

            //
            //  If we wrapped the log file, then we set the bit indicating so.
            //

            if (WrappedLogFile) {

                SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
            }
        }

        //
        //  Remember that the partial IO will start at the next page.
        //

        FirstPartialIo = NextLogPageOffset;

        //
        //  If the next page is the first page of the file then update
        //  the sequence number for log records which begin on the next
        //  page.
        //

        if (Wrapped) {

            ExpectedSeqNumber = ExpectedSeqNumber + 1;
        }

        //
        //  If we know the length of the transfer containing the page we stopped
        //  on we can just go to the page following the transfer and check
        //  the sequence number.  If we replaced the page then we have already
        //  modified the numbers.  If we know that only single pages were written
        //  to disk then we will munge the numbers now.  If we were in the
        //  middle of a multi-page I/O then the numbers are already set up.
        //

        //
        //  If we have a tail copy or are performing single page I/O
        //  we can immediately look at the next page.
        //

        if (ReplacePage ||
            FlagOn( Lfcb->RestartArea->Flags, RESTART_SINGLE_PAGE_IO )) {

            //
            //  Fudge the counts to show that we don't need swallow any pages.
            //

            PageCount = 2;
            PagePosition = 1;

        //
        //  If the counts match it means the current page should be the first
        //  page of a transfer.  We need to walk forward enough to guarantee
        //  that there was no subsequent transfer that made it out to disk.
        //

        } else if (PagePosition == PageCount) {

            USHORT CurrentPosition;

            //
            //  If the next page causes us to wrap to the beginning of the log
            //  file then we know which page to check next.
            //

            if (Wrapped) {

                //
                //  Fudge the counts to show that we don't need swallow any pages.
                //

                PageCount = 2;
                PagePosition = 1;

            //
            //  Walk forward looking for a page which is from a different IO transfer
            //  from the page we failed on.
            //

            } else {

                //
                //  We need to find a log page we know is not part of the log
                //  page which caused the original error.
                //
                //  Maintain the count within the current transfer.
                //

                CurrentPosition = 2;

                do {

                    //
                    //  We walk through the file, reading log pages.  If we find
                    //  a readable log page that must lie in a subsequent Io block,
                    //  we exit.
                    //

                    if (TestPageHeaderBcb != NULL) {

                        CcUnpinData( TestPageHeaderBcb );
                        TestPageHeaderBcb = NULL;
                    }

                    Status = LfsPinOrMapData( Lfcb,
                                              NextLogPageOffset,
                                              (ULONG)Lfcb->LogPageSize,
                                              TRUE,
                                              TRUE,
                                              TRUE,
                                              &UsaError,
                                              (PVOID *) &TestPageHeader,
                                              &TestPageHeaderBcb );

                    //
                    //  If we get a USA error then assume that we correctly
                    //  found the end of the original transfer.
                    //

                    if (UsaError) {

                        ValidFile = TRUE;
                        break;

                    //
                    //  If we were able to read the page, we examine it to see
                    //  if it is in the same or different Io block.
                    //

                    } else if (NT_SUCCESS( Status )) {

                        //
                        //  If this page is part of the error causing I/O, we will
                        //  use the transfer length to determine the page to
                        //  read for a subsequent error.
                        //

                        if ((TestPageHeader->PagePosition == CurrentPosition) &&
                            LfsCheckSubsequentLogPage( Lfcb,
                                                       TestPageHeader,
                                                       NextLogPageOffset,
                                                       ExpectedSeqNumber )) {

                            PageCount = TestPageHeader->PageCount + 1;
                            PagePosition = TestPageHeader->PagePosition;

                            break;

                        //
                        //  We found know the Io causing the error didn't
                        //  complete.  So we have no more checks to do.
                        //

                        } else {

                            ValidFile = TRUE;
                            break;
                        }

                    //
                    //  Try the next page.
                    //

                    } else {

                        //
                        //  Move to the next log page.
                        //

                        LfsNextLogPageOffset( Lfcb,
                                              NextLogPageOffset,
                                              &NextLogPageOffset,
                                              &Wrapped );

                        //
                        //  If the file wrapped then initialize the page count
                        //  and position so that we will not skip over any
                        //  pages in the final verification below.
                        //

                        if (Wrapped) {

                            ExpectedSeqNumber = ExpectedSeqNumber + 1;

                            PageCount = 2;
                            PagePosition = 1;
                        }

                        CurrentPosition += 1;
                    }

                    //
                    //  This is one more page we will want to uninitialize.
                    //

                    PartialIoCount += 1;

                } while( !Wrapped );
            }
        }

        //
        //  If we are unsure whether the file is valid then we will have
        //  the count and position in the current transfer.  We will walk through
        //  this transfer and read the subsequent page.
        //

        if (!ValidFile) {

            ULONG RemainingPages;

            //
            //  Skip over the remaining pages in this transfer.
            //

            RemainingPages = (PageCount - PagePosition) - 1;

            PartialIoCount += RemainingPages;

            while (RemainingPages--) {

                LfsNextLogPageOffset( Lfcb,
                                      NextLogPageOffset,
                                      &NextLogPageOffset,
                                      &Wrapped );

                if (Wrapped) {

                    ExpectedSeqNumber = ExpectedSeqNumber + 1;
                }
            }

            //
            //  Call our routine to check this log page.
            //

            if (TestPageHeaderBcb != NULL) {

                CcUnpinData( TestPageHeaderBcb );
                TestPageHeaderBcb = NULL;
            }

            Status = LfsPinOrMapData( Lfcb,
                                      NextLogPageOffset,
                                      (ULONG)Lfcb->LogPageSize,
                                      TRUE,
                                      TRUE,
                                      TRUE,
                                      &UsaError,
                                      (PVOID *) &TestPageHeader,
                                      &TestPageHeaderBcb );

            if (NT_SUCCESS( Status ) && !UsaError) {

                if (LfsCheckSubsequentLogPage( Lfcb,
                                               TestPageHeader,
                                               NextLogPageOffset,
                                               ExpectedSeqNumber )) {

                    DebugTrace( 0, Dbg, "Log file is fatally flawed\n", 0 );
                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                }
            }

            ValidFile = TRUE;
        }

        //
        //  Make sure the current page is unpinned.
        //

        if (LogPageHeaderBcb != NULL) {

            CcUnpinData( LogPageHeaderBcb );
            LogPageHeaderBcb = NULL;
        }

#ifdef SUPW_DBG
        if ((TailPage != NULL) && FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {
            DbgPrint("INFO: TailPage isn't getting written because of READ-ONLY (ok)\n");
        }

        if (PartialIoCount && FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {
            DbgPrint("INFO: PartialIoCount = 0x%x, not writing because of READ-ONLY (ok)\n");
        }
#endif

        //
        //  We have a valid file.  The Lfcb is initialized to the point where
        //  the last log record was found.  We possibly have a copy of the
        //  last page in the log file stored as a copy.  Or we could just have
        //  a page that we would like to reuse the end of.
        //

        if (!FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {

            if (TailPage != NULL) {

                //
                //  We will pin the correct page and copy the data from this
                //  page into it.  We will then flush it out to disk.
                //

                LfsPinOrMapData( Lfcb,
                                 TailPage->Copy.FileOffset,
                                 (ULONG)Lfcb->LogPageSize,
                                 TRUE,
                                 FALSE,
                                 TRUE,
                                 &UsaError,
                                 (PVOID *) &LogPageHeader,
                                 &LogPageHeaderBcb );

                RtlCopyMemory( LogPageHeader,
                               TailPage,
                               (ULONG)Lfcb->LogPageSize );

                //
                //  Fill in last flushed lsn value flush the page.
                //

                LogPageHeader->Copy.LastLsn = TailPage->Header.Packed.LastEndLsn;

                LfsFlushLogPage( Lfcb,
                                 LogPageHeader,
                                 TailPage->Copy.FileOffset,
                                 &LogPageHeaderBcb );
            }

            //
            //  We also want to write over any partial I/O so it doesn't cause
            //  us problems on a subsequent restart.  We have the starting offset
            //  and the number of blocks.  We will simply write a Baad signature into
            //  each of these pages.  Any subsequent reads will have a Usa error.
            //

            while (PartialIoCount--) {

                //
                //  Make sure the current page is unpinned.
                //

                if (LogPageHeaderBcb != NULL) {

                    CcUnpinData( LogPageHeaderBcb );
                    LogPageHeaderBcb = NULL;
                }

                if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                                 FirstPartialIo,
                                                 (ULONG)Lfcb->LogPageSize,
                                                 TRUE,
                                                 TRUE,
                                                 TRUE,
                                                 &UsaError,
                                                 (PVOID *) &LogPageHeader,
                                                 &LogPageHeaderBcb ))) {

                    //
                    //  Just store a the usa array header in the multi-section
                    //  header.
                    //

                    *((PULONG) &LogPageHeader->MultiSectorHeader.Signature) = LFS_SIGNATURE_BAD_USA_ULONG;

                    LfsFlushLogPage( Lfcb,
                                     LogPageHeader,
                                     FirstPartialIo,
                                     &LogPageHeaderBcb );
                }

                LfsNextLogPageOffset( Lfcb,
                                      FirstPartialIo,
                                      &FirstPartialIo,
                                      &Wrapped );
            }
        }

        //
        //  We used to invalidate any tail pages we reused, now we let them
        //  be recopied every restart even if we fail a little later
        //

    } finally {

        DebugUnwind( LfsFindLastLsn );

        //
        //  Unpin the tail pages is pinned.
        //

        if (SecondTailPageBcb != NULL) {

            CcUnpinData( SecondTailPageBcb );
        }

        if (FirstTailPageBcb != NULL) {

            CcUnpinData( FirstTailPageBcb );
        }

        //
        //  Unpin the log page header if neccessary.
        //

        if (LogPageHeaderBcb != NULL) {

            CcUnpinData( LogPageHeaderBcb );
        }

        if (TestPageHeaderBcb != NULL) {

            CcUnpinData( TestPageHeaderBcb );
        }

        DebugTrace( -1, Dbg, "LfsFindLastLsn:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine.
//

BOOLEAN
LfsCheckSubsequentLogPage (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_PAGE_HEADER RecordPageHeader,
    IN LONGLONG LogFileOffset,
    IN LONGLONG SequenceNumber
    )

/*++

Routine Description:

    This routine is called to check that a particular log page could not
    have been written after a prior Io transfer.  What we are looking for
    is the start of a transfer which was written after an Io which we
    we cannot read from during restart.  The presence of an additional
    Io means that we cannot guarantee that we can recover all of the
    restart data for the disk.  This makes the disk unrecoverable.

    We are given the sequence number of the Lsn that would occur on this page
    (if it is not part of an Log record which spans the end of a file).
    If we haven't wrapped the file and find an Lsn whose
    sequence number matches this, then we have an error.  If we have
    wrapped the file, and the sequence number in the Lsn in the
    first log page is
    written subsequent to a previous failing Io.

Arguments:

    Lfcb - Log file control block for this log file.

    RecordPageHeader - This is the header of a log page to check.

    LogFileOffset - This is the offset in the log file of this page.

    SequenceNumber - This is the sequence number that this log page should
                     not have.  This will be the sequence number for
                     any log records which begin on this page if written
                     after the page that failed.

Return Value:

    BOOLEAN - TRUE if this log page was written after some previous page,
              FALSE otherwise.

--*/

{
    BOOLEAN IsSubsequent;

    LSN Lsn;
    LONGLONG LsnSeqNumber;
    LONGLONG SeqNumberMinus1;
    LONGLONG LogPageFileOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCheckSubsequentLogPage:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                  -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RecordPageHeader      -> %08lx\n", RecordPageHeader );
    DebugTrace(  0, Dbg, "LogFileOffset (Low)   -> %08lx\n", LogFileOffset.LowPart );
    DebugTrace(  0, Dbg, "LogFileOffset (High)  -> %08lx\n", LogFileOffset.HighPart );
    DebugTrace(  0, Dbg, "SequenceNumber (Low)  -> %08lx\n", SequenceNumber.LowPart );
    DebugTrace(  0, Dbg, "SequenceNumber (High) -> %08lx\n", SequenceNumber.HighPart );

    //
    //  If the page header is either 0 or -1 then we say this page was not written
    //  after some previous page.
    //

    if (*((PULONG) RecordPageHeader->MultiSectorHeader.Signature) == LFS_SIGNATURE_UNINITIALIZED_ULONG ||
        *((PULONG) RecordPageHeader->MultiSectorHeader.Signature) == 0) {

        DebugTrace( -1, Dbg, "LfsCheckSubsequentLogPage:  Exit -> %08x\n", FALSE );
        return FALSE;
    }

    //
    //  If the last Lsn on the page occurs was
    //  written after the page that caused the original error.  Then we
    //  have a fatal error.
    //

    Lsn = RecordPageHeader->Copy.LastLsn;

    LfsTruncateLsnToLogPage( Lfcb, Lsn, &LogPageFileOffset );
    LsnSeqNumber = LfsLsnToSeqNumber( Lfcb, Lsn );

    SeqNumberMinus1 = SequenceNumber - 1;

    //
    //  If the sequence number for the Lsn in the page is equal or greater than
    //  Lsn we expect, then this is a subsequent write.
    //

    if ( LsnSeqNumber >= SequenceNumber ) {

        IsSubsequent = TRUE;

    //
    //  If this page is the start of the file and the sequence number is 1 less
    //  than we expect and the Lsn indicates that we wrapped the file, then it
    //  is also part of a subsequent io.
    //
    //  The following test checks
    //
    //      1 - The sequence number for the Lsn is from the previous pass
    //          through the file.
    //      2 - We are at the first page in the file.
    //      3 - The log record didn't begin on the current page.
    //

    } else if (( LsnSeqNumber == SeqNumberMinus1 )
               && ( Lfcb->FirstLogPage == LogFileOffset )
               && ( LogFileOffset != LogPageFileOffset )) {

        IsSubsequent = TRUE;

    } else {

        IsSubsequent = FALSE;
    }

    DebugTrace( -1, Dbg, "LfsCheckSubsequentLogPage:  Exit -> %08x\n", IsSubsequent );

    return IsSubsequent;
}


//
//  Local support routine
//

VOID
LfsFlushLogPage (
    IN PLFCB Lfcb,
    PVOID LogPage,
    IN LONGLONG FileOffset,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine is called to write a single log page to the log file.  We will
    mark it dirty in the cache, unpin it and call our flush routine.

Arguments:

    Lfcb - Log file control block for this log file.

    LogPage - Pointer to the log page in the cache.

    FileOffset - Offset of the page in the stream.

    Bcb - Address of the Bcb pointer for the cache.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT( !(FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) );

    //
    //  Set the page dirty and unpin it.
    //

    CcSetDirtyPinnedData( *Bcb, NULL );
    CcUnpinData( *Bcb );
    *Bcb = NULL;

    //
    //  Now flush the data.
    //

    Lfcb->UserWriteData->FileOffset = FileOffset;
    Lfcb->UserWriteData->Length = (ULONG) Lfcb->LogPageSize;

    CcFlushCache( Lfcb->FileObject->SectionObjectPointer,
                  (PLARGE_INTEGER) &FileOffset,
                  (ULONG) Lfcb->LogPageSize,
                  NULL );

    return;
}


//
//  Local support routine.
//

VOID
LfsRemoveClientFromList (
    PLFS_CLIENT_RECORD ClientArray,
    PLFS_CLIENT_RECORD ClientRecord,
    IN PUSHORT ListHead
    )

/*++

Routine Description:

    This routine is called to remove a client record from a client record
    list in an Lfs restart area.

Arguments:

    ClientArray - Base of client records in restart area.

    ClientRecord - A pointer to the record to add.

    ListHead - A pointer to the beginning of the list.  This points to a
               USHORT which is the value of the first element in the list.

Return Value:

    None.

--*/

{
    PLFS_CLIENT_RECORD TempClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsRemoveClientFromList:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Client Array  -> %08lx\n", ClientArray );
    DebugTrace(  0, Dbg, "Client Record -> %08lx\n", ClientRecord );
    DebugTrace(  0, Dbg, "List Head     -> %08lx\n", ListHead );

    //
    //  If this is the first element in the list, then the head of the list
    //  points to the element after this record.
    //

    if (ClientRecord->PrevClient == LFS_NO_CLIENT) {

        DebugTrace( 0, Dbg, "Element is first element in the list\n", 0 );
        *ListHead = ClientRecord->NextClient;

    //
    //  Otherwise the previous element points to the next element.
    //

    } else {

        TempClientRecord = ClientArray + ClientRecord->PrevClient;
        TempClientRecord->NextClient = ClientRecord->NextClient;
    }

    //
    //  If this is not the last element in the list, the previous element
    //  becomes the last element.
    //

    if (ClientRecord->NextClient != LFS_NO_CLIENT) {

        TempClientRecord = ClientArray + ClientRecord->NextClient;
        TempClientRecord->PrevClient = ClientRecord->PrevClient;
    }

    DebugTrace( -1, Dbg, "LfsRemoveClientFromList:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsAddClientToList (
    IN PLFS_CLIENT_RECORD ClientArray,
    IN USHORT ClientIndex,
    IN PUSHORT ListHead
    )

/*++

Routine Description:

    This routine is called to add a client record to the start of a list.

Arguments:

    ClientArray - This is the base of the client record.

    ClientIndex - The index for the record to add.

    ListHead - A pointer to the beginning of the list.  This points to a
               USHORT which is the value of the first element in the list.

Return Value:

    None.

--*/

{
    PLFS_CLIENT_RECORD ClientRecord;
    PLFS_CLIENT_RECORD TempClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsAddClientToList:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Client Array  -> %08lx\n", ClientArray );
    DebugTrace(  0, Dbg, "Client Index  -> %04x\n", ClientIndex );
    DebugTrace(  0, Dbg, "List Head     -> %08lx\n", ListHead );

    ClientRecord = ClientArray + ClientIndex;

    //
    //  This element will become the first element on the list.
    //

    ClientRecord->PrevClient = LFS_NO_CLIENT;

    //
    //  The next element for this record is the previous head of the list.
    //

    ClientRecord->NextClient = *ListHead;

    //
    //  If there is at least one element currently on the list, we point
    //  the first element to this new record.
    //

    if (*ListHead != LFS_NO_CLIENT) {

        TempClientRecord = ClientArray + *ListHead;
        TempClientRecord->PrevClient = ClientIndex;
    }

    //
    //  This index is now the head of the list.
    //

    *ListHead = ClientIndex;

    DebugTrace( -1, Dbg, "LfsAddClientToList:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\logrcsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LogRcSup.c

Abstract:

    This module implements support for dealing with log records, both
    writing and recovering them.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOG_RECORD_SUP)

VOID
LfsPrepareLfcbForLogRecord (
    IN OUT PLFCB Lfcb,
    IN ULONG RemainingLogBytes
    );

VOID
LfsTransferLogBytes (
    IN PLBCB Lbcb,
    IN OUT PLFS_WRITE_ENTRY *ThisWriteEntry,
    IN OUT PCHAR *CurrentBuffer,
    IN OUT PULONG CurrentByteCount,
    IN OUT PULONG PadBytes,
    IN OUT PULONG RemainingPageBytes,
    IN OUT PULONG RemainingLogBytes
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsPrepareLfcbForLogRecord)
#pragma alloc_text(PAGE, LfsTransferLogBytes)
#pragma alloc_text(PAGE, LfsWriteLogRecordIntoLogPage)
#endif


BOOLEAN
LfsWriteLogRecordIntoLogPage (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN ClientUndoNextLsn OPTIONAL,
    IN LSN ClientPreviousLsn OPTIONAL,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called to write a log record into the log file
    using the cache manager.  If there is room in the current log
    page it is added to that.  Otherwise we allocate a new log page
    and write the log record header for this log page.  We then
    write the log record into the remaining bytes of this page and
    into any subsequent pages if needed.

Arguments:

    Lfcb - File control block for this log file.

    Lch - This is the client handle, we may update the undo space for this
          client.

    NumberOfWriteEntries - Number of components of the log record.

    WriteEntries - Pointer to an array of write entries.

    UndoRequirement - Signed value indicating the requirement to write
                      an abort log record for this log record.  A negative
                      value indicates that this is the abort record.

    RecordType - The Lfs-defined type of this log record.

    TransactionId - Pointer to the transaction structure containing the
                    Id for transaction containing this operation.

    ClientUndoNextLsn - This is the Lsn provided by the client for use
                        in his restart.  Will be the zero Lsn for
                        a restart log record.

    ClientPreviousLsn - This is the Lsn provided by the client for use
                        in his restart.  Will the the zero Lsn for a
                        restart log record.

    UndoRequirement - This is the data size for the undo record for
                      this log record.

    ForceToDisk - Indicates if this log record will be flushed immediately
                  to disk.

    Lsn - A pointer to store the Lsn for this log record.

Return Value:

    BOOLEAN - Advisory, TRUE indicates that less than 1/4 of the log file is
        available.

--*/

{
    PLFS_WRITE_ENTRY ThisWriteEntry;

    ULONG RemainingLogBytes;
    ULONG OriginalLogBytes;

    ULONG RemainingPageBytes;
    ULONG HeaderAdjust;

    PLBCB ThisLbcb;

    LSN NextLsn;

    PLFS_RECORD_HEADER RecordHeader;

    PCHAR CurrentBuffer;
    ULONG CurrentByteCount;
    ULONG PadBytes;

    LFS_WAITER LfsWaiter;

    BOOLEAN LogFileFull = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWriteLogRecordIntoLogPage:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                      -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lch                       -> %08lx\n", Lch );
    DebugTrace(  0, Dbg, "Number of Write Entries   -> %08lx\n", NumberOfWriteEntries );
    DebugTrace(  0, Dbg, "Write Entries             -> %08lx\n", WriteEntries );
    DebugTrace(  0, Dbg, "Record Type               -> %08lx\n", RecordType );
    DebugTrace(  0, Dbg, "Transaction Id            -> %08lx\n", TransactionId );
    DebugTrace(  0, Dbg, "ClientUndoNextLsn (Low)   -> %08lx\n", ClientUndoNextLsn.LowPart );
    DebugTrace(  0, Dbg, "ClientUndoNextLsn (High)  -> %08lx\n", ClientUndoNextLsn.HighPart );
    DebugTrace(  0, Dbg, "ClientPreviousLsn (Low)   -> %08lx\n", ClientPreviousLsn.LowPart );
    DebugTrace(  0, Dbg, "ClientPreviousLsn (High)  -> %08lx\n", ClientPreviousLsn.HighPart );
    DebugTrace(  0, Dbg, "UndoRequirement           -> %08lx\n", UndoRequirement );
    DebugTrace(  0, Dbg, "ForceToDisk               -> %04x\n", ForceToDisk );

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT( !(FlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  We compute the size of this log record.
    //

    ThisWriteEntry = WriteEntries;

    RemainingLogBytes = 0;

    while (NumberOfWriteEntries--) {

        RemainingLogBytes += QuadAlign( ThisWriteEntry->ByteLength );

        ThisWriteEntry++;
    }

    OriginalLogBytes = RemainingLogBytes;

    ThisWriteEntry = WriteEntries;

    //
    //  Loop until we have the Lbcb and we know it is not part of
    //  a partial page transfer.  We need to make sure we have
    //  a Bcb for this page.
    //

    while (TRUE) {

        LogFileFull = LfsVerifyLogSpaceAvail( Lfcb,
                                              Lch,
                                              RemainingLogBytes,
                                              UndoRequirement,
                                              ForceToDisk );

        //
        //  We update the Lfcb so that we can start putting the log record into
        //  the top of the Lbcb active list.
        //

        LfsPrepareLfcbForLogRecord( Lfcb,
                                    RemainingLogBytes + Lfcb->RecordHeaderLength );

        ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                      LBCB,
                                      ActiveLinks );

#ifdef BENL_DBG
        ASSERT( ThisLbcb->BufferOffset < 0x1000 );
#endif

        //
        //  If there is a Bcb then we are golden.
        //

        if (ThisLbcb->LogPageBcb != NULL) { break; }

        //
        //  Otherwise we want to drop the Lfcb and wait for the IO to complete.
        //

        Lfcb->Waiters += 1;
        
        KeInitializeEvent( &LfsWaiter.Event, SynchronizationEvent, FALSE );
        LfsWaiter.Lsn.QuadPart = 0;

        //
        //  Setup a lfs waiter to be signalled if io is ongoing - since
        //  the lfcb is owned exclusive we don't need to use the sync fast mutex
        //  
        
        if (Lfcb->Sync->LfsIoState == LfsNoIoInProgress) {
            LfsWaiter.Waiters.Flink = NULL;
        } else {
            InsertHeadList( &Lfcb->WaiterList, &LfsWaiter.Waiters );
        }
        
        LfsReleaseLfcb( Lfcb );

        //
        //  If we really found i/o ongoing then wait on the event
        //  

        if (LfsWaiter.Waiters.Flink != NULL) {
            KeWaitForSingleObject( &LfsWaiter.Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }

        LfsAcquireLfcbExclusive( Lfcb );
        Lfcb->Waiters -= 1;
    }

    RemainingPageBytes = (ULONG)Lfcb->LogPageSize - (ULONG)ThisLbcb->BufferOffset;

    //
    //  Compute the Lsn starting in the next log buffer.
    //

    NextLsn.QuadPart = LfsComputeLsnFromLbcb( Lfcb, ThisLbcb );

    //
    //  We get a pointer to the log record header and the start of the
    //  log record in the pinned buffer.
    //

    RecordHeader = Add2Ptr( ThisLbcb->PageHeader,
                            (ULONG)ThisLbcb->BufferOffset,
                            PLFS_RECORD_HEADER );

    //
    //  We update the record header.
    //

    //
    //  Zero out the structure initially.
    //

    RtlZeroMemory( RecordHeader, Lfcb->RecordHeaderLength );

    //
    //  Update all the fields.
    //

    RecordHeader->ThisLsn = NextLsn;
    RecordHeader->ClientPreviousLsn = ClientPreviousLsn;
    RecordHeader->ClientUndoNextLsn = ClientUndoNextLsn;

    if (TransactionId != NULL) {
        RecordHeader->TransactionId = *TransactionId;
    }

    RecordHeader->ClientDataLength = RemainingLogBytes;
    RecordHeader->ClientId = Lch->ClientId;
    RecordHeader->RecordType = RecordType;

    //
    //  Check if this is a multi-page record.
    //

    if (RemainingLogBytes + Lfcb->RecordHeaderLength > RemainingPageBytes) {

        SetFlag( RecordHeader->Flags, LOG_RECORD_MULTI_PAGE );
    }

    RemainingPageBytes -= Lfcb->RecordHeaderLength;

    //
    //  Update the buffer position in the Lbcb
    //

    (ULONG)ThisLbcb->BufferOffset += Lfcb->RecordHeaderLength;
    HeaderAdjust = Lfcb->RecordHeaderLength;

    //
    //  Remember the values in the current write entry.
    //

    CurrentBuffer = ThisWriteEntry->Buffer;
    CurrentByteCount = ThisWriteEntry->ByteLength;

    PadBytes = (8 - (CurrentByteCount & ~(0xfffffff8))) & ~(0xfffffff8);

    //
    //  Continue to transfer bytes until all the client's data has
    //  been transferred.
    //

    while (RemainingLogBytes != 0) {

        PLFS_RECORD_PAGE_HEADER PageHeader;

        PageHeader = (PLFS_RECORD_PAGE_HEADER) ThisLbcb->PageHeader;

        //
        //  If the Lbcb is empty and we are about to store data into it we
        //  subtract the data size of the page from the available space.
        //  Update all the information we want to put in the header.
        //

        if (!FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

            //
            //  We subtract this page from the available pages only if
            //  we are at the beginning of the page.  Otherwise this
            //  could be a reuse page.  In that case it has already
            //  been subtracted.
            //

            if ((ULONG)ThisLbcb->BufferOffset - HeaderAdjust == (ULONG)Lfcb->LogPageDataOffset) {


                Lfcb->CurrentAvailable = Lfcb->CurrentAvailable - Lfcb->ReservedLogPageSize;                           //**** xxSub( Lfcb->CurrentAvailable, Lfcb->ReservedLogPageSize );
            }

            InsertTailList( &Lfcb->LbcbWorkque, &ThisLbcb->WorkqueLinks );
            SetFlag( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY );
        }

        HeaderAdjust = 0;

        //
        //  Compute the number of transfer bytes.  Update the remaining
        //  page bytes, remaining log bytes and position in the write
        //  buffer array.  This routine also copies the bytes into the buffer.
        //

        LfsTransferLogBytes( ThisLbcb,
                             &ThisWriteEntry,
                             &CurrentBuffer,
                             &CurrentByteCount,
                             &PadBytes,
                             &RemainingPageBytes,
                             &RemainingLogBytes );

        //
        //  This log record ends on this page.  Update the fields for the
        //  ending Lsn.
        //

        if (RemainingLogBytes == 0) {

            SetFlag( ThisLbcb->Flags, LOG_PAGE_LOG_RECORD_END );
            ThisLbcb->LastEndLsn = NextLsn;

            if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

                PageHeader->Header.Packed.LastEndLsn = NextLsn;
                PageHeader->Header.Packed.NextRecordOffset = (USHORT)ThisLbcb->BufferOffset;
            }
        }

        //
        //  We are done with this page, update the fields in the page header.
        //

        if ((RemainingPageBytes == 0) || 
            (RemainingLogBytes == 0)) {

            //
            //  We are done with this page.  Update the Lbcb and page header.
            //

            ThisLbcb->LastLsn = NextLsn;
            PageHeader->Copy.LastLsn = NextLsn;
            PageHeader->Flags = ThisLbcb->Flags;

            //
            //  We can't put any more log records on this page.  Remove
            //  it from the active queue.
            //

            if (RemainingPageBytes < Lfcb->RecordHeaderLength) {

                RemoveHeadList( &Lfcb->LbcbActive );
                ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

                //
                //  If there are more log bytes then get the next Lbcb.
                //

                if (RemainingLogBytes != 0) {

                    ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                                  LBCB,
                                                  ActiveLinks );

                    RemainingPageBytes = (ULONG)Lfcb->LogPageSize
                                         - (ULONG)ThisLbcb->BufferOffset;
                }
            }
        }
    }

    *Lsn = NextLsn;

    Lfcb->RestartArea->CurrentLsn = NextLsn;
    Lfcb->LfsRestartBias = 1;

    Lfcb->RestartArea->LastLsnDataLength = OriginalLogBytes;

    ClearFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );

    DebugTrace(  0, Dbg, "Lsn (Low)   -> %08lx\n", Lsn->LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)  -> %08lx\n", Lsn->HighPart );
    DebugTrace( -1, Dbg, "LfsWriteLogRecordIntoLogPage:  Exit\n", 0 );

    return LogFileFull;
}


//
//  Local support routine.
//

VOID
LfsPrepareLfcbForLogRecord (
    IN OUT PLFCB Lfcb,
    IN ULONG RemainingLogBytes
    )

/*++

Routine Description:

    This routine is called to insure that the Lfcb has a Lbcb in the
    active queue to perform the next log record transfer.
    This condition is met when there is a least one buffer block and
    the log record data will fit entirely on this page or this buffer
    block contains no other data in the unpacked case.  For the packed
    case we just need to make sure that there are sufficient Lbcb's.

Arguments:

    Lfcb - File control block for this log file.

    RemainingLogBytes - The number of bytes remaining for this log record.

Return Value:

    None

--*/

{
    PLBCB ThisLbcb;
    ULONG RemainingPageBytes;
    PLIST_ENTRY LbcbLinks;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsPrepareLfcbForLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RemainingLogBytes -> %08lx\n", RemainingLogBytes );

    //
    //  If there is no Lbcb in the active queue, we don't check it for size.
    //

    if (!IsListEmpty( &Lfcb->LbcbActive )) {

        //
        //  If the log record won't fit in the remaining bytes of this page,
        //  we queue this log buffer.
        //

        ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                      LBCB,
                                      ActiveLinks );

        RemainingPageBytes = (ULONG)Lfcb->LogPageSize
                             - (ULONG)ThisLbcb->BufferOffset;

        //
        //  This log page won't do if the remaining bytes won't hold the data
        //  unless this is the first log record in the page or we are packing
        //  the log file.
        //

        if ((RemainingLogBytes > RemainingPageBytes) &&  
            !FlagOn( Lfcb->Flags, LFCB_PACK_LOG ) && 
            ((ULONG)ThisLbcb->BufferOffset != (ULONG)Lfcb->LogPageDataOffset)) {

            RemoveHeadList( &Lfcb->LbcbActive );
            ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
        }
    }

    //
    //  We now make sure we can allocate enough Lbcb's for all of the log pages
    //  we will need.  We now include the bytes for the log record reader.
    //

    LbcbLinks = Lfcb->LbcbActive.Flink;

    while (TRUE) {

        //
        //  If the Lbcb link we have is the head of the list, we will need another
        //  Lbcb.
        //

        if (LbcbLinks == &Lfcb->LbcbActive) {

            ThisLbcb = LfsGetLbcb( Lfcb );

        } else {

            ThisLbcb = CONTAINING_RECORD( LbcbLinks,
                                          LBCB,
                                          ActiveLinks );
        }

        //
        //  Remember the bytes remaining on this page.  This will always be quad
        //  aligned.
        //

        RemainingPageBytes = (ULONG)Lfcb->LogPageSize - (ULONG)ThisLbcb->BufferOffset;

        if (RemainingPageBytes >= RemainingLogBytes) {

            break;
        }

        //
        //  Move to the next log record.
        //

        RemainingLogBytes -= RemainingPageBytes;

        LbcbLinks = ThisLbcb->ActiveLinks.Flink;
    }

    DebugTrace( -1, Dbg, "LfsPrepareLfcbForLogRecord:  Exit\n", 0 );

    return;
}


VOID
LfsTransferLogBytes (
    IN PLBCB Lbcb,
    IN OUT PLFS_WRITE_ENTRY *ThisWriteEntry,
    IN OUT PCHAR *CurrentBuffer,
    IN OUT PULONG CurrentByteCount,
    IN OUT PULONG PadBytes,
    IN OUT PULONG RemainingPageBytes,
    IN OUT PULONG RemainingLogBytes
    )

/*++

Routine Description:

    This routine is called to transfer the next block of bytes into
    a log page.  It is given a pointer to the current position in the
    current Lfs write entry and the number of bytes remaining on that
    log page.  It will transfer as many of the client's bytes from the
    current buffer that will fit and update various pointers.

Arguments:

    Lbcb - This is the buffer block for this log page.

    ThisWriteEntry - This is a pointer to a pointer to the current Lfs
                     write entry.

    CurrentBuffer - This is a pointer to a pointer to the current position
                    in the current write entry buffer.  If this points to a NULL
                    value it means to put zero bytes into the log.

    CurrentByteCount - This is a pointer to the number of bytes remaining
                       in the current buffer.

    PadBytes - This is a pointer to the number of padding byes for
        this write entry.

    RemainingPageBytes - This is pointer to the number of bytes remaining
                         in this page.

    RemainingLogBytes - This is the number of bytes remaining to transfer
                        for this log record.

Return Value:

    None

--*/

{
    PCHAR CurrentLogPagePosition;
    PCHAR CurrentClientPosition;

    ULONG TransferBytes;
    ULONG ThisPadBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsTransferLogBytes:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lbcb                      -> %08lx\n", Lbcb );
    DebugTrace(  0, Dbg, "ThisWriteEntry            -> %08lx\n", *ThisWriteEntry );
    DebugTrace(  0, Dbg, "CurrentBuffer             -> %08lx\n", *CurrentBuffer );
    DebugTrace(  0, Dbg, "CurrentByteCount          -> %08lx\n", *CurrentByteCount );
    DebugTrace(  0, Dbg, "RemainingPageBytes        -> %08lx\n", *RemainingPageBytes );
    DebugTrace(  0, Dbg, "RemainingLogBytes         -> %08lx\n", *RemainingLogBytes );

    //
    //  Remember the current client buffer position and current position
    //  in log page.
    //

    CurrentLogPagePosition = Add2Ptr( Lbcb->PageHeader, (ULONG)Lbcb->BufferOffset, PCHAR );
    CurrentClientPosition = *CurrentBuffer;

    //
    //  The limiting factor is either the number of bytes remaining in a
    //  write entry or the number remaining in the log page.
    //

    if (*CurrentByteCount <= *RemainingPageBytes) {

        TransferBytes = *CurrentByteCount;

        ThisPadBytes = *PadBytes;

        if (*RemainingLogBytes != (*CurrentByteCount + *PadBytes) ) {

            (*ThisWriteEntry)++;

            *CurrentBuffer = (*ThisWriteEntry)->Buffer;
            *CurrentByteCount = (*ThisWriteEntry)->ByteLength;

            *PadBytes = (8 - (*CurrentByteCount & ~(0xfffffff8))) & ~(0xfffffff8);
        }

    } else {

        TransferBytes = *RemainingPageBytes;

        ThisPadBytes = 0;

        *CurrentByteCount -= TransferBytes;

        if (*CurrentBuffer != NULL) {

            *CurrentBuffer += TransferBytes;
        }
    }

    //
    //  Transfer the requested bytes.
    //

    if (CurrentClientPosition != NULL) {

        RtlCopyMemory( CurrentLogPagePosition, CurrentClientPosition, TransferBytes );

    } else {

        RtlZeroMemory( CurrentLogPagePosition, TransferBytes );
    }

    //
    //  Reduce the remaining page and log bytes by the transfer amount and
    //  move forward in the log page.
    //

    *RemainingLogBytes -= (TransferBytes + ThisPadBytes);
    *RemainingPageBytes -= (TransferBytes + ThisPadBytes);

    (ULONG)Lbcb->BufferOffset += (TransferBytes + ThisPadBytes);

    DebugTrace( -1, Dbg, "LfsTransferLogBytes:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\restart.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Restart.c

Abstract:

    This module implements the routines which access the client restart
    areas.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESTART)
#define MODULE_POOL_TAG ('RsfL')

VOID
LfsSetBaseLsnPriv (
    IN PLFCB Lfcb,
    IN PLFS_CLIENT_RECORD ClientRecord,
    IN LSN BaseLsn
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsReadRestartArea)
#pragma alloc_text(PAGE, LfsSetBaseLsn)
#pragma alloc_text(PAGE, LfsSetBaseLsnPriv)
#pragma alloc_text(PAGE, LfsWriteRestartArea)
#endif


NTSTATUS
LfsReadRestartArea (
    IN LFS_LOG_HANDLE LogHandle,
    IN OUT PULONG BufferLength,
    IN PVOID Buffer,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by the client when he wishes to read his restart
    area in the log file.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    BufferLength - On entry it is the length of the user buffer.  On exit
                   it is the size of the data stored in the buffer.

    Buffer - Pointer to the buffer where the client restart data is to be
             copied.

    Lsn - This is the Lsn for client restart area.

Return Value:

    None

--*/

{
    BOOLEAN UsaError;

    PLCH Lch;

    PLFS_CLIENT_RECORD ClientRecord;

    PLFS_RECORD_HEADER RecordHeader;
    PBCB RecordHeaderBcb;

    PLFCB Lfcb;
    NTSTATUS RetStatus = STATUS_SUCCESS;


    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadRestartArea:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
    DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", Buffer );

    RecordHeaderBcb = NULL;

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                Lch->ClientArrayByteOffset,
                                PLFS_CLIENT_RECORD );

        //
        //  If the client doesn't have a restart area, go ahead and exit
        //  now.
        //

        if (ClientRecord->ClientRestartLsn.QuadPart == 0) {

            //
            //  We show there is no restart area by returning a length
            //  of zero.  We also set the Lsn value to zero so that
            //  we can catch it if the user tries to use the Lsn.
            //

            DebugTrace( 0, Dbg, "No client restart area exists\n", 0 );

            *BufferLength = 0;
            *Lsn = LfsZeroLsn;

            try_return( NOTHING );
        }

        //
        //  Release the Lfcb as we won't be modifying any fields in it.
        //

        LfsReleaseLfcb( Lfcb );

        //
        //  Pin the log record for this Lsn.
        //

        LfsPinOrMapLogRecordHeader( Lfcb,
                                    ClientRecord->ClientRestartLsn,
                                    FALSE,
                                    FALSE,
                                    &UsaError,
                                    &RecordHeader,
                                    &RecordHeaderBcb );

        //
        //  If the Lsn values don't match, then the disk is corrupt.
        //

        if (ClientRecord->ClientRestartLsn.QuadPart != RecordHeader->ThisLsn.QuadPart) {

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }


        //
        //  Check that the user's buffer is big enough to hold the restart
        //  data.  We raise an error status for this error.
        //

        if (RecordHeader->ClientDataLength > *BufferLength) {

            DebugTrace( 0, Dbg, "Client buffer is too small\n", 0 );
            *BufferLength = RecordHeader->ClientDataLength;
            *Lsn = LfsZeroLsn;
            try_return( RetStatus = STATUS_BUFFER_TOO_SMALL );
        }


        //
        //  Use the cache manager to copy the data into the user's buffer.
        //

        LfsCopyReadLogRecord( Lfcb,
                              RecordHeader,
                              Buffer );

        //
        //  Pass the length and the Lsn of the restart area back to the
        //  caller.
        //

        *BufferLength = RecordHeader->ClientDataLength;
        *Lsn = RecordHeader->ThisLsn;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( LfsReadRestartArea );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        //
        //  Unpin the log record header for the client restart if pinned.
        //

        if (RecordHeaderBcb != NULL) {

            CcUnpinData( RecordHeaderBcb );
        }

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace( -1, Dbg, "LfsReadRestartArea:  Exit\n", 0 );
    }

    return RetStatus;
}


VOID
LfsWriteRestartArea (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG BufferLength,
    IN PVOID Buffer,
    IN LOGICAL CleanShutdown,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by the client to write a restart area to the
    disk.  This routine will not return to the caller until the client
    restart area and all prior Lsn's have been flushed and the Lfs
    restart area on the disk has been updated.

    On return, all log records up to and including 'Lsn' have been flushed
    to the disk.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this client.

    BufferLength - On entry it is the length of the user buffer.

    Buffer - Pointer to the buffer where the client restart data resides.

    CleanShutdown - Logical indicating that the caller won't need to run
        restart from this restart area.  Lfs can set the CLEAN_SHUTDOWN flag
        in its restart area as an indication for 3rd party utilities that
        it is safe to party on the drive.

    Lsn - This is the Lsn for this write operation.  On input, this will be the
        new Base Lsn for this client.

          ****  This was used to prevent adding an interface change to
                the Beta release.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    PLFS_CLIENT_RECORD ClientRecord;

    LFS_WRITE_ENTRY WriteEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWriteRestartArea:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", BufferLength );
    DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", Buffer );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  If the clean shutdown flag is currently set and this caller
        //  will run restart out of this record then clear the bit on
        //  disk first.
        //

        if (FlagOn( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN ) &&
            !CleanShutdown) {

            ClearFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

        //
        //  Capture the client record after possibly updating above when writing
        //  the lfs restart areas
        //   

        ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                Lch->ClientArrayByteOffset,
                                PLFS_CLIENT_RECORD );

        //
        //  Go ahead and update the Base Lsn in the client area if the value
        //  given is not zero.
        //

        if (Lsn->QuadPart != 0) {

            LfsSetBaseLsnPriv( Lfcb,
                               ClientRecord,
                               *Lsn );
        }

        //
        //  Write this restart area as a log record into a log page.
        //

        WriteEntry.Buffer = Buffer;
        WriteEntry.ByteLength = BufferLength;

        LfsWriteLogRecordIntoLogPage( Lfcb,
                                      Lch,
                                      1,
                                      &WriteEntry,
                                      LfsClientRestart,
                                      NULL,
                                      LfsZeroLsn,
                                      LfsZeroLsn,
                                      0,
                                      TRUE,
                                      Lsn );

        //
        //  Update the restart area for the client.
        //

        ClientRecord->ClientRestartLsn = *Lsn;

        //
        //  Write the restart area to the disk.
        //

        if (CleanShutdown) {

            SetFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );

        } else {

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

    } finally {

        DebugUnwind( LfsWriteRestartArea );

        //
        //  Release the log file control block if still held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Log (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsWriteRestartArea:  Exit\n", 0 );
    }
    return;
}


VOID
LfsSetBaseLsn (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN BaseLsn
    )

/*++

Routine Description:

    This routine is called by the client to notify the log service of the
    oldest Lsn he expects to need during restart.  The Lfs is allowed to
    reuse any part of the circular log file which logically precedes
    this Lsn.  A client may only specify a Lsn which follows the previous
    Lsn specified by this client.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    BaseLsn - This is the oldest Lsn the client may require during a
              restart.

Return Value:

    None

--*/

{
    volatile NTSTATUS Status = STATUS_SUCCESS;

    PLCH Lch;

    PLFCB Lfcb;

    PLFS_CLIENT_RECORD ClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsSetBaseLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Base Lsn (Low)    -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "Base Lsn (High)   -> %08lx\n", BaseLsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-except to catch errors.
    //

    try {

        //
        //  Use a try-finally to facilitate cleanup.
        //

        try {

            //
            //  Acquire the log file control block for this log file.
            //

            LfsAcquireLchExclusive( Lch );
            Lfcb = Lch->Lfcb;

            //
            //  If the Log file has been closed then refuse access.
            //

            if (Lfcb == NULL) {

                ExRaiseStatus( STATUS_ACCESS_DENIED );
            }

            //
            //  Check that the client Id is valid.
            //

            LfsValidateClientId( Lfcb, Lch );

            ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                    Lch->ClientArrayByteOffset,
                                    PLFS_CLIENT_RECORD );

            //
            //  We simply call the worker routine to advance the base lsn.
            //  If we moved forward in the file, we will put our restart area in the
            //  queue.
            //

            LfsSetBaseLsnPriv( Lfcb,
                               ClientRecord,
                               BaseLsn );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );

        } finally {

            DebugUnwind( LfsSetBaseLsn );

            //
            //  Release the log file control block if held.
            //

            LfsReleaseLch( Lch );

            DebugTrace( -1, Dbg, "LfsSetBaseLsn:  Exit\n", 0 );
        }

    } except (LfsExceptionFilter( GetExceptionInformation() )) {

        Status = GetExceptionCode();
    }

    if (Status != STATUS_SUCCESS) {

        ExRaiseStatus( Status );
    }

    return;
}


//
//  Local support routine
//

VOID
LfsSetBaseLsnPriv (
    IN PLFCB Lfcb,
    IN PLFS_CLIENT_RECORD ClientRecord,
    IN LSN BaseLsn
    )

/*++

Routine Description:

    This worker routine is called internally by Lfs to modify the
    oldest Lsn a client expects to need during restart.  The Lfs is allowed to
    reuse any part of the circular log file which logically precedes
    this Lsn.  A client may only specify a Lsn which follows the previous
    Lsn specified by this client.

Arguments:

    Lfcb - Log context block for this file.

    ClientRecord - For the client whose base Lsn is being modified.

    BaseLsn - This is the oldest Lsn the client may require during a
              restart.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsSetBaseLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Base Lsn (Low)    -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "Base Lsn (High)   -> %08lx\n", BaseLsn.HighPart );

    //
    //  We only proceed if the client is moving forward in the file.
    //

    if (BaseLsn.QuadPart > Lfcb->OldestLsn.QuadPart) {

        if (BaseLsn.QuadPart > ClientRecord->OldestLsn.QuadPart) {

            ClientRecord->OldestLsn = BaseLsn;
        }

        Lfcb->OldestLsn = BaseLsn;

        //
        //  We walk through all the active clients and find the new
        //  oldest Lsn for the log file.
        //

        LfsFindOldestClientLsn( Lfcb->RestartArea,
                                Lfcb->ClientArray,
                                &Lfcb->OldestLsn );

        Lfcb->OldestLsnOffset = LfsLsnToFileOffset( Lfcb, Lfcb->OldestLsn );
        ClearFlag( Lfcb->Flags, LFCB_NO_OLDEST_LSN );

        LfsFindCurrentAvail( Lfcb );
    }

    DebugTrace( -1, Dbg, "LfsSetBaseLsnPriv:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\rstrtsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    RstrtSup.c

Abstract:

    This module implements support for dealing with the Lfs restart area.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESTART_SUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFindOldestClientLsn)
#pragma alloc_text(PAGE, LfsWriteLfsRestart)
#endif


VOID
LfsWriteLfsRestart (
    IN PLFCB Lfcb,
    IN ULONG ThisRestartSize,
    IN BOOLEAN WaitForIo
    )

/*++

Routine Description:

    This routine puts the Lfs restart area on the queue of operations to
    write to the file.  We do this by allocating a second restart area
    and attaching it to the Lfcb.  We also allocate a buffer control
    block to use for this write.  We look at the WaitForIo boolean to
    determine whether this thread can perform the I/O.  This also indicates
    whether this thread gives up the Lfcb.

Arguments:

    Lfcb - A pointer to the log file control block for this operation.

    ThisRestartSize - This is the size to use for the restart area.

    WaitForIo - Indicates if this thread is to perform the work.

Return Value:

    None.

--*/

{
    PLBCB NewLbcb = NULL;
    PLFS_RESTART_AREA NewRestart = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWriteLfsRestart:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Write Chkdsk  -> %04x\n", WriteChkdsk );
    DebugTrace(  0, Dbg, "Restart Size  -> %08lx\n", ThisRestartSize );
    DebugTrace(  0, Dbg, "WaitForIo     -> %08lx\n", WaitForIo );

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT(!(FlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        PLBCB ActiveLbcb;

        //
        //  We allocate another restart area and
        //  copy the current area into it.  Attach the new area to the Lfcb.
        //

        LfsAllocateRestartArea( &NewRestart, ThisRestartSize );

        //
        //  We allocate a Lbcb structure and update the values to
        //  reflect this restart area.
        //

        LfsAllocateLbcb( Lfcb, &NewLbcb );
        SetFlag( NewLbcb->LbcbFlags, LBCB_RESTART_LBCB );

        //
        //  If this is the second page, then add a page to the offset.
        //

        if (!Lfcb->InitialRestartArea) {

            NewLbcb->FileOffset = Lfcb->LogPageSize + NewLbcb->FileOffset;
        }

        (ULONG)NewLbcb->Length = ThisRestartSize;

        NewLbcb->PageHeader = (PVOID) Lfcb->RestartArea;

        //
        //  Set the lsn to a pseudo one right beyond the current lsn (the current may advance before flushing)
        //  

        ASSERT( (sizeof( LFS_RECORD_HEADER ) >> 3) > Lfcb->LfsRestartBias );

        NewLbcb->LastEndLsn.QuadPart = NewLbcb->LastLsn.QuadPart = Lfcb->RestartArea->CurrentLsn.QuadPart + Lfcb->LfsRestartBias;
        Lfcb->LfsRestartBias += 1;
        ASSERT( Lfcb->LfsRestartBias < 7 );

        //
        //  Copy the existing restart area into the new area.
        //

        RtlCopyMemory( NewRestart, Lfcb->RestartArea, ThisRestartSize );
        Lfcb->RestartArea = NewRestart;

        Lfcb->ClientArray = Add2Ptr( NewRestart, Lfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );

        NewRestart = NULL;

        //
        //  Update the Lfcb to indicate that the other restart area
        //  on the disk is to be used.
        //

        Lfcb->InitialRestartArea = !Lfcb->InitialRestartArea;

        //
        //  Add this Lbcb to the end of the workque and flush to that point.
        //

        InsertTailList( &Lfcb->LbcbWorkque, &NewLbcb->WorkqueLinks );

        //
        //  If we don't support a packed log file then we need to make
        //  sure that all file records written out ahead of this
        //  restart area make it out to disk and we don't add anything
        //  to this page.
        //

        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
            && !IsListEmpty( &Lfcb->LbcbActive )) {

            ActiveLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                            LBCB,
                                            ActiveLinks );

            if (FlagOn( ActiveLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

                RemoveEntryList( &ActiveLbcb->ActiveLinks );
                ClearFlag( ActiveLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
            }
        }

        if (WaitForIo) {


            LfsFlushToLsnPriv( Lfcb, NewLbcb->LastEndLsn, TRUE );
        } else {


        }

    } finally {

        DebugUnwind( LfsWriteLfsRestart );

        if (NewRestart != NULL) {

            ExFreePool( NewRestart );
        }

        DebugTrace( -1, Dbg, "LfsWriteLfsRestart:  Exit\n", 0 );
    }

    return;
}


VOID
LfsFindOldestClientLsn (
    IN PLFS_RESTART_AREA RestartArea,
    IN PLFS_CLIENT_RECORD ClientArray,
    OUT PLSN OldestLsn
    )

/*++

Routine Description:

    This routine walks through the active clients to determine the oldest
    Lsn the system must maintain.

Arguments:

    RestartArea - This is the Restart Area to examine.

    ClientArray - This is the start of the client data array.

    OldestLsn - We store the oldest Lsn we find in this value.  It is
        initialized with a starting value, we won't return a more recent
        Lsn.

Return Value:

    None.

--*/

{
    USHORT NextClient;

    PLFS_CLIENT_RECORD ClientBlock;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindOldestClientLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "RestartArea       -> %08lx\n", RestartArea );
    DebugTrace(  0, Dbg, "Base Lsn (Low)    -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "Base Lsn (High)   -> %08lx\n", BaseLsn.HighPart );

    //
    //  Take the first client off the in use list.
    //

    NextClient = RestartArea->ClientInUseList;

    //
    //  While there are more clients, compare their oldest Lsn with the
    //  current oldest.
    //

    while (NextClient != LFS_NO_CLIENT) {

        ClientBlock = ClientArray + NextClient;

        //
        //  We ignore this block if it's oldest Lsn is 0.
        //

        if (( ClientBlock->OldestLsn.QuadPart != 0 )
            && ( ClientBlock->OldestLsn.QuadPart < OldestLsn->QuadPart )) {

            *OldestLsn = ClientBlock->OldestLsn;
        }

        //
        //  Try the next client block.
        //

        NextClient = ClientBlock->NextClient;
    }

    DebugTrace(  0, Dbg, "OldestLsn (Low)   -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "OldestLsn (High)  -> %08lx\n", BaseLsn.HighPart );
    DebugTrace( -1, Dbg, "LfsFindOldestClientLsn:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=lfs

TARGETNAME=lfs
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..;..\..\..\ntos\inc;$(IFSKIT_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_

!IFDEF BUILD_FOR_3_51
C_DEFINES= $(C_DEFINES) -D_NTIFS_
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX



SOURCES=..\CacheSup.c  \
        ..\LbcbSup.c   \
        ..\LfsData.c   \
        ..\LogPgSup.c  \
        ..\LogRcSup.c  \
        ..\LsnSup.c    \
        ..\QueryLog.c  \
        ..\Registry.c  \
        ..\Restart.c   \
        ..\RstrtSup.c  \
        ..\StrucSup.c  \
        ..\SysInit.c   \
        ..\VerfySup.c  \
        ..\Write.c

PRECOMPILED_INCLUDE=..\lfsprocs.h
PRECOMPILED_PCH=lfsprocs.pch
PRECOMPILED_OBJ=lfsprocs.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\sysinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SysInit.c

Abstract:

    This module implements the Log File Service initialization.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_INITIALIZATION)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('IsfL')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsInitializeLogFileService)
#endif

extern USHORT LfsUsaSeqNumber;


BOOLEAN
LfsInitializeLogFileService (
    )

/*++

Routine Description:

    This routine must be called during system initialization before the
    first call to logging service, to allow the Log File Service to initialize
    its global data structures.  This routine has no dependencies on other
    system components being initialized.

    This routine will initialize the global structures used by the logging
    service and start the Lfs worker thread.

Arguments:

    None

Return Value:

    TRUE if initialization was successful

--*/

{
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsInitializeLogFileService:  Enter\n", 0 );

    //
    //  If the structure has already been initialized then we can return
    //  immediately.
    //

    if (LfsData.NodeTypeCode == LFS_NTC_DATA
        && LfsData.NodeByteSize == sizeof( LFS_DATA )
        && FlagOn( LfsData.Flags, LFS_DATA_INITIALIZED )) {

        DebugTrace( -1, Dbg, "LfsInitializeLogFileService:  Exit  ->  %01x\n", TRUE );

        return TRUE;
    }

    //
    //  Zero out the structure initially.
    //

    RtlZeroMemory( &LfsData, sizeof( LFS_DATA ));

    //
    //  Assume the operation will fail.
    //

    LfsData.Flags = LFS_DATA_INIT_FAILED;

    //
    //  Initialize the global structure for Lfs.
    //

    LfsData.NodeTypeCode = LFS_NTC_DATA;
    LfsData.NodeByteSize = sizeof( LFS_DATA );

    InitializeListHead( &LfsData.LfcbLinks );

    //
    //  Initialize the synchronization objects.
    //

    ExInitializeFastMutex( &LfsData.LfsDataLock );

    //
    //  Initialize the buffer allocation.  System will be robust enough to tolerate
    //  allocation failures.
    //

    ExInitializeFastMutex( &LfsData.BufferLock );
    KeInitializeEvent( &LfsData.BufferNotification, NotificationEvent, TRUE );
    LfsData.Buffer1 = LfsAllocatePoolNoRaise( PagedPool, LFS_BUFFER_SIZE );

    if (LfsData.Buffer1 == NULL) {

        return FALSE;
    }

    LfsData.Buffer2 = LfsAllocatePoolNoRaise( PagedPool, LFS_BUFFER_SIZE );

    //
    //  Make sure we got both.
    //

    if (LfsData.Buffer2 == NULL) {

        LfsFreePool( LfsData.Buffer1 );
        LfsData.Buffer1 = NULL;
        return FALSE;
    }

    //
    //  Initialization has been successful.
    //

    ClearFlag( LfsData.Flags, LFS_DATA_INIT_FAILED );
    SetFlag( LfsData.Flags, LFS_DATA_INITIALIZED );

    //
    //  Get a random number as a seed for the Usa sequence numbers.  Use the lower
    //  bits of the current time.
    //

    KeQuerySystemTime( &CurrentTime );
    LfsUsaSeqNumber = (USHORT) CurrentTime.LowPart;

    DebugTrace( -1, Dbg, "LfsInitializeLogFileService:  Exit  ->  %01x\n", TRUE );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\strucsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module provides support routines for creation and deletion
    of Lfs structures.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUC_SUP)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('SsfL')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsAllocateLbcb)
#pragma alloc_text(PAGE, LfsAllocateLfcb)
#pragma alloc_text(PAGE, LfsDeallocateLbcb)
#pragma alloc_text(PAGE, LfsDeallocateLfcb)
#pragma alloc_text(PAGE, LfsAllocateLeb)
#pragma alloc_text(PAGE, LfsDeallocateLeb)
#pragma alloc_text(PAGE, LfsReadPage)
#endif


PLFCB
LfsAllocateLfcb (
    IN ULONG LogPageSize,
    IN LONGLONG FileSize
    )

/*++

Routine Description:

    This routine allocates and initializes a log file control block.

Arguments:

    LogPageSize - lfs log file page size
    
    FileSize - Initial file size

Return Value:

    PLFCB - A pointer to the log file control block just
                              allocated and initialized.

--*/

{
    PLFCB Lfcb = NULL;
    ULONG Count;
    PLBCB NextLbcb;
    PLEB  NextLeb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsAllocateLfcb:  Entered\n", 0 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Allocate and zero the structure for the Lfcb.
        //

        ASSERT( LogPageSize <= PAGE_SIZE );

        Lfcb = LfsAllocatePool( PagedPool, sizeof( LFCB ) + sizeof( PLBCB ) * (PAGE_SIZE / LogPageSize) );

        //
        //  Zero out the structure initially.
        //

        RtlZeroMemory( Lfcb, sizeof( LFCB ) + sizeof( PLBCB ) * (PAGE_SIZE / LogPageSize));

        //
        //  Initialize the log file control block.
        //

        Lfcb->NodeTypeCode = LFS_NTC_LFCB;
        Lfcb->NodeByteSize = sizeof( LFCB );

        //
        //  Initialize the client links.
        //

        InitializeListHead( &Lfcb->LchLinks );

        //
        //  Initialize the Lbcb links.
        //

        InitializeListHead( &Lfcb->LbcbWorkque );
        InitializeListHead( &Lfcb->LbcbActive );

        //
        //  Initialize and allocate the spare Lbcb queue.
        //

        InitializeListHead( &Lfcb->SpareLbcbList );

        for (Count = 0; Count < LFCB_RESERVE_LBCB_COUNT; Count++) {

            NextLbcb = ExAllocatePoolWithTag( PagedPool, sizeof( LBCB ), ' sfL' );

            if (NextLbcb != NULL) {

                InsertHeadList( &Lfcb->SpareLbcbList, (PLIST_ENTRY) NextLbcb );
                Lfcb->SpareLbcbCount += 1;
            }
        }

        //
        //  Initialize and allocate the spare Leb queue.
        //

        InitializeListHead( &Lfcb->SpareLebList );

        for (Count = 0; Count < LFCB_RESERVE_LEB_COUNT; Count++)  {

            NextLeb = ExAllocatePoolWithTag( PagedPool, sizeof( LEB ), ' sfL' );

            if (NextLeb != NULL) {

                InsertHeadList( &Lfcb->SpareLebList, (PLIST_ENTRY) NextLeb );
                Lfcb->SpareLebCount += 1;
            }
        }

        //
        //  Allocate the Lfcb synchronization event.
        //

        Lfcb->Sync = LfsAllocatePool( NonPagedPool, sizeof( LFCB_SYNC ));

        ExInitializeResourceLite( &Lfcb->Sync->Resource );

        //
        //  Init the waiters list
        //  

        InitializeListHead( &Lfcb->WaiterList );

        //
        //  Initialize the pseudo Lsn for the restart Lbcb's
        //

        Lfcb->LfsRestartBias = 1;

        Lfcb->Sync->UserCount = 0;

        //
        //  Set the io state to no io ongoing
        //

        Lfcb->Sync->LfsIoState = LfsNoIoInProgress;

        //
        //  Initialize the spare list mutex
        //

        ExInitializeFastMutex( &(Lfcb->Sync->Mutex) );

        Lfcb->FileSize = FileSize;

    } finally {

        DebugUnwind( LfsAllocateFileControlBlock );

        if (AbnormalTermination() && (Lfcb != NULL)) {

            LfsDeallocateLfcb( Lfcb, TRUE );
            Lfcb = NULL;
        }

        DebugTrace( -1, Dbg, "LfsAllocateLfcb:  Exit -> %08lx\n", Lfcb );
    }

    return Lfcb;
}


VOID
LfsDeallocateLfcb (
    IN PLFCB Lfcb,
    IN BOOLEAN CompleteTeardown
    )

/*++

Routine Description:

    This routine releases the resources associated with a log file control
    block.

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    CompleteTeardown - Indicates if we are to completely remove this Lfcb.

Return Value:

    None

--*/

{
    PLBCB NextLbcb;
    PLEB  NextLeb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsDeallocateLfcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb  -> %08lx\n", Lfcb );

    //
    //  Check that there are no buffer blocks.
    //

    ASSERT( IsListEmpty( &Lfcb->LbcbActive ));
    ASSERT( IsListEmpty( &Lfcb->LbcbWorkque ));

    //
    //  Check that we have no clients.
    //

    ASSERT( IsListEmpty( &Lfcb->LchLinks ));

    //
    //  If there is a restart area we deallocate it.
    //

    if (Lfcb->RestartArea != NULL) {

        LfsDeallocateRestartArea( Lfcb->RestartArea );
    }

    //
    //  If there are any of the tail Lbcb's, deallocate them now.
    //

    if (Lfcb->ActiveTail != NULL) {

        LfsDeallocateLbcb( Lfcb, Lfcb->ActiveTail );
        Lfcb->ActiveTail = NULL;
    }

    if (Lfcb->PrevTail != NULL) {

        LfsDeallocateLbcb( Lfcb, Lfcb->PrevTail );
        Lfcb->PrevTail = NULL;
    }

    //
    //  Only do the following if we are to remove the Lfcb completely.
    //

    if (CompleteTeardown) {

        //
        //  If there is a resource structure we deallocate it.
        //

        if (Lfcb->Sync != NULL) {

#ifdef BENL_DBG
            KdPrint(( "LFS: lfcb teardown: 0x%x 0x%x\n", Lfcb, Lfcb->Sync ));
#endif

            ExDeleteResourceLite( &Lfcb->Sync->Resource );

            ExFreePool( Lfcb->Sync );
        }
    }

    //
    //  Deallocate all of the spare Lbcb's.
    //

    while (!IsListEmpty( &Lfcb->SpareLbcbList )) {

        NextLbcb = (PLBCB) Lfcb->SpareLbcbList.Flink;

        RemoveHeadList( &Lfcb->SpareLbcbList );

        ExFreePool( NextLbcb );
    }

    //
    //  Deallocate all of the spare Leb's.
    //

    while (!IsListEmpty( &Lfcb->SpareLebList )) {

        NextLeb = (PLEB) Lfcb->SpareLebList.Flink;

        RemoveHeadList( &Lfcb->SpareLebList );

        ExFreePool( NextLeb );
    }

    //
    //  Cleanup the log head mdls and buffer
    //

    if (Lfcb->LogHeadBuffer) {
        LfsFreePool( Lfcb->LogHeadBuffer );
    }
    if (Lfcb->LogHeadPartialMdl) {
        IoFreeMdl( Lfcb->LogHeadPartialMdl );
    }
    if (Lfcb->LogHeadMdl) {
        IoFreeMdl( Lfcb->LogHeadMdl );
    }

    if (Lfcb->ErrorLogPacket) {
        IoFreeErrorLogEntry( Lfcb->ErrorLogPacket );
        Lfcb->ErrorLogPacket = NULL;
    }

    //
    //  Discard the Lfcb structure.
    //

    ExFreePool( Lfcb );

    DebugTrace( -1, Dbg, "LfsDeallocateLfcb:  Exit\n", 0 );
    return;
}


VOID
LfsAllocateLbcb (
    IN PLFCB Lfcb,
    OUT PLBCB *Lbcb
    )

/*++

Routine Description:

    This routine will allocate the next Lbcb.  If the pool allocation fails
    we will look at the private queue of Lbcb's.

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Lbcb - Address to store the allocated Lbcb.

Return Value:

    None

--*/

{
    PLBCB NewLbcb = NULL;

    PAGED_CODE();

    //
    //  If there are enough entries on the look-aside list then get one from
    //  there.
    //

    if (Lfcb->SpareLbcbCount > LFCB_RESERVE_LBCB_COUNT) {

        NewLbcb = (PLBCB) Lfcb->SpareLbcbList.Flink;

        Lfcb->SpareLbcbCount -= 1;
        RemoveHeadList( &Lfcb->SpareLbcbList );

    //
    //  Otherwise try to allocate from pool.
    //

    } else {

        NewLbcb = ExAllocatePoolWithTag( PagedPool, sizeof( LBCB ), ' sfL' );
    }

    //
    //  If we didn't get one then look at the look-aside list.
    //

    if (NewLbcb == NULL) {

        if (Lfcb->SpareLbcbCount != 0) {

            NewLbcb = (PLBCB) Lfcb->SpareLbcbList.Flink;

            Lfcb->SpareLbcbCount -= 1;
            RemoveHeadList( &Lfcb->SpareLbcbList );

        } else {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    //
    //  Initialize the structure.
    //

    RtlZeroMemory( NewLbcb, sizeof( LBCB ));
    NewLbcb->NodeTypeCode = LFS_NTC_LBCB;
    NewLbcb->NodeByteSize = sizeof( LBCB );

    //
    //  Return it to the user.
    //

    *Lbcb = NewLbcb;
    return;
}


VOID
LfsDeallocateLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    )

/*++

Routine Description:

    This routine will deallocate the Lbcb.  If we need one for the look-aside
    list we will put it there.

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Lbcb - This is the Lbcb to deallocate.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Deallocate any restart area attached to this Lbcb.
    //

    if (FlagOn( Lbcb->LbcbFlags, LBCB_RESTART_LBCB ) &&
        (Lbcb->PageHeader != NULL)) {

        LfsDeallocateRestartArea( Lbcb->PageHeader );
    }

    //
    //  Put this in the Lbcb queue if it is short.
    //

    if (Lfcb->SpareLbcbCount < LFCB_MAX_LBCB_COUNT) {

        InsertHeadList( &Lfcb->SpareLbcbList, (PLIST_ENTRY) Lbcb );
        Lfcb->SpareLbcbCount += 1;

    //
    //  Otherwise just free the pool block.
    //

    } else {

        ExFreePool( Lbcb );
    }

    return;
}



VOID
LfsAllocateLeb (
    IN PLFCB Lfcb,
    OUT PLEB *NewLeb
    )
/*++

Routine Description:

    This routine will allocate an Leb. If the pool fails we will fall back
    on our spare list. A failure then will result in an exception

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Leb - This will contain the new Leb

Return Value:

    None

--*/
{

    ExAcquireFastMutexUnsafe( &(Lfcb->Sync->Mutex) );
    
    try {

        *NewLeb = NULL;
        if (Lfcb->SpareLebCount < LFCB_RESERVE_LEB_COUNT) {
            (*NewLeb) = ExAllocatePoolWithTag( PagedPool, sizeof( LEB ), ' sfL' );
        }

        if ((*NewLeb) == NULL) {
            if (Lfcb->SpareLebCount > 0) {
                *NewLeb = (PLEB) Lfcb->SpareLebList.Flink;
                Lfcb->SpareLebCount -= 1;
                RemoveHeadList( &Lfcb->SpareLebList );
            } else {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        RtlZeroMemory( (*NewLeb), sizeof( LEB ) );
        (*NewLeb)->NodeTypeCode = LFS_NTC_LEB;
        (*NewLeb)->NodeByteSize = sizeof( LEB );

    } finally {
        ExReleaseFastMutexUnsafe( &(Lfcb->Sync->Mutex) );
    }
}



VOID
LfsDeallocateLeb (
    IN PLFCB Lfcb,
    IN PLEB Leb
    )
/*++

Routine Description:

    This routine will deallocate an Leb. We'll cache the old Leb if there
    aren't too many already on the spare list

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Leb - This will contain the Leb to release

Return Value:

    None

--*/

{
    if (Leb->RecordHeaderBcb != NULL) {
        CcUnpinData( Leb->RecordHeaderBcb );
    }
    if ((Leb->CurrentLogRecord != NULL) && Leb->AuxilaryBuffer) {
        LfsFreeSpanningBuffer( Leb->CurrentLogRecord );
    }

    ExAcquireFastMutexUnsafe( &(Lfcb->Sync->Mutex) );

    try {
        if (Lfcb->SpareLebCount < LFCB_MAX_LEB_COUNT) {
            InsertHeadList( &Lfcb->SpareLebList, (PLIST_ENTRY) Leb );
            Lfcb->SpareLebCount += 1;
        } else {
            ExFreePool( Leb );
        }
    } finally {
        ExReleaseFastMutexUnsafe( &(Lfcb->Sync->Mutex) );    
    }
}


VOID
LfsReadPage (
    IN PLFCB Lfcb,
    IN PLARGE_INTEGER Offset,
    OUT PMDL *Mdl,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    Directly pages in a page off the disk - the cache manager interfaces (LfsPinOrMapPage)
    may come from the cache. This wil raise if memory can't be allocated and used for
    verification purposes


Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Offset - offset of page to pagein from the logfile

    Mdl - On success the mdl that describes the mdl - it must be deallocated via
          IoFreeMdl

    Buffer - On output an allocated buffer that holds the data from the page - it
          must be freed using ExFreePool

Return Value:

    None

--*/
{
    IO_STATUS_BLOCK Iosb;
    KEVENT Event;
    NTSTATUS Status;

    PAGED_CODE();

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Allocate buffer / mdl and page in the restart page from disk
    //

    *Buffer = LfsAllocatePool( NonPagedPool, (ULONG)Lfcb->LogPageSize );
    *Mdl = IoAllocateMdl( *Buffer,
                          (ULONG)Lfcb->LogPageSize,
                          FALSE,
                          FALSE,
                          NULL );

    if (*Mdl == NULL) {
        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool( *Mdl );

    //
    //  We own the LFCB sync exclusively and there is only a main resource for the logfile
    //  so we don't need to preacquire any resources before doing the page read
    //

    Status = IoPageRead( Lfcb->FileObject, *Mdl, Offset, &Event, &Iosb );
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event,
                               WrPageIn,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\verfysup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements consistency checking and structure comparisions
    on Lfs structures.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

#ifdef LFS_RAISE
BOOLEAN LfsRaiseFull = FALSE;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsCurrentAvailSpace)
#pragma alloc_text(PAGE, LfsFindCurrentAvail)
#pragma alloc_text(PAGE, LfsVerifyLogSpaceAvail)
#endif


VOID
LfsCurrentAvailSpace (
    IN PLFCB Lfcb,
    OUT PLONGLONG CurrentAvailSpace,
    OUT PULONG CurrentPageBytes
    )

/*++

Routine Description:

    This routine is called to determine the available log space in the log file.
    It returns the total number of free bytes and the number available on the
    active page if present.  The total free bytes will reflect all of the empty
    pages as well as the number in the active page.

Arguments:

    Lfcb - Lfcb for this log file.

    CurrentAvailSpace - This is the number of bytes available for log
                        records.

    CurrentPageBytes - This is the number of bytes remaining on the
                       current log page.

Return Value:

    None.

--*/

{
    *CurrentPageBytes = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCurrentAvailSpace:  Entered\n", 0 );

    //
    //  Get the total number from the Lfcb.
    //

    *CurrentAvailSpace = Lfcb->CurrentAvailable;

    //
    //  We now look to see if there are any bytes available on the Lbcb in
    //  the active queue.  We can add this to the bytes available in the
    //  log pages and also give this back to the caller.
    //

    if (!IsListEmpty( &Lfcb->LbcbActive )) {

        PLBCB ThisLbcb;

        ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                      LBCB,
                                      ActiveLinks );

        //
        //  If the page is not empty or the page is empty but this is a
        //  restart page then add the remaining bytes on this page.
        //

        if (FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY | LBCB_FLUSH_COPY )) {

            *CurrentPageBytes = (ULONG)Lfcb->LogPageSize - (ULONG)ThisLbcb->BufferOffset;

            *CurrentAvailSpace = *CurrentAvailSpace + *CurrentPageBytes;                                               //**** xxAdd( *CurrentAvailSpace, xxFromUlong( *CurrentPageBytes ));
        }
    }

    DebugTrace( +1, Dbg, "LfsCurrentAvailSpace:  Exit\n", 0 );

    return;
}


BOOLEAN
LfsVerifyLogSpaceAvail (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG RemainingLogBytes,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk
    )

/*++

Routine Description:

    This routine is called to verify that we may write this log record into the
    log file.  We want to always leave room for each transaction to abort.

    We determine how much space the current log record will take and the
    worst case for its undo operation.  If this space is available we
    update the corresponding values in the Lfcb and Lch for bookkeeping.
    Otherwise we raise a status indicating that the log file is full.

    The disk usage is different for the packed and unpacked cases.  Make the
    following adjustments after finding the total available and amount still
    remaining on the last active page,

    Packed Case:

        Size needed for log record is data size plus header size.

        Undo requirement is the undo data size plus the header size.
            We have already taken into account the end of the pages
            except for the current page.

        Add the log record size to the undo requirement to get the
            log file usage.  Compare this number with the actual available
            space (Available - CommittedUndo).  If the space is not
            available, then raise LOG_FILE_FULL.  Must take into account
            any unused bytes at the end of the current page.

    Unpacked Case:

        Size needed is initially header size plus data size.

        If the log record can't begin on the current page then
            add the bytes being thrown away to the log record size.

        If the page is being forced to disk then add any remaining
            bytes on the last page.  To the bytes being used.

        Undo requirement is twice the sum of the header size and
            undo size.  We double the requested size since the log
            record will always fit on a page.  This can be a
            positive or negative number.

        Add the log record usage to the undo usage to get the log file
            usage.  Compare this number with the actual available
            space (Available - CommittedUndo).  If the space is not
            available, then raise LOG_FILE_FULL.

Arguments:

    Lfcb - Lfcb for this log file.

    Lch - Client handle

    RemainingLogBytes - Number of bytes for the current log record

    UndoRequirement - User's requirement for the undo record.

    ForceToDisk - Indicates if this log record will be flushed to disk.

Return Value:

    BOOLEAN - Advisory, indicates that there is less than 1/4 of the log file available.

--*/

{
    ULONG CurrentLogRecordSize;
    ULONG LogRecordStart;
    ULONG TailBytes;

    LONGLONG CurrentAvailSpace;
    ULONG CurrentPageBytes;

    LONGLONG LogFileUsage;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsVerifyLogSpaceAvail:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08x\n", Lfcb );
    DebugTrace(  0, Dbg, "Lch               -> %08lx\n", Lch );
    DebugTrace(  0, Dbg, "RemainingLogBytes -> %08lx\n", RemainingLogBytes );
    DebugTrace(  0, Dbg, "UndoRequirement   -> %08lx\n", UndoRequirement );
    DebugTrace(  0, Dbg, "ForceToDisk       -> %04x\n", ForceToDisk );

    //
    //  Start by collecting the current data on the file.
    //

    LfsCurrentAvailSpace( Lfcb,
                          &CurrentAvailSpace,
                          &CurrentPageBytes );

    //
    //  We compute the amount of space needed for the current log record by
    //  adding up the following:
    //
    //      Space at end of current log page which won't be used.
    //      Size of header for log record.
    //      Size of client data in log record.
    //      Size of wasted portion of log page if this is forced to disk.
    //

    //
    //  Start with the size of the header and the client data.
    //

    CurrentLogRecordSize = RemainingLogBytes + Lfcb->RecordHeaderLength;

    //
    //  If the log is packed and there are bytes on the current page we need
    //  to take into account any bytes at the end of the page which won't
    //  be used.  This will happen if the log record spills into the end of
    //  the log page but doesn't use up the page.  If the remaining bytes are
    //  less than a record header size we must throw them away.
    //

    if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        if (CurrentPageBytes != 0
            && CurrentLogRecordSize < CurrentPageBytes
            && (CurrentPageBytes - CurrentLogRecordSize) < Lfcb->RecordHeaderLength) {

            CurrentLogRecordSize += (CurrentPageBytes - CurrentLogRecordSize);
        }

    //
    //  If this is the unpacked case we need to check for bytes being thrown away
    //  on the current page or the last page.
    //

    } else {

        //
        //  If there is an active Lbcb, we need to add any bytes that
        //  would be thrown away at the end.
        //

        if (CurrentPageBytes != 0) {

            //
            //  We won't use this log page unless the new log record will fit or
            //  unless this is the first log record in the page.
            //

            if ((CurrentPageBytes != (ULONG)Lfcb->LogPageDataSize)
                && (CurrentLogRecordSize > CurrentPageBytes)) {

                CurrentLogRecordSize += CurrentPageBytes;

                //
                //  Remember that we will start this log record at the first
                //  byte in the data portion of a page.
                //

                LogRecordStart = 0;

            //
            //  Otherwise this will start at the current offset into the
            //  data portion of the log page.
            //

            } else {

                LogRecordStart = (ULONG)Lfcb->LogPageDataSize - CurrentPageBytes;
            }

        //
        //  If there was no Lbcb, then we know that we will start at the first
        //  byte of the data portion.
        //

        } else {

            LogRecordStart = 0;
        }

        //
        //  We always assume that we will use up the rest of the bytes on the last page
        //  in computing whether the log record will fit in the available space.  We
        //  only subtract that space from the available space if this is a force write.
        //

        if (ForceToDisk) {

            //
            //  We take into account where we start on a log page and continue
            //  to subtract log pages until we know the amount on the last
            //  page.
            //

            TailBytes = RemainingLogBytes + Lfcb->RecordHeaderLength + LogRecordStart;

            while (TailBytes > (ULONG)Lfcb->LogPageDataSize) {

                TailBytes -= (ULONG)Lfcb->LogPageDataSize;
            }

            TailBytes = (ULONG)Lfcb->LogPageDataSize - TailBytes;

            CurrentLogRecordSize += TailBytes;
        }
    }

    //
    //  We now know the number of bytes needed for the current log page.
    //  Next we compute the number of bytes being reserved by UndoRequirement.
    //  If the UndoRequirement is positive, we will add to the amount reserved
    //  in the log file.  If it is negative, we will subtract from the amount
    //  reserved in the log file.
    //

    //
    //  When we have an actual reserve amount, we convert it to positive
    //  and then reserve twice the space required to hold the data and
    //  its header (up to the maximum of a single page.
    //

    if (UndoRequirement != 0) {

        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

            UndoRequirement *= 2;
        }

        if (UndoRequirement < 0) {

            UndoRequirement -= (2 * Lfcb->RecordHeaderLength);
        } else {

            UndoRequirement += (2 * Lfcb->RecordHeaderLength);
        }
    }

    //
    //  Now compute the net log file usage.  The result may be positive or
    //  negative.
    //

    LogFileUsage = ((LONG) CurrentLogRecordSize)  + UndoRequirement;                                                   //**** xxFromLong( ((LONG) CurrentLogRecordSize)  + UndoRequirement );

    //
    //  The actual available space is the CurrentAvail minus the reserved
    //  undo value in the Lfcb.
    //

    CurrentAvailSpace = CurrentAvailSpace - Lfcb->TotalUndoCommitment;                                                 //**** xxSub( CurrentAvailSpace, Lfcb->TotalUndoCommitment );

    //
    //  If this log file usage is greater than the available log file space
    //  then we raise a status code.
    //

#ifdef LFS_RAISE
    if (LfsRaiseFull) {

        LfsRaiseFull = FALSE;
        DebugTrace( -1, Dbg, "LfsVerifyLogSpaceAvail:  About to raise\n", 0 );
        ExRaiseStatus( STATUS_LOG_FILE_FULL );
    }
#endif

    if (LogFileUsage > CurrentAvailSpace) {

        DebugTrace( -1, Dbg, "LfsVerifyLogSpaceAvail:  About to raise\n", 0 );
        ExRaiseStatus( STATUS_LOG_FILE_FULL );
    }

    Lfcb->TotalUndoCommitment = Lfcb->TotalUndoCommitment + UndoRequirement;                                           //**** xxAdd( Lfcb->TotalUndoCommitment, xxFromLong( UndoRequirement ));

    Lch->ClientUndoCommitment = Lch->ClientUndoCommitment + UndoRequirement;                                           //**** xxAdd( Lch->ClientUndoCommitment, xxFromLong( UndoRequirement ));

    DebugTrace( -1, Dbg, "LfsVerifyLogSpaceAvail:  Exit\n", 0 );

    //
    //  Now check if the log file is almost used up.
    //

    if ((CurrentAvailSpace - LogFileUsage) < (Lfcb->TotalAvailable >> 2)) {

        return TRUE;
    }

    return FALSE;
}


VOID
LfsFindCurrentAvail (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This routine is called to calculate the number of bytes available for log
    records which are in completely empty log record pages.  It ignores any
    partial pages in the active work queue and ignores any page which is
    going to be reused.

Arguments:

    Lfcb - Lfcb for this log file.

Return Value:

    None.

--*/

{
    LONGLONG OldestPageOffset;
    LONGLONG NextFreePageOffset;
    LONGLONG FreeBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindCurrentAvail:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08x\n", Lfcb );

    //
    //  If there is a last lsn in the restart area then we know
    //  that we will have to compute the free range.
    //

    if (!FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN )) {

        //
        //  If there is no oldest Lsn then start at the
        //  first page of the file.
        //

        if (FlagOn( Lfcb->Flags, LFCB_NO_OLDEST_LSN )) {

            OldestPageOffset = Lfcb->FirstLogPage;

        } else {

            LfsTruncateOffsetToLogPage( Lfcb,
                                        Lfcb->OldestLsnOffset,
                                        &OldestPageOffset );
        }

        //
        //  We will use the next log page offset to compute the
        //  next free page.  If we are going to reuse this page
        //  go to the next page,  if we are at the first page then
        //  use the end of the file.
        //

        if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

            NextFreePageOffset = Lfcb->NextLogPage + Lfcb->LogPageSize;                                                //**** xxAdd( Lfcb->NextLogPage, Lfcb->LogPageSize );

        } else if ( Lfcb->NextLogPage == Lfcb->FirstLogPage ) {                                                        //**** xxEql( Lfcb->NextLogPage, Lfcb->FirstLogPage )

            NextFreePageOffset = Lfcb->FileSize;

        } else {

            NextFreePageOffset = Lfcb->NextLogPage;
        }

        //
        //  If the two offsets are the same then there is no available space.
        //

        if ( OldestPageOffset == NextFreePageOffset ) {                                                                //**** xxEql( OldestPageOffset, NextFreePageOffset )

            Lfcb->CurrentAvailable = 0;

        } else {

            //
            //  If the free offset follows the oldest offset then subtract
            //  this range from the total available pages.
            //

            if ( OldestPageOffset < NextFreePageOffset ) {                                                             //**** xxLtr( OldestPageOffset, NextFreePageOffset )

                FreeBytes = Lfcb->TotalAvailInPages - ( NextFreePageOffset - OldestPageOffset );                       //**** xxSub( Lfcb->TotalAvailInPages, xxSub( NextFreePageOffset, OldestPageOffset ));

            } else {

                FreeBytes = OldestPageOffset - NextFreePageOffset;                                                     //**** xxSub( OldestPageOffset, NextFreePageOffset );
            }

            //
            //  We now have the total bytes in the pages available.  We
            //  now have to subtract the size of the page header to get
            //  the total available bytes.
            //
            //  We will convert the bytes to pages and then multiple
            //  by the data size of each page.
            //

            FreeBytes = Int64ShrlMod32(((ULONGLONG)(FreeBytes)), Lfcb->LogPageShift);

            Lfcb->CurrentAvailable = FreeBytes * (ULONG)Lfcb->ReservedLogPageSize;                                     //**** xxXMul( FreeBytes, Lfcb->ReservedLogPageSize.LowPart );
        }

    //
    //  Otherwise the entire file is available.
    //

    } else {

        Lfcb->CurrentAvailable = Lfcb->MaxCurrentAvail;
    }

    DebugTrace( -1, Dbg, "LfsFindCurrentAvail:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\write.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the user routines which write log records into
    or flush portions of the log file.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#define LFS_PAGES_TO_VERIFY 10

VOID
LfsGetActiveLsnRangeInternal (
    IN PLFCB Lfcb,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsCheckWriteRange)
#pragma alloc_text(PAGE, LfsFlushToLsn)
#pragma alloc_text(PAGE, LfsForceWrite)
#pragma alloc_text(PAGE, LfsGetActiveLsnRange)
#pragma alloc_text(PAGE, LfsGetActiveLsnRangeInternal)
#pragma alloc_text(PAGE, LfsWrite)
#endif


VOID
LfsGetActiveLsnRangeInternal (
    IN PLFCB Lfcb,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    )
/*++

Routine Description:

    Returns back the range that is active in the logfile from the oldest valid LSN to
    where the next active LSN will be.

Arguments:

    Lfcb - the logfile lfcb

    OldestLsn - returns the oldest active lsn

    NextLsn - returns the projected next lsn to be used

Return Value:

    None

--*/
{
    PLBCB ActiveLbcb;

    PAGED_CODE();

    //
    //  Calculate what the next LSN will be using the regular logic
    //  1) if there is no active lbcb then it will be the first offset on the next
    //     page (the seq. number will increment if it wraps)
    //  2) Otherwise its the Lsn contained in the top of the active lbcb list
    //

    if (!IsListEmpty( &Lfcb->LbcbActive )) {
        ActiveLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                        LBCB,
                                        ActiveLinks );
        NextLsn->QuadPart = LfsComputeLsnFromLbcb( Lfcb, ActiveLbcb );
    } else {

        if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL | LFCB_NO_LAST_LSN)) {
            NextLsn->QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->NextLogPage + max( Lfcb->LogPageDataOffset, Lfcb->ReusePageOffset), Lfcb->SeqNumber );
        } else if (Lfcb->NextLogPage != Lfcb->FirstLogPage) {
            NextLsn->QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->NextLogPage + Lfcb->LogPageDataOffset, Lfcb->SeqNumber );
        } else {
            NextLsn->QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->NextLogPage + Lfcb->LogPageDataOffset, Lfcb->SeqNumber + 1 );
        }
    }

    OldestLsn->QuadPart = Lfcb->OldestLsn.QuadPart;
}


VOID
LfsGetActiveLsnRange (
    IN LFS_LOG_HANDLE LogHandle,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    )

/*++

Routine Description:

    Returns back the range that is active in the logfile from the oldest valid LSN to
    where the next active LSN will be. For external clients since it acquires the leb sync resource

Arguments:

    Lfcb - the logfile handle

    OldestLsn - returns the oldest active lsn

    NextLsn - returns the projected next lsn to be used

Return Value:

    None

--*/
{
    PLCH Lch;
    PLFCB Lfcb;

    PAGED_CODE();

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        LfsGetActiveLsnRangeInternal( Lfcb, OldestLsn, NextLsn );


    } finally {
        LfsReleaseLch( Lch );
    }
}


BOOLEAN
LfsWrite (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN UndoNextLsn,
    IN LSN PreviousLsn,
    IN LONG UndoRequirement,
    IN ULONG Flags,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by a client to write a log record to the log file.
    The log record is lazy written and is not guaranteed to be on the disk
    until a subsequent LfsForceWrie or LfsWriteRestartArea or until
    an LfsFlushtoLsn is issued withan Lsn greater-than or equal to the Lsn
    returned from this service.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    NumberOfWriteEntries - Number of components of the log record.

    WriteEntries - Pointer to an array of write entries.

    RecordType - Lfs defined type for this log record.

    TransactionId - Id value used to group log records by complete transaction.

    UndoNextLsn - Lsn of a previous log record which needs to be undone in
                  the event of a client restart.

    PreviousLsn - Lsn of the immediately previous log record for this client.

    Lsn - Lsn to be associated with this log record.

    UndoRequirement -

    Flags - if LFS_WRITE_FLAG_WRITE_AT_FRONT put this record at the front of the log and all
            records will continue from then on after it.

Return Value:

    BOOLEAN - Advisory, TRUE indicates that less than 1/4 of the log file is
        available.

--*/

{
    NTSTATUS Status;
    BOOLEAN LogFileFull = FALSE;
    PLCH Lch;

    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWrite:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle                -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "NumberOfWriteEntries      -> %08lx\n", NumberOfWriteEntries );
    DebugTrace(  0, Dbg, "WriteEntries              -> %08lx\n", WriteEntries );
    DebugTrace(  0, Dbg, "Record Type               -> %08lx\n", RecordType );
    DebugTrace(  0, Dbg, "Transaction Id            -> %08lx\n", TransactionId );
    DebugTrace(  0, Dbg, "UndoNextLsn (Low)         -> %08lx\n", UndoNextLsn.LowPart );
    DebugTrace(  0, Dbg, "UndoNextLsn (High)        -> %08lx\n", UndoNextLsn.HighPart );
    DebugTrace(  0, Dbg, "PreviousLsn (Low)         -> %08lx\n", PreviousLsn.LowPart );
    DebugTrace(  0, Dbg, "PreviousLsn (High)        -> %08lx\n", PreviousLsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  If the clean shutdown flag is currently set then clear it
        //  before allowing more log records out.
        //

        if (FlagOn( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN )) {

            ClearFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

        //
        //  Check for write at front flag - we can't write at front if we're about to
        //  reuse the last page or there is no last lsn - these conditions only occur
        //  right at mount (and only if the mount fails)
        //

        if (FlagOn( Flags, LFS_WRITE_FLAG_WRITE_AT_FRONT ) &&
            !FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL )) {

            LSN NextLsn;
            LSN NextBeyondLsn;
            LSN NextActiveLsn;
            LSN OldestLsn;
            ULONG Index;
            PVOID TestPageHeader = NULL;
            PMDL TestPageMdl = NULL;

            //
            //  Calculate the projected LSN for a write at the front and the page after it
            //

            NextLsn.QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->FirstLogPage + Lfcb->LogPageDataOffset, Lfcb->SeqNumber );
            NextBeyondLsn.QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->FirstLogPage + Lfcb->LogPageDataOffset + Lfcb->LogPageSize, Lfcb->SeqNumber );

            LfsGetActiveLsnRangeInternal( Lfcb, &OldestLsn, &NextActiveLsn );

            //
            //  Test if calculated front LSN falls in active range
            //

#ifdef BENL_DBG
            KdPrint(( "LFS: NextLsn: 0x%I64x Oldest: 0x%I64x Current: 0x%I64x Computed: 0x%I64x\n", NextLsn,  Lfcb->OldestLsn, Lfcb->RestartArea->CurrentLsn, NextActiveLsn ));
#endif

            if ((NextBeyondLsn.QuadPart < OldestLsn.QuadPart) ||
                (NextLsn.QuadPart > NextActiveLsn.QuadPart)) {

                //
                //  Walk through the active queue and remove any Lbcb's with
                //  data from that queue.  This will lets us create new active lbcbs
                //

                while (!IsListEmpty( &Lfcb->LbcbActive )) {

                    PLBCB ThisLbcb;

                    ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                                  LBCB,
                                                  ActiveLinks );

                    RemoveEntryList( &ThisLbcb->ActiveLinks );
                    ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

                    //
                    //  If this page has some new entries, allow it to
                    //  be flushed to disk elsewhere.  Otherwise deallocate it
                    //  here. We set LBCB_NOT_EMPTY when we first put data into
                    //  the page and add it to  the workqueue.
                    //

                    if (!FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

                        ASSERT( NULL == ThisLbcb->WorkqueLinks.Flink );

                        if (ThisLbcb->LogPageBcb != NULL) {

                            CcUnpinDataForThread( ThisLbcb->LogPageBcb,
                                                  ThisLbcb->ResourceThread );
                        }

                        LfsDeallocateLbcb( Lfcb, ThisLbcb );
                    }
                }

                ASSERT( !FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL ) );
                Lfcb->NextLogPage = Lfcb->FirstLogPage;

                //
                //   Do an extra verification step - to check for simultaneous writers in the log
                //   read the next 10 pages and confirm they have expected sequence numbers
                //

                try {

                    for (Index=0; Index < LFS_PAGES_TO_VERIFY; Index++) {
                        ULONG Signature;
                        LARGE_INTEGER Offset;

                        Offset.QuadPart =  Lfcb->FirstLogPage + Index * Lfcb->LogPageSize;

                        LfsReadPage( Lfcb, &Offset, &TestPageMdl, &TestPageHeader );
                        Signature = *((PULONG)TestPageHeader);
                        if (Signature != LFS_SIGNATURE_BAD_USA_ULONG) {
                            if (LfsCheckSubsequentLogPage( Lfcb,
                                                           TestPageHeader,
                                                           Lfcb->FirstLogPage + Index * Lfcb->LogPageSize,
                                                           Lfcb->SeqNumber + 1 )) {

                                DebugTrace( 0, Dbg, "Log file is fatally flawed\n", 0 );
                                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                            }
                        }

                        //
                        //  Make sure the current page is unpinned.
                        //

                        if (TestPageMdl) {
                            IoFreeMdl( TestPageMdl );
                            TestPageMdl = NULL;
                        }
                        if (TestPageHeader) {
                            LfsFreePool( TestPageHeader );
                            TestPageHeader = NULL ;
                        }
                    }

                } finally {

                    if (TestPageMdl) {
                        IoFreeMdl( TestPageMdl );
                        TestPageMdl = NULL;
                    }
                    if (TestPageHeader) {
                        LfsFreePool( TestPageHeader );
                        TestPageHeader = NULL ;
                    }
                }
            }
        }

#ifdef BENL_DBG
        {
            LSN OldestLsn;
            LSN NextActiveLsn;

            LfsGetActiveLsnRangeInternal( Lfcb, &OldestLsn, &NextActiveLsn );
#endif

        //
        //  Write the log record.
        //

        LogFileFull = LfsWriteLogRecordIntoLogPage( Lfcb,
                                                    Lch,
                                                    NumberOfWriteEntries,
                                                    WriteEntries,
                                                    RecordType,
                                                    TransactionId,
                                                    UndoNextLsn,
                                                    PreviousLsn,
                                                    UndoRequirement,
                                                    FALSE,
                                                    Lsn );

#ifdef BENL_DBG
            ASSERT( Lsn->QuadPart == NextActiveLsn.QuadPart );
        }
#endif

    } finally {

        DebugUnwind( LfsWrite );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)   -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)  -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsWrite:  Exit\n", 0 );
    }

    return LogFileFull;
}


BOOLEAN
LfsForceWrite (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId,
    IN LSN UndoNextLsn,
    IN LSN PreviousLsn,
    IN LONG UndoRequirement,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by a client to write a log record to the log file.
    This is idendical to LfsWrite except that on return the log record is
    guaranteed to be on disk.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    NumberOfWriteEntries - Number of components of the log record.

    WriteEntries - Pointer to an array of write entries.

    RecordType - Lfs defined type for this log record.

    TransactionId - Id value used to group log records by complete transaction.

    UndoNextLsn - Lsn of a previous log record which needs to be undone in
                  the event of a client restart.

    PreviousLsn - Lsn of the immediately previous log record for this client.

    Lsn - Lsn to be associated with this log record.

Return Value:

    BOOLEAN - Advisory, TRUE indicates that less than 1/4 of the log file is
        available.

--*/

{
    PLCH Lch;

    PLFCB Lfcb;
    BOOLEAN LogFileFull = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsForceWrite:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle                -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "NumberOfWriteEntries      -> %08lx\n", NumberOfWriteEntries );
    DebugTrace(  0, Dbg, "WriteEntries              -> %08lx\n", WriteEntries );
    DebugTrace(  0, Dbg, "Record Type               -> %08lx\n", RecordType );
    DebugTrace(  0, Dbg, "Transaction Id            -> %08lx\n", TransactionId );
    DebugTrace(  0, Dbg, "UndoNextLsn (Low)         -> %08lx\n", UndoNextLsn.LowPart );
    DebugTrace(  0, Dbg, "UndoNextLsn (High)        -> %08lx\n", UndoNextLsn.HighPart );
    DebugTrace(  0, Dbg, "PreviousLsn (Low)         -> %08lx\n", PreviousLsn.LowPart );
    DebugTrace(  0, Dbg, "PreviousLsn (High)        -> %08lx\n", PreviousLsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchExclusive( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  If the clean shutdown flag is currently set then clear it
        //  before allowing more log records out.
        //

        if (FlagOn( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN )) {

            ClearFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

        //
        //  Write the log record.
        //

        LogFileFull = LfsWriteLogRecordIntoLogPage( Lfcb,
                                                    Lch,
                                                    NumberOfWriteEntries,
                                                    WriteEntries,
                                                    RecordType,
                                                    TransactionId,
                                                    UndoNextLsn,
                                                    PreviousLsn,
                                                    UndoRequirement,
                                                    TRUE,
                                                    Lsn );

        //
        //  The call to add this lbcb to the workque is guaranteed to release
        //  the Lfcb if this thread may do the Io.
        //

        LfsFlushToLsnPriv( Lfcb, *Lsn, FALSE );

    } finally {

        DebugUnwind( LfsForceWrite );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)   -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)  -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsForceWrite:  Exit\n", 0 );
    }
    return LogFileFull;
}


VOID
LfsFlushToLsn (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN Lsn
    )

/*++

Routine Description:

    This routine is called by a client to insure that all log records
    to a certain point have been flushed to the file.  This is done by
    checking if the desired Lsn has even been written at all.  If so we
    check if it has been flushed to the file.  If not, we simply write
    the current restart area to the disk.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Lsn - This is the Lsn that must be on the disk on return from this
          routine.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFlushToLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Lsn (Low)         -> %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)        -> %08lx\n", Lsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLchShared( Lch );
        
        Lfcb = Lch->Lfcb;

        //
        //  If the log file has been closed we will assume the Lsn has been flushed.
        //

        if (Lfcb != NULL) {

            //
            //  Volumes mounted readonly ignore flush callbacks from lazy writer.
            //

            if (!FlagOn(Lfcb->Flags, LFCB_READ_ONLY)) {

                //
                //  Check that the client Id is valid.
                //

                LfsValidateClientId( Lfcb, Lch );

                //
                //  Call our common routine to perform the work.
                //

                LfsFlushToLsnPriv( Lfcb, Lsn, FALSE );

            }
        }

    } finally {

        DebugUnwind( LfsFlushToLsn );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsFlushToLsn:  Exit\n", 0 );
    }

    return;
}


VOID
LfsCheckWriteRange (
    IN PLFS_WRITE_DATA WriteData,
    IN OUT PLONGLONG FlushOffset,
    IN OUT PULONG FlushLength
    )

/*++

Routine Description:

    This routine is called Ntfs to Lfs when a flush occurs.  This will give Lfs a chance
    to trim the amount of the flush.  Lfs can then use a 4K log record page size
    for all systems (Intel and Alpha).

    This routine will trim the size of the IO request to the value stored in the
    Lfcb for this volume.  We will also redirty the second half of the page if
    we have begun writing log records into it.

Arguments:

    WriteData - This is the data in the user's data structure which is maintained
        by Lfs to describe the current writes.

    FlushOffset - On input this is the start of the flush passed to Ntfs from MM.
        On output this is the start of the actual range to flush.

    FlushLength - On input this is the length of the flush from the given FlushOffset.
        On output this is the length of the flush from the possibly modified FlushOffset.

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    PLFCB Lfcb;
    PLFCB NextLfcb;
    ULONG Range;
    ULONG Index;


    PAGED_CODE();

    //
    //  Find the correct Lfcb for this request.
    //

    Lfcb = WriteData->Lfcb;

    //
    //  Trim the write if not a system page size.
    //

    if (Lfcb->LogPageSize != PAGE_SIZE) {

        //
        //  Check if we are trimming before the write.
        //

        if (*FlushOffset < WriteData->FileOffset) {

            *FlushLength -= (ULONG) (WriteData->FileOffset - *FlushOffset);
            *FlushOffset = WriteData->FileOffset;
        }

        //
        //  Check that we aren't flushing too much.
        //

        if (*FlushOffset + *FlushLength > WriteData->FileOffset + WriteData->Length) {

            *FlushLength = (ULONG) (WriteData->FileOffset + WriteData->Length - *FlushOffset);
        }

        //
        //  Finally check if we have to redirty a page.
        //

        Range = (ULONG)PAGE_SIZE / (ULONG)Lfcb->LogPageSize;

        for (Index=0; Index < Range; Index++) {
            if (Lfcb->DirtyLbcb[Index] &&
                Lfcb->DirtyLbcb[Index]->FileOffset >= *FlushLength + *FlushOffset) {

                *((PULONG) (Lfcb->DirtyLbcb[Index]->PageHeader)) = LFS_SIGNATURE_RECORD_PAGE_ULONG;
            }

        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements the file cleanup routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    23-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonCleanup (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsCleanupCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb
    );

NTSTATUS
MsCleanupFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
MsCleanupRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb
    );

NTSTATUS
MsCleanupVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCleanupCcb )
#pragma alloc_text( PAGE, MsCleanupFcb )
#pragma alloc_text( PAGE, MsCleanupRootDcb )
#pragma alloc_text( PAGE, MsCleanupVcb )
#pragma alloc_text( PAGE, MsCommonCleanup )
#pragma alloc_text( PAGE, MsFsdCleanup )
#pragma alloc_text( PAGE, MsCancelTimer )
#endif

NTSTATUS
MsFsdCleanup (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCleanupFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdCleanup\n", 0);

    //
    // Call the common cleanup routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonCleanup( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "MsFsdCleanup -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonCleanup (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleaning up a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsContext2;
    PVCB vcb;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsFsdCleanup\n", 0);
    DebugTrace( 0, Dbg, "MsfsDeviceObject = %08lx\n", (ULONG)MsfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);



    //
    // Get the a referenced pointer to the node. If this is a CCB close and the FCB is already closed
    // then the node type comes back as undefined. We still want to cleanup in this case.
    // Cleanup for the CCB in this case is removing it from the FCB chain and removing share options. We
    // could do without this cleanup but it would look stange to have a corrupted chain in this case
    // (it does not harm as its never traversed again).
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        MsReferenceNode( ((PNODE_HEADER)(fsContext)) );
    }

    //
    // Get the VCB we are trying to access.
    //

    vcb = &MsfsDeviceObject->Vcb;

    //
    // Acquire exclusive access to the VCB.
    //

    MsAcquireExclusiveVcb( vcb );

    try {

        //
        // Decide how to handle this IRP.
        //

        switch (NodeType( fsContext ) ) {

        case MSFS_NTC_FCB:       // Cleanup a server handle to a mailslot file

            status = MsCleanupFcb( MsfsDeviceObject,
                                   Irp,
                                   (PFCB)fsContext);

            MsDereferenceFcb( (PFCB)fsContext );
            break;

        case MSFS_NTC_CCB:       // Cleanup a client handle to a mailslot file

            status = MsCleanupCcb( MsfsDeviceObject,
                                   Irp,
                                   (PCCB)fsContext);

            MsDereferenceCcb( (PCCB)fsContext );
            break;

        case MSFS_NTC_VCB:       // Cleanup MSFS

            status = MsCleanupVcb( MsfsDeviceObject,
                                   Irp,
                                   (PVCB)fsContext);

            MsDereferenceVcb( (PVCB)fsContext );
            break;

        case MSFS_NTC_ROOT_DCB:  // Cleanup root directory

            status = MsCleanupRootDcb( MsfsDeviceObject,
                                       Irp,
                                       (PROOT_DCB)fsContext,
                                       (PROOT_DCB_CCB)fsContext2);

            MsDereferenceRootDcb( (PROOT_DCB)fsContext );
            break;

    #ifdef MSDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheck( MAILSLOT_FILE_SYSTEM );
            break;
    #endif

        }


    } finally {

        MsReleaseVcb( vcb );

        status = STATUS_SUCCESS;
        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonCleanup -> %08lx\n", status);

    }

    DebugTrace(-1, Dbg, "MsCommonCleanup -> %08lx\n", status);
    return status;
}


NTSTATUS
MsCleanupCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb
    )

/*++

Routine Description:

    The routine cleans up a CCB.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    Ccb - Supplies the CCB for the mailslot to clean up.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS status;
    PFCB fcb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupCcb...\n", 0);

    //
    // Get a pointer to the FCB.
    //

    fcb = Ccb->Fcb;

    //
    // Acquire exclusive access to the FCB
    //

    MsAcquireExclusiveFcb( fcb );

    //
    // Set the CCB to closing and remove this CCB from the active list. This CCB may already be
    // closed if the FCB was closed first so don't check this. We still want the chain maintained.
    //

    Ccb->Header.NodeState = NodeStateClosing;
    RemoveEntryList( &Ccb->CcbLinks );          // Protected by the FCB lock since this is the FCB CCB chain

    MsReleaseFcb( fcb );

    //
    // Cleanup the share access.
    //

    ASSERT (MsIsAcquiredExclusiveVcb(fcb->Vcb));
    IoRemoveShareAccess( Ccb->FileObject, &fcb->ShareAccess );


    //
    // And return to our caller
    //

    status = STATUS_SUCCESS;
    return status;
}

VOID
MsCancelTimer (
    IN PDATA_ENTRY DataEntry
    )

/*++

Routine Description:

    The routine cancels the timer and if possible frees up a work block

Arguments:
    DataEntry - Block that needs to be checked for a timer

Return Value:

    None

--*/
{
    PWORK_CONTEXT WorkContext;
    //
    // There was a timer on this read operation.  Attempt
    // to cancel the operation.  If the cancel operation
    // is successful, then we must cleanup after the operation.
    // If it was unsuccessful the timer DPC will run, and
    // will eventually cleanup.
    //


    WorkContext = DataEntry->TimeoutWorkContext;
    if (WorkContext == NULL) {
       //
       // No timeout for this request, its already been canceled or its running
       //
       return;
    }

    //
    // Nobody else should touch this now. either this routine will free this memory or the
    // timer is running at it will free the memory.
    //
    DataEntry->TimeoutWorkContext = NULL;

    if (KeCancelTimer( &WorkContext->Timer ) ) {

        //
        // Release the reference to the FCB.
        //

        MsDereferenceFcb( WorkContext->Fcb );

        //
        // Free the memory from the work context, the time
        // and the DPC.
        //

        IoFreeWorkItem (WorkContext->WorkItem);
        ExFreePool( WorkContext );

    } else {
        //
        // Time code is active. Break the link between the timer block and the IRP
        //
        WorkContext->Irp = NULL;
    }
}



NTSTATUS
MsCleanupFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine cleans up an FCB.  All outstanding i/o on the file
    object are completed with an error status.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    Fcb - Supplies the FCB for the mailslot to clean up.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS status;
    PDATA_QUEUE dataQueue;
    PDATA_ENTRY dataEntry;
    PLIST_ENTRY listEntry;
    PIRP oldIrp;
    PCCB ccb;
    PWORK_CONTEXT workContext;
    PKTIMER timer;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupFcb, Fcb = %08lx\n", (ULONG)Fcb);


    status = STATUS_SUCCESS;

    //
    // Wipe out the name of the FCB from the prefix table and the parent DCB.
    //
    MsRemoveFcbName( Fcb );

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( Fcb );


    try {


        //
        // Complete all outstanding I/O on this FCB.
        //

        dataQueue = &Fcb->DataQueue;
        dataQueue->QueueState = -1;

        for (listEntry = MsGetNextDataQueueEntry( dataQueue );
             !MsIsDataQueueEmpty(dataQueue);
             listEntry = MsGetNextDataQueueEntry( dataQueue ) ) {

             //
             // This is an outstanding I/O request on this FCB.
             // Remove it from our queue and complete the request
             // if one is outstanding.
             //

             dataEntry = CONTAINING_RECORD( listEntry, DATA_ENTRY, ListEntry );


             oldIrp = MsRemoveDataQueueEntry( dataQueue, dataEntry );

             if (oldIrp != NULL) {

                 DebugTrace(0, Dbg, "Completing IRP %08lx\n", (ULONG)oldIrp );
                 MsCompleteRequest( oldIrp, STATUS_FILE_FORCED_CLOSED );

             }

        }

        //
        // Now cleanup all the CCB's on this FCB, to ensure that new
        // write IRP will not be processed.
        //


        listEntry = Fcb->Specific.Fcb.CcbQueue.Flink;

        while( listEntry != &Fcb->Specific.Fcb.CcbQueue ) {

            ccb = (PCCB)CONTAINING_RECORD( listEntry, CCB, CcbLinks );

            ccb->Header.NodeState = NodeStateClosing;

            //
            // Get the next CCB on this FCB.
            //

            listEntry = listEntry->Flink;
        }

        //
        // Cleanup the share access.
        //

        ASSERT (MsIsAcquiredExclusiveVcb(Fcb->Vcb));
        IoRemoveShareAccess( Fcb->FileObject, &Fcb->ShareAccess);

        //
        // Mark the FCB closing.
        //

        Fcb->Header.NodeState = NodeStateClosing;

   } finally {

        MsReleaseFcb( Fcb );
        DebugTrace(-1, Dbg, "MsCloseFcb -> %08lx\n", status);
    }

    //
    // Return to the caller.
    //

    return status;

}


NTSTATUS
MsCleanupRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb
    )

/*++

Routine Description:

    This routine cleans up a Root DCB.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    RootDcb - Supplies the root dcb for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupRootDcb...\n", 0);



    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Now acquire exclusive access to the Vcb.
    //

    MsAcquireExclusiveVcb( RootDcb->Vcb );

    //
    // clear any active notify requests
    //
    MsFlushNotifyForFile (RootDcb, irpSp->FileObject);

    //
    // Remove share access
    //
    IoRemoveShareAccess( irpSp->FileObject,
                         &RootDcb->ShareAccess );

    //
    // Mark the DCB CCB closing.
    //

    Ccb->Header.NodeState = NodeStateClosing;

    MsReleaseVcb( RootDcb->Vcb );

    DebugTrace(-1, Dbg, "MsCleanupRootDcb -> %08lx\n", status);

    //
    // Return to the caller.
    //

    return status;
}


NTSTATUS
MsCleanupVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    The routine cleans up a VCB.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    Vcb - Supplies the VCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupVcb...\n", 0);


    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Now acquire exclusive access to the Vcb
    //

    MsAcquireExclusiveVcb( Vcb );

    IoRemoveShareAccess( irpSp->FileObject,
                             &Vcb->ShareAccess );

    MsReleaseVcb( Vcb );

    DebugTrace(-1, Dbg, "MsCleanupVcb -> %08lx\n", status);

    //
    //  And return to our caller
    //

    return status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\debug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements the debugging function for the mailslot file
    system.

Author:

    Manny Weiser (mannyw)    17-Jan-1991

Revision History:

--*/

#include "mailslot.h"
#include "stdio.h"


#ifdef MSDBG

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _DebugTrace )
#endif

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    )

/*++

Routine Description:

    This routine display debugging information.

Arguments:

    Level - The debug level required to display this message.  If
        level is 0 the message is displayed regardless of the setting
        or the debug level

    Indent - Incremement or the current debug message indent

    X - 1st print parameter

    Y - 2nd print parameter

Return Value:

    None.

--*/

{
    LONG i;
    char printMask[100];

    PAGED_CODE();
    if ((Level == 0) || (MsDebugTraceLevel & Level)) {

        if (Indent < 0) {
            MsDebugTraceIndent += Indent;
        }

        if (MsDebugTraceIndent < 0) {
            MsDebugTraceIndent = 0;
        }

        sprintf( printMask, "%%08lx:%%.*s%s", X );

        i = (LONG)PsGetCurrentThread();
        DbgPrint( printMask, i, MsDebugTraceIndent, "", Y );
        if (Indent > 0) {
            MsDebugTraceIndent += Indent;
        }
    }
}
#endif // MSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\dpc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpc.c

Abstract:

    This modules contains the set of functions in the mailslot file
    system that are callable at DPC level.

Author:

    Manny Weiser (mannyw)    28-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DPC)

#if 0
NOT PAGEABLE -- MsReadTimeoutHandler
#endif

VOID
MsReadTimeoutHandler (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is handles read timeouts.  It is called as a DPC whenever
    a read timer expires.
    *** Non-Pageable ***

Arguments:

    Dpc - A pointer to the DPC object.

    DeferredContext - A pointer to the data queue entry associated with
                      this timer.

    SystemArgument1, SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PWORK_CONTEXT workContext;

    Dpc, SystemArgument1, SystemArgument2; // prevent warnings

    //
    // Enqueue this packet to an ex worker thread.
    //

    workContext = DeferredContext;

    IoQueueWorkItem (workContext->WorkItem, MsTimeoutRead, CriticalWorkQueue, workContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\dir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements the file directory routines for the mailslot
    file system by the dispatch driver.

Author:

    Manny Weiser (mannyw)     1-Feb-1991

Revision History:

--*/

#include "mailslot.h"

//
// Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIR)

NTSTATUS
MsCommonDirectoryControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

NTSTATUS
MsNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonDirectoryControl )
#pragma alloc_text( PAGE, MsFsdDirectoryControl )
#pragma alloc_text( PAGE, MsQueryDirectory )
#endif

NTSTATUS
MsFsdDirectoryControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the FSD routine that handles directory control
    functions (i.e., query and notify).

Arguments:

    MsfsDeviceObject - Supplies the device object for the directory function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdDirectoryControl\n", 0);

    //
    // Call the common direcotry control routine.
    //
    FsRtlEnterFileSystem();

    status = MsCommonDirectoryControl( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();
    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdDirectoryControl -> %08lx\n", status );

    return status;
}

VOID
MsFlushNotifyForFile (
    IN PDCB Dcb,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine checks the notify queues of a DCB and completes any
    outstanding IRPS that match the given file object. This is used at cleanup time.


Arguments:

    Dcb - Supplies the DCB to check for outstanding notify IRPs.

    FileObject - File object that IRP must be associated with.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Links;
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY Head;
    PIO_STACK_LOCATION IrpSp;
    LIST_ENTRY CompletionList;

    Head = &Dcb->Specific.Dcb.NotifyFullQueue;

    InitializeListHead (&CompletionList);

    KeAcquireSpinLock (&Dcb->Specific.Dcb.SpinLock, &OldIrql);

    Links = Head->Flink;
    while (1) {

        if (Links == Head) {
            //
            // We are at the end of this queue.
            //
            if (Head == &Dcb->Specific.Dcb.NotifyFullQueue) {
                Head = &Dcb->Specific.Dcb.NotifyPartialQueue;
                Links = Head->Flink;
                if (Links == Head) {
                   break;
                }
            } else {
               break;
            }
        }

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        // If this IRP is for the matching file object then remove and save for completion
        //
        if (IrpSp->FileObject == FileObject) {

            Links = Links->Flink;

            RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
            //
            // Remove cancel routine and detect if its already started running
            //
            if (IoSetCancelRoutine (Irp, NULL)) {
                //
                // Cancel isn't active and won't become active.
                //
                InsertTailList (&CompletionList, &Irp->Tail.Overlay.ListEntry);


            } else {
                //
                // Cancel is already active but is stalled before lock acquire. Initialize the
                // list head so the second remove is a noop. This is a rare case.
                //
                InitializeListHead (&Irp->Tail.Overlay.ListEntry);
            }
        } else {
            Links = Links->Flink;
        }

    }
    KeReleaseSpinLock (&Dcb->Specific.Dcb.SpinLock, OldIrql);

    while (!IsListEmpty (&CompletionList)) {

        Links = RemoveHeadList (&CompletionList);
        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );
        MsCompleteRequest( Irp, STATUS_CANCELLED );

    }

    return;
}


VOID
MsCheckForNotify (
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN NTSTATUS FinalStatus
    )

/*++

Routine Description:

    This routine checks the notify queues of a DCB and completes any
    outstanding IRPS.

    Note that the caller of this procedure must guarantee that the DCB
    is acquired for exclusive access.

Arguments:

    Dcb - Supplies the DCB to check for outstanding notify IRPs.

    CheckAllOutstandingIrps - Indicates if only the NotifyFullQueue should be
        checked.  If TRUE then all notify queues are checked, and if FALSE
        then only the NotifyFullQueue is checked.

Return Value:

    None.

--*/

{
    PLIST_ENTRY links;
    PIRP irp;
    KIRQL OldIrql;
    PLIST_ENTRY Head;

    //
    // We'll always signal the notify full queue entries.  They want
    // to be notified if every any change is made to a directory.
    //

    Head = &Dcb->Specific.Dcb.NotifyFullQueue;

    KeAcquireSpinLock (&Dcb->Specific.Dcb.SpinLock, &OldIrql);

    while (1) {

        links = RemoveHeadList (Head);
        if (links == Head) {
            //
            // This queue is empty. See if we need to skip to another.
            //
            if (Head == &Dcb->Specific.Dcb.NotifyFullQueue && CheckAllOutstandingIrps) {
                Head = &Dcb->Specific.Dcb.NotifyPartialQueue;
                links = RemoveHeadList (Head);
                if (links == Head) {
                   break;
                }
            } else {
               break;
            }
        }
        //
        // Remove the Irp from the head of the queue, and complete it
        // with a success status.
        //

        irp = CONTAINING_RECORD( links, IRP, Tail.Overlay.ListEntry );

        //
        // Remove cancel routine and detect if its already started running
        //
        if (IoSetCancelRoutine (irp, NULL)) {
            //
            // Cancel isn't active and won't become active. Release the spinlock for the complete.
            //
            KeReleaseSpinLock (&Dcb->Specific.Dcb.SpinLock, OldIrql);

            MsCompleteRequest( irp, FinalStatus );

            KeAcquireSpinLock (&Dcb->Specific.Dcb.SpinLock, &OldIrql);
        } else {
            //
            // Cancel is already active but is stalled before lock acquire. Initialize the
            // list head so the second remove is a noop. This is a rare case.
            //
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
        }
    }
    KeReleaseSpinLock (&Dcb->Specific.Dcb.SpinLock, OldIrql);

    return;
}


NTSTATUS
MsCommonDirectoryControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the common code for directory control functions.

Arguments:

    MsfsDeviceObject - Supplies the mailslot device object.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PROOT_DCB_CCB ccb;
    PROOT_DCB rootDcb;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "CommonDirectoryControl...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG)Irp);

    //
    // Decode the file object to figure out who we are.  If the result
    // is not the root DCB then its an illegal parameter.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&rootDcb,
                                            (PVOID *)&ccb )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status );
        return status;
    }

    if (nodeTypeCode != MSFS_NTC_ROOT_DCB) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);
        MsDereferenceNode( &rootDcb->Header );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the root DCB.
    //

    MsAcquireExclusiveFcb( (PFCB)rootDcb );

    //
    // Check if its been cleaned up yet.
    //
    status = MsVerifyDcbCcb (ccb);

    if (NT_SUCCESS (status)) {
        //
        // We know this is a directory control so we'll case on the
        // minor function, and call the appropriate work routines.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DIRECTORY:

            status = MsQueryDirectory( rootDcb, ccb, Irp );
            break;

        case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

            status = MsNotifyChangeDirectory( rootDcb, ccb, Irp );
            break;

        default:

            //
            // For all other minor function codes we say they're invalid
            // and complete the request.
            //

            DebugTrace(0, DEBUG_TRACE_ERROR, "Invalid FS Control Minor Function Code %08lx\n", irpSp->MinorFunction);

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }


    MsReleaseFcb( (PFCB)rootDcb );

    MsDereferenceRootDcb( rootDcb );

    if (status != STATUS_PENDING) {
        MsCompleteRequest( Irp, status );
    }

    return status;
}


NTSTATUS
MsQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the work routine for querying a directory.

Arugments:

    RootDcb - Supplies the dcb being queried

    Ccb - Supplies the context of the caller

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PUCHAR buffer;
    CLONG systemBufferLength;
    UNICODE_STRING fileName;
    ULONG fileIndex;
    FILE_INFORMATION_CLASS fileInformationClass;
    BOOLEAN restartScan;
    BOOLEAN returnSingleEntry;
    BOOLEAN indexSpecified;

#if 0
    UNICODE_STRING unicodeString;
    ULONG unicodeStringLength;
#endif
    BOOLEAN ansiStringAllocated = FALSE;

    static WCHAR star = L'*';

    BOOLEAN caseInsensitive = TRUE; //*** Make searches case insensitive

    ULONG currentIndex;

    ULONG lastEntry;
    ULONG nextEntry;

    PLIST_ENTRY links;
    PFCB fcb;

    PFILE_DIRECTORY_INFORMATION dirInfo;
    PFILE_NAMES_INFORMATION namesInfo;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsQueryDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb              = %08lx\n", (ULONG)RootDcb);
    DebugTrace( 0, Dbg, "Ccb                  = %08lx\n", (ULONG)Ccb);
    DebugTrace( 0, Dbg, "SystemBuffer         = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);
    DebugTrace( 0, Dbg, "Length               = %08lx\n", irpSp->Parameters.QueryDirectory.Length);
    DebugTrace( 0, Dbg, "FileName             = %08lx\n", (ULONG)irpSp->Parameters.QueryDirectory.FileName);
    DebugTrace( 0, Dbg, "FileIndex            = %08lx\n", irpSp->Parameters.QueryDirectory.FileIndex);
    DebugTrace( 0, Dbg, "FileInformationClass = %08lx\n", irpSp->Parameters.QueryDirectory.FileInformationClass);
    DebugTrace( 0, Dbg, "RestartScan          = %08lx\n", FlagOn(irpSp->Flags, SL_RESTART_SCAN));
    DebugTrace( 0, Dbg, "ReturnSingleEntry    = %08lx\n", FlagOn(irpSp->Flags, SL_RETURN_SINGLE_ENTRY));
    DebugTrace( 0, Dbg, "IndexSpecified       = %08lx\n", FlagOn(irpSp->Flags, SL_INDEX_SPECIFIED));

    //
    // Make local copies of the input parameters.
    //

    systemBufferLength = irpSp->Parameters.QueryDirectory.Length;

    fileIndex = irpSp->Parameters.QueryDirectory.FileIndex;
    fileInformationClass =
            irpSp->Parameters.QueryDirectory.FileInformationClass;

    restartScan = FlagOn(irpSp->Flags, SL_RESTART_SCAN);
    indexSpecified = FlagOn(irpSp->Flags, SL_INDEX_SPECIFIED);
    returnSingleEntry = FlagOn(irpSp->Flags, SL_RETURN_SINGLE_ENTRY);

    if (irpSp->Parameters.QueryDirectory.FileName != NULL) {

        fileName = *(irpSp->Parameters.QueryDirectory.FileName);

        //
        // Ensure that the name is reasonable
        //
        if( (fileName.Buffer == NULL && fileName.Length) ||
            FlagOn( fileName.Length, 1 ) ) {

            status = STATUS_OBJECT_NAME_INVALID;
            return status;
        }

    } else {

        fileName.Length = 0;
        fileName.Buffer = NULL;

    }

    //
    // Check if the CCB already has a query template attached.  If it
    // does not already have one then we either use the string we are
    // given or we attach our own containing "*"
    //

    if (Ccb->QueryTemplate == NULL) {

        //
        // This is our first time calling query directory so we need
        // to either set the query template to the user specified string
        // or to "*".
        //

        if (fileName.Buffer == NULL) {

            DebugTrace(0, Dbg, "Set template to *\n", 0);

            fileName.Length = sizeof( WCHAR );
            fileName.Buffer = &star;
        }

        DebugTrace(0, Dbg, "Set query template -> %wZ\n", (ULONG)&fileName);

        //
        // Allocate space for the query template.
        //

        Ccb->QueryTemplate = MsAllocatePagedPoolWithQuota ( sizeof(UNICODE_STRING) + fileName.Length,
                                                            'tFsM' );

        if (Ccb->QueryTemplate == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            return status;
        }

        //
        // Initialize the query template and copy over the string.
        //

        Ccb->QueryTemplate->Length = fileName.Length;
        Ccb->QueryTemplate->Buffer = (PWCH)((PSZ)Ccb->QueryTemplate + sizeof(UNICODE_STRING));

        RtlCopyMemory (Ccb->QueryTemplate->Buffer,
                       fileName.Buffer,
                       fileName.Length);


        //
        // Set the search to start at the beginning of the directory.
        //

        fileIndex = 0;

    } else {

        //
        // Check if we were given an index to start with or if we need to
        // restart the scan or if we should use the index that was saved in
        // the CCB.
        //

        if (restartScan) {

            fileIndex = 0;

        } else if (!indexSpecified) {

            fileIndex = Ccb->IndexOfLastCcbReturned + 1;
        }

    }


    //
    //  Now we are committed to completing the Irp, we do that in
    //  the finally clause of the following try.
    //

    try {

        ULONG baseLength;
        ULONG lengthAdded;
        BOOLEAN Match;

        //
        // Map the user buffer.
        //

        MsMapUserBuffer( Irp, KernelMode, (PVOID *)&buffer );

        //
        //  At this point we are about to enter our query loop.  We have
        //  already decided which Fcb index we need to return.  The variables
        //  LastEntry and NextEntry are used to index into the user buffer.
        //  LastEntry is the last entry we added to the user buffer, and
        //  NextEntry is the current one we're working on.  CurrentIndex
        //  is the Fcb index that we are looking at next.  Logically the
        //  way the loop works is as follows.
        //
        //  Scan all of the Fcb in the directory
        //
        //      if the Fcb matches the query template then
        //
        //          if the CurrentIndex is >= the FileIndex then
        //
        //              process this fcb, and decide if we should
        //              continue the main loop
        //
        //          end if
        //
        //          Increment the current index
        //
        //      end if
        //
        //  end scan
        //

        currentIndex = 0;

        lastEntry = 0;
        nextEntry =0;

        switch (fileInformationClass) {

        case FileDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                       FileName[0] );
            break;

        case FileFullDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileNamesInformation:

            baseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                       FileName[0] );
            break;

        case FileBothDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                       FileName[0] );
            break;

        default:

            try_return( status = STATUS_INVALID_INFO_CLASS );
        }

        for (links = RootDcb->Specific.Dcb.ParentDcbQueue.Flink;
             links != &RootDcb->Specific.Dcb.ParentDcbQueue;
             links = links->Flink) {

            fcb = CONTAINING_RECORD(links, FCB, ParentDcbLinks);

            ASSERT(fcb->Header.NodeTypeCode == MSFS_NTC_FCB);

            DebugTrace(0, Dbg, "Top of Loop\n", 0);
            DebugTrace(0, Dbg, "Fcb          = %08lx\n", (ULONG)fcb);
            DebugTrace(0, Dbg, "CurrentIndex = %08lx\n", currentIndex);
            DebugTrace(0, Dbg, "FileIndex    = %08lx\n", fileIndex);
            DebugTrace(0, Dbg, "LastEntry    = %08lx\n", lastEntry);
            DebugTrace(0, Dbg, "NextEntry    = %08lx\n", nextEntry);

            //
            // Check if the Fcb represents a mailslot that is part of
            // our query template.
            //
            try {
                Match = FsRtlIsNameInExpression( Ccb->QueryTemplate,
                                                 &fcb->LastFileName,
                                                 caseInsensitive,
                                                 NULL );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                try_return (status = GetExceptionCode ());
            }

            if (Match) {

                //
                // The FCB is in the query template so now check if
                // this is the index we should start returning.
                //

                if (currentIndex >= fileIndex) {

                    //
                    // Yes it is one to return so case on the requested
                    // information class.
                    //

                    ULONG bytesToCopy;
                    ULONG bytesRemainingInBuffer;

                    //
                    //  Here are the rules concerning filling up the buffer:
                    //
                    //  1.  The Io system garentees that there will always be
                    //      enough room for at least one base record.
                    //
                    //  2.  If the full first record (including file name) cannot
                    //      fit, as much of the name as possible is copied and
                    //      STATUS_BUFFER_OVERFLOW is returned.
                    //
                    //  3.  If a subsequent record cannot completely fit into the
                    //      buffer, none of it (as in 0 bytes) is copied, and
                    //      STATUS_SUCCESS is returned.  A subsequent query will
                    //      pick up with this record.
                    //

                    bytesRemainingInBuffer = systemBufferLength - nextEntry;

                    if ( (nextEntry != 0) &&
                         ( (baseLength + fcb->LastFileName.Length >
                            bytesRemainingInBuffer) ||
                           (systemBufferLength < nextEntry) ) ) {

                        DebugTrace(0, Dbg, "Next entry won't fit\n", 0);

                        try_return( status = STATUS_SUCCESS );
                    }

                    ASSERT( bytesRemainingInBuffer >= baseLength );

                    //
                    //  See how much of the name we will be able to copy into
                    //  the system buffer.  This also dictates out return
                    //  value.
                    //

                    if ( baseLength + fcb->LastFileName.Length <=
                         bytesRemainingInBuffer ) {

                        bytesToCopy = fcb->LastFileName.Length;
                        status = STATUS_SUCCESS;

                    } else {

                        bytesToCopy = bytesRemainingInBuffer - baseLength;
                        status = STATUS_BUFFER_OVERFLOW;
                    }

                    //
                    //  Note how much of buffer we are consuming and zero
                    //  the base part of the structure.
                    //

                    lengthAdded = baseLength + bytesToCopy;

                    try {

                        RtlZeroMemory( &buffer[nextEntry], baseLength );


                        switch (fileInformationClass) {

                        case FileBothDirectoryInformation:

                            //
                            //  We don't need short name
                            //

                            DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                        case FileFullDirectoryInformation:

                            //
                            //  We don't use EaLength, so fill in nothing here.
                            //

                            DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                        case FileDirectoryInformation:

                            DebugTrace(0, Dbg, "Getting directory information\n", 0);

                            //
                            //  The eof indicates the number of instances and
                            //  allocation size is the maximum allowed
                            //

                            dirInfo = (PFILE_DIRECTORY_INFORMATION)&buffer[nextEntry];

                            dirInfo->FileAttributes = FILE_ATTRIBUTE_NORMAL;

                            dirInfo->CreationTime = fcb->Specific.Fcb.CreationTime;
                            dirInfo->LastAccessTime = fcb->Specific.Fcb.LastAccessTime;
                            dirInfo->LastWriteTime = fcb->Specific.Fcb.LastModificationTime;
                            dirInfo->ChangeTime = fcb->Specific.Fcb.LastChangeTime;

                            dirInfo->FileNameLength = fcb->LastFileName.Length;

                            break;

                        case FileNamesInformation:

                            DebugTrace(0, Dbg, "Getting names information\n", 0);


                            namesInfo = (PFILE_NAMES_INFORMATION)&buffer[nextEntry];

                            namesInfo->FileNameLength = fcb->LastFileName.Length;

                            break;

                        default:

                            KeBugCheck( MAILSLOT_FILE_SYSTEM );
                        }

                        RtlCopyMemory (&buffer[nextEntry + baseLength],
                                       fcb->LastFileName.Buffer,
                                       bytesToCopy);

                        //
                        //  Update the CCB to the index we've just used.
                        //

                        Ccb->IndexOfLastCcbReturned = currentIndex;

                        //
                        //  And indicate how much of the system buffer we have
                        //  currently used up.  We must compute this value before
                        //  we long align outselves for the next entry.
                        //

                        Irp->IoStatus.Information = nextEntry + lengthAdded;

                        //
                        //  Setup the previous next entry offset.
                        //

                        *((PULONG)(&buffer[lastEntry])) = nextEntry - lastEntry;

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        status = GetExceptionCode();
                        try_return( status );
                    }

                    //
                    //  Check if the last entry didn't completely fit
                    //

                    if ( status == STATUS_BUFFER_OVERFLOW ) {

                        try_return( NOTHING );
                    }

                    //
                    //  Check if we are only to return a single entry
                    //

                    if (returnSingleEntry) {

                        try_return( status = STATUS_SUCCESS );
                    }

                    //
                    //  Set ourselves up for the next iteration
                    //

                    lastEntry = nextEntry;
                    nextEntry += (ULONG)QuadAlign( lengthAdded );
                }

                //
                //  Increment the current index by one
                //

                currentIndex += 1;
            }
        }

        //
        // At this point we've scanned the entire list of FCBs so if
        // the NextEntry is zero then we haven't found anything so we
        // will return no more files, otherwise we return success.
        //

        if (nextEntry == 0) {
            status = STATUS_NO_MORE_FILES;
        } else {
            status = STATUS_SUCCESS;
        }

    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "MsQueryDirectory -> %08lx\n", status);
    }

    return status;
}

VOID
MsNotifyChangeDirectoryCancel (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the cancel routine for the directory notify request.

Arugments:

    DeviceObject - Supplies the device object for the request being canceled.

    Irp - Supplies the Irp being canceled.

Return Value:

    None
--*/

{
    KIRQL OldIrql;
    PKSPIN_LOCK pSpinLock;

    //
    // First drop the cancel spinlock. We don't use this for this path
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    //
    // Grab the spinlock address. Easier that tracing the pointers or assuming that there is
    // only one DCB
    //
    pSpinLock = Irp->Tail.Overlay.DriverContext[0];
    //
    // Acquire the spinlock protecting these queues.
    //
    KeAcquireSpinLock (pSpinLock, &OldIrql);

    //
    // Remove the entry from the list. We will always be in one of the lists or this entry has
    // been initializes as an empty list by one of the completion routines when it detected
    // this routine was active.
    //
    RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock (pSpinLock, OldIrql);

    //
    // Complete the IRP
    //
    MsCompleteRequest( Irp, STATUS_CANCELLED );

    return;
}


NTSTATUS
MsNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing the notify change directory.

Arugments:

    RootDcb - Supplies the DCB being queried.

    Ccb - Supplies the context of the caller.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - STATUS_PENDING or STATUS_CANCELLED

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS  Status;
    KIRQL OldIrql;
    PLIST_ENTRY Head;

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsNotifyChangeDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb = %p", RootDcb);
    DebugTrace( 0, Dbg, "Ccb     = %p", Ccb);

    //
    //  Mark the Irp pending.
    //

    if (irpSp->Parameters.NotifyDirectory.CompletionFilter & (~FILE_NOTIFY_CHANGE_NAME)) {
        Head = &RootDcb->Specific.Dcb.NotifyFullQueue;
    } else {
        Head = &RootDcb->Specific.Dcb.NotifyPartialQueue;
    }
    //
    // Make it easy for the cancel routine to find this spinlock
    //
    Irp->Tail.Overlay.DriverContext[0] = &RootDcb->Specific.Dcb.SpinLock;
    //
    // Acquire the spinlock protecting these queues.
    //
    KeAcquireSpinLock (&RootDcb->Specific.Dcb.SpinLock, &OldIrql);
    IoSetCancelRoutine (Irp, MsNotifyChangeDirectoryCancel);
    //
    // See if the IRP was already canceled before we enabled cancelation
    //
    if (Irp->Cancel &&
        IoSetCancelRoutine (Irp, NULL) != NULL) {

       KeReleaseSpinLock (&RootDcb->Specific.Dcb.SpinLock, OldIrql);
       Status = STATUS_CANCELLED;

    } else {

       IoMarkIrpPending( Irp );
       InsertTailList( Head,
                       &Irp->Tail.Overlay.ListEntry );
       KeReleaseSpinLock (&RootDcb->Specific.Dcb.SpinLock, OldIrql);
       Status = STATUS_PENDING;

    }

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "NotifyChangeDirectory status %X\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\createms.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    createms.c

Abstract:

    This module implements the file create mailslot routine for MSFS called
    by the dispatch driver.

Author:

    Manny Weiser (mannyw)    17-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE_MAILSLOT)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonCreateMailslot (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

IO_STATUS_BLOCK
MsCreateMailslot (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN ULONG MailslotQuota,
    IN ULONG MaximumMessageSize,
    IN LARGE_INTEGER ReadTimeout,
    IN PEPROCESS CreatorProcess,
    IN PACCESS_STATE AccessState
    );

BOOLEAN
MsIsNameValid (
    PUNICODE_STRING Name
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonCreateMailslot )
#pragma alloc_text( PAGE, MsCreateMailslot )
#pragma alloc_text( PAGE, MsFsdCreateMailslot )
#pragma alloc_text( PAGE, MsIsNameValid )
#endif



NTSTATUS
MsFsdCreateMailslot (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateMailslotFile
    API call.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdCreateMailslot\n", 0);

    //
    //  Call the common create routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonCreateMailslot( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdCreateMailslot -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonCreateMailslot (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating a mailslot.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PFILE_OBJECT fileObject;
    PFILE_OBJECT relatedFileObject;
    UNICODE_STRING fileName;
    ACCESS_MASK desiredAccess;
    ULONG options;
    USHORT shareAccess;
    PMAILSLOT_CREATE_PARAMETERS parameters;
    ULONG mailslotQuota;
    ULONG maximumMessageSize;
    PEPROCESS creatorProcess;
    LARGE_INTEGER readTimeout;

    BOOLEAN caseInsensitive = TRUE; //**** Make all searches case insensitive

    PVCB vcb;
    PFCB fcb;

    ULONG createDisposition;
    UNICODE_STRING remainingPart;

    PAGED_CODE();

    //
    // Make local copies of the input parameters to make things easier.
    //

    irpSp                = IoGetCurrentIrpStackLocation( Irp );
    fileObject           = irpSp->FileObject;
    relatedFileObject    = irpSp->FileObject->RelatedFileObject;
    fileName             = *(PUNICODE_STRING)&irpSp->FileObject->FileName;
    desiredAccess        = irpSp->Parameters.CreateMailslot.SecurityContext->DesiredAccess;
    options              = irpSp->Parameters.CreateMailslot.Options;
    shareAccess          = irpSp->Parameters.CreateMailslot.ShareAccess;
    parameters           = irpSp->Parameters.CreateMailslot.Parameters;
    mailslotQuota        = parameters->MailslotQuota;
    maximumMessageSize   = parameters->MaximumMessageSize;

    if (parameters->TimeoutSpecified) {
        readTimeout = parameters->ReadTimeout;
    } else {
        readTimeout.QuadPart = -1;
    }

    creatorProcess       = IoGetRequestorProcess( Irp );

    DebugTrace(+1, Dbg, "MsCommonCreateMailslot\n", 0 );
    DebugTrace( 0, Dbg, "MsfsDeviceObject     = %08lx\n", (ULONG)MsfsDeviceObject );
    DebugTrace( 0, Dbg, "Irp                  = %08lx\n", (ULONG)Irp );
    DebugTrace( 0, Dbg, "FileObject           = %08lx\n", (ULONG)fileObject );
    DebugTrace( 0, Dbg, "RelatedFileObject    = %08lx\n", (ULONG)relatedFileObject );
    DebugTrace( 0, Dbg, "FileName             = %wZ\n",   (ULONG)&fileName );
    DebugTrace( 0, Dbg, "DesiredAccess        = %08lx\n", desiredAccess );
    DebugTrace( 0, Dbg, "Options              = %08lx\n", options );
    DebugTrace( 0, Dbg, "ShareAccess          = %08lx\n", shareAccess );
    DebugTrace( 0, Dbg, "Parameters           = %08lx\n", (ULONG)parameters );
    DebugTrace( 0, Dbg, "MailslotQuota        = %08lx\n", mailslotQuota );
    DebugTrace( 0, Dbg, "MaximumMesssageSize  = %08lx\n", maximumMessageSize );
    DebugTrace( 0, Dbg, "CreatorProcess       = %08lx\n", (ULONG)creatorProcess );

    //
    // Get the VCB we are trying to access and extract the
    // create disposition.
    //

    vcb = &MsfsDeviceObject->Vcb;
    createDisposition = (options >> 24) & 0x000000ff;

    //
    // Acquire exclusive access to the VCB.
    //

    MsAcquireExclusiveVcb( vcb );

    try {

        //
        // If there is a related file object then this is a relative open
        // and it better be the root DCB.  Both the then and the else clause
        // return an FCB.
        //

        if (relatedFileObject != NULL) {

            PDCB dcb;

            dcb = relatedFileObject->FsContext;

            if (NodeType(dcb) != MSFS_NTC_ROOT_DCB ||
                fileName.Length < sizeof( WCHAR ) || fileName.Buffer[0] == L'\\') {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            status = MsFindRelativePrefix( dcb,
                                           &fileName,
                                           caseInsensitive,
                                           &remainingPart,
                                           &fcb );
            if (!NT_SUCCESS (status)) {
                try_return( NOTHING );
            }

        } else {

            //
            // The only nonrelative name we allow are of the form
            // "\mailslot-name".
            //

            if ((fileName.Length <= sizeof( WCHAR )) || (fileName.Buffer[0] != L'\\')) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            fcb = MsFindPrefix(
                    vcb,
                    &fileName,
                    caseInsensitive,
                    &remainingPart
                    );

        }

        //
        // If the remaining name is empty then we better have an FCB
        // otherwise we were given a illegal object name.
        //

        if (remainingPart.Length == 0) {

            if (fcb->Header.NodeTypeCode == MSFS_NTC_FCB) {

                DebugTrace(0,
                           Dbg,
                           "Attempt to create an existing mailslot, "
                               "Fcb = %08lx\n",
                           (ULONG)fcb );

                status = STATUS_OBJECT_NAME_COLLISION;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            }

        } else {

            //
            // The remaining name is not empty so we better have the root DCB
            // and then have a valid object path.
            //

            if ( fcb->Header.NodeTypeCode == MSFS_NTC_ROOT_DCB  &&
                 MsIsNameValid( &remainingPart ) ) {

                DebugTrace(0,
                           Dbg,
                           "Create new mailslot, Fcb = %08lx\n",
                           (ULONG)fcb );

                Irp->IoStatus = MsCreateMailslot(
                                    fcb,
                                    fileObject,
                                    fileName,
                                    desiredAccess,
                                    createDisposition,
                                    shareAccess,
                                    mailslotQuota,
                                    maximumMessageSize,
                                    readTimeout,
                                    creatorProcess,
                                    irpSp->Parameters.CreateMailslot.SecurityContext->AccessState
                                    );

                status = Irp->IoStatus.Status;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            }
        }


    try_exit: NOTHING;
    } finally {

        MsReleaseVcb( vcb );

        //
        // Complete the IRP and return to the caller.
        //

        MsCompleteRequest( Irp, status );
    }

    DebugTrace(-1, Dbg, "MsCommonCreateMailslot -> %08lx\n", status);
    return status;
}


IO_STATUS_BLOCK
MsCreateMailslot (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN ULONG MailslotQuota,
    IN ULONG MaximumMessageSize,
    IN LARGE_INTEGER ReadTimeout,
    IN PEPROCESS CreatorProcess,
    IN PACCESS_STATE AccessState
    )

/*++

Routine Description:

    This routine performs the operation for creating a new mailslot
    Fcb.  This routine does not complete any IRP, it preforms its
    function and then returns an iosb.

Arguments:

    RootDcb - Supplies the root dcb where this is going to be added.

    FileObject - Supplies the file object associated with the mailslot.

    FileName - Supplies the name of the mailslot (not qualified i.e.,
        simply "mailslot-name" and not "\mailslot-name".

    DesiredAccess - Supplies the caller's desired access.

    CreateDisposition - Supplies the caller's create disposition flags.

    ShareAccess - Supplies the caller specified share access.

    MailslotQuota - Supplies the mailslot quota amount.

    MaximumMessageSize - Supplies the size of the largest message that
        can be written to this mailslot.

    CreatorProcess - Supplies the process creating the mailslot.

Return Value:

    IO_STATUS_BLOCK - Returns the status of the operation.

--*/

{

    IO_STATUS_BLOCK iosb={0};
    PFCB fcb;
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateMailslot\n", 0 );

    //
    //  Check the parameters that must be supplied for a mailslot
    //

    if (CreateDisposition == FILE_OPEN) {
        iosb.Status = STATUS_OBJECT_NAME_NOT_FOUND;
        return iosb;
    }

    //
    // Create a new FCB for the mailslot.
    //
    status = MsCreateFcb( RootDcb->Vcb,
                          RootDcb,
                          &FileName,
                          CreatorProcess,
                          MailslotQuota,
                          MaximumMessageSize,
                          &fcb );

    if (!NT_SUCCESS (status)) {
        iosb.Status = status;
        return iosb;
    }

    fcb->Specific.Fcb.ReadTimeout = ReadTimeout;

    //
    //  Set the security descriptor in the Fcb
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    status = SeAssignSecurity( NULL,
                               AccessState->SecurityDescriptor,
                               &fcb->SecurityDescriptor,
                               FALSE,
                               &AccessState->SubjectSecurityContext,
                               IoGetFileObjectGenericMapping(),
                               PagedPool );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    if (!NT_SUCCESS(status)) {

        DebugTrace(0, Dbg, "Error calling SeAssignSecurity\n", 0 );

        MsRemoveFcbName( fcb );
        MsDereferenceFcb( fcb );
        iosb.Status = status;
        return iosb;
    }

    //
    // Set the new share access.
    //
    ASSERT (MsIsAcquiredExclusiveVcb(fcb->Vcb));
    IoSetShareAccess( DesiredAccess,
                      ShareAccess,
                      FileObject,
                      &fcb->ShareAccess );

    //
    // Set the file object back pointers and our pointer to the
    // server file object.
    //

    MsSetFileObject( FileObject, fcb, NULL );

    fcb->FileObject = FileObject;

    //
    // Update the FCB timestamps.
    //

    KeQuerySystemTime( &fcb->Specific.Fcb.CreationTime );
    fcb->Specific.Fcb.LastModificationTime = fcb->Specific.Fcb.CreationTime;
    fcb->Specific.Fcb.LastAccessTime = fcb->Specific.Fcb.CreationTime;
    fcb->Specific.Fcb.LastChangeTime = fcb->Specific.Fcb.CreationTime;

    //
    // Set the return status.
    //

    iosb.Status = STATUS_SUCCESS;
    iosb.Information = FILE_CREATED;

    //
    // The root directory has changed.  Complete any notify change
    // directory requests.
    //

    MsCheckForNotify( fcb->ParentDcb, TRUE, STATUS_SUCCESS );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateMailslot -> %08lx\n", iosb.Status);
    return iosb;
}

BOOLEAN
MsIsNameValid (
    PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine tests for illegal characters in a name.  The same character
    set as Npfs/Ntfs is used.  Also preceding backslashes, wildcards, and
    path names are not allowed.

Arguments:

    Name - The name to search for illegal characters

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    ULONG i;
    WCHAR Char = L'\\';

    PAGED_CODE();
    for (i=0; i < Name->Length / sizeof(WCHAR); i += 1) {

        Char = Name->Buffer[i];

        if ( (Char <= 0xff) && (Char != L'\\') &&
             !FsRtlIsAnsiCharacterLegalNtfs(Char, FALSE) ) {

            return FALSE;
        }
    }

    //
    // If the last char of the name was slash, we have an illegal name
    //
    return (Char != L'\\');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements the file close routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    18-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonClose (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsCloseVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MsCloseRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MsCloseCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MsCloseFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCloseCcb )
#pragma alloc_text( PAGE, MsCloseFcb )
#pragma alloc_text( PAGE, MsCloseRootDcb )
#pragma alloc_text( PAGE, MsCloseVcb )
#pragma alloc_text( PAGE, MsCommonClose )
#pragma alloc_text( PAGE, MsFsdClose )
#endif

NTSTATUS
MsFsdClose (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCloseFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdClose\n", 0);

    //
    // Call the common close routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonClose( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "MsFsdClose -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonClose (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for closing a file.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID fsContext, fsContext2;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonClose...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);

    //
    // Decode the file object to figure out who we are.
    //

    if (MsDecodeFileObject( irpSp->FileObject,
                            &fsContext,
                            &fsContext2 ) == NTC_UNDEFINED) {
        //
        // FCB and CCB nodes got marked inactive on cleanup. Reference them manualy.
        //
        MsReferenceNode( ((PNODE_HEADER)(fsContext)) );
    }


    //
    // Ignore the return code from MsDecode.  Parse the fsContext
    // to decide how to process the close IRP.
    //

    switch ( NodeType( fsContext ) ) {

    case MSFS_NTC_VCB:

        status = MsCloseVcb( MsfsDeviceObject,
                             Irp,
                             (PVCB)fsContext,
                             irpSp->FileObject );

        //
        // Release the reference to the VCB obtained from MsDecodeFileObject.
        //

        MsDereferenceVcb( (PVCB)fsContext );
        break;

    case MSFS_NTC_ROOT_DCB:

        status = MsCloseRootDcb( MsfsDeviceObject,
                                 Irp,
                                 (PROOT_DCB)fsContext,
                                 (PROOT_DCB_CCB)fsContext2,
                                 irpSp->FileObject );
        //
        // Release the reference to the root DCB obtained from
        // MsDecodeFileObject.
        //

        MsDereferenceRootDcb( (PROOT_DCB)fsContext );
        break;

    case MSFS_NTC_FCB:

        status = MsCloseFcb( MsfsDeviceObject,
                             Irp,
                             (PFCB)fsContext,
                             irpSp->FileObject );
        //
        // Release the reference to the FCB obtained from MsDecodeFileObject.
        //

        MsDereferenceFcb( (PFCB)fsContext );
        break;

    case MSFS_NTC_CCB:

        status = MsCloseCcb( MsfsDeviceObject,
                             Irp,
                             (PCCB)fsContext,
                             irpSp->FileObject );
        //
        // Release the reference to the CCB obtained from MsDecodeFileObject.
        //

        MsDereferenceCcb( (PCCB)fsContext );
        break;

#ifdef MSDBG
    default:

        //
        // This is not one of ours.
        //

        KeBugCheck( MAILSLOT_FILE_SYSTEM );
        break;
#endif

    }


    //
    // Complete the close IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsCommonClose -> %08lx\n", status);
    return status;
}


NTSTATUS
MsCloseVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine closes the a file object that had opened the file system.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the IRP associate with the close.  This procedure
        completes the IRP.

    Vcb - Supplies the VCB for the mailslot file system.

    FileObject - Supplies the file object being closed.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseVcb, Vcb = %08lx\n", (ULONG)Vcb);


    //
    // Clear the referenced pointer to the VCB in the file object
    // and derefence the VCB.
    //

    ASSERT ( FileObject->FsContext == Vcb );

    MsSetFileObject( FileObject, NULL, NULL );
    MsDereferenceVcb( Vcb );

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MsCloseRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine closes a file object that had opened the root directory

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp associated with the close.  This procedure
        completes the Irp.

    RootDcb - Supplies the RootDcb for the mailslot file system.

    Ccb - Supplies the ccb.

    FileObject - Supplies the file object being closed

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseRootDcb, RootDcb = %08lx\n", (ULONG)RootDcb);


    //
    // Clear the file object pointers.
    //

    MsSetFileObject( FileObject, NULL, NULL );

    //
    // Drop the reference to the root DCB CCB. It should be deleted at this point.
    //

    MsDereferenceCcb( (PCCB)Ccb );

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MsCloseCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine closes a file object belonging the the client side of
    a mailslot file.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp associated with the close,  The irp either
        get completed here or is enqueued in the data queue to be completed
        later.

    Ccb - Supplies the ccb for the mailslot being closed.

    FileObject - Supplies the caller file object that is being closed.

Return Value:

    NTSTATUS - An appropriate completion status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseCcb...\n", 0);

    status = STATUS_SUCCESS;

    //
    // Clear the file object pointers and delete the open
    // reference to the CCB.
    //

    MsSetFileObject( FileObject, NULL, NULL );
    MsDereferenceCcb( Ccb ); // Close the Ccb


    return status;

}


NTSTATUS
MsCloseFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine closes a server side file object that opened a mailslot.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp associated with the close,  The irp either
        get completed here or is enqueued in the data queue to be completed
        later

    Ccb - Supplies the ccb for the mailslot being closed

    FileObject - Supplies the caller file object that is being closed

Return Value:

    NTSTATUS - An appropriate completion status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseCcb...\n", 0);

    status = STATUS_SUCCESS;

    //
    // The root directory has changed, complete any notify requests.
    //

    MsCheckForNotify( Fcb->ParentDcb, TRUE, STATUS_SUCCESS );

    //
    //  Clear the FsContext pointer in the file object.  This
    //  indicates that the file is in the closing state.  Finally
    //  delete the open reference to the FCB.
    //

    MsSetFileObject( FileObject, NULL, NULL );
    MsDereferenceFcb( Fcb ); // Close the Fcb


    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements the file create routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    16-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
// Local procedure prototypes
//

NTSTATUS
MsCommonCreate (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

IO_STATUS_BLOCK
MsCreateClientEnd(
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread
    );

IO_STATUS_BLOCK
MsOpenMailslotFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

IO_STATUS_BLOCK
MsOpenMailslotRootDirectory (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonCreate )
#pragma alloc_text( PAGE, MsCreateClientEnd )
#pragma alloc_text( PAGE, MsFsdCreate )
#pragma alloc_text( PAGE, MsOpenMailslotFileSystem )
#pragma alloc_text( PAGE, MsOpenMailslotRootDirectory )
#endif



NTSTATUS
MsFsdCreate (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the IRP.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdCreate\n", 0);

    //
    // Call the common create routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonCreate( MsfsDeviceObject, Irp );


    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdCreate -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonCreate (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PFILE_OBJECT fileObject;
    PFILE_OBJECT relatedFileObject;
    UNICODE_STRING fileName;
    ACCESS_MASK desiredAccess;
    USHORT shareAccess;
    BOOLEAN caseInsensitive = TRUE; //**** Make all searches case insensitive
    PVCB vcb;
    PFCB fcb;
    UNICODE_STRING remainingPart;

    PAGED_CODE();

    //
    // Make local copies of our input parameters to make things easier.
    //

    irpSp             = IoGetCurrentIrpStackLocation( Irp );
    fileObject        = irpSp->FileObject;
    relatedFileObject = irpSp->FileObject->RelatedFileObject;
    fileName          = *(PUNICODE_STRING)&irpSp->FileObject->FileName;
    desiredAccess     = irpSp->Parameters.Create.SecurityContext->DesiredAccess;
    shareAccess       = irpSp->Parameters.Create.ShareAccess;


    //
    // Get the VCB we are trying to access.
    //

    vcb = &MsfsDeviceObject->Vcb;

    //
    // Acquire exclusive access to the VCB.
    //

    MsAcquireExclusiveVcb( vcb );


    try {

        //
        // Check if we are trying to open the mailslot file system
        // (i.e., the Vcb).
        //

        if ((fileName.Length == 0) &&
            ((relatedFileObject == NULL) || (
                NodeType(relatedFileObject->FsContext) == MSFS_NTC_VCB))) {

            DebugTrace(0, Dbg, "Open mailslot file system\n", 0);

            Irp->IoStatus = MsOpenMailslotFileSystem( vcb,
                                                      fileObject,
                                                      desiredAccess,
                                                      shareAccess );

            status = Irp->IoStatus.Status;
            try_return( NOTHING );
        }

        //
        // Check if we are trying to open the root directory.
        //

        if (((fileName.Length == sizeof(WCHAR)) &&
             (fileName.Buffer[0] == L'\\') &&
             (relatedFileObject == NULL))

                ||

            ((fileName.Length == 0) && (NodeType(
                    relatedFileObject->FsContext) == MSFS_NTC_ROOT_DCB))) {

            DebugTrace(0, Dbg, "Open root directory system\n", 0);

            Irp->IoStatus = MsOpenMailslotRootDirectory( vcb->RootDcb,
                                                         fileObject,
                                                         desiredAccess,
                                                         shareAccess );

            status = Irp->IoStatus.Status;
            try_return( NOTHING );
        }

        //
        // If there is a related file object then this is a relative open
        // and it better be the root DCB.  Both the then and the else clause
        // return an FCB.
        //

        if (relatedFileObject != NULL) {

            PDCB dcb;

            dcb = relatedFileObject->FsContext;

            if (NodeType(dcb) == MSFS_NTC_ROOT_DCB) {
                status = MsFindRelativePrefix( dcb,
                                               &fileName,
                                               caseInsensitive,
                                               &remainingPart,
                                               &fcb );
                if (!NT_SUCCESS (status)) {               
                    try_return( NOTHING );
                }
            } else if (NodeType(dcb) == MSFS_NTC_CCB && fileName.Length == 0) {

                fcb = ((PCCB) dcb)->Fcb;
                remainingPart.Length = 0;

            } else if (NodeType(dcb) == MSFS_NTC_FCB && fileName.Length == 0) {

                fcb = (PFCB) dcb;
                remainingPart.Length = 0;

            } else {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }


        } else {

            //
            // The only nonrelative name we allow are of the form
            // "\mailslot-name".
            //

            if ((fileName.Length <= sizeof( WCHAR )) || (fileName.Buffer[0] != L'\\')) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            fcb = MsFindPrefix( vcb,
                                &fileName,
                                caseInsensitive,
                                &remainingPart );
        }

        //
        //  If the remaining name is not empty then we have an error, either
        //  we have an illegal name or a non-existent name.
        //

        if (remainingPart.Length != 0) {

            if (fcb->Header.NodeTypeCode == MSFS_NTC_FCB) {

                //
                // We were given a name such as "\mailslot-name\another-name"
                //

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            } else {

                //
                // We were given a non-existent name
                //

                DebugTrace(0, Dbg, "non-existent name\n", 0);
                status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        } else {

            //
            // The remaining name is empty so we better have an FCB otherwise
            // we have an invalid object name.
            //

            if (fcb->Header.NodeTypeCode == MSFS_NTC_FCB) {

                DebugTrace(0,
                           Dbg,
                           "Create client end mailslot, Fcb = %08lx\n",
                           (ULONG)fcb );

                Irp->IoStatus = MsCreateClientEnd( fcb,
                                                   fileObject,
                                                   desiredAccess,
                                                   shareAccess,
                                                   irpSp->Parameters.Create.SecurityContext->AccessState,
                                                   Irp->RequestorMode,
                                                   Irp->Tail.Overlay.Thread
                                                   );
                status = Irp->IoStatus.Status;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            }
        }


    try_exit: NOTHING;
    } finally {

        MsReleaseVcb( vcb );

        //
        // Complete the IRP and return to the caller.
        //

        MsCompleteRequest( Irp, status );
        DebugTrace(-1, Dbg, "MsCommonCreate -> %08lx\n", status);

    }

    return status;
}


IO_STATUS_BLOCK
MsCreateClientEnd (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread
    )

/*++

Routine Description:

    This routine performs the operation for opening the client end of a
    mailslot.  This routine does not complete the IRP, it performs the
    function and then returns a status.

Arguments:

    Fcb - Supplies the FCB for the mailslot being accessed.

    FileObject - Supplies the file object associated with the client end.

    DesiredAccess - Supplies the caller's desired access.

    ShareAccess - Supplies the caller's share access.

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK iosb;
    PCCB ccb;

    BOOLEAN accessGranted;
    ACCESS_MASK grantedAccess;
    UNICODE_STRING name;
    PPRIVILEGE_SET Privileges = NULL;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateClientEnd\n", 0 );

    try {

        //
        // Lock out mods to the FCB's security descriptor.
        //
        MsAcquireSharedFcb( Fcb );

        SeLockSubjectContext( &AccessState->SubjectSecurityContext );

        //
        //  First do an access check for the user against the Fcb
        //
        accessGranted = SeAccessCheck( Fcb->SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       TRUE,                        // Tokens are locked
                                       DesiredAccess,
                                       0,
                                       &Privileges,
                                       IoGetFileObjectGenericMapping(),
                                       RequestorMode,
                                       &grantedAccess,
                                       &iosb.Status );

        if (Privileges != NULL) {

              (VOID) SeAppendPrivileges(
                         AccessState,
                         Privileges
                         );

            SeFreePrivileges( Privileges );
        }

        if (accessGranted) {
            AccessState->PreviouslyGrantedAccess |= grantedAccess;
            AccessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
        }

        RtlInitUnicodeString( &name, L"Mailslot" );

        SeOpenObjectAuditAlarm( &name,
                                NULL,
                                &FileObject->FileName,
                                Fcb->SecurityDescriptor,
                                AccessState,
                                FALSE,
                                accessGranted,
                                RequestorMode,
                                &AccessState->GenerateOnClose );


        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

        MsReleaseFcb( Fcb );

        if (!accessGranted) {

            DebugTrace(0, Dbg, "Access Denied\n", 0 );

            try_return( iosb.Status );
        }


        //
        // Now make sure our share access is okay.
        //
        ASSERT (MsIsAcquiredExclusiveVcb(Fcb->Vcb));
        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess( grantedAccess,
                                                          ShareAccess,
                                                          FileObject,
                                                          &Fcb->ShareAccess,
                                                          TRUE ))) {

            DebugTrace(0, Dbg, "Sharing violation\n", 0);

            try_return( NOTHING );

        }

        //
        // Create a CCB for this client.
        //

        iosb.Status = MsCreateCcb( Fcb, &ccb );
        if (!NT_SUCCESS (iosb.Status)) {

            IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );

            try_return( iosb.Status);
        }
        

        //
        // Set the file object back pointers and our pointer to the
        // server file object.
        //

        MsSetFileObject( FileObject, ccb, NULL );

        ccb->FileObject = FileObject;

        //
        //  And set our return status
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;


    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "MsCreateClientEnd -> %08lx\n", iosb.Status);

    }

    return iosb;
}


IO_STATUS_BLOCK
MsOpenMailslotFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

{
    IO_STATUS_BLOCK iosb = {0};

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsOpenMailslotFileSystem, Vcb = %p\n", Vcb);


    //
    //  Set the new share access
    //
    ASSERT (MsIsAcquiredExclusiveVcb(Vcb));
    if (NT_SUCCESS(iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                     ShareAccess,
                                                     FileObject,
                                                     &Vcb->ShareAccess,
                                                     TRUE ))) {
        //
        // Supply the file object with a referenced pointer to the VCB.
        //

        MsReferenceVcb (Vcb);

        MsSetFileObject( FileObject, Vcb, NULL );

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;
    }


    DebugTrace(-1, Dbg, "MsOpenMailslotFileSystem -> Iosb.Status = %08lx\n", iosb.Status);

    //
    // Return to the caller.
    //

    return iosb;
}


IO_STATUS_BLOCK
MsOpenMailslotRootDirectory(
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

{
    IO_STATUS_BLOCK iosb = {0};
    PROOT_DCB_CCB ccb;

    PAGED_CODE();
    DebugTrace( +1,
                Dbg,
                "MsOpenMailslotRootDirectory, RootDcb = %08lx\n",
                (ULONG)RootDcb);

    try {

        //
        // Create a root DCB CCB
        //
        ccb = MsCreateRootDcbCcb (RootDcb, RootDcb->Vcb);

        if (ccb == NULL) {

            iosb.Status = STATUS_INSUFFICIENT_RESOURCES;
            try_return( NOTHING );

        }
        //
        // Set the new share access.
        //
        ASSERT (MsIsAcquiredExclusiveVcb(RootDcb->Vcb));
        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess(
                                          DesiredAccess,
                                          ShareAccess,
                                          FileObject,
                                          &RootDcb->ShareAccess,
                                          TRUE ))) {

            DebugTrace(0, Dbg, "bad share access\n", 0);

            //
            // Drop ccb
            //
            MsDereferenceCcb ((PCCB) ccb);

            try_return( NOTHING );
        }


        MsSetFileObject( FileObject, RootDcb, ccb );

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "MsOpenMailslotRootDirectory -> iosb.Status = %08lx\n", iosb.Status);
    }

    //
    // Return to the caller.
    //

    return iosb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\datasup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DataSup.c

Abstract:

    This module implements the mailslot data queue support functions.

Author:

    Manny Weiser (mannyw)    9-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DATASUP)

//
// Local declarations
//

VOID
MsSetCancelRoutine(
    IN PIRP Irp
    );

//
//  The following macro is used to dump a data queue
//

#define DumpDataQueue(S,P) {                                   \
    ULONG MsDumpDataQueue(IN ULONG Level, IN PDATA_QUEUE Ptr); \
    DebugTrace(0,Dbg,S,0);                                     \
    DebugTrace(0,Dbg,"", MsDumpDataQueue(Dbg,P));              \
}


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsAddDataQueueEntry )
#pragma alloc_text( PAGE, MsInitializeDataQueue )
#pragma alloc_text( PAGE, MsRemoveDataQueueEntry )
#pragma alloc_text( PAGE, MsUninitializeDataQueue )
#pragma alloc_text( PAGE, MsSetCancelRoutine )
#pragma alloc_text( PAGE, MsResetCancelRoutine )
#pragma alloc_text( PAGE, MsRemoveDataQueueIrp )
#endif

#if 0
NOT PAGEABLE -- MsCancelDataQueueIrp

#endif


NTSTATUS
MsInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process,
    IN ULONG Quota,
    IN ULONG MaximumMessageSize
    )

/*++

Routine Description:

    This routine initializes a new data queue.  The indicated quota is taken
    from the process and not returned until the data queue is uninitialized.

Arguments:

    DataQueue - Supplies the data queue to be initialized.

    Process - Supplies a pointer to the process creating the mailslot.

    Quota - Supplies the quota to assign to the data queue.

    MaximumMessageSize - The size of the largest message that can be
        written to the data queue.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsInitializeDataQueue, DataQueue = %08lx\n", (ULONG)DataQueue);

    //
    // Get the process's quota, if we can't get it then this call will
    // raise status.
    //

    Status = PsChargeProcessPagedPoolQuota (Process, Quota);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ObReferenceObject( Process );

    //
    // Initialize the data queue structure.
    //

    DataQueue->BytesInQueue       = 0;
    DataQueue->EntriesInQueue     = 0;
    DataQueue->QueueState         = Empty;
    DataQueue->MaximumMessageSize = MaximumMessageSize;
    DataQueue->Quota              = Quota;
    DataQueue->QuotaUsed          = 0;
    InitializeListHead( &DataQueue->DataEntryList );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsInitializeDataQueue -> VOID\n", 0);
    return STATUS_SUCCESS;
}


VOID
MsUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This routine uninitializes a data queue.  The previously debited quota
    is returned to the process.

Arguments:

    DataQueue - Supplies the data queue being uninitialized

    Process - Supplies a pointer to the process who created the mailslot

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsUninitializeDataQueue, DataQueue = %08lx\n", (ULONG)DataQueue);

    //
    //  Assert that the queue is empty
    //

    ASSERT( IsListEmpty(&DataQueue->DataEntryList) );
    ASSERT( DataQueue->BytesInQueue   == 0);
    ASSERT( DataQueue->EntriesInQueue == 0);
    ASSERT( DataQueue->QuotaUsed      == 0);

    //
    //  Return all of our quota back to the process
    //

    PsReturnProcessPagedPoolQuota (Process, DataQueue->Quota);
    ObDereferenceObject (Process);

    //
    // For safety's sake, zero out the data queue structure.
    //

    RtlZeroMemory (DataQueue, sizeof (DATA_QUEUE));

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsUnininializeDataQueue -> VOID\n", 0);
    return;
}


NTSTATUS
MsAddDataQueueEntry (
    IN  PDATA_QUEUE DataQueue,
    IN  QUEUE_STATE Who,
    IN  ULONG DataSize,
    IN  PIRP Irp,
    IN  PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function adds a new data entry to the of the data queue.
    Entries are always appended to the queue.  If necessary this
    function will allocate a data entry buffer, or use space in
    the IRP.

    The different actions we are perform are based on the type and who
    parameters and quota requirements.


    Who == ReadEntries

        +----------+                      - Allocate Data Entry from IRP
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |    - Allocate New System buffer
        |DeallBu...|     |EitherQuota|
        +----------+     +-----------+    - Reference and modify Irp to
          |      |         |                do Buffered I/O, Deallocate
          v      |         v                buffer, and have I/O completion
        +------+ +------>+------+           copy the buffer (Input operation)
        |User  |         |System|
        |Buffer|         |Buffer|
        +------+         +------+

    Who == WriteEntries && Quota Available

        +----------+                      - Allocate Data Entry from Quota
        |Irp       |     +-----------+
        |          |     |Buffered   |    - Allocate New System buffer
        |          |     |Quota      |
        +----------+     +-----------+    - Copy data from User buffer to
          |                |                system buffer
          v                v
        +------+         +------+         - Complete IRP
        |User  |..copy..>|System|
        |Buffer|         |Buffer|
        +------+         +------+

    Who == WriteEntries && Quota Not Available

        +----------+                     - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |   - Allocate New System buffer
        |DeallBuff |     |UserQuota  |
        +----------+     +-----------+   - Reference and modify Irp to use
          |      |         |               the new system buffer, do Buffered
          v      |         v               I/O, and Deallocate buffer
        +------+ +------>+------+
        |User  |         |System|        - Copy data from User buffer to
        |Buffer|..copy..>|Buffer|          system buffer
        +------+         +------+


Arguments:

    DataQueue - Supplies the Data queue being modified.

    Who - Indicates if this is the reader or writer that is adding to the
        mailslot.

    DataSize - Indicates the size of the data buffer needed to represent
        this entry.

    Irp - Supplies a pointer to the IRP responsible for this entry.

Return Value:

    PDATA_ENTRY - Returns a pointer to the newly added data entry.

--*/

{
    PDATA_ENTRY dataEntry;
    PLIST_ENTRY previousEntry;
    PFCB fcb;
    ULONG TotalSize;
    NTSTATUS status;

    PAGED_CODE( );

    DebugTrace(+1, Dbg, "MsAddDataQueueEntry, DataQueue = %08lx\n", (ULONG)DataQueue);

    ASSERT( DataQueue->QueueState != -1 );

    Irp->IoStatus.Information = 0;

    if (Who == ReadEntries) {

        //
        // Allocate a data entry from the IRP, and allocate a new
        // system buffer.
        //

        dataEntry = (PDATA_ENTRY)IoGetNextIrpStackLocation( Irp );

        dataEntry->DataPointer = NULL;
        dataEntry->Irp = Irp;
        dataEntry->DataSize = DataSize;
        dataEntry->TimeoutWorkContext = WorkContext;

        //
        // Check to see if the mailslot has enough quota left to
        // allocate the system buffer.
        //

        if ((DataQueue->Quota - DataQueue->QuotaUsed) >= DataSize) {

            //
            // Use the mailslot quota to allocate pool for the request.
            //

            if (DataSize) {
                dataEntry->DataPointer = MsAllocatePagedPoolCold( DataSize,
                                                                  'rFsM' );
                if (dataEntry->DataPointer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            DataQueue->QuotaUsed += DataSize;

            dataEntry->From = MailslotQuota;


        } else {

            //
            // Use the caller's quota to allocate pool for the request.
            //

            if (DataSize) {
                dataEntry->DataPointer = MsAllocatePagedPoolWithQuotaCold( DataSize,
                                                                           'rFsM' );
                if (dataEntry->DataPointer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            dataEntry->From = UserQuota;

        }

        //
        // Modify the IRP to be buffered I/O, deallocate the buffer, copy
        // the buffer on completion, and to reference the new system
        // buffer.
        //

        Irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
        Irp->AssociatedIrp.SystemBuffer = dataEntry->DataPointer;
        if (Irp->AssociatedIrp.SystemBuffer) {
            Irp->Flags |= IRP_DEALLOCATE_BUFFER;
        }

        Irp->IoStatus.Pointer = DataQueue;
        status = STATUS_PENDING;


    } else {

        //
        // This is a writer entry.
        //

        //
        // If there is enough quota left in the mailslot then we will
        // allocate the data entry and data buffer from the mailslot
        // quota.
        //
        TotalSize = sizeof(DATA_ENTRY) + DataSize;
        if (TotalSize < sizeof(DATA_ENTRY)) {
            return STATUS_INVALID_PARAMETER;
        }

        if ((DataQueue->Quota - DataQueue->QuotaUsed) >= TotalSize) {

            //
            // Allocate the data buffer using the mailslot quota.
            //

            dataEntry = MsAllocatePagedPool( TotalSize, 'dFsM' );
            if (dataEntry == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            dataEntry->DataPointer = (PVOID) (dataEntry + 1);

            DataQueue->QuotaUsed += TotalSize;

            dataEntry->From = MailslotQuota;

        } else {

            //
            // There isn't enough quota in the mailslot.  Use the
            // caller's quota.
            //

            dataEntry = MsAllocatePagedPoolWithQuota( TotalSize, 'dFsM' );
            if (dataEntry == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            dataEntry->DataPointer = (PVOID) (dataEntry + 1);

            dataEntry->From = UserQuota;

        }
        dataEntry->Irp = NULL;
        dataEntry->DataSize = DataSize;
        dataEntry->TimeoutWorkContext = NULL;

        //
        // Copy the user buffer to the new system buffer, update the FCB
        // timestamps and complete the IRP.
        //

        try {

            RtlCopyMemory (dataEntry->DataPointer, Irp->UserBuffer, DataSize);

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            // Only need to free the writers case as the readers get the buffer freed on I/O
            // completion.
            //
            if (Who == WriteEntries) {
                MsFreePool ( dataEntry );
            }

            return GetExceptionCode (); // Watch out. Could be a guard page violation thats a warning!
        }

        fcb = CONTAINING_RECORD( DataQueue, FCB, DataQueue );
        KeQuerySystemTime( &fcb->Specific.Fcb.LastModificationTime );

        Irp->IoStatus.Information = DataSize;
        status = STATUS_SUCCESS;

    } // else (writer entry)

    //
    // Now data entry points to a new data entry to add to the data queue
    // Check if the queue is empty otherwise we will add this entry to
    // the end of the queue.
    //

#if DBG
    if ( IsListEmpty( &DataQueue->DataEntryList ) ) {

        ASSERT( DataQueue->QueueState     == Empty );
        ASSERT( DataQueue->BytesInQueue   == 0);
        ASSERT( DataQueue->EntriesInQueue == 0);

    } else {

        ASSERT( DataQueue->QueueState == Who );

    }

#endif

    DataQueue->QueueState     = Who;

    //
    // Only cound written bytes and messages in the queue. This makes sense because we return
    // this value as the end of file position. GetMailslotInfo needs EntriesInQueue to
    // ignore reads.
    //
    if (Who == WriteEntries) {
        DataQueue->BytesInQueue   += dataEntry->DataSize;
        DataQueue->EntriesInQueue += 1;
    }

    //
    // Insert the new entry at the appropriate place in the data queue.
    //

    InsertTailList( &DataQueue->DataEntryList, &dataEntry->ListEntry );

    WorkContext = dataEntry->TimeoutWorkContext;
    if ( WorkContext) {
        KeSetTimer( &WorkContext->Timer,
                    WorkContext->Fcb->Specific.Fcb.ReadTimeout,
                    &WorkContext->Dpc );
    }

    if (Who == ReadEntries) {
        MsSetCancelRoutine( Irp );  // this fakes a call to cancel if we are already canceled
    }


    //
    // Return to the caller.
    //

    DumpDataQueue( "After AddDataQueueEntry\n", DataQueue );
    DebugTrace(-1, Dbg, "MsAddDataQueueEntry -> %08lx\n", (ULONG)dataEntry);

    return status;
}


PIRP
MsRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PDATA_ENTRY DataEntry
    )

/*++

Routine Description:

    This routine removes the specified data entry from the indicated
    data queue, and possibly returns the IRP associated with the entry if
    it wasn't already completed.

    If the data entry we are removing indicates buffered I/O then we also
    need to deallocate the data buffer besides the data entry but only
    if the IRP is null.  Note that the data entry might be stored in an IRP.
    If it is then we are going to return the IRP it is stored in.

Arguments:

    DataEntry - Supplies a pointer to the data entry to remove.

Return Value:

    PIRP - Possibly returns a pointer to an IRP.

--*/

{
    FROM from;
    PIRP irp;
    ULONG dataSize;
    PVOID dataPointer;

    PAGED_CODE( );

    DebugTrace(+1, Dbg, "MsRemoveDataQueueEntry, DataEntry = %08lx\n", (ULONG)DataEntry);
    DebugTrace( 0, Dbg, "DataQueue = %08lx\n", (ULONG)DataQueue);

    //
    // Remove the data entry from the queue and update the count of
    // data entries in the queue.
    //

    RemoveEntryList( &DataEntry->ListEntry );
    //
    // If the queue is now empty then we need to fix the queue
    // state.
    //

    if (IsListEmpty( &DataQueue->DataEntryList ) ) {
        DataQueue->QueueState = Empty;
    }

    //
    // Capture some of the fields from the data entry to make our
    // other references a little easier.
    //

    from = DataEntry->From;
    dataSize = DataEntry->DataSize;


    if (from == MailslotQuota) {
        DataQueue->QuotaUsed -= dataSize;
    }
    //
    // Get the IRP for this block if there is one
    //

    irp = DataEntry->Irp;
    if (irp) {
        //
        // Cancel the timer associated with this if there is one
        //
        MsCancelTimer (DataEntry);
        irp = MsResetCancelRoutine( irp );
        if ( irp == NULL ) {

            //
            // cancel is active. Let it know that we already did partial cleanup.
            // It just has to complete the IRP.
            //
            DataEntry->ListEntry.Flink = NULL;
        }

    } else {

        DataQueue->BytesInQueue -= DataEntry->DataSize;

        //
        // Free the data entry for a write request. This is part of the IRP for a read request.
        //
        ExFreePool( DataEntry );

        if (from == MailslotQuota) {
            DataQueue->QuotaUsed -= sizeof(DATA_ENTRY);
        }

        DataQueue->EntriesInQueue--;
#if DBG
        if (DataQueue->EntriesInQueue == 0) {
            ASSERT (DataQueue->QueueState == Empty);
            ASSERT (DataQueue->BytesInQueue == 0);
            ASSERT (IsListEmpty( &DataQueue->DataEntryList ));
            ASSERT (DataQueue->QuotaUsed == 0);
        }
#endif
    }


    //
    // Return to the caller.
    //

    DumpDataQueue( "After RemoveDataQueueEntry\n", DataQueue );
    DebugTrace(-1, Dbg, "MsRemoveDataQueueEntry -> %08lx\n", (ULONG)irp);

    return irp;
}


VOID
MsRemoveDataQueueIrp (
    IN PIRP Irp,
    IN PDATA_QUEUE DataQueue
    )
/*++

Routine Description:

    This routine removes an IRP from its data queue.

Requirements:

    The FCB for this data queue MUST be exclusively locked.

Arguments:

    Irp - Supplies the Irp being removed.

    DataQueue - A pointer to the data queue structure where we expect
            to find the IRP.

Return Value:

    Returns whether or not we actually dequeued the IRP.

--*/

{
    PDATA_ENTRY dataEntry;
    PLIST_ENTRY listEntry, nextListEntry;
    PWORK_CONTEXT workContext;
    PKTIMER timer;
    BOOLEAN foundIrp = FALSE;

    dataEntry = (PDATA_ENTRY)IoGetNextIrpStackLocation( Irp );

    //
    // This is the cancel path. If a completion path has already removed this IRP then return now.
    // The timer will have been canceled, counts adjusted etc.
    //
    if (dataEntry->ListEntry.Flink == NULL) {
       return;
    }
    //
    // remove this entry from the list.
    //
    RemoveEntryList (&dataEntry->ListEntry);

    MsCancelTimer (dataEntry);

    //
    // If the queue is now empty then we need to fix the queue
    // state.
    //

    //
    // Check if we need to return mailslot quota. The DATA_ENTRY was part of the IRP so we didn't
    // get charged for that
    //

    if ( dataEntry->From == MailslotQuota ) {
        DataQueue->QuotaUsed -= dataEntry->DataSize;
    }

    if (IsListEmpty( &DataQueue->DataEntryList ) ) {

        DataQueue->QueueState = Empty;

        ASSERT (DataQueue->BytesInQueue == 0);
        ASSERT (DataQueue->QuotaUsed == 0);
        ASSERT (DataQueue->EntriesInQueue == 0);
    }



    //
    //  And return to our caller
    //

    return;

} // MsRemoveDataQueueIrp


VOID
MsCancelDataQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a
    data queue

Arguments:

    DeviceObject - Device object associated with IRP or NULL if called directly by this driver

    Irp - Supplies the Irp being cancelled.

Return Value:

    None.

--*/

{
    PFCB fcb;
    PDATA_QUEUE dataQueue;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject;


    //
    // This isn't strictly correct. IoCancelIrp can be called at Irql <= DISPATCH_LEVEL but
    // this code is assuming that the IRQL of the caller is <= APC_LEVEL.
    // If we are called inline we don't hold the cancel spinlock and we already own the FCB lock.
    //
    if (DeviceObject != NULL) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;

    dataQueue = (PDATA_QUEUE)Irp->IoStatus.Pointer;


    fcb = CONTAINING_RECORD( dataQueue, FCB, DataQueue );

    //
    //  Get exclusive access to the mailslot FCB so we can now do our work.
    //
    if (DeviceObject != NULL) {
        FsRtlEnterFileSystem ();
        MsAcquireExclusiveFcb( fcb );
    }

    MsRemoveDataQueueIrp( Irp, dataQueue );

    if (DeviceObject != NULL) {
        MsReleaseFcb( fcb );
        FsRtlExitFileSystem ();
    }


    MsCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;

} // MsCancelDataQueueIrp

PIRP
MsResetCancelRoutine(
    IN PIRP Irp
    )

/*++

Routine Description:

    Stub to null out the cancel routine.

Arguments:

    Irp - Supplies the Irp whose cancel routine is to be nulled out.

Return Value:

    None.

--*/
{
    if ( IoSetCancelRoutine( Irp, NULL ) != NULL ) {
       return Irp;
    } else {
       return NULL;
    }

} // MsResetCancelRoutine

VOID
MsSetCancelRoutine(
    IN PIRP Irp
    )

/*++

Routine Description:

    Stub to set the cancel routine.  If the irp has already been cancelled,
    the cancel routine is called.

Arguments:

    Irp - Supplies the Irp whose cancel routine is to be set.

Return Value:

    None.

--*/
{
    IoMarkIrpPending( Irp ); // top level always returns STATUS_PENDING if we get this far

    IoSetCancelRoutine( Irp, MsCancelDataQueueIrp );
    if ( Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL ) {
        //
        // The IRP was canceled before we put our routine on. Fake a cancel call
        //
        
        MsCancelDataQueueIrp (NULL, Irp);
    }

    return;

} // MsSetCancelRoutine

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\deviosup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    deviosup.c

Abstract:

    This module implements the memory locking routines for MSFS.

Author:

    Manny Weiser (mannyw)   05-Apr-1991

Revision History:

--*/

#include "mailslot.h"

//
// Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsMapUserBuffer )
#endif

VOID
MsMapUserBuffer (
    IN OUT PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *UserBuffer
    )

/*++

Routine Description:

    This routine obtains a usable virtual address for the user buffer
    for the current I/O request in the specified mode.

Arguments:

    Irp - Pointer to the Irp for the request.

    AccessMode - UserMode or KernelMode.

    UserBuffer - Returns pointer to mapped user buffer.

Return Value:

    None.

--*/

{
    AccessMode;
    PAGED_CODE();

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        *UserBuffer = Irp->UserBuffer;
        return;
    }

    //
    // Get a system virtual address for the buffer.
    //

    *UserBuffer = MmGetSystemAddressForMdl( Irp->MdlAddress );
    return;

} // MsMapUserBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msconst.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSCONST_
#define _MSCONST_

//
// Every major data structure in the file system is assigned a node
// type code.  This code is the first CSHORT in the structure and is
// followed by a CSHORT containing the size, in bytes, of the structure.
//

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define MSFS_NTC_VCB                     ((NODE_TYPE_CODE)0x0601)
#define MSFS_NTC_ROOT_DCB                ((NODE_TYPE_CODE)0x0602)
#define MSFS_NTC_FCB                     ((NODE_TYPE_CODE)0x0604)
#define MSFS_NTC_CCB                     ((NODE_TYPE_CODE)0x0606)
#define MSFS_NTC_ROOT_DCB_CCB            ((NODE_TYPE_CODE)0x0608)

typedef CSHORT NODE_BYTE_SIZE;

//
// The name of the mailslot file system.
//

#define MSFS_NAME_STRING                 L"MSFS"

//
// Volume label
//
#define MSFS_VOLUME_LABEL                L"Mailslot"

//
// The default read timeout.  This is used if no timeout is specified
// when the mailslot is created.
//

#define DEFAULT_READ_TIMEOUT             { -1, -1 }

//
// The number of parameter bytes returned by a peek call.
//

#define PEEK_OUTPUT_PARAMETER_BYTES      \
            ((ULONG)FIELD_OFFSET(FILE_MAILSLOT_PEEK_BUFFER, Data[0]))

//
// The number of parameter bytes returned by a mailslot read call.
//

#define READ_OUTPUT_PARAMETER_BYTES      \
            ((ULONG)FIELD_OFFSET(FILE_MAILSLOT_READ_BUFFER, Data[0]))

//
// Access to the block header information.
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


#endif // _MSCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\mailslot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mailslot.h

Abstract:

    This module is the main include file for the Mailslot File System.
    It includes other header files.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MAILSLOT_
#define _MAILSLOT_

#define _NTSRV_
#define _NTDDK_

//
// "System" include files
//

#include <ntos.h>
#include <string.h>
#include <fsrtl.h>

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

//
// Local, independent include files
//

#include "msconst.h"
#include "msdebug.h"
#include "msdata.h"

//
// Local, dependent include files (order is important)
//

#include "msstruc.h"
#include "msfunc.h"

#endif // def _MAILSLOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    filobsup.c

Abstract:

    This module implements the mailslot file object support routines.

Author:

    Manny Weiser (mannyw)    10-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsDecodeFileObject )
#pragma alloc_text( PAGE, MsSetFileObject )
#endif

VOID
MsSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to either a ccb, fcb, vcb, or root_dcb
        structure.

    FsContext2 - Supplies a pointer to a root_dcb_ccb, or is null.

Return Value:

    None.

--*/

{
    NODE_TYPE_CODE nodeType;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsSetFileObject, FileObject = %08lx\n", (ULONG)FileObject );

    //
    // Set the fscontext fields of the file object.
    //

    FileObject->FsContext  = FsContext;
    FileObject->FsContext2 = FsContext2;

    //
    // Set the mailslot flag in the file object if necessary and return.
    //

    if (FsContext != NULL) {
        nodeType = NodeType(FsContext);

        if (nodeType == MSFS_NTC_CCB || nodeType == MSFS_NTC_FCB) {
            FileObject->Flags |= FO_MAILSLOT;
        }
    }

    DebugTrace(-1, Dbg, "MsSetFileObject -> VOID\n", 0);

    return;
}


NODE_TYPE_CODE
MsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the mailslot file system and figures out what it really
    is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    FsContext - Receive the file object FsContext pointer

    FsContext2 - Receive the file object FsContext2 pointer


Return Value:

    NODE_TYPE_CODE - Returns the node type code for a Vcb, RootDcb, Ccb,
        or zero.

        Vcb - indicates that file object opens the mailslot driver.

        RootDcb - indicates that the file object is for the root directory.

        Ccb - indicates that the file object is for a mailslot file.

        Zero - indicates that the file object was for a mailslot file
            but has been closed.

--*/

{
    NODE_TYPE_CODE NodeTypeCode = NTC_UNDEFINED;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDecodeFileObject, FileObject = %08lx\n", (ULONG)FileObject);


    //
    // Read the fs FsContext fields of the file object, then reference
    // the block pointed at by the file object
    //

    *FsContext = FileObject->FsContext;
    *FsContext2 = FileObject->FsContext2;

    //
    // Acquire the global lock to protect the node reference counts.
    //

    MsAcquireGlobalLock();

    if ( ((PNODE_HEADER)(*FsContext))->NodeState != NodeStateActive ) {

        //
        // This node is shutting down.  Indicate this to the caller.
        //

        NodeTypeCode = NTC_UNDEFINED;

    } else {

        //
        // The node is active.  Supply a referenced pointer to the node.
        //

        NodeTypeCode = NodeType( *FsContext );
        MsReferenceNode( ((PNODE_HEADER)(*FsContext)) );

    }

    //
    // Release the global lock and return to the caller.
    //

    MsReleaseGlobalLock();

    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "Referencing block %08lx\n",
               (ULONG)*FsContext);
    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "    Reference count = %lx\n",
               ((PNODE_HEADER)(*FsContext))->ReferenceCount );

    DebugTrace(-1, Dbg, "MsDecodeFileObject -> %08lx\n", NodeTypeCode);

    return NodeTypeCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\dumpsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dumpsup.c

Abstract:

    This module implements a collection of data structure dump routines
    for debugging the mailslot file system

Author:

    Manny Weiser (mannyw)    9-Jan-1991

Revision History:

--*/

#include "mailslot.h"

#ifdef MSDBG

VOID MsDumpDataQueue(IN ULONG Level, IN PDATA_QUEUE Ptr);
VOID MsDumpDataEntry(IN PDATA_ENTRY Ptr);

VOID MsDump(IN PVOID Ptr);
VOID MsDumpVcb(IN PVCB Ptr);
VOID MsDumpRootDcb(IN PROOT_DCB Ptr);
VOID MsDumpFcb(IN PFCB Ptr);
VOID MsDumpCcb(IN PCCB Ptr);
VOID MsDumpRootDcbCcb(IN PROOT_DCB_CCB Ptr);

ULONG MsDumpCurrentColumn;

#define DumpNewLine() { \
    DbgPrint("\n"); \
    MsDumpCurrentColumn = 1; \
}

#define DumpLabel(Label,Width) { \
    ULONG i; \
    CHAR _Str[20]; \
    for(i=0;i<2;i++) { _Str[i] = ' ';} \
    strncpy(&_Str[2],#Label,Width); \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = ' ';} \
    _Str[Width] = '\0'; \
    DbgPrint("%s", _Str); \
}

#define DumpField(Field) { \
    if ((MsDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    MsDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Field,18); \
    DbgPrint(":%8lx", Ptr->Field); \
    DbgPrint("         "); \
}

#define DumpHeader(Header) { \
    DumpField(Header.NodeTypeCode);   \
    DumpField(Header.NodeByteSize);   \
    DumpField(Header.NodeState);      \
    DumpField(Header.ReferenceCount); \
}

#define DumpListEntry(Links) { \
    if ((MsDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    MsDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Links,18); \
    DbgPrint(":%8lx", Ptr->Links.Flink); \
    DbgPrint(":%8lx", Ptr->Links.Blink); \
}

#define DumpName(Field,Width) { \
    ULONG i; \
    CHAR _String[256]; \
    if ((MsDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();} \
    MsDumpCurrentColumn += 18 + Width; \
    DumpLabel(Field,18); \
    for(i=0;i<Width;i++) {_String[i] = Ptr->Field[i];} \
    _String[Width] = '\0'; \
    DbgPrint("%s", _String); \
}

#define TestForNull(Name) { \
    if (Ptr == NULL) { \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name); \
        return; \
    } \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsDump )
#pragma alloc_text( PAGE, MsDumpCcb )
#pragma alloc_text( PAGE, MsDumpDataEntry )
#pragma alloc_text( PAGE, MsDumpDataQueue )
#pragma alloc_text( PAGE, MsDumpFcb )
#pragma alloc_text( PAGE, MsDumpRootDcb )
#pragma alloc_text( PAGE, MsDumpRootDcbCcb )
#pragma alloc_text( PAGE, MsDumpVcb )
#endif


VOID MsDumpDataQueue (
    IN ULONG Level,
    IN PDATA_QUEUE Ptr
    )

{
    PLIST_ENTRY listEntry;
    PDATA_ENTRY dataEntry;

    PAGED_CODE();
    if ((Level != 0) && !(MsDebugTraceLevel & Level)) {
        return;
    }

    TestForNull   ("MsDumpDataQueue");

    DumpNewLine   ();
    DbgPrint       ("DataQueue@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (QueueState);
    DumpField     (BytesInQueue);
    DumpField     (EntriesInQueue);
    DumpField     (Quota);
    DumpField     (QuotaUsed);
    DumpField     (MaximumMessageSize);
    DumpField     (DataEntryList.Flink);
    DumpField     (DataEntryList.Blink);
    DumpNewLine   ();

    for (listEntry = Ptr->DataEntryList.Flink;
         listEntry != &Ptr->DataEntryList;
         listEntry = listEntry->Flink) {

        dataEntry = CONTAINING_RECORD(listEntry, DATA_ENTRY, ListEntry);
        MsDumpDataEntry( dataEntry );
    }

    return;
}


VOID MsDumpDataEntry (
    IN PDATA_ENTRY Ptr
    )

{
    PAGED_CODE();
    TestForNull   ("MsDumpDataEntry");

    DumpNewLine   ();
    DbgPrint       ("DataEntry@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (From);
    DumpField     (Irp);
    DumpField     (DataSize);
    DumpField     (DataPointer);
    DumpField     (TimeoutWorkContext);
    DumpNewLine   ();

    return;
}


VOID MsDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull("MsDump");

    //
    //  We'll switch on the node type code
    //

    switch (NodeType(Ptr)) {

    case MSFS_NTC_VCB:               MsDumpVcb(Ptr);             break;
    case MSFS_NTC_ROOT_DCB:          MsDumpRootDcb(Ptr);         break;
    case MSFS_NTC_FCB:               MsDumpFcb(Ptr);             break;
    case MSFS_NTC_CCB:               MsDumpCcb(Ptr);             break;
    case MSFS_NTC_ROOT_DCB_CCB:      MsDumpRootDcbCcb(Ptr);      break;

    default :
        DbgPrint("MsDump - Unknown Node type code %8lx\n", *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


VOID MsDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump an Vcb structure

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull   ("MsDumpVcb");

    DumpNewLine   ();
    DbgPrint       ("Vcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpField     (RootDcb);
    DumpNewLine   ();

    MsDump        (Ptr->RootDcb);

    return;
}


VOID MsDumpRootDcb (
    IN PROOT_DCB Ptr
    )

/*++

Routine Description:

    Dump a root dcb structure

Arguments:

    Ptr - Supplies the Root Dcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    PAGED_CODE();
    TestForNull   ("MsDumpRootDcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (Vcb);
    DumpField     (FileObject);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpListEntry (Specific.Dcb.NotifyFullQueue);
    DumpListEntry (Specific.Dcb.NotifyPartialQueue);
    DumpListEntry (Specific.Dcb.ParentDcbQueue);
    DumpField     (CreatorProcess);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &Ptr->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {
        MsDump(CONTAINING_RECORD(Links, FCB, ParentDcbLinks));
    }

    return;
}


VOID MsDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    PAGED_CODE();
    TestForNull   ("MsDumpFcb");

    DumpNewLine   ();
    DbgPrint       ("Fcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (Vcb);
    DumpField     (FileObject);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpListEntry (Specific.Fcb.CcbQueue);
    DumpField     (CreatorProcess);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Fcb.CcbQueue.Flink;
         Links != &Ptr->Specific.Fcb.CcbQueue;
         Links = Links->Flink) {
        MsDump(CONTAINING_RECORD(Links, CCB, CcbLinks));
    }

    MsDumpDataQueue ( 0, &(Ptr->DataQueue) );

    return;
}


VOID MsDumpCcb (
    IN PCCB Ptr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull   ("MsDumpCcb");

    DumpNewLine   ();
    DbgPrint       ("Ccb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpField     (Fcb);
    DumpField     (FileObject);
    DumpNewLine   ();

    return;
}


VOID MsDumpRootDcbCcb (
    IN PROOT_DCB_CCB Ptr
    )

/*++

Routine Description:

    Dump a Root Dcb Ccb structure

Arguments:

    Ptr - Supplies the Root Dcb Ccb record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull   ("MsDumpRootDcbCcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcbCcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpField     (IndexOfLastCcbReturned);
    DumpField     (QueryTemplate);
    DumpNewLine   ();

    return;
}

#endif // MSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msdata.c

Abstract:

    This module declares the global variable used by the mailslot
    file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#include "mailslot.h"

#ifdef MSDBG

//
// Debugging variables
//

LONG MsDebugTraceLevel;
LONG MsDebugTraceIndent;

#endif

//
// This lock protects access to reference counts.
//

PERESOURCE MsGlobalResource;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, MsInitializeData )
#pragma alloc_text( PAGE, MsUninitializeData )
#endif

NTSTATUS
MsInitializeData(
    VOID
    )

/*++

Routine Description:

    This function initializes all MSFS global data.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();
#ifdef MSDBG
    MsDebugTraceLevel = 0;
    MsDebugTraceIndent = 0;
#endif

    MsGlobalResource = MsAllocateNonPagedPool (sizeof(ERESOURCE), 'gFsM');

    if (MsGlobalResource == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeResourceLite ( MsGlobalResource );

    return STATUS_SUCCESS;
}

VOID
MsUninitializeData(
    VOID
    )
/*++

Routine Description:

    This function uninitializes all MSFS global data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ExDeleteResourceLite ( MsGlobalResource );

    ExFreePool ( MsGlobalResource );

    MsGlobalResource = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\except.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    except.c

Abstract:

    This module declares the exception handling function used by the
    mailslot file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#include "mailslot.h"

#define Dbg             DEBUG_TRACE_CATCH_EXCEPTIONS
#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsExceptionFilter )
#pragma alloc_text( PAGE, MsProcessException )
#endif

LONG
MsExceptionFilter (
    IN NTSTATUS ExceptionCode
    )
{
    PAGED_CODE();
    DebugTrace(0, Dbg, "MsExceptionFilter %08lx\n", ExceptionCode);
    DebugDump("", Dbg, NULL );

    if (FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_EXECUTE_HANDLER;

    } else {

        return EXCEPTION_CONTINUE_SEARCH;
    }
}

NTSTATUS
MsProcessException (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )
{
    NTSTATUS FinalExceptionCode;

    PAGED_CODE();
    FinalExceptionCode = ExceptionCode;

    if (FsRtlIsNtstatusExpected( ExceptionCode )) {

        MsCompleteRequest( Irp, ExceptionCode );

    } else {

        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    return FinalExceptionCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\fscontrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fscontrl.c

Abstract:

    This module implements the file file system control routines for MSFS
    called by the dispatch driver.

Author:

    Manny Weiser (mannyw)    25-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTROL)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonFsControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsPeek (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonFsControl )
#pragma alloc_text( PAGE, MsFsdFsControl )
#pragma alloc_text( PAGE, MsPeek )
#endif


NTSTATUS
MsFsdFsControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtFsControlFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdFsControl\n", 0);

    //
    // Call the common file system control function.
    //

    status = MsCommonFsControl( MsfsDeviceObject, Irp );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdFsControl -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCommonFsControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for handling a file system control call.

Arguments:

    MsfsDeviceObject - A pointer to the mailslot file system device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", irpSp->Parameters.FileSystemControl.OutputBufferLength);
    DebugTrace( 0, Dbg, "InputBufferLength  = %08lx\n", irpSp->Parameters.FileSystemControl.InputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", irpSp->Parameters.FileSystemControl.FsControlCode);

    //
    // Decide how to handle this IRP.  Call the appropriate worker function.
    //


    switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_MAILSLOT_PEEK:

        FsRtlEnterFileSystem();

        status = MsPeek( MsfsDeviceObject, Irp );

        FsRtlExitFileSystem();

        break;

    default:

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

    }


    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCommonFsControl -> %08lx\n", status);
    return status;
}


NTSTATUS
MsPeek (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles a mailslot peek call.

Arguments:

    MsfsDeviceObject - A pointer to the mailslot file system device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PFILE_MAILSLOT_PEEK_BUFFER peekParamBuffer;
    ULONG peekParamLength;

    PVOID peekDataBuffer;
    ULONG peekDataLength;

    PDATA_QUEUE dataQueue;
    ULONG MessageLength;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsPeek\n", 0);

    //
    // Make local copies of the input parameters to make things easier.
    //

    peekParamBuffer = irpSp->Parameters.FileSystemControl.Type3InputBuffer;
    peekParamLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

    peekDataBuffer = Irp->UserBuffer;
    peekDataLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    // Ensure that the supplied buffer is large enough for the peek
    // parameters.
    //

    if (peekParamLength <  sizeof( FILE_MAILSLOT_PEEK_BUFFER ) ) {

        DebugTrace(0, Dbg, "Output buffer is too small\n", 0);

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status );
        return status;
    }

    //
    // If the requestor mode is user mode we need to probe the buffers.
    // We do not need to have an exception handler here because our top
    // level caller already has one that will complete the Irp with
    // the appropriate status if we access violate.
    //

    if (Irp->RequestorMode != KernelMode) {

        try {

            ProbeForWrite( peekParamBuffer, peekParamLength, sizeof(UCHAR) );
            ProbeForWrite( peekDataBuffer, peekDataLength, sizeof(UCHAR) );
            peekParamBuffer->ReadDataAvailable = 0;
            peekParamBuffer->NumberOfMessages = 0;
            peekParamBuffer->MessageLength = 0;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            MsCompleteRequest( Irp, status );
            return status;
        }

    }

    //
    // Decode the fil1e object.  If it returns NTC_UNDEFINED, then the
    // node is closing.  Otherwise we obtain a referenced pointer to
    // an FCB.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&fcb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status );
        return status;
    }

    //
    // Allow a peek operation only if this is a server side handle to
    // a mailslot file (i.e. the node type is FCB).
    //

    if (nodeTypeCode != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "FileObject is not the correct type\n", 0);

        MsDereferenceNode( &fcb->Header );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );


    //
    // Ensure that this FCB still belongs to an active open mailslot.
    //

    status = MsVerifyFcb( fcb );

    if (NT_SUCCESS (status)) {

        //
        // Look for write data in the mailslot.
        //

        dataQueue = &fcb->DataQueue;

        if (!MsIsDataQueueWriters( dataQueue )) {

            //
            // There are no outstanding writes so leave all the zeros in there.
            //


        } else {

            //
            // There is write data for the peek.  Fill in the peek output
            // buffer.
            //


            Irp->IoStatus = MsReadDataQueue(
                                        dataQueue,
                                        Peek,
                                        peekDataBuffer,
                                        peekDataLength,
                                        &MessageLength
                                        );

            status = Irp->IoStatus.Status;

            if (NT_SUCCESS (status)) {
                try {
                    peekParamBuffer->ReadDataAvailable = dataQueue->BytesInQueue;
                    peekParamBuffer->NumberOfMessages = dataQueue->EntriesInQueue;
                    peekParamBuffer->MessageLength = MessageLength;

                } except (EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode ();
                }
            }

        }
    }

    MsReleaseFcb( fcb );

    //
    // Release the reference to the FCB.
    //

    MsDereferenceFcb( fcb );
    //
    // Finish up the fs control IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the get / set file information routines for
    MSFS called by the dispatch driver.

Author:

     Manny Weiser (mannyw)    31-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonQueryInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
MsCommonSetInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

VOID
MsQueryBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

VOID
MsQueryStandardInfo (
    IN PFCB Fcb,
    IN PFILE_STANDARD_INFORMATION Buffer
    );

VOID
MsQueryInternalInfo (
    IN PFCB Fcb,
    IN PFILE_INTERNAL_INFORMATION Buffer
    );

VOID
MsQueryEaInfo (
    IN PFILE_EA_INFORMATION Buffer
    );

NTSTATUS
MsQueryNameInfo (
    IN PFCB Fcb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
MsQueryPositionInfo (
    IN PFCB Fcb,
    IN PFILE_POSITION_INFORMATION Buffer
    );

VOID
MsQueryMailslotInfo (
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_QUERY_INFORMATION Buffer
    );

NTSTATUS
MsSetBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
MsSetMailslotInfo (
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_SET_INFORMATION Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonQueryInformation )
#pragma alloc_text( PAGE, MsCommonSetInformation )
#pragma alloc_text( PAGE, MsFsdQueryInformation )
#pragma alloc_text( PAGE, MsFsdSetInformation )
#pragma alloc_text( PAGE, MsQueryBasicInfo )
#pragma alloc_text( PAGE, MsQueryEaInfo )
#pragma alloc_text( PAGE, MsQueryInternalInfo )
#pragma alloc_text( PAGE, MsQueryMailslotInfo )
#pragma alloc_text( PAGE, MsQueryNameInfo )
#pragma alloc_text( PAGE, MsQueryPositionInfo )
#pragma alloc_text( PAGE, MsQueryStandardInfo )
#pragma alloc_text( PAGE, MsSetBasicInfo )
#pragma alloc_text( PAGE, MsSetMailslotInfo )
#endif


NTSTATUS
MsFsdQueryInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryInformationFile API
    calls.

Arguments:

    MsfsDeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdQueryInformation\n", 0);

    //
    // Call the common query information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonQueryInformation( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdQueryInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
MsFsdSetInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetInformationFile API
    calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdSetInformation\n", 0);

    //
    //  Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonSetInformation( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdSetInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
MsCommonQueryInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying information on a file.

Arguments:

    MsfsDeviceObject - The device object to use.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    FILE_INFORMATION_CLASS fileInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;

    PVOID fsContext, fsContext2;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", irpSp->Parameters.QueryFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Decide how to handle this request.  A user can query information
    // on a DCB, ROOT_DCB, FCB, or CCB only.
    //

    switch (nodeTypeCode) {

    case MSFS_NTC_FCB:  // This is a server side handle to a mailslot file
    case MSFS_NTC_ROOT_DCB: // This is the MSFS root directory

        fcb = (PFCB)fsContext;
        break;

    default:           // This is an illegal file object to query

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);

        MsDereferenceNode( (PNODE_HEADER)fsContext );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.QueryFile.Length;
    fileInformationClass = irpSp->Parameters.QueryFile.FileInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Now acquire shared access to the FCB
    //

    MsAcquireSharedFcb( fcb );

    try {

        //
        // Based on the information class we'll do different actions.  Each
        // of the procedure that we're calling fill up as much of the
        // buffer as possible and return the remaining length, and status
        // This is done so that we can use them to build up the
        // FileAllInformation request.  These procedures do not complete the
        // IRP, instead this procedure must complete the IRP.
        //

        status = STATUS_SUCCESS;

        switch (fileInformationClass) {

        case FileAllInformation:

            AllInfo = buffer;

            MsQueryBasicInfo( fcb, &AllInfo->BasicInformation );
            MsQueryStandardInfo( fcb, &AllInfo->StandardInformation );
            MsQueryInternalInfo( fcb, &AllInfo->InternalInformation );
            MsQueryEaInfo( &AllInfo->EaInformation );
            MsQueryPositionInfo( fcb, &AllInfo->PositionInformation );

            length -= FIELD_OFFSET( FILE_ALL_INFORMATION, NameInformation );

            status = MsQueryNameInfo( fcb, &AllInfo->NameInformation, &length );

            break;

        case FileBasicInformation:

            MsQueryBasicInfo( fcb, buffer );

            length -= sizeof( FILE_BASIC_INFORMATION );
            break;

        case FileStandardInformation:

            MsQueryStandardInfo( fcb, buffer );

            length -= sizeof( FILE_STANDARD_INFORMATION );
            break;

        case FileInternalInformation:

            MsQueryInternalInfo( fcb, buffer );

            length -= sizeof( FILE_INTERNAL_INFORMATION );
            break;

        case FileEaInformation:

            MsQueryEaInfo( buffer );

            length -= sizeof( FILE_EA_INFORMATION );
            break;

        case FilePositionInformation:

            MsQueryPositionInfo( fcb, buffer );

            length -= sizeof( FILE_POSITION_INFORMATION );

            break;

        case FileNameInformation:

            status = MsQueryNameInfo( fcb, buffer, &length );
            break;

        case FileMailslotQueryInformation:

            if( nodeTypeCode == MSFS_NTC_FCB ) {

                MsQueryMailslotInfo( fcb, buffer );
                length -= sizeof( FILE_MAILSLOT_QUERY_INFORMATION );

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }


    } finally {

        MsReleaseFcb( fcb );
        MsDereferenceFcb( fcb );

        //
        // Set the information field to the number of bytes actually
        // filled in and then complete the request.
        //

        Irp->IoStatus.Information =
            irpSp->Parameters.QueryFile.Length - length;

        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
    }

    return status;
}


NTSTATUS
MsCommonSetInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for setting information on a mailslot file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    FILE_INFORMATION_CLASS fileInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PAGED_CODE();

    //
    // Get the current Irp stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.SetFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", irpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);

    //
    // Get a pointer to the FCB and ensure that this is a server side
    // handler to a mailslot file.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&fcb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "The mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonSetInformation -> %08lx\n", status );
        return status;
    }

    //
    //  Case on the type of the context, We can only set information
    //  on an FCB.
    //

    if (nodeTypeCode != MSFS_NTC_FCB) {

        MsDereferenceNode( &fcb->Header );
        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.SetFile.Length;
    fileInformationClass = irpSp->Parameters.SetFile.FileInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );

    try {

        //
        // Based on the information class we'll do different actions. Each
        // procedure that we're calling will complete the request.
        //

        switch (fileInformationClass) {

        case FileBasicInformation:

            status = MsSetBasicInfo( fcb, buffer );
            break;

        case FileMailslotSetInformation:

            status = MsSetMailslotInfo( Irp, fcb, buffer );
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }


        //
        // Directory information has changed.  Complete any notify change
        // directory requests.
        //

        MsCheckForNotify( fcb->ParentDcb, FALSE, STATUS_SUCCESS );

    } finally {

        MsReleaseFcb( fcb );
        MsDereferenceFcb( fcb );
        //
        // Complete the request.
        //

        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonSetInformation -> %08lx\n", status);
    }

    return status;
}


VOID
MsQueryBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query basic information operation.

Arguments:

    Fcb - Supplies a pointer the FCB of mailslot being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryBasicInfo...\n", 0);


    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );

    //
    // Set the various fields in the record. These times are not maintained for the root DCB0
    //

    if( Fcb->Header.NodeTypeCode == MSFS_NTC_FCB ) {
        Buffer->CreationTime = Fcb->Specific.Fcb.CreationTime;
        Buffer->LastAccessTime = Fcb->Specific.Fcb.LastAccessTime;
        Buffer->LastWriteTime = Fcb->Specific.Fcb.LastModificationTime;
        Buffer->ChangeTime = Fcb->Specific.Fcb.LastChangeTime;
    }

    Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;

    return;
}


VOID
MsQueryStandardInfo (
    IN PFCB Fcb,
    IN PFILE_STANDARD_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query standard information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

Return Value:

    VOID

--*/

{
    PDATA_QUEUE dataQueue;

    PAGED_CODE();
    DebugTrace(0, Dbg, "MsQueryStandardInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    //
    // The allocation size is the amount of quota we've charged the mailslot
    // creator.
    //

    if( Fcb->Header.NodeTypeCode == MSFS_NTC_FCB ) {
        dataQueue = &Fcb->DataQueue;
        Buffer->AllocationSize.QuadPart = dataQueue->Quota;

        //
        // The EOF is the number of written bytes ready to be read from the
        // mailslot.
        //

        Buffer->EndOfFile.QuadPart = dataQueue->BytesInQueue;

        Buffer->Directory = FALSE;
    } else {
        Buffer->Directory = TRUE;
    }
    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = TRUE;

    return;
}


VOID
MsQueryInternalInfo (
    IN PFCB Fcb,
    IN PFILE_INTERNAL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query internal information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryInternalInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_INTERNAL_INFORMATION) );

    //
    // Set the internal index number to be the address of the FCB.
    //

    Buffer->IndexNumber.QuadPart = (ULONG_PTR)Fcb;

    return;
}


VOID
MsQueryEaInfo (
    IN PFILE_EA_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query Ea information operation.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

Return Value:

    VOID - The result of this query

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryEaInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory(Buffer, sizeof(FILE_EA_INFORMATION));

    return;
}


NTSTATUS
MsQueryNameInfo (
    IN PFCB Fcb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies and receives the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    ULONG bytesToCopy;
    ULONG fileNameSize;

    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryNameInfo...\n", 0);

    //
    // See if the buffer is large enough, and decide how many bytes to copy.
    //

    *Length -= FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] );

    fileNameSize = Fcb->FullFileName.Length;

    if ( *Length >= fileNameSize ) {

        status = STATUS_SUCCESS;

        bytesToCopy = fileNameSize;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        bytesToCopy = *Length;
    }

    //
    // Copy over the file name and its length.
    //

    RtlCopyMemory (Buffer->FileName,
                   Fcb->FullFileName.Buffer,
                   bytesToCopy);

    Buffer->FileNameLength = bytesToCopy;

    *Length -= bytesToCopy;

    return status;
}


VOID
MsQueryPositionInfo (
    IN PFCB Fcb,
    IN PFILE_POSITION_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query position information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PDATA_QUEUE dataQueue;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryPositionInfo...\n", 0);

    //
    // The current byte offset is the number of bytes available to read
    // in the mailslot buffer.
    //

    if( Fcb->Header.NodeTypeCode == MSFS_NTC_FCB ) {
        dataQueue = &Fcb->DataQueue;

        Buffer->CurrentByteOffset.QuadPart = dataQueue->BytesInQueue;
    } else {
        Buffer->CurrentByteOffset.QuadPart = 0;
    }

    return;
}


VOID
MsQueryMailslotInfo (
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_QUERY_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query mailslot information operation.

Arguments:

    Fcb - Supplies the Fcb of the mailslot to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PDATA_QUEUE dataQueue;
    PDATA_ENTRY dataEntry;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryMailslotInfo...\n", 0);

    //
    // Set the fields in the record.
    //

    dataQueue = &Fcb->DataQueue;

    Buffer->MaximumMessageSize = dataQueue->MaximumMessageSize;
    Buffer->MailslotQuota = dataQueue->Quota;
    Buffer->MessagesAvailable = dataQueue->EntriesInQueue;

    Buffer->ReadTimeout = Fcb->Specific.Fcb.ReadTimeout;

    if ( dataQueue->EntriesInQueue == 0 ) {
        Buffer->NextMessageSize = MAILSLOT_NO_MESSAGE;
    } else {
        dataEntry = CONTAINING_RECORD( dataQueue->DataEntryList.Flink,
                                       DATA_ENTRY,
                                       ListEntry );

        Buffer->NextMessageSize = dataEntry->DataSize;
    }

    return;
}


NTSTATUS
MsSetBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine sets the basic information for a mailslot.

Arguments:

    Fcb - Supplies the FCB for the mailslot being modified.

    Buffer - Supplies the buffer containing the data being set.

Return Value:

    NTSTATUS - Returns our completion status.

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "SetBasicInfo...\n", 0);

    if (((PLARGE_INTEGER)&Buffer->CreationTime)->QuadPart != 0) {

        //
        //  Modify the creation time
        //

        Fcb->Specific.Fcb.CreationTime = Buffer->CreationTime;
    }

    if (((PLARGE_INTEGER)&Buffer->LastAccessTime)->QuadPart != 0) {

        //
        //  Modify the last access time
        //

        Fcb->Specific.Fcb.LastAccessTime = Buffer->LastAccessTime;
    }

    if (((PLARGE_INTEGER)&Buffer->LastWriteTime)->QuadPart != 0) {

        //
        //  Modify the last write time
        //

        Fcb->Specific.Fcb.LastModificationTime = Buffer->LastWriteTime;
    }

    if (((PLARGE_INTEGER)&Buffer->ChangeTime)->QuadPart != 0) {

        //
        //  Modify the change time
        //

        Fcb->Specific.Fcb.LastChangeTime = Buffer->ChangeTime;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MsSetMailslotInfo (
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_SET_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine sets the mailslot information for a mailslot.

Arguments:

    Irp - Pointer to an irp that contains the requestor's mode.

    Fcb - Supplies the FCB for the mailslot being modified.

    Buffer - Supplies the buffer containing the data being set.

Return Value:

    NTSTATUS - Returns our completion status.

--*/

{
    BOOLEAN fileUpdated;

    PAGED_CODE();
    DebugTrace(0, Dbg, "SetMaislotInfo...\n", 0);

    fileUpdated = FALSE;

    //
    // Check whether or not the DefaultTimeout parameter was specified.  If
    // so, then set it in the FCB.
    //

    if (ARGUMENT_PRESENT( Buffer->ReadTimeout )) {

        //
        // A read timeout parameter was specified.  Check to see whether
        // the caller's mode is kernel and if not capture the parameter inside
        // of a try...except clause.
        //

        if (Irp->RequestorMode != KernelMode) {
            try {
                ProbeForRead( Buffer->ReadTimeout,
                              sizeof( LARGE_INTEGER ),
                              sizeof( ULONG ) );

                Fcb->Specific.Fcb.ReadTimeout = *(Buffer->ReadTimeout);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Something went awry attempting to access the parameter.
                // Get the reason for the error and return it as the status
                // value from this service.
                //

                return GetExceptionCode();
            }
        } else {

            //
            // The caller's mode was kernel so simply store the parameter.
            //

            Fcb->Specific.Fcb.ReadTimeout = *(Buffer->ReadTimeout);
        }

        fileUpdated = TRUE;
    }

    //
    // Update the last change time, if necessary
    //

    if ( fileUpdated ) {
        KeQuerySystemTime( &Fcb->Specific.Fcb.LastChangeTime);
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msdata.h

Abstract:

    This module declares the global variables used by the mailslot
    file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSDATA_
#define _MSDATA_

extern LONG MsDebugTraceLevel;
extern LONG MsDebugTraceIndent;

#endif // _MSDATA_

extern PERESOURCE MsGlobalResource;
extern PERESOURCE MsPrefixTableResource;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the file read routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    15-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonRead (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsCreateWorkContext (
    PDEVICE_OBJECT DeviceObject,
    PLARGE_INTEGER Timeout,
    PFCB Fcb,
    PIRP Irp,
    PWORK_CONTEXT *ppWorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonRead )
#pragma alloc_text( PAGE, MsFsdRead )
#pragma alloc_text( PAGE, MsCreateWorkContext )
#endif

NTSTATUS
MsFsdRead (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtReadFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdRead\n", 0);

    FsRtlEnterFileSystem();

    status = MsCommonRead( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdRead -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCreateWorkContext (
    PDEVICE_OBJECT DeviceObject,
    PLARGE_INTEGER Timeout,
    PFCB Fcb,
    PIRP Irp,
    PWORK_CONTEXT *ppWorkContext
    )
/*++

Routine Description:

    This routine build a timeout work context.

Arguments:


Return Value:

    NTSTATUS - Status associated with the call

--*/
{
    PKTIMER Timer;
    PKDPC Dpc;
    PWORK_CONTEXT WorkContext;

    //
    // Allocate memory for the work context.
    //
    *ppWorkContext = NULL;

    WorkContext = MsAllocateNonPagedPoolWithQuota( sizeof(WORK_CONTEXT),
                                                   'wFsM' );
    if (WorkContext == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Timer = &WorkContext->Timer;
    Dpc = &WorkContext->Dpc;

    //
    // Fill in the work context structure.
    //

    WorkContext->Irp = Irp;
    WorkContext->Fcb = Fcb;

    WorkContext->WorkItem = IoAllocateWorkItem (DeviceObject);

    if (WorkContext->WorkItem == NULL) {
        MsFreePool (WorkContext);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Now set up a DPC and set the timer to the user specified
    // timeout.
    //

    KeInitializeTimer( Timer );
    KeInitializeDpc( Dpc, MsReadTimeoutHandler, WorkContext );

    MsAcquireGlobalLock();
    MsReferenceNode( &Fcb->Header );
    MsReleaseGlobalLock();

    *ppWorkContext = WorkContext;
    return STATUS_SUCCESS;
}


NTSTATUS
MsCommonRead (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for reading a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PIRP readIrp;
    PUCHAR readBuffer;
    ULONG readLength;
    ULONG readRemaining;
    PDATA_QUEUE readQueue;
    ULONG messageLength;

    LARGE_INTEGER timeout;

    PWORK_CONTEXT workContext = NULL;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonRead\n", 0);
    DebugTrace( 0, Dbg, "MsfsDeviceObject = %08lx\n", (ULONG)MsfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);

    //
    // Get the FCB and make sure that the file isn't closing.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&fcb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status );
        return status;
    }

    //
    // Allow read operations only if this is a server side handle to
    // a mailslot file.
    //

    if (nodeTypeCode != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "FileObject is not the correct type\n", 0);

        MsDereferenceNode( (PNODE_HEADER)fcb );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status );
        return status;
    }

    //
    // Make local copies of the input parameters to make things easier, and
    // initialize the main variables that describe the read command.
    //

    readIrp        = Irp;
    readBuffer     = Irp->UserBuffer;
    readLength     = irpSp->Parameters.Read.Length;
    readRemaining  = readLength;

    readQueue = &fcb->DataQueue;


    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );


    //
    // Ensure that this FCB still belongs to an active open mailslot.
    //

    status = MsVerifyFcb( fcb );
    if (NT_SUCCESS (status)) {

        //
        // If the read queue does not contain any write entries
        // then we either need to queue this operation or
        // fail immediately.
        //

        if (!MsIsDataQueueWriters( readQueue )) {

            //
            // There are no outstanding writes.  If the read timeout is
            // non-zero queue the read IRP, otherwise fail it.
            //

            timeout = fcb->Specific.Fcb.ReadTimeout;

            if (timeout.HighPart == 0 && timeout.LowPart == 0) {

                DebugTrace(0, Dbg, "Failing read with 0 timeout\n", 0);

                status = STATUS_IO_TIMEOUT;

                DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status );

            } else {
                //
                // Create a timer block to time the request if we need to.
                //
                if ( timeout.QuadPart != -1 ) {
                    status = MsCreateWorkContext (&MsfsDeviceObject->DeviceObject,
                                                  &timeout,
                                                  fcb,
                                                  readIrp,
                                                  &workContext);
                }


                if (NT_SUCCESS (status)) {
                    status = MsAddDataQueueEntry( readQueue,
                                                  ReadEntries,
                                                  readLength,
                                                  readIrp,
                                                  workContext );
                }
            }

        } else {

            //
            // Otherwise we have a data on a queue that contains
            // one or more write entries.  Read the data and complete
            // the read IRP.
            //

            readIrp->IoStatus = MsReadDataQueue( readQueue,
                                                 Read,
                                                 readBuffer,
                                                 readLength,
                                                 &messageLength
                                                );

            status = readIrp->IoStatus.Status;

            //
            // Update the file last access time and finish up the read IRP.
            //

            if ( NT_SUCCESS( status ) ) {
                KeQuerySystemTime( &fcb->Specific.Fcb.LastAccessTime );
            }

        }
    }

    MsReleaseFcb( fcb );

    MsDereferenceFcb( fcb );

    if (status != STATUS_PENDING) {

        if (workContext) {
            MsDereferenceFcb ( fcb );
            IoFreeWorkItem (workContext->WorkItem);
            ExFreePool (workContext);
        }

        MsCompleteRequest( readIrp, status );
    }

    DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\prefxsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefxsup.c

Abstract:

    This module implements the mailslot prefix support routines

Author:

    Manny Weiser (mannyw)    10-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_PREFXSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsFindPrefix )
#pragma alloc_text( PAGE, MsFindRelativePrefix )
#endif

PFCB
MsFindPrefix (
    IN PVCB Vcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to the root of the volume.  So all names must start
    with a "\".

Arguments:

    Vcb - Supplies the Vcb to search

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the string when the prefix no longer matches.
        For example, if the input string is "\alpha\beta" only matches the
        root directory then the remaining string is "alpha\beta".  If the
        same string matches a DCB for "\alpha" then the remaining string is
        "beta".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY prefixTableEntry;
    PFCB fcb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFindPrefix, Vcb = %08lx\n", (ULONG)Vcb);
    DebugTrace( 0, Dbg, "  String = %wZ\n", (ULONG)String);

    //
    // Find the longest matching prefix. Make sure we hold the VCB lock here
    //

    ASSERT (MsIsAcquiredExclusiveVcb(Vcb));

    prefixTableEntry = RtlFindUnicodePrefix( &Vcb->PrefixTable,
                                             String,
                                             CaseInsensitive );

    //
    // If we didn't find one then it's an error.
    //

    if (prefixTableEntry == NULL) {
        DebugDump("Error looking up a prefix", 0, Vcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Get a pointer to the FCB containing the prefix table entry.
    //

    fcb = CONTAINING_RECORD( prefixTableEntry, FCB, PrefixTableEntry );

    //
    // Tell the caller how many characters we were able to match.  We first
    // set the remaining part to the original string minus the matched
    // prefix, then we check if the remaining part starts with a backslash
    // and if it does then we remove the backslash from the remaining string.
    //

    RemainingPart->Length = String->Length - fcb->FullFileName.Length;
    RemainingPart->MaximumLength = RemainingPart->Length;
    RemainingPart->Buffer = (PWCH)((PCHAR)String->Buffer + fcb->FullFileName.Length);

    if ((RemainingPart->Length > 0) &&
        (RemainingPart->Buffer[0] == L'\\')) {

        RemainingPart->Length -= sizeof( WCHAR );
        RemainingPart->MaximumLength -= sizeof( WCHAR );
        RemainingPart->Buffer += 1;
    }

    DebugTrace(0, Dbg, "RemainingPart set to %wZ\n", (ULONG)RemainingPart);

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFindPrefix -> %08lx\n", (ULONG)fcb);

    return fcb;
}


NTSTATUS
MsFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to a input DCB, and must not start with a leading "\"
    All searching is done case insensitive.

Arguments:

    Dcb - Supplies the Dcb to start searching from

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the index into the string when the prefix no
        longer matches.  For example, if the input string is "beta\gamma"
        and the input Dcb is for "\alpha" and we only match beta then
        the remaining string is "gamma".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    USHORT nameLength;
    USHORT MaxLength;
    PWCH name;

    UNICODE_STRING fullString;
    PWCH temp;

    PFCB fcb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFindRelativePrefix, Dcb = %08lx\n", (ULONG)Dcb);
    DebugTrace( 0, Dbg, "String = %08lx\n", (ULONG)String);


    ASSERT(NodeType(Dcb) == MSFS_NTC_ROOT_DCB);

    //
    // We first need to build the complete name and then do a relative
    // search from the root.
    //

    nameLength    = String->Length;
    name          = String->Buffer;

    MaxLength = nameLength + 2*sizeof(WCHAR);
    if (MaxLength < nameLength) {
        return STATUS_INVALID_PARAMETER;
    }

    temp = MsAllocatePagedPool( MaxLength, 'nFsM' );
    if (temp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    temp[0] = L'\\';
    RtlCopyMemory (&temp[1], name, nameLength);
    temp[(nameLength / sizeof(WCHAR)) + 1] = L'\0';

    fullString.Length = nameLength + sizeof (WCHAR);
    fullString.MaximumLength = MaxLength;
    fullString.Buffer = temp;

    //
    // Find the prefix relative to the volume.
    //

    fcb = MsFindPrefix( Dcb->Vcb,
                        &fullString,
                        CaseInsensitive,
                        RemainingPart );

    //
    // Now adjust the remaining part to take care of the relative
    // volume prefix.
    //

    MsFreePool (temp);

    RemainingPart->Buffer = (PWCH)((PCH)String->Buffer + String->Length -
                                        RemainingPart->Length);

    DebugTrace(0, Dbg, "RemainingPart set to %wZ\n", (ULONG)RemainingPart);

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFindRelativePrefix -> %08lx\n", (ULONG)fcb);

    *ppFcb = fcb;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msstruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the mailslot file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSSTRUC_
#define _MSSTRUC_


//
// The VCB record is the top record in the mailslot file system in-memory
// data structure.  This structure must be allocated from non-paged pool
// and immediately follows (in memory) the Device object for the mailslot
// Structurally the layout of the data structure is as follows
//
//    +------------+
//    |MSDO        |
//    |            |
//    +------------+
//    |Vcb         |
//    |            |
//    |            |
//    +------------+
//        | ^
//        | |
//        | |
//        v |
//      +-------------+
//      |RootDcb      |
//      |             |<-+
//      +-------------+  |
//          :            |
//          :            |
//          :            |
//          v            |
//        +----------------+    +-------------------+
//        |Fcb             |    |Ccb                |
//        |                |<---|                   |
//        |                |    |                   |
//        +----------------+    +-------------------+
//                ^                       ^
//                |                       |
//           +---------+              +---------+
//           |Server FO|              |Client FO|
//           |         |              |         |
//           +---------+              +---------+
//
//
// Where there is only one VCB for the entire mailslot file system, and
// it contains a single pointer to the root DCB for the file system.  Off
// of the DCB is a queue of FCB's.  There is one FCB for every mailslot.
// There are also two additional CCB types for the VCB and the root DCB,
// and notify records for the notify change operations.
//
// A newly initialized mailslot file system only contains the VCB and
// the root DCB.  A new FCB is created when a new mailslot is created
// The file object for the creater (i.e., server end) points to the FCB
// and indicates that it is the server end.  When a user does an open on
// the mailslot its file object is set to point to a CCB which belongs
// to the FCB.
//
// A file object with a null pointer to the FsContext field is a closed or
// disconnected mailslot.
//


//
//  Each Fcb has a data queues for holding the outstanding
//  read/write requests.  The following type is used to determine
//  if the data queue contains read requests, write requests, or is empty.
//

typedef enum _QUEUE_STATE {
    ReadEntries,
    WriteEntries,
    Empty
} QUEUE_STATE;

//
// The node state.
//
// Currently only 2 states are defined.  When a node is created it's state
// is NodeStateActive.  When a cleanup IRP is processed, it set the node
// state of the corresponding node to NodeStateClosing.  Only the close
// IRP can get processed on this node.
//

typedef enum _NODE_STATE {
    NodeStateActive,
    NodeStateClosing
} NODE_STATE;

//
// The types of data entry there are.  Each corresponds to an IRP
// that can be added to a data queue.
//

typedef enum _ENTRY_TYPE {
    Read,
    ReadMailslot,
    Write,
    WriteMailslot,
    Peek
} ENTRY_TYPE;

//
// The data queue is a structure that contains the queue state, quota
// information, and the list head.  The quota information is used to
// maintain mailslot quota.
//

typedef struct _DATA_QUEUE {

    //
    // The current state of what is contained in this data queue,
    // how many bytes of read/write data there are, and how many individual
    // requests there are in the queue that contain data (includes
    // close or flush requests).
    //

    QUEUE_STATE QueueState;
    ULONG BytesInQueue;
    ULONG EntriesInQueue;

    //
    // The following two fields denote who much quota was reserved for
    // this mailslot and how much we've used up.  This is only
    // the creator quota and not the user quota.
    //

    ULONG Quota;
    ULONG QuotaUsed;


    //
    // The size of the largest message that can be written to
    // this data queue.
    //

    ULONG MaximumMessageSize;

    //
    // The queue of data entries.
    //

    LIST_ENTRY DataEntryList;


} DATA_QUEUE, *PDATA_QUEUE;

//
// The following type is used to denote where we got the memory for the
// data entry and possibly the data buffer.  We either got the memory
// from the mailslot quota, the user quota, or it is part of the next IRP
// stack location.
//

typedef enum _FROM {
    MailslotQuota,
    UserQuota,
    InIrp
} FROM;

//
// Each entry in the data queue is a data entry.  Processing an IRP
// has the potential of creating and inserting a new data entry.  If the
// memory for the entry is taken from the IRP we use the current stack
// location.
//

typedef struct _DATA_ENTRY {

    //
    // Where the data buffer came from
    //

    UCHAR From;
    CHAR Spare1;
    USHORT Spare2;

    //
    // The following field is how we connect into the queue of data entries
    //

    LIST_ENTRY ListEntry;

    //
    // The following field indicates if we still have an IRP associated
    // with this data entry that need to be completed when the remove
    // the data entry.  Note that if From is InIrp that this IRP field
    // must not be null.
    //

    PIRP Irp;

    //
    // The following two fields describe the size and location of the data
    // buffer described by this entry.  These fields are only used if the
    // type is buffered, and are ignored otherwise.
    //

    ULONG DataSize;
    PVOID DataPointer;

    //
    // Used for read data entries only.  A pointer to the work context
    // of the time out.
    //

    struct _WORK_CONTEXT *TimeoutWorkContext;

} DATA_ENTRY, *PDATA_ENTRY;



//
// The node header is used to manage standard nodes within MSFS.
//

typedef struct _NODE_HEADER {

    NODE_TYPE_CODE NodeTypeCode;  // The node type
    NODE_BYTE_SIZE NodeByteSize;  // The size of the node
    NODE_STATE NodeState;         // The current node state
    ULONG ReferenceCount;         // Number of active references to the node

} NODE_HEADER, *PNODE_HEADER;

typedef struct _VCB {

    NODE_HEADER Header;

    //
    // The filesystem name
    //

    UNICODE_STRING FileSystemName;

    //
    // The time we created the volume
    //
    LARGE_INTEGER CreationTime;

    //
    // A pointer to the root DCB for this volume
    //

    struct _FCB *RootDcb;

    //
    // A prefix table that is used for quick, prefix directed, lookup of
    // FCBs/DCBs that are part of this volume
    //

    UNICODE_PREFIX_TABLE PrefixTable;

    //
    // A resource variable to control access to the volume specific data
    // structures
    //

    ERESOURCE Resource;

    //
    // The following field is used to check share access people who want
    // to open the mailslot driver
    //

    SHARE_ACCESS ShareAccess;

} VCB, *PVCB;


//
// The Mailslot Device Object is an I/O system device object with
// additional workqueue parameters appended to the end.  There is only
// one of these records created for the entire system during system
// initialization.  The workqueue is used by the FSD to post requests to
// the filesystem.
//

typedef struct _MSFS_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    // This is the file system specific volume control block.
    //

    VCB Vcb;

} MSFS_DEVICE_OBJECT, *PMSFS_DEVICE_OBJECT;


//
// The Fcb/Dcb record corresponds to every opened mailslot and directory,
// and to every directory on an opened path.
//

typedef struct _FCB {

    //
    // Header.NodeTypeCode of this record (must be MSFS_NTC_FCB, or
    // MSFS_NTC_ROOT_DCB)
    //

    NODE_HEADER Header;

    //
    // The links for the queue of all fcbs for a specific DCB off of
    // Dcb.ParentDcbQueue.  For the root directory this queue is empty.
    //

    LIST_ENTRY ParentDcbLinks;

    //
    // A pointer to the Dcb that is the parent directory containing
    // this FCB.  If this record itself is the root dcb then this field
    // is null.
    //

    struct _FCB *ParentDcb;

    //
    // A pointer to the VCB containing this FCB.
    //

    PVCB Vcb;

    //
    // Back pointer to the server's file object.
    //

    PFILE_OBJECT FileObject;

    //
    // A pointer to the security descriptor for this mailslot.
    //

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // The following union is cased off of the node type code for the FCB.
    // is a seperate case for the directory versus file FCBs.
    //

    union {

        //
        // A Directory Control Block (DCB)
        //

        struct {

            //
            // A queue of the notify IRPs that will be completed when any
            // change is made to a file in the directory.  Queued using
            // the Tail.Overlay.ListEntry of the IRP.
            //

            LIST_ENTRY NotifyFullQueue;

            //
            // A queue of the notify IRPs that will be completed only if a
            // file is added, deleted, or renamed in the directory.  Queued
            // using the Tail.Overlay.ListEntry of the IRP.
            //

            LIST_ENTRY NotifyPartialQueue;

            //
            // A queue of all the FCBs/DCBs that are opened under this
            // DCB.
            //

            LIST_ENTRY ParentDcbQueue;


            //
            // Spinlock to protect the queues above that contain cancelable IRPs. We can't
            // synchronize with a resource because IoCancelIrp can be called at DISPATCH_LEVEL.
            //

            KSPIN_LOCK SpinLock;
        } Dcb;

        //
        // A File Control Block (FCB)
        //

        struct {

            //
            // The following field is a queue head for a list of CCBs
            // that are opened under us.
            //

            LIST_ENTRY CcbQueue;

            //
            // The default read timeout.  This is always a relative value.
            //

            LARGE_INTEGER ReadTimeout;

            //
            // File timestamps.
            //

            LARGE_INTEGER CreationTime;
            LARGE_INTEGER LastModificationTime;
            LARGE_INTEGER LastAccessTime;
            LARGE_INTEGER LastChangeTime;

        } Fcb;

    } Specific;

    //
    // The following field is used to check share access for
    // clients that want to open the file/directory.
    //

    SHARE_ACCESS ShareAccess;

    //
    // The following field is the fully qualified file name for this FCB/DCB
    // starting from the root of the volume, and last file name in the
    // fully qualified name.
    //

    UNICODE_STRING FullFileName;
    UNICODE_STRING LastFileName;

    //
    // The following field contains a prefix table entry that is used when
    // searching a volume for a name (or longest matching prefix)
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;


    //
    // The following field is used to remember the process that created this
    // mailslot.  It is needed to allocate quota and return quota.
    //

    PEPROCESS CreatorProcess;

    //
    // The following data queue is used to contain the buffered information
    // for the mailslot.
    //

    DATA_QUEUE DataQueue;

    //
    // A resource variable to control access to the File specific data
    // structures
    //

    ERESOURCE Resource;

} FCB, DCB, ROOT_DCB, *PFCB, *PDCB, *PROOT_DCB;



//
// The CCB record is allocated for every cliennt side open of a mailslot.
//

typedef struct _CCB {

    //
    // Header.NodeTypeCode of this record (must be MSFS_NTC_CCB).
    //

    NODE_HEADER Header;

    //
    // The following field is a list entry for the list of ccb that we
    // are a member of.
    //

    LIST_ENTRY CcbLinks;

    //
    // A pointer to the FCB, or VCB that we are tied to
    //

    PFCB Fcb;

    //
    // Pointers to the file object of the client has opened this file.
    //

    PFILE_OBJECT FileObject;

    //
    // A resource to control access to the CCB.
    //

    ERESOURCE Resource;

} CCB, *PCCB;


//
// The root DCB CCB record is allocated for every opened instance of the
// root dcb.  This record is pointed at by FsContext2.
//

typedef struct _ROOT_DCB_CCB {

    //
    // Header.NodeTypeCode of this record (must be MSFS_NTC_ROOT_DCB_CCB).
    //

    NODE_HEADER Header;

    //
    // A pointer to the VCB containing this CCB.
    //

    PVCB Vcb;

    //
    // Pointer to the DCB for this CCB
    //
    PROOT_DCB Dcb;

    //
    // The following field is a count of the last index returned
    // by query directory.
    //

    ULONG IndexOfLastCcbReturned;

    //
    // The following string is used as a query template for directory
    // query operations
    //

    PUNICODE_STRING QueryTemplate;

} ROOT_DCB_CCB, *PROOT_DCB_CCB;

//
// A work context contains the information needed to do read timeouts.
//

typedef struct _WORK_CONTEXT {

    //
    // Pointer to unload safe work item.
    //

    PIO_WORKITEM WorkItem;

    //
    // A pointer to the IRP for this operation.
    //

    PIRP Irp;

    //
    // A referenced pointer to the FCB that will process this operation.
    //

    PFCB Fcb;

    //
    // A timer and dpc tourine to accomplish the timeout.
    //

    KTIMER Timer;

    KDPC Dpc;

} WORK_CONTEXT, *PWORK_CONTEXT;

#endif // _MSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\readsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    readsup.c

Abstract:

    This module implements the read support routine.  This is a common
    read function that is called to do read and peek.

Author:

    Manny Weiser (mannyw)    15-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsReadDataQueue )
#pragma alloc_text( PAGE, MsTimeoutRead )
#endif

IO_STATUS_BLOCK
MsReadDataQueue (
    IN PDATA_QUEUE ReadQueue,
    IN ENTRY_TYPE Operation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    OUT PULONG MessageLength
    )

/*++

Routine Description:

    This function reads data from the read queue and fills up the
    read buffer.  It will also dequeue the data entry if this is not
    a peek operation.

    It will only be called if there is at least one message to read.


Arguments:

    ReadQueue - Provides the read queue to examine.  Its state must
        already be set to WriteEntries.

    Operation - Indicates the type of operation to perform.  If the
        operation is Peek, the write data entry is not dequeued.

    ReadBuffer - Supplies a buffer to receive the data

    ReadLength - Supplies the length, in bytes, of ReadBuffer.

    MessageLength - Returns the full size of the message, even if the
        read buffer is not large enough to contain the entire message.

Return Value:

    IO_STATUS_BLOCK - Indicates the result of the operation.

--*/

{
    IO_STATUS_BLOCK iosb;

    PLIST_ENTRY listEntry;
    PDATA_ENTRY dataEntry;
    PFCB fcb;

    PUCHAR writeBuffer;
    ULONG writeLength;

    ULONG amountRead;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsReadDataQueue\n", 0);
    DebugTrace( 0, Dbg, "ReadQueue     = %08lx\n", (ULONG)ReadQueue);
    DebugTrace( 0, Dbg, "Operation     = %08lx\n", Operation);
    DebugTrace( 0, Dbg, "ReadBuffer    = %08lx\n", (ULONG)ReadBuffer);
    DebugTrace( 0, Dbg, "ReadLength    = %08lx\n", ReadLength);

    //
    // Read the first message out of the data queue.
    //

    iosb.Status = STATUS_SUCCESS;
    iosb.Information = 0;

    listEntry = MsGetNextDataQueueEntry( ReadQueue );
    ASSERT( listEntry != &ReadQueue->DataEntryList );

    dataEntry = CONTAINING_RECORD( listEntry, DATA_ENTRY, ListEntry );

    //
    // Calculate how much data is in this entry.
    //

    writeBuffer = dataEntry->DataPointer;
    writeLength = dataEntry->DataSize;

    DebugTrace(0, Dbg, "WriteBuffer    = %08lx\n", (ULONG)writeBuffer);
    DebugTrace(0, Dbg, "WriteLength    = %08lx\n", writeLength);

    //
    // Fail this operation, if it is a read and the buffer is not large
    // enough.
    //

    if (ReadLength < writeLength) {

        if (Operation != Peek) {
            iosb.Information = 0;
            iosb.Status = STATUS_BUFFER_TOO_SMALL;

            return iosb;
        }
        iosb.Status = STATUS_BUFFER_OVERFLOW;

        DebugTrace(0, Dbg, "Overflowed peek buffer\n", 0);

        amountRead = ReadLength;
    } else {
        amountRead = writeLength;
    }


    //
    // Copy data from the write buffer at write offset to the
    // read buffer by the mininum of write remaining or read length
    //
    // This copy may take an exception and thats why this call needs to be enclosed
    // in try/except.
    //

    try {

        RtlCopyMemory (ReadBuffer,
                       writeBuffer,
                       amountRead);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        iosb.Status = GetExceptionCode ();
        return iosb;

    }

    *MessageLength = dataEntry->DataSize;


    //
    // If write length is larger than read length, this must be an
    // overflowed peek.
    //

    if (writeLength <= ReadLength) {
        //
        // The write entry is done so remove it from the read
        // queue, if this is not a peek operation.  This might
        // also have an IRP that needs to be completed.
        //

        if (Operation != Peek) {

            PIRP writeIrp;

            if ((writeIrp = MsRemoveDataQueueEntry( ReadQueue,
                                                    dataEntry )) != NULL) {
                //
                // Writes don't get queued. This is an error
                //
                KeBugCheckEx( MAILSLOT_FILE_SYSTEM,
                              1,
                              (ULONG_PTR) writeIrp,
                              (ULONG_PTR) ReadQueue,
                              (ULONG_PTR) dataEntry );

            }
        }

        DebugTrace(0, Dbg, "Successful mailslot read\n", 0);

        //
        // Indicate success.
        //

        iosb.Status = STATUS_SUCCESS;
    }


    DebugTrace(0, Dbg, "Amount read = %08lx\n", amountRead);

    iosb.Information = amountRead;
    DebugTrace(-1, Dbg, "MsReadDataQueue -> iosb.Status = %08lx\n", iosb.Status);
    return iosb;
}


VOID
MsTimeoutRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine times out a read operation.  It gains exclusive
    access to the FCB, and searches the data queue of read operations.

    If the timed out read operation is not found, it is assumed that
    a write IRP completed the read after the time out DPC ran, but
    before this function could complete the read IRP.

Arguments:

    Context - a pointer to our WorkContext

Return Value:

    None.

--*/

{
    PDATA_QUEUE dataQueue;
    PLIST_ENTRY listEntry;
    PIRP queuedIrp;
    PDATA_ENTRY dataEntry;
    PWORK_CONTEXT workContext;
    PIRP irp;
    PFCB fcb;

    PAGED_CODE();

    //
    // Reference our local variables.
    //

    workContext = (PWORK_CONTEXT)Context;

    fcb = workContext->Fcb;

    dataQueue = &fcb->DataQueue;
    //
    // Acquire exclusive access to the FCB.  This must succeed.
    //

    MsAcquireExclusiveFcb( fcb );

    //
    // There are two cases to consider here. Either this timer is the first completion
    // event for this IRP or we werent but we started running before they could cancel the timer.
    // When the second case is detected the other thread NULL's out the IRP pointer.
    //
    irp = workContext->Irp;
    if (irp) {


        dataEntry = (PDATA_ENTRY)IoGetNextIrpStackLocation( irp );
        //
        // Nobody else should touch this once we release the lock.
        //
        dataEntry->TimeoutWorkContext = NULL;

        //
        // If cancel isn't active for the IRP.
        //

        irp = MsRemoveDataQueueEntry( dataQueue, dataEntry );
    }


    //
    // Release the FCB, and derefernce it.
    //

    MsReleaseFcb( fcb );
    MsDereferenceFcb( fcb );

    //
    // Free the work context and the work item. We have to do this unconditionaly
    // if we started running
    //
    IoFreeWorkItem (workContext->WorkItem);
    ExFreePool( workContext );

    if (irp != NULL) {
        DebugTrace(0, Dbg, "Completing IRP %p\n", irp );

        MsCompleteRequest( irp, STATUS_IO_TIMEOUT );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msdebug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msdebug.c

Abstract:

    This module declares the debug functions used by the mailslot
    file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSDEBUG_
#define _MSDEBUG_

//
//  The mailslot debug levels:
//
//      0x00000000      Always gets printed (used when about to bug check)

#ifdef MSDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_CREATE               (0x00000008)
#define DEBUG_TRACE_CLOSE                (0x00000010)
#define DEBUG_TRACE_READ                 (0x00000020)
#define DEBUG_TRACE_WRITE                (0x00000040)
#define DEBUG_TRACE_FILEINFO             (0x00000080)
#define DEBUG_TRACE_CLEANUP              (0x00000100)
#define DEBUG_TRACE_DIR                  (0x00000200)
#define DEBUG_TRACE_FSCONTROL            (0x00000400)
#define DEBUG_TRACE_CREATE_MAILSLOT      (0x00000800)
#define DEBUG_TRACE_SEINFO               (0x00001000)
#define DEBUG_TRACE_0x00002000           (0x00002000)
#define DEBUG_TRACE_0x00004000           (0x00004000)
#define DEBUG_TRACE_0x00008000           (0x00008000)
#define DEBUG_TRACE_0x00010000           (0x00010000)
#define DEBUG_TRACE_DEVIOSUP             (0x00020000)
#define DEBUG_TRACE_VERIFY               (0x00040000)
#define DEBUG_TRACE_WORK_QUEUE           (0x00080000)
#define DEBUG_TRACE_READSUP              (0x00100000)
#define DEBUG_TRACE_WRITESUP             (0x00200000)
#define DEBUG_TRACE_STATESUP             (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)
#define DEBUG_TRACE_PREFXSUP             (0x01000000)
#define DEBUG_TRACE_CNTXTSUP             (0x02000000)
#define DEBUG_TRACE_DATASUP              (0x04000000)
#define DEBUG_TRACE_DPC                  (0x08000000)
#define DEBUG_TRACE_REFCOUNT             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER       (0x40000000)
#define DEBUG_TRACE_FSP_DUMP             (0x80000000)

extern LONG MsDebugTraceLevel;
extern LONG MsDebugTraceIndent;

#define DebugDump(STR,LEVEL,PTR) {                         \
    ULONG _i;                                              \
    VOID MsDump(IN PVOID Ptr);                                         \
    if (((LEVEL) == 0) || (MsDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                  \
        DbgPrint("%08lx:",_i);                             \
        DbgPrint(STR);                                     \
        if (PTR != NULL) {MsDump(PTR);}                    \
        DbgBreakPoint();                                   \
    }                                                      \
}

#define DebugTrace(i,l,x,y)              _DebugTrace(i,l,x,(ULONG)y)

//
//  The following routine and macro is used to catch exceptions in
//  try except statements.  It allows us to catch the exception before
//  executing the exception handler.  The exception catcher procedure is
//  declared in msdata.c
//

LONG MsExceptionCatcher (IN PSZ String);

#define Exception(STR)                   (MsExceptionCatcher(STR))

#else

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#define Exception(STR)                   (EXCEPTION_EXECUTE_HANDLER)

#define DebugTrace(I,L,X,Y)                              {NOTHING;}

#endif // MSDBG

#endif // _MSDEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msfunc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msfuncs.h

Abstract:

    This module defines all of the globally used procedures in the
    mailslot file system.  It also defines the functions that are
    implemented as macros.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSFUNCS_
#define _MSFUNCS_


//
// Internal mailslot data Structure Routines, implemented in strucsup.c.
// These routines maniuplate the in memory data structures.
//

NTSTATUS
MsInitializeData (
    VOID
    );

VOID
MsUninitializeData(
    VOID
    );

VOID
MsInitializeVcb (
    IN PVCB Vcb
    );

VOID
MsDeleteVcb (
    IN PVCB Vcb
    );

PROOT_DCB
MsCreateRootDcb (
    IN PVCB Vcb
    );

VOID
MsDeleteRootDcb (
    IN PROOT_DCB Dcb
    );

NTSTATUS
MsCreateFcb (
    IN  PVCB Vcb,
    IN  PDCB ParentDcb,
    IN  PUNICODE_STRING FileName,
    IN  PEPROCESS CreatorProcess,
    IN  ULONG MailslotQuota,
    IN  ULONG MaximumMessageSize,
    OUT PFCB *ppFcb
    );

VOID
MsDeleteFcb (
    IN PFCB Fcb
    );

NTSTATUS
MsCreateCcb (
    IN  PFCB Fcb,
    OUT PCCB *ppCcb
    );

PROOT_DCB_CCB
MsCreateRootDcbCcb (
    IN PROOT_DCB RootDcb,
    IN PVCB Vcb
    );

VOID
MsDeleteCcb (
    IN PCCB Ccb
    );

VOID
MsDereferenceNode (
    IN PNODE_HEADER NodeHeader
    );

VOID
MsDereferenceVcb (
    IN PVCB Vcb
    );

VOID
MsReferenceVcb (
    IN PVCB Vcb
    );

VOID
MsReferenceRootDcb (
    IN PROOT_DCB RootDcb
    );


VOID
MsDereferenceRootDcb (
    IN PROOT_DCB RootDcb
    );

VOID
MsDereferenceFcb (
    IN PFCB Fcb
    );

VOID
MsRemoveFcbName (
    IN PFCB Fcb
    );

VOID
MsDereferenceCcb (
    IN PCCB Ccb
    );


//
// Data queue support routines, implemented in DataSup.c
//

NTSTATUS
MsInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process,
    IN ULONG Quota,
    IN ULONG MaximumMessageSize
    );

VOID
MsUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process
    );

NTSTATUS
MsAddDataQueueEntry (
    IN  PDATA_QUEUE DataQueue,
    IN  QUEUE_STATE Who,
    IN  ULONG DataSize,
    IN  PIRP Irp,
    IN  PWORK_CONTEXT WorkContext
    );

PIRP
MsRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PDATA_ENTRY DataEntry
    );

VOID
MsRemoveDataQueueIrp (
    IN PIRP Irp,
    IN PDATA_QUEUE DataQueue
    );


//
// The follow routines provide common read/write data queue support
// for buffered read/write, and peek
//

IO_STATUS_BLOCK
MsReadDataQueue (                       // implemented in ReadSup.c
    IN PDATA_QUEUE ReadQueue,
    IN ENTRY_TYPE Operation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    OUT PULONG MessageLength
    );

NTSTATUS
MsWriteDataQueue (                      // implemented in WriteSup.c
    IN PDATA_QUEUE WriteQueue,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength
    );
extern
PIRP
MsResetCancelRoutine(
    IN PIRP Irp
    );


//
// Largest matching prefix searching routines, implemented in PrefxSup.c
//

PFCB
MsFindPrefix (
    IN PVCB Vcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    );

NTSTATUS
MsFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *Fcb
    );


//
// The following routines are used to manipulate the fscontext fields of
// a file object, implemented in FilObSup.c
//

VOID
MsSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    );

NODE_TYPE_CODE
MsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    );


//
// The following routines are used to manipulate the input buffers and are
// implemented in deviosup.c
//

VOID
MsMapUserBuffer (
    IN OUT PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *UserBuffer
    );


//
//  Miscellaneous support routines
//

//
// This is function is called at DPC level if a read timer expires.
//

VOID
MsReadTimeoutHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// This macro returns TRUE if a flag in a set of flags is on and FALSE
// otherwise.
//

#ifdef FlagOn
#undef FlagOn
#endif

#define FlagOn(Flags,SingleFlag) (                          \
    (BOOLEAN)(((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )

//
// This macro takes a pointer (or ulong) and returns its rounded up word
// value.
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
// This macro takes a pointer (or ulong) and returns its rounded up longword
// value.
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
// This macro takes a pointer (or ulong) and returns its rounded up quadword
// value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
// The following types and macros are used to help unpack the packed and
// misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
// This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
// This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
// This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
// The following routines/macros are used for gaining shared and exclusive
// access to the global/vcb data structures.  The routines are implemented
// in ResrcSup.c.  There is a global resources that everyone tries to take
// out shared to do their work, with the exception of mount/dismount which
// take out the global resource exclusive.  All other resources only work
// on their individual item.  For example, an Fcb resource does not take out
// a Vcb resource.  But the way the file system is structured we know
// that when we are processing an Fcb other threads cannot be trying to remove
// or alter the Fcb, so we do not need to acquire the Vcb.
//
// The procedures/macros are:
//
//         Macro          Vcb     Fcb     Ccb     Subsequent macros
//
// AcquireExclusiveVcb    Read    None    None    ReleaseVcb
//                        Write
//
// AcquireSharedVcb       Read    None    None    ReleaseVcb
//
// AcquireExclusiveFcb    None    Read    None    ReleaseFcb
//                                Write
//
// AcquireSharedFcb       None    Read    None    ReleaseFcb
//
// AcquireExclusiveCcb    None    None    Read    ReleaseCcb
//                                        Write
//
// AcquireSharedCcb       None    None    Read    ReleaseCcb
//
// ReleaseVcb
//
// ReleaseFcb
//
// ReleaseCcb
//
//
// VOID
// MsAcquireExclusiveVcb (
//     IN PVCB Vcb
//     );
//
// VOID
// MsAcquireSharedVcb (
//     IN PVCB Vcb
//      );
//
// VOID
// MsAcquireExclusiveFcb (
//     IN PFCB Fcb
//     );
//
// VOID
// MsAcquireSharedFcb (
//     IN PFCB Fcb
//     );
//
// VOID
// MsAcquireExclusiveCcb (
//     IN PCCB Ccb
//     );
//
// VOID
// MsAcquireSharedCcb (
//     IN PCCB Ccb
//     );
//
// VOID
// MsReleaseVcb (
//     IN PVCB Vcb
//     );
//
// VOID
// MsReleaseFcb (
//     IN PFCB Fcb
//     );
//
// VOID
// MsReleaseCcb (
//     IN PCCB NonpagedCcb
//     );
//

#define MsAcquireGlobalLock() ((VOID)                          \
    ExAcquireResourceExclusiveLite( MsGlobalResource, TRUE )      \
)

#define MsReleaseGlobalLock() (                                \
    ExReleaseResourceLite( MsGlobalResource )                     \
)


#define MsAcquireExclusiveVcb(VCB) ((VOID)                     \
    ExAcquireResourceExclusiveLite( &(VCB)->Resource, TRUE )       \
)

#define MsAcquireSharedVcb(VCB) ((VOID)                        \
    ExAcquireResourceSharedLite( &(VCB)->Resource, TRUE )          \
)

#define MsIsAcquiredExclusiveVcb(VCB) ExIsResourceAcquiredExclusiveLite( &(VCB)->Resource )

#define MsAcquireExclusiveFcb(FCB) ((VOID)                     \
    ExAcquireResourceExclusiveLite( &(FCB)->Resource, TRUE )       \
)

#define MsAcquireSharedFcb(FCB) ((VOID)                        \
    ExAcquireResourceSharedLite( &(FCB)->Resource, TRUE )          \
)

#define MsReleaseVcb(VCB) {                                    \
    ExReleaseResourceLite( &((VCB)->Resource) );                   \
}

#define MsReleaseFcb(FCB) {                                    \
    ExReleaseResourceLite( &((FCB)->Resource) );                   \
}


//
// The FSD Level dispatch routines.   These routines are called by the
// I/O system via the dispatch table in the Driver Object.
//
// They each accept as input a pointer to a device object (actually most
// expect an msfs device object), and a pointer to the IRP.
//

NTSTATUS
MsFsdCreate (                           //  implemented in Create.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdCreateMailslot (                   //  implemented in Createms.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdClose (                            //  implemented in Close.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdRead (                             //  implemented in Read.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdWrite (                            //  implemented in Write.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdQueryInformation (                 //  implemented in FileInfo.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdSetInformation (                   //  implemented in FileInfo.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdQueryVolumeInformation (           //  implemented in VolInfo.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdCleanup (                          //  implemented in Cleanup.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

VOID
MsCancelTimer (                         //  implemented in Cleanup.c
    IN PDATA_ENTRY DataEntry
    );

NTSTATUS
MsFsdDirectoryControl (                 //  implemented in Dir.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdFsControl (                //  implemented in FsContrl.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );


//
// The node verification functions.  These functions verify that a node
// is still active.
//

NTSTATUS
MsVerifyFcb (
    IN PFCB Fcb
    );

NTSTATUS
MsVerifyCcb (
    IN PCCB Ccb
    );

NTSTATUS
MsVerifyDcbCcb (
    IN PROOT_DCB_CCB RootDcb
    );

//
// Miscellaneous routines.
//

VOID
MsTimeoutRead (                //  implemented in readsup.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
MsCheckForNotify (                      //  implemented in Dir.c
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN NTSTATUS FinalStatus
    );

VOID
MsFlushNotifyForFile (                      //  implemented in Dir.c
    IN PDCB Dcb,
    IN PFILE_OBJECT FileObject
    );
//
// The following functions are used for MSFS exception handling
//

LONG
MsExceptionFilter (
    IN NTSTATUS ExceptionCode
    );

NTSTATUS
MsProcessException (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

//
// The following macro is used by the FSP and FSD routines to complete
// an IRP.
//

#define MsCompleteRequest(IRP,STATUS) {      \
    FsRtlCompleteRequest( (IRP), (STATUS) ); \
}

//
// Reference count macros.  These macro can be called only with
// MsGlobalResource held.
//

#define MsReferenceNode( nodeHeader )     (nodeHeader)->ReferenceCount++;

//
// Debugging functions.
//

#ifdef MSDBG

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    );

#endif

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

//
// The following macros queries the state of data queues
//

//
// BOOLEAN
// MsIsDataQueueEmpty (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine indicates to the caller if the data queue is empty.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried
//
// Return Value:
//
//     BOOLEAN - TRUE if the queue is empty and FALSE otherwise.
//

#define MsIsDataQueueEmpty( _dataQueue )    \
    ((BOOLEAN) IsListEmpty(&(_dataQueue)->DataEntryList))

//
// BOOLEAN
// MsIsDataQueueReaders (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine indicates to the caller if the data queue is full of
//     read requests.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried
//
// Return Value:
//
//     BOOLEAN - TRUE if the queue contains read requests and FALSE otherwise
//

#define MsIsDataQueueReaders( _dataQueue )    \
    ((BOOLEAN) ((_dataQueue)->QueueState == ReadEntries))

//
// BOOLEAN
// MsIsDataQueueWriters (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine indicates to the caller if the data queue is full of
//     write requests.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried
//
// Return Value:
//
//     BOOLEAN - TRUE if the queue contains write requests and FALSE otherwise

#define MsIsDataQueueWriters( _dataQueue )    \
    ((BOOLEAN)((_dataQueue)->QueueState == WriteEntries))

//
// PLIST_ENTRY
// MsGetNextDataQueueEntry (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine will return a pointer to the next data queue entry in the
//     indicated data queue without changing any of the data queue.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried.
//
// Return Value:
//
//    PLIST_ENTRY - Returns a pointer to the next data queue entry.
//

#define MsGetNextDataQueueEntry( _dataQueue )   \
    (_dataQueue)->DataEntryList.Flink

#define MsIrpDataQueue(Irp) \
    ((Irp)->Tail.Overlay.DriverContext[0])

#define MsIrpChargedQuota(Irp) \
    ((Irp)->Tail.Overlay.DriverContext[1])

#define MsIrpWorkContext(Irp) \
    ((Irp)->Tail.Overlay.DriverContext[2])


//
// PVOID
// MsAllocatePagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocatePagedPool( Size, Tag) \
    ExAllocatePoolWithTag( PagedPool, Size, Tag )

#define MsAllocatePagedPoolCold( Size, Tag) \
    ExAllocatePoolWithTag( (PagedPool|POOL_COLD_ALLOCATION), Size, Tag )

//
// PVOID
// MsAllocateNonPagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocateNonPagedPool( Size, Tag) \
    ExAllocatePoolWithTag( NonPagedPool, Size, Tag )

//
// PVOID
// MsAllocatePagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to charged paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocatePagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )

#define MsAllocatePagedPoolWithQuotaCold( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE|POOL_COLD_ALLOCATION, Size, Tag )

//
// PVOID
// MsAllocateNonPagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a charged pointer to non-paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocateNonPagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )


//
// VOID
// MsFreePool (
//    IN PVOID Mem)
//
// Routine Description:
//
//
//
// Arguments:
//
//     Mem - Memory to be freed
//
// Return Value:
//
//    None
//
#define MsFreePool(Mem) ExFreePool (Mem)


#endif // _MSFUNCS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\msinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msinit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    mailslot file system.

Author:

    Manny Weiser (mannyw)    7-Jan-91

Revision History:

    Neill Clift (NeillC)     22-Jan-2000
    Major rework, Do raise exceptions, fix locking, fix cancel logic, fix validation and error handling.

--*/

#include "mailslot.h"
#include "zwapi.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MsfsUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, MsfsUnload )
#endif

PMSFS_DEVICE_OBJECT msfsDeviceObject = NULL;






NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the mailslot file system
    device driver.  This routine creates the device object for the mailslot
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Initialize MSFS global data.
    //

    status = MsInitializeData();
    if (!NT_SUCCESS (status)) {
        return status;
    }

    //
    // Set driver to be completely paged out.
    //
    MmPageEntireDriver(DriverEntry);

    //
    // Create the MSFS device object.
    //

    RtlInitUnicodeString( &nameString, L"\\Device\\Mailslot" );
    status = IoCreateDevice( DriverObject,
                             sizeof(MSFS_DEVICE_OBJECT)-sizeof(DEVICE_OBJECT),
                             &nameString,
                             FILE_DEVICE_MAILSLOT,
                             0,
                             FALSE,
                             &deviceObject );

    if (!NT_SUCCESS( status )) {

        MsUninitializeData();

        return status;
    }

    DriverObject->DriverUnload = MsfsUnload;
    //
    //  Now because we use the irp stack for storing a data entry we need
    //  to bump up the stack size in the device object we just created.
    //

    deviceObject->StackSize += 1;

    //
    // Note that because of the way data copying is done, we set neither
    // the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    // data is not buffered we may set up for Direct I/O by hand.
    //

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
        (PDRIVER_DISPATCH)MsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] =
        (PDRIVER_DISPATCH)MsFsdCreateMailslot;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =
        (PDRIVER_DISPATCH)MsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ] =
        (PDRIVER_DISPATCH)MsFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] =
        (PDRIVER_DISPATCH)MsFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
        (PDRIVER_DISPATCH)MsFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] =
        (PDRIVER_DISPATCH)MsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] =
        (PDRIVER_DISPATCH)MsFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] =
        (PDRIVER_DISPATCH)MsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL] =
        (PDRIVER_DISPATCH)MsFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] =
        (PDRIVER_DISPATCH)MsFsdFsControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY] =
        (PDRIVER_DISPATCH)MsFsdQuerySecurityInfo;
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY] =
        (PDRIVER_DISPATCH)MsFsdSetSecurityInfo;

#ifdef _PNP_POWER_
    //
    // Mailslots should probably have a SetPower handler to ensure
    // that the driver is not powered down while a guarateed
    // mailslot delivery is in progress.   For now, we'll just
    // ignore this and let the machine set power.
    //

    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif


    //
    // Initialize stuff
    //

    msfsDeviceObject = (PMSFS_DEVICE_OBJECT)deviceObject;

    //
    // Now initialize the Vcb, and create the root dcb
    //

    MsInitializeVcb( &msfsDeviceObject->Vcb );

    //
    // Createt the root DCB
    //
    if (MsCreateRootDcb( &msfsDeviceObject->Vcb ) == NULL) {

        MsDereferenceVcb (&msfsDeviceObject->Vcb);
        IoDeleteDevice (&msfsDeviceObject->DeviceObject);
        MsUninitializeData();

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Return to the caller.
    //

    return( status );
}

VOID
MsfsUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++
      
Routine Description:
      
    This routine cleans up all of the memory associated with
    the driver.
      
Arguments:
      
    DriverObject    - Supplies the driver object controlling the device.
      
Return Value:
      
    None.
      
--*/
{
    UNICODE_STRING us;
    //
    // Remove the initial reference to the VCB. This should be the last.
    //
    ASSERT ( msfsDeviceObject->Vcb.Header.ReferenceCount == 1 );

    MsDereferenceVcb (&msfsDeviceObject->Vcb);

    RtlInitUnicodeString (&us, L"\\??\\MAILSLOT"); // Created by SMSS
    IoDeleteSymbolicLink (&us);

    //
    // Delete the device object
    //
    IoDeleteDevice (&msfsDeviceObject->DeviceObject);

    //
    // Release the globals
    //
    MsUninitializeData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\strucsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    This module implements the mailslot in-memory data structure
    manipulation routines.

Author:

    Manny Weiser (mannyw)    9-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, MsInitializeVcb )
#pragma alloc_text( INIT, MsCreateRootDcb )
#pragma alloc_text( PAGE, MsCreateCcb )
#pragma alloc_text( PAGE, MsCreateFcb )
#pragma alloc_text( PAGE, MsCreateRootDcbCcb )
#pragma alloc_text( PAGE, MsDeleteCcb )
#pragma alloc_text( PAGE, MsDeleteFcb )
#pragma alloc_text( PAGE, MsDeleteRootDcb )
#pragma alloc_text( PAGE, MsDeleteVcb )
#pragma alloc_text( PAGE, MsDereferenceCcb )
#pragma alloc_text( PAGE, MsDereferenceFcb )
#pragma alloc_text( PAGE, MsDereferenceNode )
#pragma alloc_text( PAGE, MsDereferenceRootDcb )
#pragma alloc_text( PAGE, MsDereferenceVcb )
#pragma alloc_text( PAGE, MsRemoveFcbName )
#pragma alloc_text( PAGE, MsReferenceVcb )
#pragma alloc_text( PAGE, MsReferenceRootDcb )
#endif

WCHAR FileSystemName[] = MSFS_NAME_STRING;

//
// !!! This module allocates all structures containing a resource from
//     non-paged pool.  The resources is the only field which must be
//     allocated from non-paged pool.  Consider allocating the resource
//     separately for greater efficiency.
//

VOID
MsInitializeVcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine initializes new Vcb record. The Vcb record "hangs" off the
    end of the Msfs device object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsInitializeVcb, Vcb = %08lx\n", (ULONG)Vcb);

    //
    // We start by first zeroing out all of the VCB, this will guarantee
    // that any stale data is wiped clean.
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    // Set the node type code, node byte size, and reference count.
    //

    Vcb->Header.NodeTypeCode = MSFS_NTC_VCB;
    Vcb->Header.NodeByteSize = sizeof(VCB);
    Vcb->Header.ReferenceCount = 1;
    Vcb->Header.NodeState = NodeStateActive;

    //
    // Initialize the Volume name
    //

    Vcb->FileSystemName.Buffer = FileSystemName;
    Vcb->FileSystemName.Length = sizeof( FileSystemName ) - sizeof( WCHAR );
    Vcb->FileSystemName.MaximumLength = sizeof( FileSystemName );

    //
    // Initialize the Prefix table
    //

    RtlInitializeUnicodePrefix( &Vcb->PrefixTable );

    //
    // Initialize the resource variable for the VCB.
    //

    ExInitializeResourceLite( &Vcb->Resource );

    //
    // Record creation time.
    //
    KeQuerySystemTime (&Vcb->CreationTime);
    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsInitializeVcb -> VOID\n", 0);

    return;
}


VOID
MsDeleteVcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine removes the VCB record from our in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    Vcb - Supplies the Vcb to be removed

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteVcb, Vcb = %08lx\n", (ULONG)Vcb);

    ASSERT (Vcb->Header.ReferenceCount == 0);

    //
    // Remove the Root Dcb
    //

    if (Vcb->RootDcb != NULL) {

        ASSERT (Vcb->RootDcb->Header.ReferenceCount == 1 );

        MsDereferenceRootDcb ( Vcb->RootDcb );
    }

    //
    // Uninitialize the resource variable for the VCB.
    //

    ExDeleteResourceLite( &Vcb->Resource );

    //
    // And zero out the Vcb, this will help ensure that any stale data is
    // wiped clean
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsDeleteVcb -> VOID\n", 0);

    return;
}


PROOT_DCB
MsCreateRootDcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root DCB record
    into the in memory data structure.

Arguments:

    Vcb - Supplies the Vcb to associate the new DCB under

Return Value:

    PROOT_DCB - returns pointer to the newly allocated root DCB.

--*/

{
    PROOT_DCB rootDcb;
    PWCH Name;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateRootDcb, Vcb = %08lx\n", (ULONG)Vcb);

    //
    // Make sure we don't already have a root dcb for this vcb
    //

    rootDcb = Vcb->RootDcb;

    if (rootDcb != NULL) {
        DebugDump("Error trying to create multiple root dcbs\n", 0, Vcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Allocate a new DCB and zero its fields.
    //

    rootDcb = MsAllocateNonPagedPool ( sizeof(DCB), 'DFsM' );
    if (rootDcb == NULL) {
        return NULL;
    }

    RtlZeroMemory( rootDcb, sizeof(DCB));

    //
    // Set the proper node type code, node byte size, and reference count.
    //

    rootDcb->Header.NodeTypeCode = MSFS_NTC_ROOT_DCB;
    rootDcb->Header.NodeByteSize = sizeof(ROOT_DCB);
    rootDcb->Header.ReferenceCount = 1;
    rootDcb->Header.NodeState = NodeStateActive;

    //
    // The root Dcb has an empty parent dcb links field
    //

    InitializeListHead( &rootDcb->ParentDcbLinks );


    //
    // Initialize the notify queues, and the parent dcb queue.
    //

    InitializeListHead( &rootDcb->Specific.Dcb.NotifyFullQueue );
    InitializeListHead( &rootDcb->Specific.Dcb.NotifyPartialQueue );
    InitializeListHead( &rootDcb->Specific.Dcb.ParentDcbQueue );

    //
    // Initizlize spinlock that protects IRP queues that conatin cancelable IRPs.
    //
    KeInitializeSpinLock (&rootDcb->Specific.Dcb.SpinLock);

    //
    // Set the full file name
    //

    Name = MsAllocatePagedPoolCold(2 * sizeof(WCHAR), 'DFsM' );
    if (Name == NULL) {
        ExFreePool (rootDcb);
        return NULL;
    }

    Name[0] = L'\\';
    Name[1] = L'\0';

    rootDcb->FullFileName.Buffer = Name;
    rootDcb->FullFileName.Length = sizeof (WCHAR);
    rootDcb->FullFileName.MaximumLength = 2*sizeof (WCHAR);

    rootDcb->LastFileName = rootDcb->FullFileName;


    //
    // Set the Vcb and give it a pointer to the new root DCB.
    //

    rootDcb->Vcb = Vcb;
    Vcb->RootDcb = rootDcb;
    //
    // Initialize the resource variable.
    //

    ExInitializeResourceLite( &(rootDcb->Resource) );

    //
    // Insert this DCB into the prefix table. No locks needed in initialization phase.
    //

    if (!RtlInsertUnicodePrefix( &Vcb->PrefixTable,
                                 &rootDcb->FullFileName,
                                 &rootDcb->PrefixTableEntry )) {

        DebugDump("Error trying to insert root dcb into prefix table\n", 0, Vcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateRootDcb -> %8lx\n", (ULONG)rootDcb);

    return rootDcb;
}


VOID
MsDeleteRootDcb (
    IN PROOT_DCB RootDcb
    )

/*++

Routine Description:

    This routine deallocates and removes the ROOT DCB record
    from our in-memory data structures.  It also will remove all
    associated underlings (i.e., Notify queues and child FCB records).

Arguments:

    RootDcb - Supplies the ROOT DCB to be removed

Return Value:

    None

--*/

{
    PLIST_ENTRY links;
    PIRP irp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteRootDcb, RootDcb = %08lx\n", (ULONG)RootDcb);

    //
    // We can only delete this record if the reference count is zero.
    //

    if (RootDcb->Header.ReferenceCount != 0) {
        DebugDump("Error deleting RootDcb, Still Open\n", 0, RootDcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    ASSERT (IsListEmpty (&RootDcb->Specific.Dcb.NotifyFullQueue));
    ASSERT (IsListEmpty (&RootDcb->Specific.Dcb.NotifyPartialQueue));
    //
    // We can only be removed if the no other FCB have us referenced
    // as a their parent DCB.
    //

    if (!IsListEmpty(&RootDcb->Specific.Dcb.ParentDcbQueue)) {
        DebugDump("Error deleting RootDcb\n", 0, RootDcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Remove the entry from the prefix table, and then remove the full
    // file name. No locks needed when unloading.
    //

    RtlRemoveUnicodePrefix( &RootDcb->Vcb->PrefixTable, &RootDcb->PrefixTableEntry );

    ExFreePool( RootDcb->FullFileName.Buffer );

    //
    // Free up the resource variable.
    //

    ExDeleteResourceLite( &(RootDcb->Resource) );

    //
    // Finally deallocate the DCB record.
    //

    ExFreePool( RootDcb );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsDeleteRootDcb -> VOID\n", 0);

    return;
}


NTSTATUS
MsCreateFcb (
    IN  PVCB Vcb,
    IN  PDCB ParentDcb,
    IN  PUNICODE_STRING FileName,
    IN  PEPROCESS CreatorProcess,
    IN  ULONG MailslotQuota,
    IN  ULONG MaximumMessageSize,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures.

Arguments:

    Vcb - Supplies the Vcb to associate the new FCB under.

    ParentDcb - Supplies the parent dcb that the new FCB is under.

    FileName - Supplies the file name of the file relative to the directory
        it's in (e.g., the file \config.sys is called "CONFIG.SYS" without
        the preceding backslash).

    CreatorProcess - Supplies a pointer to our creator process

    MailslotQuota - Supplies the initial quota

    MaximumMessageSize - Supplies the size of the largest message that
        can be written to the mailslot

    ppFcb - Returned allocated FCB

Return Value:

    NTSTATUS - status of operation

--*/

{
    PFCB fcb;
    PWCHAR Name;
    USHORT Length;
    USHORT MaxLength;
    NTSTATUS status;
    BOOLEAN AddBackSlash = FALSE;
    ULONG i;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateFcb\n", 0);


    Length = FileName->Length;
    MaxLength = Length + sizeof (UNICODE_NULL);

    //
    // Reject overflow or underflow cases.
    //
    if (Length < sizeof (WCHAR) || MaxLength < Length) {
        return STATUS_INVALID_PARAMETER;
    }

    if (FileName->Buffer[0] != '\\') {
        AddBackSlash = TRUE;
        MaxLength += sizeof (WCHAR);
        if (MaxLength < sizeof (WCHAR)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Allocate a new FCB record, and zero its fields.
    //
    fcb = MsAllocateNonPagedPoolWithQuota( sizeof(FCB), 'fFsM' );
    if (fcb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fcb, sizeof(FCB) );

    //
    // Set the proper node type code, node byte size, and reference count.
    //

    fcb->Header.NodeTypeCode = MSFS_NTC_FCB;
    fcb->Header.NodeByteSize = sizeof(FCB);
    fcb->Header.ReferenceCount = 1;
    fcb->Header.NodeState = NodeStateActive;

    //
    // Set the file name.
    //
    Name = MsAllocatePagedPoolWithQuotaCold( MaxLength, 'NFsM' );
    if (Name == NULL) {
        MsFreePool (fcb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    i = 0;
    if (AddBackSlash == TRUE) {
       Name[0] = '\\';
       i++;
    }
    RtlCopyMemory (&Name[i], FileName->Buffer, Length);
    *(PWCHAR)( (PCHAR)&Name[i] + Length ) = L'\0';

    //
    // Don't need to call RtlInitUnicodeString if we know the length already. Its just a waste.
    //
    fcb->FullFileName.Buffer = Name;
    fcb->FullFileName.Length = MaxLength - sizeof (WCHAR);
    fcb->FullFileName.MaximumLength = MaxLength;

    fcb->LastFileName.Buffer = Name + 1;
    fcb->LastFileName.Length = MaxLength - 2 * sizeof (WCHAR);
    fcb->LastFileName.MaximumLength = MaxLength - sizeof (WCHAR);

    //
    // Initialize the data queue. This charges the server process for the quota and can fail
    // because of that.
    //
    status = MsInitializeDataQueue( &fcb->DataQueue,
                                    CreatorProcess,
                                    MailslotQuota,
                                    MaximumMessageSize);
    if (!NT_SUCCESS (status)) {

        MsFreePool (fcb);
        MsFreePool (Name);

        return status;
    }
    
    //
    // Acquire exclusive access to the root DCB.
    //

    MsAcquireExclusiveFcb( (PFCB)ParentDcb );

    //
    // Insert this FCB into our parent DCB's queue.
    //
    InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                    &fcb->ParentDcbLinks );

    MsReleaseFcb( (PFCB)ParentDcb );

    //
    // Initialize other FCB fields.
    //

    fcb->ParentDcb = ParentDcb;
    fcb->Vcb = Vcb;

    MsReferenceVcb (Vcb);

    fcb->CreatorProcess =  CreatorProcess;
    ExInitializeResourceLite( &(fcb->Resource) );

    //
    // Initialize the CCB queue.
    //

    InitializeListHead( &fcb->Specific.Fcb.CcbQueue );

    //
    // Insert this FCB into the prefix table.
    //

    ASSERT (MsIsAcquiredExclusiveVcb(Vcb));

    if (!RtlInsertUnicodePrefix( &Vcb->PrefixTable,
                                 &fcb->FullFileName,
                                 &fcb->PrefixTableEntry )) {

        //
        // We should not be able to get here because we already looked up the name and found
        // it was not there. A failure here is a fatal error.
        //
        DebugDump("Error trying to name into prefix table\n", 0, fcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }


    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateFcb -> %08lx\n", (ULONG)fcb);

    *ppFcb = fcb;
    return STATUS_SUCCESS;
}

VOID
MsRemoveFcbName (
    IN PFCB Fcb
    )
/*++

Routine Description:

    This routine removes the FCB's name from the prefix table and the root DCB. This is done at
    cleanup time and in a backout path of create.

Arguments:

    Fcb - Supplies the FCB to have its name removed

Return Value:

    None

--*/
{
    //
    // Remove the Fcb from the prefix table. Make sure we hold the VCB lock exclusive.
    //

    ASSERT (MsIsAcquiredExclusiveVcb(Fcb->Vcb));

    RtlRemoveUnicodePrefix( &Fcb->Vcb->PrefixTable, &Fcb->PrefixTableEntry );

    //
    // Acquire exclusive access to the root DCB.
    //

    MsAcquireExclusiveFcb( (PFCB) Fcb->ParentDcb );

    //
    // Remove the Fcb from our parent DCB's queue.
    //

    RemoveEntryList( &Fcb->ParentDcbLinks );

    MsReleaseFcb( (PFCB) Fcb->ParentDcb );
}


VOID
MsDeleteFcb (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB from our in-memory data
    structures.  It also will remove all associated underlings.

Arguments:

    Fcb - Supplies the FCB to be removed

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteFcb, Fcb = %08lx\n", (ULONG)Fcb);

    //
    // Release the FCB reference to the VCB.
    //

    MsDereferenceVcb( Fcb->Vcb );

    ExFreePool( Fcb->FullFileName.Buffer );

    //
    // Free up the data queue.
    //

    MsUninitializeDataQueue(
        &Fcb->DataQueue,
        Fcb->CreatorProcess
        );

    //
    // If there is a security descriptor on the mailslot then deassign it
    //

    if (Fcb->SecurityDescriptor != NULL) {
        SeDeassignSecurity( &Fcb->SecurityDescriptor );
    }

    //
    //  Free up the resource variable.
    //

    ExDeleteResourceLite( &(Fcb->Resource) );

    //
    // Finally deallocate the FCB record.
    //

    ExFreePool( Fcb );

    //
    // Return to the caller
    //

    DebugTrace(-1, Dbg, "MsDeleteFcb -> VOID\n", 0);

    return;
}


NTSTATUS
MsCreateCcb (
    IN PFCB Fcb,
    OUT PCCB *ppCcb
    )

/*++

Routine Description:

    This routine creates a new CCB record.

Arguments:

    Fcb   - Supplies a pointer to the FCB to which we are attached.
    ppCcb - Output for the allocated CCB

Return Value:

    NTSTATUS for the operation

--*/

{
    PCCB ccb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateCcb\n", 0);

    ASSERT( Fcb->Header.NodeState == NodeStateActive );

    //
    //  Allocate a new CCB record and zero its fields.
    //

    ccb = MsAllocateNonPagedPoolWithQuota( sizeof(CCB), 'cFsM' );
    if (ccb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ccb, sizeof(CCB) );

    //
    //  Set the proper node type code, node byte size, and reference count.
    //

    ccb->Header.NodeTypeCode = MSFS_NTC_CCB;
    ccb->Header.NodeByteSize = sizeof(CCB);
    ccb->Header.ReferenceCount = 1;
    ccb->Header.NodeState = NodeStateActive;

    //
    // Insert ourselves in the list of ccb for the fcb, and reference
    // the fcb.
    //

    MsAcquireExclusiveFcb( Fcb );
    InsertTailList( &Fcb->Specific.Fcb.CcbQueue, &ccb->CcbLinks );
    MsReleaseFcb( Fcb );

    ccb->Fcb = Fcb;
    MsAcquireGlobalLock();
    MsReferenceNode( &Fcb->Header );
    MsReleaseGlobalLock();

    //
    // Initialize the CCB's resource.
    //

    ExInitializeResourceLite( &ccb->Resource );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateCcb -> %08lx\n", (ULONG)ccb);

    *ppCcb = ccb;
    return STATUS_SUCCESS;
}


PROOT_DCB_CCB
MsCreateRootDcbCcb (
    IN PROOT_DCB RootDcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates a new root DCB CCB record.

Arguments:

Return Value:

    PROOT_DCB_CCB - returns a pointer to the newly allocate ROOT_DCB_CCB

--*/

{
    PROOT_DCB_CCB ccb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateRootDcbCcb\n", 0);

    //
    // Allocate a new root DCB CCB record, and zero it out.
    //

    ccb = MsAllocateNonPagedPoolWithQuota( sizeof(ROOT_DCB_CCB), 'CFsM' );

    if (ccb == NULL) {
        return NULL;
    }

    RtlZeroMemory( ccb, sizeof(ROOT_DCB_CCB) );

    //
    // Set the proper node type code, node byte size, and reference count.
    //

    ccb->Header.NodeTypeCode = MSFS_NTC_ROOT_DCB_CCB;
    ccb->Header.NodeByteSize = sizeof(ROOT_DCB_CCB);
    ccb->Header.ReferenceCount = 1;
    ccb->Header.NodeState = NodeStateActive;

    ccb->Vcb = Vcb;
    MsReferenceVcb (Vcb);

    ccb->Dcb = RootDcb;
    MsReferenceRootDcb (RootDcb);
    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateRootDcbCcb -> %08lx\n", (ULONG)ccb);

    return ccb;
}


VOID
MsDeleteCcb (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine deallocates and removes the specified CCB record
    from the our in memory data structures.

Arguments:

    Ccb - Supplies the CCB to remove

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteCcb, Ccb = %08lx\n", (ULONG)Ccb);

    //
    // Case on the type of CCB we are deleting.
    //

    switch (Ccb->Header.NodeTypeCode) {

    case MSFS_NTC_CCB:

        MsDereferenceFcb( Ccb->Fcb );

        ExDeleteResourceLite( &Ccb->Resource );
        break;

    case MSFS_NTC_ROOT_DCB_CCB:

        MsDereferenceRootDcb ( ((PROOT_DCB_CCB)Ccb)->Dcb );

        MsDereferenceVcb ( ((PROOT_DCB_CCB)Ccb)->Vcb );

        if (((PROOT_DCB_CCB)Ccb)->QueryTemplate != NULL) {
            ExFreePool( ((PROOT_DCB_CCB)Ccb)->QueryTemplate );
        }
        break;
    }

    //
    // Deallocate the Ccb record.
    //

    ExFreePool( Ccb );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsDeleteCcb -> VOID\n", 0);

    return;
}


VOID
MsReferenceVcb (
    IN PVCB Vcb
    )
/*++

Routine Description:

    This routine references a VCB block.  If the reference count reaches 2, the driver paging is restored
    to normal so that cancelation and DPC routines won't take pagefaults.

Arguments:

    Vcb - Supplies the VCB to reference

Return Value:

    None

--*/
{
    MsAcquireGlobalLock();
    MsReferenceNode( &Vcb->Header );
    if (Vcb->Header.ReferenceCount == 2) {
        //
        // Set the driver paging back to normal
        //
        MmResetDriverPaging(MsReferenceVcb);
    }
    MsReleaseGlobalLock();
}

VOID
MsReferenceRootDcb (
    IN PROOT_DCB RootDcb
    )
/*++

Routine Description:

    This routine references a root DCB block.  If the reference count reaches 2, a reference is placed on the
    VCB so that cancelation and DPC routines won't take pagefaults.

Arguments:

    Vcb - Supplies the VCB to reference

Return Value:

    None

--*/
{
    MsAcquireGlobalLock();
    MsReferenceNode( &RootDcb->Header );
    MsReleaseGlobalLock();
}



VOID
MsDereferenceVcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine dereferences a VCB block.  If the reference count
    reaches zero, the block is freed.

Arguments:

    Vcb - Supplies the VCB to dereference

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceVcb, Vcb = %08lx\n", (ULONG)Vcb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(Vcb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the VCB.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Vcb->Header.ReferenceCount );

        MsReleaseGlobalLock();
        MsDeleteVcb( Vcb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Vcb->Header.ReferenceCount );

        if (Vcb->Header.ReferenceCount == 1) {
            //
            // Set driver to be paged completely out
            //
            MmPageEntireDriver(MsDereferenceVcb);
        }

        MsReleaseGlobalLock();

    }

    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceVcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceFcb (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine dereferences a FCB block.
    If the reference count reaches zero, the block is freed.

Arguments:

    Fcb - Supplies the FCB to dereference.

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceFcb, Fcb = %08lx\n", (ULONG)Fcb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(Fcb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the FCB.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Fcb->Header.ReferenceCount );

        MsReleaseGlobalLock();
        MsDeleteFcb( Fcb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Fcb->Header.ReferenceCount );

        MsReleaseGlobalLock();

    }

    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceFcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceCcb (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine dereferences a CCB block.  If the reference count
    reaches zero, the block is freed.

Arguments:

    Ccb - Supplies the Ccb to dereference

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceCcb, Ccb = %08lx\n", (ULONG)Ccb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(Ccb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the Ccb.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Ccb->Header.ReferenceCount );

        MsReleaseGlobalLock();

        MsDeleteCcb( Ccb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Ccb->Header.ReferenceCount );

        MsReleaseGlobalLock();

    }

    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceCcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceRootDcb (
    IN PROOT_DCB RootDcb
    )

/*++

Routine Description:

    This routine dereferences a ROOT_DCB block.  If the reference count
    reaches zero, the block is freed.

Arguments:

    RootDcb - Supplies the RootDcb to dereference

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceRootDcb, RootDcb = %08lx\n", (ULONG)RootDcb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(RootDcb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the RootDcb.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   RootDcb->Header.ReferenceCount );

        MsReleaseGlobalLock();
        MsDeleteRootDcb( RootDcb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   RootDcb->Header.ReferenceCount );

        MsReleaseGlobalLock();

    }


    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceRootDcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceNode (
    IN PNODE_HEADER NodeHeader
    )

/*++

Routine Description:

    This routine dereferences a generic mailslot block.  It figures out
    the type of block this is, and calls the appropriate worker function.

Arguments:

    NodeHeader - A pointer to a generic mailslot block header.

Return Value:

    None

--*/

{
    PAGED_CODE();
    switch ( NodeHeader->NodeTypeCode ) {

    case MSFS_NTC_VCB:
        MsDereferenceVcb( (PVCB)NodeHeader );
        break;

    case MSFS_NTC_ROOT_DCB:
        MsDereferenceRootDcb( (PROOT_DCB)NodeHeader );
        break;

    case MSFS_NTC_FCB:
        MsDereferenceFcb( (PFCB)NodeHeader );
        break;

    case MSFS_NTC_CCB:
    case MSFS_NTC_ROOT_DCB_CCB:
        MsDereferenceCcb( (PCCB)NodeHeader );
        break;

    default:

        //
        // This block is not one of ours.
        //

        KeBugCheck( MAILSLOT_FILE_SYSTEM );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\seinfo.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    SeInfo.c

Abstract:

    This module implements the Security Information routines for MSFS
    There are two entry points MsFsdQueryInformation and
    MsFsdSetInformation.

Author:

    Manny Weiser     [mannyw]    19-Feb-1992

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SEINFO)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
MsCommonSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonQuerySecurityInfo )
#pragma alloc_text( PAGE, MsCommonSetSecurityInfo )
#pragma alloc_text( PAGE, MsFsdQuerySecurityInfo )
#pragma alloc_text( PAGE, MsFsdSetSecurityInfo )
#endif

NTSTATUS
MsFsdQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Query Security Information API
    calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdQuerySecurityInfo\n", 0);

    //
    // Call the common Query Information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonQuerySecurityInfo( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "MsFsdQuerySecurityInfo -> %08lx\n", status );

    return status;
}


NTSTATUS
MsFsdSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Set Security Information API
    calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdSetSecurityInfo\n", 0);

    //
    // Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonSetSecurityInfo( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "MsFsdSetSecurityInfo -> %08lx\n", status );

    return status;
}

//
//  Internal support routine
//

NTSTATUS
MsCommonQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonQuerySecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", irpSp->Parameters.QuerySecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->Length              = %08lx\n", irpSp->Parameters.QuerySecurity.Length);
    DebugTrace( 0, Dbg, " ->UserBuffer          = %08lx\n", Irp->UserBuffer);

    //
    // Get the Fcb and figure out who we are, and make sure we're not
    // disconnected.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fcb,
                                            &fsContext2 )) != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        if (nodeTypeCode != NTC_UNDEFINED) {
            MsDereferenceNode( &fcb->Header );
        }

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireSharedFcb( fcb );

    //
    //  Call the security routine to do the actual query
    //
    status = SeQuerySecurityDescriptorInfo( &irpSp->Parameters.QuerySecurity.SecurityInformation,
                                            Irp->UserBuffer,
                                            &irpSp->Parameters.QuerySecurity.Length,
                                            &fcb->SecurityDescriptor );

    MsReleaseFcb( fcb );

    MsDereferenceFcb( fcb );
    //
    // Finish up the IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsCommonQuerySecurityInfo -> %08lx\n", status );

    return status;
}


NTSTATUS
MsCommonSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Setting security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;
    PSECURITY_DESCRIPTOR OldSecurityDescriptor;

    PAGED_CODE();

    //
    // Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonSetSecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", irpSp->Parameters.SetSecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->SecurityDescriptor  = %08lx\n", irpSp->Parameters.SetSecurity.SecurityDescriptor);

    //
    // Get the FCB and figure out who we are, and make sure we're not
    // disconnected.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fcb,
                                            &fsContext2 )) != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "Invalid handle\n", 0);

        if (nodeTypeCode != NTC_UNDEFINED) {
            MsDereferenceNode( &fcb->Header );
        }
        MsCompleteRequest( Irp, STATUS_INVALID_HANDLE );
        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the FCB
    //

    MsAcquireExclusiveFcb( fcb );

    //
    //  Call the security routine to do the actual set
    //

    OldSecurityDescriptor = fcb->SecurityDescriptor;

    status = SeSetSecurityDescriptorInfo( NULL,
                                          &irpSp->Parameters.SetSecurity.SecurityInformation,
                                          irpSp->Parameters.SetSecurity.SecurityDescriptor,
                                          &fcb->SecurityDescriptor,
                                          PagedPool,
                                          IoGetFileObjectGenericMapping() );

    if (NT_SUCCESS(status)) {
        ExFreePool( OldSecurityDescriptor );
    }

    MsReleaseFcb( fcb );
    MsDereferenceFcb( fcb );

    //
    // Finish up the IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsCommonSetSecurityInfo -> %08lx\n", status );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the get / set volume information routines for
    MSFS called by the dispatch driver.

    Setting volume information is currently unimplemented in MSFS.

Author:

     Manny Weiser (mannyw)    31-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
// Local procedure prototypes.
//

NTSTATUS
MsCommonQueryVolumeInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsQueryAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsFullSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonQueryVolumeInformation )
#pragma alloc_text( PAGE, MsFsdQueryVolumeInformation )
#pragma alloc_text( PAGE, MsQueryAttributeInfo )
#pragma alloc_text( PAGE, MsQueryFsVolumeInfo )
#pragma alloc_text( PAGE, MsQueryFsSizeInfo )
#pragma alloc_text( PAGE, MsQueryFsDeviceInfo )
#pragma alloc_text( PAGE, MsQueryFsFullSizeInfo )
#endif

NTSTATUS
MsFsdQueryVolumeInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryVolumeInformationFile
    API calls.

Arguments:

    MsfsDeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdQueryVolumeInformation\n", 0);

    //
    // Call the common query volume information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonQueryVolumeInformation( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdQueryVolumeInformation -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCommonQueryVolumeInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information.

Arguments:

    MsfsDeviceObject - The device object to use.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    ULONG bytesWritten = 0;
    FS_INFORMATION_CLASS fsInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PVCB vcb;

    PVOID fsContext, fsContext2;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FsInformationClass = %08lx\n", irpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Decide how to handle this request.  A user can query information
    // on a VCB only.
    //

    switch (nodeTypeCode) {

    case MSFS_NTC_VCB:

        vcb = (PVCB)fsContext;
        break;

    case MSFS_NTC_ROOT_DCB :

        //
        // Explorer calls us like this. Ship from the root dir to the volume.
        //
        vcb = (PVCB) ((PROOT_DCB_CCB)fsContext2)->Vcb;
        MsReferenceVcb (vcb);
        MsDereferenceRootDcb ((PROOT_DCB) fsContext);
        break;

    default:           // This is not a volume control block.

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);

        MsDereferenceNode( (PNODE_HEADER)fsContext );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1,
                   Dbg,
                   "MsCommonQueryVolumeInformation -> STATUS_INVALID_PARAMETER\n",
                    0);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.QueryVolume.Length;
    fsInformationClass = irpSp->Parameters.QueryVolume.FsInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Now acquire shared access to the VCB
    //

    MsAcquireSharedVcb( vcb );

    try {

        //
        // Decide how to handle the request.
        //

        switch (fsInformationClass) {

        case FileFsAttributeInformation:

            status = MsQueryAttributeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsVolumeInformation:

            status = MsQueryFsVolumeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsSizeInformation:

            status = MsQueryFsSizeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsFullSizeInformation:

            status = MsQueryFsFullSizeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsDeviceInformation:

            status = MsQueryFsDeviceInfo( vcb, buffer, length, &bytesWritten );
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }


    } finally {

        MsReleaseVcb( vcb );

        MsDereferenceVcb( vcb );
        //
        // Set the information field to the number of bytes actually
        // filled in and then complete the request.
        //

        Irp->IoStatus.Information = bytesWritten;

        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonQueryVolumeInformation -> %08lx\n", status );
    }

    return status;
}


NTSTATUS
MsQueryAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine performs the query fs attribute information operation.

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryFsAttributeInfo...\n", 0);

    //
    // See how many bytes of the file system name we can copy.
    //

    Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );


    if ( Length >= Vcb->FileSystemName.Length ) {

        status = STATUS_SUCCESS;

        *BytesWritten = Vcb->FileSystemName.Length;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        *BytesWritten = Length;
    }

    //
    // Fill in the attribute information.
    //

    Buffer->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES;
    Buffer->MaximumComponentNameLength = MAXIMUM_FILENAME_LENGTH;

    //
    // And copy over the file name and its length.
    //

    RtlCopyMemory (&Buffer->FileSystemName[0],
                   &Vcb->FileSystemName.Buffer[0],
                   *BytesWritten);

    Buffer->FileSystemNameLength = *BytesWritten;

    //
    // Now account for the fixed part of the structure
    //
    *BytesWritten += FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );

    return status;
}

NTSTATUS
MsQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    ULONG BytesToCopy;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    Buffer->VolumeCreationTime = Vcb->CreationTime;
    Buffer->VolumeSerialNumber = 0;

    Buffer->SupportsObjects = FALSE;

    Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );
    //
    //  Check if the buffer we're given is long enough
    //

    BytesToCopy = sizeof (MSFS_VOLUME_LABEL) - sizeof (WCHAR);

    if (Length < BytesToCopy) {

        BytesToCopy = Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       MSFS_VOLUME_LABEL,
                       BytesToCopy );
    }

    *BytesWritten = FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] ) + BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}

NTSTATUS
MsQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query size info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    Buffer->TotalAllocationUnits.QuadPart = 0;
    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = 0;
    Buffer->BytesPerSector = 0;

    *BytesWritten = sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
MsQueryFsFullSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query full size info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );


    *BytesWritten = sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
MsQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query size info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    Buffer->Characteristics = 0;
    Buffer->DeviceType = FILE_DEVICE_MAILSLOT;

    //
    //  Adjust the length variable
    //

    *BytesWritten = sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\tmsserv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tmsserv.c

Abstract:

    This module contains a user mode mailslot server test program.

    This test program can be built from the command line using the
    command 'nmake UMTEST=tmsserv'.

Author:

    Manny Weiser (mannyw)   11-Jan-91

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <ntioapi.h>

//
// Local definitions
//

BOOLEAN
CreateMailslot(
    PSZ Name,
    PHANDLE Handle
    );

BOOLEAN
QueryDirectoryTest(
    VOID
    );


BOOLEAN
QueryInfoTest(
    HANDLE Handle
    );

BOOLEAN
PeekTest(
    HANDLE Handle
    );

BOOLEAN
ReadTest(
    HANDLE Handle
    );

VOID
DisplayUsage(
    PSZ ProgramName
    );

VOID
DisplayTime(
    IN PLARGE_INTEGER
    );

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    );

#define MESSAGE_SIZE    100L
#define MAILSLOT_SIZE   (10 * MESSAGE_SIZE)

#define PEEK_PARAMETER_BYTES 16
#define READ_PARAMETER_BYTES 16
#define MAILSLOT_PARAMETER_BYTES 16    // Max of peek and read param bytes

char Buffer[1000];


int
main(argc, argv)

int argc;
char **argv;

{
    HANDLE handle;
    ULONG ms, time;
    LARGE_INTEGER delayTime;
    int i;

    if (argc < 2) {
        DisplayUsage(argv[0]);
        return 1;
    }

    if ( !CreateMailslot( argv[1], &handle ) ) {
        return 2;
    }

    for (i = 2; i < argc; i++) {

        switch ( *argv[i] ) {

        case 'r':
            if ( !ReadTest( handle ) ) {
                return 3;
            }
            break;

        case 'd':
            if ( !QueryDirectoryTest() ) {
                return 3;
            }
            break;

        case 'p':
            if ( !PeekTest( handle ) ) {
                return 3;
            }
            break;

        case 'q':
            if ( !QueryInfoTest( handle ) ) {
                return 3;
            }
            break;

        case 's':
            time = atoi( argv[i] + 1);

            printf( "%s: sleeping for %lu tenths of a second\n",
                      argv[0],
                      time );

            ms = time * 100;
            delayTime = LiNMul( ms, -10000 );
            NtDelayExecution( TRUE, (PLARGE_INTEGER)&delayTime );

            printf ("%s: awake\n", argv[0] );
            break;

        default:
            printf ("Unknown test ""%s""\n", argv[i] );
            break;

        }

    }

    printf( "Closing file\n" );
    NtClose( handle );

    printf( "%s exiting\n", argv[0] );
    return 0;
}


VOID
DisplayUsage(
    PSZ ProgramName
    )
{
    printf( "Usage: %s \\Device\\Mailslot\\Msname\n", ProgramName);
}


BOOLEAN
CreateMailslot(
    PSZ Name,
    PHANDLE Handle
    )
{
    NTSTATUS status;
    STRING ansiString;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    LARGE_INTEGER readTimeout = { -1, -1 };  // Infinite read timeout

    RtlInitString(&ansiString, Name );
    RtlOemStringToUnicodeString(&nameString, &ansiString, TRUE);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to create mailslot \"%wZ\"\n", &nameString );

    status = NtCreateMailslotFile (
                Handle,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0,
                MESSAGE_SIZE,
                &readTimeout
                );

    printf( "Open Status = %lx\n", status );
    RtlFreeUnicodeString(&nameString);

    return ( (BOOLEAN) NT_SUCCESS(status));
}

BOOLEAN
QueryDirectoryTest(
    VOID
    )
{
    HANDLE rootDirHandle;
    BOOLEAN done;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFILE_FULL_DIR_INFORMATION dirInfo;

    RtlInitUnicodeString(&nameString, L"\\Device\\Mailslot\\" );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot directory \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                &rootDirHandle,
                GENERIC_READ,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0L
                );

    RtlFreeUnicodeString(&nameString);
    printf( "MSFS root dir open status = %lx\n", status );

    status = NtQueryDirectoryFile(
                rootDirHandle,
                0,
                NULL,
                NULL,
                &ioStatusBlock,
                (PVOID)Buffer,
                sizeof(Buffer),
                FileFullDirectoryInformation,
                FALSE,
                NULL,
                FALSE );

    printf("Query directory status = %lx\n", status );
    printf("Query directory information %d\n", ioStatusBlock.Information );

    if ( NT_SUCCESS( status )) {
        done = FALSE;
        dirInfo = (PFILE_FULL_DIR_INFORMATION)Buffer;
    } else {
        done = TRUE;
    }


    while (!done) {
        printf ("NextEntry        = %d\n", dirInfo->NextEntryOffset);
        printf ("FileIndex        = %ld\n", dirInfo->FileIndex );
        printf ("CreationTime     = ");
        DisplayTime( &dirInfo->CreationTime );
        printf ("\nLastAccessTime   = ");
        DisplayTime( &dirInfo->LastAccessTime );
        printf ("\nLastWriteTime    = ");
        DisplayTime( &dirInfo->LastWriteTime );
        printf ("\nChangeTime       = ");
        DisplayTime( &dirInfo->ChangeTime );
        printf ("\nEnd of file      = %lx%08lx\n",
                dirInfo->EndOfFile.HighPart,
                dirInfo->EndOfFile.LowPart );
        printf ("Allocation size  = %lx%08lx\n",
                dirInfo->AllocationSize.HighPart,
                dirInfo->AllocationSize.LowPart );
        printf ("File attributes  = %x\n",  dirInfo->FileAttributes );
        printf ("File name length = %x\n", dirInfo->FileNameLength );
        printf ("EA size          = %x\n", dirInfo->EaSize );
        printf ("File Name        = ");
        DisplayUnicode( dirInfo->FileName, dirInfo->FileNameLength );
        printf ("\n\n");

        if (dirInfo->NextEntryOffset == 0) {
            done = TRUE;
        }

        dirInfo = (PFILE_FULL_DIR_INFORMATION)
                     ((PCHAR)dirInfo + dirInfo->NextEntryOffset);
    }

    return( (BOOLEAN)NT_SUCCESS( status ));
}


BOOLEAN
QueryInfoTest(
    HANDLE Handle
    )
{
    PFILE_BASIC_INFORMATION basicInfo;
    PFILE_STANDARD_INFORMATION standardInfo;
    PFILE_INTERNAL_INFORMATION internalInfo;
    PFILE_EA_INFORMATION eaInfo;
    PFILE_POSITION_INFORMATION positionInfo;
    PFILE_NAME_INFORMATION nameInfo;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    status = NtQueryInformationFile( Handle,
                                     &ioStatusBlock,
                                     Buffer,
                                     MESSAGE_SIZE,
                                     FileAllInformation );

    printf ("\nBasic Information:\n");

    basicInfo = (PFILE_BASIC_INFORMATION)Buffer;
    printf ("    Creation time:    " );
    DisplayTime( &basicInfo->CreationTime );
    printf ("\n    Last access time: " );
    DisplayTime( &basicInfo->LastAccessTime );
    printf ("\n    Last write time:  " );
    DisplayTime( &basicInfo->LastWriteTime );
    printf ("\n    Change time:      " );
    DisplayTime( &basicInfo->ChangeTime );
    printf ("\n");

    printf ("\nStandard Information:\n");

    standardInfo = (PFILE_STANDARD_INFORMATION)(basicInfo + 1);
    printf ("    Number of links: %ld\n", standardInfo->NumberOfLinks );
    printf ("    Delete pending : %ld\n", standardInfo->DeletePending );
    printf ("    Directory      : %ld\n", standardInfo->Directory );

    printf ("\nInternal Information:\n");

    internalInfo = (PFILE_INTERNAL_INFORMATION)(standardInfo + 1);
    printf ("    Index Number   : %ld\n", internalInfo->IndexNumber );

    printf ("\nEa Information:\n");

    eaInfo = (PFILE_EA_INFORMATION)(internalInfo + 1);
    printf ("    No ea info\n" );

    printf ("\nPosition Information:\n");

    positionInfo = (PFILE_POSITION_INFORMATION)(eaInfo+1);
    printf ("    Current offset: %ld\n", positionInfo->CurrentByteOffset );

    printf ("\nName Information:\n");

    nameInfo = (PFILE_NAME_INFORMATION)(positionInfo + 1);
    printf ("    File name length: %ld\n", nameInfo->FileNameLength );
    printf ("    File name       : ");
    DisplayUnicode( nameInfo->FileName, nameInfo->FileNameLength );
    putchar ('\n');

    return TRUE;
}

BOOLEAN
PeekTest(
    HANDLE Handle
    )
{
    FILE_MAILSLOT_PEEK_BUFFER mailslotPeekBuffer;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    status = NtFsControlFile (
                Handle,
                0L,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_MAILSLOT_PEEK,
                &mailslotPeekBuffer,
                sizeof(mailslotPeekBuffer),
                Buffer,
                MESSAGE_SIZE );

    printf( "    ReadDataAvailable = %lx\n", mailslotPeekBuffer.ReadDataAvailable );
    printf( "    NumberOfMessages  = %lx\n", mailslotPeekBuffer.NumberOfMessages);
    printf( "    MessageLength     = %lx\n", mailslotPeekBuffer.MessageLength);
    return ( (BOOLEAN) NT_SUCCESS( status ) );
}


BOOLEAN
ReadTest(
    HANDLE Handle
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;

    status = NtReadFile(
                Handle,
                0L,
                NULL,
                NULL,
                &ioStatusBlock,
                Buffer,
                MESSAGE_SIZE,
                NULL,
                NULL);


    if (NT_SUCCESS(status)) {
        status = NtWaitForSingleObject( Handle, TRUE, NULL );
        printf( "NtWaitForSingleObject returns %lx\n", status );
        status = ioStatusBlock.Status;
    }

    printf( "NtReadFileFinalStatus returns %lx\n", status );

    if (NT_SUCCESS(status)) {
        printf ("message is ""%s""\n", Buffer );
    }

    return ( (BOOLEAN)NT_SUCCESS( status ) );
}
VOID
DisplayTime(
    IN PLARGE_INTEGER Time
    )

{
    TIME_FIELDS timeFields;

    RtlTimeToTimeFields( Time, &timeFields );

    printf("%02d/%02d/%04d @ %02d:%02d:%02d.%d",
           timeFields.Month,
           timeFields.Day,
           timeFields.Year,
           timeFields.Hour,
           timeFields.Minute,
           timeFields.Second,
           timeFields.Milliseconds );

}

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    )
{
    while (Length > 0) {
        putchar( (CHAR)*UnicodeString );
        UnicodeString++;
        Length -= 2;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\tmscli.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tmscli.c

Abstract:

    User mode test program for the mailslot file system.

    This test program can be built from the command line using the
    command 'nmake UMTEST=tmscli'.

Author:

    Manny Weiser (mannyw)   17-Jan-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>

//
// Local definitions
//

VOID
DisplayUsage(
    PSZ ProgramName
    );

BOOLEAN
NotifyChangeDirectoryTest(
    VOID
    );

BOOLEAN
QueryVolumeTest(
    VOID
    );

BOOLEAN
OpenMailslot(
    PSZ Name,
    PHANDLE Handle
    );


BOOLEAN
WriteTest(
    IN HANDLE Handle
    );

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    );

#define MESSAGE_SIZE    100L
#define MAILSLOT_SIZE   (10 * MESSAGE_SIZE)

char Buffer[MESSAGE_SIZE];

int
main(
    int argc,
    char *argv[]
    )
{
    HANDLE handle;
    int i;

    printf("\nStart %s...\n", argv[0]);

    for (i = 1; i < argc; i++) {

        switch ( *argv[i] ) {

        case 'h':
        case '?':
            DisplayUsage( argv[0] );
            break;

        case 'o':
            if ( !OpenMailslot( argv[i] + 1, &handle ) ) {
                return 3;
            }
            break;

        case 'n':
            if ( !NotifyChangeDirectoryTest() ) {
                return 3;
            }
            break;

        case 'c':
            printf( "Closing file\n" );
            NtClose( handle );
            break;

        case 'w':
            if (!WriteTest(handle)) {
                return 3;
            }
            break;

        case 'v':
            if (!QueryVolumeTest()) {
                return 3;
            }
            break;

        default:
            printf( "Unknown test ""%s"" skipped.\n", argv[i] );

        }
    }

    printf( "%s exiting\n", argv[0]);
    return 0;
}


BOOLEAN
NotifyChangeDirectoryTest(
    VOID
    )
{
    HANDLE rootDirHandle;
    UCHAR buffer[512];
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;

    RtlInitUnicodeString( &nameString, L"\\Device\\Mailslot\\" );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot directory \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                &rootDirHandle,
                GENERIC_READ,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0L
                );

    printf( "MSFS root dir open status = %lx\n", status );

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = NtNotifyChangeDirectoryFile(
                rootDirHandle,
                (HANDLE) NULL,
                (PIO_APC_ROUTINE) NULL,
                (PVOID) NULL,
                &ioStatusBlock,
                buffer,
                sizeof( buffer ),
                FILE_NOTIFY_CHANGE_NAME |
                FILE_NOTIFY_CHANGE_ATTRIBUTES |
                FILE_NOTIFY_CHANGE_SIZE |
                FILE_NOTIFY_CHANGE_LAST_WRITE |
                FILE_NOTIFY_CHANGE_LAST_ACCESS |
                FILE_NOTIFY_CHANGE_CREATION |
                FILE_NOTIFY_CHANGE_EA |
                FILE_NOTIFY_CHANGE_SECURITY,
                FALSE );

    printf("Notify change directory status = %lx\n", status );

    if ( !NT_SUCCESS( status )) {
        return FALSE;
    }

    status = NtWaitForSingleObject( rootDirHandle, TRUE, NULL );
    printf( "NtWaitForSingleObject returns %lx\n", status );

    status = ioStatusBlock.Status;
    printf( "Find notify final status = %d\n", status );

    return( (BOOLEAN)NT_SUCCESS( status ));
}


BOOLEAN
QueryVolumeTest(
    VOID
    )
{
    HANDLE fsHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFILE_FS_ATTRIBUTE_INFORMATION fsAttributeInfo;

    RtlInitUnicodeString( &nameString, L"\\Device\\Mailslot" );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot fs \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                &fsHandle,
                GENERIC_READ,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0L
                );

    printf( "MSFS open status = %lx\n", status );

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = NtQueryVolumeInformationFile(
                fsHandle,
                &ioStatusBlock,
                Buffer,
                sizeof( Buffer ),
                FileFsAttributeInformation );

    printf("Query volume status = %lx\n", status );

    if ( !NT_SUCCESS( status )) {
        return FALSE;
    }

    status = ioStatusBlock.Status;
    printf( "Query volume final status = %d\n", status );

    fsAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)Buffer;
    printf ("  FileSystemAttributes       = %lx\n",
              fsAttributeInfo->FileSystemAttributes);
    printf ("  MaximumComponentNameLength = %ld\n",
              fsAttributeInfo->MaximumComponentNameLength);
    printf ("  FileSystemNameLength       = %ld\n",
              fsAttributeInfo->FileSystemNameLength);

    printf ("  FileSystemName             = ");
    DisplayUnicode(fsAttributeInfo->FileSystemName,
                   fsAttributeInfo->FileSystemNameLength);
    putchar ('\n');

    return( (BOOLEAN)NT_SUCCESS( status ));
}

VOID
DisplayUsage(
    PSZ ProgramName
    )
{
    printf( "Usage: %s \\Device\\Mailslot\\Msname\n", ProgramName);
}


BOOLEAN
OpenMailslot(
    PSZ Name,
    PHANDLE Handle
    )
{
    STRING ansiString;
    UNICODE_STRING nameString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    RtlInitString(&ansiString, Name );
    RtlOemStringToUnicodeString(&nameString, &ansiString, TRUE);

    //
    //  Open the mailslot
    //

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                Handle,
                FILE_WRITE_DATA | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                0L
                );

    printf( "Status = %x\n", status );

    RtlFreeUnicodeString(&nameString);
    return ( (BOOLEAN) NT_SUCCESS( status ) );
}


BOOLEAN
WriteTest(
    IN HANDLE Handle
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    static ULONG messageNumber = 0;

    messageNumber++;
    sprintf( Buffer, "Sending message number %d\n", messageNumber);

    status = NtWriteFile (
                Handle,
                0L,
                NULL,
                NULL,
                &ioStatusBlock,
                Buffer,
                MESSAGE_SIZE,
                NULL,
                NULL);

    printf ("Write status = %lx\n", status );

    if (NT_SUCCESS(status)) {
        status = NtWaitForSingleObject( Handle, TRUE, NULL );
        printf( "NtWaitForSingleObject returns %lx\n", status );
        status = ioStatusBlock.Status;
    }

    printf( "NtWriteFileFinalStatus returns %lx\n", status );

    return ( (BOOLEAN)NT_SUCCESS( status ) );
}

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    )
{
    while (Length > 0) {
        putchar( (CHAR)*UnicodeString );
        UnicodeString++;
        Length -= 2;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\writesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    writesup.c

Abstract:

    This module implements the write support routine.  This is a common
    write function that is called by write and mailslot write.

Author:

    Manny Weiser (mannyw)   16-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsWriteDataQueue )
#endif

NTSTATUS
MsWriteDataQueue (
    IN PDATA_QUEUE WriteQueue,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength
    )

/*++

Routine Description:

    This function writes data from the write buffer into read entries in
    the write queue.  It will also dequeue entries in the queue as necessary.


Arguments:

    WriteQueue - Provides the write queue to process.

    WriteBuffer - Provides the buffer from which to read the data.

    WriteLength  - Provides the length, in bytes, of WriteBuffer.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED if not all the data was written,
    other status codes as appropriate.

--*/

{
    NTSTATUS status;
    BOOLEAN result;

    PDATA_ENTRY dataEntry;
    PLIST_ENTRY listEntry;
    PFCB fcb;

    PUCHAR readBuffer;
    ULONG readLength;
    PIRP readIrp;
    NTSTATUS readStatus = STATUS_UNSUCCESSFUL;

    PWORK_CONTEXT workContext;
    PKTIMER timer;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsWriteDataQueue\n", 0);
    DebugTrace( 0, Dbg, "WriteQueue  = %08lx\n", (ULONG)WriteQueue);
    DebugTrace( 0, Dbg, "WriteBuffer = %08lx\n", (ULONG)WriteBuffer);
    DebugTrace( 0, Dbg, "WriteLength = %08lx\n", WriteLength);

    //
    // Now while the write queue has some read entries in it and
    // we have not successfully completed a read then we'll do the
    // following main loop.
    //

    status = STATUS_MORE_PROCESSING_REQUIRED;

    for (listEntry = MsGetNextDataQueueEntry( WriteQueue );

         (MsIsDataQueueReaders(WriteQueue) &&
          status == STATUS_MORE_PROCESSING_REQUIRED);

         listEntry = MsGetNextDataQueueEntry( WriteQueue )) {

        dataEntry = CONTAINING_RECORD( listEntry, DATA_ENTRY, ListEntry );
        readBuffer = dataEntry->DataPointer;
        readLength = dataEntry->DataSize;

        DebugTrace(0, Dbg, "Top of write loop...\n", 0);
        DebugTrace(0, Dbg, "ReadBuffer      = %08lx\n", (ULONG)readBuffer);
        DebugTrace(0, Dbg, "ReadLength      = %08lx\n", readLength);


        //
        // If the buffer for this read operation is large enough
        // copy the data.
        //

        if ( readLength >= WriteLength ) {

            //
            // Copy the data from the write buffer to the read buffer. This may take an exception
            // because its a raw user mode buffer
            //

            status = readStatus = STATUS_SUCCESS;

            try {

                RtlCopyMemory (readBuffer,
                               WriteBuffer,
                               WriteLength);

            } except (EXCEPTION_EXECUTE_HANDLER) {

                return GetExceptionCode ();

            }

        } else {

            //
            // This read buffer was overflowed.
            //

            WriteLength = 0;
            readStatus = STATUS_BUFFER_TOO_SMALL;

        }

        //
        // We are about to complete a read IRP, so dequeue it.
        //

        readIrp = MsRemoveDataQueueEntry( WriteQueue, dataEntry );
        if ( readIrp == NULL) {
           //
           // Cancel routine was already running for this IRP. Ignore it as it will be completed by
           // cancel code. Force the loop for the next read irp if there is one.
           //
           status = STATUS_MORE_PROCESSING_REQUIRED;
           continue;
        }
        //
        // Update the FCB last access time and complete the read request.
        //

        fcb = CONTAINING_RECORD( WriteQueue, FCB, DataQueue );
        if ( NT_SUCCESS( readStatus ) ) {
            KeQuerySystemTime( &fcb->Specific.Fcb.LastAccessTime );
        }

        readIrp->IoStatus.Information = WriteLength;
        MsCompleteRequest( readIrp, readStatus );

    }

    DebugTrace(0, Dbg, "Finished loop...\n", 0);

    //
    // At this point we've finished off all of the read entries in the
    // queue and we might not have written the write data.  If that
    // is the case then we'll set our result to FALSE otherwise we're
    // done so we'll return TRUE.
    //

    if ( status == STATUS_MORE_PROCESSING_REQUIRED ) {

        ASSERT( !MsIsDataQueueReaders( WriteQueue ));
    }

    DebugTrace(-1, Dbg, "MsWriteDataQueue -> %08lx\n", status);
    return status;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\verfysup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    verfysup.c

Abstract:

    This module implements the verify functions for MSFS.

Author:

    Manny Weiser (mannyw)    23-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_VERIFY)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsVerifyCcb )
#pragma alloc_text( PAGE, MsVerifyFcb )
#pragma alloc_text( PAGE, MsVerifyDcbCcb )
#endif


NTSTATUS
MsVerifyFcb (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function verifies that an FCB is still active.  If it is active,
    the function  does nothing.  If it is inactive an error status is returned.

Arguments:

    PFCB - A pointer to the FCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsVerifyFcb, Fcb = %08lx\n", (ULONG)Fcb);
    if ( Fcb->Header.NodeState != NodeStateActive ) {

        DebugTrace( 0, Dbg, "Fcb is not active\n", 0);
        return STATUS_FILE_INVALID;

    }

    DebugTrace(-1, Dbg, "MsVerifyFcb -> VOID\n", 0);
    return STATUS_SUCCESS;
}


NTSTATUS
MsVerifyCcb (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This function verifies that a CCB is still active.  If it is active,
    the function  does nothing.  If it is inactive an error status is raised.

Arguments:

    PCCB - A pointer to the CCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsVerifyCcb, Ccb = %08lx\n", (ULONG)Ccb);
    if ( Ccb->Header.NodeState != NodeStateActive ) {

        DebugTrace( 0, Dbg, "Ccb is not active\n", 0);
        return STATUS_FILE_INVALID;

    }

    DebugTrace(-1, Dbg, "MsVerifyCcb -> VOID\n", 0);
    return STATUS_SUCCESS;
}

NTSTATUS
MsVerifyDcbCcb (
    IN PROOT_DCB_CCB Ccb
    )

/*++

Routine Description:

    This function verifies that a CCB is still active.  If it is active,
    the function  does nothing.  If it is inactive an error status is raised.

Arguments:

    PCCB - A pointer to the DCB CCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsVerifyCcb, Ccb = %08lx\n", (ULONG)Ccb);
    if ( Ccb->Header.NodeState != NodeStateActive ) {

        DebugTrace( 0, Dbg, "Ccb is not active\n", 0);
        return STATUS_FILE_INVALID;

    }

    DebugTrace(-1, Dbg, "MsVerifyCcb -> VOID\n", 0);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mailslot\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the file write routines for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    16-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

//
// local procedure prototypes.
//

NTSTATUS
MsCommonWrite (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonWrite )
#pragma alloc_text( PAGE, MsFsdWrite )
#endif

NTSTATUS
MsFsdWrite (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtWriteFile API call.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdWrite\n", 0);

    FsRtlEnterFileSystem();

    status = MsCommonWrite( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdWrite -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCommonWrite (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for writing to a mailslot file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PCCB ccb;
    PFCB fcb;
    PVOID fsContext2;

    PIRP writeIrp;
    PUCHAR writeBuffer;
    ULONG writeLength;
    PDATA_QUEUE writeQueue;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonWrite\n", 0);
    DebugTrace( 0, Dbg, "MsfsDeviceObject = %08lx\n", (ULONG)MsfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);

    //
    //  Get the CCB and make sure it isn't closing.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&ccb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "The mailslot is disconnected\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status );
        return status;
    }

    //
    // Allow write operations only to the client side of the mailslot.
    //

    if (nodeTypeCode != MSFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not the correct type", 0);
        MsDereferenceNode( &ccb->Header );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status );
        return status;

    }

    //
    // Get a pointer to the FCB for this CCB
    //

    fcb = ccb->Fcb;

    //
    // Make local copies of the input parameters to make things easier, and
    // initialize the main variables that describe the write command.
    //

    writeIrp = Irp;
    writeBuffer = Irp->UserBuffer;
    writeLength = irpSp->Parameters.Write.Length;

    writeIrp->IoStatus.Information = 0;
    writeQueue = &fcb->DataQueue;

    //
    // Make sure the write does not exceed the stated maximum.  If max is
    // zero, this means don't enforce.
    //

    if ( (writeQueue->MaximumMessageSize != 0) &&
         (writeLength > writeQueue->MaximumMessageSize) ) {

        DebugTrace(0, Dbg, "Write exceeds maximum message size", 0);
        MsDereferenceCcb( ccb );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status );
        return status;
    }

    //
    // Now acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );


    //
    // Ensure that this CCB still belongs to an active open mailslot.
    //

    status = MsVerifyCcb( ccb );
    if (NT_SUCCESS (status)) {

        //
        // Now we'll call our common write data queue routine to
        // transfer data out of our write buffer into the data queue.
        // If the result of the call is FALSE then there were no queued
        // read operations and we must queue this write.
        //

        status = MsWriteDataQueue( writeQueue,
                                   writeBuffer,
                                   writeLength );


        if (status == STATUS_MORE_PROCESSING_REQUIRED)  {

            ASSERT( !MsIsDataQueueReaders( writeQueue ));

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  Add this write request to the write queue
            //

            status = MsAddDataQueueEntry( writeQueue,
                                          WriteEntries,
                                          writeLength,
                                          Irp,
                                          NULL );

        } else {

            DebugTrace(0, Dbg, "Complete the Write Irp\n", 0);


            //
            // Update the FCB last modification time.
            //
            if (NT_SUCCESS (status)) {
                writeIrp->IoStatus.Information = writeLength;
                KeQuerySystemTime( &fcb->Specific.Fcb.LastModificationTime );
            }
        }

    }

    MsReleaseFcb( fcb );

    MsDereferenceCcb( ccb );

    MsCompleteRequest( writeIrp, status );

    DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status);

    return status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\block.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    block.c

Abstract:

    This module implements block management functions.

Author:

    Manny Weiser (mannyw)    12-29-91

Revision History:

--*/

#include "mup.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_BLOCK)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupAllocateMasterIoContext )
#pragma alloc_text( PAGE, MupAllocateMasterQueryContext )
#pragma alloc_text( PAGE, MupAllocatePrefixEntry )
#pragma alloc_text( PAGE, MupAllocateUncProvider )
#pragma alloc_text( PAGE, MupCalculateTimeout )
#pragma alloc_text( PAGE, MupCloseUncProvider )
#pragma alloc_text( PAGE, MupCreateCcb )
#pragma alloc_text( PAGE, MupCreateFcb )
#pragma alloc_text( PAGE, MupDereferenceVcb )
#pragma alloc_text( INIT, MupInitializeVcb )
#endif

VOID
MupInitializeVcb(
    IN PVCB Vcb
    )

/*++

Routine Description:

    The routine initializes the VCB for the MUP.

Arguments:

    VCB - A pointer to the MUP VCB.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupInitializeVcb\n", 0);

    RtlZeroMemory( Vcb, sizeof( VCB ) );

    Vcb->BlockHeader.BlockType = BlockTypeVcb;
    Vcb->BlockHeader.BlockState = BlockStateActive;
    Vcb->BlockHeader.ReferenceCount = 1;
    Vcb->BlockHeader.BlockSize = sizeof( VCB );

    DebugTrace(-1, Dbg, "MupInitializeVcb -> VOID\n", 0);
}

VOID
MupDereferenceVcb(
    PVCB Vcb
    )
{
    LONG result;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupDereferenceVcb\n", 0 );

    result = InterlockedDecrement(
                 &Vcb->BlockHeader.ReferenceCount
                 );

    DebugTrace( 0, Dbg, "ReferenceCount = %d\n", Vcb->BlockHeader.ReferenceCount );

    if ( result == 0 ) {

        KeBugCheckEx( FILE_SYSTEM, 3, 0, 0, 0 );
    }

    DebugTrace( -1, Dbg, "MupDereferenceVcb -> VOID\n", 0 );
}


PFCB
MupCreateFcb(
    VOID
    )

/*++

Routine Description:

    This routine allocates an FCB block

Arguments:

    None.

Return Value:

    A pointer to the allocated FCB.

--*/

{
    PFCB fcb;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupCreateFcb\n", 0 );

    //
    // Attempt to allocate memory.
    //

    fcb = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(FCB),
                ' puM');

    if (fcb == NULL) {

        return NULL;

    }

    //
    // Initialize the UNC provider block header
    //

    fcb->BlockHeader.BlockType = BlockTypeFcb;
    fcb->BlockHeader.BlockState = BlockStateActive;
    fcb->BlockHeader.ReferenceCount = 1;
    fcb->BlockHeader.BlockSize = sizeof( FCB );

    InitializeListHead( &fcb->CcbList );

    DebugTrace( -1, Dbg, "MupCreateFcb -> 0x%8lx\n", fcb );
    return fcb;


}

VOID
MupDereferenceFcb(
    PFCB Fcb
    )
{
    LONG result;

    ASSERT( Fcb->BlockHeader.BlockType == BlockTypeFcb );

    DebugTrace( +1, Dbg, "MupDereferenceFcb\n", 0 );

    result = InterlockedDecrement(
                 &Fcb->BlockHeader.ReferenceCount
                 );

    DebugTrace( 0, Dbg, "ReferenceCount = %d\n", Fcb->BlockHeader.ReferenceCount);

    if ( result == 0 ) {

        ASSERT( IsListEmpty( &Fcb->CcbList ) );

        MupFreeFcb( Fcb );
    }

    DebugTrace( -1, Dbg, "MupDereferenceFcb -> VOID\n", 0 );

}

VOID
MupFreeFcb(
    PFCB Fcb
    )

/*++

Routine Description:

    This routine frees an FCB block

Arguments:

    A pointer to the FCB block to free.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeFcb\n", 0 );
    ASSERT( Fcb->BlockHeader.BlockType == BlockTypeFcb );

    ExFreePool( Fcb );

    DebugTrace( -1, Dbg, "MupFreeFcb -> VOID\n", 0 );
}


PCCB
MupCreateCcb(
    VOID
    )

/*++

Routine Description:

    This routine allocates an CCB block

Arguments:

    None.

Return Value:

    A pointer to the allocated CCB.

--*/

{
    PCCB ccb;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupCreateCcb\n", 0 );

    //
    // Attempt to allocate memory.
    //

    ccb = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(CCB),
                ' puM');

    if (ccb == NULL) {

        return NULL;

    }

    //
    // Initialize the UNC provider block header
    //

    ccb->BlockHeader.BlockType = BlockTypeCcb;
    ccb->BlockHeader.BlockState = BlockStateActive;
    ccb->BlockHeader.ReferenceCount = 1;
    ccb->BlockHeader.BlockSize = sizeof( CCB );

    DebugTrace( -1, Dbg, "MupCreateCcb -> 0x%8lx\n", ccb );

    return ccb;
}

VOID
MupDereferenceCcb(
    PCCB Ccb
    )
{
    LONG result;

    DebugTrace( +1, Dbg, "MupDereferenceCcb\n", 0 );

    ASSERT( Ccb->BlockHeader.BlockType == BlockTypeCcb );

    result = InterlockedDecrement(
                 &Ccb->BlockHeader.ReferenceCount
                 );

    DebugTrace( 0, Dbg, "ReferenceCount = %d\n", Ccb->BlockHeader.ReferenceCount );

    if ( result == 0 ) {

        ACQUIRE_LOCK( &MupCcbListLock );
        RemoveEntryList( &Ccb->ListEntry );
        RELEASE_LOCK( &MupCcbListLock );

        //
        // Release our references then free the CCB.
        //

        ObDereferenceObject( Ccb->FileObject );

        MupDereferenceFcb( Ccb->Fcb );

        MupFreeCcb( Ccb );
    }

    DebugTrace( -1, Dbg, "MupDereferenceCcb -> VOID\n", 0 );
}

VOID
MupFreeCcb(
    PCCB Ccb
    )

/*++

Routine Description:

    This routine frees a CCB block

Arguments:

    A pointer to the CCB block to free.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeCcb\n", 0 );

    ASSERT( Ccb->BlockHeader.BlockType == BlockTypeCcb );

    ExFreePool( Ccb );

    DebugTrace( -1, Dbg, "MupFreeCcb -> VOID\n", 0 );
}


PUNC_PROVIDER
MupAllocateUncProvider(
    ULONG DataLength
    )

/*++

Routine Description:

    The routine allocates and initializes the VCB for the MUP.

Arguments:

    DataLength - The size (in bytes) of the UNC provider.

Return Value:

    None.

--*/

{
    PUNC_PROVIDER uncProvider;
    ULONG size;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupAllocateUncProvider\n", 0);

    size = DataLength + sizeof( UNC_PROVIDER );

    uncProvider = ExAllocatePoolWithTag(
                        PagedPool,
                        size,
                        ' puM');

    if (uncProvider != NULL) {

        //
        // Initialize the UNC provider block header
        //

        uncProvider->BlockHeader.BlockType = BlockTypeUncProvider;
        uncProvider->BlockHeader.BlockState = BlockStateActive;
        uncProvider->BlockHeader.ReferenceCount = 0;
        uncProvider->BlockHeader.BlockSize = size;

	// 
	// By default we will make the provider unregistered
	//

	uncProvider->Registered = FALSE;

    }

    DebugTrace(-1, Dbg, "MupAllocateUncProvider -> 0x%8lx\n", uncProvider);

    return uncProvider;
}


VOID
MupDereferenceUncProvider(
    PUNC_PROVIDER UncProvider
    )

/*++

Routine Description:

    The routine dereference a UNC provider block.

Arguments:

    UncProvider - A pointer to the UNC provider block.

Return Value:

    None.

--*/

{
    LONG result;

    DebugTrace(+1, Dbg, "MupDereferenceProvider\n", 0);

    ASSERT( UncProvider->BlockHeader.BlockType == BlockTypeUncProvider );

    result = InterlockedDecrement(
                 &UncProvider->BlockHeader.ReferenceCount
                 );

    DebugTrace(0, Dbg, "ReferenceCount = %d\n", UncProvider->BlockHeader.ReferenceCount);

    ASSERT( result >= 0 );

    //
    // Do not free this block, even if the result is zero.  This
    // saves us from having to reread information for this provider
    // from the registry when the provider re-registers.
    //

    DebugTrace(-1, Dbg, "MupDereferenceUncProvider -> VOID\n", 0);
}


VOID
MupCloseUncProvider(
    PUNC_PROVIDER UncProvider
    )

/*++

Routine Description:

    The routine closes a UNC provider block.

Arguments:

    UncProvider - A pointer to the UNC provider block.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupDereferenceProvider\n", 0);

    ASSERT( UncProvider->BlockHeader.BlockType == BlockTypeUncProvider );

    MupAcquireGlobalLock();

    if ( UncProvider->BlockHeader.BlockState == BlockStateActive ) {

        DebugTrace(0, Dbg, "Closing UNC provider %08lx\n", UncProvider );

        UncProvider->BlockHeader.BlockState = BlockStateClosing;

        //
        // Mark the provider as unregistered
        //

	UncProvider->Registered = FALSE;

        MupReleaseGlobalLock();

        //
        // Close our handle to the provider, and release our reference
        // to the file object.
        //

        if (UncProvider->FileObject != NULL) {
            ZwClose( UncProvider->Handle );
            ObDereferenceObject( UncProvider->FileObject );
        }

    } else {
        MupReleaseGlobalLock();
    }

    DebugTrace(-1, Dbg, "MupDereferenceUncProvider -> VOID\n", 0);

}


PKNOWN_PREFIX
MupAllocatePrefixEntry(
    ULONG DataLength
    )

/*++

Routine Description:

    The routine allocates known prefix block.

Arguments:

    DataLength - The size (in bytes) of the extra data to allocate in the
            buffer for the prefix buffer.

Return Value:

    A pointer to the newly allocated block or NULL if it could not be
    allocated.

--*/

{
    PKNOWN_PREFIX knownPrefix;
    ULONG size;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupAllocatePrefixEntry\n", 0);

    size = DataLength + sizeof( KNOWN_PREFIX );

    knownPrefix = ExAllocatePoolWithTag(
                        PagedPool,
                        size,
                        ' puM');

    if (knownPrefix == NULL) {

        return NULL;

    }

    RtlZeroMemory( knownPrefix, size );

    //
    // Initialize the UNC provider block header
    //

    knownPrefix->BlockHeader.BlockType = BlockTypeKnownPrefix;
    knownPrefix->BlockHeader.BlockState = BlockStateActive;
    knownPrefix->BlockHeader.ReferenceCount = 1;
    knownPrefix->BlockHeader.BlockSize = size;

    if ( DataLength > 0 ) {
        knownPrefix->Prefix.Buffer = (PWCH)(knownPrefix + 1);
        knownPrefix->Prefix.MaximumLength = (USHORT)DataLength;
    } else {
        //
        // It is up to the caller to really allocate the memory!
        //
        knownPrefix->PrefixStringAllocated = TRUE;
    }

    knownPrefix->Active = FALSE;

    MupCalculateTimeout( &knownPrefix->LastUsedTime );

    DebugTrace(-1, Dbg, "MupAllocatePrefixEntry -> 0x%8lx\n", knownPrefix);

    return knownPrefix;

}

VOID
MupDereferenceKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    )

/*++

Routine Description:

    The routine dereferences a Known prefix block.

    *** MupPrefixTableLock assumed held when this routine is called.
        Remains held on exit. ***

Arguments:

    KnownPrefix - A pointer to the Known prefix block.

Return Value:

    None.

--*/

{
    LONG result;

    DebugTrace(+1, Dbg, "MupDereferenceKnownPrefix\n", 0);

    ASSERT( KnownPrefix->BlockHeader.BlockType == BlockTypeKnownPrefix );

    result = InterlockedDecrement(
                 &KnownPrefix->BlockHeader.ReferenceCount
                 );

    DebugTrace(0, Dbg, "ReferenceCount = %d\n", KnownPrefix->BlockHeader.ReferenceCount);

    ASSERT( result >= 0 );

    if ( result == 0 ) {

        //
        // Remove the table entry
        //

        if ( KnownPrefix->InTable ) {
            RtlRemoveUnicodePrefix( &MupPrefixTable, &KnownPrefix->TableEntry );
            RemoveEntryList(&KnownPrefix->ListEntry);
        }

        //
        // Free the Prefix string.
        //

        if ( KnownPrefix->PrefixStringAllocated &&
            KnownPrefix->Prefix.Buffer != NULL ) {

            ExFreePool( KnownPrefix->Prefix.Buffer );
        }

        //
        // Dereference the associated UNC provider
        //

        if ( KnownPrefix->UncProvider != NULL ) {
            MupDereferenceUncProvider( KnownPrefix->UncProvider );
        }

        //
        // Time to free the block
        //

        MupFreeKnownPrefix( KnownPrefix );

    }

    DebugTrace( 0, Dbg, "MupDereferenceKnownPrefix -> VOID\n", 0 );
}

VOID
MupFreeKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    )

/*++

Routine Description:

    This routine frees a known prefix block

Arguments:

    A pointer to the known prefix block to free.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeKnownPrefix\n", 0 );

    ASSERT( KnownPrefix->BlockHeader.BlockType == BlockTypeKnownPrefix );

    ExFreePool( KnownPrefix );

    DebugTrace( -1, Dbg, "MupFreeKnownPrefix -> VOID\n", 0 );
}



PMASTER_FORWARDED_IO_CONTEXT
MupAllocateMasterIoContext(
    VOID
    )

/*++

Routine Description:

    This routine allocates a master fowarded io context block.

Arguments:

    None.

Return Value:

    A pointer to the master forwarded context block, or NULL if the
    allocation fails

--*/

{
    PMASTER_FORWARDED_IO_CONTEXT masterContext;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupAllocateMasterIoContext\n", 0 );

    masterContext = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof( MASTER_FORWARDED_IO_CONTEXT ),
                        ' puM');

    if (masterContext != NULL) {

        //
        // Initialize the block header
        //

        masterContext->BlockHeader.BlockType = BlockTypeMasterIoContext;
        masterContext->BlockHeader.BlockState = BlockStateActive;
        masterContext->BlockHeader.ReferenceCount = 1;
        masterContext->BlockHeader.BlockSize = sizeof( MASTER_FORWARDED_IO_CONTEXT );

    }

    DebugTrace( -1, Dbg, "MupAllocateWorkContext -> 0x%8lx\n", masterContext );

    return masterContext;
}



NTSTATUS
MupDereferenceMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext,
    PNTSTATUS Status
    )

/*++

Routine Description:

    The routine dereferences a Master forwarded io context block.
    If the count reaches zero the original IRP is completed.

Arguments:

    A pointer to the a master forwarded io context block.

    Status for this mini context.

Return Value:

    NTSTATUS - OPTIONAL - The status of the original IRP.

--*/

{
    int result;
    PIRP originalIrp;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;

    DebugTrace(+1, Dbg, "MupDereferenceMasterIoContext\n", 0);
    DebugTrace( 0, Dbg, "MasterContext = 0x%08lx\n", MasterContext );


    ASSERT( MasterContext->BlockHeader.BlockType == BlockTypeMasterIoContext );

    //
    //  If any requests pass then set Irp status to success and leave
    //  it as success. If they all fail then use the last errorcode.
    //  To make this work we create the context with an error status.
    //

    if (Status != NULL) {

        //
        //  We can modify MasterContext because we have it referenced and
        //  we write 32 bits which is atomic.
        //

        if (NT_SUCCESS(*Status)) {

            MasterContext->SuccessStatus = STATUS_SUCCESS;

        } else {

            MasterContext->ErrorStatus = *Status;

        }

    }

    DebugTrace(0, Dbg, "ReferenceCount        = %d\n", MasterContext->BlockHeader.ReferenceCount);
    DebugTrace(0, Dbg, "MasterContext->Status = %8lx\n", MasterContext->ErrorStatus);


    result = InterlockedDecrement(
                 &MasterContext->BlockHeader.ReferenceCount
                 );

    ASSERT( result >= 0 );

    if ( result == 0 ) {

        //
        // Complete the original IRP
        //

        originalIrp = MasterContext->OriginalIrp;

        irpSp = IoGetCurrentIrpStackLocation( originalIrp );
        if ( irpSp->MajorFunction == IRP_MJ_WRITE ) {
            originalIrp->IoStatus.Information = irpSp->Parameters.Write.Length;
        } else {
            originalIrp->IoStatus.Information = 0;
        }

        //
        //  If any requests pass then set Irp status to success and return
        //  success. If they all fail then use the last errorcode.
        //

        if (NT_SUCCESS(MasterContext->SuccessStatus)) {

            status = STATUS_SUCCESS;

        } else {

            status = MasterContext->ErrorStatus;

        }

        DebugTrace(0, Dbg, "MupCompleteRequest = %8lx\n", status);
        MupCompleteRequest( originalIrp, status );

        //
        // Dereference the FCB
        //

        MupDereferenceFcb( MasterContext->Fcb );

        //
        // Free the Master context block
        //

        MupFreeMasterIoContext( MasterContext );

        // return status

    } else {

        status = STATUS_PENDING;

    }

    DebugTrace( 0, Dbg, "MupDereferenceMasterIoContext -> %X\n", status );

    return status;
}

VOID
MupFreeMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext
    )

/*++

Routine Description:

    This routine frees a master forwarded io context block.

Arguments:

    A pointer to the a master forwarded io context block.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeMasterIoContext\n", 0 );

    ASSERT( MasterContext->BlockHeader.BlockType == BlockTypeMasterIoContext );
    ExFreePool( MasterContext );

    DebugTrace( -1, Dbg, "MupFreeMasterIoContext -> VOID\n", 0 );
}




PMASTER_QUERY_PATH_CONTEXT
MupAllocateMasterQueryContext(
    VOID
    )

/*++

Routine Description:

    This routine allocates a master query path context block.

Arguments:

    None.

Return Value:

    A pointer to the master query path block.  If the allocation
    fails, NULL is returned.

--*/

{
    PMASTER_QUERY_PATH_CONTEXT masterContext;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupAllocateMasterQueryContext\n", 0 );

    masterContext = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof( MASTER_QUERY_PATH_CONTEXT ),
                        ' puM');

    if (masterContext == NULL) {

        return NULL;

    }


    //
    // Initialize the block header
    //

    masterContext->BlockHeader.BlockType = BlockTypeMasterQueryContext;
    masterContext->BlockHeader.BlockState = BlockStateActive;
    masterContext->BlockHeader.ReferenceCount = 1;
    masterContext->BlockHeader.BlockSize = sizeof( MASTER_QUERY_PATH_CONTEXT );
    InitializeListHead(&masterContext->MasterQueryList);
    InitializeListHead(&masterContext->QueryList);


    INITIALIZE_LOCK(
        &masterContext->Lock,
        QUERY_CONTEXT_LOCK_LEVEL,
        "Master query context lock"
        );

    DebugTrace( -1, Dbg, "MupAllocateMasterQueryContext -> 0x%8lx\n", masterContext );

    return masterContext;
}

NTSTATUS
MupDereferenceMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    )

/*++

Routine Description:

    The routine dereferences a Master query path context block.
    If the count reaches zero the original IRP is completed.

Arguments:

    A pointer to the a master query path context block.

Return Value:

    NTSTATUS - The final create IRP status.

--*/

{
    LONG result;
    NTSTATUS status;

    DebugTrace(+1, Dbg, "MupDereferenceMasterQueryContext\n", 0);
    DebugTrace( 0, Dbg, "MasterContext = 0x%08lx\n", MasterContext );

    ASSERT( MasterContext->BlockHeader.BlockType == BlockTypeMasterQueryContext );

    MupAcquireGlobalLock();

    result = --MasterContext->BlockHeader.ReferenceCount;
             
    MupReleaseGlobalLock();
    DebugTrace(0, Dbg, "ReferenceCount = %d\n", MasterContext->BlockHeader.ReferenceCount);

    ASSERT( result >= 0 );

    if ( result == 0 ) {

        BOOLEAN fActive;

        if (MasterContext->OriginalIrp == NULL) {

            DbgPrint("OriginalIrp == NULL, MasterContext=0x%x\n", MasterContext);
            KeBugCheck( FILE_SYSTEM );

        }

	// we are done with this master query so remove it from the global list
	MupAcquireGlobalLock();
	RemoveEntryList(&MasterContext->MasterQueryList);
	MupReleaseGlobalLock();


        ACQUIRE_LOCK( &MupPrefixTableLock );

        fActive = MasterContext->KnownPrefix->Active;

        MupDereferenceKnownPrefix( MasterContext->KnownPrefix );

        //
        // Reroute the request and complete the original IRP
        //

        if (( MasterContext->Provider != NULL) &&
	    ( MasterContext->ErrorStatus == STATUS_SUCCESS )) {

            //
            // Remove final ref if nothing ended up in the table
            //
            if (fActive == FALSE) {
                MupDereferenceKnownPrefix( MasterContext->KnownPrefix );
            }

            RELEASE_LOCK( &MupPrefixTableLock );

	    MUP_TRACE_NORM(TRACE_IRP, MupDereferenceMasterQueryContext_RerouteOpen,
			   LOGUSTR(MasterContext->Provider->DeviceName)
			   LOGUSTR(MasterContext->FileObject->FileName)
			   LOGPTR(MasterContext->OriginalIrp)
			   LOGPTR(MasterContext->FileObject));
            status = MupRerouteOpen(
                         MasterContext->FileObject,
                         MasterContext->Provider
                         );

        } else {

	    if (MasterContext->Provider != NULL) {
		MupDereferenceUncProvider(MasterContext->Provider);
	    }

            //
            // No provider claimed this open.  Dereference the known prefix
            // entry and fail the create request.
            //

            MupDereferenceKnownPrefix( MasterContext->KnownPrefix );
            RELEASE_LOCK( &MupPrefixTableLock );
            status = MasterContext->ErrorStatus;

        }

	MUP_TRACE_NORM(TRACE_IRP, MupDereferenceMasterQueryContext_CompleteRequest,
		       LOGPTR(MasterContext->OriginalIrp)
		       LOGSTATUS(status));
        FsRtlCompleteRequest( MasterContext->OriginalIrp, status );
        MasterContext->OriginalIrp = NULL;
        MupFreeMasterQueryContext( MasterContext );

    } else {

        status = STATUS_PENDING;

    }

    DebugTrace( 0, Dbg, "MupDereferenceMasterQueryContext -> 0x%08lx\n", status );

    return status;

}

VOID
MupFreeMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    )

/*++

Routine Description:

    This routine frees a master query path context block.

Arguments:

    A pointer to the a master query path context block.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeMasterQueryPathContext\n", 0 );

    ASSERT( BlockType( MasterContext ) == BlockTypeMasterQueryContext );

    DELETE_LOCK( &MasterContext->Lock );
    ExFreePool( MasterContext );

    DebugTrace( -1, Dbg, "MupFreeMasterQueryPathContext -> VOID\n", 0 );
}

VOID
MupCalculateTimeout(
    PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine calculates the an absolute timeout time.  This value
    equals the current system time plus the MUP timeout time.

Arguments:

    A pointer to the time structure.

Return Value:

    None.

--*/

{
    LARGE_INTEGER now;

    PAGED_CODE();
    KeQuerySystemTime( &now );
    Time->QuadPart = now.QuadPart + MupKnownPrefixTimeout.QuadPart;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements the file cleanup routine for MUP.

Author:

    Manny Weiser (mannyw)    28-Dec-1991

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
MupCleanupVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    );

NTSTATUS
MupCleanupFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupCleanup )
#pragma alloc_text( PAGE, MupCleanupFcb )
#pragma alloc_text( PAGE, MupCleanupVcb )
#endif


NTSTATUS
MupCleanup (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the the cleanup IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the Irp

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    BLOCK_TYPE blockType;
    PVOID fsContext, fsContext2;
    PFILE_OBJECT FileObject;

    MupDeviceObject;
    PAGED_CODE();
    

    if (MupEnableDfs) {
        if ((MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) ||
                (MupDeviceObject->DeviceObject.DeviceType ==
                    FILE_DEVICE_DFS_FILE_SYSTEM)) {
            status = DfsFsdCleanup((PDEVICE_OBJECT) MupDeviceObject, Irp);
            return( status );
        }
    }


    FsRtlEnterFileSystem();

    try {

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        FileObject = irpSp->FileObject;
        MUP_TRACE_HIGH(TRACE_IRP, MupCleanup_Entry,
               LOGPTR(MupDeviceObject)
               LOGPTR(Irp)
               LOGPTR(FileObject));

        DebugTrace(+1, Dbg, "MupCleanup\n", 0);
        DebugTrace( 0, Dbg, "MupDeviceObject = %08lx\n", (ULONG)MupDeviceObject);
        DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
        DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed.
        //

        if ((blockType = MupDecodeFileObject( irpSp->FileObject,
                                              &fsContext,
                                              &fsContext2 )) == BlockTypeUndefined) {

            DebugTrace(0, Dbg, "The file is closed\n", 0);

            FsRtlExitFileSystem();

            MupCompleteRequest( Irp, STATUS_INVALID_HANDLE );
            status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "MupCleanup -> %08lx\n", status );
            MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCleanup_Error_FileClosed, 
                                 LOGSTATUS(status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
                                 LOGPTR(MupDeviceObject));
            return status;
        }

        //
        // Decide how to handle this IRP.
        //

        switch ( blockType ) {


        case BlockTypeVcb:       // Cleanup MUP

            status = MupCleanupVcb( MupDeviceObject,
                                    Irp,
                                    (PVCB)fsContext
                                    );

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            MupDereferenceVcb( (PVCB)fsContext );

            //
            // Cleanup the UNC Provider
            //

            if ( fsContext2 != NULL ) {
                MupCloseUncProvider((PUNC_PROVIDER)fsContext2 );
                MupDereferenceUncProvider( (PUNC_PROVIDER)fsContext2 );

                MupAcquireGlobalLock();
                MupProviderCount--;
                MupReleaseGlobalLock();
            }

            status = STATUS_SUCCESS;
            break;

        case BlockTypeFcb:

            if (((PFCB)fsContext)->BlockHeader.BlockState == BlockStateActive) {
	       MupCleanupFcb( MupDeviceObject,
                                       Irp,
                                       (PFCB)fsContext
                                       );
	       status = STATUS_SUCCESS;
	    }
	    else {
	      status = STATUS_INVALID_HANDLE;
              MUP_TRACE_HIGH(ERROR, MupCleanup_Error1, 
                             LOGSTATUS(status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject)
                             LOGPTR(MupDeviceObject));
	    }

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            MupDereferenceFcb( (PFCB)fsContext );

            break;

    #ifdef MUPDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheckEx( FILE_SYSTEM, 2, 0, 0, 0 );
            break;
    #endif

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();

    }

    FsRtlExitFileSystem();

    MUP_TRACE_HIGH(TRACE_IRP, MupCleanup_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(Irp)
                   LOGPTR(FileObject)
                   LOGPTR(MupDeviceObject));
    DebugTrace(-1, Dbg, "MupCleanup -> %08lx\n", status);
    return status;
}



NTSTATUS
MupCleanupVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    The routine cleans up a VCB.

Arguments:

    MupDeviceObject - A pointer the the MUP device object.

    Irp - Supplies the IRP associated with the cleanup.

    Vcb - Supplies the VCB for the MUP.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    MupDeviceObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCleanupVcb...\n", 0);

    //
    //  Now acquire exclusive access to the Vcb
    //

    ExAcquireResourceExclusiveLite( &MupVcbLock, TRUE );
    status = STATUS_SUCCESS;

    try {

        //
        // Ensure that this VCB is still active.
        //

        MupVerifyBlock( Vcb, BlockTypeVcb );

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        IoRemoveShareAccess( irpSp->FileObject,
                             &Vcb->ShareAccess );


    } finally {

        ExReleaseResourceLite( &MupVcbLock );
        DebugTrace(-1, Dbg, "MupCleanupVcb -> %08lx\n", status);
    }

    //
    //  And return to our caller
    //

    return status;
}


NTSTATUS
MupCleanupFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    The routine cleans up a FCB.

Arguments:

    MupDeviceObject - A pointer the the MUP device object.

    Irp - Supplies the IRP associated with the cleanup.

    Vcb - Supplies the VCB for the MUP.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN holdingGlobalLock;
    PLIST_ENTRY listEntry, nextListEntry;
    PCCB ccb;

    MupDeviceObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCleanupVcb...\n", 0);

    //
    //  Now acquire exclusive access to the Vcb
    //

    MupAcquireGlobalLock();
    holdingGlobalLock = TRUE;
    status = STATUS_SUCCESS;

    try {

        //
        // Ensure that this FCB is still active.
        //

        MupVerifyBlock( Fcb, BlockTypeFcb );

        Fcb->BlockHeader.BlockState = BlockStateClosing;

        MupReleaseGlobalLock();
        holdingGlobalLock = FALSE;

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        // Loop through the list of CCBs, and release the open reference
        // to each one.  We must be careful because:
        //
        //   (1)  We cannot dereference the Ccb with the CcbListLock held.
        //   (2)  Dereferncing a Ccb may cause it to be removed from this
        //        list and freed.
        //

        ACQUIRE_LOCK( &MupCcbListLock );

        listEntry = Fcb->CcbList.Flink;

        while ( listEntry != &Fcb->CcbList ) {

            nextListEntry = listEntry->Flink;
            RELEASE_LOCK( &MupCcbListLock );

            ccb = CONTAINING_RECORD( listEntry, CCB, ListEntry );
            MupDereferenceCcb( ccb );

            ACQUIRE_LOCK( &MupCcbListLock );

            listEntry = nextListEntry;
        }

        RELEASE_LOCK( &MupCcbListLock );

    } finally {

        if ( holdingGlobalLock ) {
            MupReleaseGlobalLock();
        }

        DebugTrace(-1, Dbg, "MupCleanupFcb -> %08lx\n", status);
    }

    //
    //  And return to our caller
    //

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements the file create routine for the MUP.

Author:

    Manny Weiser (mannyw)    16-Dec-1991

Revision History:

--*/

#include "mup.h"
//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
// Local functions
//

NTSTATUS
CreateRedirectedFile(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PIO_SECURITY_CONTEXT Security
    );

NTSTATUS
QueryPathCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MupRerouteOpenToDfs (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
BroadcastOpen (
    IN PIRP Irp
    );

IO_STATUS_BLOCK
OpenMupFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

NTSTATUS
IsThisASysVolPath(
    IN PUNICODE_STRING PathName,
    IN PUNICODE_STRING DCName);

NTSTATUS
MupDomainToDC(
    PUNICODE_STRING RootName,
    PUNICODE_STRING DCName);

BOOLEAN
MupFlushPrefixEntry (
   PUNICODE_STRING pathName
   );

VOID
MupInvalidatePrefixTable (
    VOID
    );

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName);



#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, BroadcastOpen )
#pragma alloc_text( PAGE, CreateRedirectedFile )
#pragma alloc_text( PAGE, MupCreate )
#pragma alloc_text( PAGE, MupRerouteOpenToDfs )
#pragma alloc_text( PAGE, OpenMupFileSystem )
#pragma alloc_text( PAGE, QueryPathCompletionRoutine )
#pragma alloc_text( PAGE, MupFlushPrefixEntry)
#pragma alloc_text( PAGE, MupInvalidatePrefixTable)
#pragma alloc_text( PAGE, IsThisASysVolPath)
#pragma alloc_text( PAGE, MupDomainToDC)
#ifdef TERMSRV
#pragma alloc_text( PAGE, TSGetRequestorSessionId )
#endif // TERMSRV
#endif

#ifdef TERMSRV

NTSTATUS
TSGetRequestorSessionId(
    IN PIRP pIrp,
    OUT PULONG pulSessionId
    )
/*++

Routine Description:

    This routine returns the session ID for user that is creating a file
    via the IRP_MJ_CREATE, IRP_MJ_CREATE_NAMED_PIPE or IRP_MJ_CREATE_MAILSLOT
    IRP requests.

Arguments:

    pIrp - pointer to the I/O Request Packet.

    pulSessionId - pointer to the session Id which is set upon successful
        return.

Return Value:

    STATUS_SUCCESS - if the session ID was available.
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    PFILE_OBJECT FileObject = pIrpSp->FileObject;
    PIO_SECURITY_CONTEXT pSecurityContext;
    PSECURITY_SUBJECT_CONTEXT pSecSubjectContext;
    UNICODE_STRING FileName = FileObject->FileName;

    switch (pIrpSp->MajorFunction) {
        case IRP_MJ_CREATE:
        case IRP_MJ_CREATE_NAMED_PIPE:
        case IRP_MJ_CREATE_MAILSLOT:
            pSecurityContext = pIrpSp->Parameters.Create.SecurityContext;
            break;

#if 0
        case IRP_MJ_CREATE_NAMED_PIPE:
            pSecurityContext = pIrpSp->Parameters.CreatePipe.SecurityContext;
            break;

        case IRP_MJ_CREATE_MAILSLOT:
            pSecurityContext = pIrpSp->Parameters.CreateMailslot.SecurityContext;
            break;
#endif // 0

        default:
            pSecurityContext = NULL;
            break;
    }

    if ( pSecurityContext == NULL ) {
        *pulSessionId = (ULONG) INVALID_SESSIONID;
        ntStatus = STATUS_UNSUCCESSFUL;
        MUP_TRACE_HIGH(ERROR, TSGetRequestorSessionId_Error1, 
                       LOGSTATUS(ntStatus)
                       LOGPTR(pIrp)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));

        goto Cleanup;
    }

    pSecSubjectContext = &pSecurityContext->AccessState->SubjectSecurityContext;

    ntStatus = SeQuerySessionIdToken(
                ((pSecSubjectContext->ClientToken != NULL) ?
                    pSecSubjectContext->ClientToken :
                    pSecSubjectContext->PrimaryToken ),
                pulSessionId);
Cleanup:

    if( !NT_SUCCESS( ntStatus ) ) {
        DebugTrace(0, Dbg,
            "TSGetRequestorSessionId returns error, 0x%lx\n",
            ntStatus);
    }
    else {
        DebugTrace(0, Dbg,
            "TSGetRequestorSessionId returns SessionID, %ld\n",
            *pulSessionId);
    }

    return(ntStatus);

}


#endif // TERMSRV


NTSTATUS
MupCreate (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the the Create IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    PFILE_OBJECT fileObject;
    PFILE_OBJECT relatedFileObject;
    STRING fileName;
    ACCESS_MASK desiredAccess;
    USHORT shareAccess;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    BOOLEAN caseInsensitive = TRUE; //**** Make all searches case insensitive
    PVCB vcb;


    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCreate\n", 0);

    //
    // Make local copies of our input parameters to make things easier.
    //

    irpSp             = IoGetCurrentIrpStackLocation( Irp );
    fileObject        = irpSp->FileObject;
    relatedFileObject = irpSp->FileObject->RelatedFileObject;
    fileName          = *((PSTRING)(&irpSp->FileObject->FileName));
    desiredAccess     = irpSp->Parameters.Create.SecurityContext->DesiredAccess;
    shareAccess       = irpSp->Parameters.Create.ShareAccess;
    vcb               = &MupDeviceObject->Vcb;

    DebugTrace( 0, Dbg, "Irp               = %08lx\n", (ULONG)Irp );
    DebugTrace( 0, Dbg, "FileObject        = %08lx\n", (ULONG)fileObject );
    DebugTrace( 0, Dbg, "FileName          = %Z\n",    (ULONG)&fileName );


    MUP_TRACE_HIGH(TRACE_IRP, MupCreate_Entry, 
                   LOGPTR(MupDeviceObject)
                   LOGPTR(fileObject)
                   LOGPTR(Irp)
                   LOGUSTR(fileName));

    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] MupCreate(%wZ)\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                &fileObject->FileName);
    }
#endif

    FsRtlEnterFileSystem();

    try {

        //
        // Check to see if this is an open that came in via a Dfs device
        // object.
        //

        if (MupEnableDfs) {
            if ((MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) ||
                    (MupDeviceObject->DeviceObject.DeviceType ==
                        FILE_DEVICE_DFS_FILE_SYSTEM)) {

                status = DfsFsdCreate( (PDEVICE_OBJECT) MupDeviceObject, Irp );
                MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCreate_Error_DfsFsdCreate, 
                                     LOGSTATUS(status)
                                     LOGPTR(fileObject)
                                     LOGPTR(Irp));
                try_return( NOTHING );
            }
        }

        //
        // Check if we are trying to open the mup file system
        //

        if ( fileName.Length == 0
                         &&
             ( relatedFileObject == NULL ||
               BlockType(relatedFileObject->FsContext) == BlockTypeVcb ) ) {

            DebugTrace(0, Dbg, "Open MUP file system\n", 0);

            Irp->IoStatus = OpenMupFileSystem( &MupDeviceObject->Vcb,
                                               fileObject,
                                               desiredAccess,
                                               shareAccess );

            status = Irp->IoStatus.Status;
            MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCreate_Error_OpenMupFileSystem, 
                                 LOGSTATUS(status)
                                 LOGPTR(fileObject)
                                 LOGPTR(Irp));
            
            MupCompleteRequest( Irp, status );
            try_return( NOTHING );
        }

        //
        // This is a UNC file open.  Try to pass the request on.
        //

        status  = CreateRedirectedFile(
                      Irp,
                      fileObject,
                      irpSp->Parameters.Create.SecurityContext
                      );
        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCreate_Error_CreateRedirectedFile, 
                             LOGSTATUS(status)
                             LOGPTR(fileObject)
                             LOGPTR(Irp));

    try_exit: NOTHING;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
	  // we need to complete the IRP.
	  // But first, get the error code.
	  status = GetExceptionCode();
	  MupCompleteRequest( Irp, status );
    }

    FsRtlExitFileSystem();

    MUP_TRACE_HIGH(TRACE_IRP, MupCreate_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(fileObject)
                   LOGPTR(Irp));
    DebugTrace(-1, Dbg, "MupCreate -> %08lx\n", status);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] MupCreate exit 0x%x\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
            status);
    }
#endif
    return status;
}



IO_STATUS_BLOCK
OpenMupFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

/*++

Routine Description:

    This routine attempts to open the VCB.

Arguments:

    Vcb - A pointer to the MUP volume control block.

    FileObject - A pointer to the IO system supplied file object for this
        Create IRP.

    DesiredAccess - The user specified desired access to the VCB.

    ShareAccess - The user specified share access to the VCB.

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupOpenMupFileSystem\n", 0 );
    MUP_TRACE_LOW(DEFAULT, OpenMupFileSystem_Entry, 
                   LOGPTR(Vcb)
                   LOGPTR(FileObject)
                   LOGULONG(DesiredAccess)
                   LOGXSHORT(ShareAccess));


    ExAcquireResourceExclusiveLite( &MupVcbLock, TRUE );

    try {

        //
        //  Set the new share access
        //

        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                       ShareAccess,
                                                       FileObject,
                                                       &Vcb->ShareAccess,
                                                       TRUE ))) {

            DebugTrace(0, Dbg, "bad share access\n", 0);
            MUP_TRACE_ERROR_HIGH(iosb.Status, ALL_ERROR, OpenMupFileSystem_Error_IoCheckShareAccess,
                                 LOGSTATUS(iosb.Status)
                                 LOGPTR(FileObject));
            try_return( NOTHING );
        }

        //
        // Supply the file object with a referenced pointer to the VCB.
        //

        MupReferenceBlock( Vcb );
        MupSetFileObject( FileObject, Vcb, NULL );

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;

    try_exit: NOTHING;

    } finally {

        ExReleaseResourceLite( &MupVcbLock );

    }

    //
    // Return to the caller.
    //

    MUP_TRACE_LOW(DEFAULT, OpenMupFileSystem_Exit, 
                  LOGSTATUS(iosb.Status)
                  LOGPTR(FileObject));
    DebugTrace(-1, Dbg, "MupOpenMupFileSystem -> Iosb.Status = %08lx\n", iosb.Status);
    return iosb;
}

NTSTATUS
CreateRedirectedFile(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PIO_SECURITY_CONTEXT SecurityContext
    )
/*++

Routine Description:

    This routine attempts to reroute a file create request to a redirector.
    It attempts to find the correct redirector in 2 steps.

    (1)  The routine checks a list of known prefixes.  If the file object -
    file name prefix matches a known prefix, the request is forwarded to
    the redirector that "owns" the prefix.

    (2)  The routine queries each redirector in turn, until one claims
    ownership of the file.  The request is then rerouted to that redirector.

    If after these steps no owner is located, the MUP fails the request.

Arguments:

    Irp - A pointer to the create IRP.

    FileObject - A pointer to the IO system supplied file object for this
        create request.

    SecurityContext - A pointer to the IO security context for this request.

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status = STATUS_BAD_NETWORK_PATH;

    PUNICODE_PREFIX_TABLE_ENTRY entry;
    PKNOWN_PREFIX knownPrefix = NULL;
    PLIST_ENTRY listEntry;
    PUNC_PROVIDER provider;
    PWCH buffer;
    LONG length;
    BOOLEAN ownLock;
    BOOLEAN providerReferenced = FALSE;
    BOOLEAN firstProvider = TRUE;

    PQUERY_PATH_REQUEST qpRequest;

    PMASTER_QUERY_PATH_CONTEXT masterContext = NULL;
    PQUERY_PATH_CONTEXT queryContext;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER now;
    UNICODE_STRING FileName = FileObject->FileName;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "CreateRedirectedFile\n", 0);
    MUP_TRACE_LOW(DEFAULT, CreateRedirectedFile_Entry,
		  LOGPTR(Irp)
		  LOGPTR(FileObject)
		  LOGUSTR(FileName));

// #ifdef TERMSRV
#if 0 // need to confirm with the citrix guys about this change.

    if( IsTerminalServer() ) {

        //
        // Translate the filename for terminal server based on the session ID.
        //
        // NOTE: This re-allocates FileObject->FileName as needed
        //

        TSTranslateClientName( Irp, FileObject );
    }

#endif // TERMSRV

    //
    // Handle empty filename
    //

    if (FileObject->FileName.Length == 0) {

        MupCompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST);
        status = STATUS_INVALID_DEVICE_REQUEST;
        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, CreateRedirectedFile_Error_EmptyFilename, 
                             LOGSTATUS(status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));
        DebugTrace(-1, Dbg, "CreateRedirectedFile exit 0x%x\n", status);
        return status;

    }

    //
    // Check to see if this file name begins with a known prefix.
    //

    ACQUIRE_LOCK( &MupPrefixTableLock );

    entry = RtlFindUnicodePrefix( &MupPrefixTable, &FileObject->FileName, TRUE );

    if ( entry != NULL ) {

        DebugTrace(0, Dbg, "Prefix %Z is known, rerouting...\n", (PSTRING)&FileObject->FileName);

        //
        // This is a known file, forward appropriately
        //

        knownPrefix = CONTAINING_RECORD( entry, KNOWN_PREFIX, TableEntry );

        KeQuerySystemTime( &now );

        if ( now.QuadPart < knownPrefix->LastUsedTime.QuadPart ) {

            //
            // The known prefix has not timed out yet, recalculate the
            // timeout time and reroute the open.
            //

            MupCalculateTimeout( &knownPrefix->LastUsedTime );
            status = MupRerouteOpen( FileObject, knownPrefix->UncProvider );
            RELEASE_LOCK( &MupPrefixTableLock );
            DebugTrace(-1, Dbg, "CreateRedirectedFile -> %8lx", status );
            MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, CreateRedirectedFile_Error_MupRerouteOpen,
                                 LOGSTATUS(status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
				 LOGUSTR(FileObject->FileName));

            if (status == STATUS_REPARSE)
                Irp->IoStatus.Information = IO_REPARSE;

            MupCompleteRequest( Irp, status );
            return status;

        } else {

            DebugTrace(0, Dbg, "Prefix %Z has timed out\n", (PSTRING)&FileObject->FileName);

            //
            // The known prefix has timed out, dereference it so that
            // it will get removed from the table.
            //
            if ( knownPrefix->InTable ) {
               MupRemoveKnownPrefixEntry( knownPrefix);
            }
            RELEASE_LOCK( &MupPrefixTableLock );
        }

    } else {

        RELEASE_LOCK( &MupPrefixTableLock );

    }

    //
    // Is this a client side mailslot file?  It is if the file name
    // is of the form \\server\mailslot\Anything, and this is a create
    // operation.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    buffer = (PWCH)FileObject->FileName.Buffer;
    length = FileObject->FileName.Length;

    if ( *buffer == L'\\' && irpSp->MajorFunction == IRP_MJ_CREATE ) {
        buffer++;
        while ( (length -= sizeof(WCHAR)) > 0 && *buffer++ != L'\\' )
           NOTHING;
        length -= sizeof(WCHAR);

        if (
            length >= (sizeof(L"MAILSLOT") - sizeof(WCHAR))
                &&
             _wcsnicmp(
                buffer,
                L"Mailslot",
                MIN(length/sizeof(WCHAR),(sizeof(L"MAILSLOT")-sizeof(WCHAR))/sizeof(WCHAR))) == 0
        ) {

            //
            // This is a mailslot file.  Forward the create IRP to all
            // redirectors that support broadcast.
            //

            DebugTrace(0, Dbg, "Prefix %Z is a mailslot\n", (ULONG)&FileObject->FileName);

            status = BroadcastOpen( Irp );
            if (status == STATUS_REPARSE)
                Irp->IoStatus.Information = IO_REPARSE;
            MUP_TRACE_LOW(DEFAULT, CreateRedirectedFile_Exit_Mailslot, 
                          LOGSTATUS(status)
                          LOGPTR(Irp)
                          LOGPTR(FileObject)
			  LOGUSTR(FileName));
            MupCompleteRequest( Irp, status );
            DebugTrace(-1, Dbg, "CreateRedirectedFile -> 0x%8lx\n", status );
            return status;

        }

    }

    //
    // Check to see if this is a Dfs name. If so, we'll handle it separately
    //

    if (MupEnableDfs &&
            (FileObject->FsContext2 != UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT))) {
        UNICODE_STRING pathName;
        UNICODE_STRING DCName;

        status = DfsFsctrlIsThisADfsPath( &FileObject->FileName, FALSE, &pathName );

        if (status == STATUS_SUCCESS) {

            DebugTrace(-1, Dbg, "Rerouting open of [%wZ] to Dfs\n", &FileObject->FileName);
            status = MupRerouteOpenToDfs(FileObject);
            if (status == STATUS_REPARSE)
                Irp->IoStatus.Information = IO_REPARSE;
            MupCompleteRequest( Irp, status );
            return( status );

        }

        //
        // If special table is not init'ed, and this is \<domainname>\<specialname>,
        // rewrite into \<dcname>\<specialname>
        //
        if (DfsData.Pkt.SpecialTable.SpecialEntryCount == 0) {
            DCName.Buffer = NULL;
            DCName.Length = DCName.MaximumLength = 0;
            status = IsThisASysVolPath(&FileObject->FileName, &DCName);
            if (status == STATUS_SUCCESS)
            {
                UNICODE_STRING NewName = FileObject->FileName;
                status = MupDomainToDC(&NewName, &DCName);
                
                if (DCName.Buffer != NULL)
                    ExFreePool(DCName.Buffer);

                if (status == STATUS_SUCCESS) 
                {
                    FileObject->FileName = NewName;
                }
                else
                {
                    return status;
                }
            }
        }
    }

    //
    // We don't know who owns this file, query the redirectors in sequence
    // until one works.
    //

    IoMarkIrpPending(Irp);

    //
    // Allocate the master context and knownprefix.  If either allocation fails, we'll
    // complete the irp with STATUS_INSUFFICIENT_RESOURCES
    //

    knownPrefix = MupAllocatePrefixEntry( 0 );

    if (knownPrefix == NULL) {
        MupCompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES);
        return STATUS_PENDING;

    }

    masterContext = MupAllocateMasterQueryContext();

    if (masterContext == NULL) {

        ExFreePool(knownPrefix);

        MupCompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES);
        return STATUS_PENDING;

    }

    try {

        masterContext->OriginalIrp = Irp;

        masterContext->FileObject = FileObject;
        masterContext->Provider = NULL;
        masterContext->KnownPrefix = knownPrefix;
        masterContext->ErrorStatus = STATUS_BAD_NETWORK_PATH;

        MupAcquireGlobalLock();
	// for debugging: insert the Master Context into the global list.
	InsertHeadList(&MupMasterQueryList, &masterContext->MasterQueryList);
        MupReferenceBlock( knownPrefix );
        MupReleaseGlobalLock();

        try {

            MupAcquireGlobalLock();
            ownLock = TRUE;

            listEntry = MupProviderList.Flink;
            while ( listEntry != &MupProviderList ) {

                provider = CONTAINING_RECORD(
                               listEntry,
                               UNC_PROVIDER,
                               ListEntry
                               );

                //
                // Reference the provider block so that it doesn't go away
                // while we are using it.
                //

                MupReferenceBlock( provider );
                providerReferenced = TRUE;

                MupReleaseGlobalLock();
                ownLock = FALSE;

		// only use this provider if it is registered
		if(provider->Registered) {

		    //
		    // Allocate buffers for the io request.
		    //

		    qpRequest = NULL;
		    queryContext = NULL;

		    qpRequest = ExAllocatePoolWithTag(
			PagedPool,
			sizeof( QUERY_PATH_REQUEST ) +
			FileObject->FileName.Length,
			' puM');

		    if (qpRequest == NULL) {
			ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
		    }

		    queryContext = ExAllocatePoolWithTag(
			PagedPool,
			sizeof( QUERY_PATH_CONTEXT ),
			' puM');

		    if (queryContext == NULL) {
			ExFreePool(qpRequest);
			ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
		    }

		    InitializeListHead(&queryContext->QueryList);
		    queryContext->MasterContext = masterContext;
		    queryContext->Buffer = qpRequest;

		    //
		    // Generate a query path request.
		    //

		    qpRequest->PathNameLength = FileObject->FileName.Length;
		    qpRequest->SecurityContext = SecurityContext;

		    RtlMoveMemory(
			qpRequest->FilePathName,
			FileObject->FileName.Buffer,
			FileObject->FileName.Length
			);

		    //
		    // Build the query path Io control IRP.
		    //

		    irp = MupBuildIoControlRequest(
			NULL,
			provider->FileObject,
			queryContext,
			IRP_MJ_DEVICE_CONTROL,
			IOCTL_REDIR_QUERY_PATH,
			qpRequest,
			sizeof( QUERY_PATH_REQUEST ) + FileObject->FileName.Length,
			qpRequest,
			sizeof( QUERY_PATH_RESPONSE ),
			QueryPathCompletionRoutine
			);

		    if ( irp == NULL ) {
			ExFreePool(qpRequest);
			ExFreePool(queryContext);
			ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
		    }

		    //
		    // Set the RequestorMode to KernelMode, since all the
		    // parameters to this Irp are in kernel space
		    //

		    irp->RequestorMode = KernelMode;

		    //
		    // Get a referenced pointer to the provider, the reference
		    // is release when the IO completes.
		    //

		    queryContext->Provider = provider;
		    queryContext->QueryIrp = irp;

		    MupAcquireGlobalLock();
		    MupReferenceBlock( provider );
		    MupReferenceBlock( masterContext );
		    MupReleaseGlobalLock();


		    // insert this query into the master context's list of queries (for debugging)
		    ACQUIRE_LOCK( &masterContext->Lock );
		    InsertHeadList(&masterContext->QueryList, &queryContext->QueryList);
		    RELEASE_LOCK( &masterContext->Lock );

		    //
		    // Submit the request.
		    //

  		    MUP_TRACE_HIGH(ALL_ERROR, CreateRedirectedFile_Before_IoCallDriver,
				   LOGPTR(masterContext->OriginalIrp)
				   LOGPTR(queryContext->QueryIrp)
				   LOGPTR(FileObject)
				   LOGUSTR(FileName)
				   LOGUSTR(provider->DeviceName));
		    status = IoCallDriver( provider->DeviceObject, irp );
		    MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, CreateRedirectedFile_Error_IoCallDriver,
					 LOGSTATUS(status)
					 LOGPTR(masterContext->OriginalIrp)
					 LOGPTR(FileObject)
					 LOGUSTR(provider->DeviceName));

		} // if registered

		//
		// Acquire the lock that protects the provider list, and get
		// a pointer to the next provider in the list.
		//
		    
		MupAcquireGlobalLock();
                ownLock = TRUE;
                listEntry = listEntry->Flink;

                MupDereferenceUncProvider( provider );
                providerReferenced = FALSE;

                //
                // If this is the first provider and it responded with SUCCESS, we can return early.
                // The list of providers is sorted in order of priority, so we know that this is
                // the highest prority provider and it can get to the destination.
                //

                if( firstProvider && (status == STATUS_SUCCESS) ) {
                    break;
                }

                firstProvider = FALSE;

            } // while

        } finally {

            //
            // Dereference the previous provider.
            //

            if ( providerReferenced ) {
                MupDereferenceUncProvider( provider );
            }

            if ( ownLock ) {
                MupReleaseGlobalLock();
            }
        }


    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        masterContext->ErrorStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(masterContext != NULL);

    //
    // Release our reference to the query context.
    //

    MupDereferenceMasterQueryContext( masterContext );

    status = STATUS_PENDING;

    MUP_TRACE_LOW(DEFAULT, CreateRedirectedFile_Exit, 
                  LOGSTATUS(status)
                  LOGPTR(Irp)
                  LOGPTR(FileObject));
    DebugTrace(-1, Dbg, "CreateRedirectedFile -> 0x%8lx\n", status );
    return status;
}

NTSTATUS
MupRerouteOpen (
    IN PFILE_OBJECT FileObject,
    IN PUNC_PROVIDER UncProvider
    )

/*++

Routine Description:

    This routine redirects an create IRP request to the specified redirector
    by changing the name of the file and returning STATUS_REPARSE to the
    IO system

Arguments:

    FileObject - The file object to open

    UncProvider - The UNC provider that will process the create IRP.

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    PCHAR buffer;
    ULONG deviceNameLength;
    ULONG nameLength;
    NTSTATUS status;
    UNICODE_STRING FileName = FileObject->FileName;
    //
    // Check that we won't create a name that is too long
    //

    nameLength = UncProvider->DeviceName.Length + FileObject->FileName.Length;

    if (nameLength > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpen_Error1, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
        return STATUS_NAME_TOO_LONG;
    }

    //
    //  Allocate storage for the new file name.
    //

    buffer = ExAllocatePoolWithTag(
                 PagedPool,
                 UncProvider->DeviceName.Length + FileObject->FileName.Length,
                 ' puM');

    if ( buffer ==  NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpen_Error2, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
        return status;
    }

    //
    // Copy the device name to the string buffer.
    //

    RtlMoveMemory(
        buffer,
        UncProvider->DeviceName.Buffer,
        UncProvider->DeviceName.Length);

    deviceNameLength = UncProvider->DeviceName.Length;

    //
    // Append the file name
    //

    RtlMoveMemory(
        buffer + deviceNameLength,
        FileObject->FileName.Buffer,
        FileObject->FileName.Length);

    //
    // Free the old file name string buffer.
    //

    ExFreePool( FileObject->FileName.Buffer );

    FileObject->FileName.Buffer = (PWCHAR)buffer;
    FileObject->FileName.MaximumLength = FileObject->FileName.Length + (USHORT)deviceNameLength;
    FileObject->FileName.Length = FileObject->FileName.MaximumLength;

    //
    // Tell the file system to try again.
    //

    return STATUS_REPARSE;
}

NTSTATUS
MupRerouteOpenToDfs (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine redirects an create IRP request to the Dfs part of this
    driver by changing the name of the file and returning
    STATUS_REPARSE to the IO system

Arguments:

    FileObject - The file object to open

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    PCHAR buffer;
    ULONG deviceNameLength;
    ULONG nameLength;
    NTSTATUS status;
    UNICODE_STRING FileName = FileObject->FileName;

    PAGED_CODE();

    MUP_TRACE_NORM(TRACE_IRP, MupRerouteOpenToDfs_Entry,
		   LOGPTR(FileObject)
		   LOGUSTR(FileName));

#if DBG
    if (MupVerbose)
        DbgPrint("MupRerouteOpenToDfs(%wZ)\n", &FileObject->FileName);
#endif

    deviceNameLength = sizeof(DFS_DEVICE_ROOT) - sizeof(UNICODE_NULL);

    //
    // Check that we won't create a name that is too long
    //

    nameLength = deviceNameLength + FileObject->FileName.Length;

    if (nameLength > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpenToDfs_Error1, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
#if DBG
        if (MupVerbose)
            DbgPrint("MupRerouteOpenToDfs exit STATUS_NAME_TOO_LONG\n");
#endif
        return STATUS_NAME_TOO_LONG;
    }

    //
    //  Allocate storage for the new file name.
    //

    buffer = ExAllocatePoolWithTag(
                 PagedPool,
                 sizeof(DFS_DEVICE_ROOT) + FileObject->FileName.Length,
                 ' puM');

    if ( buffer ==  NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpenToDfs_Error2, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
#if DBG
        if (MupVerbose)
            DbgPrint("MupRerouteOpenToDfs exit STATUS_INSUFFICIENT_RESOURCES\n");
#endif
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the device name to the string buffer.
    //

    RtlMoveMemory(
        buffer,
        DFS_DEVICE_ROOT,
        sizeof(DFS_DEVICE_ROOT));

    //
    // Append the file name
    //

    RtlMoveMemory(
        buffer + deviceNameLength,
        FileObject->FileName.Buffer,
        FileObject->FileName.Length);

    //
    // Free the old file name string buffer.
    //

    ExFreePool( FileObject->FileName.Buffer );

    FileObject->FileName.Buffer = (PWCHAR)buffer;
    FileObject->FileName.MaximumLength = FileObject->FileName.Length + (USHORT)deviceNameLength;
    FileObject->FileName.Length = FileObject->FileName.MaximumLength;

    //
    // Tell the file system to try again.
    //

#if DBG
    if (MupVerbose)
        DbgPrint("MupRerouteOpenToDfs exit STATUS_REPARSE ->[%wZ]\n", &FileObject->FileName);
#endif
    return STATUS_REPARSE;
}


NTSTATUS
BroadcastOpen (
    PIRP Irp
    )

/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status;
    PFCB fcb;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject;
    BOOLEAN requestForwarded;
    PLIST_ENTRY listEntry;
    PUNC_PROVIDER uncProvider, previousUncProvider = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    PCCB ccb;
    OBJECT_HANDLE_INFORMATION handleInformation;
    HANDLE handle;
    BOOLEAN lockHeld = FALSE;
    BOOLEAN providerReferenced = FALSE;
    ULONG Len;
    UNICODE_STRING FileName;

    NTSTATUS statusToReturn = STATUS_NO_SUCH_FILE;
    ULONG priorityOfStatus = 0xFFFFFFFF;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "BroadcastOpen\n", 0 );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    FileName = irpSp->FileObject->FileName;
    try {

        //
        // Create a FCB for this file.
        //

        fcb = MupCreateFcb( );

        if (fcb == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            MUP_TRACE_HIGH(ERROR, BroadcastOpen_Error1, 
                           LOGSTATUS(status)
                           LOGPTR(Irp)
                           LOGPTR(irpSp->FileObject)
			   LOGUSTR(FileName));
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        try {

            //
            // Set the file object back pointers and our pointer to the
            // server file object.
            //

            fileObject = irpSp->FileObject;

            MupAcquireGlobalLock();
            lockHeld = TRUE;

            MupSetFileObject( fileObject,
                              fcb,
                              NULL );

            fcb->FileObject = fileObject;

            //
            // Loop through the list of UNC providers and try to create the
            // file on all file systems that support broadcast.
            //

            requestForwarded = FALSE;

            listEntry = MupProviderList.Flink;

            while ( listEntry != &MupProviderList ) {

                uncProvider = CONTAINING_RECORD( listEntry, UNC_PROVIDER, ListEntry );

                //
                // Reference the provider so that it won't go away
                //

                MupReferenceBlock( uncProvider );
                providerReferenced = TRUE;

                MupReleaseGlobalLock();
                lockHeld = FALSE;

                Len = uncProvider->DeviceName.Length + fileObject->FileName.Length;

                if ( uncProvider->MailslotsSupported && Len <= MAXUSHORT) {

                    //
                    // Build the rerouted file name, consisting of the file
                    // named we received appended to the UNC provider device
                    // name.
                    //

                    UNICODE_STRING fileName;

                    fileName.MaximumLength = fileName.Length = (USHORT) Len;

                    fileName.Buffer =
                        ExAllocatePoolWithTag(
                            PagedPool,
                            fileName.MaximumLength,
                            ' puM');

                    if (fileName.Buffer == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        MUP_TRACE_HIGH(ERROR, BroadcastOpen_Error2, 
                                       LOGSTATUS(status)
                                       LOGPTR(Irp)
                                       LOGPTR(fileObject)
				       LOGUSTR(FileName));
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }

                    RtlMoveMemory(
                        fileName.Buffer,
                        uncProvider->DeviceName.Buffer,
                        uncProvider->DeviceName.Length
                        );

                    RtlMoveMemory(
                        (PCHAR)fileName.Buffer + uncProvider->DeviceName.Length,
                        fileObject->FileName.Buffer,
                        fileObject->FileName.Length
                        );


                    //
                    // Attempt to open the file.  Copy all of the information
                    // from the create IRP we received, masking off additional
                    // baggage that the IO system added along the way.
                    //

                    DebugTrace( 0, Dbg, "Attempt to open %Z\n", (ULONG)&fileName );

                    InitializeObjectAttributes(
                        &objectAttributes,
                        &fileName,
                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                        0,
                        NULL                   // !!! Security
                        );

                    status = IoCreateFile(
                              &handle,
                              irpSp->Parameters.Create.SecurityContext->DesiredAccess & 0x1FF,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              irpSp->Parameters.Create.FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS,
                              irpSp->Parameters.Create.ShareAccess & FILE_SHARE_VALID_FLAGS,
                              FILE_OPEN,
                              irpSp->Parameters.Create.Options & FILE_VALID_SET_FLAGS,
                              NULL,               // Ea buffer
                              0,                  // Ea length
                              CreateFileTypeNone,
                              NULL,               // parameters
                              IO_NO_PARAMETER_CHECKING
                              );

                    MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, BroadcastOpen_Error_IoCreateFile,
                                         LOGSTATUS(status)
                                         LOGPTR(Irp)
                                         LOGPTR(fileObject)
					 LOGUSTR(FileName));
                    ExFreePool( fileName.Buffer );

                    if ( NT_SUCCESS( status ) ) {
                        status = ioStatusBlock.Status;
                   

			ccb = MupCreateCcb( );

			if (ccb == NULL) {

			    status = STATUS_INSUFFICIENT_RESOURCES;
			    MUP_TRACE_HIGH(ERROR, BroadcastOpen_Error3, 
					   LOGSTATUS(status)
					   LOGPTR(Irp)
					   LOGPTR(fileObject)
					   LOGUSTR(FileName));

			}
		    }

                    if ( NT_SUCCESS( status ) ) {

                        DebugTrace( 0, Dbg, "Open attempt succeeded\n", 0 );

                       //
                       // 426184, need to check return code for errors.
                       //
                        status = ObReferenceObjectByHandle(
                                     handle,
                                     0,
                                     NULL,
                                     KernelMode,
                                     (PVOID *)&ccb->FileObject,
                                     &handleInformation );
                        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, BroadcastOpen_Error_ObReferenceObjectByHandle,
                                             LOGSTATUS(status)
                                             LOGPTR(Irp)
                                             LOGPTR(fileObject)
					     LOGUSTR(FileName));

                        ZwClose( handle );
                    }

                    if ( NT_SUCCESS( status ) ) {
                        ccb->DeviceObject =
                            IoGetRelatedDeviceObject( ccb->FileObject );

                        ccb->Fcb = fcb;

                        MupAcquireGlobalLock();
                        lockHeld = TRUE;
                        MupReferenceBlock( fcb );
                        MupReleaseGlobalLock();
                        lockHeld = FALSE;

                        //
                        // At least one provider will accept this mailslot
                        // request.
                        //

                        requestForwarded = TRUE;

                        //
                        // Keep a list of CCBs.  Since we just created the FCB
                        // there is no need to use the lock to access the list.
                        //

                        InsertTailList( &fcb->CcbList, &ccb->ListEntry );

                    } else { // NT_SUCCESS( status ), IoCreateFile

                        DebugTrace( 0, Dbg, "Open attempt failed %8lx\n", status );

                        //
                        // Remember the status code if this is the highest
                        // priority provider so far.  This code is returned if
                        // all providers fail the Create operation.
                        //

                        if ( uncProvider->Priority <= priorityOfStatus ) {
                            priorityOfStatus = uncProvider->Priority;
                            statusToReturn = status;
                        }

                    }

                }  // uncProvider->MailslotsSupported

                MupAcquireGlobalLock();
                lockHeld = TRUE;

                listEntry = listEntry->Flink;

                //
                // It is now safe to dereference the previous provider.
                //

                MupDereferenceUncProvider( uncProvider );
                providerReferenced = FALSE;

            } // while

            MupReleaseGlobalLock();
            lockHeld = FALSE;

            //
            //  And set our return status
            //

            if ( requestForwarded ) {
                status = STATUS_SUCCESS;
            } else {
                status = statusToReturn;
            }

        } finally {

            DebugTrace(-1, Dbg, "BroadcastOpen -> %08lx\n", status);

            if ( providerReferenced ) {
                MupDereferenceUncProvider( uncProvider );
            }

            if ( lockHeld ) {
                MupReleaseGlobalLock();
            }

            //
            // Now if we ever terminate the preceding try-statement with
            // a status that is not successful and the FCB pointer
            // is non-null then we need to deallocate the structure.
            //

            if (!NT_SUCCESS( status ) && fcb != NULL) {
                MupFreeFcb( fcb );
            }

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        NOTHING;

    }

    return status;
}


NTSTATUS
QueryPathCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine the querying a path.  Cleanup our
    IRP and complete the original IRP if necessary.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    PQUERY_PATH_RESPONSE qpResponse;
    PMASTER_QUERY_PATH_CONTEXT masterContext;
    PQUERY_PATH_CONTEXT queryPathContext;
    PCH buffer;
    PKNOWN_PREFIX knownPrefix;
    ULONG lengthAccepted;
    NTSTATUS status;

    DeviceObject;   // prevent compiler warnings

    queryPathContext = Context;
    masterContext = queryPathContext->MasterContext;

    qpResponse = queryPathContext->Buffer;
    lengthAccepted = qpResponse->LengthAccepted;

    status = Irp->IoStatus.Status;

    MUP_TRACE_NORM(TRACE_IRP, QueryPathCompletionRoutine_Enter,
		   LOGPTR(DeviceObject)
		   LOGPTR(Irp)
		   LOGUSTR(queryPathContext->Provider->DeviceName)
		   LOGPTR(masterContext->FileObject)
		   LOGUSTR(masterContext->FileObject->FileName)
		   LOGSTATUS(status)
		   );

    //
    // Acquire the lock to protect access to the master context Provider
    // field.
    //

    ACQUIRE_LOCK( &masterContext->Lock );

    // remove this query from the MasterQueryContext's list.
    RemoveEntryList(&queryPathContext->QueryList);


    if (NT_SUCCESS(status) && lengthAccepted != 0) {

        knownPrefix = masterContext->KnownPrefix;

        if ( masterContext->Provider != NULL ) {

            if ( queryPathContext->Provider->Priority < masterContext->Provider->Priority ) {

                //
                // A provider of higher priority (i.e. a lower priority code)
                // has claimed this prefix.  Release the previous provider's
                // claim.
                //

                ACQUIRE_LOCK( &MupPrefixTableLock );

                if ( knownPrefix->InTable ) {
		    RtlRemoveUnicodePrefix(&MupPrefixTable, &knownPrefix->TableEntry);
		    RemoveEntryList(&knownPrefix->ListEntry);
		    knownPrefix->InTable = FALSE;
                }

                RELEASE_LOCK( &MupPrefixTableLock );

		knownPrefix->Active = FALSE;


                //
                // If Dfs generated this query there will not have been anything
                // stored in the knowPrefix->Prefix, so we check if there is indeed
                // anything to free.
                //

                if (knownPrefix->Prefix.Length > 0 && knownPrefix->Prefix.Buffer != NULL) {
                    ExFreePool(knownPrefix->Prefix.Buffer);
                    knownPrefix->Prefix.Length = knownPrefix->Prefix.MaximumLength = 0;
                    knownPrefix->Prefix.Buffer = NULL;
		    knownPrefix->PrefixStringAllocated = FALSE;
                }
                if(knownPrefix->UncProvider) {
                    MupDereferenceUncProvider( knownPrefix->UncProvider );
		    knownPrefix->UncProvider = NULL;
                }

            } else {

                //
                // The current provider keeps ownership of the prefix.
                //

		MupDereferenceUncProvider( queryPathContext->Provider );
                goto not_this_one;
            }
        }

        //
        // This provider gets the prefix.
        //

        masterContext->Provider = queryPathContext->Provider;
	masterContext->ErrorStatus = status;
        //
        // We have found a match.  Attempt to remember it.
        //

        if (masterContext->FileObject->FsContext2 != UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT)) {

            buffer = ExAllocatePoolWithTag(
                        PagedPool,
                        lengthAccepted,
                        ' puM');

            if (buffer != NULL) {

                RtlMoveMemory(
                    buffer,
                    masterContext->FileObject->FileName.Buffer,
                    lengthAccepted
                    );

                //
                // Copy the reference provider pointer for the known prefix
                // block.
                //

                knownPrefix->UncProvider = masterContext->Provider;
                knownPrefix->Prefix.Buffer = (PWCH)buffer;
                knownPrefix->Prefix.Length = (USHORT)lengthAccepted;
                knownPrefix->Prefix.MaximumLength = (USHORT)lengthAccepted;
                knownPrefix->PrefixStringAllocated = TRUE;

                ACQUIRE_LOCK( &MupPrefixTableLock );

                if (RtlInsertUnicodePrefix(
                        &MupPrefixTable,
                        &knownPrefix->Prefix,
                        &knownPrefix->TableEntry) == TRUE) {

                    InsertTailList( &MupPrefixList, &knownPrefix->ListEntry);
                    knownPrefix->InTable = TRUE;
                    knownPrefix->Active = TRUE;

                } else {

                    knownPrefix->InTable = FALSE;

                }

                RELEASE_LOCK( &MupPrefixTableLock );

            } else {

                knownPrefix->InTable = FALSE;

            }

        }



    } else { 

	MupDereferenceUncProvider( queryPathContext->Provider );

	if (masterContext->Provider == NULL) {

	    //
	    // If our error status is more significant than the error status
	    //  stored in the masterContext, then put ours there
	    //

	    ULONG newError, oldError;

	    //
	    // MupOrderedErrorList is a list of error codes ordered from least
	    //  important to most important.  We're calling down to multiple
	    //  redirectors, but we can only return 1 error code on complete failure.
	    //
	    // To figure out which error to return, we look at the stored error and
	    //  the current error.  We return the error having the highest index in
	    //  the MupOrderedErrorList
	    //
	    if( NT_SUCCESS( masterContext->ErrorStatus ) ) {
		masterContext->ErrorStatus = status;
	    } else {
		for( oldError = 0; MupOrderedErrorList[ oldError ]; oldError++ )
		    if( masterContext->ErrorStatus == MupOrderedErrorList[ oldError ] )
			break;

		    for( newError = 0; newError < oldError; newError++ )
			if( status == MupOrderedErrorList[ newError ] )
			    break;

			if( newError >= oldError ) {
			    masterContext->ErrorStatus = status;
			}
	    }

	}
    }

not_this_one:


    //
    // Free our buffers
    //

    ExFreePool( qpResponse );
    ExFreePool( queryPathContext );
    IoFreeIrp( Irp );




    RELEASE_LOCK( &masterContext->Lock );
    MupDereferenceMasterQueryContext( masterContext );

    //
    // Return more processing required to the IO system so that it
    // doesn't attempt further processing on the IRP we just freed.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//+----------------------------------------------------------------------------
//
//  Function:   MupFlushPrefixEntry
//
//  Synopsis:   Given a pathname, checks if the mup has the prefix cached.
//              It removes the entry if it exists from the mup cache
//
//  Arguments:  [FileName] -- pathname which needs to be removed.
//
//  Returns:    TRUE if entry found in mup cache. False otherwise.
//
//-----------------------------------------------------------------------------



BOOLEAN
MupFlushPrefixEntry(
   PUNICODE_STRING pathName)
{
    PUNICODE_PREFIX_TABLE_ENTRY entry;
    PKNOWN_PREFIX knownPrefix;

    ACQUIRE_LOCK( &MupPrefixTableLock );

    entry = RtlFindUnicodePrefix( &MupPrefixTable, pathName, TRUE );

    if (entry != NULL) {
        knownPrefix = CONTAINING_RECORD( entry, KNOWN_PREFIX, TableEntry );
        if ( knownPrefix->InTable ) {
            MupRemoveKnownPrefixEntry( knownPrefix );
        }
    }
    RELEASE_LOCK( &MupPrefixTableLock );
    
    return (entry != NULL) ? TRUE : FALSE;
}



//+----------------------------------------------------------------------------
//
//  Function:   MupInvalidatePrefixTable
//
//  Synopsis:   Removes all the entries from the mup prefix table.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//-----------------------------------------------------------------------------


VOID
MupInvalidatePrefixTable(VOID)
{
    PLIST_ENTRY listEntry;
    PKNOWN_PREFIX knownPrefix;
    
    ACQUIRE_LOCK( &MupPrefixTableLock );

    listEntry = MupPrefixList.Flink;
    while ( listEntry != &MupPrefixList ) {
        knownPrefix = CONTAINING_RECORD( listEntry, KNOWN_PREFIX, ListEntry );
        listEntry = listEntry->Flink;
        if ( knownPrefix->InTable ) {
            MupRemoveKnownPrefixEntry( knownPrefix );
        }
    }

    RELEASE_LOCK( &MupPrefixTableLock );
}

VOID
MupRemoveKnownPrefixEntry(
       PKNOWN_PREFIX knownPrefix
)
{
    MUP_TRACE_LOW(KNOWN_PREFIX, MupRemoveKnownPrefixEntry,
                  LOGPTR(knownPrefix));

     RtlRemoveUnicodePrefix(&MupPrefixTable, &knownPrefix->TableEntry);
     RemoveEntryList(&knownPrefix->ListEntry);
     knownPrefix->InTable = FALSE;
     MupDereferenceKnownPrefix(knownPrefix);
}


NTSTATUS
IsThisASysVolPath(
    IN PUNICODE_STRING PathName,
    IN PUNICODE_STRING DCName)
{
/*++

Routine Description:

    Determines whether a given path is a domain-based path or not
    The general algorithm is:

      - Extract the first component of the path
      - See if it the domain name
      - If it is, and the 2nd component is SYSVOL or NETLOGON, return the DCName

Arguments

    PathName - Name of entire file
    DCName - If this is a domain-based path, this is the name of
                        a dc in the domain.

Returns value

    STATUS_SUCCESS -- PathName is a domain-based path
    STATUS_BAD_NETWORK_PATH -- PathName is not a domain-based path

--*/
    NTSTATUS status;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PUNICODE_STRING pName;
    UNICODE_STRING RootName;
    UNICODE_STRING ShareName;
    USHORT i;
    USHORT j;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1, Dbg, "IsThisASysVolPath: PathName %wZ \n", PathName);

    //
    // Only proceed if the first character is a backslash.
    //

    if (PathName->Buffer[0] != UNICODE_PATH_SEP) {
        DfsDbgTrace(-1, Dbg, "PathName does not begin with backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    //
    // Find the first component in the name.
    //

    for (i = 1;
            i < PathName->Length/sizeof(WCHAR) &&
                PathName->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {
        NOTHING;
    }

    if (PathName->Buffer[i] != UNICODE_PATH_SEP) {
        DfsDbgTrace(-1, Dbg, "Did not find second backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    RootName.Length = (i-1) * sizeof(WCHAR);
    RootName.MaximumLength = RootName.Length;
    RootName.Buffer = &PathName->Buffer[1];

    if (RootName.Length == 0)
        return( STATUS_BAD_NETWORK_PATH );

    //
    // Figure out the share name
    //

    for (j = i+1;
            j < PathName->Length/sizeof(WCHAR) &&
                PathName->Buffer[j] != UNICODE_PATH_SEP;
                        j++) {
         NOTHING;
    }

    ShareName.Length = (j - i - 1) * sizeof(WCHAR);
    ShareName.MaximumLength = ShareName.Length;
    ShareName.Buffer = &PathName->Buffer[i+1];

    if (ShareName.Length == 0 || DfspIsSysVolShare(&ShareName) == FALSE)
        return( STATUS_BAD_NETWORK_PATH );

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    if (
        (Pkt->DomainNameFlat.Buffer != NULL
            &&
        Pkt->DomainNameDns.Buffer != NULL
            &&
        Pkt->DCName.Buffer != NULL)
            &&
        (RtlCompareUnicodeString(&RootName, &Pkt->DomainNameFlat, TRUE) == 0
            ||
        RtlCompareUnicodeString(&RootName, &Pkt->DomainNameDns, TRUE) == 0)
    ) {
        pName = &Pkt->DCName;
        DCName->Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            pName->MaximumLength,
                            ' puM');
        if (DCName->Buffer != NULL) {
            DCName->Length = pName->Length;
            DCName->MaximumLength = pName->MaximumLength;
            RtlCopyMemory(
                DCName->Buffer,
                pName->Buffer,
                pName->MaximumLength);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        status = STATUS_BAD_NETWORK_PATH;
    }

    PktRelease();
    DfsDbgTrace(-1, Dbg, "IsThisASysVolPath: Exit -> %08lx\n", LongToPtr( status ) );
    return status;

}

NTSTATUS
MupDomainToDC(
    PUNICODE_STRING RootName,
    PUNICODE_STRING DCName)
{
/*++

Routine Description:

    This routine rewrites the file name of a domain-based path into a dc-based
    path.  Ex:  \domainfoo\sysvol -> \dc1\sysvol

Arguments:

    RootName - The RootName to rewrite

    DCName - The name of the DC to change the path to

Return Value:

    NTSTATUS - The status of the operation

--*/
    ULONG Size;
    PCHAR Buffer;
    PWCHAR pBuf;
    PWCHAR OrgBuffer;

    PAGED_CODE();

    DfsDbgTrace(+1, Dbg, "MupDomainToDC: RootName = %wZ\n", RootName);

    //
    // Only proceed if the first character is a backslash.
    //

    if (RootName->Buffer == NULL) {
        DfsDbgTrace(-1, Dbg, "RootName is NULL\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    if (RootName->Buffer[0] != UNICODE_PATH_SEP) {
        DfsDbgTrace(-1, Dbg, "RootName does not begin with backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    OrgBuffer = RootName->Buffer;

    //
    // Skip over leading UNICODE_PATH_SEP
    //

    RootName->Length -= sizeof(WCHAR);
    RootName->MaximumLength -= sizeof(WCHAR);
    RootName->Buffer++;

    //
    // Motor along until end of string or a UNICODE_PATH_SEP
    //

    while (RootName->Length > 0 && RootName->Buffer[0] != UNICODE_PATH_SEP) {
        RootName->Length -= sizeof(WCHAR);
        RootName->MaximumLength -= sizeof(WCHAR);
        RootName->Buffer++;
    }

    if (RootName->Length == 0) {
        DfsDbgTrace(-1, Dbg, "Did not find second backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );

    }
        
    //
    //  Allocate storage for the new file name.
    //

    Size = sizeof(WCHAR) +          // leading UNICODE_PATH_SEP
                DCName->Length +
                    RootName->Length;

    Buffer = ExAllocatePoolWithTag(
                 PagedPool,
                 Size,
                 ' puM');

    if ( Buffer ==  NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Leading UNICODE_PATH_SEP's
    //

    pBuf = (WCHAR *)Buffer;
    *pBuf++ = UNICODE_PATH_SEP;

    //
    // Copy the DC name to the buffer
    //

    RtlMoveMemory(
        pBuf,
        DCName->Buffer,
        DCName->Length);

    pBuf += DCName->Length / sizeof(WCHAR);

    //
    // Append the trailing file name
    //

    RtlMoveMemory(
        pBuf,
        RootName->Buffer,
        RootName->Length);

    //
    // Free the old file name string buffer.
    //

    ExFreePool( OrgBuffer );

    RootName->Buffer = (PWCHAR)Buffer;
    RootName->Length = (USHORT) Size;
    RootName->MaximumLength = (USHORT) Size;

    DfsDbgTrace(+1, Dbg, "MupDomainToDC: Exit\n", 0);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\attach.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       ATTACH.C
//
//  Contents:   This module contains routines for managing attached file
//              systems.
//
//  Functions:
//
//  History:    15 May 1992  PeterCo  Created.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "mupwml.h"

#define Dbg              (DEBUG_TRACE_ATTACH)

#ifdef ALLOC_PRAGMA

//
// The following are not pageable since they can be called at DPC level
//
// DfsVolumePassThrough
// DfsFilePassThrough
//

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsVolumePassThrough, public
//
//  Synopsis:   This is the main FSD routine that passes a request
//              on to an attached-to device, or to a redirected
//              file.
//
//  Arguments:  [DeviceObject] -- Supplies a pointer to the Dfs device
//                      object this request was aimed at.
//              [Irp] -- Supplies a pointer to the I/O request packet.
//
//  Returns:    [STATUS_INVALID_DEVICE_REQUEST] -- If the DeviceObject
//                      argument is of unknown type, or the type of file
//                      is invalid for the request being performed.
//
//              NT Status from calling the underlying file system that
//                      opened the file.
//
//--------------------------------------------------------------------

NTSTATUS
DfsVolumePassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;

    DfsDbgTrace(+1, Dbg, "DfsVolumePassThrough: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    MUP_TRACE_HIGH(TRACE_IRP, DfsVolumePassThrough_Entry,
                   LOGPTR(DeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject));

    DfsDbgTrace(0, Dbg, "DeviceObject    = %x\n", DeviceObject);
    DfsDbgTrace(0, Dbg, "Irp             = %x\n", Irp        );
    DfsDbgTrace(0, Dbg, "  MajorFunction = %x\n", IrpSp->MajorFunction );
    DfsDbgTrace(0, Dbg, "  MinorFunction = %x\n", IrpSp->MinorFunction );

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS && IrpSp->FileObject != NULL) {

        TYPE_OF_OPEN TypeOfOpen;
        PDFS_VCB Vcb;
        PDFS_FCB Fcb;

        TypeOfOpen = DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb);

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        if (TypeOfOpen == RedirectedFileOpen) {

            //
            // Copy the stack from one to the next...
            //

            NextIrpSp = IoGetNextIrpStackLocation(Irp);

            (*NextIrpSp) = (*IrpSp);

            IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

            //
            //  ...and call the next device
            //

            Status = IoCallDriver( Fcb->TargetDevice, Irp );
            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsVolumePassThrough_Error_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
                                 LOGPTR(DeviceObject));

        } else {

            DfsDbgTrace(0, Dbg, "DfsVolumePassThrough: TypeOfOpen = %s\n",
                ((TypeOfOpen == UnopenedFileObject) ? "UnopenedFileObject":
                    (TypeOfOpen == LogicalRootDeviceOpen) ?
                        "LogicalRootDeviceOpen" : "???"));

            DfsDbgTrace(0, Dbg, "Irp             = %x\n", Irp);

            DfsDbgTrace(0, Dbg, " MajorFunction = %x\n", IrpSp->MajorFunction);

            DfsDbgTrace(0, Dbg, " MinorFunction = %x\n", IrpSp->MinorFunction);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            MUP_TRACE_HIGH(ERROR, DfsVolumePassThrough_Error1, 
                           LOGSTATUS(Status)
                           LOGPTR(Irp)
                           LOGPTR(FileObject)
                           LOGPTR(DeviceObject));

            Irp->IoStatus.Status = Status;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

        }

    } else {

        DfsDbgTrace(0, Dbg, "DfsVolumePassThrough: Unexpected Dev = %x\n",
                                DeviceObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;

        MUP_TRACE_HIGH(ERROR, DfsVolumePassThrough_Error2, 
                       LOGSTATUS(Status)
                       LOGPTR(Irp)
                       LOGPTR(FileObject)
                       LOGPTR(DeviceObject));
        Irp->IoStatus.Status = Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DfsDbgTrace(-1, Dbg, "DfsVolumePassThrough: Exit -> %08lx\n", ULongToPtr(Status));

    MUP_TRACE_HIGH(TRACE_IRP, DfsVolumePassThrough_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(Irp)
                   LOGPTR(FileObject)
                   LOGPTR(DeviceObject));
    return Status;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsFilePassThrough, public
//
//  Synopsis:   Like DfsVolumePassThrough, but used when the file object
//              has already been looked up, and the FCB for the file is
//              already known.  This is needed especially in close processing
//              to avoid a race between DfsLookupFcb (for a reused file object)
//              and DfsDetachFcb.
//
//  Arguments:  [pFcb] -- A pointer to an FCB for the file.
//              [Irp]  -- A pointer to the I/O request packet.
//
//  Returns:    NTSTATUS - the return value from IoCallDriver.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFilePassThrough(
    IN PDFS_FCB pFcb,
    IN PIRP Irp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;


    DfsDbgTrace(+1, Dbg, "DfsFilePassThrough: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Copy the stack from one to the next...
    //

    NextIrpSp = IoGetNextIrpStackLocation(Irp);

    (*NextIrpSp) = (*IrpSp);

    IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

    //
    //  ...and call the next device
    //

    Status = IoCallDriver( pFcb->TargetDevice, Irp );

    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsFilePassThrough_Error_IoCallDriver,
                         LOGSTATUS(Status)
                         LOGPTR(Irp));
    DfsDbgTrace(-1, Dbg, "DfsFilePassThrough: Exit -> %08lx\n", ULongToPtr(Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements the file close routine for MUP.

Author:

    Manny Weiser (mannyw)    28-Dec-1991

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)


NTSTATUS
MupCloseVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MupCloseFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupClose )
#pragma alloc_text( PAGE, MupCloseFcb )
#pragma alloc_text( PAGE, MupCloseVcb )
#endif

NTSTATUS
MupClose (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the close IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID fsContext, fsContext2;
    PFILE_OBJECT FileObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupClose\n", 0);

    if (MupEnableDfs) {
        if ((MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) ||
                (MupDeviceObject->DeviceObject.DeviceType ==
                       FILE_DEVICE_DFS_FILE_SYSTEM)) {
            status = DfsFsdClose((PDEVICE_OBJECT) MupDeviceObject, Irp);
            return( status );
	}
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  Get the current stack location
        //

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        FileObject = irpSp->FileObject;
        MUP_TRACE_HIGH(TRACE_IRP, MupClose_Entry,
                       LOGPTR(MupDeviceObject)
                       LOGPTR(Irp)
                       LOGPTR(FileObject));

        DebugTrace(+1, Dbg, "MupClose...\n", 0);
        DebugTrace( 0, Dbg, " Irp            = %08lx\n", (ULONG)Irp);

        //
        // Decode the file object to figure out who we are.
        //

        (PVOID)MupDecodeFileObject( irpSp->FileObject,
                                   &fsContext,
                                   &fsContext2 );

        if ( fsContext == NULL ) {

            DebugTrace(0, Dbg, "The file is disconnected\n", 0);

            MupCompleteRequest( Irp, STATUS_INVALID_HANDLE );
            status = STATUS_INVALID_HANDLE;
            MUP_TRACE_HIGH(ERROR, MupClose_Error1, 
                           LOGSTATUS(status)
                           LOGPTR(MupDeviceObject)
                           LOGPTR(FileObject)
                           LOGPTR(Irp));

            DebugTrace(-1, Dbg, "MupClose -> %08lx\n", status );
            FsRtlExitFileSystem();
            return status;
        }

        //
        // Ignore the return code from MupDecode.  Parse the fsContext
        // to decide how to process the close IRP.
        //

        switch ( BlockType( fsContext ) ) {

        case BlockTypeVcb:

            status = MupCloseVcb( MupDeviceObject,
                                  Irp,
                                  (PVCB)fsContext,
                                  irpSp->FileObject
                                  );

            //
            // Complete the close IRP.
            //

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            break;


        case BlockTypeFcb:

            //
            // MupDecodeFileObject bumped the refcount on the fcb,
            // so we decrement that extra ref here.
            //

            MupDereferenceFcb((PFCB)fsContext);

            status = MupCloseFcb( MupDeviceObject,
                                  Irp,
                                  (PFCB)fsContext,
                                  irpSp->FileObject
                                  );

            //
            // Complete the close IRP.
            //

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            break;

    #ifdef MUPDBG
        default:
            //
            // This is not one of ours.
            //
            KeBugCheckEx( FILE_SYSTEM, 1, 0, 0, 0 );
            break;
    #else
        default:
            //
            // Complete the IRP with an error
            //
            MupCompleteRequest(Irp,STATUS_INVALID_HANDLE);
            status = STATUS_INVALID_HANDLE;
            MUP_TRACE_HIGH(ERROR, MupClose_Error2, 
                           LOGSTATUS(status)
                           LOGPTR(MupDeviceObject)
                           LOGPTR(FileObject)
                           LOGPTR(Irp));

            break;
    #endif
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();

    }

    FsRtlExitFileSystem();


    MUP_TRACE_HIGH(TRACE_IRP, MupClose_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(MupDeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    DebugTrace(-1, Dbg, "MupClose -> %08lx\n", status);
    return status;
}


NTSTATUS
MupCloseVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine closes the a file object that had opened the file system.

Arguments:

    MupDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the IRP associate with the close.

    Vcb - Supplies the VCB for the MUP.

    FileObject - Supplies the file object being closed.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    Irp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCloseVcb, Vcb = %08lx\n", (ULONG)Vcb);


    //
    // Acquire exclusive access to the VCB.
    //

    MupAcquireGlobalLock();

    try {

        //
        // Clear the referenced pointer to the VCB in the file object
        // and derefence the VCB.
        //

        ASSERT ( FileObject->FsContext == Vcb );

        MupSetFileObject( FileObject, NULL, NULL );
        MupDereferenceVcb( Vcb );

    } finally {

        MupReleaseGlobalLock( );
        DebugTrace(-1, Dbg, "MupCloseVcb -> STATUS_SUCCESS\n", 0);

    }

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MupCloseFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine closes the a file control block.

Arguments:

    MupDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the IRP associate with the close.

    Fcb - Supplies the FCB to close.

    FileObject - Supplies the file object being closed.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    MupDeviceObject; Irp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCloseFcb, Fcb = %08lx\n", (ULONG)Fcb);

    //
    // Acquire exclusive access to the VCB.
    //

    MupAcquireGlobalLock();

    try {

        //
        // Clear the referenced pointer to the VCB in the file object
        // and derefence the VCB.
        //

        ASSERT ( FileObject->FsContext == Fcb );

        MupSetFileObject( FileObject, NULL, NULL );
        MupDereferenceFcb( Fcb );

    } finally {

        MupReleaseGlobalLock( );
        DebugTrace(-1, Dbg, "MupCloseFcb -> STATUS_SUCCESS\n", 0);

    }

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\debug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements the debugging function for the MUP.

Author:

    Manny Weiser (mannyw)    27-Dec-1991

Revision History:

--*/

#include "mup.h"
#include "stdio.h"


#ifdef MUPDBG
#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _DebugTrace )
#endif

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    )

/*++

Routine Description:

    This routine display debugging information.

Arguments:

    Level - The debug level required to display this message.  If
        level is 0 the message is displayed regardless of the setting
        or the debug level

    Indent - Incremement or the current debug message indent

    X - 1st print parameter

    Y - 2nd print parameter

Return Value:

    None.

--*/

{
    LONG i;
    char printMask[100];

    PAGED_CODE();
    if ((Level == 0) || (MupDebugTraceLevel & Level)) {

        if (Indent < 0) {
            MupDebugTraceIndent += Indent;
        }

        if (MupDebugTraceIndent < 0) {
            MupDebugTraceIndent = 0;
        }

        sprintf( printMask, "%%08lx:%%.*s%s", X );

        i = (LONG)PsGetCurrentThread();
        DbgPrint( printMask, i, MupDebugTraceIndent, "", Y );
        if (Indent > 0) {
            MupDebugTraceIndent += Indent;
        }
    }
}
#endif // MUPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\creds.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       creds.c
//
//  Contents:   Code to handle user-defined credentials
//
//  Classes:    None
//
//  Functions:  DfsCreateCredentials --
//              DfsFreeCredentials --
//              DfsInsertCredentials --
//              DfsDeleteCredentials --
//              DfsLookupCredentials --
//
//  History:    March 18, 1996          Milans Created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"

#include <align.h>
#include <ntddnfs.h>

#include "dnr.h"
#include "rpselect.h"
#include "creds.h"

VOID
DfspFillEa(
    OUT PFILE_FULL_EA_INFORMATION EA,
    IN LPSTR EaName,
    IN PUNICODE_STRING EaValue);

NTSTATUS
DfspTreeConnectToService(
    IN PDFS_SERVICE Service,
    IN PDFS_CREDENTIALS Creds);

VOID
DfspDeleteAllAuthenticatedConnections(
    IN PDFS_CREDENTIALS Creds);

NTSTATUS
DfsCompleteDeleteTreeConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,DfsCreateCredentials)
#pragma alloc_text(PAGE,DfsVerifyCredentials)
#pragma alloc_text(PAGE,DfspFillEa)
#pragma alloc_text(PAGE,DfsFreeCredentials)
#pragma alloc_text(PAGE,DfsInsertCredentials)
#pragma alloc_text(PAGE,DfsDeleteCredentials)
#pragma alloc_text(PAGE,DfsLookupCredentials)
#pragma alloc_text(PAGE,DfsLookupCredentialsByServerShare)
#pragma alloc_text(PAGE,DfspTreeConnectToService)
#pragma alloc_text(PAGE,DfspDeleteAllAuthenticatedConnections)
#pragma alloc_text(PAGE,DfsDeleteTreeConnection)

#endif // ALLOC_PRAGMA

//+----------------------------------------------------------------------------
//
//  Function:   DfsCreateCredentials
//
//  Synopsis:   Creates a DFS_CREDENTIALS structure from a
//              FILE_DFS_DEF_ROOT_CREDENTIALS structure.
//
//  Arguments:  [CredDef] -- The input PFILE_DFS_DEF_ROOT_CREDENTIALS.
//              [CredDefSize] -- Size in bytes of *CredDef.
//              [Creds] -- On successful return, contains a pointer to the
//                      allocated PDFS_CREDENTIALS structure.
//
//  Returns:    [STATUS_SUCCESS] -- Allocated credentials
//
//              [STATUS_INVALID_PARAMETER] -- CredDef didn't pass mustard.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate pool.
//
//-----------------------------------------------------------------------------

#define DEF_NAME_TO_UNICODE_STRING(srcLength, dest, srcBuf, destBuf)    \
    if ((srcLength)) {                                                  \
        (dest)->Length = (dest)->MaximumLength = srcLength;             \
        (dest)->Buffer = (destBuf);                                     \
        RtlMoveMemory((dest)->Buffer, (srcBuf), (dest)->Length);        \
        srcBuf += ((dest)->Length / sizeof(WCHAR));                     \
        destBuf += ((dest)->Length / sizeof(WCHAR));                    \
    }

#ifdef TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds
    )

#else // TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds)

#endif // TERMSRV
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG totalSize;
    PDFS_CREDENTIALS creds;
    PWCHAR nameSrc, nameBuf;
    PFILE_FULL_EA_INFORMATION ea;
    ULONG eaLength;

    totalSize = CredDef->DomainNameLen +
                    CredDef->UserNameLen +
                        CredDef->PasswordLen +
                            CredDef->ServerNameLen +
                                CredDef->ShareNameLen;

    //
    // Validate the CredDef buffer
    //

    if ((totalSize + sizeof(FILE_DFS_DEF_ROOT_CREDENTIALS) - sizeof(WCHAR)) >
            CredDefSize)
        status = STATUS_INVALID_PARAMETER;
    else if (CredDef->ServerNameLen == 0)
        status = STATUS_INVALID_PARAMETER;
    else if (CredDef->ShareNameLen == 0)
        status = STATUS_INVALID_PARAMETER;

    //
    // Allocate the new DFS_CREDENTIALS structure
    //

    if (NT_SUCCESS(status)) {

        //
        // Add in the size of the DFS_CREDENTIALS_STRUCTURE itself.
        //

        totalSize += sizeof(DFS_CREDENTIALS);

        //
        // Add in the size of the EA_BUFFER that we will create. The
        // eaLength has room for 4 FILE_FULL_EA_INFORMATION structures,
        // the names and values of the four EAs we will use, and, since each
        // EA structure has to be long-word aligned, 4 ULONGs.
        //

        eaLength = 4 * sizeof(FILE_FULL_EA_INFORMATION) +
                        sizeof(EA_NAME_DOMAIN) +
                            sizeof(EA_NAME_USERNAME) +
                                sizeof(EA_NAME_PASSWORD) +
                                    sizeof(EA_NAME_CSCAGENT) +
                                        CredDef->DomainNameLen +
                                            CredDef->UserNameLen +
                                                CredDef->PasswordLen +
                                                    4 * sizeof(ULONG);

        if (CredDef->Flags & DFS_USE_NULL_PASSWORD) {
            eaLength += sizeof(UNICODE_NULL);
            totalSize += sizeof(UNICODE_NULL);
        }

        //
        // The buffers for DomainName, UserName etc. will start right after
        // the EaBuffer of DFS_CREDENTIALS. So, EaLength has to be WCHAR
        // aligned.
        //

        eaLength = ROUND_UP_COUNT(eaLength, ALIGN_WCHAR);

        //
        // Now, allocate the pool
        //

        creds = (PDFS_CREDENTIALS) ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        totalSize + eaLength,
                                        ' puM');

        if (creds == NULL)
            status = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Fill up the DFS_CREDENTIALS structure.
    //

    if (NT_SUCCESS(status)) {

        nameSrc = CredDef->Buffer;

        nameBuf =
            (PWCHAR) ((PUCHAR) creds + sizeof(DFS_CREDENTIALS) + eaLength);

        RtlZeroMemory( creds, sizeof(DFS_CREDENTIALS) );

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->DomainNameLen,
            &creds->DomainName,
            nameSrc,
            nameBuf);

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->UserNameLen,
            &creds->UserName,
            nameSrc,
            nameBuf);

        if (CredDef->Flags & DFS_USE_NULL_PASSWORD) {

            LPWSTR nullPassword = L"";

            DEF_NAME_TO_UNICODE_STRING(
                sizeof(UNICODE_NULL),
                &creds->Password,
                nullPassword,
                nameBuf);

        } else {

            DEF_NAME_TO_UNICODE_STRING(
                CredDef->PasswordLen,
                &creds->Password,
                nameSrc,
                nameBuf);

        }

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->ServerNameLen,
            &creds->ServerName,
            nameSrc,
            nameBuf);

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->ShareNameLen,
            &creds->ShareName,
            nameSrc,
            nameBuf);

        creds->RefCount = 0;

        creds->NetUseCount = 0;

        eaLength = 0;

        ea = (PFILE_FULL_EA_INFORMATION) &creds->EaBuffer[0];

        if (creds->DomainName.Length != 0) {

            DfspFillEa(ea, EA_NAME_DOMAIN, &creds->DomainName);

            eaLength += ea->NextEntryOffset;

        }

        if (creds->UserName.Length != 0) {

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_USERNAME, &creds->UserName);

            eaLength += ea->NextEntryOffset;

        }

        if (CredDef->Flags & DFS_USE_NULL_PASSWORD) {

            UNICODE_STRING nullPassword;

            RtlInitUnicodeString(&nullPassword, L"");

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_PASSWORD, &nullPassword);

            eaLength += ea->NextEntryOffset;

        } else if (creds->Password.Length != 0) {

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_PASSWORD, &creds->Password);

            eaLength += ea->NextEntryOffset;

        }

        if (CredDef->CSCAgentCreate == TRUE) {

            UNICODE_STRING EmptyUniString;

            RtlInitUnicodeString(&EmptyUniString, NULL);

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_CSCAGENT, &EmptyUniString);

            eaLength += ea->NextEntryOffset;

        }

        ea->NextEntryOffset = 0;

        creds->EaLength = eaLength;

#ifdef TERMSRV
        creds->SessionID = SessionID;
#endif // TERMSRV

	RtlCopyLuid(&creds->LogonID, LogonID);

        *Creds = creds;

    }

    //
    // Done...
    // 

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFillEa
//
//  Synopsis:   Helper routine to fill up an EA Buffer
//
//  Arguments:  [EA] -- Pointer to FILE_FULL_EA_INFORMATION to fill
//
//              [EaName] -- Name of Ea
//
//              [EaValue] -- Value (UNICODE_STRING) of Ea
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DfspFillEa(
    OUT PFILE_FULL_EA_INFORMATION EA,
    IN LPSTR EaName,
    IN PUNICODE_STRING EaValue)
{
    ULONG nameLen;

    nameLen = strlen(EaName) + sizeof(CHAR);

    EA->Flags = 0;

    EA->EaNameLength =
        (UCHAR) ROUND_UP_COUNT(nameLen, ALIGN_WCHAR) - sizeof(CHAR);

    EA->EaValueLength = EaValue->Length;

    //
    // Set the last character of EaName to 0 - the IO subsystem checks for
    // this
    //

    EA->EaName[ EA->EaNameLength ] = 0;

    RtlMoveMemory(&EA->EaName[0], EaName, nameLen);

    if (EaValue->Length > 0) {

        RtlMoveMemory(
            &EA->EaName[ EA->EaNameLength + 1 ],
            EaValue->Buffer,
            EA->EaValueLength);

    }

    EA->NextEntryOffset = ROUND_UP_COUNT(
			    FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                EA->EaNameLength +
                                EA->EaValueLength,
                            ALIGN_DWORD);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFreeCredentials
//
//  Synopsis:   Frees up the resources used by the DFS_CREDENTIALS structure.
//              Dual of DfsCreateCredentials
//
//  Arguments:  [Creds] -- The credentials structure to free
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFreeCredentials(
    PDFS_CREDENTIALS Creds)
{
    ExFreePool( Creds );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsInsertCredentials
//
//  Synopsis:   Inserts a new user credential into DfsData.Credentials queue.
//              Note that if this routine finds an existing credential
//              record, it will free up the passed in one, bump up the ref
//              count on the existing one, return a pointer to the
//              existing one, and return STATUS_OBJECT_NAME_COLLISION.
//
//  Arguments:  [Creds] -- Pointer to DFS_CREDENTIALS structure to insert.
//              [ForDevicelessConnection] -- If TRUE, the creds are being
//                      inserted because the caller wants to create a
//                      deviceless connection.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully inserted structure
//
//              [STATUS_NETWORK_CREDENTIAL_CONFLICT] -- There is already
//                      another set of credentials for the given server\share.
//
//              [STATUS_OBJECT_NAME_COLLISION] -- There is already another
//                      net use to the same server\share with the same
//                      credentials.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsInsertCredentials(
    IN OUT PDFS_CREDENTIALS *Creds,
    IN BOOLEAN ForDevicelessConnection)
{

    NTSTATUS status = STATUS_SUCCESS;
    PDFS_CREDENTIALS creds, existingCreds;

    creds = *Creds;

    ASSERT(creds->ServerName.Length != 0);
    ASSERT(creds->ShareName.Length != 0);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

#ifdef TERMSRV

    existingCreds =
        DfsLookupCredentialsByServerShare(
            &creds->ServerName,
            &creds->ShareName,
            creds->SessionID,
            &creds->LogonID );

#else // TERMSRV

    existingCreds = DfsLookupCredentialsByServerShare(
                        &creds->ServerName,
                        &creds->ShareName,
                        &creds->LogonID );

#endif // TERMSRV

    if (existingCreds != NULL) {
        
        if (
            (creds->DomainName.Length > 0 && !RtlEqualUnicodeString(
                                                    &existingCreds->DomainName,
                                                    &creds->DomainName,
                                                    TRUE))
                    ||
            (creds->UserName.Length > 0 && !RtlEqualUnicodeString(
                                                    &existingCreds->UserName,
                                                    &creds->UserName,
                                                    TRUE))
                    ||
	    //
	    // For compatibility reasons, check for password inconsistency ONLY
	    // if we have a previously setup credentials and the previous 
	    // credentials had explicit password and the current request
	    // has explicitly specified password.
	    // rdr2\rdbss\rxconnct.c also has a similar check for the rdr.
	    //

            (existingCreds->Password.Length > 0 && creds->Password.Length > 0 && !RtlEqualUnicodeString(
                                                    &existingCreds->Password,
                                                    &creds->Password,
                                                    TRUE))
        ) {

            status = STATUS_NETWORK_CREDENTIAL_CONFLICT;

        } else {
	    //
	    // Do this for both deviceless and has device cases.
	    // With deep net uses of deviceless, multiple DevlessRoots
	    // may point to the same credentials.
	    //
	    existingCreds->NetUseCount++;
	    existingCreds->RefCount++;

            DfsFreeCredentials( *Creds );

            *Creds = existingCreds;

            status = STATUS_OBJECT_NAME_COLLISION;
        }

    } else {

        ASSERT(creds->RefCount == 0);

        ASSERT(creds->NetUseCount == 0);

        creds->RefCount = 1;

        creds->NetUseCount = 1;

        InsertTailList( &DfsData.Credentials, &creds->Link );

        status = STATUS_SUCCESS;

    }

    if (status != STATUS_NETWORK_CREDENTIAL_CONFLICT) {

        if (ForDevicelessConnection)
            (*Creds)->Flags |= CRED_IS_DEVICELESS;
        else
            (*Creds)->Flags |= CRED_HAS_DEVICE;

    }

    ExReleaseResourceLite( &DfsData.Resource );

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteCredentials
//
//  Synopsis:   Deletes a user credential record. This is the dual of
//              DfsInsertCredentials, NOT DfsCreateCredentials.
//
//  Arguments:  [Creds] -- Pointer to DFS_CREDENTIALS record to delete.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsDeleteCredentials(
    IN PDFS_CREDENTIALS Creds)
{
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    Creds->NetUseCount--;

    Creds->RefCount--;

    if (Creds->NetUseCount == 0) {

        DfspDeleteAllAuthenticatedConnections( Creds );

        RemoveEntryList( &Creds->Link );

        InsertTailList( &DfsData.DeletedCredentials, &Creds->Link );

    }

    ExReleaseResourceLite( &DfsData.Resource );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsLookupCredentials
//
//  Synopsis:   Looks up a credential, if any, associated with a file name.
//
//  Arguments:  [FileName] -- Name of file. Assumed to have atleast a
//                      \server\share part.
//
//  Returns:    Pointer to DFS_CREDENTIALS to use, NULL if not found.
//
//-----------------------------------------------------------------------------


#ifdef TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName,
    IN PLUID LogonID
    )

#endif // TERMSRV
{
    UNICODE_STRING server, share;
    USHORT i;

    //
    // FileName has to be atleast \a\b
    //

    if (FileName->Length < 4 * sizeof(WCHAR))
        return( NULL );

    if (FileName->Buffer[0] != UNICODE_PATH_SEP)
        return( NULL );

    server.Buffer = &FileName->Buffer[1];

    for (i = 1, server.Length = 0;
            i < FileName->Length/sizeof(WCHAR) &&
                FileName->Buffer[i] != UNICODE_PATH_SEP;
                    i++, server.Length += sizeof(WCHAR)) {
         NOTHING;
    }

    server.MaximumLength = server.Length;

    i++;                                         // Go past the backslash

    share.Buffer = &FileName->Buffer[i];

    for (share.Length = 0;
            i < FileName->Length/sizeof(WCHAR) &&
                    FileName->Buffer[i] != UNICODE_PATH_SEP;
                        i++, share.Length += sizeof(WCHAR)) {
          NOTHING;
    }

    share.MaximumLength = share.Length;

    if ((server.Length == 0) || (share.Length == 0))
        return( NULL );


#ifdef TERMSRV

    return DfsLookupCredentialsByServerShare( &server, &share, SessionID, LogonID );

#else // TERMSRV

    return DfsLookupCredentialsByServerShare( &server, &share, LogonID );

#endif // TERMSRV

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsLookupCredentialsByServerShare
//
//  Synopsis:   Searches DfsData.Credentials for credentials given a server
//              and share name.
//
//  Arguments:  [ServerName] -- Name of server to match.
//              [ShareName] -- Name of share to match.
//
//  Returns:    Pointer to DFS_CREDENTIALS, NULL if not found.
//
//-----------------------------------------------------------------------------

#ifdef TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PLUID LogonID
    )

#endif // TERMSRV
{
    PLIST_ENTRY link;
    PDFS_CREDENTIALS matchedCreds = NULL;

    for (link = DfsData.Credentials.Flink;
            link != &DfsData.Credentials && matchedCreds == NULL;
                link = link->Flink) {

         PDFS_CREDENTIALS creds;

         creds = CONTAINING_RECORD(link, DFS_CREDENTIALS, Link);

         if (RtlEqualUnicodeString(ServerName, &creds->ServerName, TRUE) &&
                RtlEqualUnicodeString(ShareName, &creds->ShareName, TRUE)) {
#ifdef TERMSRV

             if( (creds->SessionID == SessionID) &&
	                RtlEqualLuid(&creds->LogonID, LogonID) ) {
                matchedCreds = creds;
             }

#else // TERMSRV
             if( RtlEqualLuid(&creds->LogonID, LogonID) ) {
	     
	         matchedCreds = creds;
             }

#endif // TERMSRV
         }


    }

    return( matchedCreds );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsVerifyCredentials
//
//  Synopsis:   Returns the result of trying to connect to a Dfs share using
//              the supplied credentials
//
//  Arguments:  [Prefix] -- The Dfs Prefix to connect to.
//              [Creds] -- The DFS_CREDENTIALS record to use for connecting.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully connected.
//
//              [STATUS_BAD_NETWORK_PATH] -- Unable to find Prefix
//                      in Pkt or a server for prefix could not be found.
//
//              NT Status of Tree Connect attempt
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsVerifyCredentials(
    IN PUNICODE_STRING Prefix,
    IN PDFS_CREDENTIALS Creds)
{
    NTSTATUS status;
    UNICODE_STRING remPath, shareName;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_SERVICE service;
    ULONG i, USN;
    BOOLEAN pktLocked, fRetry;
    UNICODE_STRING UsePrefix;

    DfsGetServerShare( &UsePrefix,
                       Prefix );

    pkt = _GetPkt();


    //
    // We acquire Pkt exclusive because we might tear down the IPC$ connection
    // to a server while trying to establish a connection with supplied
    // credentials.
    //

    PktAcquireExclusive( TRUE, &pktLocked );

    do {

        fRetry = FALSE;

        pktEntry = PktLookupEntryByPrefix( pkt, &UsePrefix, &remPath );


        if (pktEntry != NULL) {

            InterlockedIncrement(&pktEntry->UseCount);

            USN = pktEntry->USN;

            status = STATUS_BAD_NETWORK_PATH;

            for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

                service = &pktEntry->Info.ServiceList[i];

                status = DfspTreeConnectToService(service, Creds);

                //
                // If tree connect succeeded, we are done.
                //

                if (NT_SUCCESS(status))
                    break;

                //
                // If tree connect failed with an "interesting error" like
                // STATUS_ACCESS_DENIED, we are done.
                //

                if (!ReplIsRecoverableError(status))
                    break;

                //
                // Tree connect failed because of an error like host not
                // reachable. In that case, we want to go on to the next
                // server in the list. But before we do that, we have to see
                // if the pkt changed on us while we were off doing the tree
                // connect.
                //

                if (USN != pktEntry->USN) {

                    fRetry = TRUE;

                    break;

                }

            }

            InterlockedDecrement(&pktEntry->UseCount);

        } else {

            status = STATUS_BAD_NETWORK_PATH;

        }

    } while ( fRetry );

    PktRelease();

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspTreeConnectToService
//
//  Synopsis:   Helper routine to tree connect to a DFS_SERVICE with supplied
//              credentials.
//
//  Arguments:  [Service] -- The service to connect to
//              [Creds] -- The credentials to use to tree connect
//
//  Returns:    NT Status of tree connect
//
//  Notes:      This routine assumes that the Pkt has been acquired before
//              being called. This routine will release and reacquire the Pkt
//              so the caller should be prepared for the event that the Pkt
//              has changed after a call to this routine.
//
//-----------------------------------------------------------------------------


NTSTATUS
DfspTreeConnectToService(
    IN PDFS_SERVICE Service,
    IN PDFS_CREDENTIALS Creds)
{
    NTSTATUS status;
    UNICODE_STRING shareName;
    HANDLE treeHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN pktLocked;
    USHORT i, k;

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );

    //
    // Compute the share name...
    //

    if (Service->pProvider != NULL &&
            Service->pProvider->DeviceName.Buffer != NULL &&
                Service->pProvider->DeviceName.Length > 0) {

        //
        // We have a provider already - use it
        //

        shareName.MaximumLength =
            Service->pProvider->DeviceName.Length +
                Service->Address.Length;

    } else {

        //
        // We don't have a provider yet - give it to the mup to find one
        //

        shareName.MaximumLength =
            sizeof(DD_NFS_DEVICE_NAME_U) +
                Service->Address.Length;

    }

    shareName.Buffer = ExAllocatePoolWithTag(PagedPool, shareName.MaximumLength, ' puM');

    if (shareName.Buffer != NULL) {

        //
        // If we have a cached connection to the IPC$ share of this server,
        // close it or it might conflict with the credentials supplied here.
        //

        if (Service->ConnFile != NULL) {

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

            if (Service->ConnFile != NULL)
                DfsCloseConnection(Service);

            ExReleaseResourceLite(&DfsData.Resource);

        }

        //
        // Now, build the share name to tree connect to.
        //

        shareName.Length = 0;

        if (Service->pProvider != NULL &&
                Service->pProvider->DeviceName.Buffer != NULL &&
                    Service->pProvider->DeviceName.Length > 0) {

            //
            // We have a provider already - use it
            //
 
            RtlAppendUnicodeToString(
                &shareName,
                Service->pProvider->DeviceName.Buffer);

        } else {

            //
            // We don't have a provider yet - give it to the mup to find one
            //

            RtlAppendUnicodeToString(
            &shareName,
            DD_NFS_DEVICE_NAME_U);

        }
 
        RtlAppendUnicodeStringToString(&shareName, &Service->Address);

        //
        // One can only do tree connects to server\share. So, in case
        // pService->Address refers to something deeper than the share,
        // make sure we setup a tree-conn only to server\share. Note that
        // by now, shareName is of the form
        // \Device\LanmanRedirector\server\share<\path>. So, count up to
        // 4 slashes and terminate the share name there.
        //

        for (i = 0, k = 0;
                i < shareName.Length/sizeof(WCHAR) && k < 5;
                    i++) {

            if (shareName.Buffer[i] == UNICODE_PATH_SEP)
                k++;
        }

        shareName.Length = i * sizeof(WCHAR);
        if (k == 5)
            shareName.Length -= sizeof(WCHAR);

        InitializeObjectAttributes(
            &objectAttributes,
            &shareName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

        //
        // Release the Pkt before going over the net...
        //

        PktRelease();

        status = ZwCreateFile(
                    &treeHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ |
                        FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                    (PVOID) Creds->EaBuffer,
                    Creds->EaLength);

        if (NT_SUCCESS(status)) {

            PFILE_OBJECT fileObject;

            //
            // 426184, need to check return code for errors.
            //
            status = ObReferenceObjectByHandle(
                          treeHandle,
                          0,
                          NULL,
                          KernelMode,
                          &fileObject,
                          NULL);

            ZwClose( treeHandle );

            if (NT_SUCCESS(status)) {
                DfsDeleteTreeConnection( fileObject, USE_FORCE );
            }
	}


        ExFreePool( shareName.Buffer );

        PktAcquireShared( TRUE, &pktLocked );

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspDeleteAllAuthenticatedConnections
//
//  Synopsis:   Deletes all authenticated connections made using a particular
//              set of credentials that we might have cached. Useful to
//              implement net use /d
//
//  Arguments:  [Creds] -- The Credentials to match against authenticated
//                      connection
//
//  Returns:    Nothing
//
//  Notes:      Pkt and DfsData must have been acquired before calling!
//
//-----------------------------------------------------------------------------

VOID
DfspDeleteAllAuthenticatedConnections(
    IN PDFS_CREDENTIALS Creds)
{
    PDFS_PKT_ENTRY pktEntry;
    ULONG i;
    PDFS_MACHINE_ENTRY machine;

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() ||
                PKT_LOCKED_FOR_EXCLUSIVE_ACCESS() );

    ASSERT( ExIsResourceAcquiredExclusiveLite( &DfsData.Resource ) );

    for (pktEntry = PktFirstEntry(&DfsData.Pkt);
            pktEntry != NULL;
                pktEntry = PktNextEntry(&DfsData.Pkt, pktEntry)) {

        for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

            //
            // Tear down connection to IPC$ if we have one...
            //

            if (pktEntry->Info.ServiceList[i].ConnFile != NULL)
                DfsCloseConnection( &pktEntry->Info.ServiceList[i] );


            machine = pktEntry->Info.ServiceList[i].pMachEntry;

            if (machine->Credentials == Creds) {

                DfsDeleteTreeConnection(machine->AuthConn, USE_LOTS_OF_FORCE);

                machine->AuthConn = NULL;

                machine->Credentials->RefCount--;

                machine->Credentials = NULL;

            }

        }

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteTreeConnection, public
//
//  Synopsis:   Tears down tree connections given the file object representing
//              the tree connection.
//
//  Arguments:  [TreeConnFileObj] -- The tree connection to tear down.
//              [ForceFilesClosed] -- If TRUE, the tree connection will be
//                      torn down even if files are open on the server
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsDeleteTreeConnection(
    IN PFILE_OBJECT TreeConnFileObj,
    IN ULONG  Level)
{
    PIRP irp;
    KEVENT event;
    static LMR_REQUEST_PACKET req;

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    req.Version = REQUEST_PACKET_VERSION;

    req.Level = Level;

    irp = DnrBuildFsControlRequest(
                TreeConnFileObj,
                &event,
                FSCTL_LMR_DELETE_CONNECTION,
                &req,
                sizeof(req),
                NULL,
                0,
                DfsCompleteDeleteTreeConnection);

    if (irp != NULL) {

        IoCallDriver(
            IoGetRelatedDeviceObject( TreeConnFileObj ),
            irp);

        KeWaitForSingleObject(
            &event,
            UserRequest,
            KernelMode,
            FALSE,           // Alertable
            NULL);           // Timeout

        IoFreeIrp( irp );

        ObDereferenceObject(TreeConnFileObj);

    }

}

NTSTATUS
DfsCompleteDeleteTreeConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx)
{

    KeSetEvent( (PKEVENT) Ctx, EVENT_INCREMENT, FALSE );

    return( STATUS_MORE_PROCESSING_REQUIRED );
}



VOID
DfsGetServerShare(
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc)
{
    ULONG i;

    *pDest = *pSrc;


    for (i = 0; ((i < pDest->Length/sizeof(WCHAR)) && (pDest->Buffer[i] == UNICODE_PATH_SEP)); i++)
    {
        NOTHING;
    }
    for (; ((i < pDest->Length/sizeof(WCHAR)) && (pDest->Buffer[i] != UNICODE_PATH_SEP)); i++)
    {
        NOTHING;
    }
    for (i = i + 1; ((i < pDest->Length/sizeof(WCHAR)) && (pDest->Buffer[i] != UNICODE_PATH_SEP)); i++)
    {
        NOTHING;
    }

    if (i <= pDest->Length/sizeof(WCHAR))
    {
        pDest->Length = (USHORT)i * sizeof(WCHAR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\debug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module defines debug functions and manifests.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

#ifndef _MUPDEBUG_
#define _MUPDEBUG_

//
// MUP debug level
//

#ifdef MUPDBG

#define DEBUG_TRACE_FILOBSUP                0x00000001
#define DEBUG_TRACE_CREATE                  0x00000002
#define DEBUG_TRACE_FSCONTROL               0x00000004
#define DEBUG_TRACE_REFCOUNT                0x00000008
#define DEBUG_TRACE_CLOSE                   0x00000010
#define DEBUG_TRACE_CLEANUP                 0x00000020
#define DEBUG_TRACE_FORWARD                 0x00000040
#define DEBUG_TRACE_BLOCK                   0x00000080

extern LONG MsDebugTraceLevel;
extern LONG MsDebugTraceIndent;

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    );

#define DebugDump(STR,LEVEL,PTR) {                          \
    ULONG _i;                                               \
    VOID MupDump();                                         \
    if (((LEVEL) == 0) || (MupDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        DbgPrint(STR);                                      \
        if (PTR != NULL) {MupDump(PTR);}                    \
        DbgBreakPoint();                                    \
    }                                                       \
}

#define DebugTrace(i,l,x,y)              _DebugTrace(i,l,x,(ULONG)y)

//
//  The following routine and macro is used to catch exceptions in
//  try except statements.  It allows us to catch the exception before
//  executing the exception handler.  The exception catcher procedure is
//  declared in msdata.c
//

LONG MupExceptionCatcher (IN PSZ String);

#define Exception(STR)                   (MupExceptionCatcher(STR))

#else  // MUPDBG

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#define Exception(STR)                   (EXCEPTION_EXECUTE_HANDLER)

#define DebugTrace(I,L,X,Y)              {NOTHING;}

#endif // MUPDBG

#endif // _MUPDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\creds.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       creds.h
//
//  Contents:   Code to handle user-defined credentials
//
//  Classes:    None
//
//  Functions:  DfsCreateCredentials --
//              DfsInsertCredentials --
//              DfsDeleteCredentials --
//              DfsLookupCredentials --
//              DfsFreeCredentials --
//
//  History:    March 18, 1996          Milans Created
//
//-----------------------------------------------------------------------------

#ifndef _DFS_CREDENTIALS_
#define _DFS_CREDENTIALS_


#ifdef TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds
    );

#else // TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds);

#endif // TERMSRV

VOID
DfsFreeCredentials(
    PDFS_CREDENTIALS Creds);

NTSTATUS
DfsInsertCredentials(
    IN OUT PDFS_CREDENTIALS *Creds,
    IN BOOLEAN ForDevicelessConnection);

VOID
DfsDeleteCredentials(
    IN PDFS_CREDENTIALS Creds);


#ifdef TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName,
    IN ULONG SessionID,
    IN PLUID LogonID		   
    );

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

#else // TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName);

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PLUID LogonID
    );

#endif // TERMSRV

NTSTATUS
DfsVerifyCredentials(
    IN PUNICODE_STRING Prefix,
    IN PDFS_CREDENTIALS Creds);

VOID
DfsDeleteTreeConnection(
    IN PFILE_OBJECT TreeConnFileObj,
    IN ULONG  Level);


PDFS_CREDENTIALS
DfsCaptureCredentials(
    IN PIRP Irp,
    IN PUNICODE_STRING FileName);


VOID
DfsGetServerShare(
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc);

#endif // _DFS_CREDENTIALS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsdata.c ===
//+----------------------------------------------------------------------------
//
//  File:       dfsdata.c
//
//  Contents:
//      This module declares the global data used by the Dfs file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"

//
//  The debug trace level
//

#define Dbg             (DEBUG_TRACE_CATCH_EXCEPTIONS)


//  DfsBugCheck
//  DfsExceptionFilter
//  DfsProcessException

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsBugCheck )
#pragma alloc_text ( PAGE, DfsExceptionFilter )
#pragma alloc_text ( PAGE, DfsProcessException )

//
//  The following rountine cannot be paged because it raises the IRQL to
//  complete IRPs.
//
//
//  DfsCompleteRequest_Real
//

#endif // ALLOC_PRAGMA

//
//  The global FSD data record
//

DFS_DATA DfsData;

//
// The global event logging level
//

ULONG DfsEventLog = 0;

//
// The global Dfs debug level
//

ULONG MupVerbose = 0;


DFS_TIMER_CONTEXT       DfsTimerContext;

//
//  Some often used strings
//

WCHAR   LogicalRootDevPath[ MAX_LOGICAL_ROOT_LEN ] = { DD_DFS_DEVICE_DIRECTORY };

#if DBG

//+---------------------------------------------------------------------------
// Function:    DfsDebugTracePrint, public
//
// Synopsis:    Produce a DFS debug trace printout
//
// Arguments:   [x] -- DbgPrint format string
//              [y] -- optional argument to DbgPrint
//
// Returns:     None
//
//----------------------------------------------------------------------------

LONG DfsDebugTraceLevel = 0x00000001;
LONG DfsDebugTraceIndent = 0;

VOID
DfsDebugTracePrint(PCHAR x, PVOID y)
{
        int i;

        DbgPrint("%p:",PsGetCurrentThread());
        if (DfsDebugTraceIndent < 0)
            DfsDebugTraceIndent = 0;
        for (i = 0; i+5 < DfsDebugTraceIndent; i += 5) {
            DbgPrint("      ");
        }
        for ( ; i < DfsDebugTraceIndent; i += 1) {
            DbgPrint(" ");
        }
        DbgPrint(x,y);
}

#endif // DBG



//+---------------------------------------------------------------------------
// Function:    DfsBugCheck, public
//
// Synopsis:    Call KeBugCheck with DFS' constant
//
// Arguments:   [pszmsg]  -- message            (DBG=1 only)
//              [pszfile] -- filename           (DBG=1 only)
//              [line]    -- line number        (DBG=1 only)
//
// Returns:     None
//
//----------------------------------------------------------------------------

#if DBG
VOID DfsBugCheck(CHAR *pszmsg, CHAR *pszfile, ULONG line)
{
    PVOID CallersAddress, CallersCaller;

    RtlGetCallersAddress(&CallersAddress, &CallersCaller);

    DbgPrint("\nDFS: BugCheck in %s, line %u (%s)\n", pszfile, line, pszmsg);
    KeBugCheckEx(DFS_FILE_SYSTEM, (ULONG_PTR)CallersAddress, (ULONG_PTR)pszmsg,
                                  (ULONG_PTR)pszfile, line);
}
#else   // DBG
VOID DfsBugCheck(VOID)
{
    PVOID CallersAddress, CallersCaller;

    RtlGetCallersAddress(&CallersAddress, &CallersCaller);
    KeBugCheckEx(DFS_FILE_SYSTEM, (ULONG_PTR)CallersAddress, (ULONG_PTR)CallersCaller,
                                0, 0);
}
#endif  // DBG

//+----------------------------------------------------------------------------
//
//  Function:   FillDebugException
//
//  Synopsis:   Captures the exception record into variables that we can
//              look at.
//
//  Arguments:  [pep] -- Pointer to exception record.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define CEXCEPTION_STACK        8

PEXCEPTION_RECORD   DfsExceptionRecord;
PCONTEXT            DfsExceptionContext;
ULONG               DfsExceptionStack[CEXCEPTION_STACK];

VOID
FillDebugException(
    PEXCEPTION_POINTERS pep)
{
    if(pep != NULL) {

        DfsExceptionRecord = pep->ExceptionRecord;

        DfsExceptionContext = pep->ContextRecord;

    }

}


//+-------------------------------------------------------------------
//
//  Function:   DfsExceptionFilter
//
//  Synopsis:   Decide if we should or should not handle an exception status
//              that is being raised.  Insert the status into the IrpContext
//              and either indicate that we should handle the exception or
//              BugCheck the system.
//
//  Arguments:  [IrpContext] -- IRP context for the request being processed.
//              [ExceptionCode] -- Supplies the exception code to being checked.
//
//  Returns:    ULONG - returns EXCEPTION_EXECUTE_HANDLER or BugChecks
//
//--------------------------------------------------------------------

LONG
DfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN NTSTATUS ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionPointers OPTIONAL
) {
    DfsDbgTrace(
        0, DEBUG_TRACE_UNWIND, "DfsExceptionFilter %lx\n", ULongToPtr(ExceptionCode) );

    FillDebugException( ExceptionPointers );

    ASSERT(ExceptionCode != STATUS_ACCESS_VIOLATION);

    ASSERTMSG(
        "DfsExceptionFilter entered\n",
        !(DfsDebugTraceLevel & DEBUG_TRACE_UNWIND));

    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        ASSERT( ExceptionCode == STATUS_INSUFFICIENT_RESOURCES );
        return EXCEPTION_EXECUTE_HANDLER;
    }

    IrpContext->Flags |= IRP_CONTEXT_FLAG_WAIT;

    if (IrpContext->ExceptionStatus == 0) {

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {
            IrpContext->ExceptionStatus = ExceptionCode;

        } else {
            BugCheck( "DfsExceptionFilter: Unexpected exception" );

        }
    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsProcessException, public
//
//  Synopsis:   This routine processes an exception.  It either completes
//              the request with the saved exception status or it sends
//              the request off to the Fsp.
//
//  Arguments:  [Irp] -- Supplies the IRP being processed
//              [ExceptionCode] -- normalized exception status being handled
//
//  Returns:    NTSTATUS - Returns the results of either posting the Irp or the
//              saved completion status.
//
//--------------------------------------------------------------------

NTSTATUS
DfsProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )
{
    NTSTATUS Status;

    DfsDbgTrace(0, Dbg, "DfsProcessException\n", 0);

    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        ASSERT( ExceptionCode == STATUS_INSUFFICIENT_RESOURCES );

        DfsCompleteRequest( IrpContext, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Check if the status is verify required and if so then we
    //  either send the request off to the fsp or we complete
    //  the request with verify required.
    //

    if (ExceptionCode == STATUS_CANT_WAIT) {

        Status = DfsFsdPostRequest( IrpContext, Irp );

    } else {

        //
        //  We got an error, so zero out the information field before
        //  completing the request if this was an input operation.
        //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
        //

        if ((Irp->Flags & IRP_INPUT_OPERATION) != 0) {

            Irp->IoStatus.Information = 0;
        }

        Status = IrpContext->ExceptionStatus;

        DfsCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCompleteRequest, public
//
//  Synopsis:   This routine completes a Irp
//
//  Arguments:  [IrpContext] - context record to be freed
//              [Irp] - Supplies the Irp being processed
//              [Status] - Supplies the status to complete the Irp with
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID
DfsCompleteRequest_Real (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
) {
    KIRQL PreviousIrql;

    //
    //  If we have an Irp then complete the irp.
    //

    if (Irp != NULL) {

        Irp->IoStatus.Status = Status;
        // KeRaiseIrql( DISPATCH_LEVEL, &PreviousIrql );
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
        // KeLowerIrql( PreviousIrql );
    }

    //
    //  Delete the Irp context.
    //

    if (IrpContext != NULL) {

        DfsDeleteIrpContext( IrpContext );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfserr.h ===
//-------------------------------------------------------------------------
//
// File:        dfserr.h
//
// Contents:    This file has all the DFS driver error codes defined.
//              This includes only NTSTATUS codes returned from the
//              DFS driver.  For user-level HRESULTs, see oleerror.mc.
//
// History:     04-Feb-93       SudK    Created.
//              23 Sep 93       Alanw   Cleaned up, changed naming
//                                      convention to be DFS_STATUS_xxx
//
//  NOTES:      These error codes probably need to be differentiated from
//              the generic mappings used. Keep in mind for next generation DFS
//
//-------------------------------------------------------------------------

#ifndef _DFSERR_H_
#define _DFSERR_H_

//
//  The following are errror status codes which can be returned by the
//  DFS driver.
//

#define DFS_STATUS_NOSUCH_LOCAL_VOLUME          STATUS_OBJECT_NAME_NOT_FOUND
#define DFS_STATUS_BAD_EXIT_POINT               STATUS_OBJECT_NAME_INVALID
#define DFS_STATUS_STORAGEID_ALREADY_INUSE      STATUS_OBJECT_NAME_COLLISION
#define DFS_STATUS_BAD_STORAGEID                STATUS_OBJECT_PATH_INVALID

//
//  Defines for PKT specific errors
//

#define DFS_STATUS_ENTRY_EXISTS             STATUS_OBJECT_NAME_COLLISION
#define DFS_STATUS_NO_SUCH_ENTRY            STATUS_OBJECT_NAME_NOT_FOUND
#define DFS_STATUS_NO_DOMAIN_SERVICE        STATUS_CANT_ACCESS_DOMAIN_INFO
#define DFS_STATUS_LOCAL_ENTRY              STATUS_CANNOT_DELETE
#define DFS_STATUS_INCONSISTENT             STATUS_INTERNAL_DB_CORRUPTION
#define DFS_STATUS_RESYNC_INFO              STATUS_MEDIA_CHECK

#endif  // _DFSERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsfilob.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FILOBSUP.C
//
//  Contents:   This module implements the Dfs File object support routines.
//
//  Functions:  DfsSetFileObject - associate internal data structs to file obj
//              DfsDecodeFileObject - get internal structures from file obj
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//              02 Mar 1993     AlanW   Added association of DFS_FCBs with
//                                      file objects (without actually
//                                      modifying fscontext fields).
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "fcbsup.h"

//
//  The debug trace level
//

#define Dbg                             (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsSetFileObject )
#pragma alloc_text ( PAGE, DfsDecodeFileObject )
#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsSetFileObject, public
//
//  Synopsis:   This routine sets the file system pointers within the
//              file object
//
//  Arguments:  [FileObject] -- the file object being modified.
//              [TypeOfOpen] -- Supplies the type of open denoted by
//                      the file object.  This is only used by this
//                      procedure for sanity checking.
//              [VcbOrFcb] -- Supplies a pointer to either a DFS_VCB or DFS_FCB.
//
//  Returns:    None.
//
//--------------------------------------------------------------------


VOID
DfsSetFileObject (
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcb
) {
    DfsDbgTrace(+1, Dbg, "DfsSetFileObject, FileObject = %08lx\n", FileObject);

    ASSERT( TypeOfOpen == RedirectedFileOpen
            && NodeType( VcbOrFcb ) == DSFS_NTC_FCB
            && ((PDFS_FCB) VcbOrFcb)->FileObject == FileObject

                ||

            (TypeOfOpen == UserVolumeOpen
             || TypeOfOpen == LogicalRootDeviceOpen)
            && NodeType( VcbOrFcb ) == DSFS_NTC_VCB

                ||

            TypeOfOpen == FilesystemDeviceOpen
            && NodeType( VcbOrFcb ) == IO_TYPE_DEVICE

                ||

            TypeOfOpen == UnopenedFileObject );



    //
    //  Now set the fscontext fields of the file object
    //

    if ( ARGUMENT_PRESENT( FileObject )) {
        ASSERT( DfsLookupFcb(FileObject) == NULL );

        if (TypeOfOpen == RedirectedFileOpen) {
            DfsAttachFcb(FileObject, (PDFS_FCB) VcbOrFcb);
        } else {
            FileObject->FsContext  = VcbOrFcb;
            FileObject->FsContext2 = NULL;
        }
    }

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsSetFileObject -> VOID\n", 0);
    return;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsDecodeFileObject, public
//
//  Synopsis:   This procedure takes a pointer to a file object, that
//              has already been opened by the Dsfs file system and
//              figures out what really is opened.
//
//  Arguments:  [FileObject] -- Supplies the file object pointer being
//                      interrogated
//              [ppVcb] -- Receives a pointer to the Vcb for the file object.
//              [ppFcb] -- Receives a pointer to the Fcb for the
//                      file object, if one exists.
//
//  Returns:    [TYPE_OF_OPEN] - returns the type of file denoted by the
//                      input file object.
//
//              FilesystemDeviceOpen -
//
//              LogicalRootDeviceOpen -
//
//              RedirectedFileOpen - The FO represents a user's opened file or
//                      directory which must be passed through to some other
//                      FSD.  Fcb, Vcb are set.  Fcb points to an Fcb.
//
//--------------------------------------------------------------------

TYPE_OF_OPEN
DfsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PDFS_VCB *ppVcb,
    OUT PDFS_FCB *ppFcb
) {
    TYPE_OF_OPEN TypeOfOpen;
    PVOID FsContext = FileObject->FsContext;
    PDFS_FCB pFcb;

    DfsDbgTrace(+1, Dbg, "DfsDecodeFileObject, FileObject = %08lx\n",
                                FileObject);

    //
    //  Zero out the out pointer parameters.
    //

    *ppFcb = NULL;
    *ppVcb = NULL;

    //
    //  Attempt to look up the associated DFS_FCB in the lookaside table.
    //  If it's there, the open type must be RedirectedFileOpen.
    //

    pFcb = DfsLookupFcb(FileObject);
    if (pFcb != NULL) {
        *ppFcb = pFcb;
        *ppVcb = pFcb->Vcb;

        ASSERT(pFcb->TargetDevice != NULL);
        TypeOfOpen = RedirectedFileOpen;

        DfsDbgTrace(0, Dbg, "DfsDecodeFileObject, Fcb = %08x\n", pFcb);
        DfsDbgTrace(-1, Dbg, "DfsDecodeFileObject -> %x\n", TypeOfOpen);
        return TypeOfOpen;
    }

    //
    //  Special case the situation where FsContext is null
    //

    if ( FsContext == NULL ) {

        TypeOfOpen = UnopenedFileObject;

    } else {

        //
        //  Now we can case on the node type code of the fscontext pointer
        //  and set the appropriate out pointers
        //

        switch ( NodeType( FsContext )) {

        case IO_TYPE_DEVICE:

            TypeOfOpen = FilesystemDeviceOpen;
            break;

        case DSFS_NTC_VCB:
            *ppVcb = (PDFS_VCB) FsContext;

            TypeOfOpen = LogicalRootDeviceOpen;
            break;

        default:
            TypeOfOpen = UnknownOpen;
        }
    }

    //
    //  and return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsDecodeFileObject -> %x\n", TypeOfOpen);

    return TypeOfOpen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsgluon.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsGluon.h
//
//  Contents:   Declarations for dfs use of gluons
//
//  Classes:
//
//  Functions:
//
//  History:    March 24, 1994		Milans Created
//
//-----------------------------------------------------------------------------


#ifndef _DFS_GLUON_
#define _DFS_GLUON_

#include <gluon.h>

//
// Marshalling info for TAddress
//

extern MARSHAL_INFO MiTAddress;

#define INIT_TADDRESS_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_TAddress[] = {			\
    	_MCode_conformant(TA_ADDRESS, Address, AddressLength),		\
    	_MCode_ush(TA_ADDRESS, AddressLength),				\
	_MCode_ush(TA_ADDRESS, AddressType),				\
	_MCode_cauch(TA_ADDRESS, Address, AddressLength) 		\
    };									\
    MARSHAL_INFO MiTAddress = _mkMarshalInfo(TA_ADDRESS, _MCode_TAddress);

//
// Marshalling info for DS_TRANSPORT
//

extern MARSHAL_INFO MiDSTransport;

#define INIT_DS_TRANSPORT_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransport[] = {			\
        _MCode_conformant(DS_TRANSPORT, taddr.Address, taddr.AddressLength), \
    	_MCode_ush(DS_TRANSPORT, usFileProtocol),			\
	_MCode_ush(DS_TRANSPORT, iPrincipal),				\
	_MCode_ush(DS_TRANSPORT, grfModifiers),				\
	_MCode_struct(DS_TRANSPORT, taddr, &MiTAddress)		\
    };									\
    MARSHAL_INFO MiDSTransport = _mkMarshalInfo(DS_TRANSPORT, _MCode_DSTransport);


//
// The following is needed to define an array of pointers to DS_TRANSPORT
//

typedef struct _DS_TRANSPORT_P {
    PDS_TRANSPORT pDSTransport;
} DS_TRANSPORT_P;

#define INIT_DS_TRANSPORT_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransportP[] = {			\
    	_MCode_pstruct(DS_TRANSPORT_P, pDSTransport, &MiDSTransport)	\
    };									\
    MARSHAL_INFO MiDSTransportP = _mkMarshalInfo(DS_TRANSPORT_P, _MCode_DSTransportP);

extern MARSHAL_INFO MiDSTransportP;

//
// Marshalling info for DS_MACHINE
//

extern MARSHAL_INFO MiDSMachine;

#define INIT_DS_MACHINE_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_DSMachine[] = {			\
        _MCode_conformant(DS_MACHINE, rpTrans, cTransports),		\
    	_MCode_guid(DS_MACHINE, guidSite),				\
	_MCode_guid(DS_MACHINE, guidMachine),				\
	_MCode_ul(DS_MACHINE, grfFlags),				\
	_MCode_pwstr(DS_MACHINE, pwszShareName),			\
	_MCode_ul(DS_MACHINE, cPrincipals),				\
	_MCode_pcapwstr(DS_MACHINE, prgpwszPrincipals, cPrincipals),	\
	_MCode_ul(DS_MACHINE, cTransports),				\
	_MCode_castruct(DS_MACHINE, rpTrans, cTransports, &MiDSTransportP) \
    };									\
    MARSHAL_INFO MiDSMachine = _mkMarshalInfo(DS_MACHINE, _MCode_DSMachine);

//
// The following is needed to define an array of pointers to DS_MACHINE
//

typedef struct _DS_MACHINE_P {
    PDS_MACHINE pDSMachine;
} DS_MACHINE_P;

#define INIT_DS_MACHINE_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSMachineP[] = {			\
    	_MCode_pstruct(DS_MACHINE_P, pDSMachine, &MiDSMachine)		\
    };									\
    MARSHAL_INFO MiDSMachineP = _mkMarshalInfo(DS_MACHINE_P, _MCode_DSMachineP);

extern MARSHAL_INFO MiDSMachineP;

#endif // _DFS_GLUON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfscreat.c ===
//+----------------------------------------------------------------------------
//
//  File:       create.c
//
//  Contents:
//
//      This module implements the File Create routine for Dfs called by the
//      dispatch driver.  Unlike traditional disk-based FSDs, there is only
//      one entry point, DfsFsdCreate.  The request is assumed to be
//      synchronous (whether the user thread requests it or not).
//      Of course, since we will typically be calling out to some other
//      FSD, that FSD may post the request and return to us with a
//      STATUS_PENDING.
//
//  Functions:  DfsFsdCreate - FSD entry point for NtCreateFile/NtOpenFile
//              DfsCommonCreate, local
//              DfsPassThroughRelativeOpen, local
//              DfsCompleteRelativeOpen, local
//              DfsPostProcessRelativeOpen, local
//              DfsRestartRelativeOpen, local
//              DfsComposeFullName, local
//              DfsAreFilesOnSameLocalVolume, local
//
//  History:    27 Jan 1992     AlanW   Created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dnr.h"
#include "fcbsup.h"
#include "mupwml.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonCreate (
    OPTIONAL IN PIRP_CONTEXT IrpContext,
    PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

IO_STATUS_BLOCK
DfsOpenDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateOptions);

NTSTATUS
DfsPassThroughRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB ParentFcb);

NTSTATUS
DfsCompleteRelativeOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
DfsPostProcessRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB ParentFcb);

VOID
DfsRestartRelativeOpen(
    IN PIRP_CONTEXT IrpContext);

NTSTATUS
DfsComposeFullName(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING RelativeName,
    OUT PUNICODE_STRING FullName);

NTSTATUS
DfsAreFilesOnSameLocalVolume(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING FileName);


#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFsdCreate )
#pragma alloc_text( PAGE, DfsCommonCreate )
#pragma alloc_text( PAGE, DfsOpenDevice )
#pragma alloc_text( PAGE, DfsPassThroughRelativeOpen )
#pragma alloc_text( PAGE, DfsPostProcessRelativeOpen )
#pragma alloc_text( PAGE, DfsRestartRelativeOpen )
#pragma alloc_text( PAGE, DfsComposeFullName )
#pragma alloc_text( PAGE, DfsAreFilesOnSameLocalVolume )

//
// The following are not pageable since they can be called at DPC level
//
// DfsCompleteRelativeOpen
//

#endif // ALLOC_PRAGMA



//+-------------------------------------------------------------------
//
//  Function:   DfsFsdCreate, public
//
//  Synopsis:   This routine implements the FSD part of the NtCreateFile
//              and NtOpenFile API calls.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where
//                      the file/directory exists that we are trying
//                      to open/create exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The Fsd status for the Irp
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PDFS_FCB pFcb = NULL;

    DfsDbgTrace(+1, Dbg, "DfsFsdCreate: Entered\n", 0);

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCreate_Entry, 
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGUSTR(FileObject->FileName)
                   LOGPTR(Irp));

    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    //
    //  Call the common create routine, with block allowed if the operation
    //  is synchronous.
    //

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonCreate( IrpContext, DeviceObject, Irp );

    } except( DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );

    }

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdCreate: Exit -> %08lx\n", ULongToPtr(Status) );
    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCreate_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    return Status;
}


//+-------------------------------------------------------------------
//  Function:   DfsCommonCreate, private
//
//  Synopsis:   This is the common routine for creating/opening a file
//              called by both the FSD and FSP threads.
//
//  Arguments:  [DeviceObject] - The device object associated with
//                      the request.
//              [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - the return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonCreate (
    OPTIONAL IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDFS_VCB Vcb = NULL;
    PDFS_FCB Fcb = NULL;

    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ACCESS_MASK DesiredAccess;
    ULONG CreateOptions;
    USHORT ShareAccess;
    NTSTATUS Status;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    DfsDbgTrace(+1, Dbg, "DfsCommonCreate\n", 0 );
    DfsDbgTrace( 0, Dbg, "Irp                   = %08lx\n", Irp );
    DfsDbgTrace( 0, Dbg, "->Flags               = %08lx\n", ULongToPtr(Irp->Flags) );
    DfsDbgTrace( 0, Dbg, "->FileObject          = %08lx\n", FileObject );
    DfsDbgTrace( 0, Dbg, "  ->RelatedFileObject = %08lx\n", FileObject->RelatedFileObject );
    DfsDbgTrace( 0, Dbg, "  ->FileName          = %wZ\n",    &FileObject->FileName );
    DfsDbgTrace( 0, Dbg, "->DesiredAccess       = %08lx\n", ULongToPtr(IrpSp->Parameters.Create.SecurityContext->DesiredAccess) );
    DfsDbgTrace( 0, Dbg, "->CreateOptions       = %08lx\n", ULongToPtr(IrpSp->Parameters.Create.Options) );
    DfsDbgTrace( 0, Dbg, "->FileAttributes      = %04x\n",  IrpSp->Parameters.Create.FileAttributes );
    DfsDbgTrace( 0, Dbg, "->ShareAccess         = %04x\n",  IrpSp->Parameters.Create.ShareAccess );
    DfsDbgTrace( 0, Dbg, "->EaLength            = %08lx\n", ULongToPtr(IrpSp->Parameters.Create.EaLength) );


    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] DfsCommonCreate(%wZ)\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        &FileObject->FileName);
    }
#endif

    //
    //  Reference our input parameters to make things easier
    //

    RelatedFileObject = IrpSp->FileObject->RelatedFileObject;
    FileName          = *((PUNICODE_STRING) &IrpSp->FileObject->FileName);
    DesiredAccess     = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    CreateOptions     = IrpSp->Parameters.Create.Options;
    ShareAccess       = IrpSp->Parameters.Create.ShareAccess;

    Iosb.Status = STATUS_SUCCESS;

    //
    //  Short circuit known invalid opens.
    //

    if ((IrpSp->Flags & SL_OPEN_PAGING_FILE) != 0) {

        DfsDbgTrace(0, Dbg,
            "DfsCommonCreate: Paging file not allowed on Dfs\n", 0);

        Iosb.Status = STATUS_INVALID_PARAMETER;

        MUP_TRACE_HIGH(ERROR, DfsCommonCreate_Error_PagingFileNotAllowed,
                       LOGSTATUS(Iosb.Status)
                       LOGPTR(DeviceObject)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));

        DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

        DfsDbgTrace(-1, Dbg, "DfsCommonCreate: Exit -> %08lx\n", ULongToPtr(Iosb.Status));

        return Iosb.Status;

    }

    //
    //  There are several cases we need to handle here.
    //
    //  1. FileName is 0 length
    //
    //     If the filename length is 0, then someone really wants to open the
    //     device object itself.
    //
    //  2. This is a Relative open and the parent is on the same volume,
    //     either local or remote.
    //
    //     We pass through the relative open to the driver that opened the
    //     parent.
    //
    //  3. This is a relative open and the parent is on a different volume.
    //
    //     Form the full name of the file by concatenating the parent's
    //     name with the relative file name. Stick this name in the FileObject
    //     and do DNR on the full name.
    //
    //  4. This is a relative open and the parent is a device object (ie,
    //     the parent was opened via case 1)
    //
    //     Assume the parent name is \, so concatenate \ with the relative
    //     file name. Stick this name in the FileObject and do DNR on the
    //     the full name.
    //
    //  5. This is an absolute open, (or a case 3/4 converted to an absolute
    //     open), and the SL_OPEN_TARGET_DIRECTORY bis *is* set.
    //
    //     a. If the file's immediate parent directory is on the same local
    //        volume as the file, then do a regular DNR, and let the
    //        underlying FS handle the SL_OPEN_TARGET_DIRECTORY.
    //
    //     b. If the file's immediate parent directory is on a local volume
    //        and the file is not on the same local volume, then immediately
    //        return STATUS_NOT_SAME_DEVICE.
    //
    //     c. If the file's immediate parent directory is on a remote volume,
    //        then do a full DNR. This will pass through the
    //        SL_OPEN_TARGET_DIRECTORY to the remote Dfs driver, which will
    //        handle it as case 5a. or 5b.
    //
    //  6. This is an absolute open, (or a case 3/4 converted to an absolute
    //     open), and the SL_OPEN_TARGET_DIRECTORY bit is *not* set.
    //
    //     Do a DNR on the FileObject's name.
    //

    try {

        //
        //  Check to see if we are opening a device object.  If so, and the
        //  file is being opened on the File system device object, it will
        //  only permit FsCtl and Close operations to be performed.
        //

        if (
            (FileName.Length == 0 && RelatedFileObject == NULL)
                ||
            (DeviceObject != NULL &&
             DeviceObject->DeviceType != FILE_DEVICE_DFS &&
             RelatedFileObject == NULL)
            ) {

            //
            // This is case 1.
            //
            // In this case there had better be a DeviceObject
            //

            ASSERT(ARGUMENT_PRESENT(DeviceObject));

            DfsDbgTrace(0, Dbg,
                "DfsCommonCreate: Opening the device, DevObj = %08lx\n",
                DeviceObject);

            Iosb = DfsOpenDevice( IrpContext,
                                  FileObject,
                                  DeviceObject,
                                  DesiredAccess,
                                  ShareAccess,
                                  CreateOptions);

            Irp->IoStatus.Information = Iosb.Information;

            DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

            try_return( Iosb.Status );

        }

        if (DeviceObject != NULL && DeviceObject->DeviceType == FILE_DEVICE_DFS) {
            Vcb = &(((PLOGICAL_ROOT_DEVICE_OBJECT)DeviceObject)->Vcb);
        }

        //
        //  If there is a related file object, then this is a relative open.
        //

        if (RelatedFileObject != NULL) {

            //
            // This is case 2, 3, or 4.
            //

            PDFS_VCB TempVcb;
            TYPE_OF_OPEN OpenType;
            UNICODE_STRING NewFileName;

            OpenType = DfsDecodeFileObject( RelatedFileObject,
                                            &TempVcb,
                                            &Fcb);

            if (OpenType == RedirectedFileOpen) {

                DfsDbgTrace(0, Dbg, "Relative file open: DFS_FCB = %08x\n", Fcb);
                DfsDbgTrace(0, Dbg, "  Directory: %wZ\n", &Fcb->FullFileName);
                DfsDbgTrace(0, Dbg, "  Relative file:  %wZ\n", &FileName);

                //
                // This is case 2.
                //

                DfsDbgTrace(0, Dbg,
                    "Trying pass through of relative open\n", 0);

                Iosb.Status = DfsPassThroughRelativeOpen(
                                    Irp,
                                    IrpContext,
                                    Fcb
                                    );

                try_return( Iosb.Status );


            } else if (OpenType == LogicalRootDeviceOpen) {

                //
                // This is case 4.
                //
                // If the open is relative to a logical root open, then we
                // are forced to convert it to an absolute open, since there
                // is no underlying FS backing up the logical root to pass
                // the relative open to first.
                //

                DfsDbgTrace( 0, Dbg, "DfsCommonCreate: Open relative to Logical Root\n", 0);

                ASSERT (TempVcb == Vcb);

                NewFileName.MaximumLength = sizeof (WCHAR) +
                                                FileName.Length;

                NewFileName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                NewFileName.MaximumLength,
                                                ' puM');

                if (NewFileName.Buffer == NULL) {

                    Iosb.Status = STATUS_INSUFFICIENT_RESOURCES;

                    DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

                    try_return( Iosb.Status );

                }

                NewFileName.Buffer[0] = L'\\';

                NewFileName.Length = sizeof (WCHAR);

            } else {

                Iosb.Status = STATUS_INVALID_HANDLE;

                DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

                DfsDbgTrace(0, Dbg, "DfsCommonCreate: Invalid related file object\n", 0);

                try_return( Iosb.Status );

            }

            (void) DnrConcatenateFilePath (
                        &NewFileName,
                        FileName.Buffer,
                        FileName.Length);

            if (IrpSp->FileObject->FileName.Buffer)
                ExFreePool( IrpSp->FileObject->FileName.Buffer );

            FileName = IrpSp->FileObject->FileName = NewFileName;

        }

        ASSERT(FileName.Length != 0);

        //
        // This is case 5b, 5c, or 6 - Do a full DNR.
        //

        if (Vcb == NULL) {

            DfsDbgTrace(0, Dbg, "DfsCommonCreate: Null Vcb!\n", 0);

            Iosb.Status = STATUS_INVALID_PARAMETER;
            MUP_TRACE_HIGH(ERROR, DfsCommonCreate_Error_NullVcb,
                           LOGSTATUS(Iosb.Status)
                           LOGPTR(DeviceObject)
                           LOGPTR(FileObject)
                           LOGPTR(Irp));
            DfsCompleteRequest(IrpContext, Irp, Iosb.Status);

            try_return(Iosb.Status);

        }

        Iosb.Status = DnrStartNameResolution(IrpContext, Irp, Vcb);

    try_exit: NOTHING;
    } finally {

        DfsDbgTrace(-1, Dbg, "DfsCommonCreate: Exit  ->  %08lx\n", ULongToPtr(Iosb.Status));
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsCommonCreate exit 0x%x\n",
                            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                            Iosb.Status);
        }
#endif
    }

    return Iosb.Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsOpenDevice, local
//
//  Synopsis:   This routine opens the specified device for direct
//              access.
//
//  Arguments:  [FileObject] - Supplies the File object
//              [DeviceObject] - Supplies the object denoting the device
//                      being opened
//              [DesiredAccess] - Supplies the desired access of the caller
//              [ShareAccess] - Supplies the share access of the caller
//              [CreateOptions] - Supplies the create options for
//                      this operation
//
//  Returns:    [IO_STATUS_BLOCK] - Returns the completion status for
//                      the operation
//
//--------------------------------------------------------------------

IO_STATUS_BLOCK
DfsOpenDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateOptions
) {
    IO_STATUS_BLOCK Iosb;
    PDFS_VCB Vcb = NULL;

    //
    //  The following variables are for abnormal termination
    //
    BOOLEAN UnwindShareAccess = FALSE;
    BOOLEAN UnwindVolumeLock = FALSE;

    DfsDbgTrace( +1, Dbg, "DfsOpenDevice: Entered\n", 0 );

    try {

        //
        //  Check to see which type of device is being opened.
        //  We don't permit all open modes on the file system
        //  device object.
        //

        if (DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM ) {
            ULONG CreateDisposition = (CreateOptions >> 24) & 0x000000ff;

            //
            //  Check for proper desired access and rights
            //
            if (CreateDisposition != FILE_OPEN
                && CreateDisposition != FILE_OPEN_IF ) {

                Iosb.Status = STATUS_ACCESS_DENIED;
                MUP_TRACE_HIGH(ERROR, DfsOpenDevice_Error_BadDisposition,
                               LOGSTATUS(Iosb.Status)
                               LOGPTR(DeviceObject)
                               LOGPTR(FileObject));
                try_return( Iosb );
            }

            //
            //  Check if we were to open a directory
            //

            if (CreateOptions & FILE_DIRECTORY_FILE) {
                DfsDbgTrace(0, Dbg, "DfsOpenDevice: Cannot open device as a directory\n", 0);

                Iosb.Status = STATUS_NOT_A_DIRECTORY;
                MUP_TRACE_HIGH(ERROR, DfsOpenDevice_Error_CannotOpenAsDirectory,
                               LOGSTATUS(Iosb.Status)
                               LOGPTR(DeviceObject)
                               LOGPTR(FileObject));
                try_return( Iosb );
            }


            DfsSetFileObject( FileObject,
                             FilesystemDeviceOpen,
                             DeviceObject
                             );

            Iosb.Status = STATUS_SUCCESS;
            Iosb.Information = FILE_OPENED;
            try_return( Iosb );
        }

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
        Vcb = & (((PLOGICAL_ROOT_DEVICE_OBJECT)DeviceObject)->Vcb);


        //
        //  If the user does not want to share anything then we will try and
        //  take out a lock on the volume.  We check if the volume is already
        //  in use, and if it is then we deny the open
        //

        if ((ShareAccess & (
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)) == 0 ) {

            if (Vcb->OpenFileCount != 0) {

                ExReleaseResourceLite( &DfsData.Resource );
                Iosb.Status = STATUS_ACCESS_DENIED;
                MUP_TRACE_HIGH(ERROR, DfsOpenDevice_Error_FileInUse,
                               LOGSTATUS(Iosb.Status)
                               LOGPTR(DeviceObject)
                               LOGPTR(FileObject));

                try_return( Iosb );
            }

            //
            //  Lock the volume
            //

            Vcb->VcbState |= VCB_STATE_FLAG_LOCKED;
            Vcb->FileObjectWithVcbLocked = FileObject;
            UnwindVolumeLock = TRUE;
        }

        //
        //  If the volume is already opened by someone then we need to check
        //  the share access
        //

        if (Vcb->DirectAccessOpenCount > 0) {

            if ( !NT_SUCCESS( Iosb.Status
                                = IoCheckShareAccess( DesiredAccess,
                                                      ShareAccess,
                                                      FileObject,
                                                      &Vcb->ShareAccess,
                                                      TRUE ))) {
                ExReleaseResourceLite( &DfsData.Resource );

                MUP_TRACE_ERROR_HIGH(Iosb.Status, ALL_ERROR, DfsOpenDevice_Error_IoCheckShareAccess,
                                     LOGSTATUS(Iosb.Status)
                                     LOGPTR(DeviceObject)
                                     LOGPTR(FileObject));

                try_return( Iosb );
            }

        } else {

            IoSetShareAccess( DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &Vcb->ShareAccess );
        }

        UnwindShareAccess = TRUE;


        //
        // Bug: 425017. Update the counters with lock held to avoid race between multiple processors.
        //


        InterlockedIncrement(&Vcb->DirectAccessOpenCount);
        InterlockedIncrement(&Vcb->OpenFileCount);

        ExReleaseResourceLite( &DfsData.Resource );
        //
        //  Setup the context pointers, and update
        //  our reference counts
        //

        DfsSetFileObject( FileObject,
                          LogicalRootDeviceOpen,
                          Vcb
                         );


        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination() && (Vcb != NULL)) {

            if (UnwindShareAccess) {
                IoRemoveShareAccess( FileObject, &Vcb->ShareAccess );
            }

            if (UnwindVolumeLock) {
                Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;
                Vcb->FileObjectWithVcbLocked = NULL;
            }

        }

        DfsDbgTrace(-1, Dbg, "DfsOpenDevice: Exit -> Iosb.Status = %08lx\n", ULongToPtr(Iosb.Status));
    }

    return Iosb;
}


//+----------------------------------------------------------------------------
//
//  Function:  DfsPassThroughRelativeOpen
//
//  Synopsis:  Passes through a relative open call to the device handling
//             the parent. This is required for structured storages on OFS
//             to work, for replication's Do-not-cross-JP sematics to work,
//             and as an optimization.
//
//  Arguments: [Irp] -- The open Irp, which we will pass through.
//             [IrpContext] -- Associated with the above Irp.
//             [ParentFcb] -- Fcb of related file object.
//
//  Returns:   Status returned by the underlying FS, or by DNR if
//             the underlying FS complained about STATUS_DFS_EXIT_PATH_FOUND.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPassThroughRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB ParentFcb)
{

    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp, NextIrpSp;
    PFILE_OBJECT FileObject;
    PDFS_FCB NewFcb;
    UNICODE_STRING NewFileName;

    DfsDbgTrace(+1, Dbg, "DfsPassThroughRelativeOpen: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // Prepare to pass the request to the device handling the parent open.
    //

    //
    // First, we preallocate an DFS_FCB, assuming that the relative open will
    // succeed. We need to do this at this point in time because the
    // FileObject->FileName is still intact; after we pass through, the
    // underlying can do as it wishes with the FileName field, and we will
    // be unable to construct the full file name for the DFS_FCB.
    //

    Status = DfsComposeFullName(
                &ParentFcb->FullFileName,
                &IrpSp->FileObject->FileName,
                &NewFileName);

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, Dbg, "DfsPassThroughRelativeOpen: Unable to create full Name %08lx\n",
                                        ULongToPtr(Status) );
        DfsCompleteRequest( IrpContext, Irp, Status );
        return( Status );
    }


    NewFcb = DfsCreateFcb( NULL, ParentFcb->Vcb, &NewFileName );

    if (NewFcb == NULL) {

        if (NewFileName.Buffer != NULL)
            ExFreePool(NewFileName.Buffer);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DfsDbgTrace(-1, Dbg, "DfsPassThroughRelativeOpen: Exited %08lx\n", ULongToPtr(Status));

        DfsCompleteRequest( IrpContext, Irp, Status );
        return( Status );

    }

    // Changes for 426540. Do all the right logic for CSC. 
    // since DFS does not "failover" for relative names, allow CSC to go
    // offline if necessary to serve the name. This does mean that the DFS
    // namespace will be served by the CSC even when one of the DFS alternates
    // exists.

    NewFcb->DfsNameContext.Flags = DFS_FLAG_LAST_ALTERNATE;

    if (NewFcb->Vcb != NULL) {
        if (NewFcb->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) {
            NewFcb->DfsNameContext.NameContextType = DFS_CSCAGENT_NAME_CONTEXT;
         }
         else {
            NewFcb->DfsNameContext.NameContextType = DFS_USER_NAME_CONTEXT;
         }
    }

    NewFcb->TargetDevice = ParentFcb->TargetDevice;
    NewFcb->ProviderId = ParentFcb->ProviderId;
    NewFcb->DfsMachineEntry = ParentFcb->DfsMachineEntry;
    NewFcb->FileObject = IrpSp->FileObject;

    DfsSetFileObject(IrpSp->FileObject,
		     RedirectedFileOpen,
		     NewFcb
		     );

    IrpSp->FileObject->FsContext = &(NewFcb->DfsNameContext);
    if (ParentFcb->ProviderId == PROV_ID_DFS_RDR) {
        IrpSp->FileObject->FsContext2 = UIntToPtr(DFS_OPEN_CONTEXT);
    }

    if (NewFileName.Buffer != NULL)
        ExFreePool( NewFileName.Buffer );

    //
    // Next, setup the IRP stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    (*NextIrpSp) = (*IrpSp);

    //
    // Put the parent DFS_FCB pointer in the IrpContext.
    //

    IrpContext->Context = (PVOID) NewFcb;

    IoSetCompletionRoutine(
        Irp,
        DfsCompleteRelativeOpen,
        IrpContext,
        TRUE,
        TRUE,
        TRUE);

    Status = IoCallDriver( ParentFcb->TargetDevice, Irp );
    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsPassThroughRelativeOpen_Error_IoCallDriver,
                         LOGSTATUS(Status)
                         LOGPTR(FileObject)
                         LOGPTR(Irp));

    DfsDbgTrace(0, Dbg, "IoCallDriver returned %08lx\n", ULongToPtr(Status));

    if (Status != STATUS_PENDING) {

        Status =  DfsPostProcessRelativeOpen(
                        Irp,
                        IrpContext,
                        NewFcb);

    }

    DfsDbgTrace(-1, Dbg, "DfsPassThroughRelativeOpen: Exited %08lx\n", ULongToPtr(Status));

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:  DfsCompleteRelativeOpen
//
//  Synopsis:  Completion routine for DfsPassThroughRelativeOpen. It is
//             interesting only in case where STATUS_PENDING was originally
//             returned from IoCallDriver. If so, then this routine simply
//             queues DfsRestartRelativeOpen to a work queue. Note that it
//             must queue an item at this stage instead of doing the work
//             itself because this routine is executed at DPC level.
//
//  Arguments: [pDevice] -- Our device object.
//             [Irp] -- The Irp being completed.
//             [IrpContext] -- Context associated with Irp.
//
//  Returns:    STATUS_MORE_PROCESSING_REQUIRED. Either the posted routine
//              or DfsPassThroughRelativeOpen must complete the IRP for real.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCompleteRelativeOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext)
{

    DfsDbgTrace( +1, Dbg, "DfsCompleteRelativeOpen: Entered\n", 0);

    //
    // We are only interested in the case when the pass through of relative
    // opens returned STATUS_PENDING. In that case, the original thread has
    // popped all the way back to the caller of NtCreateFile, and we need
    // to finish the open in an asynchronous manner.
    //

    if (Irp->PendingReturned) {

        DfsDbgTrace(0, Dbg, "Pending returned : Queuing DfsRestartRelativeOpen\n", 0);

        //
        // We need to call IpMarkIrpPending so the IoSubsystem will realize
        // that our FSD routine returned STATUS_PENDING. We can't call this
        // from the FSD routine itself because the FSD routine doesn't have
        // access to the stack location when the underlying guy returns
        // STATUS_PENDING
        //

        IoMarkIrpPending( Irp );

        ExInitializeWorkItem( &(IrpContext->WorkQueueItem),
                              DfsRestartRelativeOpen,
                              (PVOID) IrpContext );

        ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    }

    //
    // We MUST return STATUS_MORE_PROCESSING_REQUIRED to halt the completion
    // of the Irp. Either DfsRestartRelativeOpen that we queued above or
    // DfsPassThroughRelativeOpen will complete the IRP after it is done.
    //

    DfsDbgTrace(-1, Dbg, "DfsCompleteRelativeOpen: Exited\n", 0);

    return( STATUS_MORE_PROCESSING_REQUIRED );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsPostProcessRelativeOpen
//
//  Synopsis:  Continues a relative open after it has already been passed
//             to the device of the parent. One of three things could have
//             happened -
//
//              a) The device of the parent successfully handled the open.
//                 We create an fcb and return.
//              b) The device of the parent could not do the open for some
//                 reason other than STATUS_DFS_EXIT_PATH_FOUND. We return
//                 the error to the caller.
//              c) The device of the parent returned STATUS_DFS_EXIT_PATH
//                 found. In that case, we convert the relative open to an
//                 absolute open and do a full Dnr.
//
//  Arguments:  [Irp] -- Pointer to Irp
//              [IrpContext] -- Pointer to IrpContext associated with Irp
//              [Fcb] -- Preallocated Fcb of this file.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPostProcessRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB Fcb)
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    UNICODE_STRING NewFileName;
    BOOLEAN fCompleteRequest = TRUE;

    DfsDbgTrace(+1, Dbg, "DfsPostProcessRelativeOpen: Entered\n", 0);

    ASSERT( ARGUMENT_PRESENT( Irp ) );
    ASSERT( ARGUMENT_PRESENT( IrpContext ) );
    ASSERT( ARGUMENT_PRESENT( Fcb ) );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    ASSERT( Fcb->Vcb != NULL );
    ASSERT( NodeType(Fcb->Vcb) == DSFS_NTC_VCB );


    Status = Irp->IoStatus.Status;

    if (Status == STATUS_SUCCESS) {

        //
        // Just set the DFS_FCB for the FileObject.
        //

        DfsDbgTrace( 0, Dbg, "Relative Open pass through succeeded\n", 0 );

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        InterlockedIncrement(&Fcb->DfsMachineEntry->UseCount);

        //
        // Now that a File Open has succeeded, we need to bump up OpenCnt
        // on the DFS_VCB.
        //

        InterlockedIncrement(&Fcb->Vcb->OpenFileCount);

    } else if ( Status == STATUS_DFS_EXIT_PATH_FOUND ||
                    Status == STATUS_PATH_NOT_COVERED ) {

        PDFS_VCB Vcb;

        //
        // Exit path was found. We'll have to convert this relative open to
        // an absolute open, and do a normal dnr on it.
        //

        DfsDbgTrace(0, Dbg, "Exit point found! Trying absolute open\n", 0);

        Vcb = Fcb->Vcb;

        NewFileName.Buffer = ExAllocatePoolWithTag(
                                NonPagedPool,
                                Fcb->FullFileName.MaximumLength,
                                ' puM');

        if (NewFileName.Buffer != NULL) {

            NewFileName.Length = Fcb->FullFileName.Length;
            NewFileName.MaximumLength = Fcb->FullFileName.MaximumLength;

            RtlMoveMemory(
                (PVOID) NewFileName.Buffer,
                (PVOID) Fcb->FullFileName.Buffer,
                Fcb->FullFileName.Length );

	    DfsDetachFcb( FileObject, Fcb );

            DfsDeleteFcb( IrpContext, Fcb );

            if (FileObject->FileName.Buffer) {

                ExFreePool( FileObject->FileName.Buffer );

            }

            FileObject->FileName = NewFileName;

            // OFS apparently sets the FileObject->Vpb even though it failed
            //         the open. Reset it to NULL.
            //

            if (FileObject->Vpb != NULL) {
                FileObject->Vpb = NULL;
            }

            DfsDbgTrace(0, Dbg, "Absolute path == %wZ\n", &NewFileName);

            fCompleteRequest = FALSE;

            ASSERT( Vcb != NULL );

            Status = DnrStartNameResolution( IrpContext, Irp, Vcb );

        } else {

	    DfsDetachFcb( FileObject, Fcb );

            DfsDeleteFcb( IrpContext, Fcb );

            Status = STATUS_INSUFFICIENT_RESOURCES;

            DfsDbgTrace(0, Dbg, "Unable to allocate full name!\n", 0);

        }

    } else {

        DfsDetachFcb( FileObject, Fcb );
        DfsDeleteFcb( IrpContext, Fcb );

    }

    if (fCompleteRequest) {

        DfsCompleteRequest( IrpContext, Irp, Status );

    }

    DfsDbgTrace(-1, Dbg, "DfsPostProcessRelativeOpen: Exited %08lx\n", ULongToPtr(Status));

    return(Status);

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsRestartRelativeOpen
//
//  Synopsis:  This function is intended to be queued to complete processing
//             of a relative open IRP that was passed through and originally
//             came back with STATUS_PENDING.
//
//  Arguments: [IrpContext]
//
//  Returns:   Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsRestartRelativeOpen(
    IN PIRP_CONTEXT IrpContext)
{
    NTSTATUS Status;

    DfsDbgTrace(+1, Dbg, "DfsRestartRelativeOpen: Entered IrpContext == %08lx\n", IrpContext);

    Status = DfsPostProcessRelativeOpen(
                IrpContext->OriginatingIrp,
                IrpContext,
                (PDFS_FCB) IrpContext->Context);

    DfsDbgTrace(-1, Dbg, "DfsRestartRelativeOpen: Exited\n", 0);

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsComposeFullName
//
//  Synopsis:  Given a fully qualified name and a relative name, this
//             function allocates room for the concatenation of the two, and
//             fills up the buffer with the concatenated name.
//
//  Arguments: [ParentName] -- Pointer to fully qualified parent name.
//             [RelativeName] -- Pointer to name relative to parent.
//             [FullName] -- Pointer to UNICODE_STRING structure that will
//                           get filled up with the full name.
//
//  Returns:   STATUS_INSUFFICIENT_RESOURCES if memory allocation fails.
//             STAUS_SUCCESS otherwise.
//
//  Notes:     This routine uses an appropriate allocator so that the
//             returned FullName can be put into a FILE_OBJECT.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsComposeFullName(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING RelativeName,
    OUT PUNICODE_STRING FullName)
{
    ULONG nameLen;
    NTSTATUS status;

    nameLen = ParentName->Length +
                    sizeof (WCHAR) +           // For backslash
                    RelativeName->Length;

    if (nameLen > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, DfsComposeFullName_Error1,
                       LOGUSTR(*ParentName)
                       LOGSTATUS(status));
        return status;
    }

    FullName->Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        nameLen,
                                        ' puM');

    if (FullName->Buffer == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    FullName->Length = ParentName->Length;
    FullName->MaximumLength = (USHORT)nameLen;
    RtlMoveMemory (FullName->Buffer, ParentName->Buffer, ParentName->Length);

    if (RelativeName->Length > 0) {
        (void) DnrConcatenateFilePath(
                        FullName,
                        RelativeName->Buffer,
                        RelativeName->Length);
    }

    return( STATUS_SUCCESS );
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsAreFilesOnSameLocalVolume
//
//  Synopsis:   Given a file name and a name relative to it, this routine
//              will determine if both files live on the same local volume.
//
//  Arguments:  [ParentName] -- The name of the parent file.
//              [FileName] -- Name relative to parent of the other file.
//
//  Returns:    [STATUS_SUCCESS] -- The two files should indeed be on the
//                      same local volume.
//
//              [STATUS_NOT_SAME_DEVICE] -- The two files are not on the
//                      same local volume.
//
//              [STATUS_OBJECT_TYPE_MISMATCH] -- ustrParentName is not on
//                      a local volume.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsAreFilesOnSameLocalVolume(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING FileName)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntryParent;
    PDFS_PKT_ENTRY pktEntryFile;
    UNICODE_STRING remPath;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1, Dbg, "DfsAreFilesOnSameLocalVolume entered\n", 0);

    DfsDbgTrace(0, Dbg, "Parent = [%wZ]\n", ParentName);
    DfsDbgTrace(0, Dbg, "File = [%wZ]\n", FileName);

    pkt = _GetPkt();

    PktAcquireShared( TRUE, &pktLocked );

    //
    // First, see if the parent is on a local volume at all.
    //

    pktEntryParent = PktLookupEntryByPrefix( pkt, ParentName, &remPath );

    DfsDbgTrace(0, Dbg, "Parent Entry @%08lx\n", pktEntryParent);

    if (pktEntryParent == NULL ||
            !(pktEntryParent->Type & PKT_ENTRY_TYPE_LOCAL)) {

        status = STATUS_OBJECT_TYPE_MISMATCH;

    }

    if (NT_SUCCESS(status)) {

        USHORT parentLen;

        //
        // Parent is local, verify that the relative file does not cross a
        // junction point. We'll iterate through the list of exit points on
        // the parent's local volume pkt entry, comparing the remaing path
        // of the exit point with the FileName argument
        //

        ASSERT(pktEntryParent != NULL);

        parentLen = pktEntryParent->Id.Prefix.Length +
                        sizeof(UNICODE_PATH_SEP);

        for (pktEntryFile = PktEntryFirstSubordinate(pktEntryParent);
                pktEntryFile != NULL && NT_SUCCESS(status);
                    pktEntryFile = PktEntryNextSubordinate(
                        pktEntryParent, pktEntryFile)) {

            remPath = pktEntryFile->Id.Prefix;
            remPath.Length -= parentLen;
            remPath.Buffer += (parentLen/sizeof(WCHAR));

            if (DfsRtlPrefixPath( &remPath, FileName, FALSE)) {

                DfsDbgTrace(0, Dbg,
                    "Found entry %08lx for File\n", pktEntryFile);

                //
                // FileName is on another volume.
                //

                status = STATUS_NOT_SAME_DEVICE;

            }

        }

    }

    PktRelease();

    DfsDbgTrace(-1, Dbg, "DfsAreFilesOnSameLocalVolume exit %08lx\n", ULongToPtr(status));

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsclose.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       CLOSE.C
//
//  Contents:   This module implements the File Close and Cleanup routines for
//              Dsfs called by the dispatch driver.
//
//  Functions:  DfsFsdClose - FSD entry point for Close IRP
//              DfsFsdCleanup - FSD entry point for Cleanup IRP
//              DfsFspClose - FSP entry point for Close IRP
//              DfsCommonClose - Common close IRP handler
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "fcbsup.h"
#include "mupwml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsCloseWorkInSystemContext (
    PDFS_FCB pDfsFcb );

VOID
DfsClosePostSystemWork(
    PDFS_FCB pDfsFcb );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdClose )
#pragma alloc_text( PAGE, DfsFsdCleanup )
#pragma alloc_text( PAGE, DfsFspClose )
#pragma alloc_text( PAGE, DfsCommonClose )
#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DfsFsdClose, public
//
//  Synopsis:   This routine implements the FSD part of closing down the
//              last reference to a file object.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the
//                                file being closed exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the IRP
//
//  Notes:      Even when the close is through the attached device
//              object, we need to check if the file is one of ours,
//              since files opened via the logical root device
//              object get switched over to the attached device for
//              local volumes.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdClose_Entry, 
                   LOGPTR(DeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject));

    DfsDbgTrace(+1, Dbg, "DfsFsdClose:  Entered\n", 0);
    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        if (DfsLookupFcb(IrpSp->FileObject) == NULL) {
            Status = DfsVolumePassThrough(DeviceObject, Irp);
            DfsDbgTrace(-1, Dbg, "DfsFsdClose:  Exit -> %08lx\n", ULongToPtr(Status) );
            return Status;
        }
    }

    //
    //  Call the common close routine, with blocking allowed if synchronous
    //
    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonClose( IrpContext, Irp );


    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdClose:  Exit -> %08lx\n", ULongToPtr(Status));

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdClose_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(DeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject)); 
    return Status;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsFsdCleanup, public
//
//  Synopsis:   This routine implements the FSD part of closing down the
//              last user handle to a file object.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the
//                                file being closed exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    DfsDbgTrace(+1, Dbg, "DfsFsdCleanup:  Entered\n", 0);
    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCleanup_Entry,
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));

    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    //
    // Now, pass through to the device that opened the file for us if the
    // file was a redirected open of some kind.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS) {
        TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);
        if (TypeOfOpen == RedirectedFileOpen) {
            Status = DfsVolumePassThrough(DeviceObject, Irp);
            DfsDbgTrace(-1, Dbg, "DfsFsdCleanup: RedirectedOpen.Exit -> %08lx\n", ULongToPtr(Status) );
            return Status;
        }
    }

    //
    //  TypeOfOpen != RedirectedFileOpen. We do nothing special for cleanup;
    //  everything is done in the close routine.
    //

    FsRtlEnterFileSystem();

    Status = STATUS_SUCCESS;

    DfsCompleteRequest( NULL, Irp, Status );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdCleanup:  Exit -> %08lx\n", ULongToPtr(Status));

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCleanup_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    return Status;

}



//+-------------------------------------------------------------------
//
//  Function:   DfsFspClose, public
//
//  Synopsis:   This routine implements the FSP part of closing down the
//              last reference to a file object.
//
//  Arguments:  [IrpContext] -- Supplies the IRP context for the request
//                              being processed.
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    PDEVICE_OBJECT - Returns the volume device object
//                      of the volume just processed by this operation.
//                      This value is used by the Fsp dispatcher to examine
//                      the device object's overflow queue
//
//--------------------------------------------------------------------


VOID
DfsFspClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(+1, Dbg, "DfsFspClose:  Entered\n", 0);

    //
    //  Call the common close routine.
    //

    (VOID)DfsCommonClose( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspClose:  Exit -> VOID\n", 0);
}




//+-------------------------------------------------------------------
//
//  Function:   DfsCommonClose, local
//
//  Synopsis:   This is the common routine for closing a file/directory
//              called by both the fsd and fsp threads.
//
//              Close is invoked whenever the last reference to a file
//              object is deleted.  Cleanup is invoked when the last handle
//              to a file object is closed, and is called before close.
//
//              The function of close is to completely tear down and
//              remove the DFS_FCB structures associated with the
//              file object.
//
//  Arguments:  [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    BOOLEAN DontComplete = FALSE;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1, Dbg, "DfsCommonClose: Entered\n", 0);

    DfsDbgTrace( 0, Dbg, "Irp          = %08lx\n", Irp);
    DfsDbgTrace( 0, Dbg, "->FileObject = %08lx\n", FileObject);


    //
    //  This action is a noop for unopened file objects.  Nothing needs
    //  to be done for FS device opens, either.
    //

    TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);
    if (TypeOfOpen == UnopenedFileObject ||
        TypeOfOpen == FilesystemDeviceOpen ) {

        DfsDbgTrace(-1, Dbg, "DfsCommonClose:  Filesystem file object\n", 0);
        DfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    try {

        //
        //  Case on the type of open that we are trying to close.
        //

        switch (TypeOfOpen) {

        case LogicalRootDeviceOpen:

            DfsDbgTrace(0, Dbg, "DfsCommonClose: Close LogicalRootDevice\n", 0);

            InterlockedDecrement(&Vcb->DirectAccessOpenCount);
            InterlockedDecrement(&Vcb->OpenFileCount);

            if (Vcb->VcbState & VCB_STATE_FLAG_LOCKED) {
                Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;
                Vcb->FileObjectWithVcbLocked = NULL;
            }

            try_return( Status = STATUS_SUCCESS );

        case RedirectedFileOpen:

            DfsDbgTrace(0, Dbg, "DfsCommonClose:  File -> %wZ\n", &Fcb->FullFileName);

            //
            //  Decrement the OpenFileCount for the Vcb through which this
            //  file was opened.
            //

            InterlockedDecrement(&Vcb->OpenFileCount);


            //
            //  Close the redirected file by simply passing through
            //  to the redirected device.  We detach the DFS_FCB from the
            //  file object before the close so it cannot be looked
            //  up in some other thread.
            //

            DfsDetachFcb( FileObject, Fcb);
            Status = DfsFilePassThrough(Fcb, Irp);

            DontComplete = TRUE;

            //
            // Post to system work here, to avoid deadlocks with RDR.
            // workaround for bug 20642.
            //
            DfsClosePostSystemWork( Fcb );

            break;

        default:
            BugCheck("Dfs close, unexpected open type");
        }

    try_exit: NOTHING;

    } finally {

        //
        //  If this is a normal termination, then complete the request.
        //  Even if we're not to complete the IRP, we still need to
        //  delete the IRP_CONTEXT.
        //

        if (!AbnormalTermination()) {
            if (DontComplete) {
                DfsCompleteRequest( IrpContext, NULL, 0 );
            } else {
                DfsCompleteRequest( IrpContext, Irp, Status );
            }
        }

        DfsDbgTrace(-1, Dbg, "DfsCommonClose:  Exit -> %08lx\n", ULongToPtr(Status));
    }
    return Status;
}


VOID
DfsClosePostSystemWork(
    PDFS_FCB pDfsFcb )
{
    ExInitializeWorkItem( &pDfsFcb->WorkQueueItem,
                          DfsCloseWorkInSystemContext,
                          pDfsFcb );

    ExQueueWorkItem( &pDfsFcb->WorkQueueItem, CriticalWorkQueue );

    return;
}

//
//work around for bug 20642.
//
VOID
DfsCloseWorkInSystemContext (
    PDFS_FCB pDfsFcb )
{

    BOOLEAN pktLocked;
    //
    //  Decrement the RefCount on the DFS_MACHINE_ENTRY through which
    //  this file was opened
    //

    PktAcquireExclusive( TRUE, &pktLocked );

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    DfsDecrementMachEntryCount(pDfsFcb->DfsMachineEntry, TRUE);

    ExReleaseResourceLite( &DfsData.Resource );

    PktRelease();


    DfsDeleteFcb( NULL, pDfsFcb );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsinit.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsinit.c
//
//  Contents:   This module implements the DRIVER_INITIALIZATION routine
//      for the Dfs file system driver.
//
//  Functions:  DfsDriverEntry - Main entry point for driver initialization
//              DfsIoTimerRoutine - Main entry point for scavenger thread
//              DfsDeleteDevices - Routine to scavenge deleted net uses
//
//-----------------------------------------------------------------------------

#include "align.h"

#include "dfsprocs.h"
#include "fastio.h"
#include "fcbsup.h"

//
// The following are includes for init modules, which will get discarded when
// the driver has finished loading.
//

#include "provider.h"

//
//  The debug trace level
//

#define Dbg              (DEBUG_TRACE_INIT)


VOID
MupGetDebugFlags(VOID);

VOID
DfsGetEventLogValue(VOID);

VOID
DfsIoTimerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID    Context
    );

VOID
DfsDeleteDevices(
    PDFS_TIMER_CONTEXT DfsTimerContext);

NTSTATUS
DfsShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOL
DfsCheckLUIDDeviceMapsEnabled(
    VOID
    );

//
// Globals
//
HANDLE DfsDirHandle = NULL;
BOOL DfsLUIDDeviceMapsEnabled = FALSE;

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsDriverEntry)
#pragma alloc_text(PAGE, DfsDeleteDevices)
#pragma alloc_text(PAGE, DfsUnload)
#pragma alloc_text(PAGE, DfsShutdown)

//
// The following routine should not be pageable, because it gets called by
// the NT timer routine frequently. We don't want to thrash.
//
// DfsIoTimerRoutine
//


#endif // ALLOC_PRAGMA

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )



//+-------------------------------------------------------------------
//
//  Function:   DfsDriverEntry, main entry point
//
//  Synopsis:   This is the initialization routine for the Dfs file system
//      device driver.  This routine creates the device object for
//      the FileSystem device and performs all other driver
//      initialization.
//
//  Arguments:  [DriverObject] -- Pointer to driver object created by the
//                      system.
//              [RegistryPath] -- Path to section in registry describing
//                      this driver's configuration.
//
//  Returns:    [NTSTATUS] - The function value is the final status from
//                      the initialization operation.
//
//--------------------------------------------------------------------

NTSTATUS
DfsDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
) {
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT DeviceObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PWSTR p;
    int i;
    IO_STATUS_BLOCK iosb;
    LUID LogonID = SYSTEM_LUID;

#if DBG
    //
    // If debug, get debug flags
    //
    MupGetDebugFlags();

#endif

    //
    // Get the event logging level
    //
    DfsGetEventLogValue();

    //
    // See if someone else has already created a File System Device object
    // with the name we intend to use. If so, we bail.
    //

    RtlInitUnicodeString( &UnicodeString, DFS_DRIVER_NAME );

    //
    // Create the filesystem device object.
    //

    Status = IoCreateDevice( DriverObject,
             0,
             &UnicodeString,
             FILE_DEVICE_DFS_FILE_SYSTEM,
             FILE_REMOTE_DEVICE | FILE_DEVICE_SECURE_OPEN,
             FALSE,
             &DeviceObject );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Create a permanent object directory in which the logical root
    // device objects will reside.  Make the directory temporary, so
    // we can just close the handle to make it go away.
    //

    UnicodeString.Buffer = p = LogicalRootDevPath;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_LOGICAL_ROOT_LEN;
    while (*p++ != UNICODE_NULL)
        UnicodeString.Length += sizeof (WCHAR);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        0,
        NULL,
        NULL );

    Status = ZwCreateDirectoryObject(
                &DfsDirHandle,
                DIRECTORY_ALL_ACCESS,
                &ObjectAttributes);

    if ( !NT_SUCCESS( Status ) ) {
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    p[-1] = UNICODE_PATH_SEP;
    UnicodeString.Length += sizeof (WCHAR);

    //
    // Initialize the driver object with this driver's entry points.
    // Most are simply passed through to some other device driver.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DfsVolumePassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]      = (PDRIVER_DISPATCH)DfsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]       = (PDRIVER_DISPATCH)DfsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]     = (PDRIVER_DISPATCH)DfsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = (PDRIVER_DISPATCH)DfsFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = (PDRIVER_DISPATCH)DfsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = (PDRIVER_DISPATCH)DfsFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION]= (PDRIVER_DISPATCH)DfsFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION]= (PDRIVER_DISPATCH)DfsFsdSetVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = DfsShutdown;

    DriverObject->FastIoDispatch = &FastIoDispatch;

    Status = FsRtlRegisterFileSystemFilterCallbacks( DriverObject, &FsFilterCallbacks );

    if (!NT_SUCCESS( Status )) {

        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        goto ErrorOut;
    }

    //
    //  Initialize the global data structures
    //


    RtlZeroMemory(&DfsData, sizeof (DFS_DATA));

    DfsData.NodeTypeCode = DSFS_NTC_DATA_HEADER;
    DfsData.NodeByteSize = sizeof( DFS_DATA );

    InitializeListHead( &DfsData.VcbQueue );
    InitializeListHead( &DfsData.DeletedVcbQueue );

    // Initialize the devless root queue: this holds all the device less
    // net uses.
    InitializeListHead( &DfsData.DrtQueue );

    InitializeListHead( &DfsData.Credentials );
    InitializeListHead( &DfsData.DeletedCredentials );

    InitializeListHead( &DfsData.OfflineRoots );

    DfsData.DriverObject = DriverObject;
    DfsData.FileSysDeviceObject = DeviceObject;

    DfsData.LogRootDevName = UnicodeString;

    ExInitializeResourceLite( &DfsData.Resource );
    KeInitializeEvent( &DfsData.PktWritePending, NotificationEvent, TRUE );
    KeInitializeSemaphore( &DfsData.PktReferralRequests, 1, 1 );

    DfsData.MachineState = DFS_CLIENT;

    //
    //  Allocate Provider structures.
    //

    DfsData.pProvider = ExAllocatePoolWithTag(
                           PagedPool,
                           sizeof ( PROVIDER_DEF ) * MAX_PROVIDERS,
                           ' puM');

    if (DfsData.pProvider == NULL) {
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorOut;
    }

    for (i = 0; i < MAX_PROVIDERS; i++) {
        DfsData.pProvider[i].NodeTypeCode = DSFS_NTC_PROVIDER;
        DfsData.pProvider[i].NodeByteSize = sizeof ( PROVIDER_DEF );
    }

    DfsData.cProvider = 0;
    DfsData.maxProvider = MAX_PROVIDERS;


    //
    //  Initialize the system wide PKT
    //

    PktInitialize(&DfsData.Pkt);

    {
       ULONG SystemSizeMultiplier;

       switch (MmQuerySystemSize()) {
       default:
       case MmSmallSystem:
           SystemSizeMultiplier = 4;
           break;
       case MmMediumSystem:
           SystemSizeMultiplier = 8;
           break;

       case MmLargeSystem:
           SystemSizeMultiplier = 16;
           break;
       }

       //
       //  Allocate the DFS_FCB hash table structure.  The number of 
       // hash buckets will depend upon the memory size of the system.
       //

       Status = DfsInitFcbs(SystemSizeMultiplier * 2);
       if (!NT_SUCCESS (Status)) {
           PktUninitialize(&DfsData.Pkt);
           ExFreePool (DfsData.pProvider);
           ZwClose (DfsDirHandle);
           IoDeleteDevice (DeviceObject);
           goto ErrorOut;
       }

       //
       // Create a lookaside for the IRP contexts
       //

       ExInitializeNPagedLookasideList (&DfsData.IrpContextLookaside,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(IRP_CONTEXT),
                                        'IpuM',
                                        10 // unused
                                       );

    }

    //
    //  Set up global pointer to the system process.
    //

    DfsData.OurProcess = PsGetCurrentProcess();

    //
    // Set up the global pointers for the EA buffers to be used to differentiate
    // CSC agent opens from non CSC agent opens. This is a read only buffer used
    // to distinguish the CSC agent requests
    //
    //

    {
        UCHAR EaNameCSCAgentSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_CSCAGENT) + sizeof(CHAR),
                                            ALIGN_DWORD
                                            ) - sizeof(CHAR));

        DfsData.CSCEaBufferLength = ROUND_UP_COUNT(
                                         FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                         EaNameCSCAgentSize + sizeof(CHAR),
                                         ALIGN_DWORD
                                     );

        DfsData.CSCEaBuffer = ExAllocatePoolWithTag(
                                  PagedPool,
                                  DfsData.CSCEaBufferLength,
                                  ' puM');

        if (DfsData.CSCEaBuffer != NULL) {

            // clear the buffer, otherwise so we don't get any spurious 
            // failure due to IO manager checks
            memset(DfsData.CSCEaBuffer, 0, DfsData.CSCEaBufferLength);

            RtlCopyMemory(
                (LPSTR)DfsData.CSCEaBuffer->EaName,
                EA_NAME_CSCAGENT,
                EaNameCSCAgentSize);

            DfsData.CSCEaBuffer->EaNameLength = EaNameCSCAgentSize;

            DfsData.CSCEaBuffer->EaValueLength = 0;

            DfsData.CSCEaBuffer->NextEntryOffset = 0;
        } else {
            ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
            DfsUninitFcbs ();
            PktUninitialize(&DfsData.Pkt);
            ExFreePool (DfsData.pProvider);
            ZwClose (DfsDirHandle);
            IoDeleteDevice (DeviceObject);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DfsDbgTrace(-1, DEBUG_TRACE_ERROR, "Failed to allocate CSC ea buffer %08lx\n", ULongToPtr(Status) );
            return Status;
        }
    }

    //
    //  Register the file system with the I/O system. We don't need to invert this as its never registered.
    //

    IoRegisterFileSystem( DeviceObject );

    Status = IoRegisterShutdownNotification (DeviceObject); // This is automaticaly removed when IoDeleteDevice is called
    if (!NT_SUCCESS (Status)) {
        ExFreePool (DfsData.CSCEaBuffer);
        ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
        DfsUninitFcbs ();
        PktUninitialize(&DfsData.Pkt);
        ExFreePool (DfsData.pProvider);
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        return Status;
    }
    //
    //  Initialize the provider definitions from the registry.
    //

    if (!NT_SUCCESS( ProviderInit() )) {

        DfsDbgTrace(0,DEBUG_TRACE_ERROR,
               "Could not initialize some or all providers!\n", 0);

    }

    //
    // Check if LUID device maps are enabled
    //
    DfsLUIDDeviceMapsEnabled = DfsCheckLUIDDeviceMapsEnabled();
    
    //
    // Initialize the logical roots device objects. These are what form the
    // link between the outside world and the Dfs driver.
    //

#ifdef TERMSRV
    Status = DfsInitializeLogicalRoot( DD_DFS_DEVICE_NAME, NULL, NULL, 0, INVALID_SESSIONID, &LogonID);
#else // TERMSRV
    Status = DfsInitializeLogicalRoot( DD_DFS_DEVICE_NAME, NULL, NULL, 0, &LogonID);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, DEBUG_TRACE_ERROR, "Failed creation of root logical root %08lx\n", ULongToPtr(Status) );

        ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
        DfsUninitFcbs ();
        PktUninitialize(&DfsData.Pkt);
        ExFreePool (DfsData.pProvider);
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        return(Status);
    }

    //
    // Let us start off the Timer Routine.
    //

    RtlZeroMemory(&DfsTimerContext, sizeof(DFS_TIMER_CONTEXT));
    DfsTimerContext.InUse = FALSE;
    DfsTimerContext.TickCount = 0;
    
    //
    // 375929, io initialize timer, check return status.
    //
    Status =  IoInitializeTimer( DeviceObject,
                                 DfsIoTimerRoutine, 
                                 &DfsTimerContext );
    if (Status != STATUS_SUCCESS) {
#ifdef TERMSRV
        DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, INVALID_SESSIONID, &LogonID);
#else
        DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, &LogonID);
#endif
        ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
        DfsUninitFcbs ();
        PktUninitialize(&DfsData.Pkt);
        ExFreePool (DfsData.pProvider);
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        goto ErrorOut;
    }
    DfsDbgTrace(0, Dbg, "Initialized the Timer routine\n", 0);

    //
    //  Let us start the timer now.
    //

    IoStartTimer(DeviceObject);

    DfsDbgTrace(-1, Dbg, "DfsDriverEntry exit STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;

ErrorOut:

     DfsDbgTrace(-1, DEBUG_TRACE_ERROR, "DfsDriverEntry exit  %08lx\n", ULongToPtr(Status) );

     return Status;

}


NTSTATUS
DfsShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //
    // Unregister the file system object so we can unload
    //
    IoUnregisterFileSystem (DeviceObject);

    DfsCompleteRequest( NULL, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsUnload
//
//  Synopsis:   Routine called at unload time to free resources
//
//  Arguments:  [DriverObject] -- Driver object of MUP
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID
DfsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    LUID LogonID = SYSTEM_LUID;

    IoStopTimer(DfsData.FileSysDeviceObject);
#ifdef TERMSRV
    DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, INVALID_SESSIONID, &LogonID);
#else
    DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, &LogonID);
#endif
    ExFreePool (DfsData.CSCEaBuffer);
    ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
    DfsUninitFcbs ();
    PktUninitialize(&DfsData.Pkt);
    ExFreePool (DfsData.pProvider);
    ExDeleteResourceLite( &DfsData.Resource );
    ZwClose (DfsDirHandle);
    IoDeleteDevice (DfsData.FileSysDeviceObject);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteDevices
//
//  Synopsis:   Routine to scavenge deleted devices (net uses).
//
//  Arguments:  [pDfsTimerContext] -- Timer Context
//
//  Returns:    Nothing - this routine is meant to be queued to a worker
//              thread.
//
//-----------------------------------------------------------------------------

VOID
DfsDeleteDevices(
    PDFS_TIMER_CONTEXT DfsTimerContext)
{
    PLIST_ENTRY plink;
    PDFS_VCB Vcb;
    PLOGICAL_ROOT_DEVICE_OBJECT DeletedObject;

    if (DfsData.DeletedVcbQueue.Flink != &DfsData.DeletedVcbQueue) {

        DfsDbgTrace(0, Dbg, "Examining Deleted Vcbs...\n", 0);

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

        for (plink = DfsData.DeletedVcbQueue.Flink;
                plink != &DfsData.DeletedVcbQueue;
                    NOTHING) {

             Vcb = CONTAINING_RECORD(
                        plink,
                        DFS_VCB,
                        VcbLinks);

             plink = plink->Flink;

             DeletedObject = CONTAINING_RECORD(
                                Vcb,
                                LOGICAL_ROOT_DEVICE_OBJECT,
                                Vcb);

             if (Vcb->OpenFileCount == 0 &&
                    Vcb->DirectAccessOpenCount == 0 &&
                        DeletedObject->DeviceObject.ReferenceCount == 0) {

                 DfsDbgTrace(0, Dbg, "Deleting Vcb@%08lx\n", Vcb);

                 if (Vcb->LogRootPrefix.Buffer != NULL)
                     ExFreePool(Vcb->LogRootPrefix.Buffer);

                 if (Vcb->LogicalRoot.Buffer != NULL)
                     ExFreePool(Vcb->LogicalRoot.Buffer);

                 RemoveEntryList(&Vcb->VcbLinks);

                 ObDereferenceObject((PVOID) DeletedObject);

                 IoDeleteDevice( &DeletedObject->DeviceObject );

             } else {

                 DfsDbgTrace(0, Dbg, "Not deleting Vcb@%08lx\n", Vcb);

                 DfsDbgTrace(0, Dbg,
                    "OpenFileCount = %d\n", ULongToPtr(Vcb->OpenFileCount) );

                 DfsDbgTrace(0, Dbg,
                    "DirectAccessOpens = %d\n", ULongToPtr(Vcb->DirectAccessOpenCount) );

                 DfsDbgTrace(0, Dbg,
                    "DeviceObject Reference count = %d\n",
                    ULongToPtr(DeletedObject->DeviceObject.ReferenceCount) );

             }

        }

        ExReleaseResourceLite(&DfsData.Resource);

    }

    DfsTimerContext->InUse = FALSE;

}

//+-------------------------------------------------------------------------
//
// Function:    DfsIoTimerRoutine
//
// Synopsis:    This function gets called by IO Subsystem once every second.
//      This can be used for various purposes in the driver.  For now,
//      it periodically posts a request to a system thread to age Pkt
//      Entries.
//
// Arguments:   [Context] -- This is the context information.  It is actually
//              a pointer to a DFS_TIMER_CONTEXT.
//      [DeviceObject] -- Pointer to the Device object for DFS. We dont
//              really use this here.
//
// Returns: Nothing
//
// Notes:   The Context which we get here is assumed to have all the
//      required fields setup properly.
//
// History: 04/24/93    SudK    Created.
//
//--------------------------------------------------------------------------
VOID
DfsIoTimerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID    Context
)
{
    PDFS_TIMER_CONTEXT  pDfsTimerContext = (PDFS_TIMER_CONTEXT) Context;

    DfsDbgTrace(+1, Dbg, "DfsIoTimerRoutine: Entered\n", 0);

    //
    // If the DfsTimerContext is in USE then we just return blindly. Due to
    // this action we might actually lose some ticks. But then we really are
    // not very particular about this and hence dont care.
    //

    if (pDfsTimerContext->InUse == TRUE)    {

        DfsDbgTrace(-1, Dbg, "DfsIoTimerRoutine: TimerContext in use\n", 0);

        return;

    }

    //
    // First let us increment the count in the DFS_TIMER_CONTEXT. If it has
    // reached a bound value then we have to go ahead and schedule the
    // necessary work items.
    //

    pDfsTimerContext->TickCount++;

    if (pDfsTimerContext->TickCount == DFS_MAX_TICKS)   {

        DfsDbgTrace(0, Dbg, "Queuing Pkt Entry Scavenger\n", 0);

        pDfsTimerContext->InUse = TRUE;

        ExInitializeWorkItem(
            &pDfsTimerContext->WorkQueueItem,
            DfsAgePktEntries,
            pDfsTimerContext);

        ExQueueWorkItem( &pDfsTimerContext->WorkQueueItem, DelayedWorkQueue);

    } else if (DfsData.DeletedVcbQueue.Flink != &DfsData.DeletedVcbQueue) {

        DfsDbgTrace(0, Dbg, "Queueing Deleted Vcb Scavenger\n", 0);

        pDfsTimerContext->InUse = TRUE;

        ExInitializeWorkItem(
            &pDfsTimerContext->DeleteQueueItem,
            DfsDeleteDevices,
            pDfsTimerContext);

        ExQueueWorkItem(&pDfsTimerContext->DeleteQueueItem, DelayedWorkQueue);

    }

    DfsDbgTrace(-1, Dbg, "DfsIoTimerRoutine: Exiting\n", 0);

}

//+-------------------------------------------------------------------------
//
// Function:    DfsCheckLUIDDeviceMapsEnabled
//
// Synopsis:    This function calls ZwQueryInformationProcess to determine if
//    LUID device maps are enabled/disabled
//
// Arguments:   NONE
//
// Returns:
//          TRUE - LUID device maps are enabled
//
//          FALSE - LUID device maps are disabled
//
//--------------------------------------------------------------------------
BOOL
DfsCheckLUIDDeviceMapsEnabled(
    VOID
    )
{
    NTSTATUS  Status;
    ULONG     LUIDDeviceMapsEnabled;
    BOOL      Result;

    Status = ZwQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(
            -1,
            DEBUG_TRACE_ERROR,
            "DfsCheckLUIDDeviceMapsEnabled to failed to check if LUID device maps enabled, status = %08lx\n",
            ULongToPtr(Status));
        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsdata.h ===
//+----------------------------------------------------------------------------
//
//  File:       dfsdata.h
//
//  Contents:   This module declares the global data used by the
//              Dfs file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created.
//
//-----------------------------------------------------------------------------

#ifndef _DFSDATA_
#define _DFSDATA_

//
//  The global Dfs FSD data record. All Dfs allocated data structures are
//  anchored off of DfsData.
//

extern DFS_DATA DfsData;

//
//  The global timer context record, used by the timer thread and work items
//  queued by the timer thread.
//

extern DFS_TIMER_CONTEXT DfsTimerContext;

//
//  The maximum length of a logical root device name: length
//  of the device name prefix, plus size of a path separator
//  plus the maximum logical root name length.
//

#define MAX_LOGICAL_ROOT_LEN    (sizeof(DD_DFS_DEVICE_DIRECTORY) +          \
                                    sizeof (UNICODE_PATH_SEP) +             \
                                    MAX_LOGICAL_ROOT_NAME * sizeof (WCHAR))

extern WCHAR LogicalRootDevPath[];

extern ULONG DfsEventLog;
extern ULONG MupVerbose;

//
//  The global Dsfs debug level variable.
//

#if DBG

extern LONG DfsDebugTraceLevel;
extern LONG DfsDebugTraceIndent;

#define DEBUG_TRACE_ERROR               (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS         (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS    (0x00000004)
#define DEBUG_TRACE_UNWIND              (0x00000008)
#define DEBUG_TRACE_REGISTRY            (0x00000010)
#define DEBUG_TRACE_CLOSE               (0x00000020)
#define DEBUG_TRACE_CREATE              (0x00000040)
#define DEBUG_TRACE_INIT                (0x00000080)
#define DEBUG_TRACE_INSTRUM             (0x00000100)
#define DEBUG_TRACE_FILEINFO            (0x00000200)
#define DEBUG_TRACE_FSCTRL              (0x00000400)
#define DEBUG_TRACE_RTL                 (0x00000800)
#define DEBUG_TRACE_READ                (0x00001000)
#define DEBUG_TRACE_VOLINFO             (0x00002000)
#define DEBUG_TRACE_WRITE               (0x00004000)
#define DEBUG_TRACE_DEVCTRL             (0x00008000)
#define DEBUG_TRACE_PKT                 (0x00010000)
#define DEBUG_TRACE_DOTDFS              (0x00020000)
#define DEBUG_TRACE_LOCALVOL            (0x00040000)
#define DEBUG_TRACE_DNR                 (0x00080000)
#define DEBUG_TRACE_ATTACH              (0x00100000)
#define DEBUG_TRACE_FASTIO              (0x00200000)
#define DEBUG_TRACE_DIRSUP              (0x00400000)
#define DEBUG_TRACE_FILOBSUP            (0x00800000)
#define DEBUG_TRACE_EVENTLOG            (0x01000000)
#define DEBUG_TRACE_LOGROOT             (0x02000000)
#define DEBUG_TRACE_CACHESUP            (0x04000000)
#define DEBUG_TRACE_PREFXSUP            (0x08000000)
#define DEBUG_TRACE_DEVIOSUP            (0x10000000)
#define DEBUG_TRACE_STRUCSUP            (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER      (0x40000000)
#define DEBUG_TRACE_FSP_DUMP            (0x80000000)

//+---------------------------------------------------------------------------
// Macro:       DfsDbgTrace, public
//
// Synopsis:    Conditionally print a debug trace message
//
// Arguments:   [Indent] -- Indent to appluy: +1, 0 or -1
//              [Level] -- debug trace level
//              [Msg] -- Message to be printed, can include one prinf-style
//                      format effector.
//              [Y] -- Value to be printed
//
// Returns:     None
//
//----------------------------------------------------------------------------

VOID DfsDebugTracePrint(PCHAR x, PVOID y);

#define DfsDbgTrace(INDENT,LEVEL,X,Y) {                      \
    if (((LEVEL) == 0) || (DfsDebugTraceLevel & (LEVEL))) { \
        if ((INDENT) < 0) {                                 \
            DfsDebugTraceIndent += (INDENT);                \
        }                                                   \
        DfsDebugTracePrint(X, (PVOID)Y);                    \
        if ((INDENT) > 0) {                                 \
            DfsDebugTraceIndent += (INDENT);                \
        }                                                   \
    }                                                       \
}

#define DebugUnwind(X) {                                        \
    if (AbnormalTermination()) {                                \
        DfsDbgTrace(0, DEBUG_TRACE_UNWIND, #X ", Abnormal termination.\n", 0); \
    }                                                           \
}

#else

#define DfsDbgTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#define DebugUnwind(X)                   {NOTHING;}

#endif // DBG


//+---------------------------------------------------------------------------
// Macro:       BugCheck, public
//
// Synopsis:    Call DfsBugCheck with invoker's file and line numbers
//
// Arguments:   [Msg] -- Optional Message to be printed for debug
//                      builds
//
// Returns:     None
//
//----------------------------------------------------------------------------

#if DBG

VOID DfsBugCheck(CHAR *pszmsg, CHAR *pszfile, ULONG line);

#define BugCheck(sz)    DfsBugCheck(sz, __FILE__, __LINE__)

#else

VOID DfsBugCheck(VOID);

#define BugCheck(sz)    DfsBugCheck()

#endif

#endif // _DFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsmrshl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       dfsmrshl.c
//
//  Contents:   Routines to handle marshalling of data structures. This file
//              has been specifically created so that user level code can
//              avail of the marshalling code simply by including this file.
//
//  Classes:
//
//  Functions:
//
//  History:    March 29, 1994          Milans created from PeterCo's routines
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"

#define Dbg              (DEBUG_TRACE_RTL)

#else // !KERNEL_MODE

#include "dfsmrshl.h"

#ifndef ExRaiseStatus
#define ExRaiseStatus(x)        RtlRaiseStatus(x)
#endif // ExRaiseStatus

#ifndef try_return
#define try_return(s)           {s; goto try_exit;}
#endif // try_return

#ifndef DfsDbgTrace
#define DfsDbgTrace(i,l,f,s)
#endif // DfsDbgTrace

#endif // KERNEL_MODE



NTSTATUS
DfsRtlGetpwString(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    OUT    PWSTR                *ppwszString
);

NTSTATUS
DfsRtlPutpwString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PWSTR       *ppwszString
);

NTSTATUS
DfsRtlGetString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
);

NTSTATUS
DfsRtlPutString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
);

NTSTATUS
DfsRtlGetArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray);

NTSTATUS
DfsRtlPutArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsRtlGetpwString )
#pragma alloc_text( PAGE, DfsRtlPutpwString )
#pragma alloc_text( PAGE, DfsRtlGetString )
#pragma alloc_text( PAGE, DfsRtlPutString )
#pragma alloc_text( PAGE, DfsRtlGetArrayUchar )
#pragma alloc_text( PAGE, DfsRtlPutArrayUchar )
#pragma alloc_text( PAGE, DfsRtlGet )
#pragma alloc_text( PAGE, DfsRtlPut )
#pragma alloc_text( PAGE, DfsRtlSize )
#pragma alloc_text( PAGE, DfsRtlUnwindGet )

#endif //ALLOC_PRAGMA

#define UNREFERENCED_LABEL(label)\
    if(0) goto label;

//
// Defines and functions for unmarshalling base types.
// Regarding the BYTE macros below we dont care whether we are on
// LITTLE ENDIAN or BIG ENDIAN. It just does not matter.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define DfsRtlGetUchar(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 1 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (UCHAR)((MarshalBuffer)->Current[0]     ),          \
        (MarshalBuffer)->Current += 1,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUchar(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 1 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current += 1,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (USHORT)((MarshalBuffer)->Current[0]     ) |        \
                            ((MarshalBuffer)->Current[1] << 8),         \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (ULONG) ((MarshalBuffer)->Current[0]      ) |       \
                            ((MarshalBuffer)->Current[1] <<  8) |       \
                            ((MarshalBuffer)->Current[2] << 16) |       \
                            ((MarshalBuffer)->Current[3] << 24),        \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current[2] = BYTE_2(*pValue),                  \
        (MarshalBuffer)->Current[3] = BYTE_3(*pValue),                  \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (pValue)->Data1 = (ULONG) ((MarshalBuffer)->Current[0]      ) | \
                                  ((MarshalBuffer)->Current[1] <<  8) | \
                                  ((MarshalBuffer)->Current[2] << 16) | \
                                  ((MarshalBuffer)->Current[3] << 24) , \
        (pValue)->Data2 = (USHORT)((MarshalBuffer)->Current[4]      ) | \
                                  ((MarshalBuffer)->Current[5] <<  8) , \
        (pValue)->Data3 = (USHORT)((MarshalBuffer)->Current[6]      ) | \
                                  ((MarshalBuffer)->Current[7] <<  8) , \
        memcpy((pValue)->Data4, &(MarshalBuffer)->Current[8], 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (MarshalBuffer)->Current[0] = BYTE_0((pValue)->Data1),          \
        (MarshalBuffer)->Current[1] = BYTE_1((pValue)->Data1),          \
        (MarshalBuffer)->Current[2] = BYTE_2((pValue)->Data1),          \
        (MarshalBuffer)->Current[3] = BYTE_3((pValue)->Data1),          \
        (MarshalBuffer)->Current[4] = BYTE_0((pValue)->Data2),          \
        (MarshalBuffer)->Current[5] = BYTE_1((pValue)->Data2),          \
        (MarshalBuffer)->Current[6] = BYTE_0((pValue)->Data3),          \
        (MarshalBuffer)->Current[7] = BYTE_1((pValue)->Data3),          \
        memcpy(&(MarshalBuffer)->Current[8], (pValue)->Data4, 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )



#define DfsRtlSizeString(pString, pSize) (                              \
    ((pString)->Length > 0) ? (                                         \
        ((pString)->Buffer != NULL) ?                                   \
            (*(pSize)) += (2 + (pString)->Length),                      \
            STATUS_SUCCESS                                              \
        :   STATUS_DATA_ERROR                                           \
        )                                                               \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizepwString(pString, pSize) (                            \
        (*pString != NULL) ?                                            \
            (*(pSize)) += ((1 + wcslen(*pString))*sizeof(WCHAR)),       \
            STATUS_SUCCESS                                              \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizeUnicodeString(pUnicodeString, pSize)                  \
    DfsRtlSizeString(pUnicodeString, pSize)

#define DfsRtlUnwindStringGet(s) {                                      \
    if((s)->Length != 0 && (s)->Buffer != NULL) {                       \
        MarshalBufferFree((s)->Buffer);                                 \
        (s)->Buffer = NULL;                                             \
        (s)->Length = 0;                                                \
    }                                                                   \
}

#define DfsRtlUnwindUnicodeStringGet(s)                                 \
    DfsRtlUnwindStringGet(s)


NTSTATUS
DfsRtlGetArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray)
{
    NTSTATUS    status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetArrayUchar: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(pArray));

    try {
        UNREFERENCED_LABEL(try_exit);
        if (MarshalBuffer->Current + cbArray <= MarshalBuffer->Last) {
            memcpy(pArray, MarshalBuffer->Current, cbArray);
            MarshalBuffer->Current += cbArray;
        } else {
            status = STATUS_DATA_ERROR;
        }
    try_exit: NOTHING;
    } finally {
        if (AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetArrayUchar - Abnormal termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

    }

    DfsDbgTrace(-1, Dbg, "DfsRtlGetArrayUchar: Exited %08lx\n", ULongToPtr(status));
    return(status);
}

NTSTATUS
DfsRtlPutArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray)
{
    NTSTATUS    status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetArrayUchar: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(pArray));

    try {
        UNREFERENCED_LABEL(try_exit);
        if (MarshalBuffer->Current + cbArray <= MarshalBuffer->Last) {
            if (cbArray) {
                memcpy(MarshalBuffer->Current, pArray, cbArray);
                MarshalBuffer->Current += cbArray;
            }
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    try_exit: NOTHING;
    } finally {
        if (AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutArrayUchar - Abnormal termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

    }

    DfsDbgTrace(-1, Dbg, "DfsRtlPutArrayUchar: Exited %08lx\n", ULongToPtr(status));
    return(status);
}


NTSTATUS
DfsRtlGetpwString(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    OUT    PWSTR                *ppwszString
)
{
    USHORT size;
    PCHAR cp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetpwString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(ppwszString));

    try {
        UNREFERENCED_LABEL(try_exit);
        *ppwszString = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((cp = MarshalBufferAllocate(size+sizeof(WCHAR))) != NULL) {
                        memcpy(cp, MarshalBuffer->Current, size);
                        *((WCHAR *) (cp + size)) = UNICODE_NULL;
                        *ppwszString = (PWCHAR) cp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetpwString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && cp)
                MarshalBufferFree(cp);
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlGetpwString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}


NTSTATUS
DfsRtlPutpwString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PWSTR       *ppwszString
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPutpwString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(ppwszString));


    try {
        UNREFERENCED_LABEL(try_exit);
        if (*ppwszString != NULL)
            size = wcslen(*ppwszString)*sizeof(WCHAR);
        else
            size = 0;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    memcpy(MarshalBuffer->Current, *ppwszString, size);
                    MarshalBuffer->Current += size;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlPutString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



NTSTATUS
DfsRtlGetString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
)
{
    USHORT size;
    PCHAR cp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(String));

    try {
        UNREFERENCED_LABEL(try_exit);
        String->Length = String->MaximumLength = 0;
        String->Buffer = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((cp = MarshalBufferAllocate(size+sizeof(WCHAR))) != NULL) {
                        RtlZeroMemory(cp, size+sizeof(WCHAR));
                        memcpy(cp, MarshalBuffer->Current, size);
                        String->Length = size;
                        String->MaximumLength = size + sizeof(WCHAR);
                        String->Buffer = cp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && cp)
                MarshalBufferFree(cp);
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlGetString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



NTSTATUS
DfsRtlPutString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPutString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(String));


    try {
        UNREFERENCED_LABEL(try_exit);
        size = String->Length;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    if(String->Buffer != NULL) {
                        memcpy(MarshalBuffer->Current, String->Buffer, size);
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_DATA_ERROR;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlPutString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



#ifdef  NOT_NEEDED

NTSTATUS
DfsRtlGetUnicodeString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PUNICODE_STRING UnicodeString
)
{
    USHORT size;
    PWCHAR wcp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetUnicodeString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(UnicodeString));

    try {
        UnicodeString->Length = UnicodeString->MaximumLength = 0;
        UnicodeString->Buffer = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((wcp = (MarshalBufferAllocate)(size+sizeof(WCHAR))) != NULL) {
                        memcpy(wcp, MarshalBuffer->Current, size);
                        wcp[size/sizeof(WCHAR)] = UNICODE_NULL;
                        UnicodeString->Length = size;
                        UnicodeString->MaximumLength = size + sizeof(WCHAR);
                        UnicodeString->Buffer = wcp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetUnicodeString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && wcp)
                MarshalBufferFree(wcp);
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlGetUnicodeString:  Exit -> %08lx\n",
                status);
    return status;
}



NTSTATUS
DfsRtlPutUnicodeString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PUNICODE_STRING UnicodeString
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPutUnicodeString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(UnicodeString));

    try {
        size = UnicodeString->Length;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    if(UnicodeString->Buffer != NULL) {
                        memcpy(
                            MarshalBuffer->Current,
                            UnicodeString->Buffer,
                            size
                        );
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_DATA_ERROR;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutUnicodeString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlPutUnicodeString:  Exit -> %08lx\n",
                status);
    return status;
}

#else   // NOT_NEEDED

#define DfsRtlGetUnicodeString(b, s)\
    DfsRtlGetString(b, (PSTRING)(s))

#define DfsRtlPutUnicodeString(b, s)\
    DfsRtlPutString(b, (PSTRING)(s))

#endif  // NOT_NEEDED





NTSTATUS
DfsRtlGet(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    ULONG unwindcnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGet:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));

    try {

        RtlZeroMemory(Item, MarshalInfo->_size);

        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                //
                // If this compound type is a conformant structure, then
                // we need to adjust the size field here.
                //
                if (subInfo->_typecnt > 0 &&
                      subInfo->_typeInfo[0]._type == MTYPE_CONFORMANT_CNT) {
                   MARSHAL_BUFFER tempMarshalBuffer = *MarshalBuffer;
                   ULONG extraSize = 0;

                   status = DfsRtlGetUlong(&tempMarshalBuffer, &extraSize);
                   if (!NT_SUCCESS(status) || (itemSize + extraSize) < itemSize) {
                      try_return(status = STATUS_DATA_ERROR);
                   }
                   itemSize += extraSize;
                }
                break;
            case MTYPE_CONFORMANT_CNT:
                itemSize = 0;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWSTR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else if (typeInfo->_type & MTYPE_STATIC_ARRAY) {
                cnt = typeInfo->_cntoff;
            } else {
                cnt = 1;
            }

            if(typeInfo->_type & MTYPE_INDIRECT) {
                if((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0)
                    subItem = NULL;
                else {
                    subItem = NULL;
                    if ((cnt != 0) && ((itemSize * cnt) / cnt) == itemSize)
                        subItem = MarshalBufferAllocate(itemSize * cnt);
                    if(subItem == NULL)
                        try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }
                *(PVOID *)((PUCHAR)Item + typeInfo->_off) = subItem;
            }
            else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlGet(
                        MarshalBuffer,
                        subInfo,
                        subItem
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    //
                    // this field is used only when sizing a conformant
                    // structure. As such, there is no place to unmarshal
                    // it into. So, simply eat the ulong.
                    //
                    status = DfsRtlGetUlong(MarshalBuffer, &itemSize);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while(cnt--) {
                        status = DfsRtlGet(
                            MarshalBuffer,
                            subInfo,
                            subItemElem
                        );
                        if(!NT_SUCCESS(status)) {
                            while((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                DfsRtlUnwindGet(
                                    subInfo,
                                    &subInfo->_typeInfo[subInfo->_typecnt],
                                    subItemElem
                                );
                            }
                            if(typeInfo->_type & MTYPE_INDIRECT)
                                MarshalBufferFree(subItem);
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    status = DfsRtlGetGuid(
                        MarshalBuffer,
                        (GUID *)subItem
                    );
                    break;
            case MTYPE_STRING:
                    status = DfsRtlGetString(
                        MarshalBuffer,
                        (PSTRING)subItem
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlGetUnicodeString(
                        MarshalBuffer,
                        (PUNICODE_STRING)subItem
                    );
                    break;

            case MTYPE_PWSTR:
                    status = DfsRtlGetpwString(
                        MarshalBuffer,
                        (PWSTR *)subItem
                    );
                    break;

            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while (cnt--) {
                        status = DfsRtlGetpwString(
                            MarshalBuffer,
                            (PWSTR *)subItemElem);
                        if (!NT_SUCCESS(status)) {
                            while ((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                MarshalBufferFree((PVOID)*(PWSTR *)subItemElem);
                            }
                            if (typeInfo->_type & MTYPE_INDIRECT) {
                                MarshalBufferFree(subItem);
                            }
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while(cnt--) {
                        status = DfsRtlGetUnicodeString(
                            MarshalBuffer,
                            (PUNICODE_STRING)subItemElem
                        );
                        if(!NT_SUCCESS(status)) {
                            while((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                DfsRtlUnwindUnicodeStringGet(
                                    (PUNICODE_STRING)subItemElem
                                );
                            }
                            if(typeInfo->_type & MTYPE_INDIRECT)
                                MarshalBufferFree(subItem);
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    status = DfsRtlGetUlong(
                        MarshalBuffer,
                        (PULONG)subItem
                    );
                    break;
            case MTYPE_USHORT:
                    status = DfsRtlGetUshort(
                        MarshalBuffer,
                        (PUSHORT)subItem);
                    break;
            case MTYPE_UCHAR:
                    status = DfsRtlGetUchar(
                        MarshalBuffer,
                        (PUCHAR)subItem);
                    break;
            case MTYPE_UCHAR|MTYPE_COUNTED_ARRAY:
            case MTYPE_UCHAR|MTYPE_STATIC_ARRAY:
                    status = DfsRtlGetArrayUchar(
                        MarshalBuffer,
                        cnt,
                        (PUCHAR)subItem);
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                    break;
            };
            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg, "DfsRtlGet:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status))
            DfsRtlUnwindGet(MarshalInfo, typeInfo, Item);
    }

    DfsDbgTrace(-1, Dbg, "DfsRtlGet:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



NTSTATUS
DfsRtlPut(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPut:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));

    try {
        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                break;
            case MTYPE_CONFORMANT_CNT:
                itemSize = typeInfo->_off;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWSTR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY ||
               typeInfo->_type == MTYPE_CONFORMANT_CNT) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else
                cnt = typeInfo->_cntoff;

            if(typeInfo->_type & MTYPE_INDIRECT) {
                subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
                if(subItem == NULL &&
                   !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                    try_return(status = STATUS_DATA_ERROR);
            } else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlPut(
                        MarshalBuffer,
                        subInfo,
                        subItem
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    cnt *= itemSize;
                    status = DfsRtlPutUlong(
                                MarshalBuffer,
                                &cnt);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    //
                    // No sense in having an array of conformant structures
                    // ASSERT this fact
                    //

                    ASSERT(subInfo->_typecnt == 0
                                    ||
                           subInfo->_typeInfo[0]._type != MTYPE_CONFORMANT_CNT
                          );

                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlPut(
                            MarshalBuffer,
                            subInfo,
                            subItemElem
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    status = DfsRtlPutGuid(
                        MarshalBuffer,
                        (GUID *)subItem
                    );
                    break;
            case MTYPE_STRING:
                    status = DfsRtlPutString(
                        MarshalBuffer,
                        (PSTRING)subItem
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlPutUnicodeString(
                        MarshalBuffer,
                        (PUNICODE_STRING)subItem
                    );
                    break;
            case MTYPE_PWSTR:
                    status = DfsRtlPutpwString(
                        MarshalBuffer,
                        (PWSTR *)subItem
                    );
                    break;

            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PWSTR *)subItem;
                    while(cnt--) {
                        status = DfsRtlPutpwString(
                            MarshalBuffer,
                            (PWSTR *)subItemElem);
                        if (!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlPutUnicodeString(
                            MarshalBuffer,
                            (PUNICODE_STRING)subItemElem
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    status = DfsRtlPutUlong(
                        MarshalBuffer,
                        (PULONG)subItem
                    );
                    break;
            case MTYPE_USHORT:
                    status = DfsRtlPutUshort(
                        MarshalBuffer,
                        (PUSHORT)subItem);
                    break;
            case MTYPE_UCHAR:
                    status = DfsRtlPutUchar(
                        MarshalBuffer,
                        (PUCHAR)subItem);
                    break;
            case (MTYPE_UCHAR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UCHAR|MTYPE_STATIC_ARRAY):
                    status = DfsRtlPutArrayUchar(
                        MarshalBuffer,
                        cnt,
                        (PUCHAR)subItem);
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                break;
            }

            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg, "DfsRtlPut:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }

    DfsDbgTrace(-1, Dbg, "DfsRtlPut:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}




NTSTATUS
DfsRtlSize(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PVOID Item,
    OUT PULONG Size
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlSize:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));
    ASSERT(ARGUMENT_PRESENT(Size));

    try {
        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                break;
            case MTYPE_CONFORMANT_CNT:
                //
                // For conformant structures, _offset is sizeof each
                // element, _cntsize is sizeof cnt field, and _cntoff is
                // offset of cnt field.
                //
                itemSize = typeInfo->_off;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWCHAR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY ||
               typeInfo->_type == MTYPE_CONFORMANT_CNT) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else
                cnt = typeInfo->_cntoff;

            if(typeInfo->_type & MTYPE_INDIRECT) {
                subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
                if(subItem == NULL &&
                   !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                    try_return(status = STATUS_DATA_ERROR);
            } else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlSize(
                        subInfo,
                        subItem,
                        Size
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    (*Size) += sizeof(ULONG);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    //
                    // No sense in having an array of conformant structures
                    // ASSERT this fact
                    //

                    ASSERT(subInfo->_typecnt == 0
                                    ||
                           subInfo->_typeInfo[0]._type != MTYPE_CONFORMANT_CNT
                          );

                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlSize(
                            subInfo,
                            subItemElem,
                            Size
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    (*Size) += 16;
                    break;
            case MTYPE_STRING:
                    status = DfsRtlSizeString(
                        (PSTRING)subItem,
                        Size
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlSizeUnicodeString(
                        (PUNICODE_STRING)subItem,
                        Size
                    );
                    break;

            case MTYPE_PWSTR:
                    status = DfsRtlSizepwString(
                        (PWSTR *)subItem,
                        Size
                    );
                    break;
            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while (cnt--) {
                        status = DfsRtlSizepwString(
                            (PWSTR *)subItemElem,
                            Size);
                        if (!NT_SUCCESS(status)) {
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlSizeUnicodeString(
                            (PUNICODE_STRING)subItemElem,
                            Size
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    (*Size) += 4;
                    break;
            case MTYPE_USHORT:
                    (*Size) += 2;
                    break;
            case MTYPE_UCHAR:
                    (*Size) += 1;
                    break;
            case MTYPE_UCHAR|MTYPE_COUNTED_ARRAY:
            case MTYPE_UCHAR|MTYPE_STATIC_ARRAY:
                    (*Size) += (cnt * sizeof(UCHAR));
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                    break;
            };
            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg, "DfsRtlSize:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }

    DfsDbgTrace(0, Dbg, "DfsRtlSize:  (*Size) = %ld\n", ULongToPtr(*Size));
    DfsDbgTrace(-1, Dbg, "DfsRtlSize:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}




VOID
DfsRtlUnwindGet(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PMARSHAL_TYPE_INFO LastTypeInfo,
    IN  PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlUnwindGet:  Entered\n", 0);

    for(typeInfo = &MarshalInfo->_typeInfo[0];
        typeInfo < LastTypeInfo;
        typeInfo++) {

        switch(typeInfo->_type & MTYPE_BASE_TYPE) {
        case MTYPE_COMPOUND:
            subInfo = typeInfo->_subinfo;
            itemSize = subInfo->_size;
            break;
        case MTYPE_GUID:
            itemSize = sizeof(GUID);
            break;
        case MTYPE_STRING:
            itemSize = sizeof(STRING);
            break;
        case MTYPE_UNICODE_STRING:
            itemSize = sizeof(UNICODE_STRING);
            break;
        case MTYPE_ULONG:
            itemSize = sizeof(ULONG);
            break;
        case MTYPE_USHORT:
            itemSize = sizeof(USHORT);
            break;
        case MTYPE_UCHAR:
            itemSize = sizeof(UCHAR);
            break;
        default:
            ExRaiseStatus(STATUS_DATA_ERROR);
        }

        if(typeInfo->_type & MTYPE_COUNTED_ARRAY) {
            cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
            switch(typeInfo->_cntsize) {
            case sizeof(UCHAR):
                cnt = *(PUCHAR)cntptr;
                break;
            case sizeof(USHORT):
                cnt = *(PUSHORT)cntptr;
                break;
            case sizeof(ULONG):
                cnt = *(PULONG)cntptr;
                break;
            default:
                ExRaiseStatus(STATUS_DATA_ERROR);
            }
        } else
            cnt = typeInfo->_cntoff;

        if(typeInfo->_type & MTYPE_INDIRECT) {
            subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
            if(subItem == NULL &&
               !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                ExRaiseStatus(STATUS_DATA_ERROR);
        } else
            subItem = ((PUCHAR)Item + typeInfo->_off);

        switch(typeInfo->_type & ~MTYPE_INDIRECT) {

        case MTYPE_COMPOUND:
                DfsRtlUnwindGet(
                    subInfo,
                    &subInfo->_typeInfo[subInfo->_typecnt],
                    subItem
                );
                break;
        case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
        case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                subItemElem = (PUCHAR)subItem;
                while(cnt--) {
                    DfsRtlUnwindGet(
                        subInfo,
                        &subInfo->_typeInfo[subInfo->_typecnt],
                        subItemElem
                    );
                    ((PUCHAR)subItemElem) += itemSize;
                }
                break;
        case MTYPE_STRING:
                DfsRtlUnwindStringGet((PSTRING)subItem);
                break;
        case MTYPE_UNICODE_STRING:
                DfsRtlUnwindUnicodeStringGet((PUNICODE_STRING)subItem);
                break;
        case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
        case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                subItemElem = (PUCHAR)subItem;
                while(cnt--) {
                    DfsRtlUnwindUnicodeStringGet((PUNICODE_STRING)subItemElem);
                    ((PUCHAR)subItemElem) += itemSize;
                }
                break;
        case MTYPE_GUID:
        case MTYPE_ULONG:
        case MTYPE_USHORT:
        case MTYPE_UCHAR:
                break;
        default:
                ExRaiseStatus(STATUS_DATA_ERROR);
        };

        if(typeInfo->_type & MTYPE_INDIRECT) {
            MarshalBufferFree(subItem);
            *(PUCHAR *)((PUCHAR)Item + typeInfo->_off) = NULL;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlUnwindGet:  Exit -> VOID\n", 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsprocs.h ===
//+----------------------------------------------------------------------------
//
//  File:   DFSPROCS.H
//
//  Contents:
//  This module defines all of the globally used procedures in the Dsfs
//  file system.
//
//  Functions:
//
//  History:    12 Nov 1991 AlanW   Created from CDFS souce.
//              8  May 1992 PeterCo Removed References to EPs
//                                  Added stuff to support PKT (M000)
//-----------------------------------------------------------------------------


#ifndef _DFSPROCS_
#define _DFSPROCS_

//
// "System" include files
//
#if defined (MUPKD)
#include <ntos.h>
#include <string.h>
#include <fsrtl.h>

#else
#include <ntifs.h>
#include <ntddser.h>

#endif

#include <windef.h>
#include <tdi.h>
#include <wincred.h>

#include <ntddnfs.h>                             // For communicating with
                                                 // the SMB Rdr
#include <ntddmup.h>                             // For UNC registration


#include <winnetwk.h>                            // For NETRESOURCE def'n

#include <dfsfsctl.h>                            // Dfs FsControl Codes.

#include <lmdfs.h>                               // DFS_INFO_X

#include "dfserr.h"
#include "dfsstr.h"
#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"
#include "pkt.h"
#include "dfsstruc.h"
#include "dfsdata.h"
#include "log.h"

#ifndef i386

#define DFS_UNALIGNED   UNALIGNED

#else

#define DFS_UNALIGNED

#endif // MIPS

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );

//
//  The driver entry routine
//

NTSTATUS
DfsDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

VOID
DfsUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//
//  The following routine is used to create and initialIze logical root
//  device objects, implemented in dsinit.c
//

#ifdef TERMSRV

NTSTATUS
DfsInitializeLogicalRoot (
    IN LPCWSTR Name,
    IN PUNICODE_STRING Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT VcbFlags OPTIONAL,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

NTSTATUS
DfsDeleteLogicalRoot (
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

BOOLEAN
DfsLogicalRootExists(
    IN PWSTR pwszName,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

NTSTATUS
DfsInitializeDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN ULONG SessionID,
    IN PLUID LogonID
);

NTSTATUS
DfsDeleteDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN ULONG SessionID,
    IN PLUID LogonID
);

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Name,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt
    );

#else // TERMSRV

NTSTATUS
DfsInitializeLogicalRoot (
    IN LPCWSTR Name,
    IN PUNICODE_STRING Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT VcbFlags OPTIONAL,
    IN PLUID LogonID
);

NTSTATUS
DfsDeleteLogicalRoot (
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN PLUID LogonID
);

BOOLEAN
DfsLogicalRootExists(
    PWSTR       pwszName,
    IN PLUID LogonID
);

NTSTATUS
DfsInitializeDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PLUID LogonID
);

NTSTATUS
DfsDeleteDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN PLUID LogonID
);

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Name,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt
    );

#endif // TERMSRV


NTSTATUS
DfspLogRootNameToPath(
    LPCWSTR         Name,
    PUNICODE_STRING RootName
);


NTSTATUS
DfsGetResourceFromVcb(
    PIRP                pIrp,
    PDFS_VCB            Vcb,
    PUNICODE_STRING     ProviderName,
    PUCHAR              BufBegin,
    PUCHAR              Buf,
    PULONG              BufSize,
    PULONG              pResourceSize
);

NTSTATUS
DfsGetResourceFromDevlessRoot(
    PIRP                pIrp,
    PDFS_DEVLESS_ROOT   Drt,
    PUNICODE_STRING     ProviderName,
    PUCHAR              BufBegin,
    PUCHAR              Buf,
    PULONG              BufSize,
    PULONG              pResourceSize
);

//
//  The following routines are used to manipulate the fcb associated with
//  each opened file object, implemented in FilObSup.c
//

typedef enum _TYPE_OF_OPEN {
    UnopenedFileObject = 1,
    FilesystemDeviceOpen,
    LogicalRootDeviceOpen,
    RedirectedFileOpen,
    UserVolumeOpen,
    UnknownOpen,
} TYPE_OF_OPEN;

VOID
DfsSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcb
);

TYPE_OF_OPEN
DfsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PDFS_VCB *Vcb,
    OUT PDFS_FCB *Fcb
);



//
//  In-memory structure support routines, implemented in StrucSup.c
//

PIRP_CONTEXT
DfsCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
DfsDeleteIrpContext_Real (
    IN PIRP_CONTEXT IrpContext
    );

#if DBG
#define DfsDeleteIrpContext(IRPCONTEXT) {   \
    DfsDeleteIrpContext_Real((IRPCONTEXT)); \
    (IRPCONTEXT) = NULL;            \
}
#else
#define DfsDeleteIrpContext(IRPCONTEXT) {   \
    DfsDeleteIrpContext_Real((IRPCONTEXT)); \
}
#endif

VOID
DfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDFS_VCB Vcb,
    IN PUNICODE_STRING LogRootPrefix,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PDEVICE_OBJECT TargetDeviceObject
);

VOID
DfsInitializeDrt (
    IN OUT PDFS_DEVLESS_ROOT Drt,
    IN PUNICODE_STRING Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL
);


VOID
DfsDeleteVcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_VCB Vcb
);

#if DBG
#define DfsDeleteVcb(IRPCONTEXT,VCB) {    \
    DfsDeleteVcb_Real((IRPCONTEXT),(VCB)); \
    (VCB) = NULL;              \
}
#else
#define DfsDeleteVcb(IRPCONTEXT,VCB) {    \
    DfsDeleteVcb_Real((IRPCONTEXT),(VCB)); \
}
#endif


PDFS_FCB
DfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_VCB Vcb,
    IN PUNICODE_STRING FullName OPTIONAL
    );

VOID
DfsDeleteFcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB Fcb
    );

#if DBG
#define DfsDeleteFcb(IRPCONTEXT,FCB) {    \
    DfsDeleteFcb_Real((IRPCONTEXT),(FCB)); \
    (FCB) = NULL;              \
}
#else
#define DfsDeleteFcb(IRPCONTEXT,FCB) {    \
    DfsDeleteFcb_Real((IRPCONTEXT),(FCB)); \
}
#endif


//
//  Miscellaneous routines
//

VOID GuidToString(
    IN GUID   *pGuid,
    OUT PWSTR pwszGuid);

VOID StringToGuid(
    IN PWSTR pwszGuid,
    OUT GUID *pGuid);


#ifdef TERMSRV

NTSTATUS
DfsFindLogicalRoot(                 //  implemented in FsCtrl.c
    IN PUNICODE_STRING PrefixPath,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    );

#else // TERMSRV

NTSTATUS
DfsFindLogicalRoot(                 //  implemented in FsCtrl.c
    IN PUNICODE_STRING PrefixPath,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    );

#endif // TERMSRV

NTSTATUS
DfsInsertProvider(                  //  implemented in FsCtrl.c
    IN PUNICODE_STRING pustrProviderName,
    IN ULONG           fProvCapability,
    IN ULONG           eProviderId);

NTSTATUS                            //  implemented in provider.c
DfsGetProviderForDevice(
    IN PUNICODE_STRING DeviceName,
    PPROVIDER_DEF *Provider);

VOID
DfsAgePktEntries(
    IN PVOID DfsTimerContext
    );

NTSTATUS
DfsFsctrlIsThisADfsPath(
    IN PUNICODE_STRING filePath,
    IN BOOLEAN          CSCAgentCreate,
    OUT PUNICODE_STRING pathName);

NTSTATUS
PktFsctrlFlushCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
PktFsctrlFlushSpcCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
DfsFsctrlSetDCName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlSetDomainNameFlat(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlSetDomainNameDns(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
PktpSetActiveSpcService(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DcName,
    BOOLEAN ResetTimeout);

NTSTATUS
PktpUpdateSpecialTable(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DCName);


//
// Pass-through functions
//
NTSTATUS
DfsVolumePassThrough(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp
);

NTSTATUS
DfsCompleteVolumePassThrough(
    IN  PDEVICE_OBJECT pDevice,
    IN  PIRP Irp,
    IN  PVOID Context
);

NTSTATUS
DfsFilePassThrough(
    IN  PDFS_FCB pFcb,
    IN  PIRP Irp
);


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect a logical root device object; some will also work with a file
//  system device object), and a pointer to the IRP.  They either perform
//  the function at the FSD level or post the request to the FSP work
//  queue for FSP level processing.
//

NTSTATUS
DfsFsdCleanup (                 //  implemented in Close.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdClose (                   //  implemented in Close.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdCreate (                  //  implemented in Create.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdDeviceIoControl (         //  implemented in FsCtrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdDirectoryControl (            //  implemented in DirCtrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdQueryInformation (            //  implemented in FileInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdQueryInformation (            //  implemented in FileInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdSetInformation (              //  implemented in FileInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdFileSystemControl (           //  implemented in FsCtrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdSetVolumeInformation (            //  implemented in VolInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) ((BOOLEAN)(          \
    IoIsOperationSynchronous(IRP) ||             \
    DfsData.OurProcess == PsGetCurrentProcess())         \
)


//
//  Routine for posting an Irp to the FSP, implemented in fspdisp.c
//

NTSTATUS
DfsFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRPs from the work queue and calls the appropriate FSP level work routine.
//

VOID
DfsFspDispatch (                   //  implemented in FspDisp.c
    IN PVOID Context
    );

//
//  The following routines are the FSP work routines that are called
//  by the preceding DfsFsdDispath routine.  Each takes as input a pointer
//  to the IRP, performs the function, and returns.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

VOID
DfsFspClose (                   //  implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspQueryInformation (            //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspSetInformation (              //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspFileSystemControl (           //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspSetVolumeInformation (            //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following macro is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the IrpContext to be
//  null, however the only legal order to do this in is:
//
//  DfsCompleteRequest( NULL, Irp, Status );     // completes Irp & preserves context
//  ...
//  DfsCompleteRequest( IrpContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" IrpContext off to the
//  Fsp for post processing, such as read ahead.
//

VOID
DfsCompleteRequest_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#define DfsCompleteRequest(IRPCONTEXT,IRP,STATUS) { \
    DfsCompleteRequest_Real(IRPCONTEXT,IRP,STATUS); \
}



//
//  The following two macros are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in
//  the Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  DfsFsdXxx(...)
//  {
//  try {
//
//      ...
//
//  } except(DfsExceptionFilter("Xxx\n")) {
//
//      DfsProcessException( IrpContext, Irp, &Status );
//  }
//
//  Return Status;
//  }
//
//  LONG
//  DfsExceptionFilter (
//  IN PSZ String
//  );
//
//  VOID
//  DfsProcessException (
//  IN PIRP_CONTEXT IrpContext,
//  IN PIRP Irp,
//  IN PNTSTATUS ExceptionCode
//  );
//

LONG
DfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
DfsProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

NTSTATUS
DfsGetLogonId (
    IN PLUID Id
    );

//
//  VOID
//  DfsRaiseStatus (
//  IN PRIP_CONTEXT IrpContext,
//  IN NT_STATUS Status
//  );
//
//

#define DfsRaiseStatus(IRPCONTEXT,STATUS) {    \
    (IRPCONTEXT)->ExceptionStatus = (STATUS); \
    ExRaiseStatus( (STATUS) );            \
    BugCheck( "DfsRaiseStatus "  #STATUS );       \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//  try {
//      :
//      :
//
//  try_exit: NOTHING;
//  } finally {
//
//      :
//      :
//  }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//  #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//  #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }


#ifdef TERMSRV

NTSTATUS
TSGetRequestorSessionId(
    IN PIRP pIrp,
    OUT PULONG pulSessionId
    );

#endif // TERMSRV

#endif // _DFSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dnr.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dnr.c
//
//  Contents:   Distributed name resolution process and control
//
//  Functions:  DnrStartNameResolution -- Start a name resolution
//              DnrNameResolve -- Main loop for DNR
//              DnrComposeFileName -- Canonicalize file name
//              DnrCaptureCredentials -- Capture user-defined creds for Dnr
//              DnrReleaseCredentials -- Dual of DnrCaptureCredentials
//              DnrRedirectFileOpen -- Redirect a create IRP to some provider
//              DnrPostProcessFileOpen -- Resume after return from redirect
//              DnrGetAuthenticatedConnection -- Using Dnr credentials
//              DnrReleaseAuthenticatedConnection -- returned by above func
//              DfsBuildConnectionRequest -- Builds name of server IPC$ share
//              DfsFreeConnectionRequest -- Free resources allocated above
//              DfsCreateConnection -- Create a connection to a server IPC$
//              DfsCloseConnection -- Close connection opened above
//              DnrBuildReferralRequest -- Build Irp for referral request
//              DnrInsertReferralAndResume -- Resume DNR after referral
//              DnrCompleteReferral -- DPC to process a referral response
//              DnrCompleteFileOpen -- DPC to process a file open completion
//              DnrBuildFsControlRequest -- Create an IRP for an Fsctrl
//              AllocateDnrContext -- Allocate a context record for DNR
//              DeallocateDnrContext -- Free context record
//              DnrConcatenateFilePath -- Construct path with backslashes etc
//              DnrLocateDC -- Locate the server for a Dfs root
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include <smbtypes.h>
#include <smbtrans.h>
#include "fsctrl.h"
#include "fcbsup.h"
#include "dnr.h"
#include "creds.h"
#include "know.h"
#include "mupwml.h"

#include <netevent.h>

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DNR)

//
//  Local function prototypes
//


#define DNR_SET_TARGET_INFO(_DnrC, _Entry)   \
   if (((_DnrC)->pDfsTargetInfo == NULL) && (_Entry != NULL)) {\
      (_DnrC)->pDfsTargetInfo = (_Entry)->pDfsTargetInfo; \
      if ((_DnrC)->pDfsTargetInfo != NULL) {                        \
           PktAcquireTargetInfo( (_DnrC)->pDfsTargetInfo);          \
      }                                                             \
   }                                                             


PDNR_CONTEXT
AllocateDnrContext(
    IN ULONG    cbExtra
);

#define DeallocateDnrContext(pNRC)      ExFreePool(pNRC);

VOID
DnrRebuildDnrContext(
    IN PDNR_CONTEXT DnrContext,
    IN PUNICODE_STRING NewDfsPrefix,
    IN PUNICODE_STRING RemainingPath);

VOID
DnrCaptureCredentials(
    IN PDNR_CONTEXT DnrContext);

VOID
DnrReleaseCredentials(
    IN PDNR_CONTEXT DnrContext);

NTSTATUS
DnrGetAuthenticatedConnection(
    IN OUT PDNR_CONTEXT DnrContext);

VOID
DnrReleaseAuthenticatedConnection(
    IN OUT PDNR_CONTEXT DnrContext);

NTSTATUS
DfsBuildConnectionRequest(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    OUT PUNICODE_STRING pShareName);

VOID
DfsFreeConnectionRequest(
    IN OUT PUNICODE_STRING pShareName);

NTSTATUS
DnrRedirectFileOpen (
    IN    PDNR_CONTEXT DnrContext
);

NTSTATUS
DnrPostProcessFileOpen(
    IN    PDNR_CONTEXT DnrContext
);

VOID
DnrInsertReferralAndResume(
    IN    PVOID Context);

VOID
DnrLocateDC(
    IN PUNICODE_STRING FileName);

NTSTATUS
DnrCompleteReferral(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
DnrCompleteFileOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
);

PIRP
DnrBuildReferralRequest(
    IN PDNR_CONTEXT pDnrContext
);

VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry
);


VOID
MupInvalidatePrefixTable(
   VOID			 
);
NTSTATUS
DnrGetTargetInfo( 
    PDNR_CONTEXT pDnrContext);

#define DFS_REFERENCE_OBJECT(d) \
    ObReferenceObjectByPointer(d,0,NULL,KernelMode);

#define DFS_DEREFERENCE_OBJECT(d) \
    ObDereferenceObject((PVOID)(d));

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DnrStartNameResolution )
#pragma alloc_text( PAGE, DnrNameResolve )
#pragma alloc_text( PAGE, DnrComposeFileName )
#pragma alloc_text( PAGE, DnrCaptureCredentials )
#pragma alloc_text( PAGE, DnrReleaseCredentials )
#pragma alloc_text( PAGE, DnrGetAuthenticatedConnection )
#pragma alloc_text( PAGE, DnrReleaseAuthenticatedConnection )
#pragma alloc_text( PAGE, DnrRedirectFileOpen )
#pragma alloc_text( PAGE, DnrPostProcessFileOpen )
#pragma alloc_text( PAGE, DfsBuildConnectionRequest )
#pragma alloc_text( PAGE, DfsFreeConnectionRequest )
#pragma alloc_text( PAGE, DnrBuildReferralRequest )
#pragma alloc_text( PAGE, DfsCreateConnection )
#pragma alloc_text( PAGE, DfsCloseConnection )
#pragma alloc_text( PAGE, DnrBuildFsControlRequest )
#pragma alloc_text( PAGE, DnrInsertReferralAndResume )
#pragma alloc_text( PAGE, DnrLocateDC )
#pragma alloc_text( PAGE, AllocateDnrContext )
#pragma alloc_text( PAGE, DnrRebuildDnrContext )
#pragma alloc_text( PAGE, DnrConcatenateFilePath )
#pragma alloc_text( PAGE, DfspGetOfflineEntry)
#pragma alloc_text( PAGE, DfspMarkServerOnline)
#pragma alloc_text( PAGE, DfspMarkServerOffline)
#pragma alloc_text( PAGE, DfspIsRootOnline)

//
// The following are not pageable since they can be called at DPC level
//
// DnrCompleteReferral
// DnrCompleteFileOpen
//

#endif

//+-------------------------------------------------------------------
//
//  Function:   DfsIsShareNull
//
//  Synopsis:   Is this name of the form "\server\"?
//
//  Arguments:  [FileName] - pointer to the UNICODE_STRING we are checking
//
//  Returns:    TRUE if FileName is "\server\", FALSE otherwise
//
//--------------------------------------------------------------------

BOOLEAN
DfsIsShareNull(PUNICODE_STRING FileName)
{
    USHORT RootEnd = 0;
    USHORT ShareEnd = 0;
    BOOLEAN result = FALSE;
    USHORT Length = 0;
    

    // find the first '\' 
    // we start at 1 because the first character is also '\'
    for (RootEnd = 1;
	    RootEnd < FileName->Length/sizeof(WCHAR) &&
		FileName->Buffer[RootEnd] != UNICODE_PATH_SEP;
		    RootEnd++) {

	NOTHING;

    }

    // now FileName->Buffer[RootEnd] == '\' and we are beyond the root part of the name
    // find the end of the share part.
    for (ShareEnd = RootEnd+1;
	    ShareEnd < FileName->Length/sizeof(WCHAR) &&
		FileName->Buffer[ShareEnd] != UNICODE_PATH_SEP;
			ShareEnd++) {

	 NOTHING;

    }

    // the length of the share name is ShareEnd - RootEnd - 1
    // the -1 is becasue we have actually stepped one char beyond the 
    // share name's end
    // For example: 	\root\share\link	RootEnd=5, ShareEnd=11
    //			\root\share             RootEnd=5, ShareEnd=11
    //			\root\			RootEnd=5, ShareEnd=6
    Length = (USHORT) (ShareEnd - RootEnd - 1) * sizeof(WCHAR);

    if(Length == 0) {
	result = TRUE;
    } else {
	result = FALSE;
    }

    return result;
}



NTSTATUS
DfsRerouteOpenToMup(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING FileName)
{

    UNICODE_STRING NewName;
    ULONG nameLength;
    NTSTATUS status;

    nameLength = sizeof(DD_MUP_DEVICE_NAME ) + FileName->Length + sizeof(WCHAR);
    if (nameLength > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, DfsRerouteOpenToMup_Error_NameTooLong, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject));
        return status;
    }

    NewName.Buffer = ExAllocatePoolWithTag(
                         PagedPool,
                         nameLength,			  
                         ' puM');

    if ( NewName.Buffer ==  NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NewName.MaximumLength = (USHORT)nameLength;
    NewName.Length = 0;

    RtlAppendUnicodeToString(&NewName, DD_MUP_DEVICE_NAME);
    RtlAppendUnicodeStringToString(&NewName, FileName);

    if (MupVerbose) {
      DbgPrint("Newname %wZ\n", &NewName);
    }

    ExFreePool(FileObject->FileName.Buffer);
    FileObject->FileName = NewName;

    return STATUS_REPARSE;
}
    




//  The name resolution process operates as a state machine in
//  which the current step in the process is indicated by a state
//  variable, and responses to requests from the network will
//  transition the process to other states, from which actions
//  are taken.
//
//  When a user request needs further processing, an IRP is
//  dispatched with a Completion Routine that will
//  pick up processing when the sub-request is completed.  The
//  completion routine will adjust the name resolution state and restart the
//  main loop of the state machine.
//
//  The following state/action table describes the actions of
//  the procedures which implement the state machine:
//
//      Current         Condition/                      Next
//       State            Action                        State
//      -------         ----------                      -----
//
//      Enter           Acquire Pkt, canonicalize file  LocalCompletion
//                      name, optimistic allocation of
//                      FCB fails/
//                      No action
//
//      Enter           Acquire Pkt, canonicalize file  Start
//                      name, allocated FCB/
//                      Capture Credentials to use
//
//      Start           Got a referral, new pkt entry   GetFirstReplica
//                      is already in DnrContext and
//                      pkt entry is not inter-dfs/
//                      Capture USN of pkt entry
//
//      Start           lookup in PKT returns match     GetFirstReplica
//                      and pkt entry is not inter-dfs/
//                      Capture USN of pkt entry
//
//      Start           pkt entry from referral or      Start
//                      lookup is inter-dfs/
//                      Change file name in DnrContext
//                      to name in new Dfs, rebuild
//                      DnrContext
//
//      Start           lookup in PKT, no match/        GetFirstDC
//                      No action
//
//      GetFirstReplica Find First replica fails and    Done
//                      we have already got a referral/
//                      Set final status to
//                      NO_SUCH_DEVICE (must be
//                      because we don't have an
//                      appropriate redirector)
//
//      GetFirstReplica Find First replica fails and    GetFirstDC
//                      we haven't yet got a referral/
//                      locate first DC to send
//                      referral request to.
//
//      GetFirstReplica Replica found has no address,   GetFirstDC
//                      means a domain-based Dfs with
//                      no DCs/
//                      No action
//
//      GetFirstReplica Replica found with valid        SendRequest
//                      address/
//                      Capture provider info under
//                      lock protection, Reference
//                      provider's device object,
//
//      SendRequest     Supplied credentials, and tree  Done
//                      connect using creds fails/
//                      Set final status, dereference
//                      provider's device object
//
//      SendRequest     Allocate pool for new name/     PostProcessOpen
//                      Change file name into one that
//                      the provider can parse, pass
//                      the Create request to the
//                      provider, Derefence provider's
//                      device object when provider
//                      completes the request.
//
//      SendRequest     Pool Allocation fails/          Done
//                      Set final status, dereference
//                      provider's device object
//
//      PostProcessOpen Underlying FS returned REPARSE, SendRequest
//                      successfully created or found a
//                      provider for the target redir/
//                      Capture provider information
//                      under lock protection,
//                      Reference providers Device obj.
//
//      PostProcessOpen Underlying FS returned SUCCESS/ Done
//                      Insert optimistically allocated
//                      FCB into Fcb table, set final
//                      status
//
//      PostProcessOpen Open failed with                GetFirstDC
//                      PATH_NOT_COVERED or
//                      DFS_EXIT_POINT_FOUND, and
//                      we haven't yet gotten a
//                      referral/
//                      No action
//
//      PostProcessOpen Open failed with                Start
//                      OBJECT_TYPE_MISMATCH (ie,
//                      downlevel open found an
//                      interdfs link)/Change
//                      name in DnrContext to name
//                      in new Dfs, rebuild DnrContext
//
//      PostProcessOpen Open failed with                GetFirstReplica
//                      PATH_NOT_COVERED or
//                      DFS_EXIT_POINT_FOUND, and we
//                      already got a referral, and
//                      we have never reported an
//                      inconsistency/
//                      Report inconsistency
//
//      PostProcessOpen Same as above, but we already   GetNextReplica
//                      reported the inconsistency/
//                      Report the inconsistency
//
//      PostProcessOpen Open failed with network error/ GetNextReplica
//                      No action
//
//      PostProcessOpen Open failed with non-network    Done
//                      error/
//                      Set final status
//
//      GetNextReplica  No more replicas and haven't    GetFirstDC
//                      gotten a referral yet/
//                      no action
//
//      GetNextReplica  No more replicas and got a      Done
//                      referral/
//                      no action
//
//      GetNextReplica  Replica found/                  SendRequest
//                      Capture provider information
//                      under lock protection,
//                      Reference provider Device obj
//
//      GetFirstDC      Lookup referral entry not       Done
//                      found or has no services, and
//                      we have already called DC
//                      Locator once/
//                      Set final status to
//                      CANT_ACCESS_DOMAIN_INFO
//
//      GetFirstDC      Lookup referral entry returned  Done
//                      valid entry, but can't find a
//                      provider for it/
//                      Set final status to
//                      CANT_ACCESS_DOMAIN_INFO
//
//      GetFirstDC      Lookup referral entry returned  GetReferrals
//                      valid entry, and found
//                      provider/
//                      Set DnrContext->pPktEntry to
//                      DC's entry, Capture provider
//                      info under lock protection,
//                      Reference provider's Device obj
//
//      GetReferrals    Unable to open DC's IPC$ share/ GetNextDC
//                      Dereference provider's device
//                      object
//
//      GetReferrals    Opened DC's IPC$ share, but     Done
//                      unable to build referral
//                      request Irp/
//                      Dereference provider's device,
//                      Set final status to
//                      INSUFFICIENT_RESOURCES
//
//      GetReferrals    Opened DC's IPC$ share and      CompleteReferral
//                      built referral request/
//                      Release Pkt, Send referral
//                      request
//
//      GetNextDC       Successfully found another      GetReferrals
//                      DC/
//                      Capture provider info under
//                      lock protection, Reference
//                      provider's Device object
//
//      GetNextDC       Can't find another DC/          Done
//                      Set final status to
//                      CANT_ACCESS_DOMAIN_INFO
//
//      Done            Complete create Irp with
//                      DnrContext->FinalStatus
//
//      LocalCompletion Complete create Irp with
//                      local status.
//
//      CompleteReferral Referral returned with         GetReferrals
//                      BUFFER_OVERFLOW/
//                      Set referral size to
//                      indicated amount
//
//      CompleteReferral Referral returned, but         Done
//                      error in creating entry/
//                      Dereference provider's
//                      device, set final status to
//                      result of creating entry
//
//      CompleteReferral Referral returned and          GetFirstDC
//                      successfully created entry,
//                      entry is inter-dfs/
//                      Dereference provider's device,
//                      Reset ReferralSize
//
//      CompleteReferral Same as above, but entry       Start
//                      is storage entry/
//                      Dereference provider's device,
//                      Adjust DnrContext->
//                      RemainingPart to correspond
//                      to the new entry
//
//      CompleteReferral Referral request failed with   GetNextDC
//                      some network error/
//                      Dereference Provider's device
//
//      CompleteReferral Referral request failed with   Done
//                      some non-network error/
//                      Dereference provider's Device,
//                      Set final status to this error
//


//+-------------------------------------------------------------------------
//
//  Function:   DnrStartNameResolution - Start a distributed name resolution
//
//  Synopsis:   DnrStartNameResolution starts the name resolution process
//              for a request (typically an NtCreateFile).
//
//  Effects:    Could change the state of the PKT or individual
//              PKT entries.
//
//  Arguments:  [IrpContext] - pointer to a IRP_CONTEXT structure for the
//                      current request.
//              [Irp] - IRP being processed.
//              [Vcb] - Vcb of logical root.
//
//  Returns:    NTSTATUS - Status to be returned to the I/O subsystem.
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS
DnrStartNameResolution(
    IN    PIRP_CONTEXT IrpContext,
    IN    PIRP  Irp,
    IN    PDFS_VCB  Vcb
) {
    PDNR_CONTEXT        DnrContext;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT        FileObject = IrpSp->FileObject;
    PUNICODE_STRING     LogRootPrefix = &Vcb->LogRootPrefix;
    ULONG               CreateOptions;
    USHORT              cbFileName;
    SECURITY_QUALITY_OF_SERVICE sqos;
    ULONG               cbFileNameLong;

    MUP_TRACE_NORM(TRACE_IRP, DnrStartNameResolution_Entry,
		   LOGPTR(Irp)
		   LOGPTR(Vcb)
		   LOGPTR(FileObject)
		   LOGUSTR(FileObject->FileName)
		   LOGUSTR(*LogRootPrefix));

    cbFileNameLong =    FileObject->FileName.Length +
                         sizeof(UNICODE_PATH_SEP) +
                        LogRootPrefix->Length +
                         sizeof(UNICODE_NULL);

    cbFileName = (USHORT)cbFileNameLong;

    if( cbFileName != cbFileNameLong ) {
        //
        // The resulting name is too long -- we cannot deal with it
        //
        Status = STATUS_OBJECT_NAME_INVALID;
        DfsCompleteRequest(IrpContext, Irp, Status);
        DfsDbgTrace(0, Dbg, "DnrStartNameResolution:  Exit ->%x\n", ULongToPtr(Status));
        MUP_TRACE_HIGH(ERROR, DnrStartNameResolution_Error_NameTooLong,
                       LOGSTATUS(Status)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));
        return Status;
    }

    //
    // Allocate the DnrContext used to resolve the name. We optimize
    // allocation by allocating room for the FileName at the end of the
    // DnrContext.
    //

    DnrContext = AllocateDnrContext(cbFileName);

    if (DnrContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DfsCompleteRequest(IrpContext, Irp, Status);
        DfsDbgTrace(0, Dbg, "DnrStartNameResolution:  Exit ->%x\n", ULongToPtr(Status));
        MUP_TRACE_HIGH(ERROR, DnrStartNameResolution_Error2,
                       LOGSTATUS(Status)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));
        return Status;
    }

    DnrContext->FileName.Length = 0;
    DnrContext->FileName.MaximumLength = cbFileName;
    DnrContext->FileName.Buffer = (PWCHAR) ( (PBYTE) DnrContext + sizeof(DNR_CONTEXT) );

    //
    // Since FileName.Buffer has not been separately allocated, we set this
    // to FALSE.
    //

    DnrContext->NameAllocated = FALSE;

    //
    // Capture the user's security token so we can later impersonate if
    // needed.
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    Status = SeCreateClientSecurity(
                Irp->Tail.Overlay.Thread,
                &sqos,
                FALSE,                           // Remote Session
                &DnrContext->SecurityContext);   // Return context.

    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrStartNameResolution_Error_SeCreateClientSecurity,
                         LOGSTATUS(Status)
                         LOGPTR(FileObject)
                         LOGPTR(Irp)
			 LOGUSTR(FileObject->FileName));
    if (!NT_SUCCESS(Status)) {
        DeallocateDnrContext( DnrContext );
        DfsCompleteRequest(IrpContext, Irp, Status);
        DfsDbgTrace(0, Dbg, "DnrStartNameResolution:  Exit ->%x\n", ULongToPtr(Status));
        return( Status );
    }

    DnrContext->Impersonate = FALSE;

    ASSERT(NT_SUCCESS(Status));

    //
    // Initialize the rest of the DnrContext
    //

    DnrContext->AuthConn = NULL;
    DnrContext->OriginalIrp = Irp;
    DnrContext->pIrpContext = IrpContext;
    DnrContext->Credentials = NULL;
    DnrContext->FinalStatus = STATUS_SUCCESS;
    DnrContext->FcbToUse = NULL;
    DnrContext->Vcb = Vcb;
    DnrContext->State = DnrStateEnter;
    DnrContext->Attempts = 0;
    DnrContext->DnrActive = FALSE;
    DnrContext->ReleasePkt = FALSE;
    DnrContext->GotReferral = FALSE;
    DnrContext->FoundInconsistency = FALSE;
    DnrContext->CalledDCLocator = FALSE;
    DnrContext->CachedConnFile = FALSE;
    DnrContext->ReferralSize = MAX_REFERRAL_LENGTH;
    KeQuerySystemTime(&DnrContext->StartTime);


    CreateOptions = IrpSp->Parameters.Create.Options;

    //
    // ... and resolve the name
    //

    return DnrNameResolve(DnrContext);
}

//+-------------------------------------------------------------------------
//
//  Function:   DnrNameResolve - Main loop for DNR
//
//  Synopsis:   DnrNameResolve drives the name resolution process
//              for a request (typically an NtCreateFile).
//
//  Effects:    Could change the state of the PKT or individual
//              PKT entries.
//
//  Arguments:  [DnrContext] - pointer to a DNR_CONTEXT structure which
//                      records the state of the DNR.
//
//  Returns:    NTSTATUS - Status to be returned to the I/O subsystem.
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS
DnrNameResolve(
    IN    PDNR_CONTEXT DnrContext
) {
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_VCB Vcb;
    PIRP Irp;
    BOOLEAN LastEntry;
    PDFS_PKT_ENTRY shortPfxMatch;
    UNICODE_STRING shortRemainingPart;
    LARGE_INTEGER EndTime;
    PFILE_OBJECT InputFileObject;


    DfsDbgTrace(+1, Dbg, "DnrNameResolve: Entered\n", 0);

    ASSERT( !DnrContext->DnrActive && "Recursive call to Dnr!\n");


    DnrContext->DnrActive = TRUE;

    //
    // If we need to impersonate the original caller, do so before doing
    // anything else.
    //


    Irp = DnrContext->OriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    InputFileObject = IrpSp->FileObject;
    Vcb = DnrContext->Vcb;

    if (DnrContext->Impersonate) {

        Status = SeImpersonateClientEx(
                    &DnrContext->SecurityContext,
                    (PETHREAD) NULL);
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrNameResolve_Error_SeImpersonateClientEx,
                             LOGSTATUS(Status)
                             LOGPTR(InputFileObject));

        if (!NT_SUCCESS(Status)) {

            DnrContext->DnrActive = FALSE;
            DnrContext->State = DnrStateLocalCompletion;
            DfsDbgTrace(0, Dbg,
                "DnrNameResolve quitting due to SeImpersonateClientEx returning 0x%x\n", ULongToPtr(Status));

        }

    }


    //
    //  Drive the name resolution process as far as possible before
    //  it is necessary to wait for an I/O completion.
    //

    while (1) {
        PDFS_PKT_ENTRY pktEntry = NULL;
        PFILE_OBJECT FileObject = IrpSp->FileObject;

        if (DnrContext->State == DnrStateGetFirstReplica ||
            DnrContext->State == DnrStateGetFirstDC) {
            if (++DnrContext->Attempts > MAX_DNR_ATTEMPTS) {
                Status = STATUS_BAD_NETWORK_PATH;
                DnrContext->State = DnrStateLocalCompletion;
                DfsDbgTrace(0, 0,
                    "DFS: DnrNameResolve quitting due to MAX_DNR_ATTEMPTS %d\n",
                    UIntToPtr(DnrContext->Attempts));
            }
        }

        if (DnrContext->State == DnrStateStart)
        {
            if (DnrContext->Attempts > MAX_DNR_ATTEMPTS)
            {
                Status = STATUS_BAD_NETWORK_PATH;
                DnrContext->State = DnrStateLocalCompletion;
            }
        }

	MUP_TRACE_LOW(DNR, DnrNameResolve_TopOfLoop, 
		      LOGUSTR(FileObject->FileName)
		      LOGULONG(DnrContext->State)
		      );
        switch (DnrContext->State) {

        case DnrStateEnter:
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateEnter\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == FALSE);

            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

            //
            // We need to construct the fully qualified file name given the
            // logical root and the input file name relative to that root.
            // DnrComposeFileName will allocate memory to hold a string that
            // is the concatenation of the name of the logical root wrt org
            // and the file name.
            //
            //

            ASSERT((FileObject->FileName.Length & 0x1) == 0);

            DnrComposeFileName(
                &DnrContext->FileName,
                DnrContext->Vcb,
                FileObject->RelatedFileObject,
                &FileObject->FileName);

	    DnrContext->ContextFileName = DnrContext->FileName;

            DfsDbgTrace(0, Dbg,
                "DnrComposeFileName -> %wZ\n", &FileObject->FileName);


	    if(DfsIsShareNull(&DnrContext->FileName)) {
		//
		// It doesn't make sense for us to have a name in the form
		// "\server\" or "\domain\" so we reject it. If we didn't reject these
		// names we would wind up bugchecking when processing the 
		// referral with a NULL sharename.
		//
		Status = STATUS_INVALID_PARAMETER;
		DnrContext->State = DnrStateLocalCompletion;
                break;
	    }

	    Status = DfspIsRootOnline(&DnrContext->FileName,
                            (BOOLEAN)
                                ((DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0));
            if (!NT_SUCCESS(Status)) {
     	        DnrContext->State = DnrStateLocalCompletion;
                break;
	    }
#if DBG
            if (MupVerbose)
                DbgPrint("  DnrContext->FileName=(%wZ)\n", &DnrContext->FileName);
#endif

            //
            // Allocate an FCB now for use if the DNR succeeds. We must, do
            // this, or we won't know how what to do if the underlying FS
            // opens the file and then we are unable to allocate the FCB.
            //

            ASSERT(DnrContext->FcbToUse == NULL);

            DnrContext->FcbToUse =  DfsCreateFcb(
                                        NULL,
                                        DnrContext->Vcb,
                                        &DnrContext->ContextFileName);

            if (DnrContext->FcbToUse == NULL) {
                DfsDbgTrace(0, Dbg, "Could not create FCB!\n", 0);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DnrContext->State = DnrStateLocalCompletion;
                break;
            }

	    DnrContext->FcbToUse->FileObject = FileObject;
	    
	    DfsSetFileObject(FileObject, 
			     RedirectedFileOpen, 
			     DnrContext->FcbToUse);


            DnrCaptureCredentials(DnrContext);

            DnrContext->State = DnrStateStart;

            //
            // Fall through
            //

        case DnrStateStart:
            DfsDbgTrace(0, Dbg, "FSM state Start\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateStart\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
                DbgPrint("  DnrContext->FileName=(%wZ)\n", &DnrContext->FileName);
            }
#endif

            ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );

            //
            // Try to match the filename with the best
            // PktEntry we have.
            //

            //
            // Do the match in the full prefix table
            //

            pktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                            &DnrContext->FileName,
                                            &DnrContext->RemainingPart);


            //
            // Then do a match in the short prefix table
            //

            shortPfxMatch = PktLookupEntryByShortPrefix(
                                &DfsData.Pkt,
                                &DnrContext->FileName,
                                &shortRemainingPart);

            if (shortPfxMatch != NULL) {

                if (pktEntry == NULL) {

                    pktEntry = shortPfxMatch;

                    DnrContext->RemainingPart = shortRemainingPart;

                } else if (shortPfxMatch->Id.Prefix.Length >
                            pktEntry->Id.Prefix.Length) {

                    pktEntry = shortPfxMatch;

                    DnrContext->RemainingPart = shortRemainingPart;

                }

            }

            //
            // If the entry found is stale and this is our first attempt at dnr,
            // force another referral request.
            //

            if (DnrContext->Attempts == 0 && pktEntry != NULL && pktEntry->ExpireTime <= 0) {
#if DBG
                if (MupVerbose)
                    DbgPrint("  pktEntry [%wZ] is stale - force getting another\n",
                                    &pktEntry->Id.Prefix);
#endif
                DnrContext->pPktEntry = pktEntry;

                DnrContext->State = DnrStateGetFirstDC;
                //
                // Now break out so we restart Dnr and get a referral
                //
                break;

            }


#if 0
            if (pktEntry == NULL) {

                PUNICODE_STRING filePath = &DnrContext->FileName;
                UNICODE_STRING dfsRootName;
                UNICODE_STRING shareName;
                NTSTATUS status;
                PDFS_SPECIAL_ENTRY pSpecialEntry;
                ULONG i, j;

                for (i = 1;
                        i < filePath->Length/sizeof(WCHAR) &&
                            filePath->Buffer[i] != UNICODE_PATH_SEP;
                                i++) {

                    NOTHING;

                }

                dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
                dfsRootName.MaximumLength = dfsRootName.Length;
                dfsRootName.Buffer = &filePath->Buffer[1];

                for (j = i+1;
                        j < filePath->Length/sizeof(WCHAR) &&
                            filePath->Buffer[j] != UNICODE_PATH_SEP;
                                    j++) {

                     NOTHING;

                }

                shareName.Length = (USHORT) (j - i - 1) * sizeof(WCHAR);
                shareName.MaximumLength = shareName.Length;
                shareName.Buffer = &filePath->Buffer[i+1];

                PktRelease();
                DnrContext->ReleasePkt = FALSE;

                status = PktExpandSpecialName(
                                    &dfsRootName,
                                    &pSpecialEntry);

                PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

                if (NT_SUCCESS(status)) {

                    ULONG Len;

                    if ((j+1) < filePath->Length/sizeof(WCHAR)) {

                        Len = filePath->Length - ((j+1) * sizeof(WCHAR));

                        DnrContext->RemainingPart.Buffer = &filePath->Buffer[j+1];
                        DnrContext->RemainingPart.Length = (USHORT) Len;
                        DnrContext->RemainingPart.MaximumLength = (USHORT) Len;

                    } else {

                        DnrContext->RemainingPart.Buffer = NULL;
                        DnrContext->RemainingPart.Length = 0;
                        DnrContext->RemainingPart.MaximumLength = 0;

                    }

                    status = PktEntryFromSpecialEntry(
                                    pSpecialEntry,
                                    &shareName,
                                    &pktEntry);

                    InterlockedDecrement(&pSpecialEntry->UseCount);

                }

            }
#endif

#if 0
            if (pktEntry != NULL) {

                pktEntry->ExpireTime = pktEntry->TimeToLive;

            }
#endif
            DfsDbgTrace(0, Dbg, "DnrNameResolve: found pktEntry %08lx\n",
                                        pktEntry);

            DNR_SET_TARGET_INFO( DnrContext, pktEntry );

            if (pktEntry == NULL) {

                //
                // We didn't find any entry. We set pPktEntry to NULL so that
                // in GetFirstDC, the call to PktLookupReferralEntry will
                // return the right thing (ie, will give use the highest DC we
                // know about).
                //

                DnrContext->pPktEntry = NULL;
                DnrContext->State = DnrStateGetFirstDC;

            } else if (pktEntry->Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) {

                DnrRebuildDnrContext(
                    DnrContext,
                    &pktEntry->Info.ServiceList[0].Address,
                    &DnrContext->RemainingPart);


                //
                // The DnrContext has been rebuilt and programmed to
                // "restart" DNR. So, we'll just break out of the state
                // machine and reenter it with the reconstructed context
                //

            } else {

                ASSERT(pktEntry != NULL);

                DnrContext->pPktEntry = pktEntry;
                DnrContext->USN = pktEntry->USN;
                DnrContext->State = DnrStateGetFirstReplica;

            }
            break;

        case DnrStateGetFirstReplica:
            DfsDbgTrace(0, Dbg, "FSM state GetFirstReplica\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetFirstReplica\n",
                    (EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

            Status = ReplFindFirstProvider(DnrContext->pPktEntry,
                                           NULL,
                                           NULL,
                                           &DnrContext->pService,
                                           &DnrContext->RSelectContext,
                                           &LastEntry);

            if (! NT_SUCCESS(Status)) {

                ULONG PktType = DnrContext->pPktEntry->Type;

                ExReleaseResourceLite(&DfsData.Resource);

                DfsDbgTrace(0, Dbg, "No provider found %08lx\n", ULongToPtr(Status));

                if (DnrContext->GotReferral ||
                    (PktType & PKT_ENTRY_TYPE_SYSVOL) != 0 ||
                    DnrContext->GotReparse == TRUE
                ) {
                    DnrContext->FinalStatus = STATUS_NO_SUCH_DEVICE;
                    DnrContext->State = DnrStateDone;
                    break;
                } else {
                    DnrContext->State = DnrStateGetFirstDC;
                    break;
                }

            } else if (DnrContext->pService->Address.Length == 0) {

                ExReleaseResourceLite(&DfsData.Resource);

                DfsDbgTrace(0, Dbg, "Service with no address, going for referral\n", 0);

                DnrContext->State = DnrStateGetFirstDC;
                break;

            } else {

                ASSERT(DnrContext->pService != NULL);
                ASSERT(DnrContext->pService->pProvider != NULL);

#if DBG
                if (MupVerbose)
                    DbgPrint("  Alternate Name=[%wZ] Address=[%wZ]\n",
                        &DnrContext->pService->Name,
                        &DnrContext->pService->Address);
#endif

                DnrContext->pProvider = DnrContext->pService->pProvider;
                DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                if (LastEntry == TRUE) {
                    DnrContext->DfsNameContext.Flags |= DFS_FLAG_LAST_ALTERNATE;
                } else {
                    DnrContext->DfsNameContext.Flags &= ~DFS_FLAG_LAST_ALTERNATE;
                }

                ExReleaseResourceLite(&DfsData.Resource);

                DnrContext->State = DnrStateSendRequest;
            }
            // FALL THROUGH ...

        case DnrStateSendRequest:
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateSendRequest\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            DfsDbgTrace(0, Dbg, "FSM state SendRequest\n", 0);

            ASSERT(DnrContext->ReleasePkt == TRUE);

            ASSERT(DnrContext->pService != NULL);
            ASSERT(DnrContext->pProvider != NULL);
            ASSERT(DnrContext->TargetDevice != NULL);

            //
            // First of all, check to see if the volume is offline
            //

            if (DnrContext->pService->Type & DFS_SERVICE_TYPE_OFFLINE) {

                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->FinalStatus = STATUS_DEVICE_OFF_LINE;
                DnrContext->State = DnrStateDone;
                DfsDbgTrace(-1, Dbg, "DnrNameResolve: Device Offline\n",0);
                Status = STATUS_DEVICE_OFF_LINE;
                MUP_TRACE_HIGH(ERROR, DnrNameResolve_Error3,
                               LOGSTATUS(Status)
                               LOGPTR(FileObject));
                break;
            }

            //
            // Next, try to make an authenticated connection to the server, if needed
            //
            // The pkt lock may be dropped in this call, so keep the pkt entry from going
            // away.
            //

            InterlockedIncrement(&DnrContext->pPktEntry->UseCount);


            PktRelease();
            DnrContext->ReleasePkt = FALSE;

            Status = DnrGetAuthenticatedConnection( DnrContext );

            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

            InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

            if (!NT_SUCCESS(Status)) {

                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->FinalStatus = Status;

                //
                // If the error is such that we need to try another replica,
                // do so here.
                //

                if (ReplIsRecoverableError(Status)) {
                     DnrContext->State = DnrStateGetNextReplica;
                }
                else {
                     DnrContext->State = DnrStateDone;
                }

                DfsDbgTrace(-1, Dbg,
                  "DnrNameResolve: Unable to get connection %08lx\n", ULongToPtr(Status));

                break;
            }

            if (DnrContext->USN != DnrContext->pPktEntry->USN) {

                //
                // Dang, Pkt Entry changed when we made the
                // connection. We'll have to retry.
                //
                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrReleaseAuthenticatedConnection(DnrContext);
                DnrContext->State = DnrStateStart;
                DfsDbgTrace(-1, Dbg, "DnrNameResolve: USN delta - restarting DNR\n", 0);
                break;

            }

            Status = DnrRedirectFileOpen(DnrContext);

            if (Status == STATUS_PENDING) {
                return(Status);
            }
            break;

        case DnrStatePostProcessOpen:
            DfsDbgTrace(0, Dbg, "FSM state PostProcessOpen\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStatePostProcessOpen\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            //
            // We come to this state only after sending an open request over
            // the net. We should never hold the Pkt while going over the net.
            // Hence the sense of the assert below.
            //

            ASSERT(DnrContext->ReleasePkt == FALSE);

            Status = DnrPostProcessFileOpen(DnrContext);
            pktEntry = DnrContext->pPktEntry;
            break;

        case DnrStateGetNextReplica:
            DfsDbgTrace(0, Dbg, "FSM state GetNextReplica\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrGetNextReplica\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            {
                NTSTATUS ReplStatus;

                ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

                ReplStatus = ReplFindNextProvider(DnrContext->pPktEntry,
                                                  &DnrContext->pService,
                                                  &DnrContext->RSelectContext,
                                                  &LastEntry);

                if (ReplStatus == STATUS_NO_MORE_ENTRIES) {

                    ULONG PktType = DnrContext->pPktEntry->Type;

#if DBG
                    if (MupVerbose)
                        DbgPrint("  No more alternates...\n");
#endif

                    //
                    // If all failed and we are about to give up due to one
                    // of two reasons :
                    // 1. None of the Services for the PkEntry being used
                    //    responded (either they are down or network down!).
                    // 2. Some or all of the Services have inconsistencies
                    //    which we detected and informed the DC about along
                    //    the way.
                    // If we did land up with case 2 then we really have to
                    // try and get a new referral and use that - just in
                    // case things have changed since then at the DC. So let
                    // us get into a GetReferral State and try once again.
                    //

                    ExReleaseResourceLite( &DfsData.Resource );

                    if (DnrContext->GotReferral ||
                        (PktType & PKT_ENTRY_TYPE_SYSVOL) != 0 ||
                        DnrContext->GotReparse == TRUE
                    ) {
                        DnrContext->State = DnrStateDone;
                    } else {
                        DnrContext->State = DnrStateGetFirstDC;
                    }

                } else if (NT_SUCCESS( ReplStatus )) {

                    //
                    // Found another replica, go back and retry.
                    //

                    ASSERT(DnrContext->pService != NULL);
                    ASSERT(DnrContext->pService->pProvider != NULL);

                    DnrContext->pProvider = DnrContext->pService->pProvider;
                    DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                    DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                    DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                    ExReleaseResourceLite(&DfsData.Resource);

                    DnrContext->State = DnrStateSendRequest;

#if DBG
                    if (MupVerbose)
                        DbgPrint("  Alternate Name=[%wZ] Address=[%wZ]\n",
                            &DnrContext->pService->Name,
                            &DnrContext->pService->Address);
#endif

                    if (LastEntry == TRUE) {
                        DnrContext->DfsNameContext.Flags |= DFS_FLAG_LAST_ALTERNATE;
                    } else {
                        DnrContext->DfsNameContext.Flags &= ~DFS_FLAG_LAST_ALTERNATE;
                    }

                    break;
                } else  {

                    ExReleaseResourceLite(&DfsData.Resource);

                    ASSERT(ReplStatus == STATUS_NO_MORE_ENTRIES);
                }
            }
            break;

        case DnrStateGetFirstDC:
            DfsDbgTrace(0, Dbg, "FSM state GetFirstDC\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetFirstDC\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            {
                NTSTATUS ReplStatus;
                PDFS_PKT_ENTRY pPktEntryDC = NULL;

                pPktEntryDC = PktLookupReferralEntry(&DfsData.Pkt, DnrContext->pPktEntry);

                //
                // If there is no root entry, or it is stale, or it has no
                // services, then try for a new referral entry for the root
                //

                if (
                    pPktEntryDC == NULL
                        ||
                    pPktEntryDC->ExpireTime <= 0
                        ||
                    pPktEntryDC->Info.ServiceCount == 0
                ) {

                    if (DnrContext->CalledDCLocator) {
                        DnrContext->FinalStatus = STATUS_CANT_ACCESS_DOMAIN_INFO;
                        DnrContext->State = DnrStateDone;
                        break;
                    }

                    //
                    // We are unable to find a DC to go to for referrals.
                    // This can only happen if we don't have the pkt entry
                    // for the root of the Dfs. Try to get the root entry.
                    //

                    DfsDbgTrace(0, Dbg, "No DC info - will try locator\n", 0);
#if DBG
                    if (MupVerbose) {
                        if (pPktEntryDC != NULL && pPktEntryDC <= 0)
                            DbgPrint("  Entry is stale.\n");
                        DbgPrint("  No Root/DC info - will try locator\n");
                    }
#endif

                    PktRelease();
                    DnrContext->ReleasePkt = FALSE;

                    DnrLocateDC(&DnrContext->FileName);

                    PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

                    DnrContext->CalledDCLocator = TRUE;
                    DnrContext->State = DnrStateStart;

                    break;


                }

#if DBG
                if (MupVerbose) {
                    if (DnrContext->pPktEntry != NULL)
                        DbgPrint("  DnrContext->pPktEntry=[%wZ]\n",
                            &DnrContext->pPktEntry->Id.Prefix);
                    else
                        DbgPrint("  DnrContext->pPktEntry=NULL\n");
                    DbgPrint("  pPktEntryDC=[%wZ]\n", &pPktEntryDC->Id.Prefix);
                }
#endif

                DnrContext->pPktEntry = pPktEntryDC;

                DNR_SET_TARGET_INFO( DnrContext, DnrContext->pPktEntry );
                DnrContext->USN = pPktEntryDC->USN;

                ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

                ReplStatus = ReplFindFirstProvider(pPktEntryDC,
                                            NULL,
                                            NULL,
                                            &DnrContext->pService,
                                            &DnrContext->RDCSelectContext,
                                            &LastEntry);

                if (!NT_SUCCESS(ReplStatus)) {
                    ExReleaseResourceLite(&DfsData.Resource);
                    DnrContext->FinalStatus = STATUS_CANT_ACCESS_DOMAIN_INFO;
                    DnrContext->State = DnrStateDone;
                    break;
                } else {
                    ASSERT(DnrContext->pService != NULL);
                    ASSERT(DnrContext->pService->pProvider != NULL);

                    InterlockedIncrement(&DnrContext->pPktEntry->UseCount);

                    DnrContext->pProvider = DnrContext->pService->pProvider;
                    DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                    DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                    DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                    ExReleaseResourceLite(&DfsData.Resource);

                }
            }
            DnrContext->State = DnrStateGetReferrals;
            /* FALL THROUGH */


        case DnrStateGetReferrals:
            DfsDbgTrace(0, Dbg, "FSM state GetReferrals\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetReferrals\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

            //
            // Attempt to open the Dfs Root's IPC$ share if we haven't already done
            // so.
            //

            if (DnrContext->pService->ConnFile == NULL) {
                HANDLE hDC;
                SE_IMPERSONATION_STATE DisabledImpersonationState;
                BOOLEAN RestoreImpersonationState = FALSE;

                ExReleaseResourceLite(&DfsData.Resource);
                KeQuerySystemTime(&EndTime);

#if DBG
                if (MupVerbose)
                    DbgPrint("  [%d] Opening connection to [\\%wZ\\IPC$] using [%wZ]\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        &DnrContext->pService->Name,
                        &DnrContext->pProvider->DeviceName);
#endif


		if (MupUseNullSessionForDfs) {
		    RestoreImpersonationState = PsDisableImpersonation(
                                                   PsGetCurrentThread(),
                                                   &DisabledImpersonationState);
		}
		  
                Status = DfsCreateConnection(
                            DnrContext->pService,
                            DnrContext->pProvider,
                            (BOOLEAN)
                                ((DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0),
                                                                        &hDC);

                if (RestoreImpersonationState) {
                        PsRestoreImpersonation(
                            PsGetCurrentThread(),
                            &DisabledImpersonationState);
                }


#if DBG
                if (MupVerbose)
                    DbgPrint("  Open of connection Status=0x%x\n", Status);
#endif

                if (NT_SUCCESS( Status )) {

                    if (DnrContext->USN != DnrContext->pPktEntry->USN) {

                        //
                        // Dang, Pkt Entry changed when we made the
                        // connection. We'll have to retry.
                        //
                        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

                        ZwClose( hDC );

                        DnrContext->State = DnrStateGetFirstDC;
#if DBG
                        if (MupVerbose)
                            DbgPrint("  USN changed.\n");
#endif
                        break;

                    }

                }

                if ( NT_SUCCESS( Status ) ) {

                    PFILE_OBJECT DcFileObject; // Need stack based variable
                                             // because ObRef... expects
                                             // this parameter to be in
                                             // non-paged memory.

                    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

                    if (DnrContext->pService->ConnFile == NULL) {

                        //
                        // 426184, need to check return code for errors.
                        //
                        Status = ObReferenceObjectByHandle(
                                    hDC,
                                    0,
                                    NULL,
                                    KernelMode,
                                    (PVOID *)&DcFileObject,
                                    NULL);
                        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR,  DnrNameResolve_Error_ObReferenceObjectByHandle,
                                             LOGSTATUS(Status)
                                             LOGPTR(DcFileObject));
#if DBG
                        if (MupVerbose)
                            DbgPrint("  ObReferenceObjectByHandle returned 0x%x\n", Status);
#endif
                        if ( NT_SUCCESS( Status ) ) {
                            DnrContext->pService->ConnFile = DcFileObject;
                        }
                        ZwClose( hDC );
                    }
                }

                if ( NT_SUCCESS( Status ) ) {
                    DnrContext->DCConnFile = DnrContext->pService->ConnFile;
                    DnrContext->CachedConnFile = FALSE;
                    DFS_REFERENCE_OBJECT( DnrContext->DCConnFile );

                    ExReleaseResourceLite( &DfsData.Resource );

                } else if (DfsEventLog > 0) {

                    LogWriteMessage(
                        DFS_CONNECTION_FAILURE,
                        Status,
                        1,
                        &DnrContext->pService->Name);

                }

            } else {

                //
                // DnrContext->pService is protected by the Pkt lock. Since we
                // will be using pService->ConnFile to send the referral request,
                // we better reference and cache it.
                //
                DnrContext->DCConnFile = DnrContext->pService->ConnFile;
                DFS_REFERENCE_OBJECT( DnrContext->DCConnFile );
                DnrContext->CachedConnFile = TRUE;
                ExReleaseResourceLite(&DfsData.Resource);
                Status = STATUS_SUCCESS;

            }

            //
            // Unable to get IPC$ share, try the next Dfs root
            //

            if (!NT_SUCCESS(Status)) {
                DnrContext->State = DnrStateGetNextDC;
                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                break;
            }

            //
            // Opened Dfs Root's IPC$ share - remember this DC is a good one.
            //

            ReplSetActiveService(
                DnrContext->pPktEntry,
                DnrContext->RDCSelectContext);

            //
            // Build the Referral request...
            //

            Irp = DnrBuildReferralRequest(DnrContext);

            if (Irp == NULL) {
                InterlockedDecrement(&DnrContext->pPktEntry->UseCount);
                Irp = DnrContext->OriginalIrp;
                DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DFS_DEREFERENCE_OBJECT(DnrContext->DCConnFile);
                DnrContext->State = DnrStateDone;
#if DBG
                if (MupVerbose)
                    DbgPrint("  DnrBuildReferralRequest returned NULL irp\n");
#endif
                break;
            }

            DnrContext->State = DnrStateCompleteReferral;

            PktRelease();
            DnrContext->ReleasePkt = FALSE;

            //
            // The PktReferralRequests semaphore is used to control how
            // many threads can simultaneously be going for referrals. The
            // following Wait will decrement the PktReferralRequests
            // semaphore by 1 if it is not already 0. If it is 0, then
            // this thread will suspend until someone else bumps up the
            // semaphore by 1. We will bump up the semaphore count in
            // DnrCompleteReferral.
            //

            Status = KeWaitForSingleObject(
                            &DfsData.PktReferralRequests,
                            UserRequest,     // WaitReason - don't care
                            KernelMode,
                            FALSE,           // Alertable
                            NULL);           // Timeout

            ASSERT(Status == STATUS_SUCCESS);

            KeQuerySystemTime(&EndTime);
#if DBG
            if (MupVerbose)
                DbgPrint("  [%d] asking for referral (IoCallDriver)\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
#endif

            IoMarkIrpPending( DnrContext->OriginalIrp );

            Status = IoCallDriver( DnrContext->TargetDevice, Irp );

            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrNameResolve_Error_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(FileObject));
            //
            // We now return STATUS_PENDING. DnrCompleteReferral will
            // resume the Dnr.
            //

            DfsDbgTrace(-1, Dbg, "DnrNameResolve: returning %08lx\n", ULongToPtr(STATUS_PENDING));

            return(STATUS_PENDING);

        case DnrStateGetNextDC:
            DfsDbgTrace(0, Dbg, "FSM State GetNextDC\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetNextDC\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            {
               NTSTATUS ReplStatus;
               PDFS_PKT_ENTRY pPktEntry = NULL;
               UNICODE_STRING RemPath;

               pPktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                           &DnrContext->FileName,
                                           &RemPath);

               ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

               ReplStatus = ReplFindNextProvider(DnrContext->pPktEntry,
                                                 &DnrContext->pService,
                                                 &DnrContext->RDCSelectContext,
                                                 &LastEntry);
               if (NT_SUCCESS(ReplStatus)) {
                   ASSERT(DnrContext->pService != NULL);
                   ASSERT(DnrContext->pService->pProvider != NULL);

                   DnrContext->pProvider = DnrContext->pService->pProvider;
                   DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                   DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                   DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                   DnrContext->State = DnrStateGetReferrals;
               } else if (pPktEntry != NULL && pPktEntry->ExpireTime <= 0) {
                   ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );
#if DBG
                   if (MupVerbose) {
                       DbgPrint("  Out of roots to try for referral for [%wZ]\n",
                                &DnrContext->FileName);
                       DbgPrint("  Found stale referral [%wZ], adding 60 sec to it\n",
                                &pPktEntry->Id.Prefix);
                   }
#endif
                   InterlockedDecrement(&DnrContext->pPktEntry->UseCount);
                   DnrContext->State = DnrStateStart;
               } else {
#if DBG
                   if (MupVerbose)
                       DbgPrint("  Out of roots to try for referral for [%wZ], no stale found\n",
                                        &DnrContext->FileName);
#endif
                   InterlockedDecrement(&DnrContext->pPktEntry->UseCount);
                   DnrContext->FinalStatus = STATUS_CANT_ACCESS_DOMAIN_INFO;
                   DnrContext->State = DnrStateDone;
               }

               ExReleaseResourceLite(&DfsData.Resource);

            }
            break;

        case DnrStateDone:
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateDone\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            Status = DnrContext->FinalStatus;
            // FALL THROUGH ...

        case DnrStateLocalCompletion:
            DfsDbgTrace(0, Dbg, "FSM state Done\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateLocalCompletion\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            if (Status != STATUS_LOGON_FAILURE && !ReplIsRecoverableError(Status)) {

                if (DnrContext->pPktEntry != NULL &&
                    (DnrContext->pPktEntry->Type & PKT_ENTRY_TYPE_SYSVOL) &&
	            (DnrContext->pPktEntry->Link.Flink == &(DnrContext->pPktEntry->Link))) {

                    PDFS_PKT Pkt = _GetPkt();
                    PDFS_PKT_ENTRY Entry = DnrContext->pPktEntry;
                    PDFS_PKT_ENTRY pMatchEntry;

                    InterlockedIncrement(&Entry->UseCount);

                    if (DnrContext->ReleasePkt)
                        PktRelease();

                    PktAcquireExclusive(TRUE, &DnrContext->ReleasePkt);

                    InterlockedDecrement(&Entry->UseCount);

#if DBG
		    if ((MupVerbose) && (pktEntry != NULL)) {
			//
		        // Temporary debug stuff.
			//
			if ((pktEntry->NodeTypeCode != DSFS_NTC_PKT_ENTRY) ||
			    (pktEntry->NodeByteSize != sizeof(*pktEntry))) {
			    DbgPrint("DnrNameResolve: Updating bogus Pkt entry avoided: Pkt Entry 0x%x\n", pktEntry);
			}
		    }
#endif
                    pMatchEntry = PktFindEntryByPrefix(
                                           Pkt,
                                           &Entry->Id.Prefix);

                    if ((Entry->Type & PKT_ENTRY_TYPE_DELETE_PENDING) == 0) {
                        if (pMatchEntry == NULL) {
                             if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                                        &Entry->Id.Prefix,
                                                        &Entry->PrefixTableEntry)) {

                              //
                               // We successfully created the prefix entry, so now we link
                               // this entry into the PKT.
                               //
                               PktLinkEntry(Pkt, Entry);
			     }
	                } else {
                             //
                             // Destroy this entry if it isn't in the table, as we are
                             // about to orphan it.
                             //
                            if (pMatchEntry != NULL && pMatchEntry != Entry) {

                                Entry->ActiveService = NULL;
                                PktEntryIdDestroy(&Entry->Id, FALSE);
                                PktEntryInfoDestroy(&Entry->Info, FALSE);
                                ExFreePool(Entry);
                            }
                        }
                    }
                    PktRelease();
                    DnrContext->ReleasePkt = FALSE;

                }

            }

            if (DnrContext->ReleasePkt)
                PktRelease();

	    if ((Status == STATUS_DEVICE_OFF_LINE) &&
		(IrpSp->FileObject->RelatedFileObject == NULL)) {
	        Status = DfsRerouteOpenToMup(IrpSp->FileObject, &DnrContext->FileName);
	    }

            if (DnrContext->FcbToUse != NULL) {
	        DfsDetachFcb(DnrContext->FcbToUse->FileObject, DnrContext->FcbToUse);
                ExFreePool( DnrContext->FcbToUse );
	    }

            DfsCompleteRequest(DnrContext->pIrpContext, Irp, Status);


            DnrReleaseCredentials(DnrContext);

            SeDeleteClientSecurity( &DnrContext->SecurityContext );

            if (DnrContext->NameAllocated)
                ExFreePool( DnrContext->FileName.Buffer );

            if (DnrContext->pDfsTargetInfo != NULL)
            {
                PktReleaseTargetInfo(DnrContext->pDfsTargetInfo);
                DnrContext->pDfsTargetInfo = NULL;
            }
            KeQuerySystemTime(&EndTime);
#if DBG
            if (MupVerbose)
                DbgPrint("[%d] DnrNameResolve exit 0x%x\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        Status);
#endif
            DeallocateDnrContext(DnrContext);

            DfsDbgTrace(-1, Dbg, "DnrNameResolve: Exit ->%x\n", ULongToPtr(Status));
            return Status;

        default:
            BugCheck("DnrNameResolve: unexpected DNR state");
        }
    }

    BugCheck("DnrNameResolve: unexpected exit from loop");
}



//+----------------------------------------------------------------------------
//
//  Function:   DnrComposeFileName
//
//  Synopsis:   Given a DFS_VCB (implicitly a Device Object), and a file name
//              relative to that device, this routine will compose a fully
//              qualified name (ie, a name relative to the highest (org) root).
//
//  Arguments:  [FullName] --   Fully qualified name destination.
//              [Vcb] --        Pointer to Vcb of Device Object.
//              [RelatedFile] -- Related file object.
//              [FileName] -- The file being "name resolved"
//
//  Returns:
//
//  Note:       This function assumes that file names are composed precisely
//              of two parts - the name relative to org of the file object's
//              device, followed by the name of the file relative to the device
//              This may not be true if we have a related file object! In that
//              case, the full name is three part - device name relative to
//              org, related file name relative to device, and file name
//              relative to related file. However, in create.c,
//              DfsCommonCreate, we manipulate file objects so all opens look
//              like "non-relative" opens. If one changes that code, then
//              this function must be changed to correspond.
//
//-----------------------------------------------------------------------------

VOID
DnrComposeFileName(
    OUT PUNICODE_STRING FullName,
    IN  PDFS_VCB            Vcb,
    IN  PFILE_OBJECT RelatedFile,
    IN  PUNICODE_STRING FileName
)
{
    PUNICODE_STRING   LogRootPrefix = &(Vcb->LogRootPrefix);

    ASSERT(FullName->MaximumLength >= FileName->Length + LogRootPrefix->Length);
    ASSERT(FullName->Length == 0);
    ASSERT(FullName->Buffer != NULL);

    if ((LogRootPrefix->Length > 0) && (RelatedFile == NULL)) {
        RtlMoveMemory(FullName->Buffer, LogRootPrefix->Buffer,
                      LogRootPrefix->Length);
        FullName->Length = LogRootPrefix->Length;
    } else {
        FullName->Buffer[0] = UNICODE_PATH_SEP;
        FullName->Length = sizeof(UNICODE_PATH_SEP);
    }

    DnrConcatenateFilePath(
        FullName,
        FileName->Buffer,
        FileName->Length);

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrCaptureCredentials
//
//  Synopsis:   Captures the credentials to use for Dnr.
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT record describing the Dnr.
//
//  Returns:    Nothing -- The DnrContext is simply updated.
//
//-----------------------------------------------------------------------------

VOID
DnrCaptureCredentials(
    IN OUT PDNR_CONTEXT DnrContext)
{

#ifdef TERMSRV
    NTSTATUS Status;
    ULONG SessionID;
#endif // TERMSRV

    LUID LogonID;

    DfsDbgTrace(+1, Dbg, "DnrCaptureCredentials: Enter [%wZ] \n", &DnrContext->FileName);
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    DfsGetLogonId( &LogonID );

#ifdef TERMSRV

    Status = TSGetRequestorSessionId( DnrContext->OriginalIrp, & SessionID );

    ASSERT( NT_SUCCESS( Status ) ) ;

    if( NT_SUCCESS( Status ) ) {
        DnrContext->Credentials = DfsLookupCredentials( &DnrContext->FileName, SessionID, &LogonID  );
    }
    else {
        DnrContext->Credentials = NULL;
    }

#else // TERMSRV

    DnrContext->Credentials = DfsLookupCredentials( &DnrContext->FileName, &LogonID );

#endif // TERMSRV


    if (DnrContext->Credentials != NULL)
        DnrContext->Credentials->RefCount++;

    ExReleaseResourceLite( &DfsData.Resource );
    DfsDbgTrace(-1, Dbg, "DnrCaptureCredentials: Exit. Creds %x\n", DnrContext->Credentials);

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrReleaseCredentials
//
//  Synopsis:   Releases the credentials captured by DnrCaptureCredentials
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT into which credentials were
//                      captured.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DnrReleaseCredentials(
    IN PDNR_CONTEXT DnrContext)
{
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    if (DnrContext->Credentials != NULL)
        DnrContext->Credentials->RefCount--;

    ExReleaseResourceLite( &DfsData.Resource );

}


//+-------------------------------------------------------------------
//
//  Function:   DnrRedirectFileOpen, local
//
//  Synopsis:   This routine redirects a create IRP request to the specified
//              provider by doing an IoCallDriver to the device object for
//              which the file open is destined. This routine takes care of
//              converting the FileObject's name from the Dfs namespace to
//              the underlying file system's namespace.
//
//  Arguments:  [DnrContext] -- The context block for the DNR.  All
//                      parameters for the operation will be taken from
//                      here.
//
//  Returns:    [STATUS_DEVICE_OFF_LINE] -- The service for the volume
//                      is currently off line.
//
//              [STATUS_DEVICE_NOT_CONNECTED] -- The storage for the volume
//                      is not available at this time. Might have been blown
//                      off by a format etc.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate room
//                      for the file name that the provider for this volume
//                      understands.
//
//              [STATUS_PENDING] -- If the underlying file system returned
//                      STATUS_PENDING.
//
//              Any other NTSTATUS that the underlying file system returned.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS
DnrRedirectFileOpen (
    IN PDNR_CONTEXT DnrContext
) {
    PIRP Irp = DnrContext->OriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION NextIrpSp = NULL;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PDFS_VCB Vcb = DnrContext->Vcb;
    NTSTATUS Status;
    UNICODE_STRING fileName;
    ULONG CreateOptions;
    PPROVIDER_DEF pProvider;
    UNICODE_STRING ProviderDeviceName;

    DfsDbgTrace(+1, Dbg, "DnrRedirectFileOpen: Entered\n", 0);

    MUP_TRACE_NORM(DNR, DnrRedirectFileOpen_Entry,
		   LOGPTR(DnrContext->OriginalIrp)
		   LOGUSTR(DnrContext->FileName));
    //
    // If this is a csc agent open, force the open to the LanManRedirector,
    // as this is the only redirector that works with csc.
    //


    DNR_SET_TARGET_INFO( DnrContext, DnrContext->pPktEntry );

    DnrContext->DfsNameContext.pLMRTargetInfo =  NULL;
    DnrContext->DfsNameContext.pDfsTargetInfo = NULL;

    if (DnrContext->pDfsTargetInfo != NULL) {
        if (DnrContext->pDfsTargetInfo->DfsHeader.Flags & TARGET_INFO_DFS)
        {
            DnrContext->DfsNameContext.pDfsTargetInfo = 
                (PVOID)&DnrContext->pDfsTargetInfo->TargetInfo;
        }
        else {
            DnrContext->DfsNameContext.pLMRTargetInfo = 
                (PVOID)&DnrContext->pDfsTargetInfo->LMRTargetInfo;
        }
    }


    if (
        (DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME)
            &&
        (DnrContext->pService->Type & DFS_SERVICE_TYPE_DOWN_LEVEL)
    ) {
        RtlInitUnicodeString(&ProviderDeviceName, DD_NFS_DEVICE_NAME_U);
        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );
        Status = DfsGetProviderForDevice(
                    &ProviderDeviceName,
                    &DnrContext->pProvider);
        if (NT_SUCCESS( Status )) {
            DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
            if (MupVerbose)
                DbgPrint("  CSCAGENT:Provider Device [%wZ] -> [%wZ]\n",
                     &DnrContext->TargetDevice->DriverObject->DriverName,
                     &DnrContext->pProvider->DeviceObject->DriverObject->DriverName);
            DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
            DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
            DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);
        } else {
            DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
            ExReleaseResourceLite( &DfsData.Resource );
            DnrReleaseAuthenticatedConnection(DnrContext);
            DnrContext->FinalStatus = STATUS_BAD_NETWORK_PATH;
            DnrContext->State = DnrStateDone;
            return(STATUS_BAD_NETWORK_PATH);
        }
        ExReleaseResourceLite( &DfsData.Resource );
    }

    //
    // Prepare to hand of the open request to the next driver. We
    // must give it a name that it will understand; so, we save the original
    // file name in the DnrContext in case we need to restore it in the
    // event of a failure.
    //

    DnrContext->SavedFileName = FileObject->FileName;
    DnrContext->SavedRelatedFileObject = FileObject->RelatedFileObject;

    ASSERT( DnrContext->SavedFileName.Buffer != NULL );

    //
    //  Create the full path name to be opened from the target device
    //  object.
    //

    fileName.MaximumLength =
                    DnrContext->pService->Address.Length +
                    DnrContext->pPktEntry->Id.Prefix.Length +
                    sizeof (WCHAR) +
                    DnrContext->RemainingPart.Length;

    fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' puM');

    if (fileName.Buffer == NULL) {
        DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
        DnrReleaseAuthenticatedConnection(DnrContext);
        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        DnrContext->State = DnrStateDone;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (DnrContext->pService->Address.Buffer)   {

        RtlMoveMemory( fileName.Buffer,
                   DnrContext->pService->Address.Buffer,
                   DnrContext->pService->Address.Length
                   );
        fileName.Length = DnrContext->pService->Address.Length;

    } else {

        fileName.Buffer[0] = UNICODE_PATH_SEP;
        fileName.Length = sizeof(WCHAR);

    }

    //
    //  If we are supposed to strip the prefix, do it now.
    //

    if (!(DnrContext->pService->Capability & PROV_STRIP_PREFIX)) {

        DnrConcatenateFilePath(
            &fileName,
            DnrContext->pPktEntry->Id.Prefix.Buffer,
            DnrContext->pPktEntry->Id.Prefix.Length);

    }

    if (DnrContext->RemainingPart.Length > 0) {

        DnrConcatenateFilePath(
            &fileName,
            DnrContext->RemainingPart.Buffer,
            DnrContext->RemainingPart.Length);

    }

    DnrContext->NewNameLen = fileName.Length;

    //
    //  Attempt to open the file.  Copy all of the information
    //  from the create IRP we received.
    //

    DfsDbgTrace( 0, Dbg, "Attempt to open %wZ\n", &fileName );

    //
    // Copy the stack from one to the next...
    //

    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    (*NextIrpSp) = (*IrpSp);

    CreateOptions = IrpSp->Parameters.Create.Options;

    // Update the type of open in the DfsNameContext

    if (DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) {
#if DBG
        if (MupVerbose)
            DbgPrint("  FsContext = DFS_CSCAGENT_NAME_CONTEXT\n");
#endif
        DnrContext->DfsNameContext.NameContextType = DFS_CSCAGENT_NAME_CONTEXT;
    } else {
#if DBG
        if (MupVerbose)
            DbgPrint("  FsContext = DFS_USER_NAME_CONTEXT\n");
#endif
        DnrContext->DfsNameContext.NameContextType = DFS_USER_NAME_CONTEXT;
    }


    FileObject->FsContext = &(DnrContext->DfsNameContext);

    if (DnrContext->pProvider->fProvCapability & PROV_DFS_RDR) {

        //
        // We are connecting to a dfs-aware server. Indicate this to the
        // redirector.
        //

        FileObject->FsContext2 = UIntToPtr(DFS_OPEN_CONTEXT);

    } else {

        //
        // We are connecting to a downlevel server. Indicate to the redirector
        // that Dfs is trying a downlevel access.
        //

        FileObject->FsContext2 = UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT);

    }


    NextIrpSp->Parameters.Create.Options = CreateOptions;

    FileObject->RelatedFileObject = NULL;
    FileObject->FileName = fileName;

    IoSetCompletionRoutine(
        Irp,
        DnrCompleteFileOpen,
        DnrContext,
        TRUE,
        TRUE,
        TRUE);

    //
    // Now, we are going to pass the buck to the provider for this volume.
    // This can potentially go over the net. To avoid needless contentions,
    // we release the Pkt.
    //

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );

    InterlockedIncrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
    {
        LONG Count;
        Count = InterlockedIncrement(&DnrContext->pService->pMachEntry->UseCount);
        if (Count < DnrContext->pService->pMachEntry->SvcUseCount)
        {
            DbgPrint("DnrContext %x, 1\n", DnrContext);
            DfsDbgBreakPoint;
        }
    }

#else
    InterlockedIncrement(&DnrContext->pService->pMachEntry->UseCount);
#endif

    DnrContext->FcbToUse->DfsMachineEntry = DnrContext->pService->pMachEntry;
    DnrContext->FcbToUse->TargetDevice =    DnrContext->TargetDevice;
    DnrContext->FcbToUse->ProviderId   =    DnrContext->ProviderId;


    PktRelease();
    DnrContext->ReleasePkt = FALSE;

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrRedirectFileOpen of [%wZ(%wZ):0x%x] to [%wZ]\n",
                    &fileName,
                    &DnrContext->DfsNameContext.UNCFileName,
                    DnrContext->DfsNameContext.Flags,
                    &DnrContext->TargetDevice->DriverObject->DriverName);
#endif

    MUP_TRACE_NORM(DNR, DnrRedirectFileOpen_BeforeIoCallDriver,
		   LOGPTR(Irp)
		   LOGUSTR(DnrContext->FileName)
		   LOGUSTR(DnrContext->TargetDevice->DriverObject->DriverName));

    Status = IoCallDriver(DnrContext->TargetDevice, Irp);
    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrRedirectFileOpen_Error_IoCallDriver,
                         LOGSTATUS(Status)
			 LOGPTR(Irp)
                         LOGPTR(FileObject)
                         LOGPTR(DnrContext));
    
    if (Status != STATUS_PENDING) {

        DnrContext->State = DnrStatePostProcessOpen;

    }

    DfsDbgTrace( 0, Dbg, "IoCallDriver Status = %8lx\n", ULongToPtr(Status));

    DfsDbgTrace(-1, Dbg, "DnrRedirectFileOpen: Exit -> %x\n", ULongToPtr(Status));

    return(Status);

}


//+-------------------------------------------------------------------
//
//  Function:   DnrPostProcessFileOpen, local
//
//  Synopsis:   This routine picks up where DnrRedirectFileOpen left off.
//              It figures out what the underlying file system returned
//              in response to our IoCallDriver, and resumes DNR from there.
//
//  Arguments:  [DnrContext] -- The context block for the DNR.  All
//                      parameters for the operation will be taken from
//                      here.
//
//  Returns:    NTSTATUS - The status of the operation.
//
//--------------------------------------------------------------------

ULONG StopOnError = 0;

NTSTATUS
DnrPostProcessFileOpen(
    IN PDNR_CONTEXT DnrContext)
{
    NTSTATUS Status;
    PDFS_VCB Vcb = DnrContext->Vcb;
    PIRP Irp = DnrContext->OriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    LARGE_INTEGER EndTime;


    DfsDbgTrace( +1, Dbg, "DnrPostProcessFileOpen Entered: DnrContext = %08lx\n",
                DnrContext );


    Status = DnrContext->FinalStatus;

    if ((Status == STATUS_LOGON_FAILURE) || (Status == STATUS_ACCESS_DENIED))
    {
        if (MupVerbose)
        {
            DbgPrint("File %wZ, (%wZ), Status %x\n",
                     &DnrContext->ContextFileName, &FileObject->FileName, Status);
            DbgPrint("Context used was %x, %x\n", DnrContext->DfsNameContext.pDfsTargetInfo,
                     DnrContext->DfsNameContext.pLMRTargetInfo );
            DbgPrint("Driver is %wZ\n", &DnrContext->TargetDevice->DriverObject->DriverName);
        }
    }
             
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrPostProcessFileOpen entered [%wZ] Status = 0x%x\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                    &FileObject->FileName,
                    Status);
    }
#endif

    if ( Status == STATUS_REPARSE ) {

        //
        // This may have been an open sent to the MUP, who is now returning a status
        // reparse. Figure out the name of the device that this is being
        // reparsed to, create (if needed) a PROVIDER_DEF for this new device,
        // and retry DnrRedirectFileOpen. Also, update the service
        // structure to point to this new provider.
        //

        //
        // If the device is not mup, clean out any child entries for the pkt
        // entry that represents the root of the dfs, then stop dnr with
        // STATUS_REPARSE
        //

        PDFS_PKT_ENTRY pEntry;
        UNICODE_STRING ProviderDevice;
        UNICODE_STRING MupDeviceName;
        UNICODE_STRING FileName;
        UNICODE_STRING RemPath;
        USHORT i, j;

        DfsDbgTrace(0, Dbg, "Processing STATUS_REPARSE...\n", 0);

        ProviderDevice = FileObject->FileName;

        RtlInitUnicodeString(&MupDeviceName, L"\\FileSystem\\Mup");

#if DBG
        if (MupVerbose)
            DbgPrint("  Comparing [%wZ] to [%wZ]\n", 
                    &DnrContext->TargetDevice->DriverObject->DriverName,
                    &MupDeviceName);
#endif

        if ( RtlCompareUnicodeString(
                &DnrContext->TargetDevice->DriverObject->DriverName,
                &MupDeviceName,
                TRUE) != 0
        ) {

            //
            // This is *not* the mup returning REPARSE
            //

            FileName = DnrContext->FileName;

            //
            // We want to work with the \Server\Share part of the FileName only,
            // so count up to 3 backslashes, then stop.
            //

            for (i = j = 0; i < FileName.Length/sizeof(WCHAR) && j < 3; i++) {

                if (FileName.Buffer[i] == UNICODE_PATH_SEP) {

                    j++;

                }

            }

            FileName.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

#if DBG
            if (MupVerbose)
                DbgPrint("  Will remove all children of [%wZ]\n", &FileName);
#endif

            PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

            //
            // Now find the pkt entry
            //

            pEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &FileName,
                        &RemPath);

            //
            // And remove all children
            //

            if (pEntry != NULL) {

                PktFlushChildren(pEntry);

            }

            PktRelease();
            DnrContext->ReleasePkt = FALSE;

            DnrContext->GotReparse = TRUE;
            DnrContext->State = DnrStateDone;
            Status = STATUS_REPARSE;

        } else {

            //
            //  This is the mup returning REPARSE
            //

            //
            // We want to work with the \Device\Driver part of the ProviderDevice only,
            // so count up to 3 backslashes, then stop.
            //

            for (i = j = 0; i < ProviderDevice.Length/sizeof(WCHAR) && j < 3; i++) {

                if (ProviderDevice.Buffer[i] == UNICODE_PATH_SEP) {

                    j++;

                }

            }

            ProviderDevice.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

            DfsDbgTrace(0, Dbg, "Provider Device is [%wZ]\n", &ProviderDevice);

            ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

            Status = DfsGetProviderForDevice(
                        &ProviderDevice,
                        &DnrContext->pProvider);

            if (NT_SUCCESS( Status )) {

                DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->State = DnrStateSendRequest;

            } else {

                if (DnrContext->FinalStatus != STATUS_REPARSE) {
                    DnrContext->FinalStatus = Status;
                }
                DnrContext->State = DnrStateDone;

            }

            ExReleaseResourceLite( &DfsData.Resource );

        }

        ASSERT(DnrContext->ReleasePkt == FALSE);

        //
        // Set active service only if we're going to
        // continue DNR, and the USN hasn't changed.
        //
        // The exit code (see comment at end) will restart DNR if the USN
        // has changed.
        //

        if (NT_SUCCESS( Status )) {

            PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

            if (DnrContext->USN == DnrContext->pPktEntry->USN) {

                ReplSetActiveService(DnrContext->pPktEntry,
                                    DnrContext->RSelectContext);

                DnrContext->pService->ProviderId =
                    DnrContext->pProvider->eProviderId;

                DnrContext->pService->pProvider = DnrContext->pProvider;
            }

            PktConvertExclusiveToShared();

        } else {
            if (Status == STATUS_FS_DRIVER_REQUIRED) {
                Status = STATUS_REPARSE;
            }

            DnrContext->FinalStatus = Status;
            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

        }

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
        {
            LONG Count;
            Count = InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
            if (Count < DnrContext->FcbToUse->DfsMachineEntry->SvcUseCount)
            {
                DbgPrint("DnrContext %x, 2\n", DnrContext);
                DfsDbgBreakPoint;
            }
        }
#else

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
#endif

        DfsDbgTrace(0, Dbg, "State after Reparse is %d\n", DnrContext->State);

    }
    else if (( Status == STATUS_LOGON_FAILURE ) || (Status == STATUS_ACCESS_DENIED))
    {
        UNICODE_STRING ProviderDeviceName;
        UNICODE_STRING MupDeviceName;
        UNICODE_STRING ProviderDevice;
        BOOLEAN ReturnError = FALSE;

        NTSTATUS SavedStatus = Status;

        ProviderDevice = FileObject->FileName;
        RtlInitUnicodeString(&MupDeviceName, L"\\FileSystem\\Mup");

        if ( RtlCompareUnicodeString(
                &DnrContext->TargetDevice->DriverObject->DriverName,
                &MupDeviceName,
                TRUE) == 0 )
        {

            RtlInitUnicodeString(&ProviderDeviceName, DD_NFS_DEVICE_NAME_U);
            ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

            Status = DfsGetProviderForDevice( &ProviderDeviceName,
                                              &DnrContext->pProvider);

            if (Status == STATUS_SUCCESS) {
                DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->State = DnrStateSendRequest;
            }
            ExReleaseResourceLite( &DfsData.Resource );
            if (Status == STATUS_SUCCESS)
            {
                PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

                if (DnrContext->USN == DnrContext->pPktEntry->USN) {

                    ReplSetActiveService(DnrContext->pPktEntry,
                                         DnrContext->RSelectContext);

                    DnrContext->pService->ProviderId =
                        DnrContext->pProvider->eProviderId;

                    DnrContext->pService->pProvider = DnrContext->pProvider;
                }

                PktConvertExclusiveToShared();

            }
        }

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);

        if (Status != STATUS_SUCCESS)
        {
            DnrContext->FinalStatus = SavedStatus;
            DnrContext->State = DnrStateDone;

            ExFreePool( FileObject->FileName.Buffer );
            FileObject->FileName = DnrContext->SavedFileName;
            FileObject->RelatedFileObject = DnrContext->SavedRelatedFileObject;
        }
    }
     else if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {

        //
        // This was an open sent to a downlevel server\share that failed
        // because the server happens to be in a Dfs itself. If so, we
        // simply change the name on which we are doing DNR and restart DNR.
        //

        DfsDbgTrace(0, Dbg, "Downlevel access found inter-dfs link!\n", 0);

        DfsDbgTrace(
            0, Dbg, "Current File name is [%wZ]\n", &FileObject->FileName);

        ASSERT(DnrContext->ReleasePkt == FALSE);
        PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

        //
        // Bug: 332061. do not mark it as outside my dom.
        //
        // DnrContext->pPktEntry->Type |= PKT_ENTRY_TYPE_OUTSIDE_MY_DOM;

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
        {
            LONG Count;
            Count = InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
            if (Count < DnrContext->FcbToUse->DfsMachineEntry->SvcUseCount)
            {
                DbgPrint("DnrContext %x, 3\n", DnrContext);
            DfsDbgBreakPoint;
            }
        }
#else

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);

#endif
        DnrContext->RemainingPart.Length = 0;
        DnrContext->RemainingPart.MaximumLength = 0;
        DnrContext->RemainingPart.Buffer = 0;

        DnrRebuildDnrContext(
            DnrContext,
            &FileObject->FileName,
            &DnrContext->RemainingPart);

        ExFreePool(FileObject->FileName.Buffer);
        FileObject->FileName = DnrContext->SavedFileName;
        FileObject->RelatedFileObject = DnrContext->SavedRelatedFileObject;


    } else if ( NT_SUCCESS( Status ) ) {

        PDFS_FCB Fcb;
        DfsDbgTrace( 0, Dbg, "Open attempt succeeded\n", 0 );

        ASSERT( (DnrContext->FileName.Length & 0x1) == 0 );

        Fcb = DnrContext->FcbToUse;
        DnrContext->FcbToUse = NULL;

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        Fcb->TargetDevice = DnrContext->TargetDevice;
        Fcb->ProviderId = DnrContext->ProviderId;

        //
        // If we file (dir) happens to be a junction point, we capture its
        // alternate name from the Pkt Entry, so we can field requests for
        // FileAlternateNameInformation.
        //

        if (DnrContext->RemainingPart.Length == 0) {

            UNICODE_STRING allButLast;
            USHORT UseLength;

            RemoveLastComponent(
                &DnrContext->pPktEntry->Id.ShortPrefix,
                &allButLast);

            //
            // 587769: Set alternate path only if we have enough
            // space in target buffer.
            //


            UseLength = DnrContext->pPktEntry->Id.ShortPrefix.Length -
                        allButLast.Length;

            if (Fcb->AlternateFileName.MaximumLength > UseLength)
            {
                Fcb->AlternateFileName.Length = UseLength;

                RtlCopyMemory(
                    Fcb->AlternateFileName.Buffer,
                    &DnrContext->pPktEntry->Id.ShortPrefix.Buffer[allButLast.Length/sizeof(WCHAR)],
                    Fcb->AlternateFileName.Length);

                DfsDbgTrace(
                    0, Dbg, "Captured alternate name [%wZ]\n",
                    &Fcb->AlternateFileName);
            }

        }

        InterlockedIncrement(&Fcb->Vcb->OpenFileCount);

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

        if (DnrContext->USN == DnrContext->pPktEntry->USN) {
            ReplSetActiveService(DnrContext->pPktEntry,
                                DnrContext->RSelectContext);
        }

        //
        // Reset the life time since we just used this PKT entry successfully.
        //

        DnrContext->pPktEntry->ExpireTime = DnrContext->pPktEntry->TimeToLive;

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        PktConvertExclusiveToShared();

        DnrContext->FinalStatus = Status;
        DnrContext->State = DnrStateDone;

        ExFreePool( DnrContext->SavedFileName.Buffer );

    } else {    // ! NT_SUCCESS( Status ) on IoCallDriver

        DfsDbgTrace( 0, Dbg, "Open attempt failed %8lx\n", ULongToPtr(Status) );

        if (Status == STATUS_PATH_NOT_COVERED || Status == STATUS_DFS_EXIT_PATH_FOUND) {

            if (DnrContext->GotReferral) {

                //
                // We just got a referral, and the server is saying
                // path_not_covered. Means DC and server are out
                // of sync.  Inform the DC
                //

                DfsDbgTrace(0, Dbg, "Dnr: Knowledge inconsistency discovered %wZ\n",
                                        &FileObject->FileName);
                (VOID) DfsTriggerKnowledgeVerification( DnrContext );

                //
                // If we never found an inconsistency let us now
                // go back and try to see if we got this fixed.
                // We won't be in an endless loop since we will
                // not do this more than once.
                //
                if (DnrContext->FoundInconsistency == FALSE)  {
                    DnrContext->State = DnrStateGetFirstReplica;
                    DnrContext->FoundInconsistency = TRUE;
                } else
                    DnrContext->State = DnrStateGetNextReplica;
            } else {
                DnrContext->State = DnrStateGetFirstDC;
            }

        } else if (ReplIsRecoverableError( Status )) {

            //
            // Check to see if the error returned was something worth
            // trying a replica for.
            //
            DnrContext->State = DnrStateGetNextReplica;
#if DBG
            if (MupVerbose)
                DbgPrint("  Recoverable error 0x%x State = DnrStateGetNextReplica\n", Status);
#endif
        }
        else if ((Status == STATUS_OBJECT_PATH_NOT_FOUND) && 
                 (DnrContext->RemainingPart.Length == 0)) {

            //
            // if we hit a PATH_NOT_FOUND at the root, it usually means
            // that we have hit a machine that is no longer the root.
            // If there is only one target, mark it as expired.
            // otherwise, move on to the other targets.
            //

            if (DnrContext->pPktEntry->Info.ServiceCount > 1)
            {
                DnrContext->State = DnrStateGetNextReplica;
            }
            else
            {
                DnrContext->pPktEntry->ExpireTime = 0;
                DnrContext->FinalStatus = Status;
                DnrContext->State = DnrStateDone;
            }
        } else {

            DnrContext->FinalStatus = Status;
            DnrContext->State = DnrStateDone;

#if DBG
            if (MupVerbose)
                DbgPrint("  NON-Recoverable error 0x%x State = DnrStateDone\n", Status);
#endif

        }

        if (DfsEventLog > 0) {
            UNICODE_STRING puStr[2];

            if (!DnrContext->ReleasePkt)
                PktAcquireShared( TRUE, &DnrContext->ReleasePkt );
            if (DnrContext->USN == DnrContext->pPktEntry->USN) {
                puStr[0] = FileObject->FileName;
                puStr[1] = DnrContext->pService->Name;
                LogWriteMessage(DFS_OPEN_FAILURE, Status, 2, puStr);
            }
        }

        //
        // In either case, we are going back into DNR.  Let's acquire shared
        // access to Pkt.  We had released the Pkt just before doing the
        // IoCallDriver.
        //

        if (!DnrContext->ReleasePkt)
            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
        {
            LONG Count;
            Count = InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
            if (Count < DnrContext->FcbToUse->DfsMachineEntry->SvcUseCount)
            {
                DbgPrint("DnrContext %x, 4\n", DnrContext);
                DfsDbgBreakPoint;
            }
        }
#else

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);

#endif

        ExFreePool( FileObject->FileName.Buffer );
        FileObject->FileName = DnrContext->SavedFileName;
        FileObject->RelatedFileObject = DnrContext->SavedRelatedFileObject;
    }

    //
    // One last thing. If we are going back into DNR for whatever reason,
    // check to see if the PktEntry we captured in the DNR_CONTEXT has
    // changed. If so, we'll simply have to restart.
    //

    if (DnrContext->State != DnrStateDone &&
            DnrContext->pPktEntry != NULL &&
                DnrContext->pPktEntry->USN != DnrContext->USN) {

        DnrContext->State = DnrStateStart;

    }

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrPostProcessFileOpen Exited: Status = %08lx State = %d\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        Status,
                        DnrContext->State);
    }
#endif

    DfsDbgTrace( -1, Dbg, "DnrPostProcessFileOpen Exited: Status = %08lx\n",
                ULongToPtr(Status) );
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DnrGetAuthenticatedConnection
//
//  Synopsis:   If this Dnr is using user-supplied credentials, this routine
//              will setup a tree connection using the user-supplied
//              credentials.
//
//  Notes:      This routine might free and reacquire the Pkt lock. This
//              means that the Pkt entry referenced in DnrContext might
//              become invalid after this call. The caller is assumed to
//              have cached and referenced everything she will need to
//              use in DnrContext before making this call.
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT record for this Dnr
//
//  Returns:    [STATUS_SUCCESS] -- Operation completed successfully
//
//              NT Status from the attempt to create the tree connection
//
//-----------------------------------------------------------------------------


NTSTATUS
DnrGetAuthenticatedConnection(
    IN OUT PDNR_CONTEXT DnrContext)
{
    NTSTATUS Status;
    PDFS_SERVICE pService = DnrContext->pService;
    BOOLEAN fDoConnection = TRUE;
    LARGE_INTEGER EndTime;

    PFILE_OBJECT TreeConnFileObj = NULL;

    DfsDbgTrace(+1, Dbg, "DnrGetAuthenticatedConnection: Entered\n", 0);

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrGetAuthenticatedConnection(\\%wZ)\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        &pService->Address);
    }
#endif

    ASSERT(DnrContext->pService != NULL);
    ASSERT(DnrContext->pProvider != NULL);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    //
    // See if we are using supplied credentials
    //

    if (DnrContext->Credentials == NULL) {

        DfsDbgTrace(-1, Dbg,
            "DnrGetAuthenticatedConnection: Dnr with no creds\n", 0);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DnrGetAuthenticatedConnection: No creds exit STATUS_SUCCESS\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
        }
#endif
	ExReleaseResourceLite( &DfsData.Resource );
        return( STATUS_SUCCESS );
    }

    //
    // See if this is a credential record describing the use of default
    // credentials
    //

    if (DnrContext->Credentials->EaLength == 0) {

        DfsDbgTrace(-1, Dbg,
            "DnrGetAuthenticatedConnection: Dnr with default creds\n", 0);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DnrGetAuthenticatedConnection: Default creds exit STATUS_SUCCESS\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
        }
#endif
	ExReleaseResourceLite( &DfsData.Resource );
        return( STATUS_SUCCESS );

    }

    //
    // See if we already have a authenticated connection to the server, and
    // the authenticated connection was established using the credentials
    // we want to use.
    //

    if (pService->pMachEntry->AuthConn != NULL) {

        if (
            (DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0
                &&
            pService->pMachEntry->Credentials == DnrContext->Credentials
         ) {

            DnrContext->AuthConn = pService->pMachEntry->AuthConn;
            DFS_REFERENCE_OBJECT( DnrContext->AuthConn );
            fDoConnection = FALSE;
            DfsDbgTrace(0, Dbg,
                "Using existing tree connect %08lx\n", DnrContext->AuthConn);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("  [%d] Using existing tree connect\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            Status = STATUS_SUCCESS;

        } else {

            DfsDbgTrace(0, Dbg,
                "Deleting connect %08lx\n", pService->pMachEntry->AuthConn);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("  [%d] Deleting tree connect connect\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            TreeConnFileObj = pService->pMachEntry->AuthConn;

            pService->pMachEntry->AuthConn = NULL;
            pService->pMachEntry->Credentials->RefCount--;
            pService->pMachEntry->Credentials = NULL;
            if (pService->ConnFile != NULL)
                DfsCloseConnection( pService );

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    //
    // We delete the tree connection after releasing the resource, since
    // the delete involve a call to a lower level driver and we want to 
    // avoid resource lock conflicts.
    //
    if (TreeConnFileObj) {
	    DfsDeleteTreeConnection( TreeConnFileObj, USE_FORCE );
    }

    //
    // If we need to establish a new authenticated connection, do it now.
    // We need a new connection because either we had none, or the one we
    // had was using a different set of credentials.
    //

    if (fDoConnection) {

        UNICODE_STRING shareName;
        HANDLE treeHandle;
        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK ioStatusBlock;
        USHORT i, k;

        //
        // Compute the share name...
        //

        shareName.MaximumLength =
            sizeof(DD_NFS_DEVICE_NAME_U) +
                    pService->Address.Length;

        shareName.Buffer = ExAllocatePoolWithTag(PagedPool, shareName.MaximumLength, ' puM');

        if (shareName.Buffer != NULL) {

            shareName.Length = 0;

            RtlAppendUnicodeToString(
                &shareName,
                DD_NFS_DEVICE_NAME_U);

            RtlAppendUnicodeStringToString(&shareName, &pService->Address);

            //
            // One can only do tree connects to server\share. So, in case
            // pService->Address refers to something deeper than the share,
            // make sure we setup a tree-conn only to server\share. Note that
            // by now, shareName is of the form
            // \Device\LanmanRedirector\server\share<\path>. So, count up to
            // 4 slashes and terminate the share name there.
            //

            for (i = 0, k = 0;
                    i < shareName.Length/sizeof(WCHAR) && k < 5;
                        i++) {

                if (shareName.Buffer[i] == UNICODE_PATH_SEP)
                    k++;
            }

            shareName.Length = i * sizeof(WCHAR);
            if (k == 5)
                shareName.Length -= sizeof(WCHAR);

            InitializeObjectAttributes(
                &objectAttributes,
                &shareName,
                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                NULL,
                NULL);

            DfsDbgTrace(0, Dbg, "Tree connecting to %wZ\n", &shareName);
            DfsDbgTrace(0, Dbg,
                "Credentials @%08lx\n", DnrContext->Credentials);

            Status = ZwCreateFile(
                        &treeHandle,
                        SYNCHRONIZE,
                        &objectAttributes,
                        &ioStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ |
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_CREATE_TREE_CONNECTION |
                            FILE_SYNCHRONOUS_IO_NONALERT,
                        (PVOID) DnrContext->Credentials->EaBuffer,
                        DnrContext->Credentials->EaLength);

            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrGetAuthenticatedConnection_Error_ZwCreateFile,
                                 LOGSTATUS(Status));

#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("  [%d] Tree connect to [%wZ] returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        &shareName,
                        Status);
            }
#endif

            if (NT_SUCCESS(Status)) {

                PFILE_OBJECT fileObject;

                DfsDbgTrace(0, Dbg, "Tree connect succeeded\n", 0);

                //
                // 426184, need to check return code for errors.
                //
                Status = ObReferenceObjectByHandle(
                            treeHandle,
                            0,
                            NULL,
                            KernelMode,
                           (PVOID *)&fileObject,
                            NULL);
                MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrGetAuthenticatedConnection_Error_ObReferenceObjectByHandle,
                                     LOGSTATUS(Status));

                ZwClose( treeHandle );

                if (NT_SUCCESS(Status)) {
                    DnrContext->AuthConn = fileObject;
                }
            }

            if (NT_SUCCESS(Status)) {

                //
                // We have a new tree connect. Lets try to cache it for later
                // use. Note that the Pkt could have changed when we went out
                // over the net to establish the tree connect, so we cache
                // the tree connect only if the Pkt hasn't changed.
                //

                PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );
                ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

                if (DnrContext->USN == DnrContext->pPktEntry->USN) {

                    if (pService->pMachEntry->AuthConn == NULL) {

                        pService->pMachEntry->AuthConn = DnrContext->AuthConn;

                        DFS_REFERENCE_OBJECT( pService->pMachEntry->AuthConn );

                        pService->pMachEntry->Credentials =
                            DnrContext->Credentials;

                        pService->pMachEntry->Credentials->RefCount++;

                    }

                }

                ExReleaseResourceLite( &DfsData.Resource );

                DnrContext->ReleasePkt = FALSE;
                PktRelease();
            }

            ExFreePool( shareName.Buffer );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    DfsDbgTrace(-1, Dbg,
        "DnrGetAuthenticatedConnection: Exit %08lx\n", ULongToPtr(Status) );

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrGetAuthenticatedConnection exit 0x%x\n",
                (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                Status);
    }
#endif

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrReleaseAuthenticatedConnection
//
//  Synopsis:   Dereferences the authenticated connection we used during
//              Dnr.
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT record for this Dnr
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DnrReleaseAuthenticatedConnection(
    IN PDNR_CONTEXT DnrContext)
{
    if (DnrContext->AuthConn != NULL) {

        DFS_DEREFERENCE_OBJECT( DnrContext->AuthConn );

        DnrContext->AuthConn = NULL;

    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsBuildConnectionRequest
//
//  Synopsis:   Builds the file names necessary to setup an
//              authenticated connection to a server's IPC$ share.
//
//  Arguments:  [pService] -- Pointer to DFS_SERVICE describing server
//              [pProvider] -- Pointer to PROVIDER_DEF describing the
//                            provider to use to establish the connection.
//              [pShareName] -- Share name to open.
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsBuildConnectionRequest(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    OUT PUNICODE_STRING pShareName)
{
    ASSERT(pService != NULL);
    ASSERT(pProvider != NULL);

    RtlInitUnicodeString(pShareName, NULL);

    pShareName->Length = 0;

    pShareName->MaximumLength = pProvider->DeviceName.Length +
                                    sizeof(UNICODE_PATH_SEP_STR) +
                                        pService->Name.Length +
                                            sizeof(ROOT_SHARE_NAME);

    pShareName->Buffer = ExAllocatePoolWithTag(PagedPool, pShareName->MaximumLength, ' puM');

    if (pShareName->Buffer == NULL) {

        DfsDbgTrace(0, Dbg, "Unable to allocate pool for share name!\n", 0);

        pShareName->Length = pShareName->MaximumLength = 0;

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlAppendUnicodeStringToString( pShareName, &pProvider->DeviceName );

    RtlAppendUnicodeToString( pShareName, UNICODE_PATH_SEP_STR );

    RtlAppendUnicodeStringToString( pShareName, &pService->Name );

    RtlAppendUnicodeToString( pShareName, ROOT_SHARE_NAME );

    return( STATUS_SUCCESS );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFreeConnectionRequest
//
//  Synopsis:   Frees up the stuff allocated on a successful call to
//              DfsBuildConnectionRequest
//
//  Arguments:  [pShareName] -- Unicode string holding share name.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFreeConnectionRequest(
    IN OUT PUNICODE_STRING pShareName)
{

    if (pShareName->Buffer != NULL) {
        ExFreePool ( pShareName->Buffer );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateConnection -- Create a connection to a server
//
//  Synopsis:   DfsCreateConnection will attempt to create a connection
//              to some server's IPC$ share.
//
//  Arguments:  [pService] -- the Service entry, giving the server principal
//                            name
//              [pProvider] --
//
//              [CSCAgentCreate] -- TRUE if this is on behalf of CSC agent
//
//              [remoteHandle] -- This is where the handle is returned.
//
//  Returns:    NTSTATUS - the status of the operation
//
//  Notes:      The Pkt must be acquired shared before calling this! It will
//              be released and reacquired in this routine.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsCreateConnection(
    IN PDFS_SERVICE     pService,
    IN PPROVIDER_DEF    pProvider,
    IN BOOLEAN          CSCAgentCreate,
    OUT PHANDLE         remoteHandle
) {
    PFILE_FULL_EA_INFORMATION  EaBuffer;
    ULONG                      EaBufferLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING ShareName;
    NTSTATUS Status;
    BOOLEAN pktLocked;

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );
    ASSERT(pService != NULL);
    ASSERT(pProvider != NULL);

    Status = DfsBuildConnectionRequest(
                pService,
                pProvider,
                &ShareName);

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ShareName,                             // File Name
        OBJ_KERNEL_HANDLE,                      // Attributes
        NULL,                                   // Root Directory
        NULL                                    // Security
        );

    //
    // Create or open a connection to the server.
    //

    PktRelease();

    if (CSCAgentCreate) {
        EaBuffer = DfsData.CSCEaBuffer;
        EaBufferLength = DfsData.CSCEaBufferLength;
    } else {
        EaBuffer = NULL;
        EaBufferLength = 0;
    }

    Status = ZwCreateFile(
                    remoteHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    EaBuffer,
                    EaBufferLength);

    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCreateConnection_Error_ZwCreateFile,
                         LOGSTATUS(Status));
    PktAcquireShared( TRUE, &pktLocked );

    if ( NT_SUCCESS( Status ) ) {
        DfsDbgTrace(0, Dbg, "Created Connection Successfully\n", 0);
        Status = IoStatusBlock.Status;
    }

    DfsFreeConnectionRequest( &ShareName );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCloseConnection -- Close a connection to a server
//
//  Synopsis:   DfsCloseConnection will attempt to Close a connection
//              to some server.
//
//  Effects:    The file object referring to the the connection will be
//              closed.
//
//  Arguments:  [pService] - the Service entry, giving the server connection
//                      handle
//
//  Returns:    NTSTATUS - the status of the operation
//
//  History:    28 May 1992     Alanw   Created
//
//--------------------------------------------------------------------------


NTSTATUS
DfsCloseConnection(
    IN PDFS_SERVICE pService
)
{
    ASSERT( pService->ConnFile != NULL );

    ObDereferenceObject(pService->ConnFile);
    pService->ConnFile = NULL;
    InterlockedDecrement(&pService->pMachEntry->ConnectionCount);
    return STATUS_SUCCESS;
}



//+----------------------------------------------------------------------------
//
//  Function:   DnrBuildReferralRequest
//
//  Synopsis:   This routine builds all the necessary things to send
//              a referral request to a DC.
//
//  Arguments:  [pDnrContext] -- The context for building the referral.
//
//  Returns:    Pointer to an IRP that can be used to get a referral.
//
//-----------------------------------------------------------------------------

PIRP
DnrBuildReferralRequest(
    IN PDNR_CONTEXT DnrContext)
{
    PUCHAR pNameResBuf = NULL;
    PREQ_GET_DFS_REFERRAL pRef;
    PWCHAR ReferralPath;
    PPROVIDER_DEF  pProvider;
    PIRP pIrp = NULL;
    ULONG cbBuffer = 0;
    NTSTATUS Status;

    DfsDbgTrace(+1,Dbg, "DnrBuildReferralRequest Entered - DnrContext %08lx\n", DnrContext);

    cbBuffer = DnrContext->FileName.Length + sizeof(UNICODE_NULL) + sizeof(PREQ_GET_DFS_REFERRAL);

    if (DnrContext->ReferralSize > cbBuffer) {
        cbBuffer = DnrContext->ReferralSize;
    }
    else {
        DnrContext->ReferralSize = cbBuffer;
    }
    DfsDbgTrace(0, Dbg, "Referral Size = %d bytes\n", ULongToPtr(cbBuffer));

    pNameResBuf = ExAllocatePoolWithTag(NonPagedPool, cbBuffer, ' puM');

    if (pNameResBuf == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to allocate %d bytes\n", ULongToPtr(cbBuffer));
        return( NULL );

    }

    pRef = (PREQ_GET_DFS_REFERRAL) pNameResBuf;

    pRef->MaxReferralLevel = 3;

    ReferralPath = (PWCHAR) &pRef->RequestFileName[0];

    RtlMoveMemory(
        ReferralPath,
        DnrContext->FileName.Buffer,
        DnrContext->FileName.Length);

    ReferralPath[ DnrContext->FileName.Length/sizeof(WCHAR) ] = UNICODE_NULL;

    ASSERT( DnrContext->DCConnFile != NULL);

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrBuildReferrlRequest:ReferralPath=[%ws]\n", ReferralPath);
#endif




    Status = DnrGetTargetInfo( DnrContext );

    if (Status == STATUS_SUCCESS)
    {
        pIrp = DnrBuildFsControlRequest( DnrContext->DCConnFile,
                                         DnrContext,
                                         FSCTL_DFS_GET_REFERRALS,
                                         pNameResBuf,
                                         FIELD_OFFSET(REQ_GET_DFS_REFERRAL, RequestFileName) +
                                         (wcslen(ReferralPath) + 1) * sizeof(WCHAR),
                                         pNameResBuf,
                                         cbBuffer,
                                         DnrCompleteReferral );
        if (pIrp == NULL) {

            DfsDbgTrace(-1, Dbg, "DnrBuildReferralRequest: Unable to allocate Irp!\n", 0);
            ExFreePool(pNameResBuf);

        } else {
            DfsDbgTrace(-1, Dbg, "DnrBuildReferralRequest: returning %08lx\n", pIrp);
        }
    }
    return( pIrp );

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrInsertReferralAndResume
//
//  Synopsis:   This routine is queued as a work item from DnrComplete
//              referral and does the work of actually inserting the
//              referral and resuming DNR. We must not do this work
//              directly in DnrCompleteReferral because it operates at
//              raised IRQL.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DnrInsertReferralAndResume(
    IN PVOID Context)
{
    PIRP_CONTEXT  pIrpContext = (PIRP_CONTEXT) Context;
    PDNR_CONTEXT  DnrContext = (PDNR_CONTEXT) pIrpContext->Context;
    PIRP          Irp = pIrpContext->OriginatingIrp;
    PRESP_GET_DFS_REFERRAL pRefResponse;
    ULONG length, matchingLength;
    NTSTATUS status;
    LARGE_INTEGER EndTime;
    ULONG referralType = 0;
    NTSTATUS DiscardStatus;

    DfsDbgTrace(+1, Dbg, "DnrInsertReferralAndResume: Entered\n", 0);
    DfsDbgTrace(0, Dbg, "Irp          = %x\n", Irp    );
    DfsDbgTrace(0, Dbg, "Context      = %x\n", Context);

    ASSERT(DnrContext->State == DnrStateCompleteReferral);

    status = Irp->IoStatus.Status;
    length = (ULONG)Irp->IoStatus.Information;

    DfsDbgTrace(0, Dbg, "Irp->Status  = %x\n", ULongToPtr(status) );
    DfsDbgTrace(0, Dbg, "Irp->Length  = %x\n", ULongToPtr(length) );

    KeQuerySystemTime(&EndTime);

#if DBG
    if (MupVerbose)
        DbgPrint("  [%d] DnrInsertReferralAndResume entered for [%wZ] status = 0x%x\n",
                (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                &DnrContext->FileName,
                status);
#endif

    //
    // If the DC returned STATUS_BUFFER_OVERFLOW, the referral didn't fit in
    // the buffer we sent. Increase the buffer and retry the referral request
    // Since we are going to retry the request, we won't dereference the
    // provider's device object yet.
    //

    if (status == STATUS_BUFFER_OVERFLOW) {
        PULONG pcbSize;

	if (DnrContext->ReferralSize < MAX_REFERRAL_MAX) {
           DfsDbgTrace(0, Dbg, "Referral buffer was too small; retrying...\n", 0);
           DnrContext->ReferralSize = MAX_REFERRAL_MAX;
           DnrContext->State = DnrStateGetReferrals;

           //
           // Going back into Dnr. Reacquire the Pkt shared, and release the
           // PktReferralRequests semaphore, so we can go out again to get a
           // referral.
           //

           goto Cleanup;
       }
    }

    //
    // If we got an error and we were using a cached IPC$ connection,
    // close the cached IPC$ and retry the referral request.
    //

    if ( (DnrContext->CachedConnFile == TRUE) &&
         (status != STATUS_SUCCESS) ) {

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );
        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
        DnrContext->CachedConnFile = FALSE;
	if (DnrContext->pService->ConnFile != NULL) {
	  DfsCloseConnection(DnrContext->pService);
	}
        DnrContext->State = DnrStateGetReferrals;
        ExReleaseResourceLite( &DfsData.Resource );
        PktConvertExclusiveToShared();
        //
        // Going back into Dnr. Reacquire the Pkt shared, and release the
        // PktReferralRequests semaphore, so we can go out again to get a
        // referral.
        //
        goto Cleanup;
    }

    //
    // The referral request has terminated. Since we are done with the
    // provider, dereference its device object now.
    //

    DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);

    //
    // Next, handle the result of the Referral request. If we successfully
    // got a referral, then try to insert it into our Pkt.
    //

    if (NT_SUCCESS(status) && length != 0) {

        pRefResponse = (PRESP_GET_DFS_REFERRAL) Irp->AssociatedIrp.SystemBuffer;
        DfsDbgTrace(0, Dbg, "Irp->Buffer  = %x\n", pRefResponse );

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        status = PktCreateEntryFromReferral(
                        &DfsData.Pkt,
                        &DnrContext->FileName,
                        length,
                        pRefResponse,
                        PKT_ENTRY_SUPERSEDE,
                        DnrContext->pNewTargetInfo,
                        &matchingLength,
                        &referralType,
                        &DnrContext->pPktEntry);

        DNR_SET_TARGET_INFO( DnrContext, DnrContext->pPktEntry );

	if (status == STATUS_INVALID_USER_BUFFER) {
	  status = STATUS_BAD_NETWORK_NAME;
	}

        if (NT_SUCCESS(status) && DfsEventLog > 1) {
            UNICODE_STRING puStr[2];

            puStr[0] = DnrContext->FileName;
            puStr[1] = DnrContext->pService->Name;
            LogWriteMessage(DFS_REFERRAL_SUCCESS, status, 2, puStr);
        }

        if (NT_SUCCESS(status)) {

            UNICODE_STRING fileName;
            UNICODE_STRING RemPath;
            PDFS_PKT_ENTRY pEntry = NULL;
            PDFS_PKT_ENTRY pShortPfxEntry = NULL;
            PDFS_PKT Pkt;

            //
            // See if we have to remove an entry
            //

            pEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &DnrContext->FileName,
                        &RemPath);

            pShortPfxEntry = PktLookupEntryByShortPrefix(
                                &DfsData.Pkt,
				&DnrContext->FileName,
				&RemPath);

            if (pShortPfxEntry != NULL) {
                if ((pEntry == NULL) ||
		    (pShortPfxEntry->Id.Prefix.Length > pEntry->Id.Prefix.Length)) {
		  pEntry = pShortPfxEntry;
		}
	    }

            if (pEntry != NULL && pEntry != DnrContext->pPktEntry) {
	      

#if DBG
                if (MupVerbose)
                    DbgPrint("  DnrInsertReferralAndResume: Need to remove pEntry [%wZ]\n",
                            &pEntry->Id.Prefix);
#endif
                Pkt = _GetPkt();
                if ((pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) == 0) {
                    PktFlushChildren(pEntry);
                    if (pEntry->UseCount == 0) {
                        PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);
                    } else {
                        pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                        pEntry->ExpireTime = 0;
                        DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                        DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));
                    }
                }

            }

            //
            // At this point, we are essentially in the same state as we were
            // when we started DNR, except that we have one more Pkt entry to
            // match against. Continue with name resolution, after fixing up
            // DnrContext->RemainingPart to reflect the match with the new
            // PktEntry.
            //

            fileName = DnrContext->FileName;

            DnrContext->RemainingPart.Length =
                (USHORT) (fileName.Length - matchingLength);

            DnrContext->RemainingPart.MaximumLength =
                (USHORT) (fileName.MaximumLength - matchingLength);

            DnrContext->RemainingPart.Buffer =
                    &fileName.Buffer[ matchingLength/sizeof(WCHAR) ];

            DnrContext->GotReferral = TRUE;

            DnrContext->State = DnrStateStart;

        } else {

            DnrContext->FinalStatus = status;
            DnrContext->State = DnrStateDone;
        }

        PktConvertExclusiveToShared();

    } else if (status == STATUS_NO_SUCH_DEVICE) {

        UNICODE_STRING RemPath;
        PDFS_PKT_ENTRY pEntry = NULL;
        PDFS_PKT Pkt;
        BOOLEAN pktLocked;

        //
        // Check if there is a pkt entry (probably stale) that needs to be removed
        //
#if DBG
        if (MupVerbose) 
            DbgPrint("  DnrInsertReferralAndResume: remove PKT entry for \\%wZ\n",
                            &DnrContext->FileName);
#endif

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

        Pkt = _GetPkt();
#if DBG
        if (MupVerbose)
            DbgPrint("  Looking up %wZ\n", &DnrContext->FileName);
#endif
        pEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &DnrContext->FileName,
                        &RemPath);
#if DBG
        if (MupVerbose)
            DbgPrint("  pEntry=0x%x\n", pEntry);
#endif
        if (pEntry != NULL && (pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) == 0) {
            PktFlushChildren(pEntry);
            if (pEntry->UseCount == 0) {
                PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);
            } else {
                pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                pEntry->ExpireTime = 0;
                DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));
            }
        }

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->FinalStatus = status;
        DnrContext->State = DnrStateDone;

        PktConvertExclusiveToShared();

    } else if (ReplIsRecoverableError(status)) {

        DnrContext->State = DnrStateGetNextDC;

    } else if (status == STATUS_BUFFER_OVERFLOW) {

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->FinalStatus = status;

        DnrContext->State = DnrStateDone;

    }  else if (DnrContext->Attempts > 0) {

#if DBG
        if (MupVerbose)
            DbgPrint("  DnrInsertReferralAndResume restarting Attempts = %d\n",
                        DnrContext->Attempts);
#endif
        DnrContext->State = DnrStateStart;

    } else {

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->FinalStatus = status;

        DnrContext->State = DnrStateDone;

    }

    if ( !NT_SUCCESS(status) && DfsEventLog > 0) {
        UNICODE_STRING puStr[2];

        if (!DnrContext->ReleasePkt)
            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );
        if (DnrContext->USN == DnrContext->pPktEntry->USN) {
            puStr[0] = DnrContext->FileName;
            puStr[1] = DnrContext->pService->Name;
            LogWriteMessage(DFS_REFERRAL_FAILURE, status, 2, puStr);
        }
    }

Cleanup:

    //
    // Cleanup referral stuff.
    //

    if (Irp->UserBuffer && Irp->UserBuffer != Irp->AssociatedIrp.SystemBuffer)
        ExFreePool( Irp->UserBuffer );
    if (Irp->AssociatedIrp.SystemBuffer) {
        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp(Irp);
    PktReleaseTargetInfo( DnrContext->pNewTargetInfo );
    DnrContext->pNewTargetInfo = NULL;
    DfsDeleteIrpContext(pIrpContext);

    //
    // We are going back into Dnr, so prepare for that:
    //
    //  - Reacquire PKT shared
    //  - Release the semaphore for referral requests, so that the next
    //    thread can get its referral.
    //  - Restart Dnr
    //

    if (!DnrContext->ReleasePkt)
        PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

    ASSERT(DnrContext->ReleasePkt == TRUE);

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrInsertReferralAndResume next State=%d\n", DnrContext->State);
#endif

    DnrContext->Impersonate = TRUE;
    DnrContext->DnrActive = FALSE;
    DnrNameResolve(DnrContext);
    PsAssignImpersonationToken(PsGetCurrentThread(),NULL);

    DfsDbgTrace(-1, Dbg, "DnrInsertReferralAndResume: Exit -> %x\n", ULongToPtr(status) );

}



//
//  The following two functions are DPC functions which participate
//  in the Distributed Name Resolution process.  Each takes a
//  PDNR_CONTEXT as input, transitions the state of the
//  name resolution and any associated data structures, and
//  invokes the next step of the process.
//


//+-------------------------------------------------------------------
//
//  Function:   DnrCompleteReferral, local
//
//  Synopsis:   This is the completion routine for processing a referral
//              response.  Cleanup the IRP and continue processing the name
//              resolution request.
//
//  Arguments:  [pDevice] -- Pointer to target device object for
//                      the request.
//              [Irp] -- Pointer to I/O request packet
//              [Context] -- Caller-specified context parameter associated
//                      with IRP.  This is actually a pointer to a DNR
//                      Context block.
//
//  Returns:    [STATUS_MORE_PROCESSING_REQUIRED] -- The referral Irp was
//                      constructed by Dnr and will be freed by us. So, we
//                      don't want the IO Subsystem to touch the Irp anymore.
//
//  Notes:      This routine executes at DPC level. We should do an absolutely
//              minimum amount of work here.
//
//--------------------------------------------------------------------

NTSTATUS
DnrCompleteReferral(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
) {
    PIRP_CONTEXT pIrpContext = NULL;
    PDNR_CONTEXT DnrContext = (PDNR_CONTEXT) Context;

    DfsDbgTrace(+1, Dbg, "DnrCompleteReferral: Entered\n", 0);

    DfsDbgTrace(0, Dbg, "Irp = %x\n", Irp);
    DfsDbgTrace(0, Dbg, "Context = %x\n", Context);

    //
    // Derefernce the file object over which we sent the referral request
    //

    DFS_DEREFERENCE_OBJECT( DnrContext->DCConnFile );

    DnrContext->DCConnFile = NULL;

    //
    // Release the semaphore controlling number of referral requests
    //

    KeReleaseSemaphore(
        &DfsData.PktReferralRequests,
        0,                                       // Priority boost
        1,                                       // Increment semaphore amount
        FALSE);                                  // Won't call wait immediately

    try {

        pIrpContext = DfsCreateIrpContext(Irp, TRUE);
        if (pIrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        pIrpContext->Context = DnrContext;

        ExInitializeWorkItem(
                &pIrpContext->WorkQueueItem,
                DnrInsertReferralAndResume,
                pIrpContext);

        ExQueueWorkItem( &pIrpContext->WorkQueueItem, CriticalWorkQueue );

    } except(DfsExceptionFilter(pIrpContext, GetExceptionCode(), GetExceptionInformation())) {

        //
        // Ok, we can't queue the work item and complete Dnr. So, we have
        // to do two things. First of all, clean up the current Irp (ie,
        // the Referral Irp), then complete the original Dnr Irp
        //

        //
        // Cleanup referral stuff.
        //

        if (Irp->UserBuffer && Irp->UserBuffer != Irp->AssociatedIrp.SystemBuffer)
            ExFreePool( Irp->UserBuffer );
        if (Irp->AssociatedIrp.SystemBuffer) {
            ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        }

        IoFreeIrp(Irp);
        PktReleaseTargetInfo( DnrContext->pNewTargetInfo );
        DnrContext->pNewTargetInfo = NULL;

        if (pIrpContext) {

            //
            // Maybe this should be an assert that pIrpContext == NULL. If
            // it is not NULL, then the Irp context was allocated, so who
            // threw an exception anyway?
            //

            DfsDeleteIrpContext(pIrpContext);
        }

        //
        // Now, call Dnr to complete the original Irp
        //

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->DnrActive = FALSE;
        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        DnrContext->State = DnrStateDone;
        DnrNameResolve(DnrContext);
	PsAssignImpersonationToken(PsGetCurrentThread(),NULL);
    }

    //
    // Return more processing required to the IO system so that it
    // doesn't attempt further processing on the IRP. The IRP will be
    // freed by DnrInsertReferralAndResume, or has already been freed
    // if we couldn't queue up DnrInsertReferralAndResume
    //

    DfsDbgTrace(-1, Dbg, "DnrCompleteReferral: Exit -> %x\n",
                ULongToPtr(STATUS_MORE_PROCESSING_REQUIRED) );

    UNREFERENCED_PARAMETER(pDevice);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//+-------------------------------------------------------------------
//
//  Function:   DnrCompleteFileOpen, local
//
//  Synopsis:   This is the completion routine for processing a file open
//              request.  Cleanup the IRP and continue processing the name
//              resolution request.
//
//  Arguments:  [pDevice] -- Pointer to target device object for
//                      the request.
//              [Irp] -- Pointer to I/O request packet
//              [Context] -- Caller-specified context parameter associated
//                      with IRP.  This is actually a pointer to a DNR
//                      Context block.
//
//  Returns:    [STATUS_MORE_PROCESSING_REQUIRED] -- We still have to finish
//                      the DNR, so we halt further completion of this Irp
//                      by returning STATUS_MORE_PROCESSING_REQUIRED.
//
//--------------------------------------------------------------------

NTSTATUS
DnrCompleteFileOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
) {
    PDNR_CONTEXT DnrContext;
    NTSTATUS status;
    PFILE_OBJECT                FileObject;
    PIO_STACK_LOCATION IrpSp;

    DfsDbgTrace(+1, Dbg, "DnrCompleteFileOpen: Entered\n", 0);
    DfsDbgTrace(0, Dbg, "Irp          = %x\n", Irp    );
    DfsDbgTrace(0, Dbg, "Context      = %x\n", Context);

    DnrContext = Context;

    status = Irp->IoStatus.Status;

    DfsDbgTrace(0, Dbg, "Irp->Status  = %x\n", ULongToPtr(status) );

    DnrContext->FinalStatus = status;

    DnrReleaseAuthenticatedConnection( DnrContext );

    DFS_DEREFERENCE_OBJECT( DnrContext->TargetDevice );

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // If STATUS_PENDING was initially returned for the IRP, then we need
    // to restart DNR. So, we post a workitem into the FSP, giving it the
    // DnrContext to resume the DNR.
    //
    // If STATUS_PENDING was not returned, then we simply stop the
    // unwinding of the IRP stack by returning STATUS_MORE_PROCESSING_REQUIRED
    // IoCallDriver will eventually return to DnrRedirectFileOpen, which
    // will continue with the DNR.
    //

    if (Irp->PendingReturned) {

        //
        // Schedule a work item to resume DNR
        //

        DnrContext->Impersonate = TRUE;
        DnrContext->DnrActive = FALSE;
        DnrContext->State = DnrStatePostProcessOpen;
        ASSERT(DnrContext->pIrpContext->MajorFunction == IRP_MJ_CREATE);
        DnrContext->pIrpContext->Context = (PVOID) DnrContext;

        //
        // We need to call IpMarkIrpPending so the IoSubsystem will realize
        // that our FSD routine returned STATUS_PENDING. We can't call this
        // from the FSD routine itself because the FSD routine doesn't have
        // access to the stack location when the underlying guy returns
        // STATUS_PENDING
        //

        IoMarkIrpPending( Irp );

        DfsFsdPostRequest(DnrContext->pIrpContext, DnrContext->OriginalIrp);
    }

    //
    // Return more processing required to the IO system so that it
    // stops unwinding the completion routine stack. The DNR that will
    // be resumed will call IoCompleteRequest when appropriate
    // and resume the unwinding of the completion routine stack.
    //

    status = STATUS_MORE_PROCESSING_REQUIRED;
    DfsDbgTrace(-1, Dbg, "DnrCompleteFileOpen: Exit -> %x\n", ULongToPtr(status) );

    UNREFERENCED_PARAMETER(pDevice);

    return status;
}



//+-------------------------------------------------------------------
//
//  Function:   DnrBuildFsControlRequest, local
//
//  Synopsis:   This function builds an I/O request packet for a device or
//              file system I/O control request.
//
//  Arguments:  [FileObject] -- Supplies a pointer the file object to which this
//                      request is directed.  This pointer is copied into the
//                      IRP, so that the called driver can find its file-based
//                      context.  NOTE THAT THIS IS NOT A REFERENCED POINTER.
//                      The caller must ensure that the file object is not
//                      deleted while the I/O operation is in progress.  The
//                      server accomplishes this by incrementing a reference
//                      count in a local block to account for the I/O; the
//                      local block in turn references the file object.
//              [Context] -- Supplies a PVOID value that is passed to the
//                      completion routine.
//              [FsControlCode] -- Supplies the control code for the operation.
//              [MainBuffer] -- Supplies the address of the main buffer.  This
//                      must be a system virtual address, and the buffer must
//                      be locked in memory.  If ControlCode specifies a method
//                      0 request, the actual length of the buffer must be the
//                      greater of InputBufferLength and OutputBufferLength.
//              [InputBufferLength] -- Supplies the length of the input buffer.
//              [AuxiliaryBuffer] -- Supplies the address of the auxiliary
//                      buffer.  If the control code method is 0, this is a
//                      buffered I/O buffer, but the data returned by the
//                      called driver in the system buffer is not
//                      automatically copied into the auxiliary buffer.
//                      Instead, the auxiliary data ends up in MainBuffer.
//                      If the caller wishes the data to be in AuxiliaryBuffer,
//                      it must copy the data at some point after the
//                      completion routine runs.
//              [CompletionRoutine] -- The IO completion routine.
//
//  Returns:    PIRP -- Returns a pointer to the constructed IRP.  If the Irp
//              parameter was not NULL on input, the function return value will
//              be the same value (so it is safe to discard the return value in
//              this case).  It is the responsibility of the calling program to
//              deallocate the IRP after the I/O request is complete.
//
//  Notes:      should we use IoBuildIoControlRequest instead?
//
//--------------------------------------------------------------------


PIRP
DnrBuildFsControlRequest (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
) {
    CLONG method;
    PDEVICE_OBJECT deviceObject;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    const UCHAR MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

    ASSERT( MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

    //
    // Get the method with which the buffers are being passed.
    //

    method = IoControlCode & 3;
    ASSERT( method == METHOD_BUFFERED );

    //
    // Allocate an IRP.  The stack size is one higher
    // than that of the target device, to allow for the caller's
    // completion routine.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Get the address of the target device object.
    //

    Irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize + 1), FALSE );
    if ( Irp == NULL ) {

        //
        // Unable to allocate an IRP.  Inform the caller.
        //

        return NULL;
    }

    Irp->RequestorMode = KernelMode;

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the current stack location and fill in the
    // device object pointer.
    //

    IoSetNextIrpStackLocation( Irp );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    irpSp->DeviceObject = deviceObject;

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        CompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    Irp->MdlAddress = NULL;
    Irp->AssociatedIrp.SystemBuffer = MainBuffer;
    Irp->UserBuffer = AuxiliaryBuffer;

    Irp->Flags = (ULONG)IRP_BUFFERED_IO;
    if ( ARGUMENT_PRESENT(AuxiliaryBuffer) ) {
        Irp->Flags |= IRP_INPUT_OPERATION;
    }

    return Irp;

}


//+-------------------------------------------------------------------------
//
//  Function:   AllocateDnrContext, public
//
//  Synopsis:   AllocateDnrContext will allocate a DNR_CONTEXT
//              record.
//
//  Arguments:  -none-
//
//  Returns:    PDNR_CONTEXT - a pointer to the allocated DNR_CONTEXT;
//                      NULL if not enough memory.
//
//  Notes:      We should investigate allocating this out of the
//              IrpContext Zone if they are similar enough in size.
//
//--------------------------------------------------------------------------

PDNR_CONTEXT
AllocateDnrContext(
    IN ULONG    cbExtra
) {
    PDNR_CONTEXT pNRC;

    pNRC = ExAllocatePoolWithTag( NonPagedPool, sizeof (DNR_CONTEXT) + cbExtra, ' puM');
    if (pNRC == NULL) {
        return NULL;
    }
    RtlZeroMemory(pNRC, sizeof (DNR_CONTEXT));
    pNRC->NodeTypeCode = DSFS_NTC_DNR_CONTEXT;
    pNRC->NodeByteSize = sizeof (DNR_CONTEXT);

    return pNRC;
}


//+-------------------------------------------------------------------------
//
//  Function:   DnrConcatenateFilePath, public
//
//  Synopsis:   DnrConcatenateFilePath will concatenate two strings
//              representing file path names, assuring that they are
//              separated by a single '\' character.
//
//  Arguments:  [Dest] - a pointer to the destination string
//              [RemainingPath] - the final part of the path name
//              [Length] - the length (in bytes) of RemainingPath
//
//  Returns:    BOOLEAN - TRUE unless Dest is too small to
//                      hold the result (assert).
//
//--------------------------------------------------------------------------

BOOLEAN
DnrConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
) {
    PWSTR  OutBuf = (PWSTR)&(((PCHAR)Dest->Buffer)[Dest->Length]);
    ULONG NewLen;

    if (Dest->Length > 0) {
        ASSERT(OutBuf[-1] != UNICODE_NULL);
    }

    if (Length == 0)
    {
        return TRUE;
    }

    if (Dest->Length > 0 && OutBuf[-1] != UNICODE_PATH_SEP) {
        *OutBuf++ = UNICODE_PATH_SEP;
        Dest->Length += sizeof (WCHAR);
    }

    if (Length > 0 && *RemainingPath == UNICODE_PATH_SEP) {
        RemainingPath++;
        Length -= sizeof (WCHAR);
    }

    NewLen = (ULONG)Dest->Length + (ULONG)Length;

    if (NewLen > MAXUSHORT || NewLen > (ULONG)Dest->MaximumLength) {

        return FALSE;

    }

    if (Length > 0) {
        RtlMoveMemory(OutBuf, RemainingPath, Length);
        Dest->Length += Length;
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   DnrLocateDC, private
//
//  Synopsis:   Tries to create an entry for the Dfs root which will match
//              FileName.
//
//  Arguments:  [FileName] -- File name for which DC/Root is being located.
//
//  Returns:    Nothing. 
//
//-----------------------------------------------------------------------------

VOID
DnrLocateDC(
    IN PUNICODE_STRING FileName)
{
    BOOLEAN pktLocked;
    NTSTATUS status;
    UNICODE_STRING dfsRoot, dfsShare, remPath;
    UNICODE_STRING RootShareName;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_PKT pkt;
    USHORT i, j;

    ASSERT( FileName->Buffer[0] == UNICODE_PATH_SEP );

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrLocateDC(%wZ)\n", FileName);
#endif

    dfsRoot.Length = dfsRoot.MaximumLength = 0;
    dfsRoot.Buffer = &FileName->Buffer[1];

    for (i = 1;
            i < FileName->Length/sizeof(WCHAR) &&
                FileName->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {

         NOTHING;

    }

    for (j = i + 1;
            j < FileName->Length/sizeof(WCHAR) &&
                FileName->Buffer[j] != UNICODE_PATH_SEP;
                    j++) {

         NOTHING;

    }

    if ((FileName->Buffer[i] == UNICODE_PATH_SEP) && (j > i)) {

        dfsRoot.MaximumLength = dfsRoot.Length = (i - 1) * sizeof(WCHAR);
        dfsShare.MaximumLength = dfsShare.Length = (j - i - 1) * sizeof(WCHAR);
        dfsShare.Buffer = &FileName->Buffer[i+1];
#if DBG
        if (MupVerbose)
            DbgPrint("  DnrLocateDC dfsRoot=[%wZ] dfsShare=[%wZ]\n",
                    &dfsRoot,
                    &dfsShare);
#endif
        status = PktCreateDomainEntry( &dfsRoot, &dfsShare, FALSE );

        if (!NT_SUCCESS(status)) {

#if DBG
            if (MupVerbose)
                DbgPrint("  DnrLocateDC:PktCreateDomainEntry() returned 0x%x\n", status);
#endif
            RootShareName.Buffer = FileName->Buffer;
            RootShareName.Length = j * sizeof(WCHAR);
            RootShareName.MaximumLength = FileName->MaximumLength;
#if DBG
            if (MupVerbose)
                DbgPrint("  DnrLocateDC:RootShareName=[%wZ]\n", &RootShareName);
#endif

            //
            // Failed getting referral - see if we have a stale one.
            //

            pkt = _GetPkt();

            PktAcquireShared( TRUE, &pktLocked );

            pktEntry = PktLookupEntryByPrefix( pkt, &RootShareName, &remPath );

            if (pktEntry != NULL) {

#if DBG
                if (MupVerbose)
                    DbgPrint("  DnrLocateDC:Found stale pkt entry %08lx - adding 60 sec to it\n",
                                        pktEntry);
#endif
                if (pktEntry->ExpireTime <= 0) {
                    pktEntry->ExpireTime = 60;
                    pktEntry->TimeToLive = 60;
                }

                status = STATUS_SUCCESS;

            }

            PktRelease();

        }

    } else {

        status = STATUS_BAD_NETWORK_PATH;

    }

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrLocateDC exit 0x%x\n", status);
#endif

}

//+----------------------------------------------------------------------------
//
//  Function:   DnrRebuildDnrContext
//
//  Synopsis:   To handle inter-dfs links, we simply want to change the name
//              of the file we are opening to the name in the new Dfs, and
//              restart DNR afresh.
//
//              This is most easily done by simply terminating this DNR with
//              STATUS_REPARSE. However, if we do that, we would loose track
//              of the credentials (if any) we originally came in with.
//
//              Hence, this routine simply rebuilds the DnrContext. After
//              calling this, Dnr starts all over again, just as if
//              DnrNameResolve had been called by DnrStartNameResolution
//
//
//  Arguments:  [DnrContext] -- The context to rebuild.
//              [NewDfsPrefix] -- The prefix of the Dfs in which the DNR
//                      should continue.
//              [RemainingPath] -- Path relative to the NewDfsPrefix.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID
DnrRebuildDnrContext(
    IN PDNR_CONTEXT DnrContext,
    IN PUNICODE_STRING NewDfsPrefix,
    IN PUNICODE_STRING RemainingPath)
{
    UNICODE_STRING newFileName;
    ULONG newNameLen = 0;

    PIRP Irp = DnrContext->OriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    //
    // Build the new file name
    //

    newFileName.Length = 0;

    newNameLen = NewDfsPrefix->Length +
                    sizeof(UNICODE_PATH_SEP) +
                        RemainingPath->Length +
                            sizeof(UNICODE_NULL);

    if (newNameLen >= MAXUSHORT) {

        DnrContext->FinalStatus = STATUS_NAME_TOO_LONG;
        DnrContext->State = DnrStateDone;
        return;

    }

    newFileName.MaximumLength = (USHORT)newNameLen;

    newFileName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        newFileName.MaximumLength,
                                        ' puM');

    if (newFileName.Buffer != NULL) {

        newFileName.Length = NewDfsPrefix->Length;

        RtlMoveMemory(
            newFileName.Buffer,
            NewDfsPrefix->Buffer,
            newFileName.Length);

        DnrConcatenateFilePath(
            &newFileName,
            RemainingPath->Buffer,
            RemainingPath->Length);

        if (DnrContext->NameAllocated)
            ExFreePool(DnrContext->FileName.Buffer);

        DnrContext->NameAllocated = TRUE;

        DnrContext->FileName = newFileName;

    } else {

        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;

        DnrContext->State = DnrStateDone;

        return;
    }

    //
    // Rebuild the FcbToUse because the Fcb has room for the full file name
    // and it might have changed its size.
    //

    ASSERT(DnrContext->FcbToUse != NULL);

    DfsDetachFcb(DnrContext->FcbToUse->FileObject, DnrContext->FcbToUse);
    ExFreePool(DnrContext->FcbToUse);

    DnrContext->FcbToUse = DfsCreateFcb(
                                DnrContext->pIrpContext,
                                DnrContext->Vcb,
                                &DnrContext->ContextFileName);

    if (DnrContext->FcbToUse == NULL) {

        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;

        DnrContext->State = DnrStateDone;

        return;

    }
    DnrContext->FcbToUse->FileObject = FileObject;
    DfsSetFileObject(FileObject, 
		     RedirectedFileOpen, 
		     DnrContext->FcbToUse);

    //
    // Now, whack the rest of the DnrContext. Clean it up so it is essentially
    // zeroed out..
    //

    DnrContext->State = DnrStateStart;

    DnrContext->pPktEntry = NULL;
    DnrContext->USN = 0;
    DnrContext->pService = NULL;
    DnrContext->pProvider = NULL;
    DnrContext->ProviderId = 0;
    DnrContext->TargetDevice = NULL;
    DnrContext->AuthConn = NULL;
    DnrContext->DCConnFile = NULL;

    DnrContext->ReferralSize = MAX_REFERRAL_LENGTH;
    DnrContext->Attempts++;
    DnrContext->GotReferral = FALSE;
    DnrContext->FoundInconsistency = FALSE;
    DnrContext->CalledDCLocator = FALSE;
    DnrContext->CachedConnFile = FALSE;
    DnrContext->DfsNameContext.Flags = 0;
    DnrContext->GotReparse = FALSE;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfspGetOfflineEntry -- Checks for a server marked offline.
//
//  Synopsis:   DfspGetOfflineEntry returns an offline entry for the given
//              server, if it exists in our offline database.
//
//  Arguments:  [servername] - Name of the server of interest.
//              DfsData.Resource assumed held on entry.
//
//  Returns:   PLIST_ENTRY: plist_entry of the offline structure.
//
//--------------------------------------------------------------------------

PLIST_ENTRY 
DfspGetOfflineEntry(
    PUNICODE_STRING ServerName)
{
    PLIST_ENTRY listEntry;
    PDFS_OFFLINE_SERVER server;

    listEntry = DfsData.OfflineRoots.Flink;

    while ( listEntry != &DfsData.OfflineRoots ) {
	server = CONTAINING_RECORD(
		     listEntry,
		     DFS_OFFLINE_SERVER,
		     ListEntry);
	if (RtlCompareUnicodeString(
		     &server->LogicalServerName, ServerName, TRUE) == 0) {
	    break;
	}
	listEntry = listEntry->Flink;
    }
    if (listEntry == &DfsData.OfflineRoots) {
	listEntry = NULL;
    }
    return listEntry;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfspMarkServerOnline -- Marks a server online
//
//  Synopsis:   DfspMarkServerOnline removes the server entry from its offline
//              database, if it was marked as offline earlier.
//
//  Arguments:  [servername] - Name of the server of interest.
//
//  Returns:   NTSTATUS.
//
//--------------------------------------------------------------------------

NTSTATUS
DfspMarkServerOnline(
    PUNICODE_STRING ServerName)
{
    PLIST_ENTRY listEntry;
    PDFS_OFFLINE_SERVER server;
    NTSTATUS status;
    UNICODE_STRING dfsRootName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspMarkServerOnline: %wZ\n", ServerName);

    //
    // Extract server name when there is \server\share
    //

    dfsRootName = *ServerName;
    if (dfsRootName.Buffer[0] == UNICODE_PATH_SEP) {
        for (i = 1;
             i < dfsRootName.Length/sizeof(WCHAR) &&
                  dfsRootName.Buffer[i] != UNICODE_PATH_SEP;
                     i++) {
            NOTHING;
        }
        dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
        dfsRootName.MaximumLength = dfsRootName.Length;
        dfsRootName.Buffer = &ServerName->Buffer[1];
    }

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    listEntry = DfspGetOfflineEntry(&dfsRootName);

    if (listEntry != NULL) {
	RemoveEntryList(listEntry);
    }
    ExReleaseResourceLite( &DfsData.Resource );

    if (listEntry != NULL) {
	server = CONTAINING_RECORD(
		     listEntry,
		     DFS_OFFLINE_SERVER,
		     ListEntry);
	ExFreePool(server->LogicalServerName.Buffer);
	ExFreePool(server);
    }

    MupInvalidatePrefixTable();
    status = STATUS_SUCCESS;
    DfsDbgTrace(-1, Dbg, "DfspMarkServerOnline: status %x\n", ULongToPtr(status));
    return status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfspMarkServerOffline -- Marks a server offline
//
//  Synopsis:   DfspMarkServerOffline adds the server entry to its offline
//              database.
//
//  Arguments:  [servername] - Name of the server of interest.
//
//  Returns:   NTSTATUS.
//
//--------------------------------------------------------------------------

NTSTATUS
DfspMarkServerOffline(
   PUNICODE_STRING ServerName)
{
    UNICODE_STRING NewName;
    PLIST_ENTRY listEntry;
    PDFS_OFFLINE_SERVER server;
    UNICODE_STRING dfsRootName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspMarkServerOffline: %wZ \n", ServerName);

    server = ExAllocatePoolWithTag( PagedPool, sizeof(DFS_OFFLINE_SERVER), ' puM' );
    if (server == NULL) {
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Extract server name when there is \server\share
    //

    dfsRootName = *ServerName;
    if (dfsRootName.Buffer[0] == UNICODE_PATH_SEP) {
        for (i = 1;
             i < dfsRootName.Length/sizeof(WCHAR) &&
                  dfsRootName.Buffer[i] != UNICODE_PATH_SEP;
                     i++) {
            NOTHING;
        }
        dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
        dfsRootName.MaximumLength = dfsRootName.Length;
        dfsRootName.Buffer = &ServerName->Buffer[1];
    }

    NewName.Buffer = ExAllocatePoolWithTag(
                          PagedPool, 
                          dfsRootName.Length + sizeof(WCHAR),
                          ' puM' );

    if (NewName.Buffer == NULL) {
	ExFreePool(server);
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    NewName.MaximumLength = dfsRootName.Length + sizeof(WCHAR);
    NewName.Length = 0;

    RtlCopyUnicodeString(&NewName, &dfsRootName);

    server->LogicalServerName = NewName;

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    listEntry = DfspGetOfflineEntry(&dfsRootName);

    if (listEntry == NULL) {
	InsertTailList( &DfsData.OfflineRoots, &server->ListEntry);	
    }
    ExReleaseResourceLite( &DfsData.Resource );

    if (listEntry != NULL) {
	ExFreePool(NewName.Buffer);
	ExFreePool(server);
    }
    DfsDbgTrace(-1, Dbg, "DfspMarkServerOffline exit STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspIsRootOnline -- Checks if a server is online
//
//  Synopsis:   DfspIsRootOnline checks if the server is marked in its offline
//              database. If not, the server is online.
//
//  Arguments:  [servername] - Name of the server of interest.
//
//  Returns:   NTSTATUS. (Success or STATUS_DEVICE_OFFLINE)
//
//--------------------------------------------------------------------------


NTSTATUS
DfspIsRootOnline(
    PUNICODE_STRING FileName,
    BOOLEAN CSCAgentCreate)
{
    NTSTATUS status;
    PLIST_ENTRY listEntry;
    UNICODE_STRING dfsRootName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspIsRootOnline: %wZ\n", FileName);

    if (CSCAgentCreate == TRUE) {
        DfsDbgTrace(-1, Dbg, "CSCAgent, returning success!\n", 0);
	status = STATUS_SUCCESS;
    }
    else {
	dfsRootName = *FileName;
	if (dfsRootName.Buffer[0] == UNICODE_PATH_SEP) {
	    for (i = 1;
		 i < dfsRootName.Length/sizeof(WCHAR) &&
		      dfsRootName.Buffer[i] != UNICODE_PATH_SEP;
		         i++) {
		NOTHING;
	    }
	    dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
	    dfsRootName.MaximumLength = dfsRootName.Length;
	    dfsRootName.Buffer = &FileName->Buffer[1];
	}

	ExAcquireResourceSharedLite( &DfsData.Resource, TRUE );
	listEntry = DfspGetOfflineEntry(&dfsRootName);
	ExReleaseResourceLite( &DfsData.Resource );

	if (listEntry != NULL) {
	    status = STATUS_DEVICE_OFF_LINE;
	}
	else {
	    status = STATUS_SUCCESS;
	}
    }

    DfsDbgTrace(-1, Dbg, "DfspIsRootOnline: ret 0x%x\n", ULongToPtr(status) );

    return status;
}

#if 0
NTSTATUS
DnrGetTargetInfo( 
    PDNR_CONTEXT pDnrContext)
{
    UNICODE_STRING dfsRoot, dfsShare;
    PUNICODE_STRING pFileName = &pDnrContext->FileName;
    USHORT i, j;
    NTSTATUS Status;

    dfsRoot.Length = dfsRoot.MaximumLength = 0;
    dfsRoot.Buffer = &pFileName->Buffer[1];

    for (i = 1;
            i < pFileName->Length/sizeof(WCHAR) &&
                pFileName->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {

         NOTHING;

    }

    for (j = i + 1;
            j < pFileName->Length/sizeof(WCHAR) &&
                pFileName->Buffer[j] != UNICODE_PATH_SEP;
                    j++) {

         NOTHING;

    }

    if ((pFileName->Buffer[i] == UNICODE_PATH_SEP) && (j > i)) {

        dfsRoot.MaximumLength = dfsRoot.Length = (i - 1) * sizeof(WCHAR);
        dfsShare.MaximumLength = dfsShare.Length = (j - i - 1) * sizeof(WCHAR);
        dfsShare.Buffer = &pFileName->Buffer[i+1];

        Status = PktGetTargetInfo( pDnrContext->DCConnFile,
                                   &dfsRoot,
                                   &dfsShare,
                                   &pDnrContext->pNewTargetInfo );
    }
    else {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    return Status;
}

#endif
NTSTATUS
DnrGetTargetInfo( 
    PDNR_CONTEXT pDnrContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY pEntry;

    pEntry = pDnrContext->pPktEntry;
    if (pEntry != NULL)
    {
        pDnrContext->pNewTargetInfo = pEntry->pDfsTargetInfo;
        if (pDnrContext->pNewTargetInfo != NULL)
        {
            PktAcquireTargetInfo(pDnrContext->pNewTargetInfo);
        }
    }

    if (pDnrContext->pNewTargetInfo == NULL)
    {
        if (pDnrContext->pDfsTargetInfo != NULL)
        {
            pDnrContext->pNewTargetInfo = pDnrContext->pDfsTargetInfo;
            if (pDnrContext->pNewTargetInfo != NULL)
            {
                PktAcquireTargetInfo(pDnrContext->pNewTargetInfo);
            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsrtl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   DfsRtl.h
//
//  Contents:
//
//  Functions:
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#ifndef _DFSRTL_
#define _DFSRTL_

#include <stddef.h>

BOOLEAN
DfsRtlPrefixPath (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Test,
    IN BOOLEAN IgnoreCase
);

#endif // _DFSRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsstruc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsstruc.h
//
//  Contents:
//      This module defines the data structures that make up the major internal
//      part of the DFS file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo Removed all EP related stuff
//                                      Added stuff to support PKT
//              11 May 1992     PeterCo Added support for attached devices
//              24 April 1993   SudK    Added support for KernelToUserMode calls
//                                      Added support for timer functionality.
//-----------------------------------------------------------------------------


#ifndef _DFSSTRUC_
#define _DFSSTRUC_

typedef enum {
    DFS_UNKNOWN = 0,
    DFS_CLIENT = 1,
    DFS_SERVER = 2,
    DFS_ROOT_SERVER = 3,
} DFS_MACHINE_STATE;

typedef enum {
    LV_UNINITIALIZED = 0,
    LV_INITSCHEDULED,
    LV_INITINPROGRESS,
    LV_INITIALIZED,
    LV_VALIDATED
} DFS_LV_STATE;

//
//  The DFS_DATA record is the top record in the DFS file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _DFS_DATA {

    //
    //  The type and size of this record (must be DSFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A queue of all the logical roots that are known by the file system.
    //

    LIST_ENTRY  VcbQueue;

    //
    //  A list of all the deleted logical roots that still have files open
    //  on them.
    //

    LIST_ENTRY  DeletedVcbQueue;

    //
    //  A queue of all the DRT (Deviceless roots) that are known.
    //

    LIST_ENTRY  DrtQueue;

    //
    //  A list of all the user-defined credentials
    //

    LIST_ENTRY  Credentials;

    //
    //  A list of all the deleted credentials. They will be destroyed once
    //  their ref count goes to 0
    //

    LIST_ENTRY  DeletedCredentials;

    //
    //  A list of all the offline roots
    //

    LIST_ENTRY  OfflineRoots;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A pointer to the \Dfs device object
    //

    PDEVICE_OBJECT FileSysDeviceObject;

    //
    //  A pointer to an array of provider records
    //

    struct _PROVIDER_DEF *pProvider;
    int cProvider, maxProvider;

    //
    //  A resource variable to control access to the global data record
    //

    ERESOURCE Resource;

    //
    //  A spin lock to control access to the global data record; handy for
    //  Interlocked operations.
    //

    KSPIN_LOCK DfsLock;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.  This field is simply set each time an
    //  FSP thread is started, since it is easiest to do while running in the
    //  Fsp.
    //

    PEPROCESS OurProcess;

    //
    // Lookaside list for IRP contexts
    //

    NPAGED_LOOKASIDE_LIST IrpContextLookaside;

    //
    //  Device name prefix for the logical root devices.
    //  E.g.,  `\Device\WinDfs\'.
    //

    UNICODE_STRING LogRootDevName;

    //
    //  The state of the machine - DC, Server, Client etc.
    //

    DFS_MACHINE_STATE MachineState;

    //
    // The system wide Partition Knowledge Table (PKT)
    //

    DFS_PKT Pkt;

    //
    // DNR has been designed so that resources (like the Pkt above) are not
    // locked across network calls. This is critical to prevent inter-machine
    // deadlocks and for other functionality. To regulate access to these
    // resources, we use the following two events.
    //
    // This notify event is used to indicate that some thread is waiting to
    // write into the Pkt. If this event is !RESET!, it means that a thread
    // is waiting to write, and other threads trying to enter DNR should
    // hold off.
    //

    KEVENT PktWritePending;

    //
    // This semaphone is used to indicate that some thread(s) have currently
    // gone to get a referral. Another thread that wants to get a referral
    // should wait till this semaphone is SIGNALLED before attempting to go
    // get its own referral.
    //

    KSEMAPHORE PktReferralRequests;

    //
    //  A hash table for associating DFS_FCBs with file objects
    //

    struct _FCB_HASH_TABLE *FcbHashTable;

    //
    // EA buffer used to diffrentiate CSC opens from others
    //

    PFILE_FULL_EA_INFORMATION  CSCEaBuffer;
    ULONG                      CSCEaBufferLength;

} DFS_DATA, *PDFS_DATA;




#define MAX_PROVIDERS   5       // number of pre-allocated provider records

//
//  A PROVIDER_DEF is a structure that abstracts an underlying redirector.
//

typedef struct _PROVIDER_DEF {

    //
    //  The type and size of this record (must be DSFS_NTC_PROVIDER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Provider ID and Capabilities, same as in the DS_REFERRAL structure.
    //

    USHORT      eProviderId;
    USHORT      fProvCapability;

    //
    //  The following field gives the name of the device for the provider.
    //

    UNICODE_STRING      DeviceName;

    //
    //  Referenced pointers to the associated file and device objects
    //

    PDEVICE_OBJECT      DeviceObject;
    PFILE_OBJECT        FileObject;

} PROVIDER_DEF, *PPROVIDER_DEF;


//
//  The Vcb (Volume Control Block) record corresponds to every volume
//  (ie, a net use) mounted by the file system.  They are ordered in a
//  queue off of DfsData.VcbQueue.
//
//  For the DFS file system, `volumes' correspond to DFS logical roots.
//  These records are an extension of a corresponding device object.
//

typedef struct _DFS_VCB {

    //
    //  The type and size of this record (must be DSFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the device queue off of DfsData.VcbQueue
    //

    LIST_ENTRY  VcbLinks;

    //
    //  The internal state of the device.  This is a collection of FSD device
    //  state flags.
    //

    USHORT VcbState;

    //
    //  The logical root corresponding to this volume.  Forms part of the
    //  path name in the NT object name space. This string will be something
    //  like L"org", or L"dom" etc.
    //

    UNICODE_STRING LogicalRoot;

    //
    //  The LogRootPrefix has a prefix that needs to be prepended to file
    //  names being opened via this logical root before their name can
    //  be resolved.
    //

    UNICODE_STRING LogRootPrefix;

    //
    //  The credentials associated with this logical root
    //

    struct _DFS_CREDENTIALS *Credentials;

    //
    //  A count of the number of file objects that have opened the volume
    //  for direct access, and their share access state.
    //

    CLONG DirectAccessOpenCount;
    SHARE_ACCESS ShareAccess;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume, not including direct access.
    //

    CLONG OpenFileCount;
    PFILE_OBJECT FileObjectWithVcbLocked;

#ifdef TERMSRV

    ULONG SessionID;

#endif // TERMSRV
    
    LUID  LogonID;
    PDFS_PKT_ENTRY pktEntry;
} DFS_VCB;
typedef DFS_VCB *PDFS_VCB;

#define VCB_STATE_FLAG_LOCKED           (0x0001)
#define VCB_STATE_FLAG_ALLOC_FCB        (0x0002)
#define VCB_STATE_CSCAGENT_VOLUME       (0x0004)
//#define VCB_STATE_FLAG_DEVICE_ONLY    (0x0008)

#ifdef TERMSRV

//
// This SessionId indicates that the device name should not be suffixed
// with :SessionID, and that no matching on SessionID should be done.
//

#define INVALID_SESSIONID               0xffffffff

#endif


//
//  A CREDENTIAL_RECORD is a user-supplied set of credentials that should
//  be used when accessing a particular Dfs. They are ordered in a queue
//  off of DfsData.Credentials;
//

typedef struct _DFS_CREDENTIALS {

    //
    //  The links for the credentials queue off of DfsData.Credentials
    //

    LIST_ENTRY Link;

    //
    //  A flags field to keep state about this credential record.
    //

    ULONG       Flags;

    //
    //  A ref count to keep this credential record from going away while
    //  it is being used.
    //

    ULONG       RefCount;

    //
    //  A count of the number of net uses that refer to these credentials
    //

    ULONG       NetUseCount;

    //
    //  The root of the Dfs for which these credentials apply.
    //

    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;

    //
    //  The domain name, user name and password to use when accessing the
    //  Dfs rooted at ServerName\ShareName
    //

    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;

#ifdef TERMSRV

    ULONG SessionID;

#endif // TERMSRV

    LUID  LogonID;
    //
    //  When setting up a Tree connect using these credentials, we'll need
    //  to form an EA Buffer to pass in with the ZwCreateFile call. So, we
    //  form one here.
    //

    ULONG  EaLength;
    PUCHAR EaBuffer[1];

} DFS_CREDENTIALS;
typedef DFS_CREDENTIALS *PDFS_CREDENTIALS;

#define CRED_HAS_DEVICE         0x1
#define CRED_IS_DEVICELESS      0x2


//
//  The DFS_FCB record corresponds to every open file and directory.
//

typedef struct _DFS_FCB {

    //
    //  Type and size of this record (must be DSFS_NTC_FCB or DSFS_NTC_DCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A list entry for the hash table chain.
    //

    LIST_ENTRY HashChain;

    //
    //  A pointer to the Logical root device, through which this DFS_FCB
    //  was opened.
    //

    PDFS_VCB Vcb;

    //
    //  The following field is the fully qualified file name for this DFS_FCB/DCB
    //  starting from the logical root.
    //

    union {
       UNICODE_STRING FullFileName;
       DFS_NAME_CONTEXT DfsNameContext;
    };

    UNICODE_STRING AlternateFileName;

    //
    //  The following fields give the file and devices on which this DFS_FCB
    //  have been opened.  The DFS driver will pass through requests for
    //  the file object to the target device below.
    //

    PFILE_OBJECT FileObject;

    //
    //  The destinatation FSD device object through which I/O will be done.
    //

    PDEVICE_OBJECT TargetDevice;

    //
    //  The provider def that opened this file
    //

    USHORT ProviderId;

    //
    //  The DFS_MACHINE_ENTRY through which this file was opened. We need
    //  to maintain a reference for each file on a DFS_MACHINE_ENTRY in
    //  case we have authenticated connections to the server; we don't want
    //  to tear down the authenticated connection if files are open.
    //

    PDFS_MACHINE_ENTRY DfsMachineEntry;

    WORK_QUEUE_ITEM WorkQueueItem;

} DFS_FCB, *PDFS_FCB;



//
//  The Logical Root Device Object is an I/O system device object
//  created as a result of creating a DFS logical root.
//  Logical roots are in many ways analogous to volumes
//  for a local file system.
//
//  There is a DFS_VCB record appended to the end.
//

typedef struct _LOGICAL_ROOT_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  This is the file system specific volume control block.
    //

    DFS_VCB Vcb;

} LOGICAL_ROOT_DEVICE_OBJECT, *PLOGICAL_ROOT_DEVICE_OBJECT;



//
//  The Irp Context record is allocated for every orginating Irp.  It
//  is created by the Fsd dispatch routines, and deallocated by the
//  DfsCompleteRequest routine
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be DSFS_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    //
    //  A pointer to the originating Irp.
    //

    PIRP OriginatingIrp;

    //
    //  A pointer to function dependent context.
    //

    PVOID Context;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  The following flags field indicates if we can wait/block for a resource
    //  or I/O, if we are to do everything write through, and if this
    //  entry into the Fsd is a recursive call
    //

    USHORT Flags;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception
    //

    NTSTATUS ExceptionStatus;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

//
//  Values for the Irp context Flags field.
//

//#define IRP_CONTEXT_FLAG_FROM_POOL       (0x00000001) // replaced by lookaside list
#define IRP_CONTEXT_FLAG_WAIT            (0x00000002)
#define IRP_CONTEXT_FLAG_IN_FSD          (0x00000004)


//
// This context is used by the DfsIoTimer routine. We can expand on this
// whenever new functionality needs to be added to the Timer function.
//
typedef struct  _DFS_TIMER_CONTEXT {

    //
    //  TickCount. To keep track of how many times the timer routine was
    //  called.  The timer uses this to do things at a coarser granularity.
    //
    ULONG       TickCount;

    //
    //  InUse. This field is used to denote that this CONTEXT is in use
    //  by some function to which the Timer routine has passed it off.  This
    //  is used in a simple way to control access to this context.
    //
    BOOLEAN     InUse;

    //
    //  ValidateLocalPartitions. This field is used to denote that the
    //  local volumes should be validated at this time.
    //

    BOOLEAN     ValidateLocalPartitions;

    //
    //  This is used to schedule DfsAgePktEntries.
    //

    WORK_QUEUE_ITEM     WorkQueueItem;

    //
    //  This is used to schedule DfsDeleteDevices.
    //

    WORK_QUEUE_ITEM     DeleteQueueItem;

} DFS_TIMER_CONTEXT, *PDFS_TIMER_CONTEXT;

//
//  The following constant is the number of seconds between any two scans
//  through the PKT to get rid of old PKT entries.
//
#define DFS_MAX_TICKS                   240

//
//  The following constant is the number of seconds that a referral will
//  remain in cache (PKT).
//

#define MAX_REFERRAL_LIFE_TIME          300

//
// The followin constants are the starting timeout (in seconds) between
// special referrals.  The start value is doubled after every retry until it
// reaches the max.
//

#define SPECIAL_TIMEOUT_START           (5*60)          // 5 min
#define SPECIAL_TIMEOUT_MAX             (60*60)         // 60 min


//
//  The Drt (Devless Root) record corresponds to every net use.
//  They are ordered in a queue off of DfsData.VcbQueue.
//
//

typedef struct _DFS_DEVLESS_ROOT {

    //
    //  The type and size of this record (must be DSFS_NTC_DRT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the device queue off of DfsData.DrtQueue
    //

    LIST_ENTRY  DrtLinks;

    //
    //  The pathname corresponding to this entry.
    //

    UNICODE_STRING DevlessPath;

    //
    //  The credentials associated with this logical root
    //

    struct _DFS_CREDENTIALS *Credentials;

#ifdef TERMSRV

    ULONG SessionID;

#endif // TERMSRV
    
    LUID  LogonID;
    PDFS_PKT_ENTRY pktEntry;
} DFS_DEVLESS_ROOT;

typedef DFS_DEVLESS_ROOT *PDFS_DEVLESS_ROOT;

#endif // _DFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsmrshl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsMrshl.h
//
//  Contents:   Defines for Dfs marshalling routines
//
//  Classes:
//
//  Functions:
//
//  History:    March 29, 1994          Milans Created from Peterco's dfsrtl.h
//
//-----------------------------------------------------------------------------

#ifndef _DFSMRSHL_
#define _DFSMRSHL_

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <guiddef.h>
//
// MARSHALLING AND UNMARSHALLING SUPPORT
//

#ifdef  KERNEL_MODE
#define MarshalBufferAllocate(x)   ExAllocatePoolWithTag(PagedPool, x, ' puM')
#define MarshalBufferFree(x)       ExFreePool(x)
#else
#include <stdlib.h>
#define MarshalBufferAllocate(x)   malloc(x)
#define MarshalBufferFree(x)       free(x)
#endif // KERNEL_MODE

#define DfsAllocate                MarshalBufferAllocate
#define DfsFree                    MarshalBufferFree

//
// Structure used when marshalling and unmarhalling
//
typedef struct _MARSHAL_BUFFER {

    PUCHAR  First;
    PUCHAR  Current;
    PUCHAR  Last;

} MARSHAL_BUFFER, *PMARSHAL_BUFFER;


typedef struct _MARSHAL_TYPE_INFO {

    ULONG _type;                    // the type of item to be marshalled
    ULONG _off;                     // offset of item (in the struct)
    ULONG _cntsize;                 // size of counter for counted array
    ULONG _cntoff;                  // else, offset count item (in the struct)
    struct _MARSHAL_INFO * _subinfo;// if compound type, need info

} MARSHAL_TYPE_INFO, *PMARSHAL_TYPE_INFO;


typedef struct _MARSHAL_INFO {

    ULONG _size;                    // size of item
    ULONG _typecnt;                 // number of type infos
    PMARSHAL_TYPE_INFO _typeInfo;   // type infos

} MARSHAL_INFO, *PMARSHAL_INFO;

#define _mkMarshalInfo(s, i)\
    {(ULONG)sizeof(s),(ULONG)(sizeof(i)/sizeof(MARSHAL_TYPE_INFO)),i}


#define MTYPE_BASE_TYPE             (0x0000ffffL)

#define MTYPE_COMPOUND              (0x00000001L)
#define MTYPE_GUID                  (0x00000002L)
#define MTYPE_STRING                (0x00000003L)
#define MTYPE_UNICODE_STRING        (0x00000004L)
#define MTYPE_ULONG                 (0x00000005L)
#define MTYPE_USHORT                (0x00000006L)
#define MTYPE_PWSTR                 (0x00000007L)
#define MTYPE_UCHAR                 (0x00000008L)
#define MTYPE_CONFORMANT_CNT        (0x00000009L)

#define MTYPE_INDIRECT      (0x80000000L)

#define MTYPE_COMPLEX_TYPE          (0x7fff0000L)

#define MTYPE_STATIC_ARRAY  (0x00010000L)
#define MTYPE_COUNTED_ARRAY (0x00020000L)


#define _MCode_conformant(s,m,c)\
    {MTYPE_CONFORMANT_CNT, sizeof(((s *) 0)->m[0]), sizeof(((s *) 0)->c), offsetof(s,c), 0L}

#define _MCode_Base(t,s,m,i)\
    {t,offsetof(s,m),0L,0L,i}

#define _MCode_struct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND,s,m,i)
#define _MCode_guid(s,m)\
    _MCode_Base(MTYPE_GUID,s,m,NULL)
#define _MCode_str(s,m)\
    _MCode_Base(MTYPE_STRING,s,m,NULL)
#define _MCode_ustr(s,m)\
    _MCode_Base(MTYPE_UNICODE_STRING,s,m,NULL)
#define _MCode_pwstr(s,m)\
    _MCode_Base(MTYPE_PWSTR,s,m,NULL)
#define _MCode_ul(s,m)\
    _MCode_Base(MTYPE_ULONG,s,m,NULL)
#define _MCode_ush(s,m)\
    _MCode_Base(MTYPE_USHORT,s,m,NULL)
#define _MCode_uch(s,m)\
    _MCode_Base(MTYPE_UCHAR,s,m,NULL)

#define _MCode_pstruct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,i)
#define _MCode_pguid(s,m)\
    _MCode_Base(MTYPE_GUID|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pstr(s,m)\
    _MCode_Base(MTYPE_STRING|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pustr(s,m)\
    _MCode_Base(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pul(s,m)\
    _MCode_Base(MTYPE_ULONG|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_push(s,m)\
    _MCode_Base(MTYPE_USHORT|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_puch(s,m)\
    _MCode_Base(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,NULL)

#define _MCode_aStatic(t,s,m,c,i)\
    {t|MTYPE_STATIC_ARRAY,offsetof(s,m),0L,c,i}

#define _MCode_astruct(s,m,c,i)\
    _MCode_aStatic(MTYPE_COMPOUND,s,m,c,i)
#define _MCode_aguid(s,m,c)\
    _MCode_aStatic(MTYPE_GUID,s,m,c,NULL)
#define _MCode_astr(s,m,c)\
    _MCode_aStatic(MTYPE_STRING,s,m,c,NULL)
#define _MCode_austr(s,m,c)\
    _MCode_aStatic(MTYPE_UNICODE_STRING,s,m,c,NULL)
#define _MCode_aul(s,m,c)\
    _MCode_aStatic(MTYPE_ULONG,s,m,c,NULL)
#define _MCode_aush(s,m,c)\
    _MCode_aStatic(MTYPE_USHORT,s,m,c,NULL)
#define _MCode_auch(s,m,c)\
    _MCode_aStatic(MTYPE_UCHAR,s,m,c,NULL)

#define _MCode_pastruct(s,m,c,i)\
    _MCode_aStatic(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,c,i)
#define _MCode_paguid(s,m,c)\
    _MCode_aStatic(MTYPE_GUID|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pastr(s,m,c)\
    _MCode_aStatic(MTYPE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paustr(s,m,c)\
    _MCode_aStatic(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paul(s,m,c)\
    _MCode_aStatic(MTYPE_ULONG|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paush(s,m,c)\
    _MCode_aStatic(MTYPE_USHORT|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pauch(s,m,c)\
    _MCode_aStatic(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,c,NULL)

#define _MCode_aCounted(t,s,m,c,i) {\
    t|MTYPE_COUNTED_ARRAY,\
    offsetof(s,m),\
    sizeof(((s *)0)->c),\
    offsetof(s,c),\
    i\
    }

#define _MCode_castruct(s,m,c,i)\
    _MCode_aCounted(MTYPE_COMPOUND,s,m,c,i)
#define _MCode_caguid(s,m,c)\
    _MCode_aCounted(MTYPE_GUID,s,m,c,NULL)
#define _MCode_capwstr(s,m,c)\
    _MCode_aCounted(MTYPE_PWSTR,s,m,c,NULL)
#define _MCode_castr(s,m,c)\
    _MCode_aCounted(MTYPE_STRING,s,m,c,NULL)
#define _MCode_caustr(s,m,c)\
    _MCode_aCounted(MTYPE_UNICODE_STRING,s,m,c,NULL)
#define _MCode_caul(s,m,c)\
    _MCode_aCounted(MTYPE_ULONG,s,m,c,NULL)
#define _MCode_caush(s,m,c)\
    _MCode_aCounted(MTYPE_USHORT,s,m,c,NULL)
#define _MCode_cauch(s,m,c)\
    _MCode_aCounted(MTYPE_UCHAR,s,m,c,NULL)

#define _MCode_pcastruct(s,m,c,i)\
    _MCode_aCounted(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,c,i)
#define _MCode_pcaguid(s,m,c)\
    _MCode_aCounted(MTYPE_GUID|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcapwstr(s,m,c)\
    _MCode_aCounted(MTYPE_PWSTR|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcastr(s,m,c)\
    _MCode_aCounted(MTYPE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaustr(s,m,c)\
    _MCode_aCounted(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaul(s,m,c)\
    _MCode_aCounted(MTYPE_ULONG|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaush(s,m,c)\
    _MCode_aCounted(MTYPE_USHORT|MTYPE_INDIRECT,s,m,c,NULL)



#define MarshalBufferInitialize( MarshalBuffer, BufferLength, Buffer ) {\
    (MarshalBuffer)->First = (PUCHAR)(Buffer);                          \
    (MarshalBuffer)->Current = (PUCHAR)(Buffer);                        \
    (MarshalBuffer)->Last = &(MarshalBuffer)->Current[(BufferLength)];  \
    }


//
// Defines and functions for unmarshalling base types.
// The BYTE masks are perfectly fine and they dont care if
// we are on working on LITTLE_ENDIAN or BIG_ENDIAN etc.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define DfsRtlGetUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (USHORT)((MarshalBuffer)->Current[0]     ) |        \
                            ((MarshalBuffer)->Current[1] << 8),         \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (ULONG) ((MarshalBuffer)->Current[0]      ) |       \
                            ((MarshalBuffer)->Current[1] <<  8) |       \
                            ((MarshalBuffer)->Current[2] << 16) |       \
                            ((MarshalBuffer)->Current[3] << 24),        \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current[2] = BYTE_2(*pValue),                  \
        (MarshalBuffer)->Current[3] = BYTE_3(*pValue),                  \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (pValue)->Data1 = (ULONG) ((MarshalBuffer)->Current[0]      ) | \
                                  ((MarshalBuffer)->Current[1] <<  8) | \
                                  ((MarshalBuffer)->Current[2] << 16) | \
                                  ((MarshalBuffer)->Current[3] << 24) , \
        (pValue)->Data2 = (USHORT)((MarshalBuffer)->Current[4]      ) | \
                                  ((MarshalBuffer)->Current[5] <<  8) , \
        (pValue)->Data3 = (USHORT)((MarshalBuffer)->Current[6]      ) | \
                                  ((MarshalBuffer)->Current[7] <<  8) , \
        memcpy((pValue)->Data4, &(MarshalBuffer)->Current[8], 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )


//
// This routine is being used for DFS_UPD_REFERRAL_BUFFER. These
// routines will continue to be used in the future as well since
// we want to keep the structure of DFS_UPD_REFERRAL_BUFFER well
// defined rather than using the Marshalling routines provided here.
//
#define _PutGuid(cp, pguid)                      \
        cp[0] = BYTE_0((pguid)->Data1),          \
        cp[1] = BYTE_1((pguid)->Data1),          \
        cp[2] = BYTE_2((pguid)->Data1),          \
        cp[3] = BYTE_3((pguid)->Data1),          \
        cp[4] = BYTE_0((pguid)->Data2),          \
        cp[5] = BYTE_1((pguid)->Data2),          \
        cp[6] = BYTE_0((pguid)->Data3),          \
        cp[7] = BYTE_1((pguid)->Data3),          \
        memcpy(&cp[8], (pguid)->Data4, 8)


#define _PutULong(cp, ularg)                    \
        cp[0] = BYTE_0(ularg),                  \
        cp[1] = BYTE_1(ularg),                  \
        cp[2] = BYTE_2(ularg),                  \
        cp[3] = BYTE_3(ularg)


#define _GetULong(cp, ularg)                    \
        ularg = (ULONG) (cp[0])         |       \
                        (cp[1] << 8)    |       \
                        (cp[2] << 16)   |       \
                        (cp[3] << 24)


#define DfsRtlPutGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (MarshalBuffer)->Current[0] = BYTE_0((pValue)->Data1),          \
        (MarshalBuffer)->Current[1] = BYTE_1((pValue)->Data1),          \
        (MarshalBuffer)->Current[2] = BYTE_2((pValue)->Data1),          \
        (MarshalBuffer)->Current[3] = BYTE_3((pValue)->Data1),          \
        (MarshalBuffer)->Current[4] = BYTE_0((pValue)->Data2),          \
        (MarshalBuffer)->Current[5] = BYTE_1((pValue)->Data2),          \
        (MarshalBuffer)->Current[6] = BYTE_0((pValue)->Data3),          \
        (MarshalBuffer)->Current[7] = BYTE_1((pValue)->Data3),          \
        memcpy(&(MarshalBuffer)->Current[8], (pValue)->Data4, 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )



#define DfsRtlSizeString(pString, pSize) (                              \
    ((pString)->Length > 0) ? (                                         \
        ((pString)->Buffer != NULL) ?                                   \
            (*(pSize)) += (2 + (pString)->Length),                      \
            STATUS_SUCCESS                                              \
        :   STATUS_DATA_ERROR                                           \
        )                                                               \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizepwString(pString, pSize) (                            \
        (*pString != NULL) ?                                            \
            (*(pSize)) += ((1 + wcslen(*pString))*sizeof(WCHAR)),       \
            STATUS_SUCCESS                                              \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizeUnicodeString(pUnicodeString, pSize)                  \
    DfsRtlSizeString(pUnicodeString, pSize)


NTSTATUS
DfsRtlGet(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
);


NTSTATUS
DfsRtlPut(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
);


NTSTATUS
DfsRtlSize(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PVOID Item,
    OUT PULONG Size
);

VOID
DfsRtlUnwindGet(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PMARSHAL_TYPE_INFO LastTypeInfo,
    IN  PVOID Item
);

#ifdef __cplusplus
}
#endif

#endif // _DFSMRSHL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsstr.h ===
//+--------------------------------------------------------------------------
// Module Name: Dfsstr.h
//
// Copyright 1985-96, Microsoft Corporation
//
// Contents:    This module is a common place for all strings in DFS.
//
//---------------------------------------------------------------------------

#ifndef _DFSSTRING_H_
#define _DFSSTRING_H_

//
// Display names for use by Dfs related code
//

#define DFS_COMPONENT_NAME      L"Distributed File System"
#define DFS_PROVIDER_NAME       DFS_COMPONENT_NAME

//
// Commonly used strings and characters
//

#define UNICODE_PATH_SEP_STR    L"\\"
#define UNICODE_PATH_SEP        L'\\'
#define UNICODE_DRIVE_SEP_STR   L":"
#define UNICODE_DRIVE_SEP       L':'


//
// Registry key and value names for storing Dfs volume information
//

#define VOLUMES_DIR             L"Software\\Microsoft\\Dfs\\volumes\\"
#define DOMAIN_ROOT_VOL         L"domainroot"
#define ROOT_SHARE_VALUE_NAME   L"RootShare"
#define CHANGE_LOG_DIR          L"Software\\Microsoft\\Dfs\\ChangeLog\\"
#define CHANGE_ID_VALUE_NAME    L"ChangeId"
#define MAX_CHANGES_VALUE_NAME  L"MaxChanges"
#define NUM_CHANGES_VALUE_NAME  L"NumberOfChanges"
#define CHANGES_KEY_NAME        L"Changes"

//
// The share to connect with to get a referral
//

#define ROOT_SHARE_NAME         L"\\IPC$"
#define ROOT_SHARE_NAME_NOBS    L"IPC$"

//
// Names of driver created objects
//

#define DFS_DEVICE_DIR          L"\\Device\\WinDfs"
#define ORG_NAME                L"Root"
#define DFS_DEVICE_ROOT         L"\\Device\\WinDfs\\Root"
#define DFS_DEVICE_ORG          DFS_DEVICE_ROOT

//
// The share name used to identify UNC access to a Dfs name
//

#define DFS_SHARENAME           L"\\DFS"
#define DFS_SHARENAME_NOBS      L"DFS"

//
// Registry key and value names for storing local volume information
//

#define REG_KEY_LOCAL_VOLUMES   L"SYSTEM\\CurrentControlSet\\Services\\DFS\\LocalVolumes"
#define REG_VALUE_ENTRY_PATH    L"EntryPath"
#define REG_VALUE_ENTRY_TYPE    L"EntryType"
#define REG_VALUE_STORAGE_ID    L"StorageId"

//
// Registry key and value name for retrieving list of trusted domain names
//

#define REG_KEY_TRUSTED_DOMAINS  L"SYSTEM\\CurrentControlSet\\Services\\NetLogon\\Parameters"
#define REG_VALUE_TRUSTED_DOMAINS L"TrustedDomainList"

//
// The following two are related and must be kept in sync. One is the name
// of the named pipe as used by user-level processes. The second names the
// same pipe for kernel-mode code.
//

#define DFS_MESSAGE_PIPE        L"\\\\.\\pipe\\DfsMessage"
#define DFS_KERNEL_MESSAGE_PIPE L"\\Device\\NamedPipe\\DfsMessage"

#endif //_DFSSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dfsrtl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsrtl.c
//
//  Contents:
//
//  Functions:  DfsRtlPrefixPath - Is one path a prefix of another?
//
//  History:    27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"
#include "dfsrtl.h"

#define Dbg              (DEBUG_TRACE_RTL)

#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsRtlPrefixPath )

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsRtlPrefixPath, local
//
//  Synopsis:   This routine will return TRUE if the first string argument
//              is a path name prefix of the second string argument.
//
//  Arguments:  [Prefix] -- Pointer to target device object for
//                      the request.
//              [Test] -- Pointer to I/O request packet
//              [IgnoreCase] -- TRUE if the comparison should be done
//                      case-insignificant.
//
//  Returns:    BOOLEAN - TRUE if Prefix is a prefix of Test and the
//                      comparison ends at a path separator character.
//
//--------------------------------------------------------------------


BOOLEAN
DfsRtlPrefixPath (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Test,
    IN BOOLEAN IgnoreCase
) {
    int cchPrefix;

    if (Prefix->Length > Test->Length) {

        return FALSE;

    }

    cchPrefix = Prefix->Length / sizeof (WCHAR);

    if (Prefix->Length < Test->Length &&
            Test->Buffer[cchPrefix] != L'\\') {

        return FALSE;

    }

    return( RtlPrefixUnicodeString( Prefix, Test, IgnoreCase ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\dnr.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dnr.h
//
//  Contents:   Definitions for distributed name resolution context
//
//  History:    26 May 1992     Alanw   Created
//              04 Sep 1992     Milans  Added support for replica selection
//
//--------------------------------------------------------------------------


#include "rpselect.h"

//
// Maximum number of times we'll go around the main loop in DnrResolveName.
//

#define MAX_DNR_ATTEMPTS    16

//  The following define a Name resolution context which describes the
//  state of an ongoing name resolution.  A pointer to this context is
//  used as the argument to a DPC which will initiate the next step of
//  name resolution.


typedef enum    {
    DnrStateEnter = 0,
    DnrStateStart,              // Start or restart nameres process
    DnrStateGetFirstDC,         // contact a dc, so that we can...
    DnrStateGetReferrals,       // ask knowledge server for referral
    DnrStateGetNextDC,
    DnrStateCompleteReferral,   // waiting for I/O completion of referral req.
    DnrStateSendRequest,        // requesting Open, ResolveName, etc.
    DnrStatePostProcessOpen,    // resume Dnr after call to provider
    DnrStateGetFirstReplica,    // select the first server.
    DnrStateGetNextReplica,     // a server failed, select another
    DnrStateSvcListCheck,       // exhausted svc list, see if svc list changed
    DnrStateDone,               // done, complete the IRP
    DnrStateLocalCompletion = 101       // like done, small optimization
} DNR_STATE;



typedef struct _DNR_CONTEXT {

    //
    //  The type and size of this record (must be DSFS_NTC_DNR_CONTEXT)
    //
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    DNR_STATE           State;          // State of name resolution
    SECURITY_CLIENT_CONTEXT SecurityContext;  // Security context of caller.
    PDFS_PKT_ENTRY      pPktEntry;      // pointer to locked PKT entry
    ULONG               USN;            // USN of pPktEntry when we cached it
    PDFS_SERVICE        pService;       // pointer to file service being used
    PPROVIDER_DEF       pProvider;      // Same as pService->pProvider

    //
    // The Provider Defs are protected by DfsData.Resource. We don't want
    // to hold this (or any other) resource when going over the net. So, we
    // cache that part of the provider def that we need to use upon returning
    // from the network call.
    //

    USHORT              ProviderId;
    PDEVICE_OBJECT      TargetDevice;

    //
    // Since we don't want to hold any locks while going over the net,
    // we need to reference the authenticated tree connection to the server
    // we will send the open request to.
    //

    PFILE_OBJECT        AuthConn;

    // The pService field is protected by Pkt.Resource. Again, we don't want
    // to hold this resource when going over the net. However, we need to
    // use pService->ConnFile to send a referral request. So, we reference
    // and cache the pService->ConnFile in the DnrContext, release the Pkt,
    // then send the referral request over the cached DCConnFile.
    //

    PFILE_OBJECT        DCConnFile;

    PDFS_CREDENTIALS    Credentials;    // Credentials to use during Dnr
    PIRP_CONTEXT        pIrpContext;    // associated IRP context
    PIRP                OriginalIrp;    // original IRP we started with
    NTSTATUS            FinalStatus;    // status to complete IRP with
    PDFS_FCB            FcbToUse;       // If DNR succeeds, FCB to use.
    PDFS_VCB            Vcb;            // associated DFS_VCB

    // The DFS_NAME_CONTEXT instance is required to be passed down to all
    // the underlying providers. The FileName is the first field in the
    // DFS_NAME_CONTEXT as well.
    // This overlaying facilitates the manipulation of DFS_NAME_CONTEXT


    UNICODE_STRING      FileName;       // file name being processed
    union {
      UNICODE_STRING      ContextFileName;       // file name being processed
      DFS_NAME_CONTEXT    DfsNameContext; // the Dfs name context to be passed down
    };
    UNICODE_STRING      RemainingPart;  // remaining part of file name
    UNICODE_STRING      SavedFileName;  // The one that came with the file
    PFILE_OBJECT        SavedRelatedFileObject; // object.
    USHORT              NewNameLen;     // Length of translated name.

    REPL_SELECT_CONTEXT RSelectContext; // Context for replica selection
    REPL_SELECT_CONTEXT RDCSelectContext; // Context for DC replica selection
    ULONG               ReferralSize;   // size of buffer needed for referral
    unsigned int        Attempts;       // number of name resolution attempts
    BOOLEAN             ReleasePkt;     // if TRUE, Pkt resource must be freed
    BOOLEAN             DnrActive;      // if TRUE, DnrNameResolve active on this context
    BOOLEAN             GotReferral;    // if TRUE, last action was a referral
    BOOLEAN             FoundInconsistency; // if TRUE, last referral involved
                                        // inconsistencies in it.
    BOOLEAN             CalledDCLocator;// if TRUE, we have already called locator
    BOOLEAN             Impersonate;    // if TRUE, we need to impersonate using SecurityToken
    BOOLEAN             NameAllocated;  // if TRUE, FileName.Buffer was allocated separately
    BOOLEAN             GotReparse;     // if TRUE, the a non-mup redir returned STATUS_REPARSE
    BOOLEAN             CachedConnFile; // if TRUE, the connfile connection was a cached one
    PDEVICE_OBJECT      DeviceObject;
    LARGE_INTEGER       StartTime;
    PDFS_TARGET_INFO    pDfsTargetInfo;
    PDFS_TARGET_INFO    pNewTargetInfo;
} DNR_CONTEXT, *PDNR_CONTEXT;


//
//  The initial length of a referral requested over the network.
//

#define MAX_REFERRAL_LENGTH     PAGE_SIZE

//
//  The max length we'll go for a referral
//

#define MAX_REFERRAL_MAX        (0xe000)

typedef struct DFS_OFFLINE_SERVER {
    UNICODE_STRING LogicalServerName;
    LIST_ENTRY     ListEntry;
} DFS_OFFLINE_SERVER, *PDFS_OFFLINE_SERVER;

extern BOOLEAN MupUseNullSessionForDfs;

//
//  Prototypes for functions in dnr.c
//

NTSTATUS
DnrStartNameResolution(
    IN    PIRP_CONTEXT IrpContext,
    IN    PIRP  Irp,
    IN    PDFS_VCB  Vcb
);

NTSTATUS
DnrNameResolve(
    IN    PDNR_CONTEXT DnrContext
);

VOID
DnrComposeFileName(
    OUT PUNICODE_STRING FullName,
    IN  PDFS_VCB            Vcb,
    IN  PFILE_OBJECT    RelatedFile,
    IN  PUNICODE_STRING FileName
);

NTSTATUS
DfsCreateConnection(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    IN BOOLEAN       CSCAgentCreate,
    OUT PHANDLE     handle
);

NTSTATUS
DfsCloseConnection(
        IN PDFS_SERVICE pService
);

BOOLEAN
DnrConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
);

PIRP
DnrBuildFsControlRequest (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS
DfspIsRootOnline(
    PUNICODE_STRING Name,
    BOOLEAN CSCAgentCreate
);


NTSTATUS
DfspMarkServerOffline(
   PUNICODE_STRING ServerName
);

NTSTATUS
DfspMarkServerOnline(
   PUNICODE_STRING ServerName
);

PLIST_ENTRY 
DfspGetOfflineEntry(
    PUNICODE_STRING ServerName
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fastio.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       fastio.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8/11/93		Milans created
//
//-----------------------------------------------------------------------------

#ifndef _FASTIO_
#define _FASTIO_

extern FAST_IO_DISPATCH FastIoDispatch;
extern FS_FILTER_CALLBACKS FsFilterCallbacks;

#endif // _FASTIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fcbsup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fcbsup.h
//
//  Contents:   Declarations for DFS_FCB lookup support functions.
//
//  History:    20 Feb 1993     Alanw   Created
//
//--------------------------------------------------------------------------

#ifndef __FCBSUP_H__
#define __FCBSUP_H__

//
//      In order to avoid modifying file objects which are passed
//      through the DFS and used by other file systems, DFS_FCB records
//      used by DFS are not directly attached to the file object
//      through one of the fscontext fields, they are instead
//      associated with the file object, and looked up as needed.
//
//      A hashing mechanism is used for the lookup.  Since the
//      file object being looked up is just a pointer, the hash
//      function is just a simple combination of a few of the low-
//      order bits of the pointer's address.
//

//
//  Declaration of the hash table.  The hash table can be variably
//  sized, with the hash table size being a parameter of the hash
//  function.
//

typedef struct _FCB_HASH_TABLE {

    //
    //  The type and size of this record (must be DSFS_NTC_FCB_HASH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Mask value for the hash function.  The hash table size is
    //  assumed to be a power of two; the mask is the size - 1.
    //

    ULONG HashMask;

    //
    //  A spinlock to protect access to the hash bucket lists.
    //

    KSPIN_LOCK HashListSpinLock;

    //
    //  An array of list heads for the hash table chains.  There
    //  are actually N of these where N is the hash table size.
    //

    LIST_ENTRY  HashBuckets[1];
} FCB_HASH_TABLE, *PFCB_HASH_TABLE;



NTSTATUS
DfsInitFcbs(
  IN    ULONG n
);

VOID
DfsUninitFcbs(
  VOID);

PDFS_FCB
DfsLookupFcb(
  IN    PFILE_OBJECT pFile
);

VOID
DfsAttachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
);

VOID
DfsDetachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
);

#endif  // __FCBSUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    filobsup.c

Abstract:

    This module implements the mup file object support routines.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

#include "mup.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupDecodeFileObject )
#pragma alloc_text( PAGE, MupSetFileObject )
#endif

VOID
MupSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object.
    This routine MUST be called with the Global Lock held.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to the vcb.
        structure.

    FsContext2 - NULL

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupSetFileObject, FileObject = %08lx\n", (ULONG)FileObject );

    //
    // Set the fscontext fields of the file object.
    //

    FileObject->FsContext  = FsContext;
    FileObject->FsContext2 = FsContext2;

    DebugTrace(-1, Dbg, "MupSetFileObject -> VOID\n", 0);

    return;
}


BLOCK_TYPE
MupDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the MUP and figures out what it really is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    FsContext - Receive the file object FsContext pointer

    FsContext2 - Receive the file object FsContext2 pointer


Return Value:

    BlockType - Returns the node type code for a Vcb or Fcb.

        Vcb - indicates that file object opens the mup driver.

        Ccb - indicates that the file object is for a broadcast mailslot file.

        Zero - indicates that the file object has been closed.

--*/

{
    BLOCK_TYPE blockType;
    PBLOCK_HEADER pBlockHead;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupDecodeFileObject, FileObject = %08lx\n", (ULONG)FileObject);

    //
    // Acquire the global lock to protect the block reference counts.
    //

    MupAcquireGlobalLock();

    //
    // Read the fs FsContext fields of the file object, then reference
    // the block pointed at by the file object
    //

    *FsContext = FileObject->FsContext;
    *FsContext2 = FileObject->FsContext2;

    ASSERT( (*FsContext) != NULL );

    if ((*FsContext) == NULL) {

        blockType = BlockTypeUndefined;
    }
    else {
      pBlockHead = (PBLOCK_HEADER)(*FsContext);
      if ( ((pBlockHead->BlockType != BlockTypeVcb) &&
	    (pBlockHead->BlockType != BlockTypeFcb)) ||
	   ((pBlockHead->BlockState != BlockStateActive) &&
	    (pBlockHead->BlockState != BlockStateClosing)) ) {
	*FsContext = NULL;
        blockType = BlockTypeUndefined;
      } else {

        //
        // The node is active.  Supply a referenced pointer to the node.
        //

        blockType = BlockType( pBlockHead );
        MupReferenceBlock( pBlockHead );

      }
    }

    //
    // Release the global lock and return to the caller.
    //

    MupReleaseGlobalLock();

    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "Referencing block %08lx\n",
               (ULONG)*FsContext);
    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "    Reference count = %lx\n",
               ((PBLOCK_HEADER)(*FsContext))->ReferenceCount );

    DebugTrace(-1, Dbg, "MupDecodeFileObject -> %08lx\n", blockType);

    return blockType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fastio.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       fastio.c
//
//  Contents:   Routines to implement Fast IO
//
//  Classes:
//
//  Functions:
//
//  History:    8/11/93         Milans created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "fsctrl.h"
#include "fastio.h"
#include "fcbsup.h"

#define Dbg              (DEBUG_TRACE_FASTIO)

BOOLEAN
DfsFastIoCheckIfPossible (
    FILE_OBJECT *pFileObject,
    LARGE_INTEGER *pOffset,
    ULONG Length,
    BOOLEAN fWait,
    ULONG LockKey,
    BOOLEAN fCheckForRead,
    IO_STATUS_BLOCK *pIoStatusBlock,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoRead(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoWrite(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoQueryBasicInfo(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoQueryStandardInfo(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoLock(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoUnlockSingle(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );


BOOLEAN
DfsFastIoUnlockAll(
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoUnlockAllByKey(
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoDeviceControl(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject);

VOID
DfsFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice);

BOOLEAN
DfsFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

PFAST_IO_DISPATCH
DfsFastIoLookup(
    IN FILE_OBJECT *pFileObject,
    IN DEVICE_OBJECT *DeviceObject,
    IN PDEVICE_OBJECT *targetVdo);

NTSTATUS
DfsPreAcquireForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreReleaseForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreAcquireForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreReleaseForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreAcquireForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreReleaseForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFastIoCheckIfPossible )
#pragma alloc_text( PAGE, DfsFastIoRead )
#pragma alloc_text( PAGE, DfsFastIoWrite )
#pragma alloc_text( PAGE, DfsFastIoQueryBasicInfo )
#pragma alloc_text( PAGE, DfsFastIoQueryStandardInfo )
#pragma alloc_text( PAGE, DfsFastIoLock )
#pragma alloc_text( PAGE, DfsFastIoUnlockSingle )
#pragma alloc_text( PAGE, DfsFastIoUnlockAll )
#pragma alloc_text( PAGE, DfsFastIoUnlockAllByKey )
#pragma alloc_text( PAGE, DfsFastIoDeviceControl )
#pragma alloc_text( PAGE, DfsFastIoDetachDevice )
#pragma alloc_text( PAGE, DfsFastIoQueryNetworkOpenInfo )
#pragma alloc_text( PAGE, DfsFastIoMdlRead )
#pragma alloc_text( PAGE, DfsFastIoMdlReadComplete )
#pragma alloc_text( PAGE, DfsFastIoPrepareMdlWrite )
#pragma alloc_text( PAGE, DfsFastIoMdlWriteComplete )
#pragma alloc_text( PAGE, DfsFastIoReadCompressed )
#pragma alloc_text( PAGE, DfsFastIoWriteCompressed )
#pragma alloc_text( PAGE, DfsFastIoMdlReadCompleteCompressed )
#pragma alloc_text( PAGE, DfsFastIoMdlWriteCompleteCompressed )
#pragma alloc_text( PAGE, DfsFastIoLookup )
#pragma alloc_text( PAGE, DfsPreAcquireForSectionSynchronization )
#pragma alloc_text( PAGE, DfsPreReleaseForSectionSynchronization )
#pragma alloc_text( PAGE, DfsPreAcquireForModWrite )
#pragma alloc_text( PAGE, DfsPreReleaseForModWrite )
#pragma alloc_text( PAGE, DfsPreAcquireForCcFlush )
#pragma alloc_text( PAGE, DfsPreReleaseForCcFlush )

#endif // ALLOC_PRAGMA

//
//  Note: We don't register the 6 Acquire/Release FastIo Dispatches here
//  because we filter this operations through the FsFilterCallback interface
//  which allows DFS to interop better with file system filters.
//

FAST_IO_DISPATCH FastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),
    DfsFastIoCheckIfPossible,           //  CheckForFastIo
    DfsFastIoRead,                      //  FastIoRead
    DfsFastIoWrite,                     //  FastIoWrite
    DfsFastIoQueryBasicInfo,            //  FastIoQueryBasicInfo
    DfsFastIoQueryStandardInfo,         //  FastIoQueryStandardInfo
    DfsFastIoLock,                      //  FastIoLock
    DfsFastIoUnlockSingle,              //  FastIoUnlockSingle
    DfsFastIoUnlockAll,                 //  FastIoUnlockAll
    DfsFastIoUnlockAllByKey,            //  FastIoUnlockAllByKey
    NULL,                               //  FastIoDeviceControl
    NULL,                               //  AcquireFileForNtCreateSection
    NULL,                               //  ReleaseFileForNtCreateSection
    DfsFastIoDetachDevice,              //  FastIoDetachDevice
    DfsFastIoQueryNetworkOpenInfo,      //  FastIoQueryNetworkOpenInfo
    NULL,                               //  AcquireForModWrite
    DfsFastIoMdlRead,                   //  MdlRead
    DfsFastIoMdlReadComplete,           //  MdlReadComplete
    DfsFastIoPrepareMdlWrite,           //  PrepareMdlWrite
    DfsFastIoMdlWriteComplete,          //  MdlWriteComplete
    DfsFastIoReadCompressed,            //  FastIoReadCompressed
    DfsFastIoWriteCompressed,           //  FastIoWriteCompressed
    DfsFastIoMdlReadCompleteCompressed, //  MdlReadCompleteCompressed
    DfsFastIoMdlWriteCompleteCompressed,//  MdlWriteCompleteCompressed
    NULL,                               //  FastIoQueryOpen
    NULL,                               //  ReleaseForModWrite
    NULL,                               //  AcquireForCcFlush
    NULL,                               //  ReleaseForCcFlush
};

//
//  NOTE: Dfs has been changed to use the FsFilter interfaces to intercept the
//        Acquire/Release calls traditionally supported via the FastIo path
//        to provide better file system filter driver support.
//
//        By hooking these operations via the FsFilter interfaces, Dfs is able 
//        to propogate the additional information provided through these 
//        interfaces to file system filters as it redirects the operation to
//        a different driver stack (such as the device stack for 
//        LanmanRedirector or WebDavRedirector).
//        
//        This also provides a more consistent interface for these 
//        Acquire/Release operations for file system filter drivers.  With Dfs
//        supporting this interface, filters will only get called through the
//        FsFilter interfaces for these operations on both local and remote
//        file systems.
//

FS_FILTER_CALLBACKS FsFilterCallbacks =
{
    sizeof( FS_FILTER_CALLBACKS ),
    0,
    DfsPreAcquireForSectionSynchronization,     //  PreAcquireForSectionSynchronization
    NULL,                                       //  PostAcquireForSectionSynchronization
    DfsPreReleaseForSectionSynchronization,     //  PreReleaseForSectionSynchronization
    NULL,                                       //  PostReleaseForSectionSynchronization
    DfsPreAcquireForCcFlush,                    //  PreAcquireForCcFlush
    NULL,                                       //  PostAcquireForCcFlush
    DfsPreReleaseForCcFlush,                    //  PreReleaseForCcFlush
    NULL,                                       //  PostReleaseForCcFlush
    DfsPreAcquireForModWrite,                   //  PreAcquireForModWrite
    NULL,                                       //  PostAcquireForModWrite
    DfsPreReleaseForModWrite,                   //  PreReleaseForModWrite
    NULL                                        //  PostReleaseForModWrite
};
    

//
// Macro to see if a PFAST_IO_DISPATCH has a particular field
//

#define IS_VALID_INDEX(pfio, e)                                 \
    ((pfio != NULL)                                       &&    \
     (pfio->SizeOfFastIoDispatch >=                             \
        (offsetof(FAST_IO_DISPATCH, e) + sizeof(PVOID)))  &&    \
     (pfio->e != NULL)                                          \
    )


//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoLookup
//
//  Synopsis:   Given a file object, this routine will locate the fast IO
//              dispatch table for the underlying provider
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

PFAST_IO_DISPATCH
DfsFastIoLookup(
    IN FILE_OBJECT *pFileObject,
    IN DEVICE_OBJECT *DeviceObject,
    OUT PDEVICE_OBJECT *targetVdo)
{
    PFAST_IO_DISPATCH   pFastIoTable;

    *targetVdo = NULL;

    DfsDbgTrace(+1, Dbg, "DfsFastIoLookup: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS) {

        //
        // In this case we now need to do an DFS_FCB Lookup to figure out where to
        // go from here.
        //

        TYPE_OF_OPEN    TypeOfOpen;
        PDFS_VCB            Vcb;
        PDFS_FCB            Fcb;

        TypeOfOpen = DfsDecodeFileObject( pFileObject, &Vcb, &Fcb);

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        if (TypeOfOpen == RedirectedFileOpen) {

            //
            // In this case the target device is in the Fcb itself.
            //

            *targetVdo = Fcb->TargetDevice;

            pFastIoTable = (*targetVdo)->DriverObject->FastIoDispatch;

            DfsDbgTrace(0,Dbg, "DfsFastIoLookup: DvObj: %08lx",DeviceObject);
            DfsDbgTrace(0, Dbg, "TargetVdo %08lx\n", *targetVdo);
            DfsDbgTrace(-1,Dbg, "DfsFastIoLookup: Exit-> %08lx\n",pFastIoTable );

            return(pFastIoTable);

        } else {

            //
            // This can happen for opens against mup device, so its legal
            // to return NULL here. Dont assert (bug 422334)
            //

            DfsDbgTrace( 0, Dbg, "DfsFastIoLookup: TypeOfOpen      = %s\n",
                ( (TypeOfOpen == UnopenedFileObject) ? "UnopenedFileObject":
                (TypeOfOpen == LogicalRootDeviceOpen) ? "LogicalRootDeviceOpen":
                                                        "???") );

            DfsDbgTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", NULL );

            return(NULL);

        }

    } else if (DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM) {

        DfsDbgTrace(0, Dbg, "DfsFastIoLookup: Dfs File System\n", 0);

        return( NULL );

    } else {

        //
        // This is an unknown device object type and we dont know what to do
        //

        DfsDbgTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", NULL );

        return(NULL);

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoCheckIfPossible
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoCheckIfPossible (
    FILE_OBJECT *pFileObject,
    LARGE_INTEGER *pOffset,
    ULONG Length,
    BOOLEAN fWait,
    ULONG LockKey,
    BOOLEAN fCheckForRead,
    IO_STATUS_BLOCK *pIoStatusBlock,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH   pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoCheckIfPossible Enter \n", 0);
    pFastIoTable = DfsFastIoLookup(pFileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoCheckIfPossible) ) {

        fPossible = pFastIoTable->FastIoCheckIfPossible(
                        pFileObject,
                        pOffset,
                        Length,
                        fWait,
                        LockKey,
                        fCheckForRead,
                        pIoStatusBlock,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoCheckIfPossible Exit \n", 0);

    return(fPossible);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoRead
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoRead Enter \n", 0);
    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoRead) ) {

        fPossible =  pFastIoTable->FastIoRead(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoRead Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoWrite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoWrite) ) {

        fPossible = pFastIoTable->FastIoWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoWrite Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoQueryBasicInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoQueryBasicInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoQueryBasicInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryBasicInfo) ) {

        fPossible = pFastIoTable->FastIoQueryBasicInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoQueryBasicInfo Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoQueryStandardInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoQueryStandardInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoQueryStandardInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryStandardInfo) ) {

        fPossible = pFastIoTable->FastIoQueryStandardInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoQueryStandardInfo Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoLock
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoLock(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoLock Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoLock) ) {

        fPossible = pFastIoTable->FastIoLock(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoLock Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoUnlockSingle
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockSingle(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoUnlockSingle Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockSingle) ) {

        fPossible = pFastIoTable->FastIoUnlockSingle(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoUnlockSingle Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoUnlockAll
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockAll(
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoUnlockAll Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockAll) ) {

        fPossible = pFastIoTable->FastIoUnlockAll(
                        FileObject,
                        ProcessId,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoUnlockAll Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   FastIoUnlockAllByKey
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockAllByKey(
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoUnlockAllByKey Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockAllByKey) ) {

        fPossible = pFastIoTable->FastIoUnlockAllByKey(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoUnlockAllByKey Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoDeviceControl
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;
    TYPE_OF_OPEN        TypeOfOpen;
    PDFS_VCB                Vcb;
    PDFS_FCB                Fcb;

    DfsDbgTrace(+1, Dbg, "DfsFastIoDeviceControl Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoDeviceControl) ) {

        fPossible = pFastIoTable->FastIoDeviceControl(
                        FileObject,
                        Wait,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        IoControlCode,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoDeviceControl Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoDetachDevice, public
//
//  Synopsis:   This routine is a different from the rest of the fast io
//              routines. It is called when a device object is being deleted,
//              and that device object has an attached device. The semantics
//              of this routine are "You attached to a device object that now
//              needs to be deleted; please detach from the said device
//              object."
//
//  Arguments:  [SourceDevice] -- Our device, the one that we created to
//                      attach ourselves to the target device.
//              [TargetDevice] -- Their device, the one that we are attached
//                      to.
//
//  Returns:    Nothing - we must succeed.
//
//-----------------------------------------------------------------------------

VOID
DfsFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice)
{
    NOTHING;
}

BOOLEAN
DfsFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoQueryNetworkOpenInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryNetworkOpenInfo) ) {

        fPossible = pFastIoTable->FastIoQueryNetworkOpenInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoQueryNetworkOpenInfo Exit \n", 0);

    return( fPossible );

}

BOOLEAN
DfsFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlRead Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, MdlRead) ) {

        fPossible = pFastIoTable->MdlRead(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FsRtlMdlReadDev(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlRead Exit \n", 0);

    return( fPossible );
}

BOOLEAN
DfsFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlReadComplete Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, MdlReadComplete) ) {

        fResult = pFastIoTable->MdlReadComplete(
                        FileObject,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FsRtlMdlReadCompleteDev(
                        FileObject,
                        MdlChain,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlReadComplete Exit \n", 0);

    return( fResult );

}

BOOLEAN
DfsFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoPrepareMdlWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, PrepareMdlWrite) ) {

        fPossible = pFastIoTable->PrepareMdlWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FsRtlPrepareMdlWriteDev(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoPrepareMdlWrite Exit \n", 0);

    return( fPossible );
}

BOOLEAN
DfsFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlWriteComplete Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, MdlWriteComplete) ) {

        fResult = pFastIoTable->MdlWriteComplete(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FsRtlMdlWriteCompleteDev(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlWriteComplete Exit \n", 0);

    return( fResult );
}

BOOLEAN
DfsFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoReadCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoReadCompressed) ) {

        fPossible = pFastIoTable->FastIoReadCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoReadCompressed Exit \n", 0);

    return( fPossible );

}


BOOLEAN
DfsFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoWriteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoWriteCompressed) ) {

        fPossible = pFastIoTable->FastIoWriteCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoWriteCompressed Exit \n", 0);

    return( fPossible );

}

BOOLEAN
DfsFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlReadCompleteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, MdlReadCompleteCompressed) ) {

        fResult = pFastIoTable->MdlReadCompleteCompressed(
                        FileObject,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlReadCompleteCompressed Exit \n", 0);

    return( fResult );
}

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlWriteCompleteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, MdlWriteCompleteCompressed) ) {

        fResult = pFastIoTable->MdlWriteCompleteCompressed(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlWriteCompleteCompressed Exit \n", 0);

    return( fResult );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreAcquireForSectionSynchronization
//
//  Synopsis:   This is the equivalent to FastIoAcquireFileForNtCreateSection. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to synchronize
//              for memory-mapped section creation.  If this operation
//              should be redirected to an underlying FS, the parameters will
//              be changed accordingly so that the operation is redirect when 
//              this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS to continue passing this operation through or
//              to take the default action if there are no more devices in the
//              chain.
//
//              STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY to denote that the
//              operation has been satisfied by this callback so no further
//              devices in the chain should be called.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreAcquireForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT targetVdo;
    PFSRTL_COMMON_FCB_HEADER header;
    PDFS_FCB pFcb;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsFastIoLookup( Data->FileObject, Data->DeviceObject, &targetVdo );

    pFcb = DfsLookupFcb(Data->FileObject);

    //
    //  If we've got a valid pFcb and pFcb->FileObject, we need to switch
    //  this operation to the other device stack and file object.
    //
    
    if (targetVdo != NULL &&
            pFcb != NULL && 
                pFcb->FileObject != NULL) {

        IoSetTopLevelIrp( (PIRP) FSRTL_FSP_TOP_LEVEL_IRP );
        
        Data->FileObject = pFcb->FileObject;
        Data->DeviceObject = targetVdo;

        status = STATUS_SUCCESS;

    } else if ((header = Data->FileObject->FsContext) && header->Resource) {

        IoSetTopLevelIrp( (PIRP) FSRTL_FSP_TOP_LEVEL_IRP );

        ExAcquireResourceExclusiveLite( header->Resource, TRUE );

        status = STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY;
        
    } else {

        status = STATUS_SUCCESS;
    }
    
    return status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreReleaseForSectionSynchronization
//
//  Synopsis:   This is the equivalent to FastIoReleaseFileForNtCreateSection. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to end the
//              synchronization operations taken to create a memory-mapped
//              section.  If this operation should be redirected to an 
//              underlying FS, the parameters will be changed accordingly so 
//              that the operation is redirect when this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS to continue passing this operation through or
//              to take the default action if there are no more devices in the
//              chain.
//
//              STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY to denote that the
//              operation has been satisfied by this callback so no further
//              devices in the chain should be called.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreReleaseForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT targetVdo;
    PFSRTL_COMMON_FCB_HEADER header;
    PDFS_FCB pFcb;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsFastIoLookup( Data->FileObject, Data->DeviceObject, &targetVdo );

    pFcb = DfsLookupFcb(Data->FileObject);

    if (targetVdo != NULL &&
            pFcb != NULL && 
                pFcb->FileObject != NULL) {
        
        IoSetTopLevelIrp( (PIRP) NULL );
        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;
        
    } else if ((header = Data->FileObject->FsContext) && header->Resource) {
    
        IoSetTopLevelIrp( (PIRP) NULL );

        ExReleaseResourceLite( header->Resource );

        status = STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreAcquireForModWrite
//
//  Synopsis:   This is the equivalent to FastIoAcquireForModWrite. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to synchronize
//              for modified page writer operations.  If this operation
//              should be redirected to an underlying FS, the parameters will
//              be changed accordingly so that the operation is redirect when 
//              this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              behavior.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreAcquireForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsDbgTrace(+1, Dbg, "DfsPreAcquireForModWrite Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {

        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;

    } else {

        //
        // The lazy write called us because we had the dispatch routine for
        // AcquireFileForModWrite, but the underlying FS did not. So, we
        // return this particular error so that the lazy write knows exactly
        // what happened, and can take the default action.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DfsDbgTrace(-1, Dbg, "DfsPreAcquireForModWrite Exit \n", 0);

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreReleaseForModWrite
//
//  Synopsis:   This is the equivalent to FastIoReleaseForModWrite. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to end the
//              synchronization operations taken to prepare for the modified
//              page writer to do its work.  If this operation should be 
//              redirected to an underlying FS, the parameters will be changed 
//              accordingly so that the operation is redirect when this callback 
//              returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              actions.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreReleaseForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsDbgTrace(+1, Dbg, "DfsPreReleaseForModWrite Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {
        
        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;

    } else {

    
        //
        // The lazy write called us because we had the dispatch routine for
        // AcquireFileForModWrite, but the underlying FS did not. So, we
        // return this particular error so that the lazy write knows exactly
        // what happened, and can take the default action.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DfsDbgTrace(-1, Dbg, "DfsPreReleaseForModWrite Exit \n", 0);

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreAcquireForCcFlush
//
//  Synopsis:   This is the equivalent to FastIoAcquireForCcFlush. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to synchronize
//              for a CC flush of the given file.  If this operation
//              should be redirected to an underlying FS, the parameters will
//              be changed accordingly so that the operation is redirect when 
//              this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              actions.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreAcquireForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsDbgTrace(+1, Dbg, "DfsPreAcquireForCcFlush Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {
        
        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;
        
    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DfsDbgTrace(-1, Dbg, "DfsPreAcquireForCcFlush Exit \n", 0);

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreReleaseForCcFlush
//
//  Synopsis:   This is the equivalent to FastIoReleaseForCcFlush. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to end the
//              synchronization operations taken to prepare for a CC flush
//              of this file.  If this operation should be redirected to an 
//              underlying FS, the parameters will be changed accordingly so 
//              that the operation is redirect when this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              actions.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreReleaseForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );
    
    DfsDbgTrace(+1, Dbg, "DfsPreReleaseForCcFlush Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {

        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    DfsDbgTrace(-1, Dbg, "DfsPreReleaseForCcFlush Exit \n", 0);

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\forward.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fscontrl.c

Abstract:

    This module implements the forwarding of all broadcast requests
    to UNC providers.

Author:

    Manny Weiser (mannyw)    6-Jan-1992

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FORWARD)

//
//  local procedure prototypes
//

NTSTATUS
BuildAndSubmitIrp (
    IN PIRP OriginalIrp,
    IN PCCB Ccb,
    IN PMASTER_FORWARDED_IO_CONTEXT MasterContext
    );

NTSTATUS
ForwardedIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
DeferredForwardedIoCompletionRoutine(
    PVOID Context);

NTSTATUS
CommonForwardedIoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, BuildAndSubmitIrp )
#pragma alloc_text( PAGE, MupForwardIoRequest )
#endif


NTSTATUS
MupForwardIoRequest (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine forwards an I/O Request Packet to all redirectors for
    a broadcast request.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PFCB fcb;
    PVOID fscontext2;
    PLIST_ENTRY listEntry;
    PCCB ccb;
    PMASTER_FORWARDED_IO_CONTEXT masterContext;
    BOOLEAN ownLock = FALSE;

    MupDeviceObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupForwardIrp\n", 0);


    if (MupEnableDfs &&
            MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) {
        status = DfsVolumePassThrough((PDEVICE_OBJECT)MupDeviceObject, Irp);
        return( status );
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Find the FCB for this file object
    //

    FsRtlEnterFileSystem();

    MupDecodeFileObject(
        irpSp->FileObject,
        (PVOID *)&fcb,
        &fscontext2
        );

    if ( fcb == NULL || BlockType( fcb ) != BlockTypeFcb ) {

        //
        // This is not an FCB.
        //

        DebugTrace(0, Dbg, "The fail is closing\n", 0);

        FsRtlExitFileSystem();

        MupCompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST );
        status = STATUS_INVALID_DEVICE_REQUEST;

        DebugTrace(-1, Dbg, "MupForwardRequest -> %08lx\n", status );
        return status;
    }

    //
    // Allocate a context structure
    //

    masterContext = MupAllocateMasterIoContext();

    if (masterContext == NULL) {

        //
        // We ran out of resources.  Clean up and return the error.
        //

        DebugTrace(0, Dbg, "Couldn't allc masterContect\n", 0);

        FsRtlExitFileSystem();

        MupCompleteRequest( Irp, STATUS_INSUFFICIENT_RESOURCES );
        status = STATUS_INSUFFICIENT_RESOURCES;

        DebugTrace(-1, Dbg, "MupForwardRequest -> %08lx\n", status );
        return status;
    }

    DebugTrace( 0, Dbg, "Allocated MasterContext 0x%08lx\n", masterContext );

    IoMarkIrpPending(Irp);

    //
    // At this point, we're committed to returning STATUS_PENDING
    //

    masterContext->OriginalIrp = Irp;

    //
    // set status for MupDereferenceMasterIoContext. If this is still
    // an error when the context is freed then masterContext->ErrorStatus
    // will be used to complete the request.
    //

    masterContext->SuccessStatus = STATUS_UNSUCCESSFUL;
    masterContext->ErrorStatus = STATUS_BAD_NETWORK_PATH;

    //
    // Copy the referenced pointer to the FCB.
    //

    masterContext->Fcb = fcb;

    try {

        //
        // Submit the forwarded IRPs.  Note that we can not hold the lock
        // across calls to BuildAndSubmitIrp as it calls IoCallDriver().
        //

        ACQUIRE_LOCK( &MupCcbListLock );
        ownLock = TRUE;

        listEntry = fcb->CcbList.Flink;

        while ( listEntry != &fcb->CcbList ) {

            RELEASE_LOCK( &MupCcbListLock );
            ownLock = FALSE;

            ccb = CONTAINING_RECORD( listEntry, CCB, ListEntry );

            MupAcquireGlobalLock();
            MupReferenceBlock( ccb );
            MupReleaseGlobalLock();

            BuildAndSubmitIrp( Irp, ccb, masterContext );

            ACQUIRE_LOCK( &MupCcbListLock );
            ownLock = TRUE;

            listEntry = listEntry->Flink;

        }

        RELEASE_LOCK( &MupCcbListLock );
        ownLock = FALSE;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        masterContext->ErrorStatus = GetExceptionCode();

    }

    //
    // If BuildAndSubmitIrp threw an exception, the lock might still be
    // held.  Drop it if so.
    //

    if (ownLock == TRUE) {

        RELEASE_LOCK( &MupCcbListLock );

    }

    //
    // Release our reference to the master IO context block.
    //

    MupDereferenceMasterIoContext( masterContext, NULL );

    //
    // Return to the caller.
    //

    FsRtlExitFileSystem();

    DebugTrace(-1, Dbg, "MupForwardIrp -> %08lx\n", status);
    return STATUS_PENDING;
}


NTSTATUS
BuildAndSubmitIrp (
    IN PIRP OriginalIrp,
    IN PCCB Ccb,
    IN PMASTER_FORWARDED_IO_CONTEXT MasterContext
    )

/*++

Routine Description:

    This routine takes the original IRP and forwards it to the
    the UNC provider described by the CCB.

Arguments:

    OriginalIrp - Supplies the Irp being processed

    Ccb - A pointer the the ccb.

    MasterContext - A pointer to the master context block for this
        forwarded request.

Return Value:

    NTSTATUS - The status for the Irp

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp;
    PFORWARDED_IO_CONTEXT forwardedIoContext = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    ULONG bufferLength;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl = NULL;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "BuildAndSubmitIrp\n", 0);

    try {
        
        // make this NonPagedPool, since we could free this up in the
        // io completion routine.
         
        forwardedIoContext = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( FORWARDED_IO_CONTEXT ),
                                ' puM');

        if (forwardedIoContext == NULL) {

            try_return(status = STATUS_INSUFFICIENT_RESOURCES);

        }

        forwardedIoContext->pIrp = NULL;
        forwardedIoContext->DeviceObject = NULL;

        DebugTrace( 0, Dbg, "Allocated work context 0x%08lx\n", forwardedIoContext );

        //
        // Get the address of the target device object.  Note that this was
        // already done for the no intermediate buffering case, but is done
        // here again to speed up the turbo write path.
        //

        deviceObject = IoGetRelatedDeviceObject( Ccb->FileObject );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.  The allocation is performed with an exception handler
        // in case the caller does not have enough quota to allocate the
        // packet.
        //

        irp = IoAllocateIrp( deviceObject->StackSize, TRUE );

        if (irp == NULL) {

            //
            // An IRP could not be allocated.  Return an appropriate
            // error status code.
            //
            try_return(status = STATUS_INSUFFICIENT_RESOURCES);
        }

        irp->Tail.Overlay.OriginalFileObject = Ccb->FileObject;
        irp->Tail.Overlay.Thread = OriginalIrp->Tail.Overlay.Thread;
        irp->RequestorMode = KernelMode;

        //
        // Get a pointer to the stack location for the first driver.  This will be
        // used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Copy the parameters from the original request.
        //

        RtlMoveMemory(
            irpSp,
            IoGetCurrentIrpStackLocation( OriginalIrp ),
            sizeof( *irpSp )
            );

        bufferLength = irpSp->Parameters.Write.Length;

        irpSp->FileObject = Ccb->FileObject;

        //
        // Even though this is probably meaningless to a remote mailslot
        // write, pass it though obediently.
        //

        if (Ccb->FileObject->Flags & FO_WRITE_THROUGH) {
            irpSp->Flags = SL_WRITE_THROUGH;
        }

        requestorMode = OriginalIrp->RequestorMode;

        //
        // Now determine whether this device expects to have data buffered
        // to it or whether it performs direct I/O.  This is based on the
        // DO_BUFFERED_IO flag in the device object.  If the flag is set,
        // then a system buffer is allocated and the caller's data is copied
        // into it.  Otherwise, a Memory Descriptor List (MDL) is allocated
        // and the caller's buffer is locked down using it.
        //

        if (deviceObject->Flags & DO_BUFFERED_IO) {

            //
            // The device does not support direct I/O.  Allocate a system
            // buffer, and copy the caller's data into it.  This is done
            // using an exception handler that will perform cleanup if the
            // operation fails.  Note that this is only done if the operation
            // has a non-zero length.
            //

            irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;

            if ( bufferLength != 0 ) {

                //
                // If the request was made from a mode other than kernel,
                // presumably user, probe the entire buffer to determine
                // whether or not the caller has write access to it.
                //

                if (requestorMode != KernelMode) {
                    ProbeForRead(
                        OriginalIrp->UserBuffer,
                        bufferLength,
                        sizeof( UCHAR )
                        );
                }

                //
                // Allocate the intermediary system buffer from paged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(
                                                    PagedPoolCacheAligned,
                                                    bufferLength,
                                                    ' puM');

                if (irp->AssociatedIrp.SystemBuffer == NULL) {
                    try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }

                RtlMoveMemory(
                    irp->AssociatedIrp.SystemBuffer,
                    OriginalIrp->UserBuffer,
                    bufferLength);

                //
                // Set the IRP_BUFFERED_IO flag in the IRP so that I/O
                // completion will know that this is not a direct I/O
                // operation.  Also set the IRP_DEALLOCATE_BUFFER flag
                // so it will deallocate the buffer.
                //

                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

            } else {

                //
                // This is a zero-length write.  Simply indicate that this is
                // buffered I/O, and pass along the request.  The buffer will
                // not be set to deallocate so the completion path does not
                // have to special-case the length.
                //

                irp->Flags = IRP_BUFFERED_IO;
            }

        } else if (deviceObject->Flags & DO_DIRECT_IO) {

            //
            // This is a direct I/O operation.  Allocate an MDL and invoke the
            // memory management routine to lock the buffer into memory.
            // Note that no MDL is allocated, nor is any memory probed or
            // locked if the length of the request was zero.
            //

            if ( bufferLength != 0 ) {

                //
                // Allocate an MDL, charging quota for it, and hang it
                // off of the IRP.  Probe and lock the pages associated
                // with the caller's buffer for read access and fill in
                // the MDL with the PFNs of those pages.
                //

                mdl = IoAllocateMdl(
                          OriginalIrp->UserBuffer,
                          bufferLength,
                          FALSE,
                          TRUE,
                          irp
                          );

                if (mdl == NULL) {
                    try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }

                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            }

        } else {

            //
            // Pass the address of the caller's buffer to the device driver.
            // It is now up to the driver to do everything.
            //

            irp->UserBuffer = OriginalIrp->UserBuffer;

        }

        //
        // If this write operation is to be performed without any caching,
        // set the appropriate flag in the IRP so no caching is performed.
        //

        if (Ccb->FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
            irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION;
        } else {
            irp->Flags |= IRP_WRITE_OPERATION;
        }

        //
        // Setup the context block
        //

        forwardedIoContext->Ccb = Ccb;
        forwardedIoContext->MasterContext = MasterContext;

        MupAcquireGlobalLock();
        MupReferenceBlock( MasterContext );
        MupReleaseGlobalLock();

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            (PIO_COMPLETION_ROUTINE)ForwardedIoCompletionRoutine,
            forwardedIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Pass the request to the provider.
        //

        IoCallDriver( Ccb->DeviceObject, irp );

        //
        // At this point it is up to the completion routine to free things
        //

        irp = NULL;
        forwardedIoContext = NULL;
        mdl = NULL;

try_exit:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    //
    // Clean up everything if we are returning an error
    //

    if (!NT_SUCCESS(status)) {
        if ( forwardedIoContext != NULL )
            ExFreePool( forwardedIoContext );
        if (  irp != NULL ) {
            if (irp->AssociatedIrp.SystemBuffer != NULL)
                ExFreePool(irp->AssociatedIrp.SystemBuffer);
            IoFreeIrp( irp );
        }
        if ( mdl != NULL )
            IoFreeMdl( mdl );
    }

    DebugTrace(-1, Dbg, "BuildAndSubmitIrp -> 0x%08lx\n", status);

    return status;

}



NTSTATUS
ForwardedIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routines cleans up after a forwarded IRP has completed.

Arguments:

    DeviceObject - A pointer to the MUP device object.

    IRP - A pointer to the IRP being processed.

    Context - A pointer to a block containing the context of a forward IRP.

Return Value:

    None.

--*/

{
    PFORWARDED_IO_CONTEXT ioContext = Context;

    NTSTATUS status = Irp->IoStatus.Status;

    DebugTrace( +1, Dbg, "ForwardedIoCompletionRoutine\n", 0 );
    DebugTrace( 0, Dbg, "Irp     = 0x%08lx\n", Irp );
    DebugTrace( 0, Dbg, "Context = 0x%08lx\n", Context );
    DebugTrace( 0, Dbg, "status  = 0x%08lx\n", status );

    //
    // Give this to a worker thread if we are at too high an Irq level
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ioContext->DeviceObject = DeviceObject;
        ioContext->pIrp = Irp;
        ExInitializeWorkItem(
                &ioContext->WorkQueueItem,
                DeferredForwardedIoCompletionRoutine,
                Context);
        ExQueueWorkItem(&ioContext->WorkQueueItem, CriticalWorkQueue);
    } else {
        CommonForwardedIoCompletionRoutine(
                    DeviceObject,
                    Irp,
                    Context);
    }

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    DebugTrace( -1, Dbg, "ForwardedIoCompletionRoutine exit\n", 0 );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
DeferredForwardedIoCompletionRoutine(
    PVOID Context)
{
    PFORWARDED_IO_CONTEXT ioContext = Context;

    CommonForwardedIoCompletionRoutine(
        ioContext->DeviceObject,
        ioContext->pIrp,
        Context);
}

NTSTATUS
CommonForwardedIoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{

    PFORWARDED_IO_CONTEXT ioContext = Context;

    NTSTATUS status = Irp->IoStatus.Status;

    DeviceObject;

    //
    // Free the Irp, and any additional structures we may have allocated.
    //

    if ( Irp->MdlAddress ) {
        MmUnlockPages( Irp->MdlAddress );
        IoFreeMdl( Irp->MdlAddress );
    }

    if ( Irp->Flags & IRP_DEALLOCATE_BUFFER ) {
        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp( Irp );

    //
    // Release the our referenced blocks.
    //

    MupDereferenceCcb( ioContext->Ccb );
    MupDereferenceMasterIoContext( ioContext->MasterContext, &status );

    //
    // Free the slave forwarded IO context block
    //

    ExFreePool( ioContext );

    return STATUS_MORE_PROCESSING_REQUIRED;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fileinfo.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FILEINFO.C
//
//  Contents:   This module implements the File Information routines for
//              Dfs called by the dispatch driver.
//
//  Functions:  DfsFsdSetInformation - FSD entry point for NtSetInformationFile
//              DfsFspSetInformation - FSP entry point for NtSetInformationFile
//              DfsCommonSetInformation - Implement SetInformationFile for DFS
//              DfsSetRenameInfo - Takes care of rename restrictions.
//              DfsSetDispositionInfo - Enforces Deletion of StgId restrictions.
//
//  Notes:      No query information routines are presently used.
//              These requests are passed directly through to a redirected
//              file (if one exists).
//
//  History:    30 Jun 1992     AlanW   Created from FastFAT source.
//              09 Feb 1994     SudK    Added Rename/Delete restrictions.
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "dnr.h"
#include "mupwml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsSetDispositionInfo (
    IN PIRP Irp
    );

NTSTATUS
DfsSetRenameInfo (
    IN PIRP Irp,
    IN PDFS_VCB Vcb,
    IN PDFS_FCB Fcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsFsdQueryInformation )
#pragma alloc_text ( PAGE, DfsFsdSetInformation )
#pragma alloc_text ( PAGE, DfsFspSetInformation )
#pragma alloc_text ( PAGE, DfsCommonSetInformation )
#pragma alloc_text ( PAGE, DfsSetDispositionInfo )
#pragma alloc_text ( PAGE, DfsSetRenameInfo )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsdQueryInformation, public
//
//  Synopsis:   This routine implements the FSD part of the
//              NtQueryInformationFile API call
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object where
//                      the file being queried exists.
//              [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsdQueryInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_NAME_INFORMATION FileNameInfo;
    UNICODE_STRING FileNameToUse;
    ULONG BufferLength, BytesToCopy;
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;
    BOOLEAN completeIrp;


    ASSERT(ARGUMENT_PRESENT(DeviceObject));
    ASSERT(ARGUMENT_PRESENT(Irp));

    DfsDbgTrace(+1, Dbg, "DfsFsdQueryInformation - Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;

    DfsDbgTrace(0, Dbg, "InfoLevel = %d\n", FileInformationClass);

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER ||
            DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM) {

        DfsCompleteRequest( NULL, Irp, STATUS_INVALID_DEVICE_REQUEST );

        DfsDbgTrace(-1, Dbg, "DfsFsdQueryInformation - Mup/File System\n", 0);

        return( STATUS_INVALID_DEVICE_REQUEST );

    }

    ASSERT( DeviceObject->DeviceType == FILE_DEVICE_DFS );

    if (FileInformationClass != FileNameInformation &&
            FileInformationClass != FileAlternateNameInformation) {

        Status = DfsVolumePassThrough(DeviceObject, Irp);

        DfsDbgTrace(-1, Dbg,
            "DfsFsdQueryInformation: Exit -> %08lx\n", ULongToPtr(Status) );

        return Status;

    }

    FileObject = IrpSp->FileObject;

    //
    //  Decode the file object. Remember that there need not be an Fcb always.
    //

    TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);

    if (Fcb != NULL) {

        completeIrp = TRUE;

        switch (TypeOfOpen) {

        default:
            //
            //  We cannot get info on a device open
            //

            Status = STATUS_INVALID_PARAMETER;

            break;

        case RedirectedFileOpen:
        case UnknownOpen:

            FileNameInfo = (PFILE_NAME_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

            BufferLength = IrpSp->Parameters.QueryFile.Length;

            if (FileInformationClass == FileAlternateNameInformation)
                FileNameToUse = Fcb->AlternateFileName;
            else
                FileNameToUse = Fcb->FullFileName;


            if (BufferLength < sizeof(FILE_NAME_INFORMATION)) {

                Status = STATUS_INVALID_PARAMETER;

            }

            if (FileNameToUse.Length == 0) {

                ASSERT(FileInformationClass == FileAlternateNameInformation);

                Status = DfsVolumePassThrough(DeviceObject, Irp);

                completeIrp = FALSE;

            } else {
                 BufferLength -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

		 if (BufferLength < FileNameToUse.Length) {
		   BytesToCopy = BufferLength;
                   Status = STATUS_BUFFER_OVERFLOW;
		   BufferLength = 0;
		 }
		 else {
		   BytesToCopy = FileNameToUse.Length;
		   BufferLength -= BytesToCopy;
		 }
		 FileNameInfo->FileNameLength = FileNameToUse.Length;

		 if (BytesToCopy > 0) {
	             RtlCopyMemory(
                        (PVOID) &FileNameInfo->FileName,
                        (PVOID) FileNameToUse.Buffer,
                        BytesToCopy);
		 }

                Irp->IoStatus.Information = 
                    IrpSp->Parameters.QueryFile.Length - BufferLength;
            }

            break;
        }

        if (completeIrp)
            DfsCompleteRequest( NULL, Irp, Status );

    } else {

        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( NULL, Irp, Status );

    }

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdQueryInformation -> %08lx\n", ULongToPtr(Status) );

    return Status;

}


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdSetInformation, public
//
//  Synopsis:   This routine implements the FSD part of the
//              NtSetInformationFile API call.
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object where
//                      the file being set exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    ASSERT(ARGUMENT_PRESENT(DeviceObject));
    ASSERT(ARGUMENT_PRESENT(Irp));

    DfsDbgTrace(+1, Dbg, "DfsFsdSetInformation\n", 0);

    //
    //  Call the common set routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonSetInformation( IrpContext, Irp );

    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdSetInformation -> %08lx\n", ULongToPtr(Status) );

    UNREFERENCED_PARAMETER( DeviceObject );

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspSetInformation, public
//
//  Synopsis:   This routine implements the FSP part of the
//              NtSetInformationFile API call.
//
//  Arguments:  [IrpContext] -- The IRP_CONTEXT record for the operation
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------

VOID
DfsFspSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(+1, Dbg, "DfsFspSetInformation\n", 0);

    //
    //  Call the common set routine.  The Fsp is always allowed to block
    //

    (VOID)DfsCommonSetInformation( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspSetInformation -> VOID\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonSetInformation, private
//
//  Synopsis:   This is the common routine for setting file information called
//              by both the FSD and FSP threads.
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------
//

NTSTATUS
DfsCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    PFILE_OBJECT FileObject;
    FILE_INFORMATION_CLASS FileInformationClass;
    PDEVICE_OBJECT      Vdo, DeviceObject;

    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DfsDbgTrace(+1, Dbg, "DfsCommonSetInformation...\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                    = %08lx\n", Irp);
    DfsDbgTrace( 0, Dbg, "->Length               = %08lx\n", ULongToPtr(IrpSp->Parameters.SetFile.Length) );
    DfsDbgTrace( 0, Dbg, "->FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass);
    DfsDbgTrace( 0, Dbg, "->ReplaceFileObject    = %08lx\n", IrpSp->Parameters.SetFile.FileObject);
    DfsDbgTrace( 0, Dbg, "->ReplaceIfExists      = %08lx\n", IrpSp->Parameters.SetFile.ReplaceIfExists);
    DfsDbgTrace( 0, Dbg, "->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    FileObject = IrpSp->FileObject;
    DeviceObject = IrpSp->DeviceObject;

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER) {
        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DfsDbgTrace(-1, Dbg, "DfsCommonSetInformation - Mup file\n", 0);
        return( STATUS_INVALID_DEVICE_REQUEST );
    }

    //
    //  Decode the file object. Remember that there need not be an Fcb always.
    //

    TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);

    //
    //  Set this handle as having modified the file
    //

    FileObject->Flags |= FO_FILE_MODIFIED;

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {

        default:

            //
            //  We cannot set info on a device open
            //

            try_return( Status = STATUS_INVALID_PARAMETER );

        case RedirectedFileOpen:
        case UnknownOpen:

            break;

        }

        if (Fcb == NULL)
            try_return( Status = STATUS_INVALID_PARAMETER );

        //
        // Copy the stack from one to the next...
        //
        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine( Irp,
                                NULL,
                                NULL,
                                FALSE,
                                FALSE,
                                FALSE);

        //
        //  Call the next device in the chain.
        //

        Status = IoCallDriver( Fcb->TargetDevice, Irp );
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonSetInformation_Error_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));

        //
        //  The IRP will be completed by the called driver.  We have
        //  no need for the IrpContext in the completion routine.
        //

        DfsDeleteIrpContext(IrpContext);

        IrpContext = NULL;

        Irp = NULL;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( DfsCommonSetInformation );

        if (!AbnormalTermination()) {

            DfsCompleteRequest( IrpContext, Irp, Status );

        }

        DfsDbgTrace(-1, Dbg, "DfsCommonSetInformation -> %08lx\n", ULongToPtr(Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fcbsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fcbsup.c
//
//  Contents:   Support routines for associating DFS_FCB records with
//              file objects, and looking them up again.
//
//  Functions:  DfsInitFcbs - Initialize the hash table for DFS_FCB lookup
//              DfsLookupFcb - Lookup an DFS_FCB associated with a file object
//              DfsAttachFcb - Associate an DFS_FCB with a file object
//              DfsDetachFcb - Remove the Association between an DFS_FCB and
//                              a file object
//
//  History:    20 Feb 1993     Alanw   Created
//
//      TODO:   the FcbHashTable and Fcbs are currently allocated
//              out of non-paged pool; these should probably be
//              paged.  This would require using some other
//              synchronization method on the hash bucket chains
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "fcbsup.h"

#define Dbg     0x1000

#define HASH(k,m)       (((ULONG)((ULONG_PTR)(k))>>12^(ULONG)((ULONG_PTR)(k))>>2) & m)

#define DEFAULT_HASH_SIZE       16      // default size of hash table

NTSTATUS
DfsInitFcbHashTable(
    IN  ULONG cHash,
    OUT PFCB_HASH_TABLE *ppHashTable);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsInitFcbs)
#pragma alloc_text(INIT, DfsInitFcbHashTable)
#pragma alloc_text(PAGE, DfsUninitFcbs)

//
// The following routines are not pageable because they acquire spinlocks.
//
// DfsLookupFcb
// DfsAttachFcb
// DfsDetachFcb
//

#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitFcbs - Initialize the DFS_FCB lookup hash table
//
//  Synopsis:   This function initializes data structures which are
//              used for looking up an DFS_FCB associated with some open
//              file object.
//
//  Arguments:  [cHash] -- Size of the hash table to be allocated.  Must be
//                         a power of two.  If zero, a default size is used.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS, unless memory allocation
//                          fails.
//
//  Note:       The hash buckets are initialized to zero, then later
//              initialized to a list head when used.  This is a debugging
//              aid to determine if some hash buckets are never used.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInitFcbHashTable(
    IN  ULONG cHash,
    OUT PFCB_HASH_TABLE *ppHashTable)
{
    PFCB_HASH_TABLE pHashTable;
    ULONG cbHashTable;

    if (cHash == 0) {
        cHash = DEFAULT_HASH_SIZE;
    }
    ASSERT ((cHash & (cHash-1)) == 0);  // Assure cHash is a power of two

    cbHashTable = sizeof (FCB_HASH_TABLE) + (cHash-1)*sizeof (LIST_ENTRY);
    pHashTable = ExAllocatePoolWithTag(NonPagedPool, cbHashTable, ' puM');
    if (pHashTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    pHashTable->NodeTypeCode = DSFS_NTC_FCB_HASH;
    pHashTable->NodeByteSize = (NODE_BYTE_SIZE) cbHashTable;

    pHashTable->HashMask = (cHash-1);
    KeInitializeSpinLock( &pHashTable->HashListSpinLock );
    RtlZeroMemory(&pHashTable->HashBuckets[0], cHash * sizeof (LIST_ENTRY));

    *ppHashTable = pHashTable;

    return(STATUS_SUCCESS);
}

NTSTATUS
DfsInitFcbs(
  IN    ULONG cHash
) {
    NTSTATUS status;

    status = DfsInitFcbHashTable( cHash, &DfsData.FcbHashTable );

    return status;
}

VOID
DfsUninitFcbs(
    VOID)
{
    ExFreePool (DfsData.FcbHashTable);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupFcb - Lookup an DFS_FCB in the hash table
//
//  Synopsis:   This function will lookup the DFS_FCB associated with
//              a particular file object.
//
//  Arguments:  [pFile] -- Pointer to file object for which the DFS_FCB is
//                         being looked up.
//
//  Returns:    PVOID -- pointer to the DFS_FCB found, or NULL if none
//
//  Algorithm:  Knuth would call it hashing with conflict resoulution
//              by chaining.
//
//  History:    20 Feb 1993     Alanw   Created
//
//--------------------------------------------------------------------------


PDFS_FCB
DfsLookupFcb(
  IN    PFILE_OBJECT pFile
) {
    PLIST_ENTRY pListHead, pLink;
    PDFS_FCB pFCB;
    KIRQL SavedIrql;
    PFCB_HASH_TABLE pHashTable = DfsData.FcbHashTable;

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );
    pListHead = &pHashTable->HashBuckets[ HASH(pFile, pHashTable->HashMask) ];

    if ((pListHead->Flink == NULL) ||           // list not initialized
        (pListHead->Flink == pListHead)) {      // list empty
        KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pFCB = CONTAINING_RECORD(pLink, DFS_FCB, HashChain);
        if (pFCB->FileObject == pFile) {
            KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
            return pFCB;
        }
    }
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAttachFcb - Inserts an DFS_FCB into the hash table
//
//  Synopsis:   This function associates an DFS_FCB to a file object.  This
//              involves inserting it into the hash table.
//
//  Arguments:  [pFCB] -- Pointer to the DFS_FCB to be inserted.
//              [pFileObj] -- Pointer to the corresponding file object, used
//                            as the hash key.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsAttachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
) {
    PFCB_HASH_TABLE pHashTable = (PFCB_HASH_TABLE) DfsData.FcbHashTable;
    PLIST_ENTRY pListHead;
    KIRQL SavedIrql;

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );

    pListHead = &pHashTable->HashBuckets[ HASH(pFileObj, pHashTable->HashMask) ];

    if (pListHead->Flink == NULL) {
        InitializeListHead(pListHead);
    }
    InsertHeadList(pListHead, &pFCB->HashChain);
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );

    DfsDbgTrace(0, Dbg, "Attached Fcb %08lx ", pFCB);
    DfsDbgTrace(0, Dbg, "For Fileobject %08lx ", pFileObj);

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDetachFcb - Detach an DFS_FCB from the lookup hash table
//
//  Synopsis:   This function detaches an DFS_FCB from the hash table.  This
//              involves just deleting it from the hash bucket chain.
//
//  Arguments:  [pFCB] -- Pointer to the DFS_FCB to be detached.
//              [pFileObj] -- Pointer to the corresponding file object, used
//                            for debugging only.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------


VOID
DfsDetachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
) {
    PFCB_HASH_TABLE pHashTable = (PFCB_HASH_TABLE) DfsData.FcbHashTable;
    KIRQL SavedIrql;

    ASSERT(pFCB->FileObject == pFileObj);
    ASSERT(DfsLookupFcb(pFCB->FileObject) == pFCB);

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );
    RemoveEntryList(&pFCB->HashChain);
    pFCB->FileObject = NULL;
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );

    DfsDbgTrace(0, Dbg, "Detached Fcb %08lx ", pFCB);
    DfsDbgTrace(0, Dbg, "For Fileobject %08lx ", pFileObj);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fsctrl.c ===
//-----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FSCTRL.C
//
//  Contents:
//      This module implements the File System Control routines for Dfs.
//
//  Functions:
//              DfsFsdFileSystemControl
//              DfsFspFileSystemControl
//              DfsCommonFileSystemControl, local
//              DfsUserFsctl, local
//              DfsOplockRequest, local
//              DfsFsctrlDefineLogicalRoot - Define a new logical root
//              DfsFsctrlUndefineLogicalRoot - Undefine an existing root
//              DfsFsctrlGetLogicalRootPrefix - Retrieve prefix that logical
//                      root maps to.
//              DfsFsctrlGetConnectedResources -
//              DfsFsctrlDefineProvider - Define a file service provider
//              DfsFsctrlGetServerName - Get name of server given prefix
//              DfsFsctrlReadMem - return an internal data struct (debug)
//              DfsCompleteMountRequest - Completion routine for mount IRP
//              DfsCompleteLoadFsRequest - Completion routine for Load FS IRP
//              DfsFsctrlGetPkt
//              DfsFsctrlGetPktEntryState
//              DfsGetEntryStateSize - local
//              DfsGetEntryStateMarshall - local
//              DfsFsctrlSetPktEntryState
//              DfsSetPktEntryActive
//              DfsSetPktEntryTimeout
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "creds.h"
#include "dnr.h"
#include "know.h"
#include "fsctrl.h"
#include "mupwml.h"

#ifdef TERMSRV
NTKERNELAPI
NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    );
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)


//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsFsctrlDefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlDefineRootCredentials(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlUndefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlGetLogicalRootPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetConnectedResources(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetServerName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG   InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlReadMem (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_READ_MEM Request,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlGetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetPkt(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsGetEntryStateSize(
    IN ULONG Level,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_PKT_ENTRY pktEntry,
    IN PULONG pcbOutBuffer);

NTSTATUS
DfsGetEntryStateMarshall(
    IN ULONG Level,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_PKT_ENTRY pktEntry,
    IN PBYTE OutputBuffer,
    IN ULONG cbOutBuffer);

NTSTATUS
DfsFsctrlSetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput);

NTSTATUS
DfsFsctrlGetSpcTable(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsSetPktEntryActive(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_PKT_ENTRY pktEntry,
    IN DWORD State);

NTSTATUS
DfsSetPktEntryTimeout(
    IN PDFS_PKT_ENTRY pktEntry,
    IN ULONG Timeout);

NTSTATUS
DfsGetPktSize(
    OUT PULONG pSize);

NTSTATUS
DfsGetPktMarshall(
    IN PBYTE Buffer,
    IN ULONG Size);

NTSTATUS
DfsGetSpcTableNames(
    PIRP   Irp,
    PUCHAR OutputBuffer,
    ULONG  OutputBufferLength);

NTSTATUS
DfsExpSpcTableName(
    LPWSTR SpcName,
    PIRP   Irp,
    PUCHAR OutputBuffer,
    ULONG  OutputBufferLength);

NTSTATUS
DfsGetSpcDcInfo(
    PIRP   Irp,
    PUCHAR OutputBuffer,
    ULONG  OutputBufferLength);

NTSTATUS
DfsFsctrlSpcSetDc(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput);


NTSTATUS
DfsTreeConnectGetConnectionInfo(
    IN PDFS_SERVICE Service, 
    IN PDFS_CREDENTIALS Creds,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG InfoLen);

NTSTATUS
DfsFsctrlGetConnectionPerfInfo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlCscServerOffline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlCscServerOnline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlSpcRefresh (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength);

VOID
MupGetDebugFlags(VOID);

VOID
DfsGetEventLogValue(VOID);

VOID
DfsStopDfs();

void
DfsDumpBuf(
    PCHAR cp,
    ULONG len
);

BOOLEAN
DfspIsSpecialShare(
    PUNICODE_STRING ShareName);

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName);

extern
BOOLEAN DfsIsSpecialName( PUNICODE_STRING pName);

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING SpecialShares[] = {
    UNICODE_STRING_STRUCT(L"PIPE"),
    UNICODE_STRING_STRUCT(L"IPC$"),
    UNICODE_STRING_STRUCT(L"ADMIN$"),
    UNICODE_STRING_STRUCT(L"MAILSLOT")
};

static UNICODE_STRING SysVolShares[] = {
    UNICODE_STRING_STRUCT(L"SYSVOL"),
    UNICODE_STRING_STRUCT(L"NETLOGON")
};


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdFileSystemControl )
#pragma alloc_text( PAGE, DfsFspFileSystemControl )
#pragma alloc_text( PAGE, DfsCommonFileSystemControl )
#pragma alloc_text( PAGE, DfsUserFsctl )
#pragma alloc_text( PAGE, DfsFsctrlIsThisADfsPath )
#pragma alloc_text( PAGE, DfsOplockRequest )
#pragma alloc_text( PAGE, DfsFsctrlDefineLogicalRoot )
#pragma alloc_text( PAGE, DfsFsctrlDefineRootCredentials )
#pragma alloc_text( PAGE, DfsFsctrlUndefineLogicalRoot )
#pragma alloc_text( PAGE, DfsFsctrlGetLogicalRootPrefix )
#pragma alloc_text( PAGE, DfsFsctrlGetConnectedResources )
#pragma alloc_text( PAGE, DfsFsctrlGetServerName )
#pragma alloc_text( PAGE, DfsFsctrlReadMem )
#pragma alloc_text( PAGE, DfsStopDfs )
#pragma alloc_text( PAGE, DfspIsSpecialShare )
#pragma alloc_text( PAGE, DfspIsSysVolShare )
#pragma alloc_text( PAGE, DfsFsctrlGetPkt )
#pragma alloc_text( PAGE, DfsFsctrlGetPktEntryState )
#pragma alloc_text( PAGE, DfsGetEntryStateSize )
#pragma alloc_text( PAGE, DfsGetEntryStateMarshall )
#pragma alloc_text( PAGE, DfsFsctrlSetPktEntryState )
#pragma alloc_text( PAGE, DfsSetPktEntryActive )
#pragma alloc_text( PAGE, DfsSetPktEntryTimeout )
#pragma alloc_text( PAGE, DfsGetPktSize )
#pragma alloc_text( PAGE, DfsGetPktMarshall )
#pragma alloc_text( PAGE, DfsFsctrlGetSpcTable )
#pragma alloc_text( PAGE, DfsGetSpcTableNames )
#pragma alloc_text( PAGE, DfsExpSpcTableName )
#pragma alloc_text( PAGE, DfsGetSpcDcInfo )
#pragma alloc_text( PAGE, DfsFsctrlSpcSetDc )
#pragma alloc_text( PAGE, DfsTreeConnectGetConnectionInfo)
#pragma alloc_text( PAGE, DfsFsctrlGetConnectionPerfInfo)

#pragma alloc_text( PAGE, DfsFsctrlCscServerOffline)
#pragma alloc_text( PAGE, DfsFsctrlCscServerOnline)
#pragma alloc_text( PAGE, DfsFsctrlSpcRefresh)

#endif // ALLOC_PRAGMA



//+-------------------------------------------------------------------
//
//  Function:   DfsFsdFileSystemControl, public
//
//  Synopsis:   This routine implements the FSD part of FileSystem
//              control operations
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object
//                      where the file exists
//              [Irp] -- Supplies the Irp being processed
//
//  Returns:    [NTSTATUS] -- The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    BOOLEAN Wait;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    ULONG FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DfsDbgTrace(+1, Dbg, "DfsFsdFileSystemControl\n", 0);

    //
    //  Call the common FileSystem Control routine, with blocking allowed
    //  if synchronous.  This opeation needs to special case the mount
    //  and verify suboperations because we know they are allowed to block.
    //  We identify these suboperations by looking at the file object field
    //  and seeing if it's null.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->FileObject == NULL) {

        Wait = TRUE;

    } else {

        Wait = CanFsdWait( Irp );

    }

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, Wait );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonFileSystemControl( DeviceObject, IrpContext, Irp );

    } except( DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdFileSystemControl -> %08lx\n", ULongToPtr(Status));

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspFileSystemControl, public
//
//  Synopsis:   This routine implements the FSP part of the file system
//              control operations
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    Nothing.
//
//--------------------------------------------------------------------

VOID
DfsFspFileSystemControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(+1, Dbg, "DfsFspFileSystemControl\n", 0);

    //
    //  Call the common FileSystem Control routine.
    //

    DfsCommonFileSystemControl( NULL, IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspFileSystemControl -> VOID\n", 0 );

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonFileSystemControl, local
//
//  Synopsis:   This is the common routine for doing FileSystem control
//              operations called by both the FSD and FSP threads
//
//  Arguments:  [DeviceObject] -- The one used to enter our FSD Routine
//              [IrpContext] -- Context associated with the Irp
//              [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - The return status for the operation
//--------------------------------------------------------------------

NTSTATUS
DfsCommonFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp, NextIrpSp;
    ULONG FsControlCode;
    PFILE_OBJECT FileObject;
    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    DfsDbgTrace(+1, Dbg, "DfsCommonFileSystemControl\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                = %08lx\n", Irp);
    DfsDbgTrace( 0, Dbg, "MinorFunction      = %08lx\n", IrpSp->MinorFunction);

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

        //
        // If the DFS FSCTL is issued via a device that is not the DFS 
        // file system device object, then reject the request.
        //
        if ((IS_DFS_CTL_CODE(FsControlCode) == 0) ||
            (DeviceObject == DfsData.FileSysDeviceObject)) {
            Status = DfsUserFsctl( IrpContext, Irp );
        }
        else {
            DfsDbgTrace(0, Dbg, "Invalid Device object for FS control %08lx\n",
	         	     DeviceObject);

            DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    case IRP_MN_MOUNT_VOLUME:
    case IRP_MN_VERIFY_VOLUME:

        //
        // We are processing a MOUNT/VERIFY request being directed to our
        // our File System Device Object. We don't directly support
        // disk volumes, so we simply reject.
        //

        ASSERT(DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM);

        Status = STATUS_NOT_SUPPORTED;

        DfsCompleteRequest( IrpContext, Irp, Status );

        break;

    default:
      {
	PDFS_FCB Fcb;
	PDFS_VCB Vcb;

       if (DfsDecodeFileObject(IrpSp->FileObject, &Vcb, &Fcb) != RedirectedFileOpen) {

          DfsDbgTrace(0, Dbg, "Invalid FS Control Minor Function %08lx\n",
               IrpSp->MinorFunction);

          DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

          Status = STATUS_INVALID_DEVICE_REQUEST;

       }
       else {

          //
          // Copy the stack from one to the next...
          //
          NextIrpSp = IoGetNextIrpStackLocation(Irp);
          (*NextIrpSp) = (*IrpSp);

          IoSetCompletionRoutine(     Irp,
                                      NULL,
                                      NULL,
                                      FALSE,
                                      FALSE,
                                      FALSE);
  
          //
          //  Call to the real device for the file object.
          //

          Status = IoCallDriver( Fcb->TargetDevice, Irp );
          MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonFileSystemControl_Error_IoCallDriver,
                               LOGSTATUS(Status)
                               LOGPTR(Irp)
                               LOGPTR(FileObject)
                               LOGPTR(DeviceObject));
          //
          //  The IRP will be completed by the called driver.  We have
          //      no need for the IrpContext in the completion routine.
          //

          DfsDeleteIrpContext(IrpContext);
          IrpContext = NULL;
          Irp = NULL;
       }
        break;
      }
    }
    DfsDbgTrace(-1, Dbg, "DfsCommonFileSystemControl -> %08lx\n", ULongToPtr(Status) );

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsUserFsctl, local
//
//  Synopsis:   This is the common routine for implementing the user's
//              requests made through NtFsControlFile.
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PIO_STACK_LOCATION NextIrpSp;
    NTSTATUS Status;
    ULONG FsControlCode;

    ULONG cbOutput;
    ULONG cbInput;

    PUCHAR InputBuffer;
    PUCHAR OutputBuffer;

    PDFS_FCB Fcb;
    PDFS_VCB DfsVcb;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    //
    // Just in case some-one (cough) forgets about it...
    // ...zero information status now!
    //

    Irp->IoStatus.Information = 0L;

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    cbInput = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    cbOutput = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DfsDbgTrace(+1, Dbg, "DfsUserFsctl:  Entered\n", 0);
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  Cntrl Code  -> %08lx\n", ULongToPtr(FsControlCode) );
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  cbInput   -> %08lx\n", ULongToPtr(cbInput) );
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  cbOutput   -> %08lx\n", ULongToPtr(cbOutput) );

    //
    //  All DFS FsControlCodes use METHOD_BUFFERED, so the SystemBuffer
    //  is used for both the input and output.
    //

    InputBuffer = OutputBuffer = Irp->AssociatedIrp.SystemBuffer;

    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  InputBuffer -> %08lx\n", InputBuffer);
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  UserBuffer  -> %08lx\n", Irp->UserBuffer);

    //
    //  Case on the control code.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:

        Status = DfsOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME:
        Status = STATUS_NOT_SUPPORTED;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_GET_VERSION:
        if (OutputBuffer != NULL &&
                cbOutput >= sizeof(DFS_GET_VERSION_ARG)) {
            PDFS_GET_VERSION_ARG parg =
                (PDFS_GET_VERSION_ARG) OutputBuffer;
            parg->Version = 1;
            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DFS_GET_VERSION_ARG);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_STOP_DFS:
        DfsStopDfs();
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;


    case  FSCTL_DFS_IS_ROOT:
        Status = STATUS_INVALID_DOMAIN_ROLE;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_IS_VALID_PREFIX: {
            PDFS_IS_VALID_PREFIX_ARG PrefixArg;

            UNICODE_STRING fileName, pathName;

            PrefixArg = (PDFS_IS_VALID_PREFIX_ARG)InputBuffer;

            if (cbInput < sizeof(DFS_IS_VALID_PREFIX_ARG)
                    ||
                (ULONG)(FIELD_OFFSET(DFS_IS_VALID_PREFIX_ARG,RemoteName) +
                    PrefixArg->RemoteNameLen) > cbInput
            ) {
                Status = STATUS_INVALID_PARAMETER;
                DfsCompleteRequest(IrpContext, Irp, Status);
                break;
            }

            //
            // Reject negative and odd RemoteNameLen's
            //
            if (PrefixArg->RemoteNameLen < 0
                    ||
                (PrefixArg->RemoteNameLen & 0x1) != 0
            ) {
                Status = STATUS_INVALID_PARAMETER;
                DfsCompleteRequest(IrpContext, Irp, Status);
                break;
            }

            fileName.Length = PrefixArg->RemoteNameLen;
            fileName.MaximumLength = (USHORT) PrefixArg->RemoteNameLen;
            fileName.Buffer = (PWCHAR) PrefixArg->RemoteName;

            try {

                Status = DfsFsctrlIsThisADfsPath(
                             &fileName,
                             PrefixArg->CSCAgentCreate,
                             &pathName );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Status = STATUS_INVALID_PARAMETER;

            }

            DfsCompleteRequest(IrpContext, Irp, Status);

        }
        break;

    case  FSCTL_DFS_IS_VALID_LOGICAL_ROOT:
        if (cbInput == sizeof(WCHAR)) {

            UNICODE_STRING logRootName, Remaining;
            WCHAR buffer[3];
            PDFS_VCB RootVcb;
	    LUID LogonID;

            buffer[0] = *((PWCHAR) InputBuffer);
            buffer[1] = UNICODE_DRIVE_SEP;
            buffer[2] = UNICODE_PATH_SEP;

            logRootName.Length = sizeof(buffer);
            logRootName.MaximumLength = sizeof(buffer);
            logRootName.Buffer = buffer;

	    DfsGetLogonId(&LogonID);

#ifdef TERMSRV
            Status = IoGetRequestorSessionId(Irp, &SessionID);

            if (NT_SUCCESS(Status)) {
                Status = DfsFindLogicalRoot(&logRootName, SessionID, &LogonID, &RootVcb, &Remaining);
            }
#else
            Status = DfsFindLogicalRoot(&logRootName, &LogonID, &RootVcb, &Remaining);
#endif

            if (!NT_SUCCESS(Status)) {
                DfsDbgTrace(0, Dbg, "Logical root not found!\n", 0);

                Status = STATUS_NO_SUCH_DEVICE;
            }

        } else {

            Status = STATUS_INVALID_PARAMETER;

        }
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_PKT_SET_DC_NAME:
        Status = DfsFsctrlSetDCName(IrpContext,
                                    Irp,
                                    InputBuffer,
                                    cbInput);
        break;

    case  FSCTL_DFS_PKT_SET_DOMAINNAMEFLAT:
        Status = DfsFsctrlSetDomainNameFlat(IrpContext,
                                    Irp,
                                    InputBuffer,
                                    cbInput);
        break;

    case  FSCTL_DFS_PKT_SET_DOMAINNAMEDNS:
        Status = DfsFsctrlSetDomainNameDns(IrpContext,
                                    Irp,
                                    InputBuffer,
                                    cbInput);
        break;


    case  FSCTL_DFS_DEFINE_LOGICAL_ROOT:
        Status = DfsFsctrlDefineLogicalRoot( IrpContext, Irp,
                    (PFILE_DFS_DEF_ROOT_BUFFER)InputBuffer, cbInput);
        break;

    case  FSCTL_DFS_DELETE_LOGICAL_ROOT:
        Status = DfsFsctrlUndefineLogicalRoot( IrpContext, Irp,
                    (PFILE_DFS_DEF_ROOT_BUFFER)InputBuffer, cbInput);
        break;

    case  FSCTL_DFS_GET_LOGICAL_ROOT_PREFIX:
        Status = DfsFsctrlGetLogicalRootPrefix( IrpContext, Irp,
                    (PFILE_DFS_DEF_ROOT_BUFFER)InputBuffer, cbInput,
                    (PUCHAR)OutputBuffer, cbOutput);
        break;

    case  FSCTL_DFS_GET_CONNECTED_RESOURCES:
        Status = DfsFsctrlGetConnectedResources(IrpContext,
                                                Irp,
                                                InputBuffer,
                                                cbInput,
                                                OutputBuffer,
                                                cbOutput);
        break;

    case  FSCTL_DFS_DEFINE_ROOT_CREDENTIALS:
        Status = DfsFsctrlDefineRootCredentials(
                    IrpContext,
                    Irp,
                    InputBuffer,
                    cbInput);
        break;

    case  FSCTL_DFS_GET_SERVER_NAME:
        Status = DfsFsctrlGetServerName(IrpContext,
                                        Irp,
                                        InputBuffer,
                                        cbInput,
                                        OutputBuffer,
                                        cbOutput);
        break;

    case  FSCTL_DFS_SET_PKT_ENTRY_TIMEOUT:
        if (cbInput == sizeof(ULONG)) {
            DfsData.Pkt.EntryTimeToLive = *(PULONG) InputBuffer;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;


    case  FSCTL_DFS_PKT_FLUSH_CACHE:
        Status = PktFsctrlFlushCache(IrpContext, Irp,
                                     InputBuffer, cbInput
                                );
        break;

    case  FSCTL_DFS_PKT_FLUSH_SPC_CACHE:
        Status = PktFsctrlFlushSpcCache(IrpContext, Irp,
                                        InputBuffer, cbInput
                                );
        break;

    case  FSCTL_DFS_GET_PKT_ENTRY_STATE:
        Status = DfsFsctrlGetPktEntryState(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput,
                                           OutputBuffer,
                                           cbOutput);
        break;

    case  FSCTL_DFS_SET_PKT_ENTRY_STATE:
        Status = DfsFsctrlSetPktEntryState(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput);
        break;

    case  FSCTL_DFS_GET_PKT:
        Status = DfsFsctrlGetPkt(IrpContext,
                                   Irp,
                                   OutputBuffer,
                                   cbOutput);
        break;


    case  FSCTL_DFS_GET_SPC_TABLE:
        Status = DfsFsctrlGetSpcTable(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput,
                                           OutputBuffer,
                                           cbOutput);
        break;

    case FSCTL_DFS_SPECIAL_SET_DC:
        Status = DfsFsctrlSpcSetDc(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput);
        break;

    case FSCTL_DFS_REREAD_REGISTRY:
        DfsGetEventLogValue();
#if DBG
        MupGetDebugFlags();
#endif  // DBG
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

#if DBG

    case  FSCTL_DFS_INTERNAL_READ_MEM:
        Status = DfsFsctrlReadMem( IrpContext, Irp,
                    (PFILE_DFS_READ_MEM)InputBuffer, cbInput,
                                OutputBuffer, cbOutput );
        break;

    case  FSCTL_DFS_DBG_BREAK:
        DbgBreakPoint();
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_DBG_FLAGS:
        if (cbInput >= sizeof(ULONG))
            DfsDebugTraceLevel = * ((PULONG) InputBuffer);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_VERBOSE_FLAGS:
        if (cbInput >= sizeof(ULONG))
            MupVerbose = * ((PULONG) InputBuffer);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_EVENTLOG_FLAGS:
        if (cbInput >= sizeof(ULONG))
            DfsEventLog = * ((PULONG) InputBuffer);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

#endif  // DBG

    case FSCTL_DFS_GET_CONNECTION_PERF_INFO:
        Status = DfsFsctrlGetConnectionPerfInfo(IrpContext,
						Irp,
						InputBuffer,
						cbInput,
						OutputBuffer,
						cbOutput);
        break;
	

    case FSCTL_DFS_CSC_SERVER_OFFLINE:
        Status = DfsFsctrlCscServerOffline(IrpContext,
						Irp,
						InputBuffer,
						cbInput,
						OutputBuffer,
						cbOutput);
        break;
	

    case FSCTL_DFS_CSC_SERVER_ONLINE:
        Status = DfsFsctrlCscServerOnline(IrpContext,
						Irp,
						InputBuffer,
						cbInput,
						OutputBuffer,
						cbOutput);
        break;
	

    case FSCTL_DFS_SPC_REFRESH:
        Status = DfsFsctrlSpcRefresh(IrpContext,
						Irp,
						InputBuffer,
						cbInput);
        break;
	

    default:

        //
        //  It is not a recognized DFS fsctrl.  If it is for a redirected
        //  file, just pass it along to the underlying file system.
        //

        if (
            (IS_DFS_CTL_CODE(FsControlCode))
                ||
            (DfsDecodeFileObject( IrpSp->FileObject, &DfsVcb, &Fcb) != RedirectedFileOpen)
        ) {
            DfsDbgTrace(0, Dbg, "Dfs: Invalid FS control code -> %08lx\n", ULongToPtr(FsControlCode) );
            DfsCompleteRequest( IrpContext, Irp, STATUS_NOT_SUPPORTED);
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        //
        // Copy the stack from one to the next...
        //
        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine(     Irp,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    FALSE,
                                    FALSE);

        //
        //  Call to the real device for the file object.
        //

        Status = IoCallDriver( Fcb->TargetDevice, Irp );
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsUserFsctl_Error_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));
        //
        //  The IRP will be completed by the called driver.  We have
        //      no need for the IrpContext in the completion routine.
        //

        DfsDeleteIrpContext(IrpContext);
        IrpContext = NULL;
        Irp = NULL;
        break;

    }

    DfsDbgTrace(-1, Dbg, "DfsUserFsctl:  Exit -> %08lx\n", ULongToPtr(Status) );
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsOplockRequest, local
//
//  Synopsis:   DfsOplockRequest will process an oplock request.
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//                         STATUS_OPLOCK_NOT_GRANTED if the oplock is refuesed
//
//
//--------------------------------------------------------------------------

NTSTATUS
DfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    ULONG FsControlCode;
    PDFS_FCB Fcb;
    PDFS_VCB Vcb;
    TYPE_OF_OPEN TypeOfOpen;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PIO_STACK_LOCATION NextIrpSp;


    BOOLEAN AcquiredVcb = FALSE;

    //
    //  Save some references to make our life a little easier
    //

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DfsDbgTrace(+1, Dbg, "DfsOplockRequest...\n", 0);
    DfsDbgTrace( 0, Dbg, "FsControlCode = %08lx\n", ULongToPtr(FsControlCode) );

    //
    //  We only permit oplock requests on files.
    //

    if ((TypeOfOpen = DfsDecodeFileObject(IrpSp->FileObject, &Vcb, &Fcb))
                      != RedirectedFileOpen) {

        //
        // A bit bizarre that someone wants to oplock a device object, but
        // hey, if it makes them happy...
        //


        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DfsDbgTrace(-1, Dbg, "DfsOplockRequest -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // RedirectedFileOpen - we pass the buck to the underlying FS.
        //


        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);
        IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

        //
        //      ...and call the next device
        //

        Status = IoCallDriver( Fcb->TargetDevice, Irp );
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsOplockRequest_Error_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));
        DfsDeleteIrpContext( IrpContext );

        return(Status);

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsStopDfs, local
//
//  Synopsis:   "Stops" the Dfs client - causes Dfs to release all references
//              to provider device objects.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsStopDfs()
{
    ULONG i;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_VCB Vcb;

    ExAcquireResourceExclusiveLite( &DfsData.Pkt.Resource, TRUE );

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    //
    // Lets go through and release any opens to server IPC$ shares and
    // provider device objects.
    //

    for (pktEntry = PktFirstEntry(&DfsData.Pkt);
            pktEntry != NULL;
                pktEntry = PktNextEntry(&DfsData.Pkt, pktEntry)) {

        for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

            if (pktEntry->Info.ServiceList[i].ConnFile != NULL) {

                ObDereferenceObject(
                    pktEntry->Info.ServiceList[i].ConnFile);

                pktEntry->Info.ServiceList[i].ConnFile = NULL;

            }

            if (pktEntry->Info.ServiceList[i].pMachEntry->AuthConn != NULL) {

                ObDereferenceObject(
                    pktEntry->Info.ServiceList[i].pMachEntry->AuthConn);

                pktEntry->Info.ServiceList[i].pMachEntry->AuthConn = NULL;

                pktEntry->Info.ServiceList[i].pMachEntry->Credentials->RefCount--;

                pktEntry->Info.ServiceList[i].pMachEntry->Credentials = NULL;

            }

            //
            // We are going to be closing all references to provider device
            // objects. So, clear the service's pointer to its provider.
            //

            pktEntry->Info.ServiceList[i].pProvider = NULL;

        }

    }

    for (i = 0; i < (ULONG) DfsData.cProvider; i++) {

        if (DfsData.pProvider[i].FileObject != NULL) {

            ObDereferenceObject( DfsData.pProvider[i].FileObject );
            DfsData.pProvider[i].FileObject = NULL;

            ASSERT( DfsData.pProvider[i].DeviceObject != NULL );

            ObDereferenceObject( DfsData.pProvider[i].DeviceObject );
            DfsData.pProvider[i].DeviceObject = NULL;

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    ExReleaseResourceLite( &DfsData.Pkt.Resource );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlIsThisADfsPath, local
//
//  Synopsis:   Determines whether a given path is a Dfs path or not.
//              The general algorithm is:
//
//                - Do a prefix lookup in the Pkt. If an entry is found, it's
//                  a Dfs path.
//                - Ask the Dfs service whether this is a domain based Dfs
//                  path. If so, it's a Dfs path.
//                - Finally, do an ZwCreateFile on the path name (assuming
//                  it's a Dfs path). If it succeeds, it's a Dfs path.
//
//  Arguments:  [filePath] - Name of entire file
//              [pathName] - If this is a Dfs path, this will return the
//                  component of filePath that was a Dfs path name (ie, the
//                  entry path of the Dfs volume that holds the file). The
//                  buffer will point to the same buffer as filePath, so
//                  nothing is allocated.
//
//  Returns:    [STATUS_SUCCESS] -- filePath is a Dfs path.
//
//              [STATUS_BAD_NETWORK_PATH] -- filePath is not a Dfs path.
//
//-----------------------------------------------------------------------------


NTSTATUS
DfsFsctrlIsThisADfsPath(
    IN PUNICODE_STRING  filePath,
    IN BOOLEAN          CSCAgentCreate,
    OUT PUNICODE_STRING pathName)
{
    NTSTATUS status;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    UNICODE_STRING dfsRootName, shareName, remPath;
    UNICODE_STRING RootShareName;
    USHORT i, j;
    BOOLEAN pktLocked;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    KeQuerySystemTime(&StartTime);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlIsThisADfsPath: Entered %wZ\n", filePath);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] DfsFsctrlIsThisADfsPath: Entered %wZ\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
            filePath);
    }
#endif

    //
    // Only proceed if the first character is a backslash.
    //

    if (filePath->Buffer[0] != UNICODE_PATH_SEP) {
        status = STATUS_BAD_NETWORK_PATH;
        DfsDbgTrace(-1, Dbg, "filePath does not begin with backslash\n", 0);
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_PathDoesNotBeginWithBackSlash,
                       LOGSTATUS(status));
        return( status );

    }

    //
    // Find the second component in the name.
    //

    for (i = 1;
            i < filePath->Length/sizeof(WCHAR) &&
                filePath->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {

        NOTHING;

    }

    if (i >= filePath->Length/sizeof(WCHAR)) {
        status = STATUS_BAD_NETWORK_PATH;
        DfsDbgTrace(-1, Dbg, "Did not find second backslash\n", 0);

        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_DidNotFindSecondBackSlash,
                       LOGSTATUS(status));
        return( status );

    }

    status = DfspIsRootOnline(filePath, CSCAgentCreate);
    if (!NT_SUCCESS(status)) {
        return STATUS_BAD_NETWORK_PATH;
    }

    dfsRootName.Length = (i-1) * sizeof(WCHAR);
    dfsRootName.MaximumLength = dfsRootName.Length;
    dfsRootName.Buffer = &filePath->Buffer[1];

    if (dfsRootName.Length == 0) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_DfsRootNameHasZeroLength,
                       LOGSTATUS(status));

        return( status );

    }

    //
    // Figure out the share name
    //

    for (j = i+1;
            j < filePath->Length/sizeof(WCHAR) &&
                filePath->Buffer[j] != UNICODE_PATH_SEP;
                        j++) {

         NOTHING;

    }

    shareName.Length = (j - i - 1) * sizeof(WCHAR);
    shareName.MaximumLength = shareName.Length;
    shareName.Buffer = &filePath->Buffer[i+1];

    if (shareName.Length == 0) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_ShareNameHasZeroLength,
                       LOGSTATUS(status));

        return( status );

    }

    if (DfspIsSpecialShare(&shareName)) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_DfspIsSpecialShare_FALSE,
                       LOGUSTR(shareName)
                       LOGSTATUS(status));

        return( status );

    }


    //
    // For our purposes we only need to check the \\server\share part of the
    // filePath presented.  Any longer matches will be handled in the dnr loop -
    // we don't care about junction points below the root at this stage.
    //
    RootShareName.Buffer = filePath->Buffer;
    RootShareName.Length = j * sizeof(WCHAR);
    RootShareName.MaximumLength = filePath->MaximumLength;
#if DBG
    if (MupVerbose)
        DbgPrint("  RootShareName=[%wZ]\n", &RootShareName);
#endif

    //
    // First, do a prefix lookup. If we find an entry, it's a Dfs path
    //

    pkt = _GetPkt();

    PktAcquireShared( TRUE, &pktLocked );

    pktEntry = PktLookupEntryByPrefix( pkt, &RootShareName, &remPath );

    if (pktEntry != NULL && pktEntry->ExpireTime > 0) {

        DfsDbgTrace(-1, Dbg, "Found pkt entry %08lx\n", pktEntry);

        pathName->Length = RootShareName.Length - remPath.Length;
        pathName->MaximumLength = pathName->Length;
        pathName->Buffer = RootShareName.Buffer;

        PktRelease();
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsFsctrlIsThisADfsPath(1): exit STATUS_SUCCESS\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
        }
#endif
        return( STATUS_SUCCESS );

    }

#if DBG
    if (MupVerbose)  {
        if (pktEntry == NULL)
            DbgPrint("  No pkt entry found.\n");
        else
            DbgPrint("  Stale pkt entry 0x%x ExpireTime=%d\n", pktEntry, pktEntry->ExpireTime);
    }
#endif

    PktRelease();

    //
    // Nothing in the Pkt, check (by getting a referral) is this is a dfs
    //

    status = PktCreateDomainEntry( &dfsRootName, &shareName, CSCAgentCreate );

    if (NT_SUCCESS(status)) {

        pathName->Length = sizeof(UNICODE_PATH_SEP) + dfsRootName.Length;
        pathName->MaximumLength = pathName->Length;
        pathName->Buffer = RootShareName.Buffer;

        DfsDbgTrace(-1, Dbg, "Domain/Machine Dfs name %wZ\n", pathName );
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsFsctrlIsThisADfsPath(2): exit STATUS_SUCCESS\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
        }
#endif
        return( STATUS_SUCCESS );

    }

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] PktCreateDomainEntry() returned 0x%x\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
            status);
     }
#endif

    //
    // Failed getting referral - see if we have a stale one.
    //

    PktAcquireShared( TRUE, &pktLocked );

    pktEntry = PktLookupEntryByPrefix( pkt, &RootShareName, &remPath );

    if (pktEntry != NULL) {

#if DBG
        if (MupVerbose)
            DbgPrint("  Found stale pkt entry %08lx - adding 15 sec to it\n", pktEntry);
#endif
        DfsDbgTrace(-1, Dbg, "Found pkt entry %08lx\n", pktEntry);

        pathName->Length = RootShareName.Length - remPath.Length;
        pathName->MaximumLength = pathName->Length;
        pathName->Buffer = RootShareName.Buffer;

        if (pktEntry->ExpireTime <= 0) {
            pktEntry->ExpireTime = 15;
            pktEntry->TimeToLive = 15;
        }

        PktRelease();
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsFsctrlIsThisADfsPath(3): exit STATUS_SUCCESS\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
        }
#endif
        return( STATUS_SUCCESS );

    }

    PktRelease();

    if (DfspIsSysVolShare(&shareName)) {

#if DBG
        if (MupVerbose)
            DbgPrint("  Trying as sysvol\n");
#endif

        status = PktExpandSpecialName(&dfsRootName, &pSpecialEntry);

        if (NT_SUCCESS(status)) {

            InterlockedDecrement(&pSpecialEntry->UseCount);

#if DBG

            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] DfsFsctrlIsThisADfsPath(SYSVOL): exit STATUS_SUCCESS\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            return STATUS_SUCCESS;

        }

    }

    if (DfsIsSpecialName(&dfsRootName)) {
        status = STATUS_SUCCESS;
        return status;
    }

    DfsDbgTrace(-1, Dbg, "Not A Dfs path\n", 0);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] DfsFsctrlIsThisADfsPath: exit STATUS_BAD_NETWORK_PATH\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
    }
#endif
    status = STATUS_BAD_NETWORK_PATH;
    MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Exit_NotADfsPath,
               LOGSTATUS(status));

    return( STATUS_BAD_NETWORK_PATH );

}




//+----------------------------------------------------------------------------
//
//  Function:   DfspIsSpecialShare, local
//
//  Synopsis:   Sees if a share name is a special share.
//
//  Arguments:  [ShareName] -- Name of share to test.
//
//  Returns:    TRUE if special, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsSpecialShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    for (i = 0;
            (i < (sizeof(SpecialShares) / sizeof(SpecialShares[0]))) &&
                !fSpecial;
                    i++) {

        if (SpecialShares[i].Length == ShareName->Length) {

            if (_wcsnicmp(
                    SpecialShares[i].Buffer,
                        ShareName->Buffer,
                            ShareName->Length/sizeof(WCHAR)) == 0) {

                fSpecial = TRUE;

            }

        }

    }

    return( fSpecial );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsSysVolShare, local
//
//  Synopsis:   Sees if a share name is a sysvol share.
//
//  Arguments:  [ShareName] -- Name of share to test.
//
//  Returns:    TRUE if special, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    for (i = 0;
            (i < (sizeof(SysVolShares) / sizeof(SysVolShares[0]))) &&
                !fSpecial;
                    i++) {

        if (SysVolShares[i].Length == ShareName->Length) {

            if (_wcsnicmp(
                    SysVolShares[i].Buffer,
                        ShareName->Buffer,
                            ShareName->Length/sizeof(WCHAR)) == 0) {

                fSpecial = TRUE;

            }

        }

    }

    return( fSpecial );

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDefineLogicalRoot, local
//
//  Synopsis:   DfsFsctrlDefineLogicalRoot will create a new logical root structure.
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//              [pDlrParam] -- Pointer to a FILE_DFS_DEF_ROOT_BUFFER,
//                      giving the name of the logical root to be created.
//              [InputBufferLength] -- Size of InputBuffer
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      This routine needs to be called from the FSP thread,
//              since IoCreateDevice (called from DfsInitializeLogicalRoot)
//              will fail if PreviousMode != KernelMode.
//
//--------------------------------------------------------------------------


NTSTATUS
DfsFsctrlDefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength
) {
    NTSTATUS Status;
    UNICODE_STRING ustrPrefix;
    BOOLEAN pktLocked;
    PWCHAR wCp;
    PCHAR InputBufferEnd = (PCHAR)pDlrParam + InputBufferLength;
    ULONG i;
    LUID LogonID;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    DfsDbgTrace(+1, Dbg, "DfsFsctrlDefineLogicalRoot...\n", 0);

    //
    //  Reference the input buffer and make sure it's large enough
    //

    if (InputBufferLength < sizeof (FILE_DFS_DEF_ROOT_BUFFER)) {
        DfsDbgTrace(0, Dbg, "Input buffer is too small\n", 0);
        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    //
    // Verify there's a null someplace in the LogicalRoot buffer
    //

    for (i = 0; i < MAX_LOGICAL_ROOT_NAME && pDlrParam->LogicalRoot[i]; i++)
        NOTHING;

    if (i >= MAX_LOGICAL_ROOT_NAME) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }
    
    //
    // Verify there's a null someplace in the RootPrefix buffer
    //

    for (wCp = &pDlrParam->RootPrefix[0]; wCp < (PWCHAR)InputBufferEnd && *wCp; wCp++) {
        NOTHING;
    }

    if (wCp >= (PWCHAR)InputBufferEnd) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    //
    //  We can insert logical roots only from the FSP, because IoCreateDevice
    //  will fail if previous mode != Kernel mode.
    //

    if ((IrpContext->Flags & IRP_CONTEXT_FLAG_IN_FSD) != 0) {
        DfsDbgTrace(0, Dbg, "DfsFsctrlDefineLogicalRoot: Posting to FSP\n", 0);

        Status = DfsFsdPostRequest( IrpContext, Irp );

        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot: Exit -> %08lx\n", ULongToPtr(Status) );

        return(Status);
    }

    //
    // Since we are going to muck with DfsData's VcbQueue, we acquire it
    // exclusively.
    //

    RtlInitUnicodeString(&ustrPrefix, pDlrParam->RootPrefix);

    PktAcquireExclusive( TRUE, &pktLocked );

    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);


    Status = DfsGetLogonId(&LogonID);

#ifdef TERMSRV

    Status = IoGetRequestorSessionId(Irp, &SessionID);

    if( NT_SUCCESS( Status ) ) {
        Status =
            DfsInitializeLogicalRoot(
                (PWSTR) pDlrParam->LogicalRoot,
                &ustrPrefix,
                NULL,
                0,
                SessionID,
		&LogonID );
    }

#else // TERMSRV

    Status = DfsInitializeLogicalRoot(
                        (PWSTR) pDlrParam->LogicalRoot,
                        &ustrPrefix,
                        NULL,
                        0,
			&LogonID );

#endif // TERMSRV

    ExReleaseResourceLite(&DfsData.Resource);

    PktRelease();

    DfsCompleteRequest(IrpContext, Irp, Status);

    DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlUndefineLogicalRoot
//
//  Synopsis:   Deletes an existing logical root structure.
//
//  Arguments:  [IrpContext] --
//              [Irp] --
//              [pDlrParam] -- The LogicalRoot field of this structure will
//                      contain the name of the logical root to be deleted.
//              [InputBufferLength] -- Length of pDlrParam
//
//  Returns:    Yes ;-)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlUndefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength)
{
    NTSTATUS Status;
    BOOLEAN pktLocked;
    ULONG i;
    PWCHAR wCp;
    PCHAR InputBufferEnd = (PCHAR)pDlrParam + InputBufferLength;
    LUID LogonID ;
#ifdef TERMSRV
    ULONG SessionID;
#endif

    DfsDbgTrace(+1, Dbg, "DfsFsctrlUndefineLogicalRoot...\n", 0);

    //
    //  Reference the input buffer and make sure it's large enough
    //

    if (InputBufferLength < sizeof (FILE_DFS_DEF_ROOT_BUFFER)) {
        DfsDbgTrace(0, Dbg, "Input buffer is too small\n", 0);

        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    DfsGetLogonId( &LogonID );
    //
    // Verify there's a null someplace in the LogicalRoot buffer
    //

    for (i = 0; i < MAX_LOGICAL_ROOT_NAME && pDlrParam->LogicalRoot[i]; i++)
        NOTHING;

    if (i >= MAX_LOGICAL_ROOT_NAME) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    if (pDlrParam->LogicalRoot[0] == UNICODE_NULL) {

        //
        // Verify there's a null someplace in the RootPrefix buffer
        //

        for (wCp = &pDlrParam->RootPrefix[0]; wCp < (PWCHAR)InputBufferEnd && *wCp; wCp++) {
            NOTHING;
        }

        if (wCp >= (PWCHAR)InputBufferEnd) {
            Status = STATUS_INVALID_PARAMETER;
            DfsCompleteRequest( IrpContext, Irp, Status );
            DfsDbgTrace(-1, Dbg, "DfsFsctrlUnDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
            return Status;
        }

    }

#ifdef TERMSRV

    if ( !NT_SUCCESS(IoGetRequestorSessionId(Irp, &SessionID)) ) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

#endif

    //
    //  We can remove logical roots only from the FSP
    //

    if (pDlrParam->LogicalRoot[0] != UNICODE_NULL) {

        DfsDbgTrace(0, Dbg, "Deleting root [%ws]\n", pDlrParam->LogicalRoot);

#ifdef TERMSRV

        Status =
            DfsDeleteLogicalRoot(
                (PWSTR) pDlrParam->LogicalRoot,
                pDlrParam->fForce,
                SessionID,
                &LogonID );
#else // TERMSRV

        Status = DfsDeleteLogicalRoot(
                    (PWSTR) pDlrParam->LogicalRoot,
                    pDlrParam->fForce,
                    &LogonID);

#endif // TERMSRV

        DfsDbgTrace(0, Dbg, "DfsDeleteLogicalRoot returned %08lx\n", ULongToPtr(Status) );

    } else {
        UNICODE_STRING name;
        RtlInitUnicodeString(&name, pDlrParam->RootPrefix);

        DfsDbgTrace(0, Dbg, "Deleting connection to [%wZ]\n", &name);

#ifdef TERMSRV

        Status = DfsDeleteDevlessRoot(
		    &name,		
		    SessionID,
		    &LogonID );
#else // TERMSRV

        Status = DfsDeleteDevlessRoot(
                    &name,
                    &LogonID);

#endif // TERMSRV
    }

    DfsCompleteRequest(IrpContext, Irp, Status);

    DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );

    return Status;

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetLogicalRootPrefix
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetLogicalRootPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS Status;
    UNICODE_STRING RootPath, Remaining;
    PDFS_VCB           Vcb;
    WCHAR          RootBuffer[MAX_LOGICAL_ROOT_NAME + 2];
    BOOLEAN        bAcquired = FALSE;
    ULONG          i;
    USHORT         PrefixLength;
    LUID LogonID;


#ifdef TERMSRV
    ULONG SessionID;
#endif

    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetLogicalRootPrefix...\n", 0);

    //
    //  Reference the input buffer and make sure it's large enough
    //

    if (InputBufferLength < sizeof (FILE_DFS_DEF_ROOT_BUFFER)) {
        DfsDbgTrace(0, Dbg, "Input buffer is too small\n", 0);
        Status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < MAX_LOGICAL_ROOT_NAME && pDlrParam->LogicalRoot[i]; i++)
        NOTHING;

    if (i >= MAX_LOGICAL_ROOT_NAME) {
        Status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    RootPath.Buffer = RootBuffer;
    RootPath.Length = 0;
    RootPath.MaximumLength = sizeof RootBuffer;

    Status = DfspLogRootNameToPath(pDlrParam->LogicalRoot, &RootPath);
    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(0, Dbg, "Input name is too big\n", 0);
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    bAcquired = ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    DfsGetLogonId(&LogonID);

#ifdef TERMSRV

    Status = IoGetRequestorSessionId(Irp, &SessionID);

    if( NT_SUCCESS( Status ) ) {

        Status = DfsFindLogicalRoot( &RootPath, SessionID, &LogonID, &Vcb, &Remaining);
    }

#else // TERMSRV

    Status = DfsFindLogicalRoot(&RootPath, &LogonID, &Vcb, &Remaining);

#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(0, Dbg, "Logical root not found!\n", 0);

        Status = STATUS_NO_SUCH_DEVICE;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    PrefixLength = Vcb->LogRootPrefix.Length;

    if ((PrefixLength + sizeof(UNICODE_NULL)) > OutputBufferLength) {

        //
        // Return required length in IoStatus.Information.
        //

        RETURN_BUFFER_SIZE( PrefixLength + sizeof(UNICODE_NULL), Status );

        DfsDbgTrace(0, Dbg, "Output buffer too small\n", 0);
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    //
    // All ok, copy prefix and get out.
    //

    if (PrefixLength > 0) {
        RtlMoveMemory(
            OutputBuffer,
            Vcb->LogRootPrefix.Buffer,
            PrefixLength);
    }
    ((PWCHAR) OutputBuffer)[PrefixLength/sizeof(WCHAR)] = UNICODE_NULL;
    Irp->IoStatus.Information = Vcb->LogRootPrefix.Length + sizeof(UNICODE_NULL);
    Status = STATUS_SUCCESS;

Cleanup:
    if (bAcquired) {
        ExReleaseResourceLite(&DfsData.Resource);
    }
    DfsCompleteRequest(IrpContext, Irp, Status);

    return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetConnectedResources
//
//  Synopsis:   Returns LPNETRESOURCE structures for each Logical Root,
//              starting from the logical root indicated in the InputBuffer
//              and including as many as will fit in OutputBuffer.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsFsctrlGetConnectedResources(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{

    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY Link;
    PDFS_DEVLESS_ROOT pDrt;
    PDFS_VCB    pVcb;
    ULONG       count = 0;
    ULONG       remLen;
    ULONG       skipNum;
    ULONG       DFS_UNALIGNED *retCnt;
    UNICODE_STRING      providerName;
    PUCHAR      buf = OutputBuffer;
    BOOLEAN     providerNameAllocated;
    LUID        LogonID;
    ULONG       ResourceSize;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetConnectedResources, TRUE, TRUE, FALSE);

#ifdef TERMSRV

    //
    // Get SessionID of this request first.
    //

    Status = IoGetRequestorSessionId(Irp, &SessionID);

    if( !NT_SUCCESS(Status) ) {

        Status = STATUS_INVALID_PARAMETER;

        DfsCompleteRequest( IrpContext, Irp, Status );

        DfsDbgTrace(-1,Dbg,
            "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

        return Status;
    }

#endif

    if (OutputBufferLength < sizeof(ULONG)) {

        Status = STATUS_BUFFER_TOO_SMALL;

        DfsCompleteRequest( IrpContext, Irp, Status );

        DfsDbgTrace(-1,Dbg,
            "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

        return( Status );
    }

    if (InputBufferLength < sizeof(DWORD))     {

        Status = STATUS_INVALID_PARAMETER;

        DfsCompleteRequest( IrpContext, Irp, Status );

        DfsDbgTrace(-1,Dbg,
            "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

        return Status;

    }

    if (InputBufferLength == sizeof(DWORD)) {

        skipNum = *((ULONG *) InputBuffer);

        providerName.Length = sizeof(DFS_PROVIDER_NAME) - sizeof(UNICODE_NULL);
        providerName.MaximumLength = sizeof(DFS_PROVIDER_NAME);
        providerName.Buffer = DFS_PROVIDER_NAME;

        providerNameAllocated = FALSE;

    } else {

        skipNum = 0;

        providerName.Length =
            (USHORT) (InputBufferLength - sizeof(UNICODE_NULL));
        providerName.MaximumLength = (USHORT) InputBufferLength;
        providerName.Buffer = ExAllocatePoolWithTag(PagedPool, InputBufferLength, ' puM');

        if (providerName.Buffer != NULL) {

            providerNameAllocated = TRUE;

            RtlCopyMemory(
                providerName.Buffer,
                InputBuffer,
                InputBufferLength);

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;

            DfsCompleteRequest( IrpContext, Irp, Status );

            DfsDbgTrace(-1,Dbg,
                "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

            return Status;

        }

    }

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    remLen = OutputBufferLength-sizeof(ULONG);

    retCnt =  (ULONG *) (OutputBuffer + remLen);

    DfsGetLogonId(&LogonID);

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    //
    // First get the device-less connections
    //

    for (Link = DfsData.DrtQueue.Flink;
            Link != &DfsData.DrtQueue;
                Link = Link->Flink ) {

	pDrt =  CONTAINING_RECORD( Link, DFS_DEVLESS_ROOT, DrtLinks );

#ifdef TERMSRV
	if( (SessionID != INVALID_SESSIONID) &&
	        (SessionID == pDrt->SessionID) &&
	             RtlEqualLuid(&pDrt->LogonID, &LogonID) ) {
#else // TERMSRV
        if ( RtlEqualLuid(&pDrt->LogonID, &LogonID) ) {
#endif

            if (skipNum > 0) {
                skipNum--;
            } else {
                //
                // Report devices for this session only
                //
                Status = DfsGetResourceFromDevlessRoot(
                            Irp,
                            pDrt,
                            &providerName,
                            OutputBuffer,
                            buf,
                            &remLen,
                            &ResourceSize);

                if (!NT_SUCCESS(Status))
                    break;

                buf = buf + ResourceSize;

                count++;
            }
        }
    }

    //
    // Next, get the Device connections
    //

    if (NT_SUCCESS(Status)) {

        for (Link = DfsData.VcbQueue.Flink;
                Link != &DfsData.VcbQueue;
                    Link = Link->Flink ) {

            pVcb = CONTAINING_RECORD( Link, DFS_VCB, VcbLinks );

#ifdef TERMSRV
            if( (pVcb->LogicalRoot.Length == sizeof(WCHAR)) &&
                    (SessionID != INVALID_SESSIONID) &&
                        (SessionID == pVcb->SessionID) &&
	                      RtlEqualLuid(&pVcb->LogonID, &LogonID) ) {
#else // TERMSRV
            if ((pVcb->LogicalRoot.Length == sizeof(WCHAR)) &&
	                RtlEqualLuid(&pVcb->LogonID, &LogonID) ) {
#endif

                if (skipNum > 0) {

                    skipNum--;

                } else {

                    Status = DfsGetResourceFromVcb(
                                Irp,
                                pVcb,
                                &providerName,
                                OutputBuffer,
                                buf,
                                &remLen,
                                &ResourceSize);

                    if (!NT_SUCCESS(Status))
                        break;

                    buf = buf + ResourceSize;

                    count++;
                }
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        //
        // Now if we did not get atleast one in, then we need to return
        // required size which is in remLen.
        //
        if (count == 0) {

            // the + sizeof(ULONG) is for cnt size

            RETURN_BUFFER_SIZE( remLen + sizeof(ULONG), Status );

            DfsDbgTrace(0, Dbg, "Output buffer too small\n", 0);

        } else if (Status == STATUS_BUFFER_OVERFLOW) {

            *retCnt = count;

            Irp->IoStatus.Information = OutputBufferLength;

            DfsDbgTrace(0, Dbg, "Could not fill in all RESOURCE structs \n", 0);

        } else {

            //
            // Dont know why we should get any other error code.
            //

            ASSERT(Status == STATUS_BUFFER_OVERFLOW);
        }
    } else {

        //
        // Everything went smoothly.
        //

        DfsDbgTrace(0, Dbg, "Succeeded in getting all Resources \n", 0);

        *retCnt = count;

        Irp->IoStatus.Information = OutputBufferLength;
    }

    if (providerNameAllocated == TRUE) {

        ExFreePool(providerName.Buffer);

    }

    ExReleaseResourceLite(&DfsData.Resource);

    DfsCompleteRequest( IrpContext, Irp, Status );

    DfsDbgTrace(-1,Dbg,"DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

    return Status;
}

	


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDefineRootCredentials
//
//  Synopsis:   Creates a new logical root, a new user credential record, or
//              both.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlDefineRootCredentials(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PFILE_DFS_DEF_ROOT_CREDENTIALS def;
    PDFS_CREDENTIALS creds = NULL;
    ULONG prefixIndex;
    UNICODE_STRING prefix;
    BOOLEAN deviceless = FALSE;
    LUID  LogonID;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    //
    // We must do this from the FSP because IoCreateDevice will fail if
    // PreviousMode != KernelMode
    //

    STD_FSCTRL_PROLOGUE(DfsFsctrlDefineRootCredentials, TRUE, FALSE, FALSE);

    //
    // Validate our parameters, best we can.
    //

    if (InputBufferLength < sizeof(FILE_DFS_DEF_ROOT_CREDENTIALS)) {

        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, status );
        DfsDbgTrace(-1,Dbg,"DfsFsctrlDefineRootCredentials: Exit->%08lx\n", ULongToPtr(status) );
        return status;

    }

    def = (PFILE_DFS_DEF_ROOT_CREDENTIALS) InputBuffer;

    prefixIndex = (def->DomainNameLen +
                        def->UserNameLen +
                            def->PasswordLen +
                                def->ServerNameLen +
                                    def->ShareNameLen) / sizeof(WCHAR);

    prefix.MaximumLength = prefix.Length = def->RootPrefixLen;
    prefix.Buffer = &def->Buffer[ prefixIndex ];

    if (
        !UNICODESTRING_IS_VALID(prefix, InputBuffer, InputBufferLength)
            ||
        (prefix.Length < (4 * sizeof(WCHAR)))
            ||
        (prefix.Buffer[0] != UNICODE_PATH_SEP)
        ) {

            status = STATUS_INVALID_PARAMETER;
            DfsCompleteRequest( IrpContext, Irp, status );
            DfsDbgTrace(-1,Dbg,"DfsFsctrlDefineRootCredentials: Exit->%08lx\n", ULongToPtr(status) );
            return status;

        }

    deviceless = (BOOLEAN) (def->LogicalRoot[0] == UNICODE_NULL);

#ifdef TERMSRV

    if (NT_SUCCESS(status)) {

        status = IoGetRequestorSessionId(Irp, &SessionID);

        if (!NT_SUCCESS(status) ) {
            status = STATUS_INVALID_PARAMETER;
        }
    }

#endif
    //
    // Now get the LogonID.
    //
    if (NT_SUCCESS(status)) {
	status = DfsGetLogonId(&LogonID);

    }

    //
    // First, create the credentials.
    //

    if (NT_SUCCESS(status)) {

#ifdef TERMSRV

        status = DfsCreateCredentials(def, 
				      InputBufferLength, 
				      SessionID, 
				      &LogonID,
				      &creds );


#else // TERMSRV

        status = DfsCreateCredentials(def, 
				      InputBufferLength, 
				      &LogonID,
				      &creds );


#endif // TERMSRV

        if (NT_SUCCESS(status)) {

            //
            // Verify the credentials if the username, domainname, or
            // password are not null
            //

            if ((def->DomainNameLen > 0) ||
                    (def->UserNameLen > 0) ||
                        (def->PasswordLen > 0)) {

                status = DfsVerifyCredentials( &prefix, creds );

            }

            if (NT_SUCCESS(status)) {

                PDFS_CREDENTIALS existingCreds;

                status = DfsInsertCredentials( &creds, deviceless );

                if (status == STATUS_OBJECT_NAME_COLLISION) {

                    status = STATUS_SUCCESS;

                }

            }

            if (!NT_SUCCESS(status))
                DfsFreeCredentials( creds );

        }
    }

    //
    // Next, try and create the logical root, if specified
    //

    if (NT_SUCCESS(status)) { 
        BOOLEAN pktLocked;

        PktAcquireExclusive( TRUE, &pktLocked );

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

	if (!deviceless) {
	    USHORT  VcbStateFlags = 0;

	    if (def->CSCAgentCreate) {
		VcbStateFlags |= VCB_STATE_CSCAGENT_VOLUME;
	    }

#ifdef TERMSRV

	    status = DfsInitializeLogicalRoot(
				(PWSTR) def->LogicalRoot,
				&prefix,
				creds,
				VcbStateFlags,
				SessionID,
				&LogonID );

#else // TERMSRV

	    status = DfsInitializeLogicalRoot(
				(PWSTR) def->LogicalRoot,
				&prefix,
				creds,
				VcbStateFlags,
				&LogonID );

#endif // TERMSRV
	}
	else {
#ifdef TERMSRV
	    status = DfsInitializeDevlessRoot(
				&prefix,
				creds,
				SessionID,
				&LogonID );
#else // TERMSRV
	    status = DfsInitializeDevlessRoot(
				&prefix,
				creds,
				&LogonID );
#endif // TERMSRV					     

	}

	if (status != STATUS_SUCCESS) {
	    DfsDeleteCredentials( creds );
        }

        ExReleaseResourceLite(&DfsData.Resource);

        PktRelease();

    }

    DfsCompleteRequest( IrpContext, Irp, status );
    DfsDbgTrace(-1,Dbg,"DfsFsctrlDefineRootCredentials: Exit->%08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetServerName
//
//  Synopsis:   Given a Prefix in Dfs namespace it gets a server name for
//              it.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsFsctrlGetServerName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG   InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDFS_PKT            pkt;
    PDFS_PKT_ENTRY      pEntry;
    UNICODE_STRING      ustrPrefix, RemainingPath;
    PWCHAR              pwch;
    PDFS_SERVICE        pService;
    ULONG               cbSizeRequired = 0;
    BOOLEAN             pktLocked;
    PWCHAR              wCp = (PWCHAR) InputBuffer;
    ULONG               i;

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetServerName, TRUE, TRUE, FALSE);

    if (InputBufferLength < 2 * sizeof(WCHAR)
            ||
        wCp[0] != UNICODE_PATH_SEP
    ) {

        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, status );
        return status;

    }

    ustrPrefix.Length = (USHORT) InputBufferLength;
    ustrPrefix.MaximumLength = (USHORT) InputBufferLength;
    ustrPrefix.Buffer = (PWCHAR) InputBuffer;

    if (ustrPrefix.Buffer[0] == UNICODE_PATH_SEP &&
            ustrPrefix.Buffer[1] == UNICODE_PATH_SEP) {
        ustrPrefix.Buffer++;
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    if (ustrPrefix.Buffer[ ustrPrefix.Length/sizeof(WCHAR) - 1]
            == UNICODE_NULL) {
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    pkt = _GetPkt();

    PktAcquireExclusive(TRUE, &pktLocked);

    pEntry = PktLookupEntryByPrefix(pkt,
                                    &ustrPrefix,
                                    &RemainingPath);

    if (pEntry == NULL) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        if (pEntry->ActiveService != NULL) {

            pService = pEntry->ActiveService;

        } else if (pEntry->Info.ServiceCount == 0) {

            pService = NULL;

        } else {

            pService = pEntry->Info.ServiceList;
        }

        if (pService != NULL) {

            cbSizeRequired = sizeof(UNICODE_PATH_SEP) +
                                pService->Address.Length +
                                    sizeof(UNICODE_PATH_SEP) +
                                        RemainingPath.Length +
                                            sizeof(UNICODE_NULL);

            if (OutputBufferLength < cbSizeRequired) {

                RETURN_BUFFER_SIZE(cbSizeRequired, status);

            } else {

                PWCHAR pwszPath, pwszAddr, pwszRemainingPath;
                ULONG cwAddr;

                //
                // The code below is simply constructing a string of the form
                // \<pService->Address>\RemainingPath. However, due to the
                // fact that InputBuffer and OutputBuffer actually point to
                // the same piece of memory, RemainingPath.Buffer points into
                // a spot in the *OUTPUT* buffer. Hence, we first have to
                // move the RemainingPath to its proper place in the
                // OutputBuffer, and then stuff in the pService->Address,
                // instead of the much more natural method of constructing the
                // string left to right.
                //

                pwszPath = (PWCHAR) OutputBuffer;

                pwszAddr = pService->Address.Buffer;

                cwAddr = pService->Address.Length / sizeof(WCHAR);

                if (cwAddr > 0 && pwszAddr[cwAddr-1] == UNICODE_PATH_SEP)
                    cwAddr--;

                pwszRemainingPath = &pwszPath[ 1 + cwAddr ];

                if (RemainingPath.Length > 0) {

                    if (RemainingPath.Buffer[0] != UNICODE_PATH_SEP) {

                        pwszRemainingPath++;

                    }

                    RtlMoveMemory(
                        pwszRemainingPath,
                        RemainingPath.Buffer,
                        RemainingPath.Length);

                    pwszRemainingPath[-1] = UNICODE_PATH_SEP;

                }

                pwszRemainingPath[RemainingPath.Length/sizeof(WCHAR)] = UNICODE_NULL;

                RtlCopyMemory(
                    &pwszPath[1],
                    pwszAddr,
                    cwAddr * sizeof(WCHAR));

                pwszPath[0] = UNICODE_PATH_SEP;

                Irp->IoStatus.Information = cbSizeRequired;
            }

        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    PktRelease();

    DfsCompleteRequest( IrpContext, Irp, status );

    DfsDbgTrace(-1,Dbg,"DfsFsctrlGetServerName: Exit->%08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetPktEntryState
//
//  Synopsis:   Given a Prefix in Dfs namespace it gets a list of servers
//              for it.  (DFS_INFO_X calls).
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_GET_PKT_ENTRY_STATE_ARG arg;
    PDFS_SERVICE pService;
    UNICODE_STRING DfsEntryPath;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING remPath;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;
    ULONG Level;
    PCHAR cp;
    PUCHAR InBuffer = NULL;


    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetPktEntryState\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetPktEntryState, TRUE, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_GET_PKT_ENTRY_STATE_ARG)) {

        DfsDbgTrace( 0, Dbg, "Input buffer too small\n", 0);

        NtStatus =  STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        DfsCompleteRequest( IrpContext, Irp, NtStatus );

        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetPktEntryState -> %08lx\n", ULongToPtr(NtStatus) );

        return( NtStatus );

    }

    //
    // Dup the buffer - we're going to construct UNICODE strings that point into
    // the buffer, and the buffer is also the output buffer, so we don't want to
    // overwrite those strings as we build the output buffer.
    //
    InBuffer = ExAllocatePoolWithTag(PagedPool, InputBufferLength, ' puM');

    if (InBuffer) {

        try {

            RtlCopyMemory(InBuffer, InputBuffer, InputBufferLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    } else {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Check args that don't need to be unmarshalled.
    //

    if (NT_SUCCESS(NtStatus)) {

        arg = (PDFS_GET_PKT_ENTRY_STATE_ARG) InBuffer;

        if (!(arg->Level >= 1 && arg->Level <= 4) ||

            (arg->ServerNameLen == 0 && arg->ShareNameLen != 0)) {

            NtStatus = STATUS_INVALID_PARAMETER;

        }

        //
        // All the path lengths have to add up. Eventhough these are signed values,
        // ie. SHORTs, they can't be negative.
        //
        if (arg->DfsEntryPathLen < 0 ||
           arg->ServerNameLen < 0 ||
           arg->ShareNameLen < 0 ||
           ((ULONG) (arg->DfsEntryPathLen + arg->ServerNameLen + arg->ShareNameLen) >
            InputBufferLength)) {

           NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Unmarshall the strings
    //

    if (NT_SUCCESS(NtStatus)) {

        try {

            Level = arg->Level;

            DfsEntryPath.Length = DfsEntryPath.MaximumLength = arg->DfsEntryPathLen;
            DfsEntryPath.Buffer = arg->Buffer;

            DfsDbgTrace( 0, Dbg, "\tDfsName=%wZ\n", &DfsEntryPath);

            RtlInitUnicodeString(&ServerName, NULL);
            RtlInitUnicodeString(&ShareName, NULL);

            if (arg->ServerNameLen) {

                cp = (PCHAR)arg->Buffer + arg->DfsEntryPathLen;
                ServerName.Buffer = (WCHAR *)cp;
                ServerName.Length = ServerName.MaximumLength = arg->ServerNameLen;
                cp += arg->ServerNameLen;

            }

            if (arg->ShareNameLen) {

                ShareName.Buffer = (WCHAR *)cp;
                ShareName.Length = ShareName.MaximumLength = arg->ShareNameLen;

                DfsDbgTrace( 0, Dbg, "\tServerName=%wZ\n", &ServerName);
                DfsDbgTrace( 0, Dbg, "\tShareName=%wZ\n", &ShareName);

            }

            DfsDbgTrace( 0, Dbg, "\tLevel=%d\n", ULongToPtr(arg->Level) );
            DfsDbgTrace( 0, Dbg, "\tOutputBufferLength=0x%x\n", ULongToPtr(OutputBufferLength) );

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Do a prefix lookup. If we find an entry, it's a Dfs path
        //

        pkt = _GetPkt();

        PktAcquireShared( TRUE, &pktLocked );

        pktEntry = PktLookupEntryByPrefix( pkt, &DfsEntryPath, &remPath );

        if (pktEntry != NULL) {

            DfsDbgTrace( 0, Dbg, "\tFound pkt entry %08lx\n", pktEntry);

            //
            // Calculate the needed output buffer size
            //
            NtStatus = DfsGetEntryStateSize(Level,
                                            &ServerName,
                                            &ShareName,
                                            pktEntry,
                                            &cbOutBuffer);
            //
            // Let user know if it's too small
            //

            if (OutputBufferLength < cbOutBuffer) {

                RETURN_BUFFER_SIZE(cbOutBuffer, NtStatus);

            }

        } else {

            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    if (NtStatus == STATUS_SUCCESS) {

        //
        // Args are ok, and it fits - marshall the data
        //

        NtStatus = DfsGetEntryStateMarshall(Level,
                                            &ServerName,
                                            &ShareName,
                                            pktEntry,
                                            OutputBuffer,
                                            cbOutBuffer);

        Irp->IoStatus.Information = cbOutBuffer;

    }

    //
    // Release any locks taken, and free any memory allocated.
    //

    if (pktLocked) {

        PktRelease();

    }

    if (InBuffer) {

        ExFreePool(InBuffer);

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlGetPktEntryState -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetEntryStateSize
//
//  Synopsis:   Helper routine for DfsFsctrlGetPktEntryState
//              Calculates output buffer size.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetEntryStateSize(
    ULONG Level,
    PUNICODE_STRING ServerName,
    PUNICODE_STRING ShareName,
    PDFS_PKT_ENTRY pktEntry,
    PULONG pcbOutBuffer)
{

    UNICODE_STRING Server;
    UNICODE_STRING Share;
    PDFS_SERVICE pService;
    ULONG Size;
    ULONG NumServices;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfsGetEntryStateSize\n", 0);

    //
    // Calculate the needed output buffer size
    //
    Size = pktEntry->Id.Prefix.Length +   // Len of EntryPath
              sizeof(WCHAR);              // ... with null

    switch (Level) {

    case 4:
        Size += sizeof(DFS_INFO_4);
        break;
    case 3:
        Size += sizeof(DFS_INFO_3);
        break;
    case 2:
        Size += sizeof(DFS_INFO_2);
        break;
    case 1:
        Size += sizeof(DFS_INFO_1);
        break;
    }

    //
    // For Level 3 & 4, add the size of any storages that
    // match the ServerName/ShareName passed in.
    //

    NumServices = pktEntry->Info.ServiceCount;

    if (Level == 3 || Level == 4) {

        for (i = 0; i < NumServices; i++) {

            UNICODE_STRING uStr;
            USHORT m, n;

            pService = &pktEntry->Info.ServiceList[i];

            DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

            //
            // We want to work with the \Server\Share part of the address only,
            // so count up to 3 backslashes, then stop.
            //
            uStr = pService->Address;
            for (m = n = 0; m < uStr.Length/sizeof(WCHAR) && n < 3; m++) {
                if (uStr.Buffer[m] == UNICODE_PATH_SEP) {
                    n++;
                }
            }

            uStr.Length = (n >= 3) ? (m-1) * sizeof(WCHAR) : m * sizeof(WCHAR);


            //
            // Tease apart the address (of form \Server\Share into Server and Share
            //
            RemoveLastComponent(&uStr, &Server);

            //
            // Remove leading & trailing '\'
            //
            Server.Length -= 2* sizeof(WCHAR);
            Server.MaximumLength -= 2* sizeof(WCHAR);
            Server.Buffer++;

            //
            // And figure out Share
            //
            Share.Buffer = Server.Buffer + (Server.Length / sizeof(WCHAR)) + 1;
            Share.Length = pService->Address.Length - (Server.Length + 2 * sizeof(WCHAR));
            Share.MaximumLength = Share.Length;

  
            DfsDbgTrace( 0, Dbg, "DfsGetEntryStateSize: Server=%wZ\n", &Server);
            DfsDbgTrace( 0, Dbg, "                      Share=%wZ\n", &Share);

            if ((ServerName->Length && RtlCompareUnicodeString(ServerName, &Server, TRUE))

                        ||

                (ShareName->Length && RtlCompareUnicodeString(ShareName, &Share, TRUE))) {

                continue;

            }

            Size += sizeof(DFS_STORAGE_INFO) +
                      pService->Address.Length +
                         sizeof(WCHAR);

        }

    }

    DfsDbgTrace( 0, Dbg, "Size=0x%x\n", ULongToPtr(Size) );

    *pcbOutBuffer = Size;

    DfsDbgTrace(-1, Dbg, "DfsGetEntryStateSize -> %08lx\n", STATUS_SUCCESS );

    return (STATUS_SUCCESS);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetEntryStateMarshall
//
//  Synopsis:   Helper routine for DfsFsctrlGetPktEntryState
//              Marshalls the output buffer
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetEntryStateMarshall(
    ULONG Level,
    PUNICODE_STRING ServerName,
    PUNICODE_STRING ShareName,
    PDFS_PKT_ENTRY pktEntry,
    PBYTE OutputBuffer,
    ULONG cbOutBuffer)
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG iStr;
    ULONG i;
    PDFS_INFO_4 pDfsInfo4;
    PDFS_INFO_3 pDfsInfo3;
    PDFS_STORAGE_INFO pDfsStorageInfo;
    PDFS_SERVICE pService;
    ULONG NumStorageInfo;
    UNICODE_STRING Server;
    UNICODE_STRING Share;

    DfsDbgTrace(+1, Dbg, "DfsGetEntryStateMarshall\n", 0);

    try {

        RtlZeroMemory(OutputBuffer, cbOutBuffer);

        pDfsInfo4 = (PDFS_INFO_4) OutputBuffer;
        pDfsInfo3 = (PDFS_INFO_3) OutputBuffer;

        //
        // iStr will be used to place unicode strings into the buffer
        // starting at the end, working backwards
        //

        iStr = cbOutBuffer;

        //
        // LPWSTR's are stored as offsets into the buffer - the NetDfsXXX calls
        // fix them up.
        //
        iStr -= pktEntry->Id.Prefix.Length + sizeof(WCHAR);
        RtlCopyMemory(&OutputBuffer[iStr],
                      pktEntry->Id.Prefix.Buffer,
                      pktEntry->Id.Prefix.Length);

        //
        // This could could be much more clever, as the DFS_INFO_X structs
        // are similar, but I've gone for clarity over cleverness. (jharper)
        //

        switch (Level) {

        case 4:
            pDfsInfo4->EntryPath = (WCHAR*) ULongToPtr(iStr);
            pDfsInfo4->Comment = NULL;
            pDfsInfo4->State = DFS_VOLUME_STATE_OK;
            pDfsInfo4->Timeout = pktEntry->TimeToLive;
            pDfsInfo4->Guid = pktEntry->Id.Uid;
            pDfsInfo4->NumberOfStorages = pktEntry->Info.ServiceCount;
            pDfsStorageInfo = (PDFS_STORAGE_INFO)(pDfsInfo4 + 1);
            pDfsInfo4->Storage = (PDFS_STORAGE_INFO)((PCHAR)pDfsStorageInfo - OutputBuffer);
            break;
        case 3:
            pDfsInfo3->EntryPath = (WCHAR*) ULongToPtr(iStr);
            pDfsInfo3->Comment = NULL;
            pDfsInfo3->State = DFS_VOLUME_STATE_OK;
            pDfsInfo3->NumberOfStorages = pktEntry->Info.ServiceCount;
            pDfsStorageInfo = (PDFS_STORAGE_INFO)(pDfsInfo3 + 1);
            pDfsInfo3->Storage = (PDFS_STORAGE_INFO)((PCHAR)pDfsStorageInfo - OutputBuffer);
            break;
        case 2:
            pDfsInfo3->EntryPath = (WCHAR*) ULongToPtr(iStr);
            pDfsInfo3->Comment = NULL;
            pDfsInfo3->State = DFS_VOLUME_STATE_OK;
            pDfsInfo3->NumberOfStorages = pktEntry->Info.ServiceCount;
            break;
        case 1:
            pDfsInfo3->EntryPath = (WCHAR*) ULongToPtr(iStr);
            break;

        }

        //
        // For Level 3 & 4 we now walk the services and load State,
        // ServerName and ShareName.  With the complication that if the user
        // specified ServerName and/or ShareName, we must match on those, too.
        //

        if (Level == 3 || Level == 4) {

            NumStorageInfo = 0;

            for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

                LPWSTR wp;
                UNICODE_STRING uStr;
                USHORT m, n;

                pService = &pktEntry->Info.ServiceList[i];

                DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

                //
                // We want to work with the \Server\Share part of the address only,
                // so count up to 3 backslashes, then stop.
                //
                uStr = pService->Address;
                for (m = n = 0; m < uStr.Length/sizeof(WCHAR) && n < 3; m++) {
                    if (uStr.Buffer[m] == UNICODE_PATH_SEP) {
                        n++;
                    }
                }

                uStr.Length = (n >= 3) ? (m-1) * sizeof(WCHAR) : m * sizeof(WCHAR);

                //
                // Tease apart the address (of form \Server\Share) into Server
                // (Handles a dfs-link like \server\share\dir1\dir2)
                //
                RemoveLastComponent(&uStr, &Server);

                //
                // Remove leading & trailing '\'s
                //
                Server.Length -= 2* sizeof(WCHAR);
                Server.MaximumLength = Server.Length;
                Server.Buffer++;

                //
                // And figure out Share (which will be everything after the server)
                //
                Share.Buffer = Server.Buffer + (Server.Length / sizeof(WCHAR)) + 1;
                Share.Length = pService->Address.Length - (Server.Length + 2 * sizeof(WCHAR));
                Share.MaximumLength = Share.Length;

                DfsDbgTrace( 0, Dbg, "DfsGetEntryStateSize: Server=%wZ\n", &Server);
                DfsDbgTrace( 0, Dbg, "                      Share=%wZ\n", &Share);

                //
                // If ServerName or ShareName are specified, then they must match
                //
                if (
                    (ServerName->Length && RtlCompareUnicodeString(ServerName, &Server, TRUE))

                            ||

                    (ShareName->Length && RtlCompareUnicodeString(ShareName, &Share, TRUE))
                ) {

                    continue;

                }

                //
                // Online or Offline?
                //
                if (pService->Type & DFS_SERVICE_TYPE_OFFLINE) {

                    pDfsStorageInfo->State = DFS_STORAGE_STATE_OFFLINE;

                } else {

                    pDfsStorageInfo->State = DFS_STORAGE_STATE_ONLINE;

                }

                //
                // Active?
                //
                if (pService == pktEntry->ActiveService) {

                    pDfsStorageInfo->State |= DFS_STORAGE_STATE_ACTIVE;

                }

                //
                // Sever name
                //
                iStr -= Server.Length + sizeof(WCHAR);

                RtlCopyMemory(&OutputBuffer[iStr],
                              Server.Buffer,
                              Server.Length);

                pDfsStorageInfo->ServerName = (WCHAR*) ULongToPtr(iStr);

                //
                // Share name
                //
                iStr -= Share.Length + sizeof(WCHAR);

                RtlCopyMemory(&OutputBuffer[iStr],
                              Share.Buffer,
                              Share.Length);

                pDfsStorageInfo->ShareName = (WCHAR*) ULongToPtr(iStr);

                pDfsStorageInfo++;

                NumStorageInfo++;

            }

            //
            // Finally, adjust the # entries we loaded into the buffer
            //
            switch (Level) {

            case 4:
                pDfsInfo4->NumberOfStorages = NumStorageInfo;
                break;
            case 3:
                pDfsInfo3->NumberOfStorages = NumStorageInfo;
                break;

            }

        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        NtStatus = STATUS_SUCCESS;  // Per Arg Validation Spec

    }

    DfsDbgTrace(-1, Dbg, "DfsGetEntryStateMarshall -> %08lx\n", ULongToPtr(NtStatus) );

    return (NtStatus);

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetPktEntryState
//
//  Synopsis:   Given a Prefix in Dfs namespace it sets the Timeout or the State
//              of an alternate. (DFS_INFO_X calls).
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_SET_PKT_ENTRY_STATE_ARG arg;
    PDFS_SERVICE pService;
    UNICODE_STRING DfsEntryPath;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING remPath;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;
    ULONG Level;
    ULONG State;
    ULONG Timeout;
    PCHAR cp;


    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetPktEntryState\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetPktEntryState, TRUE, FALSE, FALSE);

    if (InputBufferLength < sizeof(DFS_SET_PKT_ENTRY_STATE_ARG)) {

        DfsDbgTrace( 0, Dbg, "Input buffer too small\n", 0);

        NtStatus =  STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        DfsCompleteRequest( IrpContext, Irp, NtStatus );

        DfsDbgTrace(-1, Dbg, "DfsFsctrlSetPktEntryState exit 0x%x\n", ULongToPtr(NtStatus) );

        return( NtStatus );

    }

    //
    // Check args that don't need to be unmarshalled.
    //

    if (NT_SUCCESS(NtStatus)) {

        arg = (PDFS_SET_PKT_ENTRY_STATE_ARG) InputBuffer;

        Level = arg->Level;

        //
        // Check for valid Level
        //
        // Level 101 requires that both be present
        // Level 102 ignores ServerName and ShareName
        //
        switch (Level) {

        case 101:
            State = arg->State;
            if (State != DFS_STORAGE_STATE_ACTIVE ||
                    arg->ServerNameLen == 0 ||
                        arg->ShareNameLen == 0) {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        case 102:
            Timeout = arg->Timeout;
            break;

        default:
            NtStatus = STATUS_INVALID_PARAMETER;

        }

    }

    //
    // Unmarshall the strings
    //
    if (NT_SUCCESS(NtStatus)) {

        try {

            DfsEntryPath.Length = DfsEntryPath.MaximumLength = arg->DfsEntryPathLen;
            DfsEntryPath.Buffer = arg->Buffer;

            DfsDbgTrace( 0, Dbg, "\tDfsName=%wZ\n", &DfsEntryPath);

            RtlInitUnicodeString(&ServerName, NULL);
            RtlInitUnicodeString(&ShareName, NULL);

            if (arg->ServerNameLen) {

                cp = (PCHAR)arg->Buffer + arg->DfsEntryPathLen;
                ServerName.Buffer = (WCHAR *)cp;
                ServerName.Length = ServerName.MaximumLength = arg->ServerNameLen;

                DfsDbgTrace( 0, Dbg, "\tServerName=%wZ\n", &ServerName);

            }

            if (arg->ShareNameLen) {

                cp = (PCHAR)arg->Buffer + arg->DfsEntryPathLen + arg->ServerNameLen;
                ShareName.Buffer = (WCHAR *)cp;
                ShareName.Length = ShareName.MaximumLength = arg->ShareNameLen;

                DfsDbgTrace( 0, Dbg, "\tShareName=%wZ\n", &ShareName);

            }

            DfsDbgTrace( 0, Dbg, "\tLevel=%d\n", ULongToPtr(arg->Level) );

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    }

    //
    // Do a prefix lookup. If we find an entry, it's a Dfs path
    //
    if (NT_SUCCESS(NtStatus)) {

        pkt = _GetPkt();

        PktAcquireExclusive( TRUE, &pktLocked );

        pktEntry = PktLookupEntryByPrefix( pkt, &DfsEntryPath, &remPath );

        if (pktEntry != NULL) {

            DfsDbgTrace( 0, Dbg, "\tFound pkt entry %08lx\n", pktEntry);

        } else {

            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Args are ok - do the work
        //
        switch (Level) {

        case 101:
            NtStatus = DfsSetPktEntryActive(
                                        &ServerName,
                                        &ShareName,
                                        pktEntry,
                                        State);
            break;
        case 102:
            NtStatus = DfsSetPktEntryTimeout(pktEntry,
                                             Timeout);
            break;

        }

        Irp->IoStatus.Information = 0;

    }

    //
    // Release any locks taken, and free any memory allocated.
    //
    if (pktLocked) {

        PktRelease();

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlSetPktEntryState exit 0x%x\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}
//+-------------------------------------------------------------------------
//
//  Function:   RemoveFirstComponent, public
//
//  Synopsis:   Removes the first component of the string passed.
//
//  Arguments:  [Prefix] -- The prefix whose first component is to be returned.
//              [newPrefix] -- The first component.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      On return, the newPrefix points to the same memory buffer
//              as Prefix.
//
//--------------------------------------------------------------------------

void
RemoveFirstComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix
)
{
    PWCHAR      pwch;
    USHORT      i=sizeof(WCHAR);

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch ++; //skip the first slash

    while ((*pwch != UNICODE_PATH_SEP) && ((pwch - newPrefix->Buffer) != Prefix->Length))  {
        i += sizeof(WCHAR);
        pwch++;
    }

    newPrefix->Length = i + sizeof(WCHAR);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetPktEntryActive
//
//  Synopsis:   Helper for DfsFsctrlSetPktEntryState
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsSetPktEntryActive(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING ShareName,
    PDFS_PKT_ENTRY pktEntry,
    DWORD State)
{
    UNICODE_STRING Server;
    UNICODE_STRING Share;
    PDFS_SERVICE pService;
    NTSTATUS NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfsSetPktEntryActive\n", 0);

    for (i = 0; i < pktEntry->Info.ServiceCount && NtStatus != STATUS_SUCCESS; i++) {

        LPWSTR wp;

        pService = &pktEntry->Info.ServiceList[i];

        DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

        //
        // Tease apart the address (of form \Server\Share) into Server and Share
        //
        RemoveFirstComponent(&pService->Address, &Server);

        //
        // Remove leading & trailing '\'s
        //
        Server.Length -= 2* sizeof(WCHAR);
        Server.MaximumLength = Server.Length;
        Server.Buffer++;

        //
        // And figure out Share
        //
        Share.Buffer = Server.Buffer + (Server.Length / sizeof(WCHAR)) + 1;
        Share.Length = pService->Address.Length - (Server.Length + 2 * sizeof(WCHAR));
        Share.MaximumLength = Share.Length;

        //
        // If ServerName or ShareName don't match, then move on to the next service
        //
        if (
            RtlCompareUnicodeString(ServerName, &Server, TRUE)

                    ||

            RtlCompareUnicodeString(ShareName, &Share, TRUE)
        ) {

            continue;

        }

        DfsDbgTrace( 0, Dbg, "DfsSetPktEntryActive: Server=%wZ\n", &Server);
        DfsDbgTrace( 0, Dbg, "                      Share=%wZ\n", &Share);

        //
        // Make this the active share
        //

        pktEntry->ActiveService = pService;

        NtStatus = STATUS_SUCCESS;

    }

    DfsDbgTrace(-1, Dbg, "DfsSetPktEntryActive -> %08lx\n", ULongToPtr(NtStatus) );

    return NtStatus;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetPktEntryTimeout
//
//  Synopsis:   Helper for DfsFsctrlSetPktEntryState
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsSetPktEntryTimeout(
    PDFS_PKT_ENTRY pktEntry,
    ULONG Timeout)
{
    DfsDbgTrace(+1, Dbg, "DfsSetPktEntryTimeout\n", 0);

    pktEntry->ExpireTime = pktEntry->TimeToLive = Timeout;

    DfsDbgTrace(-1, Dbg, "DfsSetPktEntryTimeout -> %08lx\n", STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetPkt
//
//  Synopsis:   Returns the current (cached Pkt)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetPkt(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_PKT pkt;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;


    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetPktEntryState\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetPkt, FALSE, TRUE, FALSE);

    pkt = _GetPkt();

    PktAcquireShared( TRUE, &pktLocked );

    //
    // Calculate the needed output buffer size
    //
    NtStatus = DfsGetPktSize(&cbOutBuffer);

    //
    // Let user know if it's too small
    //
    if (OutputBufferLength < cbOutBuffer) {

        RETURN_BUFFER_SIZE(cbOutBuffer, NtStatus);

    }

    if (NtStatus == STATUS_SUCCESS) {

        //
        // Args are ok, and it fits - marshall the data
        //
        NtStatus = DfsGetPktMarshall(OutputBuffer, cbOutBuffer);

        Irp->IoStatus.Information = cbOutBuffer;

    }

    //
    // Release any locks taken, and free any memory allocated.
    //
    if (pktLocked) {

        PktRelease();

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlGetPkt -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetPktSize, private
//
//  Synopsis:   Calculates the size needed to return the Pkt.  Helper for
//              DfsFsctrlGetPkt().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetPktSize(
    PULONG pSize)
{
    ULONG EntryCount = 0;
    ULONG i;
    ULONG Size = 0;
    PDFS_PKT_ENTRY pPktEntry;
    PDFS_PKT pkt = _GetPkt();

    //
    // Walk the linked list of Pkt entries
    //

    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        //
        // Space for the Prefix and ShortPrefix, including a UNICODE_NULL
        //
        Size += pPktEntry->Id.Prefix.Length + sizeof(WCHAR);
        Size += pPktEntry->Id.ShortPrefix.Length + sizeof(WCHAR);

        //
        // Space for an array of pointers to DFS_PKT_ADDRESS_OBJECTS
        //
        Size += sizeof(PDFS_PKT_ADDRESS_OBJECT) * pPktEntry->Info.ServiceCount;

        //
        // Space for the ServerShare address, plus a UNICODE_NULL, plus the state
        //
        for (i = 0; i < pPktEntry->Info.ServiceCount; i++) {

            Size += sizeof(USHORT) + pPktEntry->Info.ServiceList[i].Address.Length + sizeof(WCHAR);

        }

        EntryCount++;

    }

    //
    // Space for the DFS_PKT_ARG, which will have EntryCount objects on the end
    //
    Size += FIELD_OFFSET(DFS_GET_PKT_ARG, EntryObject[EntryCount]);

    //
    // Make sure the size is a multiple of the size of a PDFS_PKT_ADDRESS_OBJECT, as that is what
    // will be at the end of the buffer
    //

    while ((Size & (sizeof(PDFS_PKT_ADDRESS_OBJECT)-1)) != 0) {
        Size++;
    }

    *pSize = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetPktMarshall, private
//
//  Synopsis:   Marshalls the Pkt.  Helper for DfsFsctrlGetPkt().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetPktMarshall(
    PBYTE Buffer,
    ULONG Size)
{
    ULONG EntryCount = 0;
    ULONG i;
    ULONG j;
    ULONG Type;
    PCHAR pCh;
    PDFS_PKT_ENTRY pPktEntry;
    PDFS_GET_PKT_ARG pPktArg;
    PDFS_PKT pkt = _GetPkt();

    //
    // This will be a two-pass operation, the first pass will calculate how
    // much room for the LPWSTR arrays at the end of the buffer, then the
    // second pass will put the strings into place, too.
    //

    RtlZeroMemory(Buffer,Size);

    //
    // Point to the end of the buffer
    //
    pCh = (PCHAR)(Buffer + Size);

    pPktArg = (PDFS_GET_PKT_ARG)Buffer;

    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        //
        // Space for an array of pointers to DFS_PKT_ADDRESS_OBJECTS
        //
        pCh -= sizeof(PDFS_PKT_ADDRESS_OBJECT) * pPktEntry->Info.ServiceCount;
        pPktArg->EntryObject[EntryCount].Address = (PDFS_PKT_ADDRESS_OBJECT *)pCh;

        EntryCount++;

    }

    //
    // Now marshall
    //

    EntryCount = 0;
    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        pCh -= pPktEntry->Id.Prefix.Length + sizeof(WCHAR);
        pPktArg->EntryObject[EntryCount].Prefix = (LPWSTR)pCh;
        RtlCopyMemory(
            pPktArg->EntryObject[EntryCount].Prefix,
            pPktEntry->Id.Prefix.Buffer,
            pPktEntry->Id.Prefix.Length);

        pCh -= pPktEntry->Id.ShortPrefix.Length + sizeof(WCHAR);
        pPktArg->EntryObject[EntryCount].ShortPrefix = (LPWSTR)pCh;
        RtlCopyMemory(
            pPktArg->EntryObject[EntryCount].ShortPrefix,
            pPktEntry->Id.ShortPrefix.Buffer,
            pPktEntry->Id.ShortPrefix.Length);

        pPktArg->EntryObject[EntryCount].Type = pPktEntry->Type;
        pPktArg->EntryObject[EntryCount].USN = pPktEntry->USN;
        pPktArg->EntryObject[EntryCount].ExpireTime = pPktEntry->ExpireTime;
        pPktArg->EntryObject[EntryCount].UseCount = pPktEntry->UseCount;
        pPktArg->EntryObject[EntryCount].Uid = pPktEntry->Id.Uid;
        pPktArg->EntryObject[EntryCount].ServiceCount = pPktEntry->Info.ServiceCount;

        for (i = 0; i < pPktEntry->Info.ServiceCount; i++) {

            Type = pPktEntry->Info.ServiceList[i].Type;
            pCh -= sizeof(USHORT) + pPktEntry->Info.ServiceList[i].Address.Length + sizeof(WCHAR);
            pPktArg->EntryObject[EntryCount].Address[i] = (PDFS_PKT_ADDRESS_OBJECT)pCh;
            pPktArg->EntryObject[EntryCount].Address[i]->State = (USHORT)Type;
            if (pPktEntry->ActiveService == &pPktEntry->Info.ServiceList[i]) {
                pPktArg->EntryObject[EntryCount].Address[i]->State |= DFS_SERVICE_TYPE_ACTIVE;
            }

            RtlCopyMemory(
                &pPktArg->EntryObject[EntryCount].Address[i]->ServerShare[0],
                pPktEntry->Info.ServiceList[i].Address.Buffer,
                pPktEntry->Info.ServiceList[i].Address.Length);

        }

        EntryCount++;

    }

    pPktArg->EntryCount = EntryCount;

    //
    // Convert all the pointers to relative offsets
    //

    for (i = 0; i < pPktArg->EntryCount; i++) {

        for (j = 0; j < pPktArg->EntryObject[i].ServiceCount; j++) {

            POINTER_TO_OFFSET(pPktArg->EntryObject[i].Address[j], Buffer);

        }

        POINTER_TO_OFFSET(pPktArg->EntryObject[i].Prefix, Buffer);
        POINTER_TO_OFFSET(pPktArg->EntryObject[i].ShortPrefix, Buffer);
        POINTER_TO_OFFSET(pPktArg->EntryObject[i].Address, Buffer);

    }

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetSpcTable
//
//  Synopsis:   Given a NULL string, it returns a list of all the domains
//              Given a non-NULL string, it returns a list of DC's in that domain
//              (if the name is a domain name).  Similar to a special referral request.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetSpcTable(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR SpcName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetSpcTable\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetSpcTable, TRUE, TRUE, FALSE);

    SpcName = (WCHAR *)InputBuffer;

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && SpcName[i]; i++)
        NOTHING;

    if (i >= InputBufferLength/sizeof(WCHAR)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, NtStatus );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetSpcTable -> %08lx\n", ULongToPtr(NtStatus) );
        return NtStatus;
    }

    DfsDbgTrace(0, Dbg, "SpcName=[%ws]\n", SpcName);

    if (wcslen(SpcName) == 0) {

        //
        // return all the domain names
        //

        NtStatus = DfsGetSpcTableNames(
                        Irp,
                        OutputBuffer,
                        OutputBufferLength);

    } else if (wcslen(SpcName) == 1 && *SpcName == L'*') {

        //
        // Return DC Info
        //

        NtStatus = DfsGetSpcDcInfo(
                        Irp,
                        OutputBuffer,
                        OutputBufferLength);

    } else {

        //
        // Expand the one name
        //

        NtStatus = DfsExpSpcTableName(
                        SpcName,
                        Irp,
                        OutputBuffer,
                        OutputBufferLength);

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlGetSpcTable -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetspcTableNames, private
//
//  Synopsis:   Marshalls the spc table (Names).  Helper for DfsFsctrlGetSpcTable().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetSpcTableNames(
    PIRP Irp,
    PUCHAR  OutputBuffer,
    ULONG OutputBufferLength)
{
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PDFS_PKT Pkt;
    WCHAR *wCp;
    ULONG Size;
    ULONG i;
    BOOLEAN pktLocked;
    NTSTATUS Status;

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    Pkt = _GetPkt();

    pSpecialTable = &Pkt->SpecialTable;

    PktAcquireShared(TRUE, &pktLocked);

    Size = sizeof(UNICODE_NULL);

    pSpecialEntry = CONTAINING_RECORD(
                        pSpecialTable->SpecialEntryList.Flink,
                        DFS_SPECIAL_ENTRY,
                        Link);

    for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

        Size += pSpecialEntry->SpecialName.Length +
                    sizeof(UNICODE_NULL) +
                        sizeof(WCHAR);

        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialEntry->Link.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);
    }

    if (Size > OutputBufferLength) {

        RETURN_BUFFER_SIZE(Size, Status)

        PktRelease();

        return Status;

    }

    wCp = (WCHAR *)OutputBuffer;
    pSpecialEntry = CONTAINING_RECORD(
                        pSpecialTable->SpecialEntryList.Flink,
                        DFS_SPECIAL_ENTRY,
                        Link);

    for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

        *wCp++ = pSpecialEntry->NeedsExpansion == TRUE ? L'-' : '+';
        RtlCopyMemory(
            wCp,
            pSpecialEntry->SpecialName.Buffer,
            pSpecialEntry->SpecialName.Length);
        wCp += pSpecialEntry->SpecialName.Length/sizeof(WCHAR);
        *wCp++ = UNICODE_NULL;

        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialEntry->Link.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);
    }

    *wCp++ = UNICODE_NULL;

    PktRelease();

    Irp->IoStatus.Information = Size;

    return STATUS_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetSpcDcInfo, private
//
//  Synopsis:   Marshalls DC Info w.r.t. the special name table
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetSpcDcInfo(
    PIRP Irp,
    PUCHAR  OutputBuffer,
    ULONG OutputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN pktLocked;
    PDFS_PKT Pkt;
    WCHAR *wCp;
    ULONG Size;

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    Size = sizeof(UNICODE_NULL);

    Size += Pkt->DCName.Length +
                sizeof(UNICODE_NULL) +
                    sizeof(WCHAR);

    Size += Pkt->DomainNameFlat.Length +
                sizeof(UNICODE_NULL) +
                    sizeof(WCHAR);

    Size += Pkt->DomainNameDns.Length +
                sizeof(UNICODE_NULL) +
                    sizeof(WCHAR);

    if (Size > OutputBufferLength) {

        RETURN_BUFFER_SIZE(Size, Status)
        PktRelease();

        return Status;

    }

    wCp = (WCHAR *)OutputBuffer;

    *wCp++ = L'*';
    RtlCopyMemory(
                wCp,
                Pkt->DCName.Buffer,
                Pkt->DCName.Length);
    wCp += Pkt->DCName.Length/sizeof(WCHAR);
    *wCp++ = UNICODE_NULL;

    *wCp++ = L'*';
    RtlCopyMemory(
                wCp,
                Pkt->DomainNameFlat.Buffer,
                Pkt->DomainNameFlat.Length);
    wCp += Pkt->DomainNameFlat.Length/sizeof(WCHAR);
    *wCp++ = UNICODE_NULL;

    *wCp++ = L'*';
    RtlCopyMemory(
                wCp,
                Pkt->DomainNameDns.Buffer,
                Pkt->DomainNameDns.Length);
    wCp += Pkt->DomainNameDns.Length/sizeof(WCHAR);
    *wCp++ = UNICODE_NULL;

    *wCp++ = UNICODE_NULL;

    PktRelease();

    Irp->IoStatus.Information = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsExpSpcTableName, private
//
//  Synopsis:   Marshalls the spc table (1 expansion).  Helper for DfsFsctrlGetSpcTable().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsExpSpcTableName(
    LPWSTR SpcName,
    PIRP Irp,
    PUCHAR  OutputBuffer,
    ULONG OutputBufferLength)
{
    PDFS_SPECIAL_ENTRY pSpcEntry = NULL;
    UNICODE_STRING Name;
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR *wCp;
    ULONG Size;
    ULONG i;

    RtlInitUnicodeString(&Name, SpcName);

    Status = PktExpandSpecialName(&Name, &pSpcEntry);

    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    Size = sizeof(UNICODE_NULL);

    for (i = 0; i < pSpcEntry->ExpandedCount; i++) {

        Size += pSpcEntry->ExpandedNames[i].ExpandedName.Length +
                    sizeof(UNICODE_NULL) +
                        sizeof(WCHAR);

    }

    if (Size > OutputBufferLength) {

        RETURN_BUFFER_SIZE(Size, Status)

        InterlockedDecrement(&pSpcEntry->UseCount);

        return Status;

    }

    wCp = (WCHAR *)OutputBuffer;

    for (i = 0; i < pSpcEntry->ExpandedCount; i++) {

        *wCp++ = i == pSpcEntry->Active ? L'+' : L'-';
        RtlCopyMemory(
                    wCp,
                    pSpcEntry->ExpandedNames[i].ExpandedName.Buffer,
                    pSpcEntry->ExpandedNames[i].ExpandedName.Length);
        wCp += pSpcEntry->ExpandedNames[i].ExpandedName.Length/sizeof(WCHAR);
        *wCp++ = UNICODE_NULL;

    }

    *wCp++ = UNICODE_NULL;

    InterlockedDecrement(&pSpcEntry->UseCount);

    Irp->IoStatus.Information = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSpcSetDc
//
//  Synopsis:   Given a special name and a dc name, it makes the DC in that special
//              list the 'active' DC.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSpcSetDc(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_SPECIAL_SET_DC_INPUT_ARG arg = (PDFS_SPECIAL_SET_DC_INPUT_ARG) InputBuffer;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSpcSetDc\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlSpcSetDc, TRUE, FALSE, FALSE);

    //
    // Check the input args
    //

    if (InputBufferLength < sizeof(DFS_SPECIAL_SET_DC_INPUT_ARG)) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER(arg->SpecialName.Buffer, arg);
    if (!UNICODESTRING_IS_VALID(arg->SpecialName, InputBuffer, InputBufferLength)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER(arg->DcName.Buffer, arg);
    if (!UNICODESTRING_IS_VALID(arg->DcName, InputBuffer, InputBufferLength)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    NtStatus = PktpSetActiveSpcService(
                    &arg->SpecialName,
                    &arg->DcName,
                    TRUE);

exit_with_status:

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlSpcSetDc -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}


#if DBG


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlReadMem, local
//
//  Synopsis:   DfsFsctrlReadMem is a debugging function which will return
//              the contents of a chunk of kernel space memory
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//              [Request] -- Pointer to a FILE_DFS_READ_MEM struct,
//                      giving the description of the data to be returned.
//              [InputBufferLength] -- Size of InputBuffer
//              [OutputBuffer] -- User's output buffer, in which the
//                      data structure will be returned.
//              [OutputBufferLength] -- Size of OutputBuffer
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      Available in DBG builds only.
//
//--------------------------------------------------------------------------


NTSTATUS
DfsFsctrlReadMem (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_READ_MEM Request,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
) {
    NTSTATUS Status;
    PUCHAR ReadBuffer;
    ULONG ReadLength;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlReadMem...\n", 0);

    if (InputBufferLength != sizeof (FILE_DFS_READ_MEM)) {
        DfsDbgTrace(0, Dbg, "Input buffer is wrong size\n", 0);

        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    ReadBuffer = (PUCHAR) Request->Address;
    ReadLength = (ULONG) Request->Length;

    //
    // Special case ReadBuffer == 0 and ReadLength == 0 - means return the
    // address of DfsData
    //

    if (ReadLength == 0 && ReadBuffer == 0) {

        if (OutputBufferLength < sizeof(ULONG_PTR)) {
            DfsDbgTrace(0, Dbg, "Output buffer is too small\n", 0);

            DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            Status = STATUS_INVALID_PARAMETER;

            DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );
            return Status;

        } else {

            *(PULONG_PTR) OutputBuffer = (ULONG_PTR) &DfsData;

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            DfsCompleteRequest( IrpContext, Irp, Status );
            return Status;
        }

    }

    //
    // Normal case, read data from the address specified in input buffer
    //

    if (ReadLength > OutputBufferLength) {
        DfsDbgTrace(0, Dbg, "Output buffer is smaller than requested size\n", 0);

        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    try {

        RtlMoveMemory( OutputBuffer, ReadBuffer, ReadLength );

        Irp->IoStatus.Information = ReadLength;
        Irp->IoStatus.Status = Status = STATUS_SUCCESS;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = STATUS_INVALID_USER_BUFFER;
    }

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

void
DfsDumpBuf(PCHAR cp, ULONG len)
{
    ULONG i, j, c;

    for (i = 0; i < len; i += 16) {
        DbgPrint("%08x  ", i);
        for (j = 0; j < 16; j++) {
            c = i+j < len ? cp[i+j] & 0xff : ' ';
            DbgPrint("%02x ", c);
            if (j == 7)
                DbgPrint(" ");
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            c = i+j < len ? cp[i+j] & 0xff : ' ';
            if (c < ' ' || c > '~')
                c = '.';
            DbgPrint("%c", c);
            if (j == 7)
                DbgPrint("|");
        }
        DbgPrint("\n");
    }
}


#endif // DBG


//+----------------------------------------------------------------------------
//
//  Function:   DfsCaptureCredentials
//
//  Synopsis:   Captures the credentials to use... similar to DnrCaptureCred..
//
//  Arguments:  Irp and Filename.
//
//  Returns:    Credentials
//
//-----------------------------------------------------------------------------

PDFS_CREDENTIALS
DfsCaptureCredentials(
    IN PIRP Irp,
    IN PUNICODE_STRING FileName)
{
#ifdef TERMSRV
    NTSTATUS Status;
    ULONG SessionID;
#endif // TERMSRV
    LUID LogonID;
    PDFS_CREDENTIALS creds;

    DfsDbgTrace(+1, Dbg, "DfsCaptureCredentials: Enter [%wZ] \n", FileName);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );
    DfsGetLogonId( &LogonID );

#ifdef TERMSRV

    Status = IoGetRequestorSessionId( Irp, & SessionID );
    if( NT_SUCCESS( Status ) ) {
        creds = DfsLookupCredentials( FileName, SessionID, &LogonID  );
    }
    else {
        creds = NULL;
    }

#else // TERMSRV

    creds = DfsLookupCredentials( FileName, &LogonID );

#endif // TERMSRV

    if (creds !=  NULL)
	creds->RefCount++;

    ExReleaseResourceLite( &DfsData.Resource );
    DfsDbgTrace(-1, Dbg, "DfsCaptureCredentials: Exit. Creds %x\n", creds);

    return creds;
}



//+----------------------------------------------------------------------------
//
//  Function:   DfsReleaseCredentials
//
//  Synopsis:   Releases the credentials supplied.
//
//  Arguments:  Credentials
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsReleaseCredentials(
    IN PDFS_CREDENTIALS Creds )

{
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    if (Creds != NULL)
         Creds->RefCount--;

    ExReleaseResourceLite( &DfsData.Resource );

}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetConnectionPerfInfo, public
//
//  Synopsis:   This routine implements the functionality to get the 
//              performance information of an opened connection.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------

		      
NTSTATUS
DfsFsctrlGetConnectionPerfInfo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    UNICODE_STRING Prefix;
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING remPath, shareName;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_SERVICE service;
    ULONG i, USN;
    BOOLEAN pktLocked, fRetry;
    PDFS_CREDENTIALS Creds;
    ULONG InfoLen;
    PUCHAR BufToUse;
    UNICODE_STRING UsePrefix;

    BufToUse = Irp->UserBuffer;

    //
    // try to use the User's buffer here. The underlying call sets up 
    // pointers to unicode strings within the output buffer, and passing
    // a kernel buffer and copying it out to the user would not produce
    // the intended results.
    //

    if (BufToUse!= NULL) {
        try {
            ProbeForWrite(BufToUse,OutputBufferLength,sizeof(UCHAR));
        } except(EXCEPTION_EXECUTE_HANDLER) {
	    status = STATUS_INVALID_PARAMETER;
        }
    }
    else {
	status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {
	if ( (InputBufferLength > 0) &&
	    (InputBufferLength < MAXUSHORT) &&
	    ((InputBufferLength & 0x1) == 0) ) {

	    Prefix.MaximumLength = (USHORT)(InputBufferLength);
	    Prefix.Buffer = (PWCHAR) InputBuffer;
	    Prefix.Length = Prefix.MaximumLength;
	}
	else {
	    status = STATUS_INVALID_PARAMETER;
	}
    }

    if (NT_SUCCESS(status)) {
	Creds = DfsCaptureCredentials (Irp, &Prefix);

	DfsDbgTrace(+1, Dbg, "GetConnPerfInfo entered %wZ\n", &Prefix);
	DfsDbgTrace(0, Dbg, "GetConnPerfInfo creds=0x%x\n", Creds);

        DfsGetServerShare( &UsePrefix, &Prefix);
	pkt = _GetPkt();
	PktAcquireShared( TRUE, &pktLocked );    

	do {
	    fRetry = FALSE;

	    pktEntry = PktLookupEntryByPrefix( pkt, &UsePrefix, &remPath );

	    if (pktEntry != NULL) {
		InterlockedIncrement(&pktEntry->UseCount);
		USN = pktEntry->USN;
		status = STATUS_BAD_NETWORK_PATH;
		for (i = 0; i < pktEntry->Info.ServiceCount; i++) {
		    service = &pktEntry->Info.ServiceList[i];

		    try {
		      status = DfsTreeConnectGetConnectionInfo(
					service, 
					Creds,
					BufToUse,
					OutputBufferLength,
					&InfoLen);
		    }
		    except(EXCEPTION_EXECUTE_HANDLER) {
		      status = STATUS_INVALID_PARAMETER;
		    }
		    
		    //
                    // If tree connect succeeded, we are done.
                    //
		    if (NT_SUCCESS(status))
			break;
		    //
		    // If tree connect failed with an "interesting error" like
                    // STATUS_ACCESS_DENIED, we are done.
                    //
		    if (!ReplIsRecoverableError(status))
			break;
		    //
                    // Tree connect failed because of an error like host not
                    // reachable. In that case, we want to go on to the next
                    // server in the list. But before we do that, we have to see
                    // if the pkt changed on us while we were off doing the tree
                    // connect.
                    //
		    if (USN != pktEntry->USN) {
			fRetry = TRUE;
			break;
		    }
		}
		InterlockedDecrement(&pktEntry->UseCount);
	    } else {
		status = STATUS_BAD_NETWORK_PATH;
	    }
	} while ( fRetry );

	PktRelease();

	DfsReleaseCredentials(Creds);
	//
        // Dont put the InfoLen here... we already have the information in the
        // the user buffer, and dont want a copyout of kernel to user.
        //
    }
    Irp->IoStatus.Information = 0;

    DfsCompleteRequest(IrpContext, Irp, status);

    DfsDbgTrace(-1, Dbg, "GetConnPerfInfo Done, Status %x\n", ULongToPtr(status) );
    return( status );

}



//+-------------------------------------------------------------------
//
//  Function:   DfsTreeConnecGetConnectionInfo, private
//
//  Synopsis:   This routine calls into the provider with FSCTL_LMR
//              fsctl. Only lanman supports this fsctl, and if the provider
//              is lanman, we get our information buffer filled in.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------
    
NTSTATUS
DfsTreeConnectGetConnectionInfo(
				 IN PDFS_SERVICE Service, 
				 IN PDFS_CREDENTIALS Creds,
				 IN OUT PUCHAR OutputBuffer,
				 IN ULONG OutputBufferLength,
				 OUT PULONG InfoLen)
{
    NTSTATUS status;
    NTSTATUS ObjectRefStatus;
    UNICODE_STRING shareName;
    HANDLE treeHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN pktLocked;
    USHORT i, k;
    
    *InfoLen = 0;

    DfsDbgTrace(+1, Dbg, "DfsTreeConnectGetInfo entered creds %x\n", Creds);
    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );
    //
    // Compute the share name...
    //
    if (Service->pProvider != NULL &&
            Service->pProvider->DeviceName.Buffer != NULL &&
                Service->pProvider->DeviceName.Length > 0) {
        //
        // We have a provider already - use it
        //
        shareName.MaximumLength =
            Service->pProvider->DeviceName.Length +
                Service->Address.Length;
    } else {
        //
        // We don't have a provider yet - give it to the mup to find one
        //
        shareName.MaximumLength =
            sizeof(DD_NFS_DEVICE_NAME_U) +
                Service->Address.Length;
    }
    shareName.Buffer = ExAllocatePoolWithTag(PagedPool, shareName.MaximumLength, ' puM');

    if (shareName.Buffer != NULL) {
        //
        // If we have a cached connection to the IPC$ share of this server,
        // close it or it might conflict with the credentials supplied here.
        //

        if (Service->ConnFile != NULL) {

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
            if (Service->ConnFile != NULL)
                DfsCloseConnection(Service);

            ExReleaseResourceLite(&DfsData.Resource);
        }

        //
        // Now, build the share name to tree connect to.
        //

        shareName.Length = 0;

        if (Service->pProvider != NULL &&
                Service->pProvider->DeviceName.Buffer != NULL &&
                    Service->pProvider->DeviceName.Length > 0) {
            //
            // We have a provider already - use it
            //
 
            RtlAppendUnicodeToString(
                &shareName,
                Service->pProvider->DeviceName.Buffer);

        } else {

            //
            // We don't have a provider yet - give it to the mup to find one
            //

            RtlAppendUnicodeToString(
            &shareName,
            DD_NFS_DEVICE_NAME_U);
        }
 
        RtlAppendUnicodeStringToString(&shareName, &Service->Address);

        //
        // One can only do tree connects to server\share. So, in case
        // pService->Address refers to something deeper than the share,
        // make sure we setup a tree-conn only to server\share. Note that
        // by now, shareName is of the form
        // \Device\LanmanRedirector\server\share<\path>. So, count up to
        // 4 slashes and terminate the share name there.
        //

        for (i = 0, k = 0;
                i < shareName.Length/sizeof(WCHAR) && k < 5;
                    i++) {

            if (shareName.Buffer[i] == UNICODE_PATH_SEP)
                k++;
        }

        shareName.Length = i * sizeof(WCHAR);
        if (k == 5)
            shareName.Length -= sizeof(WCHAR);

        InitializeObjectAttributes(
            &objectAttributes,
            &shareName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

        //
        // Release the Pkt before going over the net...
        //

        PktRelease();

        status = ZwCreateFile(
                    &treeHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ |
                        FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                    (PVOID) (Creds) ? Creds->EaBuffer : NULL,
		    (Creds) ? Creds->EaLength : 0);

        if (NT_SUCCESS(status)) {

            PFILE_OBJECT fileObject;
	    LMR_REQUEST_PACKET request;
	    
	    DfsGetLogonId(&request.LogonId);
	    request.Type = GetConnectionInfo;
	    request.Version = REQUEST_PACKET_VERSION;
	    request.Level = 3;

	    status = ZwFsControlFile(
				     treeHandle,
				     NULL,
				     NULL,
				     NULL,
				     &ioStatusBlock,
				     FSCTL_LMR_GET_CONNECTION_INFO,
				     (LPVOID)&request,
				     sizeof(request),
				     OutputBuffer,
				     OutputBufferLength);
			    
	    if (NT_SUCCESS(status)) {
		*InfoLen = (ULONG)ioStatusBlock.Information;
	    }

            //
            // 426184, need to check return code for errors.
            //
            ObjectRefStatus = ObReferenceObjectByHandle(
                                 treeHandle,
                                 0,
                                 NULL,
                                 KernelMode,
                                 &fileObject,
                                 NULL);

            ZwClose( treeHandle );

            if (NT_SUCCESS(ObjectRefStatus)) {
                DfsDeleteTreeConnection( fileObject, USE_FORCE );
            }
        }

        ExFreePool( shareName.Buffer );

        PktAcquireShared( TRUE, &pktLocked );

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }
    DfsDbgTrace(-1, Dbg, "DfsTreeConnectGetInfo exit: Status %x\n", ULongToPtr(status) );
    return( status );

}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlCscServerOffline, public
//
//  Synopsis:   This routine implements the functionality to mark a server
//              as offline.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------


NTSTATUS
DfsFsctrlCscServerOffline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    UNICODE_STRING ServerName;
    LPWSTR Name;
    ULONG i, j;
    NTSTATUS NtStatus;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlCscServerOffline -> %ws\n", (WCHAR *)InputBuffer);


    if(InputBuffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
	DfsCompleteRequest( IrpContext, Irp, NtStatus );
	return NtStatus;
    }
    Name = (WCHAR *)InputBuffer;

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && (Name[i] == UNICODE_PATH_SEP); i++)
        NOTHING;

    for (j = i; j < InputBufferLength/sizeof(WCHAR) && (Name[j] != UNICODE_PATH_SEP); j++)
        NOTHING;
    
    ServerName.Buffer = &Name[i];
    ServerName.MaximumLength = ServerName.Length = (USHORT)(j - i) * sizeof(WCHAR);

    NtStatus = DfspMarkServerOffline(&ServerName);

    DfsCompleteRequest( IrpContext, Irp, NtStatus );
    DfsDbgTrace(-1, Dbg, "DfsFsctrlCscServerOffline -> %08lx\n", ULongToPtr(NtStatus) );
    return NtStatus;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlCscServerOnline, public
//
//  Synopsis:   This routine implements the functionality to mark a server
//              as online.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------



NTSTATUS
DfsFsctrlCscServerOnline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    UNICODE_STRING ServerName;
    LPWSTR Name;
    ULONG i, j;
    NTSTATUS NtStatus;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlCscServerOnline -> %ws\n", (WCHAR *)InputBuffer);
    
    if(InputBuffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
	DfsCompleteRequest( IrpContext, Irp, NtStatus );
	return NtStatus;
    }
    Name = (WCHAR *)InputBuffer;

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && (Name[i] == UNICODE_PATH_SEP); i++)
        NOTHING;

    for (j = i; j < InputBufferLength/sizeof(WCHAR) && (Name[j] != UNICODE_PATH_SEP); j++)
        NOTHING;
    
    ServerName.Buffer = &Name[i];
    ServerName.MaximumLength = ServerName.Length = (USHORT)(j - i) * sizeof(WCHAR);

    NtStatus = DfspMarkServerOnline(&ServerName);

    DfsCompleteRequest( IrpContext, Irp, NtStatus );
    DfsDbgTrace(-1, Dbg, "DfsFsctrlCscServerOnline -> %08lx\n", ULongToPtr(NtStatus) );
    return NtStatus;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlSpcRefresh, public
//
//  Synopsis:   This routine implements the functionality to update the
//              special table with a list of trusted domains, based on
//              the passed in domainname and dcname.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------


#if defined (_WIN64)
// 32 bit structure for handling spcrefresh from 32 bit client

typedef struct _DFS_SPC_REFRESH_INFO32 {
    ULONG  EventType;
    WORD * POINTER_32 DomainName;               // Name of domain
    WORD * POINTER_32 DCName;                   // Path of the share
} DFS_SPC_REFRESH_INFO32, *PDFS_SPC_REFRESH_INFO32;


#endif /* _WIN64 */
NTSTATUS
DfsFsctrlSpcRefresh (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength
) {
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING DomainName;
    UNICODE_STRING DCName;
    ULONG NameLen, i;
    LPWSTR Name, BufferEnd;
    DFS_SPC_REFRESH_INFO Param;
    PDFS_SPC_REFRESH_INFO pParam;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSpcRefresh\n", 0);
    STD_FSCTRL_PROLOGUE(DfsFsctrlSpcRefresh, TRUE, FALSE, FALSE);

    pParam = (PDFS_SPC_REFRESH_INFO) InputBuffer;

#if defined (_WIN64)
    if (IoIs32bitProcess(Irp)) {
        PDFS_SPC_REFRESH_INFO32 pParam32;
    
        pParam32 = (PDFS_SPC_REFRESH_INFO32) InputBuffer;

        if (InputBufferLength < sizeof(DFS_SPC_REFRESH_INFO32)) {
            NtStatus =  STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }
   
        Param.EventType = pParam32->EventType;
        Param.DomainName = (WCHAR *)(((ULONG_PTR)pParam32) + (ULONG)pParam32->DomainName);
        Param.DCName = (WCHAR *)(((ULONG_PTR)pParam32) + (ULONG)pParam32->DCName);
        pParam = &Param;
    }
    else {
#endif
    if (InputBufferLength < sizeof(DFS_SPC_REFRESH_INFO)) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }
      
    OFFSET_TO_POINTER(pParam->DomainName, pParam);
    OFFSET_TO_POINTER(pParam->DCName, pParam);

#if defined (_WIN64)
    }
#endif

    if (pParam->EventType != 0) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // If either string is not within the input buffer, error.
    //
    if ((POINTER_IN_BUFFER(pParam->DomainName, sizeof(WCHAR), 
                           InputBuffer, InputBufferLength) == 0) ||
        (POINTER_IN_BUFFER(pParam->DomainName, sizeof(WCHAR),
                           InputBuffer, InputBufferLength) == 0)) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // make sure the strings are valid.
    //
    BufferEnd = (LPWSTR)(InputBuffer + InputBufferLength);
    NameLen = (ULONG)(BufferEnd - pParam->DomainName);
    Name = pParam->DomainName;

    // Strip off leading slashes.
    for (i = 0; i < NameLen; i++) {
      if (*Name != UNICODE_PATH_SEP) {
	break;
      }
      Name++;
    }
    NameLen -= (ULONG)(Name - pParam->DomainName);

    for (i = 0; i < NameLen && Name[i]; i++)
      NOTHING;

    if ((i >= NameLen) || (i >= MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    RtlInitUnicodeString(&DomainName, Name);


    NameLen = (ULONG)(BufferEnd - pParam->DCName);
    Name = pParam->DCName;

    // Strip off leading slashes.
    for (i = 0; i < NameLen; i++) {
      if (*Name != UNICODE_PATH_SEP) {
	break;
      }
      Name++;
    }
    NameLen -= (ULONG)(Name - pParam->DCName);

    for (i = 0; i < NameLen && Name[i]; i++)
      NOTHING;

    if ((i >= NameLen) || (i >= MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    RtlInitUnicodeString(&DCName, Name);
    
    NtStatus = PktpUpdateSpecialTable(
                    &DomainName,
                    &DCName);

exit_with_status:

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlSpcRefresh -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fsctrl.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dsfsctl.h
//
//  Contents:   This module contains the definitions of internally used file
//              system controls for the Dfs file system.  It also contains
//              definitions of macros used in the implementation of Fsctrls.
//
//              Public control code and structure declarations are in the
//              private header file dfsfsctl.h.
//
//  Classes:    -none-
//
//  Functions:  -none-
//
//  History:    02 Jan 1992     Alan Whitney (alanw)    Created
//
//--------------------------------------------------------------------------



#ifndef _DSFSCTL_
#define _DSFSCTL_


#ifndef IOCTL_DFS_BASE
# include <dfsfsctl.h>
#endif  //IOCTL_DFS_BASE

//+----------------------------------------------------------------------------
//
//  Macro:      IS_DFS_CTL_CODE
//
//  Synopsis:   Determines whether a fsctrl code is a Dfs fsctrl code.
//
//  Arguments:  [c] -- The control code to test
//
//  Returns:    TRUE if c is a Dfs fsctrl code, FALSE if its not.
//
//-----------------------------------------------------------------------------

#define IS_DFS_CTL_CODE(c)                                              \
    (((c) & CTL_CODE(0xFF, 0,0,0)) == CTL_CODE(FSCTL_DFS_BASE, 0,0,0))


//+----------------------------------------------------------------------------
//
//  Macro:      OFFSET_TO_POINTER
//
//  Synopsis:   Certain fsctls (mainly those issued by the srvsvc) communicate
//              via buffers that contain "pointers" which are really offsets
//              from the beginning of the buffer. This macro fixes up the
//              offsets to real pointers
//
//  Arguments:  [field] -- The field to fix up.
//              [buffer] -- The beginning of the buffer.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define OFFSET_TO_POINTER(field, buffer)  \
    ( ((PCHAR)field) += ((ULONG_PTR)buffer) )

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_TO_OFFSET
//
//  Synopsis:   Reverse of OFFSET_TO_POINTER.  Turns a pointer into a
//              buffer-relative address
//
//  Arguments:  [field] -- The field to fix up.
//              [buffer] -- The beginning of the buffer.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define POINTER_TO_OFFSET(field, buffer)  \
    ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )

//+----------------------------------------------------------------------------
//
//  Macro:      UNICODESTRING_IS_VALID
//
//  Synopsis:   Determines whether a passed-in UNICODE_STRING is good
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define UNICODESTRING_IS_VALID(ustr,start,len)                              \
    (                                                                       \
    ((ustr).Length <= (len)) &&                                             \
    ((PCHAR)(ustr).Buffer >= (PCHAR)(start)) &&                             \
    ((PCHAR)(ustr).Buffer <= (PCHAR)(start) + ((len) - (ustr).Length))      \
    )

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_IN_BUFFER
//
//  Synopsis:   Determines whether a pointer lies within a buffer
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define POINTER_IN_BUFFER(ptr,size,buf,len)                           \
  (((PCHAR)(ptr) >= (PCHAR)(buf)) && (((PCHAR)(ptr) + (size)) <= ((PCHAR)(buf) + len)))


//+----------------------------------------------------------------------------
//
//  Function:   DFS_DUPLICATE_STRING
//
//  Synopsis:   Macro to create a UNICODE_STRING from an LPWSTR. The buffer
//              for the UNICODE_STRING is allocated using ExAllocatePoolWithTag.
//
//              Useful for duplicating strings received in fsctls from the
//              server.
//
//  Arguments:  [ustr] -- Destination UNICODE_STRING
//              [pwsz] -- Source LPWSTR
//              [status] -- If pool allocation fails, this will be set to
//                      STATUS_INSUFFICIENT_RESOURCES
//
//  Returns:    Nothing. Check the status parameter to see if the operation
//              succeeded.
//
//-----------------------------------------------------------------------------

#define DFS_DUPLICATE_STRING(ustr,pwsz,status)                               \
ustr.Length = wcslen(pwsz) * sizeof(WCHAR);                                  \
ustr.MaximumLength = ustr.Length + sizeof(WCHAR);                            \
ustr.Buffer = ExAllocatePoolWithTag(PagedPool,ustr.MaximumLength,' puM');    \
if (ustr.Buffer != NULL) {                                                   \
    RtlCopyMemory( ustr.Buffer, pwsz, ustr.MaximumLength );                  \
    status = STATUS_SUCCESS;                                                 \
} else {                                                                     \
    status = STATUS_INSUFFICIENT_RESOURCES;                                  \
}


//+---------------------------------------------------------------------------
//
// Macro:       STD_FSCTRL_PROLOGUE, public
//
// Synopsis:    Do the standard stuff associated with any fsctrl implementation
//              which needs to run in the FSP.  This assumes a standard set
//              of parameters for the calling function, as below:
//
//                      DfsMyownFsctrl(
//                              IN PIRP_CONTEXT IrpContext,
//                              IN PIRP Irp,
//                      [maybe] IN PVOID InputBuffer,
//                              IN ULONG InputBufferLength,
//                      [maybe] IN PVOID OutputBuffer,
//                              IN ULONG OutputBufferLength
//                      );
//
// Arguments:   [szName] -- Name of the function for debug trace messages
//              [fExpInp] -- TRUE if it takes an input buffer
//              [fExpOutp] -- TRUE if it takes an output buffer
//              [fInFsp] -- TRUE if the request must be processed from the
//                          FSP.
//
// Returns:     None
//
//  Notes:      The macros CHECK_BUFFER_TRUE and CHECK_BUFFER_FALSE are
//              necessary for the generation of STD_FSCTRL_PROLOGUE and
//              are not intended to be used directly.
//
//
//----------------------------------------------------------------------------

#define CHK_BUFFER_FALSE(szName, inout) ;
#define CHK_BUFFER_TRUE(szName, inout)                          \
    if (!ARGUMENT_PRESENT(inout##Buffer) || (inout##BufferLength == 0)) {\
        DfsDbgTrace(0, Dbg, #szName ": Bad buffer\n", 0);                \
        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );\
        return STATUS_INVALID_PARAMETER;                                \
    }

#define CHK_INFSP_FALSE(szName)
#define CHK_INFSP_TRUE(szName)                                          \
    if ((IrpContext->Flags & IRP_CONTEXT_FLAG_IN_FSD) != 0) {           \
        DfsDbgTrace(0, Dbg, #szName ": Posting to FSP\n",0);             \
        status = DfsFsdPostRequest( IrpContext, Irp );                  \
        return status;                                                  \
    }

#define STD_FSCTRL_PROLOGUE(szName, fExpInp, fExpOutp, fInFsp) {        \
    ASSERT(ARGUMENT_PRESENT(IrpContext) && (ARGUMENT_PRESENT(Irp)));    \
    CHK_BUFFER_##fExpInp(szName, Input)                                 \
    CHK_BUFFER_##fExpOutp(szName, Output)                               \
    CHK_INFSP_##fInFsp(szName)                                          \
    DfsDbgTrace(+1, Dbg, #szName ": Entered\n", 0);                      \
}


//+---------------------------------------------------------------------------
//
//  Macro:      RETURN_BUFFER_SIZE, public
//
//  Synopsis:   Return conventional errors when the output of an fsctrl
//              function is larger than the user buffer. This assumes a
//              standard set of parameters for the calling function, as
//              below:
//
//                      DfsMyownFsctrl(
//                              IN PIRP_CONTEXT IrpContext,
//                              IN PIRP Irp,
//                      [maybe] IN PVOID InputBuffer,
//                      [maybe] IN ULONG InputBufferLength,
//                              IN PVOID OutputBuffer,
//                              IN ULONG OutputBufferLength
//                      );
//
//  Arguments:  [x] -- The required size of the output buffer
//              [Status] -- The status to be returned from the fsctrl.
//
//  Returns:    Sets Status to STATUS_BUFFER_TOO_SMALL or
//              STATUS_BUFFER_OVERFLOW.  The convention we use is that if
//              the OutputBuffer is at least sizeof(ULONG) big, then we stuff
//              the needed size in OutputBuffer and return
//              STATUS_BUFFER_OVERFLOW, which is a warning code.  If the
//              OutputBuffer isn't big enough for that, we return
//              STATUS_BUFFER_TOO_SMALL.
//
//  Notes:      Requires that the function declare "OutputBufferLength",
//              "OutputBuffer", and "Irp". Irp->IoStatus.Information will
//              be set to the return size.
//
//----------------------------------------------------------------------------

#define RETURN_BUFFER_SIZE(x, Status)                                   \
    if ((OutputBufferLength) < sizeof(ULONG)) {                         \
        Status = STATUS_BUFFER_TOO_SMALL;                               \
    } else {                                                            \
        Status = STATUS_BUFFER_OVERFLOW;                                \
        *((PULONG) OutputBuffer) = x;                                   \
        Irp->IoStatus.Information = sizeof(ULONG);                      \
    }


//
//  Internal Distributed file system control operations (private, checked versions only)
//

#define FSCTL_DFS_DBG_BREAK             CTL_CODE(FSCTL_DFS_BASE, 2045, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_DBG_FLAGS             CTL_CODE(FSCTL_DFS_BASE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_INTERNAL_READ_MEM     CTL_CODE(FSCTL_DFS_BASE, 2047, METHOD_BUFFERED, FILE_READ_DATA)

#define FSCTL_DFS_SET_PKT_ENTRY_TIMEOUT CTL_CODE(FSCTL_DFS_BASE, 2048, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_VERBOSE_FLAGS         CTL_CODE(FSCTL_DFS_BASE, 2049, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_EVENTLOG_FLAGS        CTL_CODE(FSCTL_DFS_BASE, 2050, METHOD_BUFFERED, FILE_WRITE_DATA)
//
//  Control structure for FSCTL_DFS_INTERNAL_READ_MEM (input)
//

typedef struct _FILE_DFS_READ_MEM {
    DWORD_PTR Address;
    ULONG     Length;
} FILE_DFS_READ_MEM, *PFILE_DFS_READ_MEM;

#endif // _DSFSCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\know.c ===
//+------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       Know.C
//
//  Contents:   This file has all the code that involves with knowledge
//              synchronisation on the DC.
//
//  Synoposis:  This code handles the fixing of knowledge inconsistencies.
//              All this code runs only on the DC in response to FSCTRLs from
//              a client etc.
//
//  Functions:  DfsTriggerKnowledgeVerification -
//
//  History:    22-March-1993   SudK    Created
//              18-June-1992    SudK    Added FixLocalVolumeKnowledge
//
//-------------------------------------------------------------------

#include "dfsprocs.h"
#include "fsctrl.h"
#include "dnr.h"
#include "know.h"
#include "log.h"
#include "smbtypes.h"
#include "smbtrans.h"

#define Dbg     (DEBUG_TRACE_LOCALVOL)


//
//  local function prototypes
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsTriggerKnowledgeVerification )
#endif // ALLOC_PRAGMA


//+------------------------------------------------------------------
//
//  Function:   DfsTriggerKnowledgeVerification
//
//  Synopsis:   This function calls the DC and informs it that a specific
//              service for a volume seems to have inconsistenct knowledge
//              with the DC.
//
//              If the service in question is a local service, then it means
//              that there is an extra exit point on the disk. In that event
//              this routine merely deletes the extra exit point.
//
//  Arguments:  [DnrContext] -- The DnrContext has all that this func needs.
//
//  Returns:    The status from this not checked by anyone actually.
//
//  History:    4-April-1993    SudK    Created
//
//  Notes:      This method should be called from DNR only.  It is
//              assumed that the caller has released any locks on the
//              PKT.  There is a possibility of deadlock if the PKT lock
//              is held over this function, since the DC may call back
//              to us to correct knowledge errors.
//
//-------------------------------------------------------------------
NTSTATUS
DfsTriggerKnowledgeVerification(
    IN  PDNR_CONTEXT    DnrContext)
{

    NTSTATUS                    status = STATUS_SUCCESS;
    NTSTATUS                    ReplStatus;
    IO_STATUS_BLOCK             ioStatusBlock;

    ULONG                       size;
    PBYTE                       buffer = NULL;
    PDFS_REFERRAL_V1            ref;

    UNICODE_STRING              prefix, address;

    PDFS_PKT_ENTRY              pPktEntryDC;
    PDFS_SERVICE                DCService;
    PPROVIDER_DEF               DCProvider;
    REPL_SELECT_CONTEXT         DCSelectContext;
    HANDLE                      remoteHandle;

    UNICODE_STRING              puStr[2];

    DfsDbgTrace(+1, Dbg, "DfsTriggerKnowledgeVerification: %wZ\n",
                                            &DnrContext->pPktEntry->Id.Prefix);
    DfsDbgTrace( 0, Dbg, " ServiceName: [%wZ]\n",
        ((DnrContext->pService->Type & DFS_SERVICE_TYPE_LOCAL) ?
            &DnrContext->pService->Address :
                &DnrContext->pService->Name) );

    RtlZeroMemory(&DCSelectContext, sizeof(REPL_SELECT_CONTEXT));

    //
    // First, create a REQ_REPORT_DFS_INCONSISTENCY buffer for the rdr to
    // send to the DC.
    //

    if (DnrContext->pPktEntry->USN != DnrContext->USN) {

        DfsDbgTrace(0, Dbg,"Pkt Entry changed!\n", 0 );
        DfsDbgTrace(0, Dbg, "Old USN: %d\n", ULongToPtr(DnrContext->USN) );
        DfsDbgTrace(0, Dbg, "New USN: %d\n", ULongToPtr(DnrContext->pPktEntry->USN) );

        status = STATUS_INVALID_HANDLE;
    }

    if (NT_SUCCESS(status)) {

        prefix = DnrContext->pPktEntry->Id.Prefix;

        address = DnrContext->pService->Address;

        size = prefix.Length +
                sizeof(WCHAR) +
                    sizeof(DFS_REFERRAL_V1) +
                        address.Length +
                            sizeof(WCHAR);

        // For some strange, undocumented reason, the buffer size passed in
        // to ZwFsControlFile is size + sizeof(ULONG). So allocate that size here.

        buffer = ExAllocatePoolWithTag( PagedPool, size + sizeof(ULONG), ' puM' );

        if (buffer != NULL) {

            RtlMoveMemory( buffer, prefix.Buffer, prefix.Length);

            ((PWCHAR)buffer)[prefix.Length/sizeof(WCHAR)] = UNICODE_NULL;

            ref = (PDFS_REFERRAL_V1) (buffer + prefix.Length + sizeof(WCHAR));

            ref->VersionNumber = 1;

            ref->Size = sizeof(DFS_REFERRAL_V1) + address.Length + sizeof(WCHAR);

            ref->ServerType = 0;

            RtlMoveMemory( ref->ShareName, address.Buffer, address.Length );

            ref->ShareName[ address.Length/sizeof(WCHAR) ] = UNICODE_NULL;

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // Next, connect to the DC.
    //

    if (NT_SUCCESS(status)) {

        BOOLEAN pktLocked;
        BOOLEAN LastEntry = FALSE;

        //
        // We need to get a handle to the DC now.  So that we can make an
        // FSCTRL to the DC.
        //

        PktAcquireShared( TRUE, &pktLocked );

        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

        pPktEntryDC = PktLookupReferralEntry(
                            &DfsData.Pkt,
                            DnrContext->pPktEntry);

        if (pPktEntryDC != NULL) {

            ReplStatus = ReplFindFirstProvider(
                                pPktEntryDC,
                                NULL,
                                NULL,
                                &DCService,
                                &DCSelectContext,
                                &LastEntry);

        }

        if (pPktEntryDC == NULL || !NT_SUCCESS(ReplStatus)) {

            DfsDbgTrace(0, Dbg,
                "DfsTriggerKnowVerification. Failed to find DC\n", 0);

            status = STATUS_CANT_ACCESS_DOMAIN_INFO;

        } else {

            DCProvider = DCService->pProvider;

        }

        ExReleaseResourceLite( &DfsData.Resource );

        if (NT_SUCCESS(status)) {

            status = DfsCreateConnection(
                        DCService,
                        DCProvider,
                        (BOOLEAN)((DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0),
                        &remoteHandle);

        }

        PktRelease();

    }

    //
    //  Lastly, tell the DC to try and fix up the volume on the server. This
    //  call may result in a call back to ourselves in the event that we
    //  are missing knowledge about a local volume.
    //

    if (NT_SUCCESS(status))     {

        status = ZwFsControlFile(
                    remoteHandle,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_DFS_VERIFY_REMOTE_VOLUME_KNOWLEDGE,
                    buffer,
                    size + sizeof(ULONG),
                    NULL,
                    0
                );

        if (NT_SUCCESS(status))
            status = ioStatusBlock.Status;

        ZwClose( remoteHandle );

    }


    if (buffer != NULL)
        ExFreePool(buffer);

    DfsDbgTrace(-1, Dbg,
        "DfsTriggerKnowledgeVerification - exit %08lx\n", ULongToPtr(status) );

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\io.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    io.c

Abstract:

    This module contains IRP building routines.

Author:

    Manny Weiser (mannyw)    13-Jan-1992

Revision History:

--*/

#include "mup.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupBuildIoControlRequest )
#endif

PIRP
MupBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    )

/*++

Routine Description:

    This function builds an I/O request packet for a device or
    file system I/O control request.

Arguments:

    Irp - Supplies a pointer to an IRP.  If NULL, this routine allocates
        an IRP and returns its address.  Otherwise, it supplies the
        address of an IRP allocated by the caller.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    MajorFunction - The major function that we are calling.  Currently
        this most be one of IRP_MJ_FILE_SYSTEM_CONTROL or
        IRP_MJ_DEVICE_IO_CONTROL.

    IoControlCode - Supplies the control code for the operation.

    MainBuffer - Supplies the address of the main buffer.  This must
        be a system virtual address, and the buffer must be locked in
        memory.  If ControlCode specifies a method 0 request, the actual
        length of the buffer must be the greater of InputBufferLength
        and OutputBufferLength.

    InputBufferLength - Supplies the length of the input buffer.

    AuxiliaryBuffer - Supplies the address of the auxiliary buffer.  If the
        control code method is 0, this is a buffered I/O buffer, but the
        data returned by the called driver in the system buffer is not
        automatically copied into the auxiliary buffer.  Instead, the
        auxiliary data ends up in MainBuffer.  If the caller wishes the
        data to be in AuxiliaryBuffer, it must copy the data at some point
        after the completion routine runs.

        If the control code method is 1 or 2, this parameter is ignored;
        instead, the Mdl parameter is used to obtain the starting
        virtual address of the buffer.

    CompletionRoutine - The IO completion routine.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.  If the Irp
        parameter was not NULL on input, the function return value will
        be the same value (so it is safe to discard the return value in
        this case).  It is the responsibility of the calling program to
        deallocate the IRP after the I/O request is complete.

--*/

{
    CLONG method;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PMDL pMdl;

    ASSERT( MajorFunction == IRP_MJ_DEVICE_CONTROL );
    PAGED_CODE();

    if (MainBuffer == NULL) {

        return (NULL);

    }


    //
    // Get the method with which the buffers are being passed.
    //

    method = IoControlCode & 3;

    //
    // Allocate an IRP.  The stack size is one higher
    // than that of the target device, to allow for the caller's
    // completion routine.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Get the address of the target device object.
    //

    Irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize + 1), FALSE );
    if ( Irp == NULL ) {

        //
        // Unable to allocate an IRP.  Inform the caller.
        //

        return NULL;
    }

    IoSetNextIrpStackLocation( Irp );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the current stack location and fill in the
    // device object pointer.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    irpSp->DeviceObject = deviceObject;

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        CompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Based on the method by which the buffers are being passed,
    // describe a system buffer and optionally build an MDL.
    //

    switch ( method ) {

    case 0:

        //
        // For this case, InputBuffer must be large enough to contain
        // both the input and the output buffers.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        Irp->UserBuffer = AuxiliaryBuffer;

        Irp->Flags = (ULONG)IRP_BUFFERED_IO;
        if ( ARGUMENT_PRESENT(AuxiliaryBuffer) ) {
            Irp->Flags |= IRP_INPUT_OPERATION;
        }

        break;

    case 1:
    case 2:

        //
        // For these two cases, MainBuffer is the buffered I/O "system
        // buffer".  Build an MDL for either read or write access,
        // depending on the method, for the output buffer.
        //

        pMdl = IoAllocateMdl( MainBuffer, InputBufferLength, FALSE, FALSE, Irp );

        if (pMdl == NULL) {

            IoFreeIrp(Irp);
            return NULL;

        }

        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        Irp->Flags = (ULONG)IRP_BUFFERED_IO;

        //
        // An MDL to describe the buffer has not been built.  Build
        // it now.
        //

        MmProbeAndLockPages(
                    Irp->MdlAddress,
                    KernelMode,
                    IoReadAccess
                    );
        break;

    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->UserBuffer = AuxiliaryBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = MainBuffer;
        break;

    }

    return Irp;

} // MupBuildIoControlRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fscontrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fscontrl.c

Abstract:

    This module implements the file system control routines for the MUP
    called by the dispatch driver.

Author:

    Manny Weiser (mannyw)    26-Dec-1991

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTROL)

//
//  local procedure prototypes
//

NTSTATUS
RegisterUncProvider (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupFsControl )
#pragma alloc_text( PAGE, RegisterUncProvider )
#endif


NTSTATUS
MupFsControl (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the the File System Control IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the Irp

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT FileObject;

    PAGED_CODE();
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = irpSp->FileObject;

    DebugTrace(+1, Dbg, "MupFsControl\n", 0);
    MUP_TRACE_HIGH(TRACE_IRP, MupFsControl_Entry,
                   LOGPTR(MupDeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject));

    //
    //  Reference our input parameters to make things easier
    //


    DebugTrace(+1, Dbg, "MupFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", irpSp->Parameters.FileSystemControl.OutputBufferLength);
    DebugTrace( 0, Dbg, "InputBufferLength  = %08lx\n", irpSp->Parameters.FileSystemControl.InputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", irpSp->Parameters.FileSystemControl.FsControlCode);

    try {
        //
        // Decide how to handle this IRP.  Call the appropriate worker function.
        //

        switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_MUP_REGISTER_UNC_PROVIDER:

            if( Irp->RequestorMode != KernelMode ) {
                status = STATUS_ACCESS_DENIED;
                MupCompleteRequest(Irp, STATUS_ACCESS_DENIED);
                return STATUS_ACCESS_DENIED;
            }

            status = RegisterUncProvider( MupDeviceObject, Irp );
            break;

        default:

            if (MupEnableDfs) {
                status = DfsFsdFileSystemControl(
                            (PDEVICE_OBJECT) MupDeviceObject,
                            Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
                MupCompleteRequest(Irp, STATUS_INVALID_PARAMETER);
            }

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        NOTHING;
    }

    //
    // Return to the caller.
    //


    MUP_TRACE_HIGH(TRACE_IRP, MupFsControl_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(MupDeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    DebugTrace(-1, Dbg, "MupFsControl -> %08lx\n", status);
    return status;
}


NTSTATUS
RegisterUncProvider (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles registration of a UNC provider.  The provider
    is added to the list of available providers.

Arguments:

    MupDeviceObject - A pointer to the file system device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PVCB vcb;
    PVOID fsContext2;
    PIO_STACK_LOCATION irpSp;

    PREDIRECTOR_REGISTRATION paramBuffer;
    ULONG paramLength;
    BLOCK_TYPE blockType;

    PUNC_PROVIDER uncProvider = NULL;
    PUNC_PROVIDER provider;
    PLIST_ENTRY listEntry;
    PVOID dataBuffer;

    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN InsertInProviderList = FALSE;

    MupDeviceObject;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "RegisterUncProvider\n", 0);

    //
    // Get MUP ordering information, if we haven't already.
    //

    MupAcquireGlobalLock();

    if ( !MupOrderInitialized ) {
        MupOrderInitialized = TRUE;
        MupReleaseGlobalLock();
        MupGetProviderInformation();
    } else {
        MupReleaseGlobalLock();
    }

    //
    // Make local copies of the input parameters to make things easier.
    //

    paramLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    paramBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Decode the file object.  If it is the file system VCB, it will be
    // referenced.
    //

    blockType = MupDecodeFileObject(
                    irpSp->FileObject,
                    (PVOID *)&vcb,
                    &fsContext2
                    );

    if ( blockType != BlockTypeVcb ) {

        DebugTrace(0, Dbg, "File is disconnected from us\n", 0);

        MupCompleteRequest( Irp, STATUS_INVALID_HANDLE );
        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "RegisterUncProvider -> %08lx\n", status );
        return status;
    }

    try {

        UNICODE_STRING deviceName;

        deviceName.Length = (USHORT)paramBuffer->DeviceNameLength;
        deviceName.MaximumLength = (USHORT)paramBuffer->DeviceNameLength;
        deviceName.Buffer = (PWCH)((PCHAR)paramBuffer + paramBuffer->DeviceNameOffset);

        //
        // Do the work
        //

        uncProvider = MupCheckForUnregisteredProvider( &deviceName );

        if ( uncProvider == NULL) {

            InsertInProviderList = TRUE;
	    uncProvider = MupAllocateUncProvider(
                              paramBuffer->DeviceNameLength);

            if (uncProvider != NULL) {

                //
                // Copy the data from the IRP.
                //

                dataBuffer = uncProvider + 1;
                uncProvider->DeviceName = deviceName;
                uncProvider->DeviceName.Buffer = dataBuffer;
                uncProvider->Priority = 0x7FFFFFFF;
                RtlMoveMemory(
                    uncProvider->DeviceName.Buffer,
                    (PCHAR)paramBuffer + paramBuffer->DeviceNameOffset,
                    paramBuffer->DeviceNameLength);

            } else {

                status = STATUS_INVALID_USER_BUFFER;
                try_return( NOTHING );

            }

        }

        dataBuffer = (PCHAR)dataBuffer + uncProvider->DeviceName.MaximumLength;

        uncProvider->MailslotsSupported = paramBuffer->MailslotsSupported;


        //
        // Reference the unc provider
        //

        MupReferenceBlock( uncProvider );

        //
        // Get a handle to the provider.
        //

        InitializeObjectAttributes(
            &objectAttributes,
            &uncProvider->DeviceName,
            OBJ_CASE_INSENSITIVE,      // Attributes
            0,                         // Root Directory
            NULL                       // Security
            );

        status = NtOpenFile(
                    &uncProvider->Handle,
                    FILE_TRAVERSE,
                    &objectAttributes,
                    &ioStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );

        if ( NT_SUCCESS( status ) ) {
            status = ioStatusBlock.Status;
        }

        if ( NT_SUCCESS( status ) ) {
            //
            // Use the file object, to keep a pointer to the uncProvider
            //

            irpSp->FileObject->FsContext2 = uncProvider;
            //
            // 426184, need to check return code for errors.
            //
            status = ObReferenceObjectByHandle(
                         uncProvider->Handle,
                         0,
                         NULL,
                         KernelMode,
                         (PVOID *)&uncProvider->FileObject,
                         &handleInformation
                         );

	    if (!NT_SUCCESS( status)) {
	      NtClose(uncProvider->Handle);
	    }
        }

        if ( !NT_SUCCESS( status ) ) {
            MupDereferenceUncProvider(uncProvider);
	}
        else {
            uncProvider->DeviceObject = IoGetRelatedDeviceObject(
                                            uncProvider->FileObject
                                            );

            MupAcquireGlobalLock();

            MupProviderCount++;

	    if(InsertInProviderList) {
		//
		// We need to make sure we put the providers in the list in order of priority.
		//

		listEntry = MupProviderList.Flink;
		while ( listEntry != &MupProviderList ) {

		    provider = CONTAINING_RECORD(
			listEntry,
			UNC_PROVIDER,
			ListEntry
			);

		    if( uncProvider->Priority < provider->Priority ) {
			break;
		    }
		    listEntry = listEntry->Flink;
		}

		InsertTailList(listEntry, &uncProvider->ListEntry);
	    }
	    
	    uncProvider->Registered = TRUE;
            MupReleaseGlobalLock();


            //
            // !!! What do we do with the handle?  It is useless.
            //

            //
            // Finish up the fs control IRP.
            //

            status = STATUS_SUCCESS;
        }

try_exit: NOTHING;
    } finally {

        if ( AbnormalTermination() ) {
            status = STATUS_INVALID_USER_BUFFER;
        }

        //
        // Release the reference to the VCB.
        //

        MupDereferenceVcb( vcb );

        DebugTrace(-1, Dbg, "MupRegisterUncProvider -> %08lx\n", status);
    }

    MupCompleteRequest( Irp, status );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\fspdisp.c ===
//+----------------------------------------------------------------------------
//
//  File:       FSPDISP.C
//
//  Contents:   This module implements the main dispatch procedure
//              for the Dsfs FSP.
//
//  Functions:  DfsFsdPostRequest - post an IRP request to the FSP
//              DfsFspDispatch - Dispatch IRP requests from FSP thread
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//              25 Apr 1993     Alanw   Updated to use Ex worker threads
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dnr.h"


//
//  Define our local debug trace level
//

#define Dbg                             (DEBUG_TRACE_FSP_DISPATCHER)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFspDispatch )
//
// DfsFsdPostRequest cannot be paged since it is called from
// DnrCompleteFileOpen
//
//  DfsFsdPostRequest
//
#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DfsFsdPostRequest, public
//
//  Synopsis:   This routine enqueues the request packet specified by
//              IrpContext to the work queue associated with the
//              FileSysDeviceObject.  This is a FSD routine.
//
//  Arguments:  [IrpContext] -- Pointer to the IrpContext to be queued to
//                      the Fsp
//              [Irp] -- I/O Request Packet, or NULL if it has already been
//                      completed.
//
//  Returns:    STATUS_PENDING
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(0, Dbg, "DfsFsdPostRequest: Irp = %08lx\n", Irp);

    ASSERT( ARGUMENT_PRESENT(Irp) &&
            IrpContext->OriginatingIrp == Irp );

    //
    //  Verify our assumptions about not needing DfsPrePostIrp processing.
    //
    ASSERT((IrpContext->MajorFunction != IRP_MJ_READ) &&
           (IrpContext->MajorFunction != IRP_MJ_WRITE) &&
           (IrpContext->MajorFunction != IRP_MJ_DIRECTORY_CONTROL) &&
           (IrpContext->MajorFunction != IRP_MJ_QUERY_EA) &&
           (IrpContext->MajorFunction != IRP_MJ_SET_EA));


    //
    //  Mark that we've already returned pending to the user
    //
    IoMarkIrpPending( Irp );

    //
    //  Send the IRP_CONTEXT off to an Ex worker thread.
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          DfsFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsFspDispatch, public
//
//  Synopsis:   This is the main FSP thread routine that is executed to receive
//              and dispatch IRP requests.  Each FSP requst begins its
//              execution here.
//
//  Arguments:  [Context] -- Supplies a pointer to a DFS IRP context record.
//
//  Returns:    Nonthing
//
//  Notes:
//
//--------------------------------------------------------------------

VOID
DfsFspDispatch (
    IN PVOID Context
) {

//    PFS_DEVICE_OBJECT FileSysDeviceObject = Context;
    PIRP Irp;
    PIRP_CONTEXT IrpContext = Context;

    Irp = IrpContext->OriginatingIrp;

    //
    //  Now because we are the Fsp we will force the IrpContext to
    //  indicate true on Wait.
    //

    IrpContext->Flags |= IRP_CONTEXT_FLAG_WAIT;
    IrpContext->Flags &= ~IRP_CONTEXT_FLAG_IN_FSD;

    //
    //  Now we'll loop forever, reading a new IRP request and dispatching
    //  on the IRP function
    //

    while (TRUE) {

        DfsDbgTrace(0, Dbg, "DfsFspDispatch: Irp = %08lx\n", Irp);

        ASSERT (Irp != NULL && Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED);


        //
        //  Now case on the function code.      For each major function code,
        //  either call the appropriate FSP routine or case on the minor
        //  function and then call the FSP routine.      The FSP routine that
        //  we call is responsible for completing the IRP, and not us.
        //  That way the routine can complete the IRP and then continue
        //  post processing as required.  For example, a read can be
        //  satisfied right away and then read-ahead can be done.
        //
        //  We'll do all of the work within an exception handler that
        //  will be invoked if ever some underlying operation gets into
        //  trouble.
        //

        FsRtlEnterFileSystem();

        try {
            switch (IrpContext->MajorFunction) {

                //
                //  For Create/Open operations, we post a workitem only
                //  to resume DNR after a call to IoCallDriver.
                //
                //

            case IRP_MJ_CREATE:
	    case IRP_MJ_CREATE_NAMED_PIPE:
	    case IRP_MJ_CREATE_MAILSLOT:

                 ASSERT(IrpContext->Context != NULL);
                 ASSERT( ((PDNR_CONTEXT)IrpContext->Context)->NodeTypeCode ==
                        DSFS_NTC_DNR_CONTEXT );
                 DnrNameResolve( (PDNR_CONTEXT)IrpContext->Context );
		 PsAssignImpersonationToken(PsGetCurrentThread(),NULL);
                 break;

                //
                //      For close operations
                //
                case IRP_MJ_CLOSE:
                    DfsFspClose( IrpContext, Irp );
                    break;

                //
                //  For Set Information operations,
                //

                case IRP_MJ_SET_INFORMATION:

                    DfsFspSetInformation( IrpContext, Irp );
                    break;

                //
                //  For Query Volume Information operations,
                //

                case IRP_MJ_QUERY_VOLUME_INFORMATION:

                    DfsFspQueryVolumeInformation( IrpContext, Irp );
                    break;

                //
                //  For Set Volume Information operations,
                //

                case IRP_MJ_SET_VOLUME_INFORMATION:

                    DfsFspSetVolumeInformation( IrpContext, Irp );
                    break;

                //
                //  For File System Control operations,
                //

                case IRP_MJ_FILE_SYSTEM_CONTROL:

                    DfsFspFileSystemControl( IrpContext, Irp );
                    break;

                //
                //  For any other major operations, return an invalid
                //  request.
                //

                default:
                    DfsDbgTrace(0, Dbg, "DfsFspDispatch:  Unhandled request, MajorFunction = %08lx\n", IrpContext->MajorFunction);

                    DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                    break;
            }

        } except( DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

            DfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

        FsRtlExitFileSystem();

        //
        //  NOTE: If we were to process an overflow device queue, we would
        //        do it here.  Instead, we'll just return to the worker
        //        thread.
        //

        break;

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\know.h ===
//+------------------------------------------------------------------
//
// File:        Know.h
//
// Contents:    Header file for knowledge related functions.
//
// Functions:   
//
// History:     22-March-1992   SudK    Created
//
//-------------------------------------------------------------------



NTSTATUS
DfsTriggerKnowledgeVerification(
    IN  PDNR_CONTEXT    DnrContext
    );

NTSTATUS
DfsDispatchUserModeThread(
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\lock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This module implements debugging function for locks.

Author:

    Manny Weiser (mannyw) 17-Jan-1992
        This is essentially a copy of the LAN Manager server lock
        debugging

Revision History:

--*/

#if MUPDBG

#include "mup.h"

#define HAS_TEB(_teb) ((BOOLEAN)(((ULONG)(_teb) <= MM_HIGHEST_USER_ADDRESS) ? FALSE : MmIsNonPagedSystemAddressValid(_teb)))

#define MupCurrentTeb( ) ((PTEB)(KeGetCurrentThread( )->Teb))

#define MupTebLockList( ) \
    ((PLIST_ENTRY)&(MupCurrentTeb( )->UserReserved[MUP_TEB_LOCK_LIST]))

#define MupThreadLockAddress( )                                               \
    ( IsListEmpty( MupTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 MupTebLockList( )->Flink,    \
                                                 MUP_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 ) )

#define MupThreadLockLevel( )                                                 \
    ( IsListEmpty( MupTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 MupTebLockList( )->Flink,    \
                                                 MUP_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockLevel )

#define MupThreadLockName( )                                                  \
    ( IsListEmpty( MupTebLockList( ) ) ? "none" : CONTAINING_RECORD(          \
                                                 MupTebLockList( )->Flink,    \
                                                 MUP_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockName )

KSPIN_LOCK LockSpinLock = {0};
BOOLEAN LockSpinLockInitialized = FALSE;

#define MAX_LOCKS_HELD 15

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupInitializeLock )
#pragma alloc_text( PAGE, MupDeleteLock )
#pragma alloc_text( PAGE, MupReleaseLock )
#pragma alloc_text( PAGE, MupCheckListIntegrity )
#endif
#if 0
NOT PAGEABLE - MupAcquireLock
#endif

VOID
MupInitializeLock(
    IN PMUP_LOCK Lock,
    IN ULONG LockLevel,
    IN PSZ LockName
    )

/*++

Routine Description:

    This routine initializes the input lock variable.

Arguments:

    Lock - Supplies the lock variable being initialized

    LockLevel - Supplies the level of the lock

    LockName - Supplies the name of the lock

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( !LockSpinLockInitialized ) {
        LockSpinLockInitialized = TRUE;
        KeInitializeSpinLock( &LockSpinLock );
    }

    //
    // Initialize the executive resource.
    //

    ExInitializeResourceLite( &Lock->Resource );

    //
    // Initialize the lock level.  This is used to determine whether a
    // thread may acquire the lock.  Save the lock name.
    //

    LOCK_LEVEL( Lock ) = LockLevel;

    LOCK_NAME( Lock ) = LockName;

    return;

} // MupInitializeLock


VOID
MupDeleteLock (
    IN PMUP_LOCK Lock
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) a lock variable.

Arguments:

    Lock - Supplies the lock variable being deleted

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Make sure the lock is unowned.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) != 0 ) {

        DbgPrint( "MupDeleteLock: Thread %d\n", KeGetCurrentThread( ) );
        DbgPrint( "MupDeleteLock: Attempt to delete owned lock %s(%lx)",
            LOCK_NAME( Lock ),
            Lock
            );
        DbgBreakPoint();

    }

    //
    // Delete the resource.
    //

    ExDeleteResourceLite( &Lock->Resource );

    return;

} // MupDeleteLock


VOID
MupAcquireLock(
    IN PMUP_LOCK Lock
    )

/*++

Routine Description:

    The routine acquires a lock.

Arguments:

    Lock - Supplies the lock to acquire

Return Value:

    BOOLEAN - Indicates whether the lock was acquired.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;
    ULONG threadLockLevel;
    KIRQL oldIrql;

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = MupCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // If this thread does not have a nonpaged TEB, do not do lock-level
    // debugging.  (We might be at DPC level, so we can't take page
    // faults.)
    //

    if ( hasTeb ) {

        //
        // Make sure that this thread has been initialized for lock
        // debugging.  If not, initialize it.
        //

        KeAcquireSpinLock( &LockSpinLock, &oldIrql );
        if ( (ULONG)currentTeb->UserReserved[MUP_TEB_LOCK_INIT] !=
                                                        0xbabababa ) {
            PLIST_ENTRY tebLockList = MupTebLockList( );
            InitializeListHead( tebLockList );
            currentTeb->UserReserved[MUP_TEB_LOCK_INIT] = (PVOID)0xbabababa;
        }
        KeReleaseSpinLock( &LockSpinLock, oldIrql );

        //
        // Make sure that the list of locks in the TEB is consistent.
        //

        MupCheckListIntegrity( MupTebLockList( ), MAX_LOCKS_HELD );

        //
        // The "lock level" of this thread is the highest level of the
        // locks currently held exclusively.  If this thread holds no
        // locks, the lock level of the thread is 0 and it can acquire
        // any lock.
        //

        threadLockLevel = MupThreadLockLevel( );

        //
        // Make sure that the lock the thread is attempting to acquire
        // has a higher level than the last-acquired exclusive lock.
        // Note that a recursive exclusive acquisition of a lock should
        // succeed, even if a different, higher-level lock has been
        // acquired since the lock was originally acquired.  Shared
        // acquisition of a lock that is already held exclusively must
        // fail.
        //

        if ( LOCK_LEVEL( Lock ) <= threadLockLevel ) {

            DbgPrint( "Thread %lx, last lock %s(%lx, L%lx) attempted to ",
                        currentThread,
                        MupThreadLockName( ), MupThreadLockAddress( ),
                        threadLockLevel );
            DbgPrint( "acquire %s(%lx, L%lx) for %s access.\n",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        "exclusive" );
            DbgBreakPoint( );

        }

    }

    //
    // Acquire the lock.
    //

    ExAcquireResourceExclusiveLite( &Lock->Resource, TRUE );

    //
    // The thread acquired the lock for exlusive access.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == -1 ) {

        if ( hasTeb ) {

            //
            // Insert the lock on the thread's list of locks.
            //

            ExInterlockedInsertHeadList(
                MupTebLockList( ),
                LOCK_THREAD_LIST( Lock ),
                &LockSpinLock
                );

        }

    }

    return;

} // MupAcquireLock


VOID
MupReleaseLock(
    IN PMUP_LOCK Lock
    )

/*++

Routine Description:

    This routine releases a lock.

Arguments:

    Lock - Supplies the lock to release

Return Value:

    None.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;

    PAGED_CODE( );

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = MupCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // Make sure the lock is really owned by the current thread.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 0 ) {

        // !!! Should crash server on internal error here.

        DbgPrint( "Thread %lx releasing unowned lock %s(%lx)\n",
                    currentThread, LOCK_NAME( Lock ), Lock );
        DbgBreakPoint( );

    } else if ( (LOCK_NUMBER_OF_ACTIVE( Lock ) < 0) &&
                (LOCK_EXCLUSIVE_OWNER( Lock ) != (ULONG)currentThread) ) {

        // !!! Should crash server on internal error here.

        DbgPrint( "Thread %lx releasing lock %s(%lx) owned by "
                    "thread %lx\n",
                    currentThread, LOCK_NAME( Lock ), Lock,
                    LOCK_EXCLUSIVE_OWNER( Lock ) );
        DbgBreakPoint( );

    } else if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == -1 ) {

        //
        // The thread is fully releasing exclusive access to the lock.
        //

        if ( hasTeb ) {

            //
            // Remove the lock from the list of locks held by this
            // thread.
            //

            ExInterlockedRemoveHeadList(
                LOCK_THREAD_LIST( Lock )->Blink,
                &LockSpinLock
                );
            LOCK_THREAD_LIST( Lock )->Flink = NULL;
            LOCK_THREAD_LIST( Lock )->Blink = NULL;

            //
            // Make sure that the list of locks in the TEB is consistent.
            //

            MupCheckListIntegrity( MupTebLockList( ), MAX_LOCKS_HELD );

        }

    }

    //
    // Now actually do the release.
    //

    ExReleaseResourceLite( &Lock->Resource );

    return;

} // MupReleaseLock


ULONG
MupCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This debug routine checks the integrity of a doubly-linked list by
    walking the list forward and backward.  If the number of elements is
    different in either direction, or there are too many entries in the
    list, execution is stopped.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    MaxEntries - if the number of entries in the list exceeds this
        number, breakpoint.

Return Value:

    ULONG - the number of entries in the list.

--*/

{
    PLIST_ENTRY current;
    ULONG entriesSoFar;
    ULONG flinkEntries;

    for ( current = ListHead->Flink, entriesSoFar = 0;
          current != ListHead;
          current = current->Flink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            DbgPrint( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    flinkEntries = entriesSoFar;

    for ( current = ListHead->Blink, entriesSoFar = 0;
          current != ListHead;
          current = current->Blink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            DbgPrint( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    if ( flinkEntries != entriesSoFar ) {
        DbgPrint( "In list %lx, Flink entries: %ld, Blink entries: %lx\n",
                      ListHead, flinkEntries, entriesSoFar );
        DbgBreakPoint( );
    }

    return entriesSoFar;

} // MupCheckListIntegrity

#endif // MUPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\minfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   MInfo.C
//
//  Contents:
//
//  Functions:
//
//  History:
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE
#include "dfsprocs.h"
#endif

INIT_TADDRESS_MARSHAL_INFO()
INIT_DS_TRANSPORT_P_MARSHAL_INFO()
INIT_DS_TRANSPORT_MARSHAL_INFO()
INIT_DS_MACHINE_P_MARSHAL_INFO()
INIT_DS_MACHINE_MARSHAL_INFO()

INIT_DFS_MACHINE_ENTRY_MARSHAL_INFO()
INIT_DFS_SERVICE_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_ID_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_INFO_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_MARSHAL_INFO()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mup.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mup.h

Abstract:

    This module is the main include file for the MUP.
    It includes other header files.

Author:

    Manny Weiser (mannyw)    17-Dec-1991

Revision History:

--*/

#ifndef _MUP_
#define _MUP_

#include <dfsprocs.h>

//
// Local, independent include files
//

#include "debug.h"

//
// Local, dependent include files (order is important)
//

#include "lock.h"
#include "mupdata.h"
#include "mupstruc.h"
#include "mupfunc.h"
#include "mupwml.h"

#endif // def _MUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\lock.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    This module defines the data structures and function prototypes used
    for spin lock debugging.

Author:

    Manny Weiser (mannyw)    18-Jan-1992

Revision History:

--*/

#ifndef _LOCK_
#define _LOCK_

#if MUPDBG

#define MUP_TEB_LOCK_LIST 0

#define INITIALIZE_LOCK( lock, level, name ) \
                    MupInitializeLock( (lock), (level), (name) )
#define DELETE_LOCK( lock ) MupDeleteLock( lock )

#define ACQUIRE_LOCK(lock) MupAcquireLock( lock )
#define RELEASE_LOCK(lock) MupReleaseLock( lock )
#define LOCK_NAME( lock ) ((lock)->Header.LockName)
#define LOCK_LEVEL( lock ) ((lock)->Header.LockLevel)
#define LOCK_THREAD_LIST( lock ) (&((lock)->Header.ThreadListEntry))

#define LOCK_NUMBER_OF_ACTIVE( lock ) ((lock)->Resource.ActiveCount)
#define LOCK_EXCLUSIVE_OWNER( lock ) ((ULONG)(lock)->Resource.OwnerThreads[0].OwnerThread)

//
// MUP_LOCK_HEADER is a structure that contains debugging information
// used by the server lock package.  Mup spin locks contain a
// MUP_LOCK_HEADER.
//

typedef struct _MUP_LOCK_HEADER {

    //
    // To prevent deadlocks, locks are assigned level numbers.  If a
    // thread holds a lock with level N, it may only acquire new locks
    // with a level greater then N.  Level numbers are assigned during
    // lock initialization.
    //

    ULONG LockLevel;

    //
    // A doubly-linked list of all the locks owned by a thread is stored
    // in a thread's TEB.  The list is in order of lock level (from
    // highest to lowest), which is also, by definition of lock levels,
    // the order in which the thread acquired the locks.  This allows
    // the thread to release the locks in any order while maintaining
    // easy access to the highest-level lock that the thread owns,
    // thereby providing a mechanism for ensuring that locks are
    // acquired in increasing order.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // The symbolic name of the lock is used in DbgPrint calls.
    //

    PSZ LockName;

} MUP_LOCK_HEADER, *PMUP_LOCK_HEADER;

//
// When debugging is enabled, a server lock is a wrapper around an
// executive resource.
//

typedef struct _MUP_LOCK {

    //
    // The MUP_LOCK_HEADER must appear first!
    //

    MUP_LOCK_HEADER Header;

    //
    // The actual "lock" is maintained by the resource package.
    //

    ERESOURCE Resource;

} MUP_LOCK, *PMUP_LOCK;

VOID
MupInitializeLock(
    IN PMUP_LOCK Lock,
    IN ULONG Locklevel,
    IN PSZ LockName
    );

VOID
MupDeleteLock (
    IN PMUP_LOCK Lock
    );

VOID
MupAcquireLock(
    IN PMUP_LOCK Lock
    );

VOID
MupReleaseLock(
    IN PMUP_LOCK Lock
    );

ULONG
MupCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    );

//
// Macros that define locations in the UserReserved field of the TEB
// where lock level information is stored.
//

#define MUP_TEB_LOCK_LIST 0
#define MUP_TEB_LOCK_INIT 2
#define MUP_TEB_USER_SIZE (3 * sizeof(ULONG))

//
// Levels used for spin locks used in the MUP.  Locks can be acquired
// only in increasing lock level order.  Be careful when adding a new
// lock or when changing the order of lock levels.
//

#define GLOBAL_LOCK_LEVEL                       (ULONG)0x80000100
#define PREFIX_TABLE_LOCK_LEVEL                 (ULONG)0x80000200
#define CCB_LIST_LOCK_LEVEL                     (ULONG)0x80000300
#define QUERY_CONTEXT_LOCK_LEVEL                (ULONG)0x80000400
#define DEBUG_LOCK_LEVEL                        (ULONG)0x80000500

#else

#define INITIALIZE_LOCK( lock, level, name ) ExInitializeResourceLite( (lock) )
#define DELETE_LOCK( lock ) ExDeleteResourceLite( (lock) )
#define ACQUIRE_LOCK( lock ) \
                    ExAcquireResourceExclusiveLite( (lock), TRUE )
#define RELEASE_LOCK(lock) ExReleaseResourceLite( (lock) )

typedef ERESOURCE MUP_LOCK, *PMUP_LOCK;
#endif // MUPDBG

#endif // _LOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\logroot.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       logroot.c
//
//  Contents:   This module implements the logical root handling functions.
//
//  Functions:  DfsInitializeLogicalRoot -
//              DfsDeleteLogicalRoot -
//              DfspLogRootNameToPath -
//
//  History:    14-June-1994    SudK    Created (Most stuff moved from Dsinit.c)
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "creds.h"
#include "dnr.h"
#include "fcbsup.h"

#include <stdio.h>

#define Dbg     DEBUG_TRACE_LOGROOT

NTSTATUS
DfsDefineDosDevice(
    IN WCHAR Device,
    IN PUNICODE_STRING Target);

NTSTATUS
DfsUndefineDosDevice(
    IN WCHAR Device);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFindLogicalRoot )
#pragma alloc_text( PAGE, DfsInitializeLogicalRoot )
#pragma alloc_text( PAGE, DfsDeleteLogicalRoot )
#pragma alloc_text( PAGE, DfspLogRootNameToPath )
#pragma alloc_text( PAGE, DfsGetResourceFromVcb )
#pragma alloc_text( PAGE, DfsGetResourceFromDevlessRoot )
#pragma alloc_text( PAGE, DfsLogicalRootExists )

#endif

#ifdef TERMSRV

//
// Maximum character string length of a session Id (decimal)
//

#define SESSIONID_MAX_LEN 10

//
// Maximum characters string length of a session ID [10] (decimal) or
// logon ID [16] (hex, base 16)
//
#define ID_MAX_LEN 16

#endif // TERMSRV

//
// Global that denotes whether LUID device maps are enabled
//  TRUE  - LUID device maps are enabled
//  FALSE - LUID device maps are not enabled
//      Defined in nt\base\fs\mup\dfsinit.c
//
extern BOOL DfsLUIDDeviceMapsEnabled;


//+-------------------------------------------------------------------------
//
//  Function:   DfsFindLogicalRoot, local
//
//  Synopsis:   DfsFindLogicalRoot takes as input a DS path name in
//              the standard form (root:\file\path\name), looks up
//              the DFS_VCB associated with the logical root, and returns
//              a string pointing to beyond the logical root part
//              of the input string.
//
//  Arguments:  [PrefixPath] -- Input path name
//              [Vcb] -- Returns DFS_VCB which corresponds to logical root
//                      in PrefixPath
//              [RemainingPath] -- Returns with portion of PrefixPath
//                      after the logical root name and colon
//
//  Returns:    NTSTATUS:
//                      STATUS_SUCCESS if Vcb found
//                      STATUS_OBJECT_PATH_SYNTAX_BAD - no logical root name
//                      STATUS_NO_SUCH_DEVICE - logical root name not found
//
//--------------------------------------------------------------------------


#ifdef TERMSRV

NTSTATUS
DfsFindLogicalRoot(
    IN PUNICODE_STRING PrefixPath,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    )

#else // TERMSRV

NTSTATUS
DfsFindLogicalRoot(
    IN PUNICODE_STRING PrefixPath,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    )

#endif // TERMSRV
{
    PLIST_ENTRY Link;
    unsigned int i;
    NTSTATUS    Status = STATUS_SUCCESS;
    NETRESOURCE testnt;

    DfsDbgTrace(+1, Dbg, "DfsFindLogicalRoot...\n", 0);

    *RemainingPath = *PrefixPath;

    for (i = 0; i < RemainingPath->Length/sizeof(WCHAR); i++) {
        if ((RemainingPath->Buffer[i] == (WCHAR)':') ||
            (RemainingPath->Buffer[i] == UNICODE_PATH_SEP))
            break;
    }

    if ((i*sizeof(WCHAR) >= RemainingPath->Length) ||
        (RemainingPath->Buffer[i] == UNICODE_PATH_SEP)) {
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    RemainingPath->Length = (USHORT)(i * sizeof (WCHAR));

    //
    // Search for the logical root in all known DFS_VCBs
    //

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);
    for ( Link = DfsData.VcbQueue.Flink;
          Link != &DfsData.VcbQueue;
          Link = Link->Flink ) {

        *Vcb = CONTAINING_RECORD( Link, DFS_VCB, VcbLinks );

#ifdef TERMSRV
        if ((SessionID == INVALID_SESSIONID) ||
            (SessionID == (*Vcb)->SessionID)) {
#endif
	    if ( RtlEqualLuid(LogonID, &(*Vcb)->LogonID) ) {
		if (RtlEqualString( (PSTRING)&(*Vcb)->LogicalRoot,
				   (PSTRING)RemainingPath, (BOOLEAN)TRUE) ) {
		    break;
		}
	    }
#ifdef TERMSRV
        }
#endif // TERMSRV
    }
    if (Link == &DfsData.VcbQueue) {
        Status = STATUS_NO_SUCH_DEVICE;
        ExReleaseResourceLite(&DfsData.Resource);
        DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    //
    // Adjust remaining path to point beyond the logical root name
    //

    RemainingPath->Buffer = (WCHAR*)((char*) (RemainingPath->Buffer) +
                                     RemainingPath->Length + sizeof (WCHAR) );
    RemainingPath->Length = PrefixPath->Length -
                                    (RemainingPath->Length + sizeof (WCHAR));

    if (RemainingPath->Length <= 0 ||
        RemainingPath->Buffer[0] != UNICODE_PATH_SEP) {
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        ExReleaseResourceLite(&DfsData.Resource);
        DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    ExReleaseResourceLite(&DfsData.Resource);
    DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeLogicalRoot, public
//
//  Synopsis:   Allocate and initialize storage for a logical root.
//              This includes creating a device object and DFS_VCB for it.
//
//  Effects:    A logical root device object is created.  A corresponding
//              DFS_VCB is also created and linked into the list of known
//              DFS_VCBs.
//
//  Arguments:  [Name] --   name of logical root.
//              [Prefix] -- Prefix to be prepended to file names opened
//                          via the logical root being created before
//                          they can be resolved in the DFS name space.
//              [Credentials] -- The credentials to use when accessing files
//                          via this logical root.
//              [VcbFlags] -- To be OR'd into the VcbState field of the
//                          DFS_VCB of the newly created logical root device.
//
//  Requires:   DfsData must first be set up. Also an EXCLUSIVE LOCK on
//              DfsData.Resource must be acquired.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS unless there is some problem.
//
//  History:    25 Jan 1992 alanw   created
//
//--------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsInitializeLogicalRoot(
    IN LPCWSTR Name,
    IN PUNICODE_STRING  Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT VcbFlags,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

NTSTATUS
DfsInitializeLogicalRoot(
    IN LPCWSTR        Name,
    IN PUNICODE_STRING  Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT       VcbFlags,
    IN PLUID LogonID
    )


#endif // TERMSRV
{
    UNICODE_STRING UnicodeString = DfsData.LogRootDevName;
    UNICODE_STRING LogRootPrefix;
    UNICODE_STRING RootName, RemainingPath;
    UNICODE_STRING LogicalRoot;

#ifdef TERMSRV

    //
    // The SessionID suffix is :SessionID where SessionID is 10 digits max.
    //

    UNICODE_STRING DeviceString;
    WCHAR DeviceBuffer[MAX_LOGICAL_ROOT_LEN + ID_MAX_LEN + sizeof(WCHAR)];
    UNICODE_STRING IDString;
    WCHAR IDBuffer[ID_MAX_LEN + 1];   // +1 for UNICODE_NULL

#endif // TERMSRV

    WCHAR          *TmpBuf;
    PDFS_VCB       Vcb;
    WCHAR          RootBuffer[MAX_LOGICAL_ROOT_LEN];
    PDFS_PKT_ENTRY pktEntry = NULL;

    LPCWSTR pstr = Name;
    PWSTR pdst;
    PLOGICAL_ROOT_DEVICE_OBJECT DeviceObject = NULL;
    NTSTATUS Status;

    DfsDbgTrace(0, Dbg, "DfsInitializeLogicalRoot -> %ws\n", Name);
    DfsDbgTrace(0, Dbg, "DfsInitializeLogicalRoot -> %wZ\n", Prefix);

    //
    // First, see if a logical root by the given name already exists
    //

    ASSERT(ARGUMENT_PRESENT(Name));
    RootName.Buffer = RootBuffer;
    RootName.MaximumLength = sizeof(RootBuffer);
    Status = DfspLogRootNameToPath(Name, &RootName);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

#ifdef TERMSRV
    Status = DfsFindLogicalRoot(&RootName, SessionID, LogonID, &Vcb, &RemainingPath);
#else
    Status = DfsFindLogicalRoot(&RootName, &Vcb, LogonID, &RemainingPath);
#endif

    ASSERT(Status != STATUS_OBJECT_PATH_SYNTAX_BAD);
    if (Status != STATUS_NO_SUCH_DEVICE) {
        return(STATUS_OBJECT_NAME_COLLISION);
    }

#ifdef TERMSRV

    //
    // For multiuser,
    // If LUID device maps are enabled,
    // then we add the LogonID to the devicename - e.g.
    // net use f: to a DFS share for logon ID 0x000000000003a3f0 will create
    // a symbolic link with the following format:
    // \??\f: -> \Device\WinDfs\f:000000000003a3f0
    //
    // If LUID device maps are not enabled,
    // then we add the SessionID to the devicename - e.g.
    // net use f: to a DFS share for session ID 3 will create a symbolic link
    // \DosDevices\f::3 -> \device\WinDfs\f:3
    // In the VCB we store the SessionID for matching purposes.
    // Both the symbolic link and the object name shall contain the SessionID
    // in the name. However, in deviceObject->Vcb.LogicalRoot.Buffer, the
    // name does not contain the SessionID. To find a matching VCB, both the name
    // and SessionID must match.
    //

    DeviceString.Buffer = DeviceBuffer;
    DeviceString.MaximumLength = sizeof(DeviceBuffer);
    DeviceString.Length = 0;

    //
    // Build the UnicodeString without the SessionID or LogonID
    //

    RtlAppendUnicodeToString(&UnicodeString, (LPWSTR)Name);


    if( SessionID != INVALID_SESSIONID) {

        if( (DfsLUIDDeviceMapsEnabled == TRUE) &&
            (LogonID != NULL) &&
            (sizeof(*LogonID) == sizeof(LUID)) ) {
            //
            // Build the DeviceString with the LogonID
            //
            _snwprintf( IDBuffer,
                        sizeof(IDBuffer)/sizeof(WCHAR),
                        L"%08x%08x",
                        LogonID->HighPart,
                        LogonID->LowPart );

            IDBuffer[ID_MAX_LEN] = UNICODE_NULL;

            RtlInitUnicodeString( &IDString, IDBuffer );
        }
        else {
            //
            // Build the DeviceString with the SessionID
            //
            IDString.Buffer = IDBuffer;
            IDString.MaximumLength = sizeof(IDBuffer);
            IDString.Length = 0;

            RtlIntegerToUnicodeString(SessionID, 10, &IDString);
        }
        
        RtlCopyUnicodeString(&DeviceString, &DfsData.LogRootDevName);
        RtlAppendUnicodeToString(&DeviceString, (LPWSTR)Name);
        RtlAppendUnicodeToString(&DeviceString,L":");
        RtlAppendUnicodeStringToString(&DeviceString, &IDString);
        DeviceString.MaximumLength = DeviceString.Length;

        //
        // Next, try to setup the Dos Device link
        //

        if (Prefix) {
            Status = DfsDefineDosDevice( Name[0], &DeviceString );
            if (!NT_SUCCESS(Status)) {
                return( Status );
            }
        }
    }
    else {

        ASSERT( Prefix == FALSE );
    }

#else // TERMSRV

    //
    // DfsData.LogRootDevName is initialized to be L"\Device\WinDfs\"
    // Here, we tack on the name of the Logical root we are creating
    // to the above string, so that the string becomes, for example,
    // L"\Device\WinDfs\Root". Note that at this point, we are scribbling
    // into the buffer belonging to DfsData.LogRootDevName, but this
    // should be ok, since we are not changing the Length field of that
    // Unicode string! BTW, we need a string of this form to create the
    // device object.
    //

    pdst = &UnicodeString.Buffer[UnicodeString.Length/sizeof (WCHAR)];
    while (*pstr != UNICODE_NULL) {
        *pdst++ = *pstr++;
        UnicodeString.Length += sizeof (WCHAR);
    }

    //
    // Next, try to setup the Dos Device link
    //
    if (Prefix) {
        Status = DfsDefineDosDevice( Name[0], &UnicodeString );
        if (!NT_SUCCESS(Status)) {
            return( Status );
        }
    }

#endif // TERMSRV

    //
    // Before we initialize the Vcb, we need to allocate space for the
    // Prefix. PagedPool should be fine here. We need to reallocate because
    // we will store this permanently in the DFS_VCB.
    //

    LogRootPrefix.Buffer = NULL;

    if (Prefix && Prefix->Length > 0) {
        LogRootPrefix.Length = Prefix->Length;
        LogRootPrefix.MaximumLength = LogRootPrefix.Length + sizeof(WCHAR);
        LogRootPrefix.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    LogRootPrefix.MaximumLength,
                                    ' puM');

        if (LogRootPrefix.Buffer != NULL) {
            RtlMoveMemory(LogRootPrefix.Buffer,
                          Prefix->Buffer,
                          Prefix->MaximumLength);

            LogRootPrefix.Buffer[Prefix->Length/sizeof(WCHAR)] = UNICODE_NULL;

        } else {

            //
            // Couldn't allocate memory! Ok to return with error code, since
            // we haven't changed the state of the IO subsystem yet.
            //

            if (Prefix) {
                NTSTATUS DeleteStatus;

                DeleteStatus = DfsUndefineDosDevice( Name[0] );

                ASSERT(NT_SUCCESS(DeleteStatus));
            }

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        RtlInitUnicodeString(&LogRootPrefix, NULL);
    }

    //
    //  Save the logical root name for the DFS_VCB structure. Remember, above
    //  we had UnicodeString to be of the form L"\Device\WinDfs\org". Now,
    //  we copy UnicodeString, then adjust the buffer and length fields so that
    //  the Buffer points to the beginning of the L"org"; Then, we allocate
    //  space for LogicalRootBuffer, and copy the name to it!
    //

    LogicalRoot = UnicodeString;

    LogicalRoot.Buffer = &LogicalRoot.Buffer[ DfsData.LogRootDevName.Length/sizeof (WCHAR) ];
    LogicalRoot.Length -= DfsData.LogRootDevName.Length;
    LogicalRoot.MaximumLength -= DfsData.LogRootDevName.Length;

    //
    // Now dup the buffer that LogicalRoot uses
    //

    TmpBuf = ExAllocatePoolWithTag( PagedPool,
                                    LogicalRoot.Length,
                                    ' puM');

    if (TmpBuf == NULL) {

        //
        // Couldn't allocate memory! Ok to return with error code, since
        // we still haven't changed the state of the IO subsystem yet.
        //

        if (LogRootPrefix.Buffer != NULL) {

            ExFreePool(LogRootPrefix.Buffer);

        }

        if (Prefix) {
            NTSTATUS DeleteStatus;

            DeleteStatus = DfsUndefineDosDevice( Name[0] );

            ASSERT(NT_SUCCESS(DeleteStatus));
        }

        return(STATUS_INSUFFICIENT_RESOURCES);

    } else {

        RtlMoveMemory( TmpBuf,
                       LogicalRoot.Buffer,
                       LogicalRoot.Length );

        LogicalRoot.Buffer = TmpBuf;

    }

    //
    //  Create the device object for the logical root.
    //

#ifdef TERMSRV

    Status = IoCreateDevice( DfsData.DriverObject,
                 sizeof( LOGICAL_ROOT_DEVICE_OBJECT ) -
                    sizeof( DEVICE_OBJECT ),
                 (SessionID != INVALID_SESSIONID) ?
                    &DeviceString : &UnicodeString,
                 FILE_DEVICE_DFS,
                 FILE_REMOTE_DEVICE,
                 FALSE,
                 (PDEVICE_OBJECT *) &DeviceObject );

#else // TERMSRV

    Status = IoCreateDevice( DfsData.DriverObject,
                 sizeof( LOGICAL_ROOT_DEVICE_OBJECT ) -
                 sizeof( DEVICE_OBJECT ),
                 &UnicodeString,
                 FILE_DEVICE_DFS,
                 FILE_REMOTE_DEVICE,
                 FALSE,
                 (PDEVICE_OBJECT *) &DeviceObject );

#endif // TERMSRV

    if ( !NT_SUCCESS( Status ) ) {
        if (LogRootPrefix.Buffer) {
            ExFreePool(LogRootPrefix.Buffer);
            ExFreePool(LogicalRoot.Buffer);
        }
        if (Prefix) {
            NTSTATUS DeleteStatus;

            DeleteStatus = DfsUndefineDosDevice( Name[0] );

            ASSERT(NT_SUCCESS(DeleteStatus));
        }
        return Status;
    }

    //
    // Pin the pkt entry in the cache by incrementing the Usecount
    //

    if (LogRootPrefix.Buffer != NULL && LogRootPrefix.Length > 0) {

        UNICODE_STRING prefix = LogRootPrefix;
        USHORT i, j;

        //
        // We want to work with the \server\share part of the prefix only,
        // so count up to 3 backslashes, then stop.
        //

        for (i = j = 0; i < prefix.Length/sizeof(WCHAR) && j < 3; i++) {

            if (prefix.Buffer[i] == UNICODE_PATH_SEP) {

                j++;

            }

        }

        prefix.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

        pktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                            &prefix,
                                            &RemainingPath);

        if (pktEntry != NULL && RemainingPath.Length == 0) {

            InterlockedIncrement(&pktEntry->UseCount);

        }
	else {
	  pktEntry = NULL;
	}
    }

    DeviceObject->DeviceObject.StackSize = 5;

    DfsInitializeVcb ( NULL,
               &DeviceObject->Vcb,
               &LogRootPrefix,
               Credentials,
               (PDEVICE_OBJECT)DeviceObject );

    DeviceObject->Vcb.VcbState |= VcbFlags;

#ifdef TERMSRV
    DeviceObject->Vcb.SessionID = SessionID;
#endif
    DeviceObject->Vcb.pktEntry = pktEntry;

    RtlCopyLuid(&DeviceObject->Vcb.LogonID, LogonID);

    //
    // Above we preallocated the buffer we need here.  So just use it.
    //

    DeviceObject->Vcb.LogicalRoot = LogicalRoot;

    //
    //  This is not documented anywhere, but calling IoCreateDevice has set
    //  the DO_DEVICE_INITIALIZING flag in DeviceObject->Flags. Normally,
    //  device objects are created only at driver init time, and IoLoadDriver
    //  will clear this bit for all device objects created at init time.
    //  Since in Dfs, we need to create and delete devices on the fly (ie,
    //  via FsCtl), we need to manually clear this bit.
    //

    DeviceObject->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteLogicalRoot
//
//  Synopsis:   Removes a logical root if found and possible.
//
//  Arguments:  [Name] -- Name of the Logical Root
//              [fForce] -- Whether to Forcibly delete logical root inspite of
//                          open files.
//
//  Returns:    STATUS_SUCCESS -- If successfully deleted logical root
//
//              STATUS_NO_SUCH_DEVICE -- If there is no logical root to
//                      delete.
//
//              STATUS_DEVICE_BUSY -- If fForce is false and there are open
//                      files via this logical root.
//
//-----------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsDeleteLogicalRoot(
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN ULONG SessionID,
    IN PLUID LogonID
)

#else // TERMSRV

NTSTATUS
DfsDeleteLogicalRoot(
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN PLUID LogonID
)

#endif // TERMSRV
{
    UNICODE_STRING RootName;
    UNICODE_STRING RemainingPath;
    WCHAR          RootBuffer[MAX_LOGICAL_ROOT_LEN + 2];
    PDFS_PKT_ENTRY PktEntry;
    PDFS_VCB       Vcb;
    NTSTATUS       Status;
    PLOGICAL_ROOT_DEVICE_OBJECT DeviceObject;
    BOOLEAN        pktLocked;
    PDFS_PKT_ENTRY pktEntry;

    //
    // The 2 extra spots are for holding :\ to form a path out of a
    // root name; ie, to go from root to a root:\ form.
    //
    DfsDbgTrace(0, Dbg, "DfsDeleteLogicalRoot -> %ws\n", Name);
    DfsDbgTrace(0, Dbg, "DfsDeleteLogicalRoot -> %s\n", fForce ? "TRUE":"FALSE");


    //
    // First see if the logical root even exists.
    //

    ASSERT(ARGUMENT_PRESENT(Name));

    RootName.Buffer = RootBuffer;
    RootName.MaximumLength = sizeof(RootBuffer);

    Status = DfspLogRootNameToPath(Name, &RootName);

    if (!NT_SUCCESS(Status))
        return(Status);

    //
    // Acquire Pkt and DfsData, wait till we do so.
    //

    PktAcquireExclusive(TRUE, &pktLocked);

    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

#ifdef TERMSRV
    Status = DfsFindLogicalRoot(&RootName, SessionID, LogonID, &Vcb, &RemainingPath);
#else // TERMSRV
    Status = DfsFindLogicalRoot(&RootName, LogonID, &Vcb, &RemainingPath);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Check to see if there are open files via this volume.
    //

    if (!fForce &&
            ((Vcb->DirectAccessOpenCount != 0) ||
                (Vcb->OpenFileCount != 0))) {

        Status = STATUS_DEVICE_BUSY;

        goto Cleanup;

    }

    //
    // Delete the credentials used by this connection
    //

    if (Vcb->Credentials != NULL) {
       DfsDeleteCredentials( Vcb->Credentials );
    }

    //
    // Get rid of the Dos Device
    //

    DfsUndefineDosDevice( Name[0] );

    //
    // Dec ref count on pkt entry
    //
    if (Vcb->pktEntry != NULL) {
      InterlockedDecrement(&Vcb->pktEntry->UseCount);

      Vcb->pktEntry = NULL;
    }

    //
    // Now, get rid of the Device itself. This is a bit tricky, because there
    // might be files open on this device. So, we reference the device and
    // call ObMakeTemporaryObject. This causes the object to be removed from
    // the NT Object table, but, since atleast our reference is active,
    // prevents the object from being freed. Then, we insert this object into
    // our DeletedVcb list. The timer routine will periodically wake up and
    // see if all references to this device have been released, at which
    // point the device will be finally freed.
    //

    RemoveEntryList(&Vcb->VcbLinks);

    InsertTailList( &DfsData.DeletedVcbQueue, &Vcb->VcbLinks );

    DeviceObject = CONTAINING_RECORD( Vcb, LOGICAL_ROOT_DEVICE_OBJECT, Vcb);

    ObReferenceObjectByPointer( DeviceObject, 0, NULL, KernelMode );

    ObMakeTemporaryObject((PVOID) DeviceObject);

    DeviceObject->DeviceObject.Flags &= ~DO_DEVICE_HAS_NAME;

Cleanup:

    ExReleaseResourceLite(&DfsData.Resource);

    PktRelease();

    return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspLogRootNameToPath
//
//  Synopsis:   Amazingly enough, all it does it takes a PWSTR, copies it into
//              a Unicode string's buffer, and appends a \ to the tail of the
//              buffer, thus making a path out of a Logical root name.
//
//  Arguments:  [Name] --   Name of logical root, like L"org"
//              [RootName] --   Destination for L"org\\"
//
//  Returns:    STATUS_BUFFER_OVERFLOW, STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspLogRootNameToPath(
    IN  LPCWSTR Name,
    OUT PUNICODE_STRING RootName
)
{
    unsigned short i, nMaxNameLen;

    //
    // The two extra spots are required to append a ":\" after the root name.
    //
    nMaxNameLen = (RootName->MaximumLength/sizeof(WCHAR)) - 2;

    //
    // Copy the name
    //
    for (i = 0; Name[i] != UNICODE_NULL && i < nMaxNameLen; i++) {
        RootName->Buffer[i] = Name[i];
    }

    //
    // Make sure entire name was copied before we ran out of space
    //
    if (Name[i] != UNICODE_NULL) {
        //
        // Someone sent in a name bigger than allowed.
        //
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // Append the ":\" to form a path
    //
    RootName->Length = i * sizeof(WCHAR);
    return(RtlAppendUnicodeToString(RootName, L":\\"));
}

#define PackMem(buf, str, len, pulen) {                                 \
        ASSERT(*(pulen) >= (len));                                      \
        RtlMoveMemory((buf) + *(pulen) - (len), (str), (len));          \
        *(pulen) -= (len);                                              \
        }


//+----------------------------------------------------------------------------
//
//  Function:   DfsGetResourceFromVcb
//
//  Synopsis:   Given a DFS_VCB it constructs a NETRESOURCE struct into the buffer
//              passed in. At the same time it uses the end of the buffer to
//              fill in a string. If the buffer is insufficient in size the
//              required size is returned in "pulen". If everything succeeds
//              then the pulen arg is decremented to indicate remaining size
//              of buffer.
//
//  Arguments:  [Vcb] -- The source DFS_VCB
//              [ProviderName] -- Provider Name to stuff in the NETRESOURCE
//              [BufBegin] -- Start of actual buffer for computing offsets
//              [Buf] -- The NETRESOURCE structure to fill
//              [BufSize] -- On entry, size of buf. On return, contains
//                      remaining size of buf.
//
//  Returns:    [STATUS_SUCCESS] -- Operation completed successfully.
//              [STATUS_BUFFER_OVERFLOW] -- buf is not big enough.
//
//  Notes:      This routine fills in a NETRESOURCE structure starting at
//              Buf. The strings in the NETRESOURCE are filled in starting
//              from the *end* (ie, starting at Buf + *BufSize)
//
//-----------------------------------------------------------------------------


#if defined (_WIN64)
typedef struct  _DFS_NETRESOURCE32 {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    ULONG    lpLocalName;
    ULONG    lpRemoteName;
    ULONG    lpComment ;
    ULONG    lpProvider;
}DFS_NETRESOURCE32, *PDFS_NETRESOURCE32;

#endif

NTSTATUS
DfsGetResourceFromVcb(
    PIRP        pIrp,
    PDFS_VCB    Vcb,
    PUNICODE_STRING ProviderName,
    PUCHAR      BufBegin,
    PUCHAR      Buf,
    PULONG      BufSize,
    PULONG      pResourceSize

)
{
    LPNETRESOURCE netResource = (LPNETRESOURCE) Buf;
    ULONG               sizeRequired = 0, ResourceSize;
    WCHAR               localDrive[ 3 ];
    ULONG32    CommentOffset, ProviderOffset, LocalNameOffset, RemoteNameOffset;

#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      ResourceSize = sizeof(DFS_NETRESOURCE32);
    }
    else
#endif
    ResourceSize = sizeof(NETRESOURCE);

    *pResourceSize = ResourceSize;

    sizeRequired = ResourceSize +
                    ProviderName->Length +
                        sizeof(UNICODE_NULL) +
                            3 * sizeof(WCHAR) +     // lpLocalName D: etc.
                                sizeof(UNICODE_PATH_SEP) +
                                    Vcb->LogRootPrefix.Length +
                                        sizeof(UNICODE_NULL);

    if (*BufSize < sizeRequired) {
        *BufSize = sizeRequired;
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // Buffer is big enough, fill in the NETRESOURCE structure
    //

    Buf += ResourceSize;
    *BufSize -= ResourceSize;

    netResource->dwScope       = RESOURCE_CONNECTED;
    netResource->dwType        = RESOURCETYPE_DISK;
    netResource->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    netResource->dwUsage       = RESOURCEUSAGE_CONNECTABLE;

    CommentOffset = 0;
    //
    // Fill in the provider name
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, ProviderName->Buffer, ProviderName->Length, BufSize);
    ProviderOffset = (ULONG32)(Buf + *BufSize - BufBegin);

    //
    // Fill in the local name next
    //

    localDrive[0] = Vcb->LogicalRoot.Buffer[0];
    localDrive[1] = UNICODE_DRIVE_SEP;
    localDrive[2] = UNICODE_NULL;

    PackMem(Buf, localDrive, sizeof(localDrive), BufSize);
    LocalNameOffset =  (ULONG32)(Buf + *BufSize - BufBegin);

    //
    // Fill in the remote name last
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, Vcb->LogRootPrefix.Buffer, Vcb->LogRootPrefix.Length, BufSize);
    PackMem(Buf, UNICODE_PATH_SEP_STR, sizeof(UNICODE_PATH_SEP), BufSize);
    RemoteNameOffset = (ULONG32)(Buf + *BufSize - BufBegin);

#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      PDFS_NETRESOURCE32 pNetResource32 = (PDFS_NETRESOURCE32)netResource;

      pNetResource32->lpComment = CommentOffset;
      pNetResource32->lpProvider = ProviderOffset;
      pNetResource32->lpLocalName = LocalNameOffset;
      pNetResource32->lpRemoteName = RemoteNameOffset;
    }
    else {
#endif

      netResource->lpComment = (LPWSTR)UIntToPtr( CommentOffset );
      netResource->lpProvider = (LPWSTR)UIntToPtr( ProviderOffset );
      netResource->lpLocalName = (LPWSTR)UIntToPtr( LocalNameOffset );
      netResource->lpRemoteName = (LPWSTR)UIntToPtr( RemoteNameOffset );
#if defined (_WIN64)
    }
#endif

    return(STATUS_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetResourceFromDevlessRoot
//
//  Synopsis:   Builds a NETRESOURCE structure for a device-less connection.
//              The LPWSTR members of NETRESOURCE actually contain offsets
//              from the BufBegin parameter.
//
//  Arguments:  [Drt] -- The DevicelessRoot structure
//              [ProviderName] -- Provider Name to stuff in the NETRESOURCE
//              [BufBegin] -- Start of actual buffer for computing offsets
//              [Buf] -- The NETRESOURCE structure to fill
//              [BufSize] -- On entry, size of buf. On return, contains
//                      remaining size of buf.
//
//  Returns:    [STATUS_SUCCESS] -- Operation completed successfully.
//              [STATUS_BUFFER_OVERFLOW] -- buf is not big enough.
//
//  Notes:      This routine fills in a NETRESOURCE structure starting at
//              Buf. The strings in the NETRESOURCE are filled in starting
//              from the *end* (ie, starting at Buf + *BufSize)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetResourceFromDevlessRoot(
    PIRP        pIrp,
    PDFS_DEVLESS_ROOT pDrt,
    PUNICODE_STRING ProviderName,
    PUCHAR BufBegin,
    PUCHAR Buf,
    PULONG BufSize,
    PULONG pResourceSize)
{
    LPNETRESOURCE netResource = (LPNETRESOURCE) Buf;
    ULONG               sizeRequired = 0, ResourceSize;
    WCHAR               localDrive[ 3 ];
    ULONG32    CommentOffset, ProviderOffset, LocalNameOffset, RemoteNameOffset;
#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      ResourceSize = sizeof(DFS_NETRESOURCE32);
    }
    else
#endif
    ResourceSize = sizeof(NETRESOURCE);

    *pResourceSize = ResourceSize;

    sizeRequired = ResourceSize +
                    ProviderName->Length +
                        sizeof(UNICODE_NULL) +
                            2 * sizeof(UNICODE_PATH_SEP) +
				pDrt->DevlessPath.Length +
                                     sizeof(UNICODE_NULL);

    if (*BufSize < sizeRequired) {
        *BufSize = sizeRequired;
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // Buffer is big enough, fill in the NETRESOURCE structure
    //

    Buf += ResourceSize;
    *BufSize -= ResourceSize;

    netResource->dwScope       = RESOURCE_CONNECTED;
    netResource->dwType        = RESOURCETYPE_DISK;
    netResource->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    netResource->dwUsage       = RESOURCEUSAGE_CONNECTABLE;

    CommentOffset = 0;
    LocalNameOffset = 0;

    //
    // Fill in the provider name
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, ProviderName->Buffer, ProviderName->Length, BufSize);
    ProviderOffset = (ULONG32)(Buf + *BufSize - BufBegin);

    //
    // Fill in the remote name last
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, pDrt->DevlessPath.Buffer, pDrt->DevlessPath.Length, BufSize);

    PackMem(Buf, UNICODE_PATH_SEP_STR, sizeof(UNICODE_PATH_SEP), BufSize);

    RemoteNameOffset = (ULONG32)(Buf + *BufSize - BufBegin);

#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      PDFS_NETRESOURCE32 pNetResource32 = (PDFS_NETRESOURCE32)netResource;

      pNetResource32->lpComment = CommentOffset;
      pNetResource32->lpProvider = ProviderOffset;
      pNetResource32->lpLocalName = LocalNameOffset;
      pNetResource32->lpRemoteName = RemoteNameOffset;
    }
    else {
#endif

      netResource->lpComment = (LPWSTR)UIntToPtr( CommentOffset );
      netResource->lpProvider = (LPWSTR)UIntToPtr( ProviderOffset );
      netResource->lpLocalName = (LPWSTR)UIntToPtr( LocalNameOffset );
      netResource->lpRemoteName = (LPWSTR)UIntToPtr( RemoteNameOffset );
#if defined (_WIN64)
    }
#endif

    return(STATUS_SUCCESS);


}


#ifdef TERMSRV

BOOLEAN
DfsLogicalRootExists(
    IN PWSTR pwszName,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

BOOLEAN
DfsLogicalRootExists(
    IN PWSTR pwszName,
    IN PLUID LogonID
    )

#endif // TERMSRV
{

    UNICODE_STRING RootName;
    UNICODE_STRING RemainingPath;
    WCHAR      RootBuffer[MAX_LOGICAL_ROOT_LEN + 2];
    PDFS_VCB       Vcb;
    NTSTATUS       Status;

    ASSERT(ARGUMENT_PRESENT(pwszName));
    RootName.Buffer = RootBuffer;
    RootName.MaximumLength = sizeof(RootBuffer);

    Status = DfspLogRootNameToPath(pwszName, &RootName);
    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

#ifdef TERMSRV
    Status = DfsFindLogicalRoot(&RootName, SessionID, LogonID, &Vcb, &RemainingPath);
#else // TERMSRV
    Status = DfsFindLogicalRoot(&RootName, LogonId, &Vcb, &RemainingPath);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {

        //
        // If this asserts, we need to fix the code above that creates the
        // Logical Root name, or fix DfsFindLogicalRoot.
        //
        ASSERT(Status != STATUS_OBJECT_PATH_SYNTAX_BAD);
        return(FALSE);
    }
    else        {
        return(TRUE);
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDefineDosDevice
//
//  Synopsis:   Creates a dos device to a logical root
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDefineDosDevice(
    IN WCHAR Device,
    IN PUNICODE_STRING Target)
{
    NTSTATUS status;
    HANDLE device;
    OBJECT_ATTRIBUTES ob;
    UNICODE_STRING deviceName;
    WCHAR Buf[25];

    wcscpy(Buf, L"\\??\\X:");
    RtlInitUnicodeString( &deviceName, Buf);
    deviceName.Buffer[ deviceName.Length/sizeof(WCHAR) - 2] = Device;

    InitializeObjectAttributes(
        &ob,
        &deviceName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    status = ZwCreateSymbolicLinkObject(
                    &device,
                    SYMBOLIC_LINK_ALL_ACCESS,
                    &ob,
                    Target);

    if (NT_SUCCESS(status))
        ZwClose( device );

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsUndefineDosDevice
//
//  Synopsis:   Undefines a dos device
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsUndefineDosDevice(
    IN WCHAR Device
    )
{

    NTSTATUS status;
    HANDLE device;
    OBJECT_ATTRIBUTES ob;
    UNICODE_STRING deviceName;
    WCHAR Buf[25];

    wcscpy(Buf, L"\\??\\X:");
    RtlInitUnicodeString( &deviceName, Buf);
    deviceName.Buffer[ deviceName.Length/sizeof(WCHAR) - 2] = Device;

    InitializeObjectAttributes(
        &ob,
        &deviceName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    status = ZwOpenSymbolicLinkObject(
                &device,
                SYMBOLIC_LINK_QUERY | DELETE,
                &ob);

    if (NT_SUCCESS(status)) {

        status = ZwMakeTemporaryObject( device );

        ZwClose( device );

    }

    return( status );

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFindDevlessRoot, local
//
//  Synopsis:   DfsFindDevlessRoot takes as input a UNC name
//              looks up the DFS_DEVLESS_ROOT associated with the root,
//              and returns the DevlessRoot
//
//  Arguments:  [Path] -- Input path name
//              [Drt] -- Returns DFS_DEVLESS_ROOT which corresponds to
//                       the root for the Path
//
//  Returns:    NTSTATUS:
//                      STATUS_SUCCESS if Drt found
//                      STATUS_NO_SUCH_DEVICE - root name not found
//
//--------------------------------------------------------------------------


#ifdef TERMSRV

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Path,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt
    )

#else // TERMSRV

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Path,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt,
    )

#endif // TERMSRV
{
    PLIST_ENTRY Link;
    NTSTATUS    Status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsFindDevlessRoot...%wZ\n", Path);

    //
    // Search for the devless ROOT.
    //

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    for ( Link = DfsData.DrtQueue.Flink;
          Link != &DfsData.DrtQueue;
          Link = Link->Flink ) {

        *Drt = CONTAINING_RECORD( Link, DFS_DEVLESS_ROOT, DrtLinks );

#ifdef TERMSRV
        if ((SessionID == INVALID_SESSIONID) ||
            (SessionID == (*Drt)->SessionID)) {
#endif
	    if ( RtlEqualLuid(LogonID, &(*Drt)->LogonID) ) {
		if (RtlEqualString( (PSTRING)&(*Drt)->DevlessPath,
				   (PSTRING)Path, (BOOLEAN)TRUE) ) {
		    break;
		}
	    }
#ifdef TERMSRV
        }
#endif // TERMSRV
    }
    if (Link == &DfsData.DrtQueue) {
        Status = STATUS_NO_SUCH_DEVICE;
        ExReleaseResourceLite(&DfsData.Resource);
        DfsDbgTrace(-1, Dbg, "DfsFindDevlessRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    ExReleaseResourceLite(&DfsData.Resource);
    DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeDevlessRoot, public
//
//  Synopsis:   Allocate and initialize storage for a Deviceless root.
//
//  Effects:    A DFS_DEVLESS_ROOT structure is created.
//
//  Arguments:  [Name] -- Pathname that is the deviceless root.
//              [Credentials] -- The credentials to use when accessing files
//                          via this logical root.
//
//  Requires:   DfsData must first be set up. Also an EXCLUSIVE LOCK on
//              DfsData.Resource must be acquired.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS unless there is some problem.
//
//--------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsInitializeDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

NTSTATUS
DfsInitializeDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PLUID LogonID
    )

#endif // TERMSRV
{

    PDFS_DEVLESS_ROOT Drt;
    PDFS_PKT_ENTRY pktEntry = NULL;
    UNICODE_STRING DevlessRootName;
    NTSTATUS Status;

    DfsDbgTrace(0, Dbg, "DfsInitializeDevlessRoot -> %wZ\n", Name);

#ifdef TERMSRV
    Status = DfsFindDevlessRoot(Name, SessionID, LogonID, &Drt);
#else
    Status = DfsFindDevlessRoot(Name, LogonID, &Drt);
#endif

    if (Status != STATUS_NO_SUCH_DEVICE) {
        //
        // this means we found a device. In the devless Root case, this means 
        // we dont have to do any more work. Just return a success response.
        // However, we still have the credentials which the caller assumes
        // we will be using. Get rid of it here and return success.
        //
        DfsDeleteCredentials(Credentials);
        return(STATUS_SUCCESS);
    }

    Drt = ExAllocatePoolWithTag( PagedPool,
				sizeof(DFS_DEVLESS_ROOT),
				' puM');
    if (Drt == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Before we initialize the Drt, we need to allocate space for the
    // Prefix. PagedPool should be fine here. We need to reallocate because
    // we will store this permanently in the DFS_DEVLESS_ROOT.
    //

    DevlessRootName.Length = Name->Length;
    DevlessRootName.MaximumLength = DevlessRootName.Length + sizeof(WCHAR);
    DevlessRootName.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    DevlessRootName.MaximumLength,
                                    ' puM');

    if (DevlessRootName.Buffer != NULL) {
            RtlMoveMemory(DevlessRootName.Buffer,
                          Name->Buffer,
                          Name->MaximumLength);
	    
            DevlessRootName.Buffer[Name->Length/sizeof(WCHAR)] = UNICODE_NULL;
    } else {
      ExFreePool(Drt);
      return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Pin the pkt entry in the cache by incrementing the Usecount
    //

    if (DevlessRootName.Buffer != NULL && DevlessRootName.Length > 0) {

        UNICODE_STRING prefix = DevlessRootName;
        USHORT i, j;
        UNICODE_STRING RemainingPath;

        //
        // We want to work with the \server\share part of the prefix only,
        // so count up to 3 backslashes, then stop.
        //

        for (i = j = 0; i < prefix.Length/sizeof(WCHAR) && j < 3; i++) {
            if (prefix.Buffer[i] == UNICODE_PATH_SEP) {
                j++;
            }
        }

        prefix.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

        pktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                            &prefix,
                                            &RemainingPath);

        if (pktEntry != NULL && RemainingPath.Length == 0) {

            InterlockedIncrement(&pktEntry->UseCount);

        }
	else {
	  pktEntry = NULL;
	}

    }

    DfsInitializeDrt ( Drt,
		       &DevlessRootName,
		       Credentials);

#ifdef TERMSRV
    Drt->SessionID = SessionID;
#endif
    Drt->pktEntry = pktEntry;
    RtlCopyLuid(&Drt->LogonID, LogonID);

    return STATUS_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteDevlessRoot
//
//  Synopsis:   Removes a Devless root if found and possible.
//
//  Arguments:  [Name] -- Name of the Logical Root
//
//  Returns:    STATUS_SUCCESS -- If successfully deleted logical root
//
//              STATUS_NO_SUCH_DEVICE -- If there is no logical root to
//                      delete.
//
//
//-----------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsDeleteDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN ULONG SessionID,
    IN PLUID LogonID
)

#else // TERMSRV

NTSTATUS
DfsDeleteDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN PLUID LogonID
)

#endif // TERMSRV
{
    PDFS_PKT_ENTRY PktEntry;
    PDFS_DEVLESS_ROOT Drt;
    NTSTATUS       Status;
    BOOLEAN        pktLocked;
    PDFS_PKT_ENTRY pktEntry;

    DfsDbgTrace(0, Dbg, "DfsDeleteDevlessRoot -> %wZ\n", Name);

    //
    // Acquire Pkt and DfsData, wait till we do so.
    //

    PktAcquireExclusive(TRUE, &pktLocked);

    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

#ifdef TERMSRV
    Status = DfsFindDevlessRoot(Name, SessionID, LogonID, &Drt);
#else // TERMSRV
    Status = DfsFindDevlessRoot(Name, LogonID, &Drt);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Delete the credentials used by this connection
    //

    DfsDeleteCredentials( Drt->Credentials );

    if (Drt->pktEntry != NULL) {
         InterlockedDecrement(&Drt->pktEntry->UseCount);
 
	 Drt->pktEntry = NULL;
    }

    RemoveEntryList(&Drt->DrtLinks);

    if (Drt->DevlessPath.Buffer) {
	ExFreePool(Drt->DevlessPath.Buffer);
    }
    ExFreePool(Drt);

Cleanup:

    ExReleaseResourceLite(&DfsData.Resource);

    PktRelease();

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\log.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       log.h
//
//  Contents:   Module to log messages from the driver to the NT event logging
//		system.
//
//  Classes:
//
//  Functions:  LogWriteMessage()
//	
//  History:    3/30/93		Milans created
//		04/18/93	SudK	Changed this function entirely.
//
//-----------------------------------------------------------------------------

#ifndef _LOG_H_
#define _LOG_H_

#define EVENT_SUCCESSFUL_INIT	0
#define EVENT_RANDOM_ERROR	1

VOID LogWriteMessage(
	IN ULONG	UniqueErrorCode,
	IN NTSTATUS	NtStatusCode,
	IN ULONG	nStrings,
	IN PUNICODE_STRING pustrArg OPTIONAL);

#endif // _LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mupdata.c

Abstract:

    This module declares global MUP data.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

extern MUP_LOCK MupGlobalLock;
extern ERESOURCE MupVcbLock;
extern MUP_LOCK MupPrefixTableLock;
extern MUP_LOCK MupCcbListLock;
extern KSPIN_LOCK MupInterlock;
extern LIST_ENTRY MupProviderList;
extern LIST_ENTRY MupPrefixList;
extern LIST_ENTRY MupMasterQueryList;
extern ULONG MupProviderCount;
extern UNICODE_PREFIX_TABLE MupPrefixTable;
extern CCHAR MupStackSize;
extern LARGE_INTEGER MupKnownPrefixTimeout;
extern BOOLEAN MupOrderInitialized;
extern NTSTATUS MupOrderedErrorList[];
extern BOOLEAN MupEnableDfs;

#ifdef MUPDBG
extern MUP_LOCK MupDebugLock;
extern ULONG MupDebugTraceLevel;
extern ULONG MupDebugTraceIndent;
#endif

#define MAILSLOT_PREFIX        L"Mailslot"
#define KNOWN_PREFIX_TIMEOUT   15             // 15 minutes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\log.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       log.c
//
//  Contents:   Module to log messages from the driver to the NT event logging
//              system.
//
//  Classes:
//
//  Functions:  LogWriteMessage()
//
//  History:    3/30/93         Milans created
//              04/18/93        SudK    modified to use a MessageFile. and some
//                                      cleanup to the function below.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"

#define Dbg             DEBUG_TRACE_EVENTLOG


VOID LogpPutString(
    IN PUNICODE_STRING pustrString,
    IN OUT PCHAR *ppStringBuffer,
    IN OUT UCHAR *pcbBuffer);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, LogWriteMessage )
#pragma alloc_text( PAGE, LogpPutString )
#endif // ALLOC_PRAGMA



//+----------------------------------------------------------------------------
//
//  Function:   LogWriteMessage
//
//  Synopsis:   Logs a message to the NT event logging system.
//
//  Arguments:  [UniqueErrCode] -- The code that identifes the message.
//              [NtStatusCode] --  Status code from some error.
//              [nStrings]      -- Number of strings being passed in.
//              [pustrArg]      -- The Array of insertion strings.
//
//  Returns:    Nothing at all.
//
//  History:    04/18/93        SudK    Created.
//
//-----------------------------------------------------------------------------
VOID LogWriteMessage(
        IN ULONG        UniqueErrorCode,
        IN NTSTATUS     NtStatusCode,
        IN ULONG        nStrings,
        IN PUNICODE_STRING pustrArg OPTIONAL)
{
    PIO_ERROR_LOG_PACKET pErrorLog;
    UCHAR                cbSize;
    UCHAR                *pStringBuffer;
    ULONG                i;

    //
    // Compute the size of the Error Log Packet that we need to start with.
    //
    cbSize = sizeof(IO_ERROR_LOG_PACKET);

    for (i = 0; i < nStrings; i++)  {
        cbSize = (UCHAR)( cbSize + pustrArg[i].Length + sizeof(WCHAR));
    }

    if (cbSize > ERROR_LOG_MAXIMUM_SIZE) {
        cbSize = ERROR_LOG_MAXIMUM_SIZE;
    }

    pErrorLog = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                            DfsData.DriverObject,
                                            cbSize);
    if (!pErrorLog) {

        //
        // Well, I guess we won't be logging this one.
        //

        return;
    }

    //
    // Zero out all fields, then set the ones we want.
    //

    RtlZeroMemory((PVOID) pErrorLog, sizeof(IO_ERROR_LOG_PACKET));
    pErrorLog->FinalStatus = NtStatusCode;
    pErrorLog->ErrorCode = UniqueErrorCode;
    pErrorLog->NumberOfStrings = (USHORT) nStrings;

    pErrorLog->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    pStringBuffer = ((PCHAR) pErrorLog) + sizeof(IO_ERROR_LOG_PACKET);

    //
    // Copy the strings into the buffer, making sure we truncate if and when
    // we need to.
    //

    cbSize -= sizeof(IO_ERROR_LOG_PACKET);

    for (i = 0; i < nStrings; i++)  {
        LogpPutString(&pustrArg[i], &pStringBuffer, &cbSize);
    }

    //
    // And finally, write out the log
    //

    IoWriteErrorLogEntry(pErrorLog);

}


//+----------------------------------------------------------------------------
//
//  Function:   LogpPutString
//
//  Synopsis:   Copies a string into the buffer part of an IO_ERROR_LOG_PACKET.
//              Takes care of truncating if the whole string won't fit.
//
//  Arguments:  [pustrString] -- Pointer to unicode string to copy.
//              [ppStringBuffer] -- On input, pointer to beginning of buffer
//                               to copy to. On exit, will point one past the
//                               end of the copied string.
//              [pcbBuffer] -- On input, max size of buffer. On output,
//                               remaining size after string has been copied.
//
//  Returns:    Nothing
//
//  History:    04/18/93        SudK    Created.
//
//-----------------------------------------------------------------------------

VOID LogpPutString(
    IN PUNICODE_STRING pustrString,
    IN OUT PCHAR *ppStringBuffer,
    IN OUT UCHAR *pcbBuffer)
{
    ULONG       len;
    PWCHAR      pwch;

    if ((*pcbBuffer == 0) || (pustrString->Length == 0))        {
        return;
    }

    if ( *pcbBuffer >= (pustrString->Length + sizeof(WCHAR)) ) {
        RtlMoveMemory(*ppStringBuffer, pustrString->Buffer, pustrString->Length);
        (*pcbBuffer) -= pustrString->Length;
        (*ppStringBuffer) += pustrString->Length;

    } else {
        RtlMoveMemory(*ppStringBuffer, pustrString->Buffer, (*pcbBuffer)-sizeof(WCHAR));
        *pcbBuffer = sizeof(WCHAR);
        (*ppStringBuffer) += (*pcbBuffer - sizeof(WCHAR));
    }

    //
    // Null Terminate the String Now if necessary.
    //
    if (*((PWCHAR) *ppStringBuffer - 1) != L'\0')       {
        *((PWCHAR) *ppStringBuffer) = L'\0';
        *ppStringBuffer += sizeof(WCHAR);
        (*pcbBuffer) -= sizeof(WCHAR);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mupdata.c

Abstract:

    This module defines global MUP data.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

#include "mup.h"

//
// MupGlobalLock is used to protect everything that is not protected
// by its own lock.
//

MUP_LOCK MupGlobalLock = {0};

//
// MupVcbLock is used to protect access to the VCB itself.
//

ERESOURCE MupVcbLock = {0};

//
// MupPrefixTableLock is used to protect the prefix table.
//

MUP_LOCK MupPrefixTableLock = {0};

//
// MupCcbListLock is used to protect access to the CCB list for all FCBs
//

MUP_LOCK MupCcbListLock = {0};

//
// MupInterlock is used to protect access to block reference counts.
//

KSPIN_LOCK MupInterlock = {0};

//
// The global list of all providers.  This list is protected by
// MupGlobalLock.
//

LIST_ENTRY MupProviderList = {0};

//
// The list of Mup prefixes

LIST_ENTRY MupPrefixList = {0};

//
// The list of active queries

LIST_ENTRY MupMasterQueryList = {0};

//
// The number of registered providers.
//

ULONG MupProviderCount = 0;

//
// The prefix table save all known prefix blocks.  It is protected by
// MupPrefixTableLock.
//

UNICODE_PREFIX_TABLE MupPrefixTable = {0};

//
// The MUP IRP stack size.
//

CCHAR MupStackSize = 0;

//
// The MUP known prefix timeout.  This is currently set at compile time.
//

LARGE_INTEGER MupKnownPrefixTimeout = {0};

//
// Indicator to know if provider ordering information has been read from
// the registry.
//

BOOLEAN MupOrderInitialized = {0};

//
// When we need to ask several rdrs to do an operation, and they all fail,
//  we need to return a single error code.  MupOrderedErrorList is a list
//  of status codes, from least important to most important, to guide in
//  determining which error codes should be returned.  An error code
//  at a higher index will replace an error code at a lower index.  An error
//  code not in the list always wins.  This processing is in MupDereferenceMasterIoContext()
//
NTSTATUS MupOrderedErrorList[] = {
        STATUS_UNSUCCESSFUL,
        STATUS_INVALID_PARAMETER,
        STATUS_REDIRECTOR_NOT_STARTED,
        STATUS_BAD_NETWORK_NAME,
        STATUS_BAD_NETWORK_PATH,
        0
};

//
// This boolean indicates whether to enable the Dfs client or not.
//

BOOLEAN MupEnableDfs = FALSE;

#ifdef MUPDBG
MUP_LOCK MupDebugLock = {0};
ULONG MupDebugTraceLevel = 0;
ULONG MupDebugTraceIndent = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, MupInitializeData )
#pragma alloc_text( PAGE, MupUninitializeData )
#endif
NTSTATUS
MupInitializeData(
    )

/*++

Routine Description:

    This routine initialize the MUP global data.

Arguments:

    None

Return Value:

    NTSTATUS - The function value is the final status from the data
        initialization.

--*/

{
    PAGED_CODE();
    INITIALIZE_LOCK(
        &MupGlobalLock,
        GLOBAL_LOCK_LEVEL,
        "MupGlobalLock"
        );

    INITIALIZE_LOCK(
        &MupPrefixTableLock,
        PREFIX_TABLE_LOCK_LEVEL,
        "MupPrefixTableLock"
        );

    INITIALIZE_LOCK(
        &MupCcbListLock,
        CCB_LIST_LOCK_LEVEL,
        "MupCcbListLock"
        );

#ifdef MUPDBG
    INITIALIZE_LOCK(
        &MupDebugLock,
        DEBUG_LOCK_LEVEL,
        "MupDebugLock"
        );
#endif

    KeInitializeSpinLock( &MupInterlock );

    ExInitializeResourceLite( &MupVcbLock );

    MupProviderCount = 0;

    InitializeListHead( &MupProviderList );
    InitializeListHead( &MupPrefixList );   
    InitializeListHead( &MupMasterQueryList );
    RtlInitializeUnicodePrefix( &MupPrefixTable );


    MupStackSize = 3; // !!!

    //
    // Calculate the timeout in NT relative time.
    //

    MupKnownPrefixTimeout.QuadPart = UInt32x32To64(
                               KNOWN_PREFIX_TIMEOUT * 60,
                               10 * 1000 * 1000
                               );

    MupOrderInitialized = FALSE;

    return STATUS_SUCCESS;
}

VOID
MupUninitializeData(
    )
/*++

Routine Description:

    This routine uninitializes the MUP global data.

Arguments:

    None

Return Value:

    None

--*/
{
    DELETE_LOCK(
        &MupGlobalLock
        );

    DELETE_LOCK(
        &MupPrefixTableLock
        );

    DELETE_LOCK(
        &MupCcbListLock
        );

#ifdef MUPDBG
    DELETE_LOCK(
        &MupDebugLock
        );
#endif

    ExDeleteResourceLite( &MupVcbLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupwml.c ===
#include "mupwml.h"


WML_CONTROL_GUID_REG _MupDrv_ControlGuids[] = {
    { //fc4b0d39-e8be-4a83-a32f-c0c7c4f61ee4  Debug control guid
        0xfc4b0d39, 0xe8be, 0x4a83, 
            { 0xa3, 0x2f, 0xc0, 0xc7, 0xc4, 0xf6, 0x1e, 0xe4 },
            // 3 trace guids per control guid.
            { 
               {// f1ca510b-57a7-4f4b-ab4c-561cacca158d 
                   0xf1ca510b, 0x57a7, 0x4f4b,
                       { 0xab, 0x4c, 0x56, 0x1c, 0xac, 0xca, 0x15, 0x8d },
               },
               { // d5ade09c-c701-48c6-99ac-d95ff213a0a3
                   0xd5ade09c, 0xc701, 0x48c6,
                       { 0x99, 0xac, 0xd9, 0x5f, 0xf2, 0x13, 0xa0, 0xa3 },
               },
               { // 8a97d97c-30d0-454b-8109-5a9b9389f1b2
                   0x8a97d97c, 0x30d0, 0x454b,
                       { 0x81, 0x09, 0x5a, 0x9b, 0x93, 0x89, 0xf1, 0xb2 },
               }
            },
    },
    { //fc570986-5967-4641-a6f9-05291bce66c5  Perf  control guid
        0xfc570986, 0x5967, 0x4641, 
            { 0xa6, 0xf9, 0x05, 0x29, 0x1b, 0xce, 0x66, 0xc5 },
            // 3 traced guids per control guid
            {
               {// 2ef42982-ccf7-4880-87bf-bc835d09ab66
                   0x2ef42982, 0xccf7, 0x4880,
                       { 0x87, 0xbf, 0xbc, 0x83, 0x5d, 0x09, 0xab, 0x66 },
               },
               {// 99e51b5c-cffc-4a46-b940-0e395014b54a
                   0x99e51b5c, 0xcffc, 0x4a46,
                       { 0xb9, 0x40, 0x0e, 0x39, 0x50, 0x14, 0xb5, 0x4a },
               },
               {// acd929fb-ec34-4d8e-b068-4c11636f6e9d
                   0xacd929fb, 0xec34, 0x4d8e,
                       {0xb0, 0x68, 0x4c, 0x11, 0x63, 0x6f, 0x6e, 0x9d },
               }
            },
    },
    { //39a7b5e0-be85-47fc-b9f5-593a659abac1  Instr. control guid
        0x39a7b5e0, 0xbe85, 0x47fc, 
            { 0xb9, 0xf5, 0x59, 0x3a, 0x65, 0x9a, 0xba, 0xc1 },
            // 3 trace guids per control guid
            {
               {// 6a13aa9a-7330-4415-bb26-60c105a4c6ae
                   0x6a13aa9a, 0x7330, 0x4415, 
                       { 0xbb, 0x26, 0x60, 0xc1, 0x05, 0xa4, 0xc6, 0xae },
               },
               { // 2bb352a4-7261-42e6-9f40-b91c214ed59a
                   0x2bb352a4, 0x7261, 0x42e6,
                       { 0x9f, 0x40, 0xb9, 0x1c, 0x21, 0x4e, 0xd5, 0x9a },
               },
               {// 6dfa04f0-cf82-426e-ae9e-735f72faa11d
                   0x6dfa04f0, 0xcf82, 0x426e,
                       { 0xae, 0x9e, 0x73, 0x5f, 0x72, 0xfa, 0xa1, 0x1d },
               }
            },
    },
};



ULONG called = 0;

NTSTATUS
MupDrvWmiDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
{
    WML_TINY_INFO Info;
    NTSTATUS Status;
    UNICODE_STRING RegPath;

    called = 1;
    RtlInitUnicodeString (&RegPath, L"Mup");

    RtlZeroMemory (&Info, sizeof(Info));

    Info.ControlGuids = _MupDrv_ControlGuids;
    Info.GuidCount = sizeof(_MupDrv_ControlGuids) / sizeof(WML_CONTROL_GUID_REG);
    Info.DriverRegPath = &RegPath;
    
    Status = WmlTinySystemControl (&Info, pDeviceObject, pIrp);

    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mupstruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the MUP.

Author:

    Manny Weiser (mannyw)    16-Dec-1991

Revision History:

--*/

#ifndef _MUPSTRUC_
#define _MUPSTRUC_



typedef enum _BLOCK_TYPE {
    BlockTypeUndefined,
    BlockTypeVcb,
    BlockTypeUncProvider,
    BlockTypeKnownPrefix,
    BlockTypeFcb,
    BlockTypeCcb,
    BlockTypeMasterIoContext,
    BlockTypeIoContext,
    BlockTypeMasterQueryContext,
    BlockTypeQueryContext,
    BlockTypeBuffer
} BLOCK_TYPE;

typedef enum _BLOCK_STATE {
    BlockStateUnknown,
    BlockStateActive,
    BlockStateClosing
} BLOCK_STATE;

//
// A block header starts every block
//

typedef struct _BLOCK_HEADER {
    BLOCK_TYPE BlockType;
    BLOCK_STATE BlockState;
    ULONG ReferenceCount;
    ULONG BlockSize;
} BLOCK_HEADER, *PBLOCK_HEADER;

//
// The MUP volume control block.  This structure is used to track access
// the the MUP device object.
//

typedef struct _VCB {
    BLOCK_HEADER BlockHeader;

    //
    // The IO share access.
    //

    SHARE_ACCESS ShareAccess;

} VCB, *PVCB;

//
// The MUP Device Object is an I/O system device object.
//

typedef struct _MUP_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;
    VCB Vcb;

} MUP_DEVICE_OBJECT, *PMUP_DEVICE_OBJECT;


//
// A UNC provider.  A UNC provider block corresponds to a registered UNC
// provider device.
//

typedef struct _UNC_PROVIDER {

    BLOCK_HEADER BlockHeader;
    LIST_ENTRY ListEntry;

    //
    // The device name of the provider
    //

    UNICODE_STRING DeviceName;

    //
    // Our handle to the UNC device and the associated file and device objects
    //

    HANDLE Handle;

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

    //
    // The priority of the provider.
    //

    ULONG Priority;

    //
    // Indicate if the provider supports mailslots.
    //

    BOOLEAN MailslotsSupported;

    //
    // Indicate if the provider is currently registered or unregistered
    //

    BOOLEAN Registered;

} UNC_PROVIDER, *PUNC_PROVIDER;

//
// A known prefix.  A known prefix is a path prefix (like \\server\share)
// that is "owned" by a specific UNC provider.
//

typedef struct _KNOWN_PREFIX {

    BLOCK_HEADER BlockHeader;

    UNICODE_PREFIX_TABLE_ENTRY TableEntry;

    //
    // The prefix string
    //

    UNICODE_STRING Prefix;

    //
    // The time the prefix was last used.
    //

    LARGE_INTEGER LastUsedTime;

    //
    // A referenced pointer to the owning UNC Provider
    //

    PUNC_PROVIDER UncProvider;

    //
    // If TRUE the Prefix string was allocated separately to this block.
    //

    BOOLEAN PrefixStringAllocated;

    //
    // If TRUE the Prefix string has been inserted in the prefix table
    //

    BOOLEAN InTable;

    //
    // If Active, the entry either is in the table or had been inserted in the
    // table at some point.

    BOOLEAN Active;
    //
    // Links for the linked list of entries
    //

    LIST_ENTRY ListEntry;

} KNOWN_PREFIX, *PKNOWN_PREFIX;


//
// A File Control Block.  The FCB corresponds to an open broadcast file,
// i.e. a mailslot handle.  We don't store any information about the FCB,
// we let the various providers handle all of that.
//

typedef struct _FCB {

    BLOCK_HEADER BlockHeader;

    //
    // A pointer to the IO system's file object, that references this FCB.
    //

    PFILE_OBJECT FileObject;

    //
    // A list of CCBs for this FCB.   The list is protected by MupCcbListLock.
    //

    LIST_ENTRY CcbList;

} FCB, *PFCB;

//
// A CCB.  The CCB is the per provider version of the FCB, all provider
// specific information about an FCB is kept here.
//

typedef struct _CCB {

    BLOCK_HEADER BlockHeader;

    //
    // A referenced pointer to the FCB for this CCB.
    //

    PFCB Fcb;

    //
    // A list entry to keep this block on the FCB's CcbList.
    //

    LIST_ENTRY ListEntry;

    //
    // The file and device objects for this open file.
    //

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

} CCB, *PCCB;


//
// The master and slave forward i/o context blocks are used to track
// forward IRPs.  Each forwarded IRP is tracked by the
// Master Forwarded Io Context (which corresponds to our FCB) and a per
// provider Io Context (which corresponse to our CCB).
//
// Since the Forwarded Io Context is never referenced or dereferenced it
// doesn't get a block header.
//

typedef struct _MASTER_FORWARDED_IO_CONTEXT {

    BLOCK_HEADER BlockHeader;

    //
    // The original IRP (i.e. the one sent to the MUP) that is being handled.
    //

    PIRP OriginalIrp;

    //
    // The status that will be used to complete the Irp. If all the mailslot
    // writes fail (eg. a portable not in its docking station) then the status
    // from the last write will be returned. If one works then STATUS_SUCCESS.
    //
    //

    NTSTATUS SuccessStatus;
    NTSTATUS ErrorStatus;

    //
    // A referenced pointer to the FCB for this i/o.
    //

    PFCB Fcb;

} MASTER_FORWARDED_IO_CONTEXT, *PMASTER_FORWARDED_IO_CONTEXT;

typedef struct _FORWARDED_IO_CONTEXT {

    //
    // A referenced pointer to the CCB.
    //

    PCCB Ccb;

    //
    // A referenced pointer to the Master Context.
    //

    PMASTER_FORWARDED_IO_CONTEXT MasterContext;

    //
    //  These structures are used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;
    PDEVICE_OBJECT DeviceObject;
    PIRP pIrp;

} FORWARDED_IO_CONTEXT, *PFORWARDED_IO_CONTEXT;


//
// The master and slave query path context blocks are used to track
// create IRPs.  Each forwarded IRP is tracked by the
// Master query Path Context (which corresponds to our FCB) and a per
// provider query path (which corresponse to our CCB).
//
// Since the query path context is never referenced or dereferenced it
// doesn't get a block header.
//

typedef struct _MASTER_QUERY_PATH_CONTEXT {

    BLOCK_HEADER BlockHeader;

    //
    // A pointer to the original create IRP.
    //

    PIRP OriginalIrp;

    //
    // A pointer to the FileObject in the original create IRP.
    //

    PFILE_OBJECT FileObject;

    //
    // This is used to track the identity of the provider that will
    // receive the Create IRP.
    //

    PUNC_PROVIDER Provider;

    //
    // A lock to protect access to Provider
    //

    MUP_LOCK Lock;

    //
    // An unreferenced pointer to the newly allocated known prefix block.
    //

    PKNOWN_PREFIX KnownPrefix;

    //
    // The status code to be returned from this operation
    //
    NTSTATUS ErrorStatus;

    //
    // A list of QUERY_PATH_CONTEXTs outstadning for this MasterContext
    //
    LIST_ENTRY QueryList;

    //
    // The entry for this master context in the global list MupMasterQueryList
    //
    LIST_ENTRY MasterQueryList;

} MASTER_QUERY_PATH_CONTEXT, *PMASTER_QUERY_PATH_CONTEXT;

typedef struct _QUERY_PATH_CONTEXT {

    //
    // A referenced poitner to the master query path context block.
    //

    PMASTER_QUERY_PATH_CONTEXT MasterContext;

    //
    // A referenced pointer to the UNC provider we are querying.
    //

    PUNC_PROVIDER Provider;

    //
    // A pointer to the Device Io Control buffer we allocated to query
    // the above provider.
    //

    PVOID Buffer;

    //
    // The entry for this context in the MasterContext's QueryList
    //
    LIST_ENTRY QueryList;

    //
    // The IRP associated with this query context (i.e., the IRP sent to the UNC_PROVIDER)
    //
    PIRP QueryIrp;

} QUERY_PATH_CONTEXT, *PQUERY_PATH_CONTEXT;

#endif // _MUPSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mupinit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    multiple UNC provider file system.

Author:

    Manny Weiser (mannyw)    12-17-91

Revision History:

--*/

#include "mup.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MupUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
MuppIsDfsEnabled();

BOOLEAN
MupCheckNullSessionUsage();

BOOLEAN MupUseNullSessionForDfs = TRUE;

//
// Globals
//
PMUP_DEVICE_OBJECT mupDeviceObject;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, MuppIsDfsEnabled )
#pragma alloc_text( PAGE, MupUnload )
#endif

NTSTATUS MupDrvWmiDispatch(PDEVICE_OBJECT p, PIRP i);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the mup file system
    device driver.  This routine creates the device object for the mup
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();
    //
    // Initialize MUP global data.
    //

    MupInitializeData();

    //
    // Initialize the Dfs client
    //

    MupEnableDfs = MuppIsDfsEnabled();


    if (MupEnableDfs) {
        status = DfsDriverEntry( DriverObject, RegistryPath );
        if (!NT_SUCCESS( status )) {
            MupEnableDfs = FALSE;
        }
    }

    //
    // Create the MUP device object.
    //

    RtlInitUnicodeString( &nameString, DD_MUP_DEVICE_NAME );
    status = IoCreateDevice( DriverObject,
                             sizeof(MUP_DEVICE_OBJECT)-sizeof(DEVICE_OBJECT),
                             &nameString,
                             FILE_DEVICE_MULTI_UNC_PROVIDER,
                             0,
                             FALSE,
                             &deviceObject );

    if (!NT_SUCCESS( status )) {
        if (MupEnableDfs) {
            DfsUnload (DriverObject);
        }
        MupUninitializeData();
        return status;

    }
    DriverObject->DriverUnload = MupUnload;

    //
    // Initialize the driver object with this driver's entry points.
    //
    // 2/27/96 MilanS - Be careful with these. If you add to this list
    // of dispatch routines, you'll need to make appropriate calls to the
    // corresponding Dfs fsd routine.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
        (PDRIVER_DISPATCH)MupCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE] =
        (PDRIVER_DISPATCH)MupCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] =
        (PDRIVER_DISPATCH)MupCreate;

    DriverObject->MajorFunction[IRP_MJ_WRITE] =
        (PDRIVER_DISPATCH)MupForwardIoRequest;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] =
        (PDRIVER_DISPATCH)MupFsControl;

    DriverObject->MajorFunction[IRP_MJ_CLEANUP] =
        (PDRIVER_DISPATCH)MupCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =
        (PDRIVER_DISPATCH)MupClose;

    //
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = 
                                         (PDRIVER_DISPATCH) MupDrvWmiDispatch;



    status = IoWMIRegistrationControl (deviceObject, WMIREG_ACTION_REGISTER);
    // Initialize the VCB
    //

    mupDeviceObject = (PMUP_DEVICE_OBJECT)deviceObject;
    MupInitializeVcb( &mupDeviceObject->Vcb );

    //
    // Return to the caller.
    //
    return( STATUS_SUCCESS );
}

VOID
MupUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This is the unload routine for the mup driver

Arguments:

    DriverObject - Mups driver object 

Return Value:

    None

--*/
{
    IoDeleteDevice (&mupDeviceObject->DeviceObject);
    if (MupEnableDfs) {
        DfsUnload (DriverObject);
    }
    MupUninitializeData();
}


BOOLEAN
MuppIsDfsEnabled()

/*++

Routine Description:

    This routine checks a registry key to see if the Dfs client is enabled.
    The client is assumed to be enabled by default, and disabled only if there
    is a registry value indicating that it should be disabled.

Arguments:

    None

Return Value:

    TRUE if Dfs client is enabled, FALSE otherwise.

--*/

{
    NTSTATUS status;
    HANDLE mupRegHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG valueSize;
    BOOLEAN dfsEnabled = TRUE;

#define MUP_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Mup"
#define DISABLE_DFS_VALUE_NAME  L"DisableDfs"

    UNICODE_STRING mupRegKey = {
        sizeof(MUP_KEY) - sizeof(WCHAR),
        sizeof(MUP_KEY),
        MUP_KEY};

    UNICODE_STRING disableDfs = {
        sizeof(DISABLE_DFS_VALUE_NAME) - sizeof(WCHAR),
        sizeof(DISABLE_DFS_VALUE_NAME),
        DISABLE_DFS_VALUE_NAME};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } disableDfsValue;


    InitializeObjectAttributes(
        &objectAttributes,
        &mupRegKey,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL
        );

    status = ZwOpenKey(&mupRegHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        status = ZwQueryValueKey(
                    mupRegHandle,
                    &disableDfs,
                    KeyValuePartialInformation,
                    (PVOID) &disableDfsValue,
                    sizeof(disableDfsValue),
                    &valueSize);

        if (NT_SUCCESS(status) && disableDfsValue.Info.Type == REG_DWORD) {

            if ( (*((PULONG) disableDfsValue.Info.Data)) == 1 )
                dfsEnabled = FALSE;

        }

        ZwClose( mupRegHandle );

    }

    return( dfsEnabled );

}


BOOLEAN
MupCheckNullSessionUsage()
{
    NTSTATUS status;
    HANDLE mupRegHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG valueSize;
    BOOLEAN NullSessionEnabled = FALSE;

#define MUP_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Mup"
#define DFS_NULL_SESSION_VALUE_NAME  L"DfsUseNullSession"

    UNICODE_STRING mupRegKey = {
        sizeof(MUP_KEY) - sizeof(WCHAR),
        sizeof(MUP_KEY),
        MUP_KEY};

    UNICODE_STRING UseNullSession = {
        sizeof(DFS_NULL_SESSION_VALUE_NAME) - sizeof(WCHAR),
        sizeof(DFS_NULL_SESSION_VALUE_NAME),
        DFS_NULL_SESSION_VALUE_NAME};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } DfsUseNullSessionValue;


    InitializeObjectAttributes(
        &objectAttributes,
        &mupRegKey,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL
        );

    status = ZwOpenKey(&mupRegHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        status = ZwQueryValueKey(
                    mupRegHandle,
                    &UseNullSession,
                    KeyValuePartialInformation,
                    (PVOID) &DfsUseNullSessionValue,
                    sizeof(DfsUseNullSessionValue),
                    &valueSize);

        if (NT_SUCCESS(status) && DfsUseNullSessionValue.Info.Type == REG_DWORD) {

            if ( (*((PULONG) DfsUseNullSessionValue.Info.Data)) == 1 )
                NullSessionEnabled = TRUE;
        }

        ZwClose( mupRegHandle );

    }

    return( NullSessionEnabled );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupwml.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mupwml.h

Abstract:

    This file defines macro for use by the mup driver

Author:

    udayh

Revision History:

--*/

#ifndef __MUP_MUPWML_H__
#define __MUP_MUPWML_H__
#include <dfsprocs.h>
#define _NTDDK_
#include "wmlkm.h"
#include "wmlmacro.h"
// Streams 

#define _MUP_TRACE_STREAM               0x00
#define _MUP_PERF_STREAM                0x01
#define _MUP_INSTR_STREAM               0x02

#define _MUP_ENABLE_0                   0x0000
#define _MUP_ENABLE_DEFAULT             0x0001
#define _MUP_ENABLE_TRACE_IRP           0x0004
#define _MUP_ENABLE_FILEIO              0x0002
#define _MUP_ENABLE_FILEINFO            0x0008
#define _MUP_ENABLE_SURROGATE           0x0010
#define _MUP_ENABLE_PKT                 0x0020
#define _MUP_ENABLE_KNOWN_PREFIX        0x0040
#define _MUP_ENABLE_DNR                 0x0080
#define _MUP_ENABLE_UNUSED6             0x0100
#define _MUP_ENABLE_UNUSED5             0x0200
#define _MUP_ENABLE_UNUSED4             0x0400
#define _MUP_ENABLE_UNUSED3             0x0800
#define _MUP_ENABLE_UNUSED2             0x1000
#define _MUP_ENABLE_ALL_ERROR           0x2000
#define _MUP_ENABLE_ERROR               0x4000
#define _MUP_ENABLE_MONITOR             0x8000


#define _MUP_LEVEL_HIGH                    0x1
#define _MUP_LEVEL_NORM                    0x2
#define _MUP_LEVEL_LOW                     0x4



#define MUP_LOG_STREAM(_stream)   _MUP_ ## _stream ## _STREAM
#define MUP_LOG_FLAGS(_flag)      _MUP_ENABLE_ ## _flag
#define MUP_LOG_LEVEL(_level)     _MUP_LEVEL_ ## _level

#define MUP_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(_MupDrv, MUP_LOG_STREAM(_why), MUP_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,
#define MUP_TRACE_HIGH(_flag, _type, _arg)              \
            MUP_LOG(TRACE, HIGH, MUP_LOG_FLAGS(_flag), _type, _arg)
#define MUP_TRACE_NORM(_flag, _type, _arg)              \
            MUP_LOG(TRACE, NORM, MUP_LOG_FLAGS(_flag), _type, _arg)
#define MUP_TRACE_LOW(_flag, _type, _arg)               \
            MUP_LOG(TRACE, LOW, MUP_LOG_FLAGS(_flag), _type, _arg)

#define MUP_TRACE_ERROR(_status, _flag, _type, _arg)    \
            MUP_LOG(TRACE, NORM, (MUP_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : MUP_LOG_FLAGS(ERROR))), _type, _arg)

#define MUP_TRACE_ERROR_HIGH(_status, _flag, _type, _arg)    \
            MUP_LOG(TRACE, HIGH, (MUP_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : MUP_LOG_FLAGS(ERROR))), _type, _arg)

#define MUP_TRACE_ERROR_LOW(_status, _flag, _type, _arg)    \
            MUP_LOG(TRACE, LOW, (MUP_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : MUP_LOG_FLAGS(ERROR))), _type, _arg)


#define MUP_PERF(_flag, _type, _arg)                    \
            MUP_LOG (PERF, HIGH, MUP_LOG_FLAGS(_flag), _type, _arg)
#define MUP_INSTR(_flag, _type, _arg)                   \
            MUP_LOG (INSTR, HIGH, MUP_LOG_FLAGS(_flag), _type, _arg)

#if 0
#define MUP_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, MUP_LOG_STREAM(_why), MUP_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define MUP_DBG_PRINT(_flag, _fmtstr, _arg)             \
            MUP_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define MUP_ERR_PRINT (_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                MUP_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }

#endif

// from the WPP generated .h file
// We use different macros, so need to do some cut and paste
// Hopefully this will get automated in the future.

#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )

#  define MSG_ID_BroadcastOpen_Error1	 WPP_DEFINE_MSG_ID(0,47)
#  define MSG_ID_BroadcastOpen_Error2	 WPP_DEFINE_MSG_ID(0,48)
#  define MSG_ID_BroadcastOpen_Error3	 WPP_DEFINE_MSG_ID(0,50)
#  define MSG_ID_BroadcastOpen_Error_IoCreateFile	 WPP_DEFINE_MSG_ID(0,49)
#  define MSG_ID_BroadcastOpen_Error_ObReferenceObjectByHandle	 WPP_DEFINE_MSG_ID(0,51)
#  define MSG_ID_CreateRedirectedFile_Before_IoCallDriver	 WPP_DEFINE_MSG_ID(0,39)
#  define MSG_ID_CreateRedirectedFile_Entry	 WPP_DEFINE_MSG_ID(0,35)
#  define MSG_ID_CreateRedirectedFile_Error_EmptyFilename	 WPP_DEFINE_MSG_ID(0,36)
#  define MSG_ID_CreateRedirectedFile_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,40)
#  define MSG_ID_CreateRedirectedFile_Error_MupRerouteOpen	 WPP_DEFINE_MSG_ID(0,37)
#  define MSG_ID_CreateRedirectedFile_Exit	 WPP_DEFINE_MSG_ID(0,41)
#  define MSG_ID_CreateRedirectedFile_Exit_Mailslot	 WPP_DEFINE_MSG_ID(0,38)
#  define MSG_ID_DfsCommonCreate_Error_NullVcb	 WPP_DEFINE_MSG_ID(0,61)
#  define MSG_ID_DfsCommonCreate_Error_PagingFileNotAllowed	 WPP_DEFINE_MSG_ID(0,60)
#  define MSG_ID_DfsCommonFileSystemControl_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,87)
#  define MSG_ID_DfsCommonQueryVolumeInformation_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,117)
#  define MSG_ID_DfsCommonSetInformation_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,84)
#  define MSG_ID_DfsComposeFullName_Error1	 WPP_DEFINE_MSG_ID(0,67)
#  define MSG_ID_DfsCreateConnection_Error_ZwCreateFile	 WPP_DEFINE_MSG_ID(0,83)
#  define MSG_ID_DfsFilePassThrough_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,15)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_DfsRootNameHasZeroLength	 WPP_DEFINE_MSG_ID(0,92)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_DfspIsSpecialShare_FALSE	 WPP_DEFINE_MSG_ID(0,94)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_DidNotFindSecondBackSlash	 WPP_DEFINE_MSG_ID(0,91)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_PathDoesNotBeginWithBackSlash	 WPP_DEFINE_MSG_ID(0,90)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_ShareNameHasZeroLength	 WPP_DEFINE_MSG_ID(0,93)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Exit_NotADfsPath	 WPP_DEFINE_MSG_ID(0,95)
#  define MSG_ID_DfsFsdCleanup_Entry	 WPP_DEFINE_MSG_ID(0,56)
#  define MSG_ID_DfsFsdCleanup_Exit	 WPP_DEFINE_MSG_ID(0,57)
#  define MSG_ID_DfsFsdClose_Entry	 WPP_DEFINE_MSG_ID(0,54)
#  define MSG_ID_DfsFsdClose_Exit	 WPP_DEFINE_MSG_ID(0,55)
#  define MSG_ID_DfsFsdCreate_Entry	 WPP_DEFINE_MSG_ID(0,58)
#  define MSG_ID_DfsFsdCreate_Exit	 WPP_DEFINE_MSG_ID(0,59)
#  define MSG_ID_DfsOpenDevice_Error_BadDisposition	 WPP_DEFINE_MSG_ID(0,62)
#  define MSG_ID_DfsOpenDevice_Error_CannotOpenAsDirectory	 WPP_DEFINE_MSG_ID(0,63)
#  define MSG_ID_DfsOpenDevice_Error_FileInUse	 WPP_DEFINE_MSG_ID(0,64)
#  define MSG_ID_DfsOpenDevice_Error_IoCheckShareAccess	 WPP_DEFINE_MSG_ID(0,65)
#  define MSG_ID_DfsOplockRequest_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,89)
#  define MSG_ID_DfsPassThroughRelativeOpen_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,66)
#  define MSG_ID_DfsRerouteOpenToMup_Error_NameTooLong	 WPP_DEFINE_MSG_ID(0,68)
#  define MSG_ID_DfsUserFsctl_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,88)
#  define MSG_ID_DfsVolumePassThrough_Entry	 WPP_DEFINE_MSG_ID(0,10)
#  define MSG_ID_DfsVolumePassThrough_Error1	 WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_DfsVolumePassThrough_Error2	 WPP_DEFINE_MSG_ID(0,13)
#  define MSG_ID_DfsVolumePassThrough_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_DfsVolumePassThrough_Exit	 WPP_DEFINE_MSG_ID(0,14)
#  define MSG_ID_DnrGetAuthenticatedConnection_Error_ObReferenceObjectByHandle	 WPP_DEFINE_MSG_ID(0,82)
#  define MSG_ID_DnrGetAuthenticatedConnection_Error_ZwCreateFile	 WPP_DEFINE_MSG_ID(0,81)
#  define MSG_ID_DnrNameResolve_Error3	 WPP_DEFINE_MSG_ID(0,75)
#  define MSG_ID_DnrNameResolve_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,77)
#  define MSG_ID_DnrNameResolve_Error_ObReferenceObjectByHandle	 WPP_DEFINE_MSG_ID(0,76)
#  define MSG_ID_DnrNameResolve_Error_SeImpersonateClientEx	 WPP_DEFINE_MSG_ID(0,73)
#  define MSG_ID_DnrNameResolve_TopOfLoop	 WPP_DEFINE_MSG_ID(0,74)
#  define MSG_ID_DnrRedirectFileOpen_BeforeIoCallDriver	 WPP_DEFINE_MSG_ID(0,79)
#  define MSG_ID_DnrRedirectFileOpen_Entry	 WPP_DEFINE_MSG_ID(0,78)
#  define MSG_ID_DnrRedirectFileOpen_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,80)
#  define MSG_ID_DnrStartNameResolution_Entry	 WPP_DEFINE_MSG_ID(0,69)
#  define MSG_ID_DnrStartNameResolution_Error2	 WPP_DEFINE_MSG_ID(0,71)
#  define MSG_ID_DnrStartNameResolution_Error_NameTooLong	 WPP_DEFINE_MSG_ID(0,70)
#  define MSG_ID_DnrStartNameResolution_Error_SeCreateClientSecurity	 WPP_DEFINE_MSG_ID(0,72)
#  define MSG_ID_MupCleanup_Entry	 WPP_DEFINE_MSG_ID(0,18)
#  define MSG_ID_MupCleanup_Error1	 WPP_DEFINE_MSG_ID(0,20)
#  define MSG_ID_MupCleanup_Error_FileClosed	 WPP_DEFINE_MSG_ID(0,19)
#  define MSG_ID_MupCleanup_Exit	 WPP_DEFINE_MSG_ID(0,21)
#  define MSG_ID_MupClose_Entry	 WPP_DEFINE_MSG_ID(0,22)
#  define MSG_ID_MupClose_Error1	 WPP_DEFINE_MSG_ID(0,23)
#  define MSG_ID_MupClose_Error2	 WPP_DEFINE_MSG_ID(0,24)
#  define MSG_ID_MupClose_Exit	 WPP_DEFINE_MSG_ID(0,25)
#  define MSG_ID_MupCreate_Entry	 WPP_DEFINE_MSG_ID(0,27)
#  define MSG_ID_MupCreate_Error_CreateRedirectedFile	 WPP_DEFINE_MSG_ID(0,30)
#  define MSG_ID_MupCreate_Error_DfsFsdCreate	 WPP_DEFINE_MSG_ID(0,28)
#  define MSG_ID_MupCreate_Error_OpenMupFileSystem	 WPP_DEFINE_MSG_ID(0,29)
#  define MSG_ID_MupCreate_Exit	 WPP_DEFINE_MSG_ID(0,31)
#  define MSG_ID_MupDereferenceMasterQueryContext_CompleteRequest	 WPP_DEFINE_MSG_ID(0,17)
#  define MSG_ID_MupDereferenceMasterQueryContext_RerouteOpen	 WPP_DEFINE_MSG_ID(0,16)
#  define MSG_ID_MupFsControl_Entry	 WPP_DEFINE_MSG_ID(0,85)
#  define MSG_ID_MupFsControl_Exit	 WPP_DEFINE_MSG_ID(0,86)
#  define MSG_ID_MupRemoveKnownPrefixEntry	 WPP_DEFINE_MSG_ID(0,53)
#  define MSG_ID_MupRerouteOpenToDfs_Entry	 WPP_DEFINE_MSG_ID(0,44)
#  define MSG_ID_MupRerouteOpenToDfs_Error1	 WPP_DEFINE_MSG_ID(0,45)
#  define MSG_ID_MupRerouteOpenToDfs_Error2	 WPP_DEFINE_MSG_ID(0,46)
#  define MSG_ID_MupRerouteOpen_Error1	 WPP_DEFINE_MSG_ID(0,42)
#  define MSG_ID_MupRerouteOpen_Error2	 WPP_DEFINE_MSG_ID(0,43)
#  define MSG_ID_OpenMupFileSystem_Entry	 WPP_DEFINE_MSG_ID(0,32)
#  define MSG_ID_OpenMupFileSystem_Error_IoCheckShareAccess	 WPP_DEFINE_MSG_ID(0,33)
#  define MSG_ID_OpenMupFileSystem_Exit	 WPP_DEFINE_MSG_ID(0,34)
#  define MSG_ID_PktPostSystemWork_Error_KeWaitForSingleObject	 WPP_DEFINE_MSG_ID(0,115)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_NullServerName	 WPP_DEFINE_MSG_ID(0,105)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_ShareNameNotFound	 WPP_DEFINE_MSG_ID(0,108)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_ShareNameZeroLength	 WPP_DEFINE_MSG_ID(0,107)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_TooShortToBeValid	 WPP_DEFINE_MSG_ID(0,104)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_ZeroLengthShareName	 WPP_DEFINE_MSG_ID(0,106)
#  define MSG_ID_PktpCheckReferralString_Error	 WPP_DEFINE_MSG_ID(0,103)
#  define MSG_ID_PktpCheckReferralString_Error_StringNotWordAlligned	 WPP_DEFINE_MSG_ID(0,102)
#  define MSG_ID_PktpCheckReferralSyntax_Error_InvalidBuffer2	 WPP_DEFINE_MSG_ID(0,99)
#  define MSG_ID_PktpCheckReferralSyntax_Error_InvalidBuffer3	 WPP_DEFINE_MSG_ID(0,100)
#  define MSG_ID_PktpCheckReferralSyntax_Error_InvalidBuffer4	 WPP_DEFINE_MSG_ID(0,101)
#  define MSG_ID_QueryPathCompletionRoutine_Enter	 WPP_DEFINE_MSG_ID(0,52)
#  define MSG_ID_ReplFindFirstProvider_Error_NotFound	 WPP_DEFINE_MSG_ID(0,116)
#  define MSG_ID_TSGetRequestorSessionId_Error1	 WPP_DEFINE_MSG_ID(0,26)
#  define MSG_ID__PktExpandSpecialName_Error_DCNameNotInitialized	 WPP_DEFINE_MSG_ID(0,111)
#  define MSG_ID__PktExpandSpecialName_Error_ExAllocatePoolWithTag	 WPP_DEFINE_MSG_ID(0,112)
#  define MSG_ID__PktExpandSpecialName_Error_NoSpecialReferralTable	 WPP_DEFINE_MSG_ID(0,109)
#  define MSG_ID__PktExpandSpecialName_Error_NotInSpecialReferralTable	 WPP_DEFINE_MSG_ID(0,110)
#  define MSG_ID__PktExpandSpecialName_Error_UnableToOpenRdr	 WPP_DEFINE_MSG_ID(0,113)
#  define MSG_ID__PktExpandSpecialName_Error_ZwFsControlFile	 WPP_DEFINE_MSG_ID(0,114)
#  define MSG_ID__PktGetReferral_Error_ExallocatePoolWithTag	 WPP_DEFINE_MSG_ID(0,97)
#  define MSG_ID__PktGetReferral_Error_UnableToOpenRdr	 WPP_DEFINE_MSG_ID(0,96)
#  define MSG_ID__PktGetReferral_Error_ZwFsControlFile	 WPP_DEFINE_MSG_ID(0,98)


// end WPP stuff

            
#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)
            

extern WML_CONTROL_GUID_REG _MupDrv_ControlGuids[];


//
// Reserved Guids
//
// 
// 
// 
// 
//    
// 6dfa04f0-cf82-426e-ae9e-735f72faa11d
// 5b5f4066-b952-48b5-a4cf-86c942a06968
// 1fd9a84a-6373-4e6c-be34-c16013e3cb07
// d621eecd-6863-4fc4-bb14-80e652739fcf

#endif /* __MUP_MUPWML_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\mupfunc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mupfunc.h

Abstract:

    This module defines all the function prototypes and macros for the MUP.

Author:

    Manny Weiser (mannyw)    17-Dec-1991

Revision History:

--*/

#ifndef _MUPFUNC_
#define _MUPFUNC_


NTSTATUS
MupCreate (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupFsControl (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupCleanup (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupClose (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupForwardIoRequest (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

//
// Internal support functions
//

NTSTATUS
MupInitializeData(
    );

VOID
MupUninitializeData(
    VOID
    );

PIRP
MupBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
MupRerouteOpen (
    IN PFILE_OBJECT FileObject,
    IN PUNC_PROVIDER UncProvider
    );

VOID
MupCalculateTimeout(
    PLARGE_INTEGER Time
    );

//
// Block Management functions.
//

VOID
MupInitializeVcb(
    IN PVCB Vcb
    );

VOID
MupDereferenceVcb(
    PVCB Vcb
    );

PFCB
MupCreateFcb(
    VOID
    );

VOID
MupDereferenceFcb(
    PFCB Fcb
    );

VOID
MupFreeFcb(
    PFCB Fcb
    );

PCCB
MupCreateCcb(
    VOID
    );

VOID
MupDereferenceCcb(
    PCCB Ccb
    );

VOID
MupFreeCcb(
    PCCB Ccb
    );

PUNC_PROVIDER
MupAllocateUncProvider(
    ULONG DataLength
    );

VOID
MupDereferenceUncProvider(
    PUNC_PROVIDER UncProvider
    );

VOID
MupCloseUncProvider(
    PUNC_PROVIDER UncProvider
    );

PKNOWN_PREFIX
MupAllocatePrefixEntry(
    ULONG DataLength
    );

VOID
MupDereferenceKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    );

VOID
MupFreeKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    );

PMASTER_FORWARDED_IO_CONTEXT
MupAllocateMasterIoContext(
    VOID
    );

NTSTATUS
MupDereferenceMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext,
    PNTSTATUS Status
    );

VOID
MupFreeMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext
    );

PMASTER_QUERY_PATH_CONTEXT
MupAllocateMasterQueryContext(
    VOID
    );

NTSTATUS
MupDereferenceMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    );

VOID
MupFreeMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    );

//
// File object support functions.
//

VOID
MupSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    );

BLOCK_TYPE
MupDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    );

//
// Registry Functions
//

VOID
MupGetProviderInformation (
    VOID
    );

PUNC_PROVIDER
MupCheckForUnregisteredProvider(
    PUNICODE_STRING DeviceName
    );

VOID
MupRemoveKnownPrefixEntry(
    PKNOWN_PREFIX KnownPrefix
    );

//
//  Acquiring and releasing MUP locks.
//

#define MupAcquireGlobalLock() ACQUIRE_LOCK( &MupGlobalLock )
#define MupReleaseGlobalLock() RELEASE_LOCK( &MupGlobalLock )

#define BlockType( Block )                 ((PBLOCK_HEADER)(Block))->BlockType

#define MupCompleteRequest( Irp, Status )  FsRtlCompleteRequest( Irp, Status )
#define MupReferenceBlock( Block )         ++((PBLOCK_HEADER)(Block))->ReferenceCount
#define MupVerifyBlock( Block, Type)  \
                                                                   \
    if ( ((PBLOCK_HEADER)(Block))->BlockState != BlockStateActive  \
                ||                                                 \
         ((PBLOCK_HEADER)(Block))->BlockType != Type) {            \
                                                                   \
        ExRaiseStatus( STATUS_INVALID_HANDLE );                    \
                                                                   \
    }

//
// Memory allocation and free
//

#if !MUPDBG

#define ALLOCATE_PAGED_POOL( size, type ) FsRtlAllocatePoolWithTag( PagedPool, (size), ' puM' )
#define ALLOCATE_NONPAGED_POOL( size, type ) FsRtlAllocatePoolWithTag( NonPagedPool, (size), ' puM' )
#define FREE_POOL( buffer ) ExFreePool( buffer )

#else

PVOID
MupAllocatePoolDebug (
    IN POOL_TYPE PoolType,
    IN CLONG BlockSize,
    IN BLOCK_TYPE BlockType
    );

VOID
MupFreePoolDebug (
    IN PVOID P
    );

#define ALLOCATE_PAGED_POOL( size, type ) MupAllocatePoolDebug( PagedPool, (size), (type) )
#define ALLOCATE_NONPAGED_POOL( size, type ) MupAllocatePoolDebug( NonPagedPool, (size), (type) )
#define FREE_POOL( buffer ) MupFreePoolDebug( buffer )

#endif

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

//
// General purpose
//

#define MIN(a,b)  (((a) < (b)) ? (a) : (b))

//
// Terminal Server Macro.
//

#define IsTerminalServer() (BOOLEAN)(SharedUserData->SuiteMask & (1 << TerminalServer))

#endif // _MUPFUNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\pkt.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKT.C
//
//  Contents:   This module implements the Partition Knowledge Table routines
//              for the Dfs driver.
//
//  Functions:  PktInitialize -
//              PktInitializeLocalPartition -
//              RemoveLastComponent -
//              PktCreateEntry -
//              PktCreateDomainEntry -
//              PktCreateSubordinateEntry -
//              PktLookupEntryById -
//              PktEntryModifyPrefix -
//              PktLookupEntryByPrefix -
//              PktLookupEntryByUid -
//              PktLookupReferralEntry -
//              PktTrimSubordinates -
//              PktpRecoverLocalPartition -
//              PktpValidateLocalPartition -
//              PktCreateEntryFromReferral -
//              PktExpandSpecialEntryFromReferral -
//              PktCreateSpecialEntryTableFromReferral -
//              PktGetSpecialReferralTable -
//              PktpAddEntry -
//              PktExpandSpecialName -
//              PktParsePath -
//              PktLookupSpecialNameEntry -
//              PktCreateSpecialNameEntry -
//              PktGetReferral -
//              DfspSetActiveServiceByServerName -
//
//  History:     5 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include <smbtypes.h>
#include <smbtrans.h>

#include "dnr.h"
#include "log.h"
#include "know.h"
#include "mupwml.h"

#include "wincred.h"

#include <netevent.h>


#define Dbg              (DEBUG_TRACE_PKT)

//
// These should come from ntos\inc\ps.h, but
// there are #define conflicts
//

BOOLEAN
PsDisableImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState);

VOID
PsRestoreImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState);

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName);


//
//  Local procedure prototypes
//

NTSTATUS
PktpCheckReferralSyntax(
    IN PUNICODE_STRING ReferralPath,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN DWORD ReferralSize);

NTSTATUS
PktpCheckReferralString(
    IN LPWSTR String,
    IN PCHAR ReferralBuffer,
    IN PCHAR ReferralBufferEnd);

NTSTATUS
PktpCheckReferralNetworkAddress(
    IN PWCHAR Address,
    IN ULONG MaxLength);

NTSTATUS
PktpCreateEntryIdFromReferral(
    IN PRESP_GET_DFS_REFERRAL Ref,
    IN PUNICODE_STRING ReferralPath,
    OUT ULONG *MatchingLength,
    OUT PDFS_PKT_ENTRY_ID Peid);

NTSTATUS
PktpAddEntry (
    IN PDFS_PKT Pkt,
    IN PDFS_PKT_ENTRY_ID EntryId,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN ULONG CreateDisposition,
    IN PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY  *ppPktEntry);

PDS_MACHINE
PktpGetDSMachine(
    IN PUNICODE_STRING ServerName);

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo);

NTSTATUS
DfspSetServiceListToDc(
    PDFS_PKT_ENTRY pktEntry);

VOID
PktShuffleSpecialEntryList(
    PDFS_SPECIAL_ENTRY pSpecialEntry);

VOID
PktSetSpecialEntryListToDc(
    PDFS_SPECIAL_ENTRY pSpecialEntry);

VOID
PktShuffleGroup(
    PDFS_PKT_ENTRY_INFO pInfo,
    ULONG       nStart,
    ULONG       nEnd);

NTSTATUS
PktGetReferral(
    IN PUNICODE_STRING MachineName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ShareName,
    IN BOOLEAN         CSCAgentCreate);

NTSTATUS
DfspSetActiveServiceByServerName(
    PUNICODE_STRING ServerName,
    PDFS_PKT_ENTRY pktEntry);

BOOLEAN
DfspIsDupPktEntry(
    PDFS_PKT_ENTRY ExistingEntry,
    ULONG EntryType,
    PDFS_PKT_ENTRY_ID EntryId,
    PDFS_PKT_ENTRY_INFO EntryInfo);

BOOLEAN
DfspIsDupSvc(
    PDFS_SERVICE pS1,
    PDFS_SERVICE pS2);

VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry);

BOOLEAN
DfspDnsNameToFlatName(
    PUNICODE_STRING DnsName,
    PUNICODE_STRING FlatName);

NTSTATUS
DfsGetLMRTargetInfo(
    HANDLE IpcHandle,
    PDFS_TARGET_INFO *ppTargetInfo );

NTSTATUS 
PktCreateTargetInfo(
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    BOOLEAN SpecialName,
    PDFS_TARGET_INFO *ppDfsTargetInfo );

DWORD PktLastReferralStatus = 0;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, PktInitialize )
#pragma alloc_text( PAGE, PktUninitialize )

#pragma alloc_text( PAGE, RemoveLastComponent )
#pragma alloc_text( PAGE, PktCreateEntry )
#pragma alloc_text( PAGE, PktCreateDomainEntry )
#pragma alloc_text( PAGE, PktEntryModifyPrefix )
#pragma alloc_text( PAGE, PktLookupEntryByPrefix )
#pragma alloc_text( PAGE, PktLookupEntryByUid )
#pragma alloc_text( PAGE, PktLookupReferralEntry )
#pragma alloc_text( PAGE, PktCreateEntryFromReferral )
#pragma alloc_text( PAGE, PktExpandSpecialEntryFromReferral )
#pragma alloc_text( PAGE, PktpCheckReferralSyntax )
#pragma alloc_text( PAGE, PktpCheckReferralString )
#pragma alloc_text( PAGE, PktpCheckReferralNetworkAddress )
#pragma alloc_text( PAGE, PktpCreateEntryIdFromReferral )
#pragma alloc_text( PAGE, PktpAddEntry )
#pragma alloc_text( PAGE, PktExpandSpecialName )
#pragma alloc_text( PAGE, PktpGetDSMachine )
#pragma alloc_text( PAGE, PktShuffleServiceList )
#pragma alloc_text( PAGE, DfspSetServiceListToDc )
#pragma alloc_text( PAGE, PktShuffleSpecialEntryList )
#pragma alloc_text( PAGE, PktSetSpecialEntryListToDc )
#pragma alloc_text( PAGE, PktShuffleGroup )
#pragma alloc_text( PAGE, PktParsePath )
#pragma alloc_text( PAGE, PktLookupSpecialNameEntry )
#pragma alloc_text( PAGE, PktCreateSpecialNameEntry )
#pragma alloc_text( PAGE, PktGetSpecialReferralTable )
#pragma alloc_text( PAGE, PktCreateSpecialEntryTableFromReferral )
#pragma alloc_text( PAGE, DfspSetActiveServiceByServerName )
#pragma alloc_text( PAGE, DfspIsDupPktEntry )
#pragma alloc_text( PAGE, DfspIsDupSvc )
#pragma alloc_text( PAGE, DfspDnsNameToFlatName )
#pragma alloc_text( PAGE, PktpUpdateSpecialTable)
#pragma alloc_text( PAGE, PktFindEntryByPrefix )

#endif // ALLOC_PRAGMA

//
// declare the global null guid
//
GUID _TheNullGuid;

//
// If we are in a workgroup, there's no use in trying to contact the DC!
//
BOOLEAN MupInAWorkGroup = FALSE;


#define SpcIsRecoverableError(x)  ( (x) == STATUS_IO_TIMEOUT ||               \
                                    (x) == STATUS_REMOTE_NOT_LISTENING ||     \
                                    (x) == STATUS_VIRTUAL_CIRCUIT_CLOSED ||   \
                                    (x) == STATUS_BAD_NETWORK_PATH ||         \
                                    (x) == STATUS_NETWORK_BUSY ||             \
                                    (x) == STATUS_INVALID_NETWORK_RESPONSE || \
                                    (x) == STATUS_UNEXPECTED_NETWORK_ERROR || \
                                    (x) == STATUS_NETWORK_NAME_DELETED ||     \
                                    (x) == STATUS_BAD_NETWORK_NAME ||         \
                                    (x) == STATUS_REQUEST_NOT_ACCEPTED ||     \
                                    (x) == STATUS_DISK_OPERATION_FAILED ||    \
                                    (x) == STATUS_NETWORK_UNREACHABLE ||      \
                                    (x) == STATUS_INSUFFICIENT_RESOURCES ||   \
                                    (x) == STATUS_SHARING_PAUSED ||           \
                                    (x) == STATUS_DFS_UNAVAILABLE ||          \
                                    (x) == STATUS_DEVICE_OFF_LINE ||          \
                                    (x) == STATUS_NETLOGON_NOT_STARTED        \
                                  )

//+-------------------------------------------------------------------------
//
//  Function:   PktInitialize, public
//
//  Synopsis:   PktInitialize initializes the partition knowledge table.
//
//  Arguments:  [Pkt] - pointer to an uninitialized PKT
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      This routine is called only at driver init time.
//
//--------------------------------------------------------------------------

NTSTATUS
PktInitialize(
    IN  PDFS_PKT Pkt
) {
    PDFS_SPECIAL_TABLE pSpecialTable = &Pkt->SpecialTable;
    NTSTATUS DiscardStatus;

    DfsDbgTrace(+1, Dbg, "PktInitialize: Entered\n", 0);

    //
    // initialize the NULL GUID.
    //
    RtlZeroMemory(&_TheNullGuid, sizeof(GUID));

    //
    // Always zero the pkt first
    //
    RtlZeroMemory(Pkt, sizeof(DFS_PKT));

    //
    // do basic initialization
    //
    Pkt->NodeTypeCode = DSFS_NTC_PKT;
    Pkt->NodeByteSize = sizeof(DFS_PKT);
    ExInitializeResourceLite(&Pkt->Resource);
    InitializeListHead(&Pkt->EntryList);
    DiscardStatus = DfsInitializeUnicodePrefix(&Pkt->PrefixTable);
    DiscardStatus = DfsInitializeUnicodePrefix(&Pkt->ShortPrefixTable);
    RtlInitializeUnicodePrefix(&Pkt->DSMachineTable);
    Pkt->EntryTimeToLive = MAX_REFERRAL_LIFE_TIME;

    InitializeListHead(&pSpecialTable->SpecialEntryList);

    DfsDbgTrace(-1, Dbg, "PktInitialize: Exit -> VOID\n", 0 );
    return STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   PktUninitialize, public
//
//  Synopsis:   PktUninitialize uninitializes the partition knowledge table.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT
//
//  Returns:    None
//
//  Notes:      This routine is called only at driver unload time
//
//--------------------------------------------------------------------------
VOID
PktUninitialize(
    IN  PDFS_PKT Pkt
    )
{
    DfsFreePrefixTable(&Pkt->PrefixTable);
    DfsFreePrefixTable(&Pkt->ShortPrefixTable);
    ExDeleteResourceLite(&Pkt->Resource);
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveLastComponent, public
//
//  Synopsis:   Removes the last component of the string passed.
//
//  Arguments:  [Prefix] -- The prefix whose last component is to be returned.
//              [newPrefix] -- The new Prefix with the last component removed.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      On return, the newPrefix points to the same memory buffer
//              as Prefix.
//
//--------------------------------------------------------------------------

void
RemoveLastComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix
)
{
    PWCHAR      pwch;
    USHORT      i=0;

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch += (Prefix->Length/sizeof(WCHAR)) - 1;

    while ((*pwch != UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  {
        i += sizeof(WCHAR);
        pwch--;
    }

    newPrefix->Length = newPrefix->Length - i;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktCreateEntry, public
//
//  Synopsis:   PktCreateEntry creates a new partition table entry or
//              updates an existing one.  The PKT must be acquired
//              exclusively for this operation.
//
//  Arguments:  [Pkt] - pointer to an initialized (and exclusively acquired) PKT
//              [PktEntryType] - the type of entry to create/update.
//              [PktEntryId] - pointer to the Id of the entry to create
//              [PktEntryInfo] - pointer to the guts of the entry
//              [CreateDisposition] - specifies whether to overwrite if
//                  an entry already exists, etc.
//              [ppPktEntry] - the new entry is placed here.
//
//  Returns:    [STATUS_SUCCESS] - if all is well.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -  the create disposition was
//                  set to PKT_REPLACE_ENTRY and no entry of the specified
//                  Id exists to replace.
//
//              [DFS_STATUS_ENTRY_EXISTS] - a create disposition of
//                  PKT_CREATE_ENTRY was specified and an entry of the
//                  specified Id already exists.
//
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the entry would
//                  required the invalidation of a local entry or exit point.
//
//              [STATUS_INVALID_PARAMETER] - the Id specified for the
//                  new entry is invalid.
//
//              [STATUS_INSUFFICIENT_RESOURCES] - not enough memory was
//                  available to complete the operation.
//
//  Notes:      The PktEntryId and PktEntryInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the PktEntryId and PktEntryInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly created PktEntry.  Note that this
//              routine does not deallocate the PktEntryId structure or
//              the PktEntryInfo structure itself. On successful return from
//              this function, the PktEntryId structure will be modified
//              to have a NULL Prefix entry, and the PktEntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktCreateEntry(
    IN  PDFS_PKT Pkt,
    IN  ULONG PktEntryType,
    IN  PDFS_PKT_ENTRY_ID PktEntryId,
    IN  PDFS_PKT_ENTRY_INFO PktEntryInfo OPTIONAL,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY *ppPktEntry)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY pfxMatchEntry = NULL;
    PDFS_PKT_ENTRY uidMatchEntry = NULL;
    PDFS_PKT_ENTRY entryToUpdate = NULL;
    PDFS_PKT_ENTRY entryToInvalidate = NULL;
    PDFS_PKT_ENTRY SupEntry = NULL;
    UNICODE_STRING remainingPath, newRemainingPath;

    ASSERT(ARGUMENT_PRESENT(Pkt) &&
           ARGUMENT_PRESENT(PktEntryId) &&
           ARGUMENT_PRESENT(ppPktEntry));

    DfsDbgTrace(+1, Dbg, "PktCreateEntry: Entered\n", 0);

    RtlZeroMemory(&remainingPath, sizeof(UNICODE_STRING));
    RtlZeroMemory(&newRemainingPath, sizeof(UNICODE_STRING));

    //
    // We're pessimistic at first...
    //

    *ppPktEntry = NULL;

    //
    // See if there exists an entry with this prefix.  The prefix
    // must match exactly (i.e. No remaining path).
    //

    pfxMatchEntry = PktLookupEntryByPrefix(Pkt,
                                           &PktEntryId->Prefix,
                                           &remainingPath);

    if (remainingPath.Length > 0)       {
        SupEntry = pfxMatchEntry;
        pfxMatchEntry = NULL;
    } else {
        UNICODE_STRING newPrefix;

        RemoveLastComponent(&PktEntryId->Prefix, &newPrefix);
        SupEntry = PktLookupEntryByPrefix(Pkt,
                                          &newPrefix,
                                          &newRemainingPath);
    }


    //
    // Now search for an entry that has the same Uid.
    //

    uidMatchEntry = PktLookupEntryByUid(Pkt, &PktEntryId->Uid);

    //
    // Now we must determine if during this create, we are going to be
    // updating or invalidating any existing entries.  If an existing
    // entry is found that has the same Uid as the one we are trying to
    // create, the entry becomes a target for "updating".  If the Uid
    // passed in is NULL, then we check to see if an entry exists that
    // has a NULL Uid AND a Prefix that matches.  If this is the case,
    // that entry becomes the target for "updating".
    //
    // To determine if there is an entry to invalidate, we look for an
    // entry with the same Prefix as the one we are trying to create, BUT,
    // which has a different Uid.  If we detect such a situation, we
    // we make the entry with the same Prefix the target for invalidation
    // (we do not allow two entries with the same Prefix, and we assume
    // that the new entry takes precedence).
    //

    if (uidMatchEntry != NULL) {

        entryToUpdate = uidMatchEntry;

        if (pfxMatchEntry != uidMatchEntry)
            entryToInvalidate = pfxMatchEntry;

    } else if ((pfxMatchEntry != NULL) &&
              NullGuid(&pfxMatchEntry->Id.Uid)) {

        //
        // This should go away once we don't have any NULL guids at all in
        // the driver. 
        //
        entryToUpdate = pfxMatchEntry;

    } else {

        entryToInvalidate = pfxMatchEntry;

    }

    //
    // Now we check to make sure that our create disposition is
    // consistent with what we are about to do.
    //

    if ((CreateDisposition & PKT_ENTRY_CREATE) && entryToUpdate != NULL) {

        *ppPktEntry = entryToUpdate;

        status = DFS_STATUS_ENTRY_EXISTS;

    } else if ((CreateDisposition & PKT_ENTRY_REPLACE) && entryToUpdate==NULL) {

        status = DFS_STATUS_NO_SUCH_ENTRY;
    }

    //
    //  if we have an error here we can get out now!
    //

    if (!NT_SUCCESS(status)) {

        DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr(status) );
        return status;
    }

#if DBG
    if (MupVerbose)
        DbgPrint("  #####CreateDisposition=0x%x, entryToUpdate=[%wZ], PktEntryInfo=0x%x\n",
                        CreateDisposition,
                        &entryToUpdate->Id.Prefix,
                        PktEntryInfo);
#endif

    //
    // If this entry is a dup of the one we will want to replace,
    // simply up the timeout on the existing, destroy the new,
    // then return.
    //
    if (DfspIsDupPktEntry(entryToUpdate, PktEntryType, PktEntryId, PktEntryInfo) == TRUE) {
#if DBG
        if (MupVerbose)
            DbgPrint("  ****DUPLICATE PKT ENTRY!!\n");
#endif
        PktEntryIdDestroy(PktEntryId, FALSE);
        PktEntryInfoDestroy(PktEntryInfo, FALSE);
        entryToUpdate->ExpireTime = 60;
        entryToUpdate->TimeToLive = 60;
        DfspSetServiceListToDc(entryToUpdate);
        (*ppPktEntry) = entryToUpdate;
        DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr(status) );
        return status;
    }

    //
    // At this point we must insure that we are not going to
    // be invalidating any local partition entries.
    //

    if ((entryToInvalidate != NULL) &&
        (!(entryToInvalidate->Type &  PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) ) &&
        (entryToInvalidate->Type &
         (PKT_ENTRY_TYPE_LOCAL |
          PKT_ENTRY_TYPE_LOCAL_XPOINT |
          PKT_ENTRY_TYPE_PERMANENT))) {

        DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n",
                    ULongToPtr(DFS_STATUS_LOCAL_ENTRY) );
        return DFS_STATUS_LOCAL_ENTRY;
    }

    //
    // We go up the links till we reach a REFERRAL entry type. Actually
    // we may never go up since we always link to a REFERRAL entry. Anyway
    // no harm done!
    //

    while ((SupEntry != NULL) &&
           !(SupEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC))  {
        SupEntry = SupEntry->ClosestDC;
    }

    //
    // If we had success then we need to see if we have to
    // invalidate an entry.
    //

    if (NT_SUCCESS(status) && entryToInvalidate != NULL) {
	if (entryToInvalidate->UseCount != 0) {
	    DbgPrint("PktEntryReassemble: Destroying in use pkt entry %x, usecount %x\n", 
		     entryToInvalidate, entryToInvalidate->UseCount);
	}
	PktEntryDestroy(entryToInvalidate, Pkt, (BOOLEAN)TRUE);
    }

    //
    // If we are not updating an entry we must construct a new one
    // from scratch.  Otherwise we need to update.
    //

    if (entryToUpdate != NULL) {

        status = PktEntryReassemble(entryToUpdate,
                                    Pkt,
                                    PktEntryType,
                                    PktEntryId,
                                    PktEntryInfo,
                                    pDfsTargetInfo);

        if (NT_SUCCESS(status))  {
            (*ppPktEntry) = entryToUpdate;
            PktEntryLinkChild(SupEntry, entryToUpdate);
        }
    } else {

        //
        // Now we are going to create a new entry. So we have to set
        // the ClosestDC Entry pointer while creating this entry. The
        // ClosestDC entry value is already in SupEntry.
        //

        PDFS_PKT_ENTRY newEntry;

        newEntry = (PDFS_PKT_ENTRY) ExAllocatePoolWithTag(
                                                   PagedPool,
                                                   sizeof(DFS_PKT_ENTRY),
                                                   ' puM');
        if (newEntry == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            status = PktEntryAssemble(newEntry,
                                      Pkt,
                                      PktEntryType,
                                      PktEntryId,
                                      PktEntryInfo,
                                      pDfsTargetInfo);
            if (!NT_SUCCESS(status)) {
                ExFreePool(newEntry);
            } else {
                (*ppPktEntry) = newEntry;
                PktEntryLinkChild(SupEntry, newEntry);
            }
        }
    }

    DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktCreateDomainEntry
//
//  Synopsis:   Given a name that is thought to be a domain name, this routine
//              will create a Pkt Entry for the root of the domain's Dfs.
//              The domain must exist, must have a Dfs root, and must be
//              reachable for this routine to succeed.
//
//  Arguments:  [DomainName] -- Name of domain/machine thought to support a Dfs
//              [ShareName] -- Name of FtDfs or dfs share
//              [CSCAgentCreate] -- TRUE if this is a CSC agent create
//
//  Returns:    [STATUS_SUCCESS] -- Successfully completed operation.
//
//              Status from PktGetReferral
//
//-----------------------------------------------------------------------------

NTSTATUS
PktCreateDomainEntry(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ShareName,
    IN BOOLEAN         CSCAgentCreate)
{
    NTSTATUS status;
    PUNICODE_STRING MachineName;
    PDFS_SPECIAL_ENTRY pSpecialEntry = NULL;
    ULONG EntryIdx;
    ULONG Start;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    DfsDbgTrace(+1, Dbg, "PktCreateDomainEntry: DomainName %wZ \n", DomainName);
    DfsDbgTrace( 0, Dbg, "                      ShareName %wZ \n", ShareName);

    KeQuerySystemTime(&StartTime);

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktCreateDomainEntry(%wZ,%wZ)\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        DomainName,
                        ShareName);
    }
#endif

    //
    // See if machine name is really a domain name, if so
    // turn it into a DC name
    //

    status = PktExpandSpecialName(DomainName, &pSpecialEntry);

    if (NT_SUCCESS(status)) {

        //
        // Step through the DC list trying for a referral
        // Check the status returned - only continue on recoverable errors
        //
       
        Start = pSpecialEntry->Active;

        for (EntryIdx = Start; EntryIdx < pSpecialEntry->ExpandedCount; EntryIdx++) {

            MachineName = &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName;

            status = PktGetReferral(MachineName, DomainName, ShareName, CSCAgentCreate);

            if (!NT_SUCCESS(status) && SpcIsRecoverableError(status)) {

                continue;

            }

            break;

        }

        if (status != STATUS_NO_SUCH_DEVICE && !NT_SUCCESS(status) && Start > 0) {

            for (EntryIdx = 0; EntryIdx < Start; EntryIdx++) {

                MachineName = &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName;

                status = PktGetReferral(MachineName, DomainName, ShareName, CSCAgentCreate);

                if (!NT_SUCCESS(status) && SpcIsRecoverableError(status)) {

                    continue;

                }

                break;

            }

        }

        if (NT_SUCCESS(status) || status == STATUS_NO_SUCH_DEVICE) {

            pSpecialEntry->Active = EntryIdx;

        }

        InterlockedDecrement(&pSpecialEntry->UseCount);

    } else {

        status = PktGetReferral(DomainName, DomainName, ShareName, CSCAgentCreate);
        PktLastReferralStatus = status;

    }

    KeQuerySystemTime(&EndTime);

    DfsDbgTrace(-1, Dbg, "PktCreateDomainEntry: Exit -> %08lx\n", ULongToPtr(status) );

#if DBG
    if (MupVerbose)
        DbgPrint("  [%d] DfsCreateDomainEntry returned %08lx\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                status);
#endif

    return status;

}

//+----------------------------------------------------------------------------
//
//  Function:   PktGetReferral -- helper for PktCreateDomainEntry
//
//  Synopsis:   Ask [MachineName] for referral for \DomainName\ShareName
//
//  Arguments:  [MachineName] -- Name of machine to submit referral request to
//              [DomainName] -- Name of domain/machine thought to support a Dfs
//              [ShareName] -- Name of FtDfs or dfs share
//              [CSCAgentCreate] -- TRUE if this is a CSC agent create
//
//  Returns:    [STATUS_SUCCESS] -- Successfully completed operation.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate memory.
//              [BAD_NETWORK_PATH] -- Unable to allocate provider
//              [STATUS_INVALID_NETWORK_RESPONSE] -- Bad referral
//
//-----------------------------------------------------------------------------

NTSTATUS
_PktGetReferral(
    IN PUNICODE_STRING MachineName, // Machine to direct referral to
    IN PUNICODE_STRING DomainName,  // the machine or domain name to use
    IN PUNICODE_STRING ShareName,   // the ftdfs or dfs name
    IN BOOLEAN         CSCAgentCreate) // the CSC agent create flag
{
    NTSTATUS status;
    HANDLE hServer = NULL;
    DFS_SERVICE service;
    PPROVIDER_DEF provider;
    PREQ_GET_DFS_REFERRAL ref = NULL;
    ULONG refSize = 0;
    ULONG type, matchLength;
    UNICODE_STRING refPath;
    IO_STATUS_BLOCK iosb;
    PDFS_PKT_ENTRY pktEntry;
    BOOLEAN attachedToSystemProcess = FALSE;
    BOOLEAN pktLocked;
    KAPC_STATE ApcState;
    ULONG MaxReferralLength;
    ULONG i;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    PDFS_TARGET_INFO pDfsTargetInfo = NULL;

    DfsDbgTrace(+1, Dbg, "PktGetReferral: MachineName %wZ \n", MachineName);
    DfsDbgTrace( 0, Dbg, "                DomainName %wZ \n", DomainName);
    DfsDbgTrace( 0, Dbg, "                ShareName %wZ \n", ShareName);

    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] PktGetReferral([%wZ]->[\\%wZ\\%wZ]\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                MachineName,
                                DomainName,
                                ShareName);
    }
#endif

    //
    // Get a provider (LM rdr) and service (connection to a machine) describing the remote server.
    //

    provider = ReplLookupProvider( PROV_ID_MUP_RDR );

    if (provider == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to open LM Rdr!\n", 0);
#if DBG
        if (MupVerbose)
            DbgPrint("Unable to open LM Rdr returning STATUS_BAD_NETWORK_PATH\n", 0);
#endif
        if (DfsEventLog > 0)
            LogWriteMessage(LM_REDIR_FAILURE, 0, 0, NULL);
        
        status = STATUS_BAD_NETWORK_PATH;

        MUP_TRACE_HIGH(ERROR, _PktGetReferral_Error_UnableToOpenRdr,
                       LOGUSTR(*MachineName)
                       LOGUSTR(*DomainName)
                       LOGUSTR(*ShareName)
                       LOGBOOLEAN(CSCAgentCreate)
                       LOGSTATUS(status)); 

        return STATUS_BAD_NETWORK_PATH;
    }
    

    RtlZeroMemory( &service, sizeof(DFS_SERVICE) );

    status = PktServiceConstruct(
                &service,
                DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_REFERRAL,
                PROV_DFS_RDR,
                STATUS_SUCCESS,
                PROV_ID_MUP_RDR,
                MachineName,
                NULL);

    DfsDbgTrace(0, Dbg, "PktServiceConstruct returned %08lx\n", ULongToPtr(status) );

    //
    // Build a connection to this machine
    //

    if (NT_SUCCESS(status)) {
        PktAcquireShared( TRUE, &pktLocked );
        if (PsGetCurrentProcess() != DfsData.OurProcess) {
            KeStackAttachProcess( DfsData.OurProcess, &ApcState );
            attachedToSystemProcess = TRUE;
        }

        RestoreImpersonationState = PsDisableImpersonation(
                                        PsGetCurrentThread(),
                                        &DisabledImpersonationState);


	status = DfsCreateConnection(
			&service,
			provider,
			CSCAgentCreate,
			&hServer);

#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DfsCreateConnection returned 0x%x\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                status);
        }
#endif
        if (!NT_SUCCESS(status) && DfsEventLog > 0)
            LogWriteMessage(DFS_CONNECTION_FAILURE, status, 1, MachineName);

        
        DfsDbgTrace(0, Dbg, "DfsCreateConnection returned %08lx\n", ULongToPtr(status) );
        
        if (status == STATUS_SUCCESS)
        {
            status = PktGetTargetInfo( hServer,
                                       DomainName,
                                       ShareName,
                                       &pDfsTargetInfo );
        }
        PktRelease();
        pktLocked = FALSE;

    }


    MaxReferralLength = MAX_REFERRAL_LENGTH;

Retry:

    RtlZeroMemory( &refPath, sizeof(UNICODE_STRING) );

    //
    // Build the referral request (\DomainName\ShareName)
    //

    if (NT_SUCCESS(status)) {
        ULONG ReferralSize = 0;

        refPath.Length = 0;
        refPath.MaximumLength = sizeof(UNICODE_PATH_SEP) +
                                    DomainName->Length +
                                        sizeof(UNICODE_PATH_SEP) +
                                            ShareName->Length +
                                                sizeof(UNICODE_NULL);

        ReferralSize = refPath.MaximumLength + sizeof(REQ_GET_DFS_REFERRAL);

        if (ReferralSize > MAX_REFERRAL_MAX) {
            status = STATUS_INVALID_PARAMETER;
        }
        else if (MaxReferralLength < ReferralSize)
        {
            MaxReferralLength = ReferralSize;
        }

        if (NT_SUCCESS(status)) {
            refPath.Buffer = ExAllocatePoolWithTag( NonPagedPool,
                                                    refPath.MaximumLength + MaxReferralLength,
                                                    ' puM');

            if (refPath.Buffer != NULL) {
                ref = (PREQ_GET_DFS_REFERRAL)&refPath.Buffer[refPath.MaximumLength / sizeof(WCHAR)];
                RtlAppendUnicodeToString( &refPath, UNICODE_PATH_SEP_STR);
                RtlAppendUnicodeStringToString( &refPath, DomainName);
                RtlAppendUnicodeToString( &refPath, UNICODE_PATH_SEP_STR);
                RtlAppendUnicodeStringToString( &refPath, ShareName );
                refPath.Buffer[ refPath.Length / sizeof(WCHAR) ] = UNICODE_NULL;
                ref->MaxReferralLevel = 3;

                RtlMoveMemory(
                    &ref->RequestFileName[0],
                    refPath.Buffer,
                    refPath.Length + sizeof(WCHAR));

                DfsDbgTrace(0, Dbg, "Referral Path : %ws\n", ref->RequestFileName);

                refSize = sizeof(USHORT) + refPath.Length + sizeof(WCHAR);

                DfsDbgTrace(0, Dbg, "Referral Size is %d bytes\n", ULongToPtr(refSize) );
            } else {

                DfsDbgTrace(0, Dbg, "Unable to allocate %d bytes\n",
                            ULongToPtr(refPath.MaximumLength + MaxReferralLength));
                status = STATUS_INSUFFICIENT_RESOURCES;
                MUP_TRACE_HIGH(ERROR, _PktGetReferral_Error_ExallocatePoolWithTag,
                               LOGUSTR(*MachineName)
                               LOGUSTR(*DomainName)
                               LOGUSTR(*ShareName)
                               LOGBOOLEAN(CSCAgentCreate)
                               LOGSTATUS(status));
            }
        }
    }

    //
    // Send the referral out
    //

    if (NT_SUCCESS(status)) {

        DfsDbgTrace(0, Dbg, "Ref Buffer @%08lx\n", ref);

        status = ZwFsControlFile(
                    hServer,                     // Target
                    NULL,                        // Event
                    NULL,                        // APC Routine
                    NULL,                        // APC Context,
                    &iosb,                       // Io Status block
                    FSCTL_DFS_GET_REFERRALS,     // FS Control code
                    (PVOID) ref,                 // Input Buffer
                    refSize,                     // Input Buffer Length
                    (PVOID) ref,                 // Output Buffer
                    MaxReferralLength);          // Output Buffer Length

        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, _PktGetReferral_Error_ZwFsControlFile,
                             LOGUSTR(*MachineName)
                             LOGUSTR(*DomainName)
                             LOGUSTR(*ShareName)
                             LOGBOOLEAN(CSCAgentCreate)
                             LOGSTATUS(status));

        DfsDbgTrace(0, Dbg, "Fscontrol returned %08lx\n", ULongToPtr(status) );
        KeQuerySystemTime(&EndTime);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] ZwFsControlFile returned %08lx\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                status);
        }
#endif 

    }

    //
    // ...and handle the response
    //

    if (NT_SUCCESS(status)) {
        status = PktCreateEntryFromReferral(
                    &DfsData.Pkt,
                    &refPath,
                    (ULONG)iosb.Information,
                    (PRESP_GET_DFS_REFERRAL) ref,
                    PKT_ENTRY_SUPERSEDE,
                    pDfsTargetInfo,
                    &matchLength,
                    &type,
                    &pktEntry);

        DfsDbgTrace(0, Dbg, "PktCreateEntryFromReferral returned %08lx\n", ULongToPtr(status) );
#if DBG
        if (MupVerbose)
            DbgPrint("  PktCreateEntryFromReferral returned %08lx\n", status);
#endif

    } else if (status == STATUS_BUFFER_OVERFLOW && (refPath.Buffer != NULL) && MaxReferralLength < MAX_REFERRAL_MAX) {

        //
        // The referral didn't fit in the buffer supplied.  Make it bigger and try
        // again.
        //

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable: MaxReferralLength %d too small\n",
                        ULongToPtr(MaxReferralLength) );

        ExFreePool(refPath.Buffer);
        refPath.Buffer = NULL;
        MaxReferralLength *= 2;
        if (MaxReferralLength > MAX_REFERRAL_MAX)
            MaxReferralLength = MAX_REFERRAL_MAX;
        status = STATUS_SUCCESS;
        goto Retry;

    } else if (status == STATUS_NO_SUCH_DEVICE) {

        UNICODE_STRING ustr;
        UNICODE_STRING RemPath;
        WCHAR *wCp = NULL;
        ULONG Size;
        PDFS_PKT_ENTRY pEntry = NULL;
        PDFS_PKT Pkt;
        BOOLEAN NestedPktLocked;

        //
        // Check if there is a pkt entry (probably stale) that needs to be removed
        //
#if DBG
        if (MupVerbose)
            DbgPrint("  PktGetReferral: remove PKT entry for \\%wZ\\%wZ\n",
                    DomainName,
                    ShareName);
#endif

       Size = sizeof(WCHAR) +
                DomainName->Length +
                    sizeof(WCHAR) +
                        ShareName->Length;

       ustr.Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            Size,
                            ' puM');

       if (ustr.Buffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
       } else {
            wCp = ustr.Buffer;
            ustr.Length = (USHORT)Size;
            *wCp++ = UNICODE_PATH_SEP;
            RtlCopyMemory(wCp, DomainName->Buffer, DomainName->Length);
            wCp += DomainName->Length/sizeof(WCHAR);
            *wCp++ = UNICODE_PATH_SEP;
            RtlCopyMemory(wCp, ShareName->Buffer, ShareName->Length);
            Pkt = _GetPkt();
            PktAcquireExclusive(TRUE, &NestedPktLocked);
#if DBG
            if (MupVerbose)
                DbgPrint("Looking up %wZ\n", &ustr);
#endif
            pEntry = PktLookupEntryByPrefix(
                            &DfsData.Pkt,
                            &ustr,
                            &RemPath);
#if DBG
            if (MupVerbose)
                DbgPrint("pEntry=0x%x\n", pEntry);
#endif
            if (pEntry != NULL && (pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) == 0) {
                PktFlushChildren(pEntry);
                if (pEntry->UseCount == 0) {
                    PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);
                } else {
                    NTSTATUS DiscardStatus;

                    pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                    pEntry->ExpireTime = 0;
                    DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                    DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));
                }
            }
            ExFreePool(ustr.Buffer);
            PktRelease();
        }
    }

    if (!NT_SUCCESS(status) && DfsEventLog > 0 && refPath.Buffer != NULL) {
        UNICODE_STRING puStr[2];

        puStr[0] = refPath;
        puStr[1] = *MachineName;

        LogWriteMessage(DFS_REFERRAL_FAILURE, status, 2, puStr);

    }

    if (NT_SUCCESS(status) && DfsEventLog > 1 && refPath.Buffer != NULL) {
        UNICODE_STRING puStr[2];

        puStr[0] = refPath;
        puStr[1] = *MachineName;

        LogWriteMessage(DFS_REFERRAL_SUCCESS, status, 2, puStr);

    }

    //
    // Well, we are done. Cleanup all the things we allocated...
    //
    PktServiceDestroy( &service, FALSE );

    if (pDfsTargetInfo != NULL)
    {
        PktReleaseTargetInfo( pDfsTargetInfo ); 
    }
    if (hServer != NULL) {
        ZwClose( hServer );
    }

    if (refPath.Buffer != NULL) {
        ExFreePool( refPath.Buffer );
    }

    if (RestoreImpersonationState) {
            PsRestoreImpersonation(
                PsGetCurrentThread(),
                &DisabledImpersonationState);
    }

    if (attachedToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }

    DfsDbgTrace(-1, Dbg, "PktGetReferral returning %08lx\n", ULongToPtr(status) );

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] PktGetReferral returning %08lx\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
    }
#endif

    return( status );

}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByPrefix, public
//
//  Synopsis:   PktLookupEntryByPrefix finds an entry that has a
//              specified prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the partitions prefix to lookup.
//              [Remaining] - any remaining path.  Points within
//                  the Prefix to where any trailing (nonmatched)
//                  characters are.
//
//  Returns:    The PKT_ENTRY that has the exact same prefix, or NULL,
//              if none exists or is marked for delete.
//
//  Notes:
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry;

    DfsDbgTrace(+1, Dbg, "PktLookupEntryByPrefix: Entered\n", 0);
    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->PrefixTable,Prefix,Remaining))) {
        USHORT pfxLength;

        //
        // reset a pointer to the corresponding entry
        //

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry);

        if (!(pktEntry->Type & PKT_ENTRY_TYPE_DELETE_PENDING)) {

            pfxLength = pktEntry->Id.Prefix.Length;

            //
            //  Now calculate the remaining path and return
            //  the entry we found.  Note that we bump the length
            //  up by one char so that we skip any path separater.
            //

            if ((pfxLength < Prefix->Length) &&
                    (Prefix->Buffer[pfxLength/sizeof(WCHAR)] == UNICODE_PATH_SEP))
                pfxLength += sizeof(WCHAR);

            if (pfxLength < Prefix->Length) {
                Remaining->Length = (USHORT)(Prefix->Length - pfxLength);
                Remaining->Buffer = &Prefix->Buffer[pfxLength/sizeof(WCHAR)];
                Remaining->MaximumLength = (USHORT)(Prefix->MaximumLength - pfxLength);
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByPrefix: Remaining = %wZ\n",
                            Remaining);
            } else {
                Remaining->Length = Remaining->MaximumLength = 0;
                Remaining->Buffer = NULL;
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByPrefix: No Remaining\n", 0);
            }

            DfsDbgTrace(-1, Dbg, "PktLookupEntryByPrefix: Exit -> %08lx\n",
                        pktEntry);
            return pktEntry;

        }
    }

    DfsDbgTrace(-1, Dbg, "PktLookupEntryByPrefix: Exit -> %08lx\n", NULL);
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByShortPrefix, public
//
//  Synopsis:   PktLookupEntryByShortPrefix finds an entry that has a
//              specified prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the partitions prefix to lookup.
//              [Remaining] - any remaining path.  Points within
//                  the Prefix to where any trailing (nonmatched)
//                  characters are.
//
//  Returns:    The PKT_ENTRY that has the exact same prefix, or NULL,
//              if none exists or is marked for delete.
//
//  Notes:
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupEntryByShortPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry;

    DfsDbgTrace(+1, Dbg, "PktLookupEntryByShortPrefix: Entered\n", 0);

    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->ShortPrefixTable,Prefix,Remaining))) {
        USHORT pfxLength;

        //
        // reset a pointer to the corresponding entry
        //

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry);

        if (!(pktEntry->Type & PKT_ENTRY_TYPE_DELETE_PENDING)) {

            pfxLength = pktEntry->Id.ShortPrefix.Length;

            //
            //  Now calculate the remaining path and return
            //  the entry we found.  Note that we bump the length
            //  up by one char so that we skip any path separater.
            //

            if ((pfxLength < Prefix->Length) &&
                    (Prefix->Buffer[pfxLength/sizeof(WCHAR)] == UNICODE_PATH_SEP))
                pfxLength += sizeof(WCHAR);

            if (pfxLength < Prefix->Length) {
                Remaining->Length = (USHORT)(Prefix->Length - pfxLength);
                Remaining->Buffer = &Prefix->Buffer[pfxLength/sizeof(WCHAR)];
                Remaining->MaximumLength = (USHORT)(Prefix->MaximumLength - pfxLength);
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByShortPrefix: Remaining = %wZ\n",
                            Remaining);
            } else {
                Remaining->Length = Remaining->MaximumLength = 0;
                Remaining->Buffer = NULL;
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByShortPrefix: No Remaining\n", 0);
            }

            DfsDbgTrace(-1, Dbg, "PktLookupEntryByShortPrefix: Exit -> %08lx\n",
                        pktEntry);
            return pktEntry;

        }

    }

    DfsDbgTrace(-1, Dbg, "PktLookupEntryByShortPrefix: Exit -> %08lx\n", NULL);
    return NULL;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByUid, public
//
//  Synopsis:   PktLookupEntryByUid finds an entry that has a
//              specified Uid.  The PKT must be acquired for this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Uid] - a pointer to the partitions Uid to lookup.
//
//  Returns:    A pointer to the PKT_ENTRY that has the exact same
//              Uid, or NULL, if none exists.
//
//  Notes:      The input Uid cannot be the Null GUID.
//
//              On a DC where there may be *lots* of entries in the PKT,
//              we may want to consider using some other algorithm for
//              looking up by ID.
//
//--------------------------------------------------------------------------

PDFS_PKT_ENTRY
PktLookupEntryByUid(
    IN  PDFS_PKT Pkt,
    IN  GUID *Uid
) {
    PDFS_PKT_ENTRY entry;

    DfsDbgTrace(+1, Dbg, "PktLookupEntryByUid: Entered\n", 0);

    //
    // We don't lookup NULL Uids
    //

    if (NullGuid(Uid)) {
        DfsDbgTrace(0, Dbg, "PktLookupEntryByUid: NULL Guid\n", NULL);

        entry = NULL;
    } else {
        entry = PktFirstEntry(Pkt);
    }

    while (entry != NULL) {
        if (GuidEqual(&entry->Id.Uid, Uid))
            break;
        entry = PktNextEntry(Pkt, entry);
    }

    //
    // Don't return the entry if it is marked for delete
    //

    if (entry != NULL && (entry->Type & PKT_ENTRY_TYPE_DELETE_PENDING) != 0) {
        entry = NULL;
    }

    DfsDbgTrace(-1, Dbg, "PktLookupEntryByUid: Exit -> %08lx\n", entry);
    return entry;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupReferralEntry, public
//
//  Synopsis:   Given a PKT Entry pointer it returns the closest referral
//              entry in the PKT to this entry.
//
//  Arguments:  [Pkt] - A pointer to the PKT that is being manipulated.
//              [Entry] - The PKT entry passed in by caller.
//
//  Returns:    The pointer to the referral entry that was requested.
//              This could have a NULL value if we could not get anything
//              at all - The caller's responsibility to do whatever he wants
//              with it.
//
//  Note:       If the data structures in the PKT are not linked up right
//              this function might return a pointer to the DOMAIN_SERVICE
//              entry on the DC.  If DNR uses this to do an FSCTL we will have
//              a deadlock.  However, this should never happen.  If it does we
//              have a BUG somewhere in our code. I cannot even have an
//              assert out here.
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupReferralEntry(
    PDFS_PKT            Pkt,
    PDFS_PKT_ENTRY      Entry
) {

    UNICODE_STRING FileName;
    UNICODE_STRING RemPath;
    USHORT i, j;

    DfsDbgTrace(+1, Dbg, "PktLookupReferralEntry: Entered\n", 0);

    if (Entry == NULL)  {

        DfsDbgTrace(-1, Dbg, "PktLookupReferralEntry: Exit -> NULL\n", 0);

        return( NULL );

    }

    FileName = Entry->Id.Prefix;

#if DBG
    if (MupVerbose)
        DbgPrint("  PktLookupReferralEntry(1): FileName=[%wZ]\n", &FileName);
#endif

    //
    // We want to work with the \Server\Share part of the FileName only,
    // so count up to 3 backslashes, then stop.
    //

    for (i = j = 0; i < FileName.Length/sizeof(WCHAR) && j < 3; i++) {

        if (FileName.Buffer[i] == UNICODE_PATH_SEP) {

            j++;

        }

    }

    FileName.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

#if DBG
    if (MupVerbose)
        DbgPrint("  PktLookupReferralEntry(2): FileName=[%wZ]\n", &FileName);
#endif

    //
    // Now find the pkt entry
    //

    Entry = PktLookupEntryByPrefix(
                Pkt,
                &FileName,
                &RemPath);

#if DBG
    if (MupVerbose)
        if (Entry != NULL)
            DbgPrint("  Parent Entry=[%wZ]\n", &Entry->Id.Prefix);
        else
            DbgPrint("  Parent Entry=NULL\n");
#endif

    //
    // Make sure that we found an entry for machine that can give out a referral
    //

    if (
        Entry != NULL
                &&
        (
            (Entry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) == 0
                ||
            (Entry->Type & PKT_ENTRY_TYPE_DELETE_PENDING) != 0
        )
    ) {

        Entry = NULL;

    }

    DfsDbgTrace(-1, Dbg, "PktLookupReferralEntry: Exit -> %08lx\n", Entry);

#if DBG
    if (MupVerbose)
        DbgPrint("  PktLookupReferralEntry: Exit -> %08lx\n", Entry);
#endif

    return(Entry);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktCreateEntryFromReferral, public
//
//  Synopsis:   PktCreateEntryFromReferral creates a new partition
//              table entry from a referral and places it in the table.
//              The PKT must be aquired exclusively for this operation.
//
//  Arguments:  [Pkt] -- pointer to a initialized (and exclusively
//                      acquired) PKT
//              [ReferralPath] -- Path for which this referral was obtained.
//              [ReferralSize] -- size (in bytes) of the referral buffer.
//              [ReferralBuffer] -- pointer to a referral buffer
//              [CreateDisposition] -- specifies whether to overwrite if
//                      an entry already exists, etc.
//              [MatchingLength] -- The length in bytes of referralPath that
//                      matched.
//              [ReferralType] - On successful return, this is set to
//                      DFS_STORAGE_REFERRAL or DFS_REFERRAL_REFERRAL
//                      depending on the type of referral we just processed.
//              [ppPktEntry] - the new entry is placed here.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
PktCreateEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT ULONG   *MatchingLength,
    OUT ULONG   *ReferralType,
    OUT PDFS_PKT_ENTRY *ppPktEntry
)
{
    DFS_PKT_ENTRY_ID EntryId;
    UNICODE_STRING RemainingPath;
    ULONG RefListSize;
    NTSTATUS Status;
    BOOLEAN bPktAcquired = FALSE;


    UNREFERENCED_PARAMETER(Pkt);

    DfsDbgTrace(+1, Dbg, "PktCreateEntryFromReferral: Entered\n", 0);

    try {

        RtlZeroMemory(&EntryId, sizeof(EntryId));

        //
        // Do some parameter validation
        //

        Status = PktpCheckReferralSyntax(
                    ReferralPath,
                    ReferralBuffer,
                    ReferralSize);

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        Status = PktpCreateEntryIdFromReferral(
                    ReferralBuffer,
                    ReferralPath,
                    MatchingLength,
                    &EntryId);

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

	//
        //  Create/Update the prefix entry
        //

        PktAcquireExclusive(TRUE, &bPktAcquired);

        Status = PktpAddEntry(&DfsData.Pkt,
                              &EntryId,
			      ReferralBuffer,
                              CreateDisposition,
                              pDfsTargetInfo,
                              ppPktEntry);

        PktRelease();
        bPktAcquired = FALSE;

        //
        // We have to tell the caller as to what kind of referral was just
        // received through ReferralType.
        //

        if (ReferralBuffer->StorageServers == 1) {
            *ReferralType = DFS_STORAGE_REFERRAL;
        } else {
            *ReferralType = DFS_REFERRAL_REFERRAL;
        }

    try_exit:   NOTHING;

    } finally {

        DebugUnwind(PktCreateEntryFromReferral);

        if (bPktAcquired)
            PktRelease();

        if (AbnormalTermination())
            Status = STATUS_INVALID_USER_BUFFER;

        PktEntryIdDestroy( &EntryId, FALSE );

    }

    DfsDbgTrace(-1, Dbg, "PktCreateEntryFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   PktExpandSpecialEntryFromReferral, public
//
//  Synopsis:   Creates a special list corresponding to the list of names
//              in a referral.
//
//  Arguments:  [Pkt] -- pointer to a initialized (and exclusively
//                      acquired) PKT
//              [ReferralPath] -- Path for which this referral was obtained.
//              [ReferralSize] -- size (in bytes) of the referral buffer.
//              [ReferralBuffer] -- pointer to a referral buffer
//              [pSpecialEntry] - the entry to expand
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
PktExpandSpecialEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry
)
{
    PUNICODE_STRING ustrExpandedName;
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_REFERRAL_V3 v3;
    PDFS_EXPANDED_NAME pExpandedNames;
    LPWSTR wzSpecialName;
    LPWSTR wzExpandedName;
    ULONG TimeToLive = 0;
    ULONG i, j;

    DfsDbgTrace(+1, Dbg, "PktExpandSpecialEntryFromReferral(%wZ): Entered\n", ReferralPath);

    //
    // We can't update if another thread is using this entry
    //

    if (pSpecialEntry->UseCount > 1) {
        return STATUS_SUCCESS;
    }

    //
    // Do some parameter validation
    //

    try {

        Status = PktpCheckReferralSyntax(
                    ReferralPath,
                    ReferralBuffer,
                    ReferralSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialEntryFromReferral exit 0x%x\n", ULongToPtr(Status) );
        return( Status);
    }

    v3 = &ReferralBuffer->Referrals[0].v3;

    if (v3->NumberOfExpandedNames > 0) {

        pExpandedNames = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames,
                            ' puM');
        if (pExpandedNames == NULL) {
            if (pSpecialEntry->NeedsExpansion == FALSE) {
                pSpecialEntry->Stale = FALSE;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            DfsDbgTrace( 0, Dbg, "Unable to allocate ExpandedNames\n", 0);
            DfsDbgTrace(-1, Dbg, "PktExpandSpecialEntryFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
            return (Status);
        }
        RtlZeroMemory(
            pExpandedNames,
            sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames);

        //
        // Loop over the referral, filling in the expanded names
        // If we fail an allocate request, we simply go on.
        //
        wzExpandedName = (LPWSTR) (( (PCHAR) v3) + v3->ExpandedNameOffset);
        for (i = j = 0; i < v3->NumberOfExpandedNames; i++) {
            TimeToLive = v3->TimeToLive;
            //
            // Strip leading '\'
            //
            if (*wzExpandedName == UNICODE_PATH_SEP)
                wzExpandedName++;

            DfsDbgTrace( 0, Dbg, "%ws\n", wzExpandedName);

            ustrExpandedName = &pExpandedNames[j].ExpandedName;
            if (wcslen(wzExpandedName) > 0) {
                ustrExpandedName->Length = wcslen(wzExpandedName) * sizeof(WCHAR);
                ustrExpandedName->MaximumLength = ustrExpandedName->Length + sizeof(WCHAR);
                ustrExpandedName->Buffer = ExAllocatePoolWithTag(
                                                PagedPool,
                                                ustrExpandedName->MaximumLength,
                                                ' puM');
                if (ustrExpandedName->Buffer != NULL) {
                    RtlCopyMemory(
                        ustrExpandedName->Buffer,
                        wzExpandedName,
                        ustrExpandedName->MaximumLength);
                    j++;
                } else {
                    ustrExpandedName->Length = ustrExpandedName->MaximumLength = 0;
                }
            }
            wzExpandedName += wcslen(wzExpandedName) + 1;
        }

        if (j > 0) {
            if (pSpecialEntry->ExpandedNames != NULL) {
                PUNICODE_STRING pustr;

	        for (i = 0; i < pSpecialEntry->ExpandedCount; i++) {
                    pustr = &pSpecialEntry->ExpandedNames[i].ExpandedName;
                    if (pustr->Buffer) {
                       ExFreePool(pustr->Buffer);
                    }		      
		}
                ExFreePool(pSpecialEntry->ExpandedNames);
                pSpecialEntry->ExpandedNames = NULL;
                pSpecialEntry->ExpandedCount = 0;
            }
            pSpecialEntry->ExpandedCount = j;
            pSpecialEntry->Active = 0;
            pSpecialEntry->ExpandedNames = pExpandedNames;
            pSpecialEntry->NeedsExpansion = FALSE;
            pSpecialEntry->Stale = FALSE;
            // PktShuffleSpecialEntryList(pSpecialEntry);
            PktSetSpecialEntryListToDc(pSpecialEntry);
        } else {
            ExFreePool(pExpandedNames);
        }

    }

    DfsDbgTrace(-1, Dbg, "PktExpandSpecialEntryFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

NTSTATUS
PktCreateSpecialEntryTableFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN  PUNICODE_STRING DCName)
{
    PUNICODE_STRING ustrSpecialName;
    PUNICODE_STRING ustrExpandedName;
    PDFS_EXPANDED_NAME pExpandedNames;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_REFERRAL_V3 v3;
    LPWSTR wzSpecialName;
    LPWSTR wzExpandedName;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TimeToLive = 0;
    ULONG i, j, n;

    DfsDbgTrace(+1, Dbg, "PktCreateSpecialEntryTableFromReferral(%wZ): Entered\n", ReferralPath);

    //
    // Do some parameter validation
    //

    try {

        Status = PktpCheckReferralSyntax(
                    ReferralPath,
                    ReferralBuffer,
                    ReferralSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral exit 0x%x\n", ULongToPtr(Status) );
        return( Status);
    }

    //
    // Loop over referrals
    //

    v3 = &ReferralBuffer->Referrals[0].v3;

    for (n = 0; n < ReferralBuffer->NumberOfReferrals; n++) {

       