IN OUT PVISIT_DIR *VisitDirStack,
    OUT    PULONG Cluster OPTIONAL,
    OUT    PWSTRING *DirectoryPath OPTIONAL
    )
{
    PVISIT_DIR visit_dir;

    visit_dir = *VisitDirStack;
    if( visit_dir == NULL ){
        return FALSE;
    }
    *VisitDirStack = visit_dir->Next;

    if( ARGUMENT_PRESENT( Cluster ) ){
        *Cluster = visit_dir->Cluster;
    }

    if( ARGUMENT_PRESENT( DirectoryPath ) ){
        *DirectoryPath = visit_dir->Path;
    }

    FREE( visit_dir );
    return TRUE;
}

STATIC VOID
EraseAssociatedLongName(
    PFATDIR Dir,
    INT     FirstLongEntry,
    INT     ShortEntry
    )
{
    FAT_DIRENT dirent;

    for (int j = FirstLongEntry; j < ShortEntry; ++j) {
        dirent.Initialize(Dir->GetDirEntry(j));
        dirent.SetErased();
    }
}

STATIC BOOLEAN
IsString8Dot3(
    PCWSTRING   s
    )
/*++

Routine Description:

    This routine is used to ensure that lfn's legally correspond
    to their short names.  The given string is examined to see if it
    is a legal fat 8.3 name.

Arguments:

    s -- lfn to examine.

Return Value:

    TRUE            - The string is a legal 8.3 name.
    FALSE           - Not legal.

--*/
{
    USHORT i;
    BOOLEAN extension_present = FALSE;
    WCHAR c;

    //
    // The name can't be more than 12 characters (including a single dot).
    //

    if (s->QueryChCount() > 12) {
        return FALSE;
    }

    for (i = 0; i < s->QueryChCount(); ++i) {

        c = s->QueryChAt(i);

#if 0
        if (!FsRtlIsAnsiCharLegalFat(c, FALSE)) {
            return FALSE;
        }
#endif

        if (c == '.') {

            //
            // We stepped onto a period.  We require the following things:
            //
            //      - it can't be the first character
            //      - there can be only one
            //      - there can't be more than 3 characters following it
            //      - the previous character can't be a space
            //

            if (i == 0 ||
                extension_present ||
                s->QueryChCount() - (i + 1) > 3 ||
                s->QueryChAt(i - 1) == ' ') {

                return FALSE;
            }
            extension_present = TRUE;
        }

        //
        // The base part of the name can't be more than 8 characters long.
        //

        if (i >= 8 && !extension_present) {
            return FALSE;
        }

    }

    //
    // The name cannot end in a space or a period.
    //

    if (c == ' ' || c == '.') {
        return FALSE;
    }

    return TRUE;
}

STATIC PMESSAGE      _pvfMessage = NULL;
STATIC BOOLEAN       _Verbose = FALSE;

VOID
FreeSpaceInBitmap(
    IN      ULONG       StartingCluster,
    IN      PCFAT       Fat,
    IN OUT  PBITVECTOR  FatBitMap
    );

BOOLEAN
FAT_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       LogFileSize,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies the FAT superarea and if neccessary fixes
    it to a correct state.

Arguments:

    FixLevel        - Supplies the level of fixes that may be performed on
                      the disk.
    Message         - Supplies an outlet for messages.
    Flags           - Supplies flags to control the behavior of chkdsk
                      (see ulib\inc\ifsserv.hxx for details)
    LogFileSize     - ignored
    ExitStatus      - Returns an indication of the result of the check
    DriveLetter     - For autocheck, supplies the letter of the volume
                      being checked

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FAT_DIRENT      eadent;
    ULONG           cluster_size;
    ULONG           ea_clus_num;
    USHORT          num_eas, save_num_eas;
    PEA_INFO        ea_infos;
    ULONG           cluster_count;
    HMEM            ea_header_mem;
    EA_HEADER       ea_header;
    BOOLEAN         changes = FALSE;
    BITVECTOR       fat_bitmap;
    FATCHK_REPORT   report;
    PUSHORT         p;
    VOLID           volid;
    ULONG           free_count, bad_count, total_count;
    BOOLEAN         fmsg;
    DSTRING         label;
    DSTRING         eafilename;
    DSTRING         eafilepath;
    BOOLEAN         tmp_bool;
    ULONG           tmp_ulong;
    DSTRING         date;
    DSTRING         time;
    UCHAR           dirty_byte, media_byte;

    BOOLEAN         Verbose = (BOOLEAN)(Flags & CHKDSK_VERBOSE);
    BOOLEAN         OnlyIfDirty = (BOOLEAN)(Flags & CHKDSK_CHECK_IF_DIRTY);
    BOOLEAN         EnableUpgrade = (BOOLEAN)(Flags & CHKDSK_ENABLE_UPGRADE);
    BOOLEAN         EnableDowngrade = (BOOLEAN)(Flags & CHKDSK_DOWNGRADE);
    BOOLEAN         RecoverFree = (BOOLEAN)(Flags & CHKDSK_RECOVER_FREE_SPACE);
    BOOLEAN         RecoverAlloc = (BOOLEAN)(Flags & CHKDSK_RECOVER_ALLOC_SPACE);

    _pvfMessage = Message;
    _Verbose = Verbose;

    memset(&report, 0, sizeof(FATCHK_REPORT));

    if (NULL == ExitStatus) {
        ExitStatus = &report.ExitStatus;
    }
    report.ExitStatus = CHKDSK_EXIT_SUCCESS;
    *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;

    fmsg = TRUE;

    if (FixLevel != CheckOnly) {
        fmsg = FALSE;
    }

    if (EnableUpgrade || EnableDowngrade) {
        Message->Set(MSG_CHK_CANNOT_UPGRADE_DOWNGRADE_FAT);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // Check to see if the dirty bit is set.
    //
    dirty_byte = QueryVolumeFlags();
    if (OnlyIfDirty) {
        if ((dirty_byte &
             (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) == 0) {
            Message->Set(MSG_CHK_VOLUME_CLEAN);
            Message->Display();
            Message->SetLoggingEnabled(FALSE);
            *ExitStatus = CHKDSK_EXIT_SUCCESS;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return TRUE;
        }

        // We need to re-initialize the fatsa object to include the whole
        // super area

        if (!Initialize(_drive, Message, TRUE)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (!Read(Message)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        // If the second bit of the dirty byte is set then
        // also perform a full recovery of the free and allocated
        // space.

        if (dirty_byte & FAT_BPB_RESERVED_TEST_SURFACE) {
            RecoverFree = TRUE;
            RecoverAlloc = TRUE;
        }
    }

    //
    // NOTE that this check must follow the above "if (OnlyIfDirty)" because in the
    //      OnlyIfDirty case only the first part of the FAT_SA object is in memory
    //      until the above if gets executed.
    //
    if (QueryLength() <= SecPerBoot()) {
        Message->Set(MSG_NOT_FAT);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // The volume is not clean, so if we're autochecking we want to
    // make sure that we're printing real messages on the console
    // instead of just dots.
    //

#if defined(_AUTOCHECK_)

    if (Message->SetDotsOnly(FALSE)) {

        Message->SetLoggingEnabled(FALSE);
        if (NULL != DriveLetter) {
            Message->Set(MSG_CHK_RUNNING);
            Message->Display("%W", DriveLetter);
        }

        Message->Set(MSG_FILE_SYSTEM_TYPE);
        Message->Display("%s", _ft == LARGE32 ? "FAT32" : "FAT");
        Message->SetLoggingEnabled();

    }

    if (Message->IsInAutoChk()) {

        ULONG   timeout;

        if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
            timeout = AUTOCHK_TIMEOUT;
        }

        if (timeout > MAX_AUTOCHK_TIMEOUT_VALUE)
            timeout = AUTOCHK_TIMEOUT;

        if (timeout != 0) {
            if (dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE))
                Message->Set(MSG_CHK_AUTOCHK_SKIP_WARNING);
            else
                Message->Set(MSG_CHK_USER_AUTOCHK_SKIP_WARNING);
            Message->Display();
            if (Message->IsKeyPressed(MSG_CHK_ABORT_AUTOCHK, timeout)) {
                Message->SetLoggingEnabled(FALSE);
                Message->Set(MSG_CHK_AUTOCHK_ABORTED);
                Message->Display();
                *ExitStatus = CHKDSK_EXIT_SUCCESS;
                return TRUE;
            } else {
                Message->Set(MSG_CHK_AUTOCHK_RESUMED);
                Message->Display();
            }
        } else if ((dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE))) {
            Message->Set(MSG_CHK_VOLUME_IS_DIRTY);
            Message->Display();
        }
    } else {
        DebugAssert(Message->IsInSetup());
        if (dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) {
            Message->Set(MSG_CHK_VOLUME_IS_DIRTY);
            Message->Display();
        }
    }

#endif  // _AUTOCHECK_

    //
    // The BPB's Media Byte must be in the set accepted
    // by the file system.
    //
    media_byte = QueryMediaByte();

#if defined(FE_SB) && defined(_X86_)
    if ((media_byte != 0x00) &&  /* FMR */
        (media_byte != 0x01) &&  /* FMR */
        (media_byte != 0xf0) &&
#else
    if ((media_byte != 0xf0) &&
#endif
        (media_byte != 0xf8) &&
        (media_byte != 0xf9) &&
#if defined(FE_SB) && defined(_X86_)
        (media_byte != 0xfa) &&  /* FMR */
        (media_byte != 0xfb) &&  /* FMR */
#endif
        (media_byte != 0xfc) &&
        (media_byte != 0xfd) &&
        (media_byte != 0xfe) &&
        (media_byte != 0xff)) {

        SetMediaByte(_drive->QueryMediaByte());
    }

    // First print out the label and volume serial number.

    // We won't bother printing this message under autocheck.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ ) && !defined( _EFICHECK_ )

    TIMEINFO        timeinfo;

    if ((QueryLabel(&label, &timeinfo) || label.Initialize("")) &&
        label.QueryChCount() &&
        timeinfo.QueryDate(&date) &&
        timeinfo.QueryTime(&time)) {

        Message->Set(MSG_VOLUME_LABEL_AND_DATE);
        Message->Display("%W%W%W", &label, &date, &time);
    }

#else
#if defined(_EFICHECK_)

    if (QueryLabel(&label) && label.QueryChCount() > 0) {
        Message->Set(MSG_VOLUME_LABEL_AND_DATE); // date is !!not!! displayed for EFI, since timeinfo is not implemented.
        Message->Display("%W", &label);
    }

#endif
#endif // !_AUTOCHECK_ && !_SETUP_LOADER_


    if (volid = QueryVolId()) {
        p = (PUSHORT) &volid;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", p[1], p[0]);
    }

    // Validate the FAT.

    if (_dirF32 == NULL)
        _fat->Scrub(&changes);

    if (changes) {
        dofmsg(Message, &fmsg);
        Message->Set(MSG_CHK_ERRORS_IN_FAT);
        Message->Display();
    }


    //
    // Make sure that the media type in the BPB is the same as at
    // the beginning of the FAT.
    //

    if (QueryMediaByte() != _fat->QueryMediaByte()) {
#if defined(FE_SB) // MO & OEM FAT Support
        BOOLEAN bPrintError = TRUE;

#if defined(_X86_)
        if (IsPC98_N()) {

            // PC98 Nov.01.1994
            // to help the early NEC DOS

            if(_drive->QueryMediaType() == FixedMedia &&
                       QueryMediaByte() == 0xf8 && _fat->QueryMediaByte() == 0xfe) {

                bPrintError = FALSE;

            }
        }
#endif

        if (bPrintError == TRUE  &&
            (_drive->QueryMediaType() == F3_128Mb_512 ||
             _drive->QueryMediaType() == F3_230Mb_512   )) {

            // We won't to recognized as illegal in following case.
            //
            // Some OpticalDisk might have 0xf0 as media in BPB, but it also has 0xF8 in FAT.
            //

            if (QueryMediaByte() == 0xf0 && _fat->QueryMediaByte() == 0xf8) {

                bPrintError = FALSE;
            }
        }

        if( bPrintError ) {
#endif

            dofmsg(Message, &fmsg);
            Message->Set(MSG_PROBABLE_NON_DOS_DISK);
            Message->Display();
            if (!Message->IsYesResponse(FALSE)) {
                report.ExitStatus = CHKDSK_EXIT_SUCCESS;
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return TRUE;
            }

#if defined(FE_SB) // REAL_FAT_SA::Create():Optical disk support
            //
            // Here is a table of Optical Disk (MO) format on OEM DOS.
            //
            //   128MB    |  NEC  |  IBM  | Fujitsu |
            // -----------+-------+-------+---------+
            // BPB.Media  | 0xF0  | 0xF0  | 0xF0    |
            // -----------+-------+-------+---------+
            // FAT.DiskID | 0xF0  | 0xF8  | 0xF8    |
            // -----------+-------+-------+---------+
            //
            //   230MB    |  NEC  |  IBM  | Fujitsu |
            // -----------+-------+-------+---------+
            // BPB.Media  | 0xF0  | 0xF0  | 0xF0    |
            // -----------+-------+-------+---------+
            // FAT.DiskID | 0xF8  | 0xF8  | 0xF8    |
            // -----------+-------+-------+---------+
            //
            // We will take NEC's way....

            if (_drive->QueryMediaType() == F3_230Mb_512) {

                DebugAssert(QueryMediaByte() == (UCHAR) 0xF0);

                _fat->SetEarlyEntries((UCHAR) 0xF8);
            } else {
                _fat->SetEarlyEntries(QueryMediaByte());
            }
        }
#else
        _fat->SetEarlyEntries(QueryMediaByte());
#endif
    }


    // Compute the cluster size and the number of clusters on disk.

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();
    cluster_count = QueryClusterCount();


    // No EAs have been detected yet.

    ea_infos = NULL;
    num_eas = 0;


    // Create an EA file name string.

    if (!eafilename.Initialize("EA DATA. SF") ||
        !eafilepath.Initialize("\\EA DATA. SF")) {
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }


    //
    // This bitmap will be reinitialized before 'WalkDirectoryTree'.
    // Its contents will be ignored until then.
    //

    if (!fat_bitmap.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // If there is an EA file on disk then...

    // FAT32 volume does not support EA.
    if (_dir != NULL && // <-- If this is not a FAT32 volume.
        eadent.Initialize(_dir->SearchForDirEntry(&eafilename), FAT_TYPE_EAS_OKAY)) {

        // Validate the EA file directory entry.

        if (!ValidateDirent(&eadent, &eafilepath, FixLevel, FALSE, Message,
                            &fmsg, &fat_bitmap, &tmp_bool, &tmp_ulong,
                            ExitStatus)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }


        // If the EA file directory entry was valid then...

        // FATDIR::SearchForDirEntry will not return an erased dirent, but whatever...
        if (!eadent.IsErased()) {

            // The EA file should not have an EA handle.
            if (eadent.QueryEaHandle()) {
                dofmsg(Message, &fmsg);
                Message->Set(MSG_CHK_EAFILE_HAS_HANDLE);
                Message->Display();
                eadent.SetEaHandle(0);
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            }

            // Compute the EA file's starting cluster.
            ea_clus_num = eadent.QueryStartingCluster();

            //
            // Perform any log operations recorded at the beginning
            // of the EA file.
            //

            if (!PerformEaLogOperations(ea_clus_num, FixLevel,
                                        Message, &fmsg)) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }

            //
            // Validate the EA file's EA sets and return an array of
            // information about them.
            //
            ea_infos = RecoverEaSets(ea_clus_num, &num_eas, FixLevel,
                                     Message, &fmsg);

            //
            // If there are no valid EAs in the EA file then erase
            // the EA file.
            //
            if (!ea_infos) {

                if (num_eas) {
                    _Verbose = FALSE;
                    _pvfMessage = NULL;
                    return FALSE;
                }

                eadent.SetErased();

                dofmsg(Message, &fmsg);
                Message->Set(MSG_CHK_EMPTY_EA_FILE);
                Message->Display();
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }
    }


    // Initialize FAT bitmap to be used in detection of cross-links.

    if (!fat_bitmap.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!CheckSectorHeapAllocation(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }


    //
    // Should probably add another function to perform the following task.
    //

    if (_dirF32 != NULL)  {

        if (!VerifyAndFixFat32RootDir( &fat_bitmap, Message, &report, &fmsg)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

    }

    // Validate all of the files on the disk.
    save_num_eas = num_eas;

    if (!WalkDirectoryTree(ea_infos, &num_eas, &fat_bitmap, &report,
                           FixLevel, RecoverAlloc, Message, Verbose, &fmsg)) {
       // DELETE(ea_infos);
       delete [] ea_infos; ea_infos = NULL;
       _Verbose = FALSE;
       _pvfMessage = NULL;
       return FALSE;
    }

    if (save_num_eas != num_eas && ea_infos) {

        if (!EraseEaHandle(ea_infos, num_eas, save_num_eas, FixLevel, Message)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (!num_eas) {

            delete [] ea_infos;
            ea_infos = NULL;

            //
            // Note that the following two steps cause the EA file chain to get recovered
            //  as a lost cluster chain since all this does is erase the dirent, not the
            //  cluster chain.
            //
            eadent.SetErased();
            FreeSpaceInBitmap(eadent.QueryStartingCluster(), _fat,
                              &fat_bitmap);

            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_EMPTY_EA_FILE);
            Message->Display();
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    // If there are EAs on the disk then...

    if (ea_infos) {

        // Remove all unused EAs from EA file.

        if (!PurgeEaFile(ea_infos, num_eas, &fat_bitmap, FixLevel, Message,
                         &fmsg)) {
            // DELETE( ea_infos );
            delete [] ea_infos; ea_infos = NULL;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }


        // Rebuild header portion of EA file.

        if (!ea_header_mem.Initialize() ||
            !RebuildEaHeader(&ea_clus_num, ea_infos, num_eas,
                             &ea_header_mem, &ea_header, &fat_bitmap,
                             FixLevel, Message, &fmsg)) {
            // DELETE( ea_infos );
            delete [] ea_infos; ea_infos = NULL;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (ea_clus_num) {
            eadent.SetStartingCluster(ea_clus_num);
            eadent.SetFileSize(cluster_size*
                               _fat->QueryLengthOfChain(ea_clus_num));
        } else {
            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_EMPTY_EA_FILE);
            Message->Display();

            //
            // Note that the following two steps cause the EA file chain to get recovered
            //  as a lost cluster chain since all this does is erase the dirent, not the
            //  cluster chain.
            //
            eadent.SetErased();
            FreeSpaceInBitmap(eadent.QueryStartingCluster(), _fat,
                              &fat_bitmap);
        }
        *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    //
    // If WalkDirectoryTree deleted any files, we need to sync the
    // FAT_EXTENSIONS up with the FAT again.
    //
    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!RecoverOrphans(&fat_bitmap, FixLevel, Message, &fmsg, &report, &changes)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // RecoverOrphans may have cleared faulty entries from the FAT,
    // and now we need to sync the FAT_EXTENSIONS again.
    //
    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // If requested, validate all of the free space on the volume.

    if (RecoverFree && !RecoverFreeSpace(Message)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    total_count = cluster_count - FirstDiskCluster;

    if (changes) {
        report.ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    *ExitStatus = report.ExitStatus;

    switch (*ExitStatus) {
      case CHKDSK_EXIT_SUCCESS:
        Message->DisplayMsg(MSG_CHK_NO_PROBLEM_FOUND);
        break;

      case CHKDSK_EXIT_ERRS_FIXED:
        Message->DisplayMsg((FixLevel != CheckOnly) ? MSG_CHK_ERRORS_FIXED : MSG_CHK_NEED_F_PARAMETER);
        break;

      case CHKDSK_EXIT_COULD_NOT_CHK:
//    case CHKDSK_EXIT_ERRS_NOT_FIXED:
//    case CHKDSK_EXIT_COULD_NOT_FIX:
        Message->DisplayMsg(MSG_CHK_ERRORS_NOT_FIXED);
        break;

    }

    BIG_INT temp_big_int;
    ULONG   temp_ulong;
    MSGID   message_id;
    BOOLEAN KSize;
    DSTRING wdNum1;
    char    wdAstr[14];
    DSTRING wdNum2;


    if (!wdNum1.Initialize("             ") ||
        !wdNum2.Initialize("             ")   ) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    temp_big_int = cluster_size;
    temp_big_int = temp_big_int * total_count;

    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility

    if (temp_big_int.GetHighPart() || (temp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_TOTAL_KILOBYTES;
        KSize = TRUE;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_TOTAL_DISK_SPACE;
        KSize = FALSE;
    }

    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (report.HiddenEntriesCount) {
        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.HiddenClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_HIDDEN_FILES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_HIDDEN_FILES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.HiddenEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (report.DirEntriesCount) {
        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.DirClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_DIRECTORIES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_DIRECTORIES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.DirEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (report.FileEntriesCount) {

        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.FileClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_USER_FILES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_USER_FILES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.FileEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (bad_count = _fat->QueryBadClusters()) {
        temp_big_int = bad_count;
        temp_big_int = temp_big_int * cluster_size;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_BAD_SECTORS;
        }
        Message->Set(message_id);
        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    if (ea_infos) {
        Message->Set(MSG_CHK_EA_SIZE);

        sprintf(wdAstr, "%u", cluster_size*_fat->QueryLengthOfChain(ea_clus_num));
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = _fat->QueryFreeClusters();

    temp_big_int = free_count;
    temp_big_int = temp_big_int * cluster_size;
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_AVAILABLE_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_AVAILABLE_DISK_SPACE;
    }
    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_TOTAL_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", total_count);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (FixLevel != CheckOnly && ea_infos && !ea_header.Write()) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // Clear the dirty bit.
    //
    if( RecoverAlloc ) {
        SetVolumeFlags(FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE,
                       TRUE);
    } else {
        SetVolumeFlags(FAT_BPB_RESERVED_DIRTY, TRUE);
    }


    if (FixLevel != CheckOnly && !Write(Message)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // DELETE(ea_infos);
    delete [] ea_infos; ea_infos = NULL;
    _Verbose = FALSE;
    _pvfMessage = NULL;
    return TRUE;
}

BOOLEAN
FAT_SA::VerifyAndFixFat32RootDir (
    IN OUT  PBITVECTOR      FatBitMap,
    IN      PMESSAGE        Message,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PBOOLEAN        NeedErrorMessage
    )

/*++

Routine Description:

    This routine verifies the FAT32 root directory which is not an integral
    part of the super area buffer. The method employed to verify and fix the
    root directory is very similar to the one used to verify and fix regular
    directory structure.

Arguments:

    BitVector - Supplies a bit map for cross/bad links detection. The whole
                map should be zeroed when it is passed in this method.
    Message   - Supplies an outlet for messages.
    Report    - Supplies the fat chkdsk report structures for storing the
                actions performed by this method.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Values:

    TRUE  - Success.
    FALSE - Failed.

--*/
{

    BOOLEAN crosslink_detected = FALSE;
    BOOLEAN changes_made = FALSE;
    ULONG   starting_cluster;
    ULONG   dummy;

    starting_cluster = QueryFat32RootDirStartingCluster();
    _fat->ScrubChain( starting_cluster,
                      FatBitMap,
                      &changes_made,
                      &crosslink_detected,
                      &dummy );
    //
    // Root dir is the only component marked in the
    // bitmap so far.
    //

    DebugAssert(!crosslink_detected);

    if (changes_made) {
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_BAD_LINK);
        Message->Display("%s", "\\");
        Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

        //
        //  We have to reinitialized the root directory.
        //

        if (!_hmem_F32->Initialize() ||
            !_dirF32->Initialize( _hmem_F32, _drive, this,
                                  _fat, starting_cluster)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        //
        //  Force a re-reading of the root directory.
        //  We don't care if it fails, subsequent code can fix that.
        //

        _dirF32->Read();
    }

    //
    // Validate the readability of the root chain
    //

    //
    // We don't want replacement clusters becuase the replacement given
    // by RecoverChain will be zeroed which, according to the spec., means
    // it contains the end of the directory structure and WalkDirectoryTree
    // will just go ahead and erase all the 'good' directory entries that comes
    // after the replaced cluster. Not a really nice thing to do to the root
    // directory IMHO.
    //
    if(!RecoverChain(&starting_cluster, &changes_made, 0, FALSE)){
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (changes_made) {

        if ( starting_cluster ) {

            if ( starting_cluster != _dirF32->QueryStartingCluster() ) {
                SetFat32RootDirStartingCluster( starting_cluster );
            }

            //
            // Should reinitialize the root directory
            //
            if (!_hmem_F32->Initialize() ||
                !_dirF32->Initialize( _hmem_F32, _drive, this,
                                      _fat, starting_cluster)) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }


        } else {

            if(!RelocateNewFat32RootDirectory( Report, FatBitMap, Message )) {
                return FALSE;
            }

        }


        //
        //  Reread the root directory
        //
        if (!_dirF32->Read()) {
            //
            //  Shouldn't fail.
            //
            DebugAbort("Failed to read the FAT32 root directory despite all the fixing.\n");

        }
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_CHK_NTFS_CORRECTING_ERROR_IN_DIRECTORY);
        Message->Display("%s", "\\");
        //
        // Erasing the root will totally destroy the disk
        // so we just leave it partially corrupted and
        // hopefully WalkDirectoryTree will be able to fix it.
        //
        Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    return TRUE;
}

BOOLEAN
FAT_SA::RelocateNewFat32RootDirectory (
    IN OUT PFATCHK_REPORT   Report,
    IN OUT PBITVECTOR       FatBitMap,
    IN     PMESSAGE         Message
    )
/*++

Routine Description:

    This routine relocates a FAT32 root directory

Arguments:

    Report - Supplies the fat chkdsk report structure for storing
             the fix status.

    FatBitMap - Supplies a pointer to the bit map for cross-link
                detection.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - Success.
    FALSE - Failed.

--*/
{

    SECRUN  root_secrun; // Allocate one cluster for the
                         // new root directory.
    ULONG   root_clus;   // New cluster number of the
                         // root directory
    ULONG   cluster_size;// Number of sectors in a cluster.

    ULONG   starting_data_lbn;
    ULONG   sector_size;

    starting_data_lbn = QueryStartDataLbn();
    cluster_size = QuerySectorsPerCluster();
    sector_size = _drive->QuerySectorSize();


    for (;;) {

        root_clus = _fat->AllocChain(1, NULL);

        if (!root_clus) {
            //
            // The disk is full, we have no choice but to bail out.
            //
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        if ( !_hmem_F32->Initialize() ||
             !root_secrun.Initialize( _hmem_F32,
                                      _drive,
                                      QuerySectorFromCluster(root_clus, NULL),
                                      cluster_size)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        memset(root_secrun.GetBuf(), 0, cluster_size * sector_size);

        if (root_secrun.Write() && root_secrun.Read()) {
            SetFat32RootDirStartingCluster(root_clus);
            //
            //  Set the bit for the new root in the bit map.
            //
            FatBitMap->SetBit(root_clus);

            //
            //  Reinitialize the FAT32 root directory
            //
            if ( !_hmem_F32->Initialize() ||
                 !_dirF32->Initialize( _hmem_F32, _drive, this,
                                       _fat, root_clus)) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }


            Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            return TRUE;
        } else {
            _fat->SetClusterBad(root_clus);
        }

    }

    DebugPrintTrace(("FAT_SA::RelocateNewFat32RootDirectory: This line should not be reached.\n"));
    return FALSE;
}


BOOLEAN
FAT_SA::PerformEaLogOperations(
    IN      ULONG       EaFileCn,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine reads the EA file log from the disk and then performs
    any logged operations specified.

Arguments:

    EaFileCn         - Supplies the first cluster of the EA file.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM            hmem;
    EA_HEADER       ea_header;
    PEA_FILE_HEADER pea_header;
    ULONG           cluster_size;
    ULONG           num_clus;

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();
    num_clus = sizeof(EA_FILE_HEADER) + BaseTableSize*sizeof(USHORT);
    if (num_clus%cluster_size) {
        num_clus = (num_clus/cluster_size + 1);
    } else {
        num_clus = (num_clus/cluster_size);
    }

    if (!hmem.Initialize() ||
        !ea_header.Initialize(&hmem, _drive, this, _fat, EaFileCn, num_clus) ||
        !(pea_header = ea_header.GetEaFileHeader())) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!ea_header.Read()) {
        Message->Set(MSG_CHK_CANT_CHECK_EA_LOG);
        Message->Display();
        return TRUE;
    }

    if (pea_header->Signature != HeaderSignature ||
        pea_header->FormatType ||
        pea_header->LogType) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_BAD_LOG, NORMAL_MESSAGE, TEXT_MESSAGE);
        Message->Display();
        if (Message->IsYesResponse(TRUE)) {
            pea_header->Signature = HeaderSignature;
            pea_header->Cluster1 = 0;
            pea_header->Cluster2 = 0;
            pea_header->Cluster3 = 0;

            if (FixLevel != CheckOnly) {
                ea_header.Write();
            }

            return TRUE;
        } else {
            return FALSE;
        }
    }

    if (pea_header->Cluster1) {
        if (_fat->IsInRange(pea_header->Cluster1) &&
            _fat->IsInRange(pea_header->NewCValue1)) {
            _fat->SetEntry(pea_header->Cluster1, pea_header->NewCValue1);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    if (pea_header->Cluster2) {
        if (_fat->IsInRange(pea_header->Cluster2) &&
            _fat->IsInRange(pea_header->NewCValue2)) {
            _fat->SetEntry(pea_header->Cluster2, pea_header->NewCValue2);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    if (pea_header->Cluster3) {
        if (_fat->IsInRange(pea_header->Cluster3) &&
            _fat->IsInRange(pea_header->NewCValue3)) {
            _fat->SetEntry(pea_header->Cluster3, pea_header->NewCValue3);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }
    return TRUE;
}


PEA_INFO
FAT_SA::RecoverEaSets(
    IN      ULONG       EaFileCn,
    OUT     PUSHORT     NumEas,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine validates and if necessary recovers the EA file.

Arguments:

    EaFileCn            - Supplies the cluster number for the EA file.
    NumEas              - Returns the number of EA sets in the EA file.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Value:

    An allocated array containing 'NumberOfEaSets' entries documenting
    important information about the EA sets.  If there are no EAs then
    'NumberOfEaSets' is returned as 0 and NULL is returned.  If there
    is an error then NULL will be returned with a non-zero
    'NumberOfEaSets'.

--*/
{
    PEA_INFO    ea_infos;
    ULONG       clus, prev;
    USHORT      num_eas;
    ULONG       i;
    ULONG       length;

    DebugAssert(NumEas);

    *NumEas = 1;

    length = _fat->QueryLengthOfChain(EaFileCn);
    ea_infos = NEW EA_INFO[length];
    if (!ea_infos) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return NULL;
    }

    memset(ea_infos, 0, length*sizeof(EA_INFO));

    //
    // Scan file for EA sets and validate them while updating the
    // array.
    //
    num_eas = 0;
    prev = EaFileCn;
    while (!_fat->IsEndOfChain(prev)) {

        clus = VerifyAndFixEaSet(prev, &ea_infos[num_eas], FixLevel,
                                 Message, NeedErrorsMessage);

        if (clus) {
            num_eas++;
        } else {
            clus = _fat->QueryEntry(prev);
        }

        prev = clus;
    }

    if (!num_eas) {

        // All the ea sets are unused, the ea file is
        // effectively empty.

        // Should use array delete instead.
        // DELETE( ea_infos );
        delete [] ea_infos;

        // Free the cluster chain occupied by the ea file
        // so subsequent checking and fixing will not
        // complain about the lost chain in the ea file.

        _fat->FreeChain(EaFileCn);

        ea_infos = NULL;
        *NumEas = 0;
        return NULL;
    }


    // Go through and remove unused portions of the EA file.

    for (i = 0; i < (USHORT)(num_eas - 1); i++) {
        if (ea_infos[i].LastCn != ea_infos[i + 1].PreceedingCn) {

            _fat->RemoveChain(ea_infos[i].LastCn,
                              ea_infos[i + 1].PreceedingCn);

            dofmsg(Message, NeedErrorsMessage);

            Message->Set(MSG_CHK_UNUSED_EA_PORTION);
            Message->Display();

            ea_infos[i + 1].PreceedingCn = ea_infos[i].LastCn;
        }
    }

    if (!_fat->IsEndOfChain(ea_infos[num_eas - 1].LastCn)) {

        _fat->SetEndOfChain(ea_infos[num_eas - 1].LastCn);

        dofmsg(Message, NeedErrorsMessage);

        Message->Set(MSG_CHK_UNUSED_EA_PORTION);
        Message->Display();
    }


    // Sort the EAs in the EA file.

    if (!EaSort(ea_infos, num_eas, Message, NeedErrorsMessage)) {
        return NULL;
    }

    *NumEas = num_eas;

    return ea_infos;
}


ULONG
FAT_SA::VerifyAndFixEaSet(
    IN      ULONG       PreceedingCluster,
    OUT     PEA_INFO    EaInfo,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine attempts to identify the clusters following the
    'PreceedingCluster' as an EA set.  If this routine does not
    recognize these clusters as an EA set then it will return 0.
    Otherwise, it will return the last cluster of the validated EA set.

    Changes may be made to the clusters if they are recognized as an EA
    set with errors.

Arguments:

    PreceedingCluster   - Supplies the cluster preceeding the EA set cluster.
    Info                - Returns information about the EA set.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    The cluster number of the last cluster in the EA set or 0.

--*/
{
    HMEM    hmem;
    EA_SET  easet;
    ULONG   clus;
    PEA_HDR eahdr;
    LONG    i;
    ULONG   j;
    ULONG   need_count;
    LONG    total_size;
    LONG    size;
    ULONG   length;
    BOOLEAN need_write;
    PEA     pea;
    BOOLEAN more;
    ULONG   chain_length;

    clus = _fat->QueryEntry(PreceedingCluster);
    chain_length = _fat->QueryLengthOfChain(clus);

    length = 1;
    need_write = FALSE;

    if (!hmem.Initialize() ||
        !easet.Initialize(&hmem, _drive, this, _fat, clus, length) ||
        !(eahdr = easet.GetEaSetHeader())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return 0;
    }

    if (!easet.Read()) {
        return 0;
    }

    if (!easet.VerifySignature()) {
        return 0;
    }

    need_count = 0;
    total_size = 4;
    for (i = 0; ; i++) {
        for (j = 0; !(pea = easet.GetEa(i, &size, &more)) && more &&
                     length + j < chain_length; ) {
            j++;
            if (!hmem.Initialize() ||
                !easet.Initialize(&hmem, _drive, this, _fat, clus, length + j)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return 0;
            }

            if (!easet.Read()) {
                return 0;
            }
        }

        if (pea) {
            length += j;
        } else {
            break;
        }

        total_size += size;

        if (pea->Flag & NeedFlag) {
            need_count++;
        }
    }

    if (!i) {
        return 0;
    }

    if (total_size != eahdr->TotalSize) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_EASET_SIZE);
        Message->Display("%d", clus);
        eahdr->TotalSize = total_size;
        need_write = TRUE;
    }

    if (need_count != eahdr->NeedCount) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_EASET_NEED_COUNT);
        Message->Display("%d", clus);
        eahdr->NeedCount = need_count;
        need_write = TRUE;
    }

    EaInfo->OwnHandle = eahdr->OwnHandle;
    EaInfo->PreceedingCn = PreceedingCluster;
    EaInfo->LastCn = _fat->QueryNthCluster(PreceedingCluster, length);
    memcpy(EaInfo->OwnerFileName, eahdr->OwnerFileName, 14);
    EaInfo->UsedCount = 0;

    if (need_write) {
        if (FixLevel != CheckOnly && !easet.Write()) {
            return 0;
        }
    }

    return EaInfo->LastCn;
}


BOOLEAN
FAT_SA::EaSort(
    IN OUT  PEA_INFO    EaInfos,
    IN      ULONG       NumEas,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine sorts the EaInfos array by 'OwnHandle' into ascending order.
    It also edits the FAT with the changes in the EAs order.

Arguments:

    EaInfos             - Supplies the array of EA_INFOs to sort.
    NumEas              - Supplies the number of elements in the array.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN done;
    EA_INFO tmp;
    ULONG   clus;
    ULONG   i;
    BOOLEAN change;

    done = FALSE;
    change = FALSE;
    while (!done) {
        done = TRUE;
        for (i = 0; i < NumEas - 1; i++) {
            if (EaInfos[i].OwnHandle > EaInfos[i + 1].OwnHandle) {
                done = FALSE;

                clus = _fat->RemoveChain(EaInfos[i + 1].PreceedingCn,
                                         EaInfos[i + 1].LastCn);

                _fat->InsertChain(clus,
                                  EaInfos[i + 1].LastCn,
                                  EaInfos[i].PreceedingCn);

                EaInfos[i + 1].PreceedingCn = EaInfos[i].PreceedingCn;
                EaInfos[i].PreceedingCn = EaInfos[i + 1].LastCn;
                if (i + 2 < NumEas) {
                    EaInfos[i + 2].PreceedingCn = EaInfos[i].LastCn;
                }

                change = TRUE;

                tmp = EaInfos[i];
                EaInfos[i] = EaInfos[i + 1];
                EaInfos[i + 1] = tmp;
            }
        }
    }

    if (change) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNORDERED_EA_SETS);
        Message->Display();
    }

    return TRUE;
}


BOOLEAN
FAT_SA::RebuildEaHeader(
    IN OUT  PULONG      StartingCluster,
    IN OUT  PEA_INFO    EaInfos,
    IN      ULONG       NumEas,
    IN OUT  PMEM        EaHeaderMem,
    OUT     PEA_HEADER  EaHeader,
    IN OUT  PBITVECTOR  FatBitMap,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine rebuilds the header and tables of the EA file base on the
    information in the 'EaInfos' array.  The header log is set to zero,
    and the header itself is relocated if any of the clusters are bad.

    The starting cluster may be relocated if there are bad clusters.

Arguments:

    StartingCluster     - Supplies the first cluster of the EA file.
    EaInfos             - Supplies an array containing information for every
                            EA set.
    NumberOfEas         - Supplies the total number of EA sets.
    EaHeaderMem         - Supplies the memory for the EA header.
    EaHeader            - Returns the EA header.
    FatBitMap           - Supplies the cross-links bitmap.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           length;
    ULONG           cluster_size;
    ULONG           actual_length;
    ULONG           new_chain;
    ULONG           last_cluster;
    BOOLEAN         changes;
    LONG            i, j, k;
    PEA_MAP_TBL     table;
    PEA_FILE_HEADER header;
    LONG            tmp;
    BOOLEAN         empty_ea_file;
    ULONG           clus;


    // Compute the number of clusters necessary for the header portion of
    // the EA file.

    length = sizeof(EA_FILE_HEADER) +
             BaseTableSize*sizeof(USHORT) +
             EaInfos[NumEas - 1].OwnHandle*sizeof(USHORT);

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    if (length%cluster_size) {
        length = length/cluster_size + 1;
    } else {
        length = length/cluster_size;
    }

    //
    // Make sure that the header contains enough clusters to accomodate
    // the size of the offset table.
    //

    last_cluster = EaInfos[0].PreceedingCn;

    actual_length = _fat->QueryLengthOfChain(*StartingCluster, last_cluster);

    if (length > actual_length) {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_NEED_MORE_HEADER_SPACE);
        Message->Display();

        new_chain = _fat->AllocChain((length - actual_length),
                                     &last_cluster);
        if (!new_chain) {
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        if (IsCompressed() && !AllocSectorsForChain(new_chain)) {
            _fat->FreeChain(new_chain);
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        for (clus = new_chain;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->SetBit(clus);
        }
        FatBitMap->SetBit(clus);

        _fat->InsertChain(new_chain, last_cluster, EaInfos[0].PreceedingCn);

        EaInfos[0].PreceedingCn = last_cluster;

    } else if (length < actual_length) {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNUSED_EA_PORTION);
        Message->Display();

        last_cluster = _fat->QueryNthCluster(*StartingCluster,
                                             length - 1);

        clus = _fat->RemoveChain(last_cluster, EaInfos[0].PreceedingCn);

        EaInfos[0].PreceedingCn = last_cluster;

        for (;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->ResetBit(clus);
        }
        FatBitMap->ResetBit(clus);

    }


    // Verify the cluster chain containing the header.

    changes = FALSE;
    if (FixLevel != CheckOnly &&
        !RecoverChain(StartingCluster, &changes, last_cluster, TRUE)) {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
        Message->Display();

        return FALSE;
    }

    if (changes) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_RELOCATED_EA_HEADER);
        Message->Display();
    }


    // Compute the tables.

    if (!EaHeader->Initialize(EaHeaderMem, _drive, this, _fat,
                              *StartingCluster, (USHORT) length) ||
        !(table = EaHeader->GetMapTable()) ||
        !(header = EaHeader->GetEaFileHeader())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!EaHeader->Read()) {
        if (FixLevel == CheckOnly) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_RELOCATED_EA_HEADER);
            Message->Display();
        } else {
            return FALSE;
        }
    }


    // Set the log in the header to zero.

    header->Signature = HeaderSignature;
    header->FormatType = 0;
    header->LogType = 0;
    header->Cluster1 = 0;
    header->NewCValue1 = 0;
    header->Cluster2 = 0;
    header->NewCValue2 = 0;
    header->Cluster3 = 0;
    header->NewCValue3 = 0;
    header->Handle = 0;
    header->NewHOffset = 0;


    // Reconcile the tables with the EaInfo information.

    changes = FALSE;

    for (i = 0; i < BaseTableSize; i++) {
        table->BaseTab[i] = 0;
    }

    j = 0;
    empty_ea_file = TRUE;
    for (i = 0; i < (LONG) NumEas; i++) {

        if (EaInfos[i].UsedCount != 1) {
            continue;
        }

        empty_ea_file = FALSE;

        for (; j < (LONG) EaInfos[i].OwnHandle; j++) {
            if (table->OffTab[j] != InvalidHandle) {
                table->OffTab[j] = InvalidHandle;
                changes = TRUE;
            }
        }

        length = _fat->QueryLengthOfChain(*StartingCluster,
                                         EaInfos[i].PreceedingCn);

        for (k = j>>7; k >= 0 && !table->BaseTab[k]; k--) {
            table->BaseTab[k] = (USHORT) length;
        }

        tmp = length - table->BaseTab[j>>7];

        if ((LONG)table->OffTab[j] != tmp) {
            table->OffTab[j] = (USHORT) tmp;
            changes = TRUE;
        }

        j++;
    }

    if (empty_ea_file) {

        for (clus = *StartingCluster;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->ResetBit(clus);

        }
        FatBitMap->ResetBit(clus);

        *StartingCluster = 0;

        return TRUE;
    }

    tmp = _fat->QueryLengthOfChain(*StartingCluster);
    for (k = ((j - 1)>>7) + 1; k < BaseTableSize; k++) {
        table->BaseTab[k] = (USHORT) tmp;
    }

    for (; j < (LONG) EaHeader->QueryOffTabSize(); j++) {
        if (table->OffTab[j] != InvalidHandle) {
            table->OffTab[j] = InvalidHandle;
            changes = TRUE;
        }
    }

    if (changes) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_ERROR_IN_EA_HEADER);
        Message->Display();
    }

    return TRUE;
}


VOID
FreeSpaceInBitmap(
    IN      ULONG       StartingCluster,
    IN      PCFAT       Fat,
    IN OUT  PBITVECTOR  FatBitMap
    )
{
    if (!StartingCluster) {
        return;
    }

    while (!Fat->IsEndOfChain(StartingCluster)) {
        FatBitMap->ResetBit(StartingCluster);
        StartingCluster = Fat->QueryEntry(StartingCluster);
    }
    FatBitMap->ResetBit(StartingCluster);
}


ULONG
ComputeFileNameHashValue(
    IN  PVOID   FileName
    )
{
    ULONG   h;
    BYTE    i;
    PUCHAR  p;

    p = (PUCHAR) FileName;
    h = 0;
    for (i=0; i<11; i++) {
        h = (h << 2) ^ p[i];
    }
    for (i=0; i<2; i++) {
        h = (h << 2) ^ p[i];
    }
    return h;
}

STATIC ULONG         _Twinkle = 0;
STATIC LONG64        _LastTwnkTime = 0;
STATIC ULONG         _LastPercent = 0xFFFFFFFF;

BOOLEAN
DisplayTwnkPercent(
    ULONG   percent
    )
{
    BIG_INT currenttime;

#if !defined( _EFICHECK_ )
    NtQuerySystemTime((_LARGE_INTEGER *)&currenttime);
#else
    EfiQuerySystemTime((_LARGE_INTEGER *)&currenttime);
#endif
    // The above clock counts in 1/10,000ths of a second

    if((percent != _LastPercent) ||
       ((currenttime.GetQuadPart() - _LastTwnkTime) >= (6 * 100 * 10000)))
    {
        if(percent > 100) {
            percent = 100;
        }
        if((_Twinkle > 5) || _Verbose) {
            _Twinkle = 0;
        }
        if(_Verbose && (percent == _LastPercent)) {
            return TRUE;
        }
        _LastPercent = percent;
        _LastTwnkTime = currenttime.GetQuadPart();
        if(_pvfMessage) {
            STR  dots[6];

            dots[5] = '\0';
            dots[4] = ' ';
            dots[3] = ' ';
            dots[2] = ' ';
            dots[1] = ' ';
            dots[0] = ' ';
            switch(_Twinkle) {
                case 5:
                default:
                    dots[4] = '.';
                case 4:
                    dots[3] = '.';
                case 3:
                    dots[2] = '.';
                case 2:
                    dots[1] = '.';
                case 1:
                    dots[0] = '.';
                case 0:
                    ;
            }
            if(!_Verbose) {
                _Twinkle++;
            }
            _pvfMessage->Set(MSG_PERCENT_COMPLETE2);
            if (!_pvfMessage->Display("%d%s", percent, &dots[0])) {
                return FALSE;
            }
            if(_Verbose) {
                _pvfMessage->Set(MSG_BLANK_LINE);
                _pvfMessage->Display();
            }

        }
    }

    return TRUE;
}

VOID DoTwinkle(
    VOID
          )
{
    DisplayTwnkPercent(_LastPercent);
    return;
}

VOID DoInsufMemory(
   VOID
          )
{

    if(_pvfMessage) {
        _pvfMessage->Set(MSG_CHK_NO_MEMORY);
        _pvfMessage->Display();
    }
    return;
}

BOOLEAN
FAT_SA::WalkDirectoryTree(
    IN OUT  PEA_INFO        EaInfos,
    IN OUT  PUSHORT         NumEas,
    IN OUT  PBITVECTOR      FatBitMap,
    OUT     PFATCHK_REPORT  Report,
    IN      FIX_LEVEL       FixLevel,
    IN      BOOLEAN         RecoverAlloc,
    IN OUT  PMESSAGE        Message,
    IN      BOOLEAN         Verbose,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine walks all of the files on the volume by traversing
    the directory tree.  In doing so it validates all of the
    directory entries on the disk.  It also verifies the proper
    chaining of all file cluster chains.  This routine also validates
    the integrity of the EA handles for all of the directory entries
    on the disk.

    The FatBitMap is used to find and eliminate cross-links in the file
    system.

Arguments:

    EaInfos             - Supplies the EA information.
    NumEas              - Supplies the number of EA sets.
    FatBitMap           - Supplies a bit map marking all of the clusters
                            currently in use.
    Report              - Returns a FAT CHKDSK report on the files of the disk.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    Verbose             - Supplies whether or not to be verbose.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVISIT_DIR      visit_list;
    ULONG           current_dir;
    PFATDIR         dir;
    FILEDIR         filedir;
    FAT_DIRENT      dirent;
    ULONG           i, j;
    ULONG           clus, next;
    DSTRING         file_path;
    PWSTRING        new_path;
    PWSTRING        current_path;
    ULONG           new_dir;
    DSTRING         filename;
    DSTRING         long_name;
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           new_chain;
    ULONG           cluster_size;
    ULONG           length;
    DSTRING         backslash;
    DSTRING         eafilename;
    DSTRING         eafilename_path;
    DSTRING         tmp_string;
    BOOLEAN         cross_link_detected;
    ULONG           cross_link_prevclus;
    HMEM            tmphmem;
    FILEDIR         tmpfiledir;
    FAT_DIRENT      tmpdirent1;
    FAT_DIRENT      tmpdirent2;
    BOOLEAN         non_zero_dirents;
    HASH_INDEX      file_name_hash_table;
    ULONG           hash_value;
    PULONG          matching_index_array;
    ULONG           matching_index_count;
    BOOLEAN         has_long_entry = FALSE;
    UCHAR           chksum;
    BOOLEAN         broke;
    ULONG           first_long_entry;
    FAT_DIRENT      dirent2;
    ULONG           percent;
    ULONG           allocated_clusters;
    BOOLEAN         processing_ea_file;
    ULONG           old_clus;
    ULONG           new_clus;
    UCHAR           FatType;
    USHORT          numEasLeft = *NumEas;


    DEBUG((D_INFO, (CHAR8*)"Sizeof(INT) %x\n", sizeof(INT)));

    // find no clue for the following assert
    // DebugAssert(sizeof(PUCHAR) <= sizeof(INT));
    DebugAssert(sizeof(USHORT) <= sizeof(INT));
    DebugAssert(sizeof(ULONG  ) <= sizeof(INT));

    visit_list = NULL;

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    if (!backslash.Initialize("\\") ||
        !eafilename.Initialize("EA DATA. SF") ||
        !eafilename_path.Initialize("\\EA DATA. SF")) {

        return FALSE;
    }

    if (!(current_path = NEW DSTRING) ||
        !current_path->Initialize(&backslash)) {

        return FALSE;
    }

    if (!PushVisitDir( &visit_list, 0, current_path )) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    Message->Set(MSG_CHK_CHECKING_FILES);
    Message->Display();

    percent = 0;
    if(!DisplayTwnkPercent(percent)) {
        return FALSE;
    }

    for (;
         PopVisitDir( &visit_list, &current_dir, &current_path );
         DELETE( current_path )) {

        DoTwinkle();

        has_long_entry = FALSE;

        if (current_dir) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat, current_dir)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            if (!filedir.Read()) {
                Message->Set(MSG_BAD_DIR_READ);
                Message->Display();
                return FALSE;
            }

            dir = &filedir;
        } else {

           if ( _dir ) {
              dir = _dir;
              FatType = FAT_TYPE_EAS_OKAY;
           } else {
              dir = _dirF32;
              FatType = FAT_TYPE_FAT32;
           }

        }

        if (!file_name_hash_table.Initialize(dir->QueryNumberOfEntries(), 10)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        for (i = (current_dir ? 2 : 0); ; i++) {

            if (!dirent.Initialize(dir->GetDirEntry(i), FatType) ||
                dirent.IsEndOfDirectory()) {

                if (has_long_entry) {
                    //
                    // There was an orphaned lfn at the end of the
                    // directory.  Erase it now.
                    //

                    Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;
                }

                //
                // This code must make sure that all other directory
                // entries are end of directory entries.
                //
                non_zero_dirents = FALSE;

                for (; dirent.Initialize(dir->GetDirEntry(i),FatType); i++) {

                    if (!dirent.IsEndOfDirectory()) {
                        non_zero_dirents = TRUE;
                        dirent.SetEndOfDirectory();
                    }
                }

                if (non_zero_dirents) {
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_TRAILING_DIRENTS);
                    Message->Display("%W", current_path);

                    Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
                }

                break;
            }

            if (dirent.IsErased()) {

                if (has_long_entry) {

                    //
                    // The preceding lfn is orphaned.  Remove it.
                    //

                    Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;
                }

                continue;
            }

            if (dirent.IsLongEntry()) {

                // skip long name entries; come back to them later

                if (has_long_entry) {
                    // already amid long entry
                    continue;
                }

                // first long entry

                has_long_entry = TRUE;
                first_long_entry = i;
                continue;
            }

            dirent.QueryName(&filename);

            if (has_long_entry) {

                DSTRING lfn;

                //
                // The current entry is short, and we've just finished
                // skipping the associated long entry.  Look back through
                // the long entries, make sure they're okay.
                //

                broke = FALSE;

                chksum = dirent.QueryChecksum();

                for (j = i - 1; j >= first_long_entry; j--) {
                    dirent2.Initialize(dir->GetDirEntry(j),FatType);

                    if (!dirent2.IsLongNameEntry()) {
                        continue;
                    }

                    broke = (dirent2.QueryLongOrdinal() != i - j) ||
                            (dirent2.QueryChecksum() != chksum) ||
                            (LOUSHORT(dirent2.QueryStartingCluster()) != 0);

                    broke = broke || !dirent2.IsWellTerminatedLongNameEntry();

                    if (broke || dirent2.IsLastLongEntry()) {
                        break;
                    }
                }

                broke = broke || (!dirent2.IsLastLongEntry());

#if 0
// We'll elide this code because Win95 isn't this strict and we
// don't want to delete all their lfn's.

                if (!broke && dir->QueryLongName(i, &lfn)) {

                    broke = !dirent.NameHasTilde() &&
                        (dirent.NameHasExtendedChars() ||
                            0 != filename.Stricmp(&lfn)) &&
                        !IsString8Dot3(&lfn);
                }
#endif

                if (broke) {

                    Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                    //
                    // Erase all the long name entries.
                    //

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;

                }

                //
                // Fall into code to check short name.
                //
            }

            DoTwinkle();

            dirent.QueryName(&filename);

            if (!file_path.Initialize(current_path)) {
                return FALSE;
            }

            if (current_dir) {
                if (!file_path.Strcat(&backslash)) {
                    return FALSE;
                }
            }

            if (dir->QueryLongName(i, &long_name) &&
                long_name.QueryChCount() != 0) {

                if (!file_path.Strcat(&long_name)) {
                    return FALSE;
                }

            } else {

                if (!file_path.Strcat(&filename)) {
                    return FALSE;
                }
            }

            if (Verbose && !dirent.IsVolumeLabel()) {
                Message->Set(MSG_CHK_FILENAME);
                Message->Display("%W", &file_path);
            }

            if (!ValidateDirent(&dirent, &file_path, FixLevel, RecoverAlloc,
                                Message, NeedErrorsMessage, FatBitMap,
                                &cross_link_detected, &cross_link_prevclus,
                                &Report->ExitStatus)) {
                return FALSE;
            }

            DoTwinkle();

            if (dirent.IsErased()) {

                //
                // ValidateDirent erased this entry, presumably because it's
                // hosed.  Remove corresponding long name, if any.
                //

                if (has_long_entry) {
                    EraseAssociatedLongName(dir, first_long_entry, i);
                    has_long_entry = FALSE;
                }
                continue;
            }

            //
            // Analyze for duplicate names
            //
            if (!dirent.IsVolumeLabel()) {

                BOOLEAN     renamed = FALSE;
                ULONG       renaming_positions = 0;
                FAT_DIRENT  temp_dirent;
                DSTRING     new_filename;
                BOOLEAN     changes = FALSE;

                if (!CheckAndFixFileName(dir->GetDirEntry(i), &changes)) {
                    Message->Set(MSG_CHK_UNHANDLED_INVALID_NAME);
                    Message->Display("%W%W", &filename, current_path);
                }

                for (;;) {
                    hash_value = ComputeFileNameHashValue(dir->GetDirEntry(i));

                    if (!file_name_hash_table.QueryAndAdd(hash_value,
                                                          i,
                                                          &matching_index_array,
                                                          &matching_index_count)) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }

                    DebugAssert(matching_index_count >= 1);
                    matching_index_count--;

                    if (matching_index_count &&
                        IsFileNameMatch(dir, FatType, i, matching_index_count, matching_index_array)) {

                        file_name_hash_table.RemoveLastEntry(hash_value, i);

                        Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                        renamed = TRUE;
                        if (!RenameFileName(&renaming_positions, dir->GetDirEntry(i))) {

                            if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                                if (!new_filename.Initialize(TEXT("????????.???"))) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            } else
                                temp_dirent.QueryName(&new_filename);   // bugbug: should have return code

                            dofmsg(Message, NeedErrorsMessage);
                            Message->Set(MSG_CHK_RENAMING_FAILURE);
                            Message->Display("%W%W%W", &filename, current_path, &new_filename);

                            if (!filename.Initialize(&new_filename)) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }

                            if (!file_path.Initialize(current_path)) {
                                return FALSE;
                            }

                            if (current_dir) {
                                if (!file_path.Strcat(&backslash)) {
                                    return FALSE;
                                }
                            }

                            if (dir->QueryLongName(i, &long_name) &&
                                long_name.QueryChCount() != 0) {

                                if (!file_path.Strcat(&long_name)) {
                                    return FALSE;
                                }

                            } else {

                                if (!file_path.Strcat(&new_filename)) {
                                    return FALSE;
                                }
                            }

                            break;  // done
                        }

                    } else if (renamed) {

                        if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                            if (!new_filename.Initialize(TEXT("????????.???"))) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }
                        } else
                            temp_dirent.QueryName(&new_filename);   // bugbug: should have return code

                        Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_RENAMED_REPEATED_ENTRY);
                        Message->Display("%W%W%W", &filename, current_path, &new_filename);

                        if (!filename.Initialize(&new_filename)) {
                            Message->Set(MSG_CHK_NO_MEMORY);
                            Message->Display();
                            return FALSE;
                        }

                        if (!file_path.Initialize(current_path)) {
                            return FALSE;
                        }

                        if (current_dir) {
                            if (!file_path.Strcat(&backslash)) {
                                return FALSE;
                            }
                        }

                        if (dir->QueryLongName(i, &long_name) &&
                            long_name.QueryChCount() != 0) {

                            if (!file_path.Strcat(&long_name)) {
                                return FALSE;
                            }

                        } else {

                            if (!file_path.Strcat(&new_filename)) {
                                return FALSE;
                            }
                        }

                        break;  // no more conflict, done

                    } else if (changes) {

                        Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_INVALID_NAME_CORRECTED);
                        Message->Display("%W%W", &filename, current_path);
                        break;  // done

                    } else
                        break;  // done as there is no name conflict

                    DoTwinkle();
                }
            }

            DoTwinkle();

            //
            // Analyze for cross-links.
            //
            if (cross_link_detected) {  // CROSSLINK !!

                Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                // Identify cross linked cluster.

                clus = cross_link_prevclus;

                next = cross_link_prevclus ?
                       _fat->QueryEntry(cross_link_prevclus) :
                       dirent.QueryStartingCluster();

                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_CROSS_LINK);
                Message->Display("%W%d", &file_path, next);

                processing_ea_file = (eafilename_path == file_path);

                if (dirent.IsDirectory()) {

                    DebugAssert(!processing_ea_file);

                    Message->Set(MSG_CHK_DIR_TRUNC);
                    Message->Display();

                    if (clus) {
                        _fat->SetEndOfChain(clus);
                    } else {
                        dirent.SetErased();
                        if (has_long_entry) {
                            EraseAssociatedLongName(dir, first_long_entry, i);
                            has_long_entry = FALSE;
                        }
                        continue;
                    }

                } else {

                    if (!CopyClusters(next, &new_chain, FatBitMap,
                                      FixLevel, Message)) {
                        return FALSE;
                    }

                    if (new_chain) {
                        Message->Set(MSG_CHK_CROSS_LINK_COPY);
                        Message->Display();

                        if (processing_ea_file) {

                            USHORT      j;

                            old_clus = next;
                            new_clus = new_chain;
                            for(;;) {
                                for (j=0; j<*NumEas; j++) {
                                    if (EaInfos[j].PreceedingCn == old_clus) {
                                        EaInfos[j].PreceedingCn = new_clus;
                                    } else if (EaInfos[j].LastCn == old_clus) {
                                        EaInfos[j].LastCn = new_clus;
                                    }
                                }
                                if (_fat->IsEndOfChain(new_clus) || _fat->IsEndOfChain(old_clus)) {
                                    DebugAssert(_fat->IsEndOfChain(new_clus) &&
                                                _fat->IsEndOfChain(old_clus));
                                    break;
                                }
                                old_clus = _fat->QueryEntry(old_clus);
                                new_clus = _fat->QueryEntry(new_clus);
                            }
                        }

                        if (clus) {
                            _fat->SetEntry(clus, new_chain);
                        } else {
                            dirent.SetStartingCluster(new_chain);
                        }

                    } else {

                        Message->Set(MSG_CHK_CROSS_LINK_TRUNC);
                        Message->Display();

                        if (clus) {

                            if (processing_ea_file) {

                                USHORT      j;

                                old_clus = next;
                                for(;;) {
                                    for (j=0; j<*NumEas; j++) {
                                        if (EaInfos[j].LastCn == old_clus) {
                                            numEasLeft = j;
                                            break;
                                        }
                                    }
                                    if (_fat->IsEndOfChain(old_clus))
                                        break;
                                    old_clus = _fat->QueryEntry(old_clus);
                                }
                            }

                            _fat->SetEndOfChain(clus);
                            dirent.SetFileSize(
                                    cluster_size*_fat->QueryLengthOfChain(
                                    dirent.QueryStartingCluster()));

                        } else {
                            numEasLeft = 0;
                            dirent.SetErased();

                            if (has_long_entry) {
                                EraseAssociatedLongName(dir, first_long_entry,
                                    i);
                                has_long_entry = FALSE;
                            }
                        }
                    }
                }
            }

            DoTwinkle();

            if (!ValidateEaHandle(&dirent, current_dir, i, EaInfos, *NumEas,
                                  &file_path, FixLevel, Message,
                                  NeedErrorsMessage)) {
                return FALSE;
            }

            DoTwinkle();

            //
            // Do special stuff if the current entry is a directory.
            //

            if (dirent.IsDirectory()) {

                new_dir = dirent.QueryStartingCluster();

                //
                // Validate the integrity of the directory.
                //

                // Very first make sure it actually has a valid starting clus (check for 0)

                if(!(_fat->IsInRange(new_dir))) {

                    if (dirent.IsDot() ||
                    dirent.IsDotDot()) {

                    // If this happens on the . or .. entry just ignore it as it will
                    // get fixed up later.

                    continue;
                    }

                    Message->Set(MSG_CHK_ERROR_IN_DIR);
                            Message->Display("%W", &file_path);
                            Message->Set(MSG_CHK_CONVERT_DIR_TO_FILE, NORMAL_MESSAGE, TEXT_MESSAGE);
                            Message->Display();
                            if (Message->IsYesResponse(TRUE)) {
                    dirent.ResetDirectory();
                    dirent.SetStartingCluster(0);
                    dirent.SetFileSize(0);
                    }
                    continue;
                }

                // Read the directory.

                if (!tmphmem.Initialize() ||
                    !tmpfiledir.Initialize(&tmphmem, _drive, this, _fat,
                                           new_dir) ||
                    !tmpfiledir.Read()) {
                    Message->Set(MSG_CHK_NO_MEMORY);
                    Message->Display();

                    return FALSE;
                }

                // Check the . and .. entries.

                if (!tmpdirent1.Initialize(tmpfiledir.GetDirEntry(0),FatType) ||
                    !tmpdirent2.Initialize(tmpfiledir.GetDirEntry(1),FatType)) {
                    DebugAbort("GetDirEntry of 0 and 1 failed!");
                    return FALSE;
                }

                if (!tmpdirent1.IsDot() ||
                    !tmpdirent2.IsDotDot() ||
                    !tmpdirent1.IsDirectory() ||
                    !tmpdirent2.IsDirectory()) {

                    Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_ERROR_IN_DIR);
                    Message->Display("%W", &file_path);
                    Message->Set(MSG_CHK_CONVERT_DIR_TO_FILE, NORMAL_MESSAGE, TEXT_MESSAGE);
                    Message->Display();

                    if (Message->IsYesResponse(TRUE)) {
                        dirent.ResetDirectory();
                        dirent.SetFileSize(
                               _fat->QueryLengthOfChain(new_dir)*
                               cluster_size);

                    } else {

                        FreeSpaceInBitmap(dirent.QueryStartingCluster(),
                                          _fat, FatBitMap);

                        dirent.SetErased();

                        if (has_long_entry) {
                            EraseAssociatedLongName(dir, first_long_entry, i);
                            has_long_entry = FALSE;
                        }
                        continue;
                    }

                } else {  // Directory looks valid.

                    if (tmpdirent1.QueryStartingCluster() != new_dir ||
                        tmpdirent2.QueryStartingCluster() != current_dir ||
                        tmpdirent1.QueryFileSize() ||
                        tmpdirent2.QueryFileSize()) {

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_ERRORS_IN_DIR_CORR);
                        Message->Display("%W", &file_path);

                        Report->ExitStatus = CHKDSK_EXIT_ERRS_FIXED;

                        tmpdirent1.SetStartingCluster(new_dir);
                        tmpdirent2.SetStartingCluster(current_dir);
                        tmpdirent1.SetFileSize(0);
                        tmpdirent2.SetFileSize(0);

                        if (FixLevel != CheckOnly && !tmpfiledir.Write()) {
                            DebugAbort("Could not write tmp file dir.");
                            return FALSE;
                        }
                    }

                    // Add the directory to the list of directories
                    // to validate.

                    if (!(new_path = NEW DSTRING) ||
                        !new_path->Initialize(&file_path)) {

                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }

                    if (!PushVisitDir( &visit_list, new_dir, new_path )) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }
                }
            }

            //
            // Generate report stats.
            //

            if (current_dir || !(filename == eafilename)) {
                length = _fat->QueryLengthOfChain(dirent.QueryStartingCluster());
                if (dirent.IsHidden()) {
                    Report->HiddenEntriesCount++;
                    Report->HiddenClusters += length;
                } else if (dirent.IsDirectory()) {
                    Report->DirEntriesCount++;
                    Report->DirClusters += length;
                } else if (!dirent.IsVolumeLabel()) {
                    Report->FileEntriesCount++;
                    Report->FileClusters += length;
                }
            }

            allocated_clusters = _fat->QueryAllocatedClusterCount();

            if (0 == allocated_clusters) {
                allocated_clusters++;   // Prevent divide by 0
            }

            percent = (Report->HiddenClusters + Report->DirClusters +
                      Report->FileClusters) * 100 / allocated_clusters;

            if(!DisplayTwnkPercent(percent)) {
                return FALSE;
            }
            has_long_entry = FALSE;
        }

        file_name_hash_table.DumpHashTable();
#if 0
        //
        // The following line should be moved to REAL_FAT_SA::Write.
        //
        //
        //  The placement of the following line actually touches upon
        //  the philosophical dilemma of what makes a superarea a superarea.
        //  In the good old FAT16/12 days when the root directory is a fixed size
        //  structure and sitting right next to the fat and boot sector, it kind
        //  of makes sense to define the superarea as a run of sectors including the
        //  the root directory. But now that the FAT32 root directory is defined
        //  as a cluster chain, is the superarea still an area (or a run of sectors
        //  as a matter of fact) by including the FAT32 root directory?(Rhetorical
        //  question) Hence I can sort of understand why the following line
        //  is placed where it is originally (but this is an incomplete job
        //  considering the fact that the FAT32 root directory is still part of
        //  the superarea object). So in order to honor the fine tradition of
        //  totally embedding the root directory into the superarea, I have decided
        //  to move the following line to the Write method of the FAT superarea
        //  object. The proper way out of this dilemma is to define the superarea
        //  as a persistent object which is not necessarily a contagious run of
        //  sectors. (I think I get a little bit carried away.)
        //
        if((_dirF32) && !(current_dir)) { //root directory fix
            if (FixLevel != CheckOnly && !_dirF32->Write()) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }
        }
#endif

        if (current_dir) {
            if (FixLevel != CheckOnly && !filedir.Write()) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }
        }
    }

    percent = 100;
    if(!DisplayTwnkPercent(percent)) {
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }
    Message->Set(MSG_CHK_DONE_CHECKING);
    Message->Display();

    *NumEas = numEasLeft;
    _Verbose = FALSE;
    _pvfMessage = NULL;
    return TRUE;
}


BOOLEAN
FAT_SA::ValidateDirent(
    IN OUT  PFAT_DIRENT Dirent,
    IN      PCWSTRING   FilePath,
    IN      FIX_LEVEL   FixLevel,
    IN      BOOLEAN     RecoverAlloc,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage,
    IN OUT  PBITVECTOR  FatBitMap,
    OUT     PBOOLEAN    CrossLinkDetected,
    OUT     PULONG      CrossLinkPreviousCluster,
    OUT     PULONG      ExitStatus
    )
/*++

Routine Description:

    This routine verifies that all components of a directory entry are
    correct.  If the time stamps are invalid then they will be corrected
    to the current time.  If the filename is invalid then the directory
    entry will be marked as deleted.  If the cluster number is out of
    disk range then the directory entry will be marked as deleted.
    Otherwise, the cluster chain will be validated and the length of
    the cluster chain will be compared against the file size.  If there
    is a difference then the file size will be corrected.

    If there are any strange errors then FALSE will be returned.

Arguments:

    Dirent                      - Supplies the directory entry to validate.
    FilePath                    - Supplies the full path name for the directory
                                    entry.
    RecoverAlloc                - Supplies whether or not to recover all
                                    allocated space on the volume.
    Message                     - Supplies an outlet for messages.
    NeedErrorsMessage           - Supplies whether or not an error has
                                    occurred during check only mode.
    FatBitMap                   - Supplies a bitmap marking in use all known
                                    clusters.
    CrossLinkDetected           - Returns TRUE if the file is cross-linked with
                                   another.
    CrossLinkPreviousCluster    - Returns the cluster previous to the
                                    cross-linked one.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   start_clus;
    BOOLEAN changes;
    ULONG   length;
    ULONG   min_file_size;
    ULONG   max_file_size;
    ULONG   clus;
    BIG_INT tmp_big_int;
    ULONG   file_size;
    ULONG   cluster_size;
    BOOLEAN recover_status;

    DebugAssert(CrossLinkDetected);
    DebugAssert(CrossLinkPreviousCluster);

    *CrossLinkDetected = FALSE;

    if (Dirent->IsErased()) {
        return TRUE;
    }

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

// Don't validate names or time stamps anymore.
#if 0

    if (!Dirent->IsValidName()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INVALID_NAME);
        Message->Display("%W", FilePath);
        Dirent->SetErased();
        return TRUE;
    }

    if (!Dirent->IsValidTimeStamp()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INVALID_TIME_STAMP);
        Message->Display("%W", FilePath);
        if (!Dirent->SetTimeStamp()) {
            return FALSE;
        }
    }

#endif

    if (Dirent->IsDirectory() && Dirent->QueryFileSize()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_DIR_HAS_FILESIZE);
        Message->Display("%W", FilePath);
        Dirent->SetFileSize( 0 );
        *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if ((start_clus = Dirent->QueryStartingCluster()) != 0 ) {
        if (!_fat->IsInRange(start_clus) || _fat->IsClusterFree(start_clus)) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_FIRST_UNIT);
            Message->Display("%W", FilePath);

            Dirent->SetErased();
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            return TRUE;
        }

        if (Dirent->IsDirectory() || RecoverAlloc) {
            _fat->ScrubChain(start_clus, &changes);

            if (changes) {
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_LINK);
                Message->Display("%W", FilePath);
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            }

            //
            // Validate the readability of the directory or file
            // in the case that 'RecoverAlloc' is TRUE.
            //
            if (Dirent->IsDirectory()) {
                if (!(recover_status = RecoverChain(&start_clus, &changes))) {
                   Message->Set(MSG_CHK_NO_MEMORY);
                   Message->Display();
                   return FALSE;
                }
            } else if (FixLevel != CheckOnly) {

               // If we check the recover status for directory, why shouldn't we check
               // the recover status for file also? (I added the following check.)
               if (!(recover_status = RecoverChain(&start_clus, &changes, 0, TRUE))) {
                   Message->Set(MSG_CHK_NO_MEMORY);
                   Message->Display();
                   return FALSE;
               }
            } else {
                recover_status = TRUE;
                changes = FALSE;
            }

            if (changes) {
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
                dofmsg(Message, NeedErrorsMessage);
                if (Dirent->IsDirectory()) {
                    if (!start_clus) {
                        Message->Set(MSG_CHK_BAD_DIR);
                        Message->Display("%W", FilePath);
                        Dirent->SetErased();
                        return TRUE;
                    } else {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_DIR);
                        Message->Display("%W", FilePath);
                        Dirent->SetStartingCluster(start_clus);
                    }
                } else {
                    // In the file case, since we're replacing bad clusters
                    // with new ones, start_clus cannot be zero.
                    DebugAssert(start_clus);

                    if (recover_status) {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS);
                        Message->Display("%W", FilePath);
                    } else {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE);
                        Message->Display();
                    }
                    Dirent->SetStartingCluster(start_clus);
                }
            }
        }

        _fat->ScrubChain(start_clus, FatBitMap, &changes,
                         CrossLinkDetected, CrossLinkPreviousCluster);

        if (changes) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_LINK);
            Message->Display("%W", FilePath);
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        // Note here that we know here that start_clus != 0 so length will be
        // at least 1.

        tmp_big_int = length = _fat->QueryLengthOfChain(start_clus);

        tmp_big_int = tmp_big_int * cluster_size;

        if (tmp_big_int.GetHighPart()) {
            if ((tmp_big_int.GetHighPart() != 1) || tmp_big_int.GetLowPart()) {
                //
                // Cluster chain is > 4GB in size, error. Max allowed is 4GB worth
                // of clusters. Note that since cluster size is a power of 2 (since
                // sec/clus and sector_size are both powers of 2) we KNOW that cluster_size
                // evenly divides 4GB.
                //
                clus = start_clus;
                tmp_big_int = cluster_size;
                while(tmp_big_int.GetHighPart() == 0) {
                    clus = _fat->QueryEntry(clus);
                    tmp_big_int += cluster_size;
                }
                _fat->SetEndOfChain(clus);

                // This message is not exactly correct, but saying that the file size
                // is messed up is not totally unreasonable..........

                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_FILE_SIZE);
                Message->Display("%W", FilePath);
                Dirent->SetFileSize(0xFFFFFFFF);
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
            max_file_size = 0xFFFFFFFF;
            min_file_size = (0xFFFFFFFF - cluster_size) + 2;
        } else {
            max_file_size = tmp_big_int.GetLowPart();
            min_file_size = (max_file_size - cluster_size) + 1;
        }

        if (( file_size = Dirent->QueryFileSize()) != 0 ) {
            if (file_size < min_file_size ||
                file_size > max_file_size) {

                //
                // Note that no message is displayed if the
                // file size is less than the allocation--it
                // is just silently corrected.
                //
                if (file_size > max_file_size) {
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_BAD_FILE_SIZE);
                    Message->Display("%W", FilePath);
                }
                Dirent->SetFileSize(max_file_size);
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        } else {
            if (!Dirent->IsDirectory()) {
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_FILE_SIZE);
                Message->Display("%W", FilePath);
                Dirent->SetFileSize(max_file_size);
                *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }
    } else {
        if (Dirent->IsDirectory() && !Dirent->IsDotDot()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_LINK);
            Message->Display("%W", FilePath);
            Dirent->SetErased();
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
            return TRUE;
        }

        if (Dirent->QueryFileSize()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_FILE_SIZE);
            Message->Display("%W", FilePath);
            Dirent->SetFileSize(0);
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    return TRUE;
}


BOOLEAN
FAT_SA::EraseEaHandle(
    IN      PEA_INFO    EaInfos,
    IN      USHORT      NumEasLeft,
    IN      USHORT      NumEas,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine erases the EA handle that references ea set beyond the
    number of ea sets that should be left.

Arguments:

    EaInfos             - Supplies the list of current EA information.
    NumEasLeft          - Supplies the number of EA sets that should be in EaInfos.
    NumEas              - Supplies the total number of EA sets.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM        hmem;
    FILEDIR     filedir;
    FAT_DIRENT  other_dirent;
    USHORT      i;

    for (i=NumEasLeft; i<NumEas; i++) {
        if (EaInfos[i].UserFileEntryCn) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat,
                                    EaInfos[i].UserFileEntryCn) ||
                !filedir.Read() ||
                !other_dirent.Initialize(filedir.GetDirEntry(
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }
        } else {
            if (!other_dirent.Initialize(_dir->GetDirEntry(
            // Default _dir works because FAT 32 won't have EA's on it to validate
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                return FALSE;
            }
        }

        //
        // Do not follow an EA link to an LFN entry. Zeroing the EA handle in an LFN entry
        // destroys name data. The link is probably just invalid
        //
        if (!other_dirent.IsLongNameEntry()) {

            other_dirent.SetEaHandle(0);

            if (EaInfos[i].UserFileEntryCn && FixLevel != CheckOnly &&
                !filedir.Write()) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOLEAN
FAT_SA::ValidateEaHandle(
    IN OUT  PFAT_DIRENT Dirent,
    IN      ULONG       DirClusterNumber,
    IN      ULONG       DirEntryNumber,
    IN OUT  PEA_INFO    EaInfos,
    IN      USHORT      NumEas,
    IN      PCWSTRING   FilePath,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine validates the EA handle in the directory entry 'Dirent'.
    It ensures that it references an actual EA set.  It also ensures
    that it is the only directory entry which references the EA set.

    If several entries try to reference the same EA set then ties will
    be broken based on the 'OwnerFileName' entry in the EA set.

Arguments:

    Dirent              - Supplies the directory entry to validate.
    DirClusterNumber    - Supplies the cluster number of the directory
                          containing the dirent.
    DirEntryNumber      - Supplies the position of the directory entry in
                          the directory.
    EaInfos             - Supplies the list of current EA information.
    NumEas              - Supplies the number of EA sets.
    FilePath            - Supplies the full path name for the directory entry.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          during check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    USHORT      handle;
    DSTRING     wfilename;
    STR         filename[14];
    BOOLEAN     remove_other_handle;
    HMEM        hmem;
    FILEDIR     filedir;
    FAT_DIRENT  other_dirent;


    if (!(handle = Dirent->QueryEaHandle())) {
        return TRUE;
    }
    // The above should exclude any FAT 32 drive.

    if (!EaInfos) {
        NumEas = 0;
    }

    for (i = 0; i < NumEas; i++) {
        if (handle == EaInfos[i].OwnHandle) {
            break;
        }
    }

    if (i == NumEas) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNRECOG_EA_HANDLE);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        return TRUE;
    }

    if (EaInfos[i].UsedCount >= 2) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        return TRUE;
    }

    Dirent->QueryName(&wfilename);
    if (!wfilename.QuerySTR( 0, TO_END, filename, 14)) {
        return FALSE;
    }

    if (EaInfos[i].UsedCount == 0) {
        memcpy(EaInfos[i].UserFileName, filename, 14);
        EaInfos[i].UserFileEntryCn = DirClusterNumber;
        EaInfos[i].UserFileEntryNumber = DirEntryNumber;
        EaInfos[i].UsedCount = 1;
        return TRUE;
    }


    // UsedCount == 1.

    remove_other_handle = FALSE;

    if (!strcmp(filename, EaInfos[i].OwnerFileName)) {

        remove_other_handle = TRUE;

        if (!strcmp(EaInfos[i].UserFileName,
                    EaInfos[i].OwnerFileName)) {

            EaInfos[i].UsedCount = 2;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_SHARED_EA);
            Message->Display("%W", FilePath);
            Dirent->SetEaHandle(0);
        }

    } else {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);

        if (strcmp(EaInfos[i].UserFileName,
                   EaInfos[i].OwnerFileName)) {

            EaInfos[i].UsedCount = 2;
            remove_other_handle = TRUE;
        }
    }


    if (remove_other_handle) {

        if (EaInfos[i].UserFileEntryCn) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat,
                                    EaInfos[i].UserFileEntryCn) ||
                !filedir.Read() ||
                !other_dirent.Initialize(filedir.GetDirEntry(
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }
        } else {
            if (!other_dirent.Initialize(_dir->GetDirEntry(
                // Default _dir works because FAT 32 won't have EA's on it to validate
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                return FALSE;
            }
        }

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        //
        // Do not follow an EA link to an LFN entry. Zeroing the EA handle in an LFN entry
        // destroys name data. The link is probably just invalid
        //
        if (!other_dirent.IsLongNameEntry()) {
            other_dirent.SetEaHandle(0);

            if (EaInfos[i].UserFileEntryCn && FixLevel != CheckOnly &&
                !filedir.Write()) {

                return FALSE;
            }
        }
        strcpy(EaInfos[i].UserFileName, filename);
        EaInfos[i].UserFileEntryCn = DirClusterNumber;
        EaInfos[i].UserFileEntryNumber = DirEntryNumber;
    }

    return TRUE;
}


BOOLEAN
FAT_SA::CopyClusters(
    IN      ULONG       SourceChain,
    OUT     PULONG      DestChain,
    IN OUT  PBITVECTOR  FatBitMap,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine copies the cluster chain beginning at 'SourceChain'
    to a free portion of the disk.  The beginning of the copied chain
    will be returned in 'DestChain'.  If there isn't enough free space
    on the disk to copy the chain then 'DestChain' will return 0.

Arguments:

    SourceChain - Supplies the chain to copy.
    DestChain   - Returns the copy of the chain.
    FatBitMap   - Supplies the orphan and cross-link bitmap.
    FixLevel    - Supplies the CHKDSK fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           src, dst;
    BOOLEAN         changes;
    ULONG           clus;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    if (!(*DestChain = _fat->AllocChain(
                       _fat->QueryLengthOfChain(SourceChain)))) {
        return TRUE;
    }

    changes = FALSE;
    if (FixLevel != CheckOnly && !RecoverChain(DestChain, &changes, 0, TRUE)) {
        if (*DestChain) {
            _fat->FreeChain(*DestChain);
        }
        *DestChain = 0;
        return TRUE;
    }

    if (IsCompressed() && !AllocSectorsForChain(*DestChain)) {
        _fat->FreeChain(*DestChain);
        *DestChain = 0;
        return TRUE;
    }

    // Mark the new chain as "used" in the FAT bitmap.
    for (clus = *DestChain;
         !_fat->IsEndOfChain(clus);
         clus = _fat->QueryEntry(clus)) {

        FatBitMap->SetBit(clus);
    }
    FatBitMap->SetBit(clus);

    src = SourceChain;
    dst = *DestChain;
    for (;;) {
        if (!cluster.Initialize(&hmem, _drive, this, _fat, src, 1)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        cluster.Read();

        if (!cluster.Initialize(&hmem, _drive, this, _fat, dst, 1)) {
            return FALSE;
        }

        if (FixLevel != CheckOnly && !cluster.Write()) {
            return FALSE;
        }

        if (_fat->IsEndOfChain(src)) {
            break;
        }

        src = _fat->QueryEntry(src);
        dst = _fat->QueryEntry(dst);
    }

    return TRUE;
}


BOOLEAN
FAT_SA::PurgeEaFile(
    IN      PEA_INFO    EaInfos,
    IN      USHORT      NumEas,
    IN OUT  PBITVECTOR  FatBitMap,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
/*++

Routine Description:

    This routine is executed after the directory tree is walked.  Stored,
    in the EaInfos array, is information concerning which EAs get used
    and by how many files.

    If an EA set is not used, or is used by more than one file, then this
    routine will eliminate it from the EA file.

Arguments:

    EaInfos             - Supplies an array of EA information.
    NumEas              - Supplies the number of EA sets.
    FatBitMap           - Supplies the FAT cross-link detection bitmap.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occured
                          in check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG        i;
    EA_SET      easet;
    HMEM        hmem;
    PEA_HDR     eahdr;
    ULONG       clus;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    for (i = NumEas - 1; i >= 0; i--) {

        if (EaInfos[i].UsedCount != 1) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_UNUSED_EA_SET);
            Message->Display("%d", EaInfos[i].OwnHandle);

            // Mark the FAT entries of the removed chain as "not claimed",
            // for the purposes of orphan recovery.

            for (clus = _fat->QueryEntry(EaInfos[i].PreceedingCn);
                 clus != EaInfos[i].LastCn;
                 clus = _fat->QueryEntry(clus)) {

                FatBitMap->ResetBit(clus);

            }
            FatBitMap->ResetBit(clus);


            //
            // Remove the unused EA chain from the EA file.  Here we also
            // have to examine subsequent EaInfos; we may have to modify
            // several PreceedingCn entries if several adjacent EA chains
            // have been removed.
            //

            _fat->RemoveChain(EaInfos[i].PreceedingCn,
                              EaInfos[i].LastCn);

            for (LONG j = i + 2; j < NumEas; j++) {
                if (EaInfos[j].PreceedingCn == EaInfos[i + 1].PreceedingCn) {

                    EaInfos[j].PreceedingCn = EaInfos[i].PreceedingCn;

                } else {
                    break;
                }
            }

            EaInfos[i + 1].PreceedingCn = EaInfos[i].PreceedingCn;

        } else if (strcmp(EaInfos[i].OwnerFileName,
                          EaInfos[i].UserFileName)) {

            if (!easet.Initialize(&hmem, _drive, this, _fat,
                                  _fat->QueryEntry(EaInfos[i].PreceedingCn),
                                  1) ||
                !easet.Read() ||
                !(eahdr = easet.GetEaSetHeader())) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_NEW_OWNER_NAME);
            Message->Display("%d%s%s", EaInfos[i].OwnHandle,
                    eahdr->OwnerFileName, EaInfos[i].UserFileName);

            memcpy(eahdr->OwnerFileName, EaInfos[i].UserFileName, 14);

            if (FixLevel != CheckOnly && !easet.Write()) {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOLEAN
FAT_SA::RecoverOrphans(
    IN OUT  PBITVECTOR     FatBitMap,
    IN      FIX_LEVEL      FixLevel,
    IN OUT  PMESSAGE       Message,
    IN OUT  PBOOLEAN       NeedErrorsMessage,
    IN OUT  PFATCHK_REPORT Report,
       OUT  PBOOLEAN       Changes
    )
/*++

Routine Description:

    This routine examines the file system for cluster chains which are
    not claimed by any file.  These 'orphans' will then be recovered in
    a subdirectory of the root or removed from the system.

Arguments:

    FatBitMap           - Supplies a bit map marking all currently used
                            clusters.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occured
                            in check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    //
    // Why the below define placing an artificial limit on the number of orphans?
    // 1.) The format for the file names is "FILE%04d.CHK" starting at 0 so we can
    //     do only 0-9999 before generating a duplicate file name.
    // 2.) Since CHKDSK recovers all of the orphans into a single directory this prevents
    //     it from making a directory with a HUGE file count in it (which is a performance
    //     issue).
    //
#if defined( _AUTOCHECK_ ) || defined( _EFICHECK_ )
    // Due to memory constraints, the maximum number of orphans to
    // recover is less for Autochk than for run-time Chkdsk.
    //
    // BUG BUG this is the old setting for this, the above comment makes no
    //         sense because there is no in memory allocation that I can find
    //         which is effected by this setting. This may have been a HACK fix
    //         for an overflow of the memory heap (which is fatal when there
    //         is no paging file). This problem no longer exists because of
    //         the paging memory heap tracking that has been added to AUTOCHK.
    //         ARR
    //
    //  CONST ULONG maximum_orphans = 1000;
    //
    CONST ULONG maximum_orphans = 10000;
#else
    CONST ULONG maximum_orphans = 10000;
#endif

    ULONG       i;
    ULONG       clus;
    BOOLEAN     changes;
    HMEM        hmem;
    FILEDIR     found_dir;
    STR         found_name[14];
    DSTRING     wfound_name;
    STR         filename[14];
    FAT_DIRENT  dirent;
    ULONG       found_cluster;
    ULONG       orphan_count;
    ULONG   orphan_rec_clus_cnt;
    ULONG       cluster_size;
    ULONG       found_length;
    ULONG       next;
    PUCHAR      orphan_track;
    ULONG       cluster_count;
    ULONG       num_orphans;
    ULONG       num_orphan_clusters;
    DSTRING     tmp_string;
    BITVECTOR   tmp_bitvector;
    BOOLEAN     tmp_bool;
    ULONG       tmp_ulong;
    BIG_INT     tmp_big_int;
    MSGID       message_id;
    BOOLEAN KSize;

    cluster_count = QueryClusterCount();

    if (!(orphan_track = NEW UCHAR[cluster_count])) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    memset(orphan_track, 0, cluster_count);

    if (!tmp_bitvector.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    num_orphans = 0;
    num_orphan_clusters = 0;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (!_fat->IsClusterFree(i) &&
            !FatBitMap->IsBitSet(i) &&
            !_fat->IsClusterBad(i) &&
            !_fat->IsClusterReserved(i)) {

            num_orphans++;

            tmp_bitvector.ResetAll();

            _fat->ScrubChain(i, &tmp_bitvector, &changes,
                             &tmp_bool, &tmp_ulong);

            if (changes) {
                *Changes = TRUE;
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_CHK_BAD_LINKS_IN_ORPHANS);
                Message->Display("%d", i);
            }

            num_orphan_clusters++;

            clus = i;
            while (!_fat->IsEndOfChain(clus)) {
                next = _fat->QueryEntry(clus);

                if (orphan_track[next] == 1) {
                    num_orphans--;
                    orphan_track[next] = 2;
                    break;
                }

                if (FatBitMap->IsBitSet(next)) {   // CROSSLINK !!

                    *Changes = TRUE;
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_CROSS_LINKED_ORPHAN);
                    Message->Display("%d", clus);

                    _fat->SetEndOfChain(clus);

                    break;
                }

                num_orphan_clusters++;

                FatBitMap->SetBit(next);
                orphan_track[next] = 2;

                clus = next;
            }
            FatBitMap->SetBit(i);
            orphan_track[i] = 1;
        }
    }


    // Now scan through the secondary pointers in search of orphans.

    changes = FALSE;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (orphan_track[i]) {
            changes = TRUE;
            break;
        }
    }

    if (!changes) {
        // No orphans to recover.
        return TRUE;
    }

    // Compute whether reporting size in bytes or kilobytes
    //
    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility
    //
    tmp_ulong = cluster_count - FirstDiskCluster;
    tmp_big_int = cluster_size;
    tmp_big_int = tmp_big_int * tmp_ulong;
    if (tmp_big_int.GetHighPart() || (tmp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        KSize = TRUE;
    } else {
        KSize = FALSE;
    }

    *Changes = TRUE;
    dofmsg(Message, NeedErrorsMessage);
    Message->Set(MSG_CONVERT_LOST_CHAINS, NORMAL_MESSAGE, TEXT_MESSAGE);
    Message->Display();

    if (!Message->IsYesResponse(TRUE)) {

        if (FixLevel != CheckOnly) {

            for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
                if (orphan_track[i] == 1) {
                    _fat->FreeChain(i);
                }
            }
            if (KSize) {
                message_id = MSG_KILOBYTES_FREED;
            } else {
                message_id = MSG_BYTES_FREED;
            }
        } else {
            if (KSize) {
                message_id = MSG_KILOBYTES_WOULD_BE_FREED;
            } else {
                message_id = MSG_BYTES_WOULD_BE_FREED;
            }
        }

        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
        }
        Message->Set(message_id);
        Message->Display("%d", tmp_ulong);

        return TRUE;
    }


    // Set up for orphan recovery.


    // Establish "FOUND.XXX" directory.
    for (i = 0; i < 1000; i++) {
        sprintf(found_name, "FOUND.%03d", i);
        if (!wfound_name.Initialize(found_name)) {
            return FALSE;
        }

        if (_dir && !_dir->SearchForDirEntry(&wfound_name)) {

            break;

        } else if (_dirF32 && !_dirF32->SearchForDirEntry(&wfound_name)) {

            break;

        }


    }

    if (i == 1000) {

        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
        Message->Set(message_id);
        Message->Display("%d%d", tmp_ulong,
                                 num_orphans);
        return TRUE;
    }

    found_length = ((min(num_orphans,maximum_orphans)*BytesPerDirent - 1)/cluster_size + 1);

    if (!(found_cluster = _fat->AllocChain(found_length)) &&
        !(found_cluster = _fat->AllocChain(found_length = 1))) {

        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
        Message->Set(message_id);
        Message->Display("%d%d", tmp_ulong,
                                 num_orphans);
        return TRUE;
    }

    // Check the chain.
    changes = FALSE;
    if (FixLevel != CheckOnly &&
        !RecoverChain(&found_cluster, &changes, 0, TRUE)) {

        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
        Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                 num_orphans);
        return TRUE;
    }

    if (!hmem.Initialize() ||
        !found_dir.Initialize(&hmem, _drive, this, _fat, found_cluster)) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        DebugAbort( "Initialization failed" );
        return FALSE;
    }

    // Allocate space for the cluster chain in the sector heap (fat_db)

    if (IsCompressed() && !AllocSectorsForChain(found_cluster)) {
        _fat->FreeChain(found_cluster);
        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();

        return TRUE;
    }

    memset(hmem.GetBuf(), 0, (UINT) hmem.QuerySize());

    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (_dir) {
       _fat_dir = _dir;
       FatType = FAT_TYPE_EAS_OKAY;
    }
    else {
       _fat_dir = _dirF32;
       FatType = FAT_TYPE_FAT32;
    }
    if (!dirent.Initialize(_fat_dir->GetFreeDirEntry(),FatType)) {
        Message->Set(MSG_NO_ROOM_IN_ROOT);
        Message->Display();
        Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
        Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                 num_orphans);
        return TRUE;
    }

    dirent.Clear();

    if (!dirent.SetName(&wfound_name)) {
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        return FALSE;
    }

    dirent.SetStartingCluster(found_cluster);

    if(_dirF32) {
        if (FixLevel != CheckOnly && !_dirF32->Write()) {
                return FALSE;
        }
    }

    if (!dirent.Initialize(found_dir.GetDirEntry(0),FatType)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    dirent.Clear();

    if (!tmp_string.Initialize(".")) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!dirent.SetName(&tmp_string)) {
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        return FALSE;
    }

    dirent.SetStartingCluster(found_cluster);

    if (!dirent.Initialize(found_dir.GetDirEntry(1),FatType)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    dirent.Clear();

    if (!tmp_string.Initialize("..")) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!dirent.SetName(&tmp_string)) {
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        return FALSE;
    }

    dirent.SetStartingCluster(0);

    // OK, now let's recover those orphans.

    orphan_rec_clus_cnt = orphan_count = 0;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (orphan_track[i] != 1) {
            continue;
        }
        if (orphan_count == maximum_orphans) {
            Message->Set(MSG_TOO_MANY_ORPHANS);
            Message->Display();
            break;
        }

        if (!dirent.Initialize(found_dir.GetFreeDirEntry(), FatType)) {
            if (_fat->ReAllocChain(found_cluster, ++found_length)
                    != found_length)  {
                Message->Set(MSG_ORPHAN_DISK_SPACE);
                Message->Display();
                tmp_big_int = cluster_size;
                tmp_big_int = tmp_big_int * num_orphan_clusters;
                if (KSize) {
                    tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
                    message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
                } else {
                    tmp_ulong = tmp_big_int.GetLowPart();
                    message_id = MSG_WOULD_BE_RECOVERED_FILES;
                }
                Message->Set(message_id);
                Message->Display("%d%d", tmp_ulong,
                                         num_orphans);
                break;
            }

//XXX: FATDB: need to get sectors for found_cluster + realloc.

            changes = FALSE;
            if (FixLevel != CheckOnly &&
                !RecoverChain(&found_cluster, &changes, 0, TRUE)) {

                Message->Set(MSG_ORPHAN_DISK_SPACE);
                Message->Display();
                tmp_big_int = cluster_size;
                tmp_big_int = tmp_big_int * num_orphan_clusters;
                if (KSize) {
                    tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
                    message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
                } else {
                    tmp_ulong = tmp_big_int.GetLowPart();
                    message_id = MSG_WOULD_BE_RECOVERED_FILES;
                }
                Message->Set(message_id);
                Message->Display("%d%d", tmp_ulong,
                                         num_orphans);
                return TRUE;
            }

            if (FixLevel != CheckOnly && !found_dir.Write()) {
                return FALSE;
            }

            if (!hmem.Initialize() ||
                !found_dir.Initialize(&hmem, _drive, this, _fat,
                                      found_cluster) ||
                !found_dir.Read()) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
                Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                         num_orphans);
                return TRUE;
            }

            if (!dirent.Initialize(found_dir.GetDirEntry(2 + orphan_count), FatType))
            {
                return FALSE;
            }

            dirent.SetEndOfDirectory();

            if (!dirent.Initialize(found_dir.GetFreeDirEntry(),FatType))
            {
                return FALSE;
            }
        }

        sprintf(filename, "FILE%04d.CHK", orphan_count);

        if (!tmp_string.Initialize(filename)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        dirent.Clear();

        if (!dirent.SetName(&tmp_string)) {
            return FALSE;
        }

        if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
            !dirent.SetLastAccessTime()) {
            return FALSE;
        }

        dirent.SetStartingCluster(i);
        dirent.SetFileSize(cluster_size*_fat->QueryLengthOfChain(i));

        orphan_count++;
        orphan_rec_clus_cnt += _fat->QueryLengthOfChain(i);
    }

    // Set all dirents past the orphan count to end of directory.

    for (i = 2 + orphan_count; dirent.Initialize(found_dir.GetDirEntry(i),FatType); i++)
    {
        dirent.SetEndOfDirectory();
    }

    if (FixLevel != CheckOnly && !found_dir.Write()) {
        return FALSE;
    }

    if(FixLevel == CheckOnly) {
        if (KSize) {
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
    } else {
        if (KSize) {
            message_id = MSG_KILOBYTES_IN_RECOVERED_FILES;
        } else {
            message_id = MSG_RECOVERED_FILES;
        }

        // Add the recovered data to the report totals

        Report->FileClusters += orphan_rec_clus_cnt;
        Report->FileEntriesCount += orphan_count;
        Report->DirClusters += found_length;
        Report->DirEntriesCount++;
    }
    tmp_big_int = cluster_size;
    tmp_big_int = tmp_big_int * num_orphan_clusters;
    if (KSize) {
        tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
    } else {
        tmp_ulong = tmp_big_int.GetLowPart();
    }
    Message->Set(message_id);

    Message->Display("%d%d", tmp_ulong,
                             num_orphans);

    return TRUE;
}


BOOLEAN
FAT_SA::AllocSectorsForChain(
    ULONG ChainHead
    )
/*++

Routine Description:

    When VerifyAndFix needs to allocate a cluster chain in order
    to create a new directory (such as \FOUND.000), it also needs to
    allocate space in the sector heap for data blocks for those
    clusters.  This routine does that.

Arguments:

    ChainHead - a cluster chain; data blocks are allocated for each
                cluster in this chain.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure - not enough disk space

--*/
{
    ULONG   clus;
    ULONG   next;

    clus = ChainHead;
    for (;;) {
        if (!AllocateClusterData(clus,
                                 (UCHAR)QuerySectorsPerCluster(),
                                 FALSE,
                                 (UCHAR)QuerySectorsPerCluster())) {
            break;
        }

        if (_fat->IsEndOfChain(clus)) {
            return TRUE;
        }

        clus = _fat->QueryEntry(clus);
    }

    // Error: not enough disk space. XXX

    // Free the sectors we already allocated

    while (ChainHead != clus) {
        FreeClusterData(ChainHead);
        next = _fat->QueryEntry(ChainHead);
        _fat->SetClusterFree(ChainHead);
        ChainHead = next;
    }

    return FALSE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
FAT_SA::RecoverFreeSpace(
    IN OUT  PMESSAGE    Message
    )
{
    return TRUE;
}

#else // _SETUP_LOADER_ not defined

BOOLEAN
FAT_SA::RecoverFreeSpace(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine checks all of the space marked free in the FAT for
    bad clusters.  If any clusters are bad they are marked bad in the
    FAT.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       clus, length, max_length;
    ULONG       start_sector, num_sectors, i;
    NUMBER_SET  bad_sectors;
    LBN         lbn;
    ULONG       percent_complete;
    ULONG       num_checked, total_to_check;

    Message->Set(MSG_CHK_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);
    Message->Display();

    _pvfMessage = Message;
    percent_complete = 0;
    if(!DisplayTwnkPercent(percent_complete)) {
        _pvfMessage = NULL;
        return FALSE;
    }

    num_checked = 0;
    total_to_check = _fat->QueryFreeClusters();
    max_length = QueryClusterCount()/20 + 1;
    for (clus = FirstDiskCluster; _fat->IsInRange(clus); clus++) {

        for (length = 0; _fat->IsInRange(clus + length) &&
                         _fat->IsClusterFree(clus + length) &&
                         length < max_length; length++) {
        }

        if (length) {

            start_sector = QueryStartDataLbn() +
                           (clus - FirstDiskCluster)*QuerySectorsPerCluster();
            num_sectors = length*QuerySectorsPerCluster();

            if (!bad_sectors.Initialize() ||
                !_drive->Verify(start_sector, num_sectors, &bad_sectors)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                _pvfMessage = NULL;
                return FALSE;
            }

            for (i = 0; i < bad_sectors.QueryCardinality(); i++) {
                lbn = bad_sectors.QueryNumber(i).GetLowPart();
                _fat->SetClusterBad(((lbn - QueryStartDataLbn())/
                                    QuerySectorsPerCluster()) +
                                    FirstDiskCluster );
            }

            clus += length - 1;
            num_checked += length;

            if (100*num_checked/total_to_check > percent_complete) {
                percent_complete = 100*num_checked/total_to_check;
            }
            if (!DisplayTwnkPercent(percent_complete)) {
                _pvfMessage = NULL;
                return FALSE;
            }
        }
    }

    percent_complete = 100;
    if(!DisplayTwnkPercent(percent_complete)) {
        _pvfMessage = NULL;
        return FALSE;
    }

    Message->Set(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);
    Message->Display();

    _pvfMessage = NULL;

    return TRUE;
}

#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\fatsa.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    fatsa.cxx

Environment:

        ULIB, User Mode

--*/

#include "pch.cxx"

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "cmem.hxx"
#include "error.hxx"
#include "rtmsg.h"
#include "drive.hxx"


#if !defined( _EFICHECK_ )
extern "C" {
#include <parttype.h>
}
#endif // _EFICHECK_

#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_) && !defined( _EFICHECK_ )
#include "timeinfo.hxx"
#endif


// Control-C handling is not necessary for autocheck.
#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_) && !defined( _EFICHECK_ )

#include "keyboard.hxx"

#endif

#define CSEC_FAT32MEG                   65536
#define CSEC_FAT16BIT                   32680
#define CSEC_FAT32BIT                  (1024*1024)


#define MIN_CLUS_BIG    4085    // Minimum clusters for a big FAT.
#define MAX_CLUS_BIG    65525   // Maximum + 1 clusters for big FAT.

#define MIN_CLUS_FAT32  65536




DEFINE_EXPORTED_CONSTRUCTOR( FAT_SA, SUPERAREA, UFAT_EXPORT );

VOID
FAT_SA::Construct (
        )
/*++

Routine Description:

    Constructor for FAT_SA.

Arguments:

    None.

Return Value:

        None.

--*/
{
    _fat = NULL;
    _dir = NULL;
    _dirF32 = NULL;
    _hmem_F32 = NULL;

}


UFAT_EXPORT
FAT_SA::~FAT_SA(
    )
/*++

Routine Description:

    Destructor for FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

BOOLEAN
FAT_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine runs through the clusters for the file described by
    'FileName' and takes out bad sectors.

Arguments:

    FullPathFileName    - Supplies a full path name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    HMEM        hmem;
    ULONG       clus;
    BOOLEAN     changes;
    PFATDIR     fatdir;
    BOOLEAN     need_delete;
    FAT_DIRENT  dirent;
    ULONG       old_file_size;
    ULONG       new_file_size;

    if ((clus = QueryFileStartingCluster(FullPathFileName,
                                         &hmem,
                                         &fatdir,
                                         &need_delete,
                                         &dirent)) == 1) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", FullPathFileName);
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (clus == 0) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", FullPathFileName);
        return FALSE;
    }

    if (dirent.IsDirectory()) {
        old_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        old_file_size = dirent.QueryFileSize();
    }

    if (!RecoverChain(&clus, &changes)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (dirent.IsDirectory() || changes) {
        new_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        new_file_size = old_file_size;
    }

    if (changes) {


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ ) && !defined( _EFICHECK_ )

        // Disable contol-C handling and

        if (!KEYBOARD::EnableBreakHandling()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

#endif


        // Lock the drive in preparation for writes.

        if (!_drive->Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

        dirent.SetStartingCluster(clus);

        dirent.SetFileSize(new_file_size);

        if (!fatdir->Write()) {
            return FALSE;
        }

        if (!Write(Message)) {
            return FALSE;
        }


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ ) && !defined( _EFICHECK_ )

        KEYBOARD::DisableBreakHandling();

#endif


    }

    Message->Set(MSG_RECOV_BYTES_RECOVERED);
    Message->Display("%d%d", new_file_size, old_file_size);


    if (need_delete) {
        DELETE(fatdir);
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


SECTORCOUNT
FAT_SA::QueryFreeSectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number of unused sectors on disk.

Arguments:

    None.

Return Value:

    The number of free sectors on disk.

--*/
{
    if (!_fat) {
        perrstk->push(ERR_NOT_READ, QueryClassId());
        return 0;
    }

    return _fat->QueryFreeClusters()*QuerySectorsPerCluster();
}


FATTYPE
FAT_SA::QueryFatType(
    ) CONST
/*++

Routine Description:

    This routine computes the FATTYPE of the FAT for this volume.

Arguments:

    None.

Return Value:

    The FATTYPE for the FAT.

--*/
{
    return _ft;
}



#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_) && !defined( _EFICHECK_ )

BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label
    ) CONST
/*++

Routine Description:

    This routine queries the label from the FAT superarea.
    If the label is not present then 'Label' will return the null-string.
    If the label is invalid then FALSE will be returned.

Arguments:

    Label   - Returns a volume label.

Return Value:

    FALSE   - The label is invalid.
    TRUE    - The label is valid.

--*/
{
    return QueryLabel(Label, NULL);
}


BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label,
    OUT PTIMEINFO   TimeInfo
    ) CONST
/*++

Routine Description:

    This routine queries the label from the FAT superarea.
    If the label is not present then 'Label' will return the null-string.
    If the label is invalid then FALSE will be returned.

Arguments:

    Label   - Returns a volume label.

Return Value:

    FALSE   - The label is invalid.
    TRUE    - The label is valid.

--*/
{
    INT         i;
    FAT_DIRENT  dirent;
    FILETIME    TimeStamp;
    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (!_dirF32) {

        DebugAssert(_dir);
        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;

    } else {

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;
    }

    for (i = 0; ; i++) {
        if (!dirent.Initialize(_fat_dir->GetDirEntry(i), FatType) ||
            dirent.IsEndOfDirectory()) {
            return Label->Initialize("");
        }

        if (!dirent.IsErased() && dirent.IsVolumeLabel()) {
            break;
        }
    }

    dirent.QueryName(Label);

    if ( TimeInfo ) {
        return ( dirent.QueryLastWriteTime( (LARGE_INTEGER *)&TimeStamp ) &&
                 TimeInfo->Initialize( &TimeStamp ) );
    }

    return TRUE;
}

#else // _AUTOCHECK_ or _SETUP_LOADER_ is defined

BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label
    ) CONST
{
    INT         i;
    FAT_DIRENT  dirent;

    PFATDIR     _fat_dir;

    if (!_dirF32) {

        DebugAssert(_dir);
        _fat_dir = _dir;

    } else {

        _fat_dir = _dirF32;
    }

    for (i = 0; ; i++) {
        if (!dirent.Initialize(_fat_dir->GetDirEntry(i)) ||
            dirent.IsEndOfDirectory()) {
            return Label->Initialize("");
        }

        if (!dirent.IsErased() && dirent.IsVolumeLabel()) {
            break;
        }
    }

    dirent.QueryName(Label);

    return TRUE;
}


#endif // _AUTOCHECK_


BOOLEAN
FAT_SA::SetLabel(
    IN  PCWSTRING   NewLabel
    )
/*++

Routine Description:

    This routine sets the label for a FAT partition.

Arguments:

    NewLabel    - Supplies the new volume label.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FAT_DIRENT  dirent;
    INT         i;
    DSTRING     label;
    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (!_dir) {

        if (!_dirF32) {
            return FALSE;
        }

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;

    } else {
        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;
    }

    if (!label.Initialize(NewLabel)) {
        return FALSE;
    }

    if (!label.Strupr()) {
        return FALSE;
    }

    if (!IsValidString(&label)) {
        return FALSE;
    }

    for (i = 0; dirent.Initialize(_fat_dir->GetDirEntry(i), FatType); i++) {

        if (dirent.IsEndOfDirectory()) {
            break;
        }

        if (dirent.IsErased()) {
            continue;
        }

        if (dirent.IsVolumeLabel()) {
            if (!label.QueryChCount()) {
                dirent.SetErased();
                return TRUE;
            }

            return (BOOLEAN) (dirent.SetLastWriteTime() &&
                              dirent.SetName(&label));
        }
    }

    if (!label.QueryChCount()) {
        return TRUE;
    }

    if (!dirent.Initialize(_fat_dir->GetFreeDirEntry(), FatType)) {
        return FALSE;
    }

    dirent.Clear();
    dirent.SetVolumeLabel();

    return (BOOLEAN) (dirent.SetLastWriteTime() && dirent.SetName(&label));
}


UFAT_EXPORT
ULONG
FAT_SA::QueryFileStartingCluster(
    IN  PCWSTRING   FullPathFileName,
    OUT PHMEM       Hmem,
    OUT PPFATDIR    Directory,
    OUT PBOOLEAN    DeleteDirectory,
    OUT PFAT_DIRENT DirEntry
    )
/*++

Routine Description:

    This routine computes the starting cluster number of the file described
    by 'FileName' by tracing through the directories leading to the file.

Arguments:

    FullPathFileName    - Supplies a full path file name that starts with
                            a '\' (i.e. no drive spec).

Return Value:

    The starting cluster for the file or 1 if the file is not found or
    0xFFFFFFFF if there was an error.

--*/
{
    CHNUM       i, j, l;
    DSTRING     component;
    ULONG       clus;
    FAT_DIRENT  the_dirent;
    PFILEDIR    filedir;
    PFAT_DIRENT dirent;
    HMEM        hmem;
    PFATDIR        _fat_dir;
    UCHAR        FatType;

    DebugAssert(_dir || _dirF32);

    if (_dir) {

        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;

    } else {

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;
    }

    DebugAssert(_fat);

    filedir = NULL;

    if (!Hmem) {
        Hmem = &hmem;
    }

    if (DirEntry) {
        dirent = DirEntry;
    } else {
        dirent = &the_dirent;
    }

    l = FullPathFileName->QueryChCount();

    for (i = 0; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {

        /* NOTHING */
    }

    if (i == l) {
        return 0xFFFFFFFF;
    }

    if (i == l - 1) { // root directory
        return 0;
    }

    j = ++i;
    for (; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {
        /* NOTHING */
    }

    if (!component.Initialize(FullPathFileName, j, i - j) ||
        !component.Strupr()) {
        return 1;
    }

    if (!dirent->Initialize(_fat_dir->SearchForDirEntry(&component), FatType)) {
        return 1;
    }

    if (!(clus = dirent->QueryStartingCluster())) {
        return 0;
    }

    while (i < l) {

        if (!filedir &&
            !(filedir = NEW FILEDIR)) {
            return 0xFFFFFFFF;
        }

        if (!Hmem->Initialize() ||
            !filedir->Initialize(Hmem, _drive, this, _fat, clus)) {
            return 0xFFFFFFFF;
        }

        if (!filedir->Read()) {
            return 1;
        }

        j = ++i;
        for (; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {
        }

        if (!component.Initialize(FullPathFileName, j, i - j) ||
            !component.Strupr()) {
            return 0xFFFFFFFF;
        }

        if (!dirent->Initialize(filedir->SearchForDirEntry(&component), FatType))
        {
            return 1;
        }

        if (!(clus = dirent->QueryStartingCluster())) {
            return 1;
        }
    }

    if (Directory) {
        if (filedir) {
            *Directory = filedir;
            if (DeleteDirectory) {
                *DeleteDirectory = TRUE;
            }
        } else {
            *Directory = _dir;
            if (DeleteDirectory) {
                *DeleteDirectory = FALSE;
            }
        }
    } else {
        DELETE(filedir);
    }

    return clus;
}


VOID
FAT_SA::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the local data in the fat super area.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_fat);
    DELETE(_dir);
    DELETE(_dirF32);

}


FATTYPE
FAT_SA::ComputeFatType(
    ) CONST
/*++

Routine Description:

    Given the total number of clusters on the disk, this routine computes
    whether the FAT entries will be 12, 16, or 32 bits each.

Arguments:

    ClusterCount    - Supplies the number of clusters on the disk.

Return Value:

    SMALL   - A 12 bit FAT is required.
    LARGE16 - A 16 bit FAT is required.
    LARGE32 - A 32 bit FAT is required.

--*/
{
    PARTITION_SYSTEM_ID id;

    id = ComputeSystemId();

    if (id == SYSID_FAT12BIT) {
        return(SMALL);
    } else if (id == SYSID_FAT32BIT) {
        return(LARGE32);
    } else {
        return(LARGE16);
    }
}


PARTITION_SYSTEM_ID
FAT_SA::ComputeSystemId(
    ) CONST
/*++

Routine Description:

    This routine computes the system id for a FAT file system with
    the given number of sectors.

Arguments:

    None.

Return Value:

    The correct system id for this partition.

--*/
{
#if 1
    SECTORCOUNT           disk_size;

    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
        case F3_1Pt2_512:
        case F8_256_128:
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
#endif
        case F5_1Pt2_512:
        case F3_1Pt44_512:
        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return SYSID_FAT12BIT;

        case F3_120M_512:
            return SYSID_FAT16BIT;
    }

    disk_size = QueryVirtualSectors();

    if (_ft == INVALID_FATTYPE ) {

        //
        // If the _ft member is not initialized,
        // use the sector count to determine the
        // partition class. Note that this method of
        // determining the partition class is not absolutely
        // fool-proof but this method works at least as good
        // as what we have in the past. The proper way of doing
        // the system id computation is to make sure that
        // the fat type is always computed before the
        // partition id and always uses the fat type and,
        // in some cases, the sector count to determine the
        // partition id.
        //
        if (disk_size < CSEC_FAT32BIT) {
            if ( disk_size < 65536 ) {
                return SYSID_FAT16BIT;
            } else {
                return SYSID_FAT32MEG;
            }
        } else {
            return SYSID_FAT32BIT;
        }

    } else {

        if (_ft == LARGE32 ) {
            return SYSID_FAT32BIT;
        } else {
            if ( disk_size < 65536 ) {
                return SYSID_FAT16BIT;
            } else {
                return SYSID_FAT32MEG;
            }
        }
    }

    if (_drive->IsSuperFloppy()) {
        return SYSID_FAT16BIT;    // just return something other than SYSID_NONE
    }

    return SYSID_NONE;

#else // FUTURE_CODE

    // BUGBUG for EFI we need to handle this differently

    return 0xEF;

#endif // FUTURE_CODE
}

#if !defined(_SETUP_LOADER_)

ULONG
FAT_SA::ComputeRootEntries(
    ) CONST
/*++

Routine Description:

    This routine uses the size of the disk and a standard table in
    order to compute the required number of root directory entries.

Arguments:

    None.

Return Value:

    The required number of root directory entries.

--*/
{
    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
#endif
            return 112;

        case F5_1Pt2_512:
        case F3_1Pt44_512:
#if defined(FE_SB) && defined(_X86_)
        case F3_1Pt2_512:
#endif
            return 224;

        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return 240;

#if defined(FE_SB) && defined(_X86_)
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
             return 192;

        case F8_256_128:
            return 68;

        case RemovableMedia:
            return 512;
#endif
    }

    return 512;
}


USHORT
FAT_SA::ComputeSecClus(
    IN  SECTORCOUNT Sectors,
    IN  FATTYPE     FatType,
#if defined(FE_SB) && defined(_X86_)
    IN  MEDIA_TYPE  MediaType,
    IN  ULONG       SectorSize
#else
    IN  MEDIA_TYPE  MediaType
#endif
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster required
    based on the actual number of sectors.

Arguments:

    Sectors     - Supplies the total number of sectors on the disk.
    FatType     - Supplies the type of FAT.
    MediaType   - Supplies the type of the media.

Return Value:

    The required number of sectors per cluster.

--*/
{
    USHORT      sec_per_clus;
    SECTORCOUNT threshold;


    if (FatType == LARGE32) {

        if (Sectors >= 64*1024*1024) {
            sec_per_clus = 64;                  /* over 32GB -> 32K */
        } else if (Sectors >= 32*1024*1024) {
            sec_per_clus = 32;                  /* up to 32GB -> 16K */
        } else if (Sectors >= 16*1024*1024) {
            sec_per_clus = 16;                  /* up to 16GB -> 8K */
        } else {
            sec_per_clus = 8;                   /* up to 8GB -> 4K */
        }

        return sec_per_clus;
    }

    if (FatType == SMALL) {
        threshold = MIN_CLUS_BIG;
        sec_per_clus = 1;
    } else {
        threshold = MAX_CLUS_BIG;
        sec_per_clus = 1;
    }

    while (Sectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    return sec_per_clus;
}

#endif // _SETUP_LOADER_


BOOLEAN
FAT_SA::IsValidString(
    IN  PCWSTRING    String
    )
/*++

Routine Description:

    This routine determines whether or not the given null-terminated string
    has any invalid characters in it.

Arguments:

    String  - Supplies the string to validate.

Return Value:

    FALSE   - The string contains invalid characters.
    TRUE    - The string is free from invalid characters.

Notes:

    The list of invalid characters is stricter than HPFS requires.

--*/
{
    CHNUM   i, l;

    l = String->QueryChCount();

    for (i = 0; i < l; i++) {
        if (String->QueryChAt(i) < 32) {
            return FALSE;
        }

        switch (String->QueryChAt(i)) {
            case '*':
            case '?':
                case '/':
            case '\\':
                case '|':
                case ',':
                case ';':
                case ':':
                case '+':
                case '=':
            case '<':
            case '>':
                case '[':
                case ']':
            case '"':
            case '.':
                return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\ifsutil.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    ifsutil.cxx

Abstract:

        This module contains run-time, global support for the
    IFS Utilities library (IFSUTIL).   This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"

#if !defined( _AUTOCHECK_ ) && !defined( _EFICHECK_ )

ERRSTACK* perrstk;

#endif // _AUTOCHECK_


//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C"
IFSUTIL_EXPORT
BOOLEAN
InitializeIfsUtil (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

IFSUTIL_EXPORT
BOOLEAN
InitializeIfsUtil (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined(FE_SB) && defined(_X86_)
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize machine id.
        //
        InitializeMachineData();
    }
#endif

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ ) || defined( _EFICHECK_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "IfsUtil initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_IFSUTIL_MEM_LEAK)
    DebugPrint("IFSUTIL.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrintTrace(("IFSUTIL.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "IfsUtil initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_IFSUTIL_MEM_LEAK)
            DebugPrint("IFSUTIL.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrintTrace(("IFSUTIL.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrint("IFSUTIL.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrint("IFSUTIL.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif _AUTOCHECK_ || _SETUP_LOADER_

    return TRUE;
}

#ifndef _EFICHECK_
DECLARE_CLASS(  AUTOENTRY           );
#endif

DECLARE_CLASS(  CACHE               );

#ifndef _EFICHECK_
DECLARE_CLASS(  CANNED_SECURITY     );
DECLARE_CLASS(  DIGRAPH             );
DECLARE_CLASS(  DIGRAPH_EDGE        );
#endif

DECLARE_CLASS(  DP_DRIVE            );
DECLARE_CLASS(  DRIVE               );
DECLARE_CLASS(  DRIVE_CACHE         );
#ifndef _EFICHECK_
DECLARE_CLASS(  INTSTACK            );
#endif
DECLARE_CLASS(  IO_DP_DRIVE         );
DECLARE_CLASS(  LOG_IO_DP_DRIVE     );

#ifndef _EFICHECK_
DECLARE_CLASS(  MOUNT_POINT_MAP     );
DECLARE_CLASS(  MOUNT_POINT_TUPLE   );
#endif

DECLARE_CLASS(  NUMBER_EXTENT       );
DECLARE_CLASS(  NUMBER_SET          );
DECLARE_CLASS(  PHYS_IO_DP_DRIVE    );
DECLARE_CLASS(  READ_CACHE          );
#ifndef _EFICHECK_
DECLARE_CLASS(  READ_WRITE_CACHE    );
#endif
DECLARE_CLASS(  SECRUN              );
#ifndef _EFICHECK_
DECLARE_CLASS(  SPARSE_SET          );
DECLARE_CLASS(  TLINK               );
#endif
DECLARE_CLASS(  SUPERAREA           );
DECLARE_CLASS(  VOL_LIODPDRV        );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
    if(
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    AUTOENTRY           ) &&
#endif

        DEFINE_CLASS_DESCRIPTOR(    CACHE               ) &&

#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    CANNED_SECURITY     ) &&
        DEFINE_CLASS_DESCRIPTOR(    DIGRAPH             ) &&
        DEFINE_CLASS_DESCRIPTOR(    DIGRAPH_EDGE        ) &&
#endif

        DEFINE_CLASS_DESCRIPTOR(    DP_DRIVE            ) &&
        DEFINE_CLASS_DESCRIPTOR(    DRIVE               ) &&
        DEFINE_CLASS_DESCRIPTOR(    DRIVE_CACHE         ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    INTSTACK            ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    IO_DP_DRIVE         ) &&
        DEFINE_CLASS_DESCRIPTOR(    LOG_IO_DP_DRIVE     ) &&

#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_MAP     ) &&
        DEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_TUPLE   ) &&
#endif

        DEFINE_CLASS_DESCRIPTOR(    NUMBER_EXTENT       ) &&
        DEFINE_CLASS_DESCRIPTOR(    NUMBER_SET          ) &&
        DEFINE_CLASS_DESCRIPTOR(    PHYS_IO_DP_DRIVE    ) &&
        DEFINE_CLASS_DESCRIPTOR(    READ_CACHE          ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    READ_WRITE_CACHE    ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    SECRUN              ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    SPARSE_SET          ) &&
        DEFINE_CLASS_DESCRIPTOR(    TLINK               ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    SUPERAREA           ) &&
        DEFINE_CLASS_DESCRIPTOR(    VOL_LIODPDRV        ) ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    AUTOENTRY           );
#endif

    UNDEFINE_CLASS_DESCRIPTOR(    CACHE               );

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    CANNED_SECURITY     );
    UNDEFINE_CLASS_DESCRIPTOR(    DIGRAPH             );
    UNDEFINE_CLASS_DESCRIPTOR(    DIGRAPH_EDGE        );
#endif

    UNDEFINE_CLASS_DESCRIPTOR(    DP_DRIVE            );
    UNDEFINE_CLASS_DESCRIPTOR(    DRIVE               );
    UNDEFINE_CLASS_DESCRIPTOR(    DRIVE_CACHE         );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    INTSTACK            );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    IO_DP_DRIVE         );
    UNDEFINE_CLASS_DESCRIPTOR(    LOG_IO_DP_DRIVE     );

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_MAP     );
    UNDEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_TUPLE   );
#endif

    UNDEFINE_CLASS_DESCRIPTOR(    NUMBER_EXTENT       );
    UNDEFINE_CLASS_DESCRIPTOR(    NUMBER_SET          );
    UNDEFINE_CLASS_DESCRIPTOR(    PHYS_IO_DP_DRIVE    );
    UNDEFINE_CLASS_DESCRIPTOR(    READ_CACHE          );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    READ_WRITE_CACHE    );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    SECRUN              );

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    SPARSE_SET          );
    UNDEFINE_CLASS_DESCRIPTOR(    TLINK               );
#endif

    UNDEFINE_CLASS_DESCRIPTOR(    SUPERAREA           );
    UNDEFINE_CLASS_DESCRIPTOR(    VOL_LIODPDRV        );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\iterator.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    iterator.cxx

Abstract:

    This contains the definitions for the non-inline member functions
    for the abstract ITERATOR class. The only interesting aspect of this
    implementation is that the destructor decrements the iterator count in
    it's associated CONTAINER. This count, increment by the CONTAINER when
    the ITERATOR is constructed, allows the associated CONTAINER to watch
    for outstanding ITERATORs when it is destroyed - a situation which is
    dangerous and surely a bug.

Environment:

    ULIB, User Mode

[Notes:]

    optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR( ITERATOR, OBJECT );

ITERATOR::~ITERATOR(
    )
{
}


POBJECT
ITERATOR::FindNext(
    IN      PCOBJECT    Key
    )
{
    POBJECT p;

    for (p = GetNext(); p; p = GetNext()) {
        if (!Key->Compare(p)) {
            break;
        }
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\hashindx.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    hashindx.cxx

--*/

#include <pch.cxx>

#include "ulib.hxx"

#include "hashindx.hxx"

#if !defined( _EFICHECK_ )

extern "C" {
#include <stdio.h>
}

//#define HASH_INDEX_PERFORMANCE    1

#if HASH_INDEX_PERFORMANCE
#include <math.h>
#endif

#endif // EFICHECK

#define MAX_HASH_TABLE_SIZE     32768

DEFINE_CONSTRUCTOR( HASH_INDEX, OBJECT );

VOID
HASH_INDEX::Construct (
        )
/*++

Routine Description:

    Constructor for HASH_INDEX.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _hashTable = NULL;
    _hash_table_size = 0;
    _hash_table_mask = 0;
    _hash_table_bits = 0;
    _hash_element_increment = 0;
}


VOID
HASH_INDEX::Destroy(
    )
/*++

Routine Description:

    This routine returns the HASH_INDEX to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PHASH_INDEX_ELEMENT   hashElementPtr;
    USHORT                i;

    if (_hashTable == NULL)
        return;

    hashElementPtr = _hashTable;
    for (i=0; i<_hash_table_size; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr++;
    }
    FREE(_hashTable);

    _hash_table_size = 0;
    _hash_table_mask = 0;
    _hash_table_bits = 0;
    _hash_element_increment = 0;
}


HASH_INDEX::~HASH_INDEX(
    )
/*++

Routine Description:

    Destructor for HASH_INDEX.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
HASH_INDEX::Initialize(
    ULONG       HashTableSize,
    USHORT      HashElementIncrement
    )
/*++

Routine Description:

    This routine initializes the set for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    Destroy();

    // compute hash table bit size

    if (HashTableSize <= 1024)
        _hash_table_bits = 10;
    else if (HashTableSize <= 2048)
        _hash_table_bits = 11;
    else if (HashTableSize <= 4096)
        _hash_table_bits = 12;
    else if (HashTableSize <= 8192)
        _hash_table_bits = 13;
    else if (HashTableSize <= 16384)
        _hash_table_bits = 14;
    else
        _hash_table_bits = 15;

    // set hash table size & mask

    _hash_table_size = (1 << _hash_table_bits);
    _hash_table_mask = _hash_table_size - 1;
    _hash_element_increment = HashElementIncrement;

    _hashTable = (PHASH_INDEX_ELEMENT)MALLOC(sizeof(HASH_INDEX_ELEMENT)*_hash_table_size);

    if (_hashTable == NULL)
        return FALSE;

    memset(_hashTable, 0, sizeof(HASH_INDEX_ELEMENT)*_hash_table_size);

    return TRUE;
}

BOOLEAN
HASH_INDEX::QueryAndAdd(
    IN  ULONG       HashValue,
    IN  ULONG       Index,
    OUT PULONG      *MatchIndexArray,
    OUT PULONG      MatchIndexCount
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number    - Supplies the number to add to the set.
    Duplicate - Returns TRUE if Number already exists in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PHASH_INDEX_ELEMENT hashElementPtr;
    PULONG              tmpPtr;
    SHORT               bits_left;
    USHORT              hash_key;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    bits_left = sizeof(ULONG)*8;
    hash_key = 0;
    do {
        hash_key ^= (HashValue & _hash_table_mask);
        HashValue = HashValue >> _hash_table_bits;
        bits_left -= _hash_table_bits;
    } while (bits_left > 0);

    hashElementPtr = &(_hashTable[hash_key]);

    //
    // Is this the first entry
    //

    if (hashElementPtr->elements == NULL) {

        hashElementPtr->elements = (PULONG)
                                   MALLOC(sizeof(ULONG)*_hash_element_increment);
        if (hashElementPtr->elements == NULL)
            return FALSE;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = _hash_element_increment;
    }

    //
    // Is there room to add another entry
    //
    if (hashElementPtr->elementCount == hashElementPtr->maxElementCount) {
#if !defined( _EFICHECK_ ) // EFI uses a different realloc.

        tmpPtr = (PULONG)REALLOC(hashElementPtr->elements,
                                 sizeof(ULONG)*
                                 (_hash_element_increment +
                                  hashElementPtr->maxElementCount));

#else

        tmpPtr = (PULONG)ReallocatePool( hashElementPtr->elements,
                                        hashElementPtr->maxElementCount * sizeof(ULONG),
                                        (_hash_element_increment + hashElementPtr->maxElementCount) * sizeof(ULONG) );

#endif

        if (tmpPtr == NULL)
            return FALSE;
        hashElementPtr->elements = tmpPtr;
        hashElementPtr->maxElementCount += _hash_element_increment;
    }

    //
    // Insert the element
    //
    hashElementPtr->elements[hashElementPtr->elementCount] = Index;
    hashElementPtr->elementCount += 1;
    DebugAssert(hashElementPtr->elementCount <= hashElementPtr->maxElementCount);

    *MatchIndexArray = hashElementPtr->elements;
    *MatchIndexCount = hashElementPtr->elementCount;

    return TRUE;
}

BOOLEAN
HASH_INDEX::RemoveAll(
     )
{
    PHASH_INDEX_ELEMENT     hashElementPtr;
    USHORT                  i;

    DebugPtrAssert(_hashTable);
    hashElementPtr = _hashTable;
    for (i=0; i<_hash_table_size; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

VOID
HASH_INDEX::RemoveLastEntry(
    ULONG   HashValue,
    ULONG   Index
    )
{
    PHASH_INDEX_ELEMENT hashElementPtr;
    SHORT               bits_left;
    USHORT              hash_key;
    ULONG               count;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    bits_left = sizeof(ULONG)*8;
    hash_key = 0;
    do {
        hash_key ^= (HashValue & _hash_table_mask);
        HashValue = HashValue >> _hash_table_bits;
        bits_left -= _hash_table_bits;
    } while (bits_left > 0);

    hashElementPtr = &(_hashTable[hash_key]);

    count = hashElementPtr->elementCount;
    if (count-- >= 1) {
        DebugAssert(hashElementPtr->elements[count] == Index);
        hashElementPtr->elementCount = count;
    }
}

VOID
HASH_INDEX::DumpHashTable(
    )
/*++

Routine Description:

    This routine dumps out the hash table

--*/
{
#if HASH_INDEX_PERFORMANCE
    USHORT                  i;
    PHASH_INDEX_ELEMENT     hashElementPtr;
    ULONG                   slotused = 0, min_count = 100000, max_count = 0, elem_count = 0;
    double                  avg_count = 0, sd_count = 0, avg_slot = 0, sd_slot = 0;

    hashElementPtr = _hashTable;
    printf("\n");
    for (i=0; i<_hash_table_size; i++) {
        if (hashElementPtr->elements != NULL) {
            slotused++;
            avg_slot += i;
            sd_slot += i*i;
//            printf("%d, %d\n", i, hashElementPtr->elementCount);
            if (min_count > hashElementPtr->elementCount)
                min_count = hashElementPtr->elementCount;
            if (max_count < hashElementPtr->elementCount)
                max_count = hashElementPtr->elementCount;
            avg_count += hashElementPtr->elementCount;
            sd_count += (hashElementPtr->elementCount)*(hashElementPtr->elementCount);
        }
        hashElementPtr++;
    }
    printf("Slot (%d): %d, %g, %g\n",
           _hash_table_size, slotused, avg_slot/slotused, sqrt(sd_slot/(slotused-1)));
    printf("Element: %d, %d, %g, %g\n",
           min_count, max_count, avg_count/slotused, sqrt(sd_count/(slotused-1)));

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\hmem.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    hmem.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "error.hxx"
#include "hmem.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( HMEM, MEM, ULIB_EXPORT );

VOID
HMEM::Construct (
    )
/*++

Routine Description:

    The is the contructor of HMEM.  It initializes the private data
    to reasonable default values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _size = 0;
    _real_buf = NULL;
    _buf = NULL;
}


ULIB_EXPORT
HMEM::~HMEM(
    )
/*++

Routine Description:

    Destructor for HMEM.  Frees up any memory used.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
HMEM::Initialize(
    )
/*++

Routine Description:

    This routine initializes HMEM to an initial state.  All pointers or
    information previously aquired from this object will become invalid.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    return TRUE;
}


ULIB_EXPORT
PVOID
HMEM::Acquire(
    IN  ULONG   Size,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This routine acquires the memory resources of this object for
    the client to use.  'Size' bytes of data are guaranteed by
    this routine or this routine will return NULL.  After one call
    of 'Acquire' has succeeded, all subsequent calls will return the
    same memory, provided that the Size requested is within bounds
    specified in the first successful call.  The first successful call
    will dictate the size and location of the memory which will be
    available by calls to 'QuerySize' and 'GetBuf' respectively.

    A call to Initialize will invalidate all memory previously granted
    by this object and enable the next call to Acquire to specify
    any size.

Arguments:

    Size            - The number of bytes of memory expected.
    AlignmentMask   - Supplies the alignment required on the memory.

Return Value:

    A valid pointer to 'Size' bytes of memory or NULL.

--*/
{
    if (_buf) {
        if (Size <= _size && !(((ULONG_PTR) _buf)&AlignmentMask)) {
            return _buf;
        } else {
            return NULL;
        }
    }

    _size = Size;

    if (!(_real_buf = MALLOC((UINT) (_size + AlignmentMask)))) {
        return NULL;
    }

    _buf = (PVOID) ((ULONG_PTR) ((PCHAR) _real_buf + AlignmentMask) &
                            (~(ULONG_PTR)AlignmentMask));

    return _buf;
}


ULIB_EXPORT
BOOLEAN
HMEM::Resize(
    IN  ULONG   NewSize,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This method reallocates the object's buffer to a larger
    chunk of memory.

Arguments:

    NewSize         -- supplies the new size of the buffer.
    AlignmentMask   -- supplies the alignment requirements on the memory.

Return Value:

    TRUE upon successful completion.

Notes:

    This method allocates a new buffer, copies the appropriate
    amount of data to it, and then frees the old buffer.  Clients
    who use Resize must avoid caching pointers to the memory, but
    must use GetBuf to find out where the memory is.

    If NewSize is smaller than the current buffer size, we keep
    the current buffer.

    If this method fails, the object is left unchanged.

--*/
{
    PVOID NewBuffer;
    PVOID NewRealBuffer;

    // First, check to see if our current buffer is big enough
    // and has the correct alignment
    // to satisfy the client.

    if( _buf &&
        NewSize <= _size &&
        !(((ULONG_PTR) _buf)&AlignmentMask)) {

            return TRUE;
    }

    // We need to allocate a new chunk of memory.

    if( (NewRealBuffer = MALLOC((UINT) (NewSize + AlignmentMask))) == NULL ) {

        return FALSE;
    }

    NewBuffer = (PVOID) ((ULONG_PTR) ((PCHAR) NewRealBuffer + AlignmentMask) &
                                 (~(ULONG_PTR)AlignmentMask));

    // Copy data from the old buffer to the new.  Since we know
    // that NewSize is greater than _size, we copy _size bytes.

    memset( NewBuffer, 0, (UINT) NewSize );
    memcpy( NewBuffer, _buf, (UINT) min(_size, NewSize) );

    // Free the old buffer and set the object's private variables.

    FREE( _real_buf );
    _real_buf = NewRealBuffer;
    _buf = NewBuffer;
    _size = NewSize;

    return TRUE;
}


VOID
HMEM::Destroy(
    )
/*++

Routine Description:

    This routine frees the memory of a previous call to Acquire thus
    invalidating all pointers to that memory and enabling future
    Acquires to succeed.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _size = 0;
    if (_real_buf) {
        FREE(_real_buf);
        _real_buf = NULL;
    }
    _buf = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\filedir.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    filedir.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( FILEDIR, FATDIR, UFAT_EXPORT );

VOID
FILEDIR::Construct (
    )
/*++

Routine Description:

    Constructor for FILEDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}


UFAT_EXPORT
FILEDIR::~FILEDIR(
    )
/*++

Routine Description:

    Destructor for FILEDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
BOOLEAN
FILEDIR::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               StartingCluster
    )
/*++

Routine Description:

    This routine initializes the FILEDIR object for use.  It will enable
    referencing the directory starting at StartingCluster.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive on which the directory resides.
    FatSuperArea    - Supplies the super area for the FAT file system on
                        the drive.
    Fat             - Supplies the file allocation table for the drive.
    StartingCluster - Supplies the first cluster of the directory.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _starting_cluster = StartingCluster;

    if (!_cluster.Initialize(Mem, Drive, FatSuperArea, Fat, StartingCluster)) {
        perrstk->push(ERR_NOT_INIT, QueryClassId());
    DoInsufMemory();
        Destroy();
        return FALSE;

    }

    _number_of_entries = Drive->QuerySectorSize()*
                         FatSuperArea->QuerySectorsPerCluster()*
                         _cluster.QueryLength()/
                         BytesPerDirent;

    if (!_number_of_entries) {

        perrstk->push(ERR_NOT_INIT, QueryClassId());
        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
FILEDIR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.  Memory will
    be freed and all other function besided Init will be inoperative.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\makefile.inc ===
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\list.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    list.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "list.hxx"
#include "listit.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( LIST, SEQUENTIAL_CONTAINER, ULIB_EXPORT );

VOID
LIST::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _head = NULL;
    _tail = NULL;
    _count = 0;
}


VOID
LIST::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _head = NULL;
    _tail = NULL;
    _count = 0;
}


ULIB_EXPORT
LIST::~LIST(
    )
/*++

Routine Description:

    Destructor for LIST.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
LIST::Initialize(
    )
/*++

Routine Description:

    This routine initializes the object to a valid initial state.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!_mem_block_mgr.Initialize(sizeof(OBJECT_LIST_NODE))) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


ULONG
LIST::QueryMemberCount(
    ) CONST
/*++

Routine Description:

    This routine computes the number of members in the list.

Arguments:

    None.

Return Value:

    The number of members in the list.

--*/
{
    return _count;
}


ULIB_EXPORT
BOOLEAN
LIST::Put(
    IN  POBJECT Member
    )
/*++

Routine Description:

    This routine adds a new member to the end of the list.

Arguments:

    Member  - Supplies the element to add to the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_tail) {

        if (!(_head = _tail = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
            return FALSE;
        }

        _head->next = _head->prev = NULL;
        _head->data = Member;

        _count++;
        return TRUE;
    }

    if (!(_tail->next = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
        return FALSE;
    }

    _tail->next->prev = _tail;
    _tail = _tail->next;

    _tail->next = NULL;
    _tail->data = Member;

    _count++;
    return TRUE;
}


POBJECT
LIST::Remove(
    IN OUT  PITERATOR   Position
    )
/*++

Routine Description:

    This routine removes the element at the specified position from the
    list.  The iterator is left pointing at the following element in
    the list.

Arguments:

    Position    - Supplies a pointer to the element to remove.

Return Value:

    A pointer to the element removed.

--*/
{
    POBJECT_LIST_NODE   p;
    PLIST_ITERATOR      piter;
    POBJECT             pobj;

    DebugAssert(LIST_ITERATOR::Cast(Position));

    if (!(piter = (PLIST_ITERATOR) Position) || !(p = piter->_current)) {
        return NULL;
    }

    if (p->next) {
        p->next->prev = p->prev;
    }

    if (p->prev) {
        p->prev->next = p->next;
    }

    if (_head == p) {
        _head = p->next;
    }

    if (_tail == p) {
        _tail = p->prev;
    }

    piter->_current = p->next;

    pobj = p->data;

    _mem_block_mgr.Free(p);

    _count--;

    return pobj;
}


ULIB_EXPORT
PITERATOR
LIST::QueryIterator(
    ) CONST
/*++

Routine Description:

    This routine returns an iterator for this list.

Arguments:

    None.

Return Value:

    A valid iterator.

--*/
{
    PLIST_ITERATOR  p;

    if (!(p = NEW LIST_ITERATOR)) {
        return NULL;
    }

    p->Initialize(this);

    return p;
}


ULIB_EXPORT
BOOLEAN
LIST::Insert(
    IN OUT  POBJECT     Member,
    IN OUT  PITERATOR   Position
    )
/*++

Routine Description:

    This routine inserts a new element before the specified position.
    The 'Position' continues to point to the same element.

Arguments:

    Member      - Supplies the element to insert.
    Position    - Supplies the point at which to insert this member.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    POBJECT_LIST_NODE   p, current;

    DebugAssert(LIST_ITERATOR::Cast(Position));

    current = ((PLIST_ITERATOR) Position)->_current;

    if (!current) {
        return Put(Member);
    }

    if (!(p = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
        return FALSE;
    }

    _count++;
    p->data = Member;

    if (current == _head) {
        _head = p;
    }

    p->next = current;
    p->prev = current->prev;
    current->prev = p;

    if (p->prev) {
        p->prev->next = p;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\mem.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    mem.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "mem.hxx"


DEFINE_CONSTRUCTOR( MEM, OBJECT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\listit.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    listit.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "listit.hxx"


DEFINE_CONSTRUCTOR( LIST_ITERATOR, ITERATOR );


DEFINE_CAST_MEMBER_FUNCTION( LIST_ITERATOR );


VOID
LIST_ITERATOR::Reset(
    )
{
    _current = NULL;
}


POBJECT
LIST_ITERATOR::GetCurrent(
    )
{
    return _current ? _current->data : NULL;
}


POBJECT
LIST_ITERATOR::GetNext(
    )
{
    _current = _current ? _current->next : _list->_head;
    return _current ? _current->data : NULL;
}


POBJECT
LIST_ITERATOR::GetPrevious(
    )
{
    _current = _current ? _current->prev : _list->_tail;
    return _current ? _current->data : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\numset.cxx ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    numset.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "numset.hxx"
#include "iterator.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NUMBER_SET, OBJECT, IFSUTIL_EXPORT );

DEFINE_CONSTRUCTOR( NUMBER_EXTENT, OBJECT );

VOID
NUMBER_SET::Construct (
        )
/*++

Routine Description:

    Constructor for NUMBER_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _card = 0;
    _iterator = NULL;
}


VOID
NUMBER_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the NUMBER_SET to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _list.DeleteAllMembers();
    _card = 0;
    DELETE(_iterator);
}


IFSUTIL_EXPORT
NUMBER_SET::~NUMBER_SET(
    )
/*++

Routine Description:

    Destructor for NUMBER_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!_list.Initialize() ||
        !(_iterator = _list.QueryIterator())) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number  - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (p) {

        next = p->Start + p->Length;

        if (Number < next) {
            return TRUE;
        }

        if (Number == next) {

            p->Length += 1;
            _card += 1;

            if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {

                if (pn->Start == Number + 1) {

                    p->Length += pn->Length;
                    pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                    DELETE(pn);
                }
            }

            return TRUE;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        if (Number + 1 == p->Start) {

            p->Start = Number;
            p->Length += 1;
            _card += 1;
            return TRUE;
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::AddStart(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.  Call this routine once before calling
    AddNext.

    NOTE: Do not insert other calls of this class in between AddStart and AddNext.

Arguments:

    Number    - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    _iterator->Reset();
    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    while (p != NULL) {
        if (p->Start <= Number) {
            next = p->Start + p->Length;

            // if within range, then done
            if (Number < next)
                return TRUE;

            // if passed the range by 1, try to expand the range to include it
            if (Number == next) {
                p->Length += 1;
                _card += 1;
                // see if the next range can be merged with the expanded range
                if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {
                   if (pn->Start == Number + 1) {
                       p->Length += pn->Length;
                       pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                       DELETE(pn);
                   }
                }
                p = (PNUMBER_EXTENT)_iterator->GetPrevious();
                return TRUE;
            }

            // if less than the next range by 1, try to expand the range to
            // include it.  There won't be a merge as there must be more than
            // one hole in between the two ranges
            if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
                if (p->Start <= Number)
                    continue;
                if ((Number+1) == p->Start) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
            }
            break;
        } else {
            // search backwards
            p = (PNUMBER_EXTENT) _iterator->GetPrevious();
            if (p == NULL) {
                p = (PNUMBER_EXTENT) _iterator->GetNext();
                DebugAssert(p);
                if (p && ((Number+1) == p->Start)) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
                break;
            }
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::AddNext(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.  Call this routine after calling
    AddStart once.  This routine differs from Add ni the sense that it searches
    through each of the subset from where it last added instead of starting
    backwards like Add does.

    NOTE: Do not insert any other call of this class in between two AddNext calls.

Arguments:

    Number    - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    if (!(p = (PNUMBER_EXTENT) _iterator->GetCurrent())) {
        _iterator->Reset();
        p = (PNUMBER_EXTENT) _iterator->GetPrevious();
    }

    while (p != NULL) {
        if (p->Start <= Number) {
            next = p->Start + p->Length;

            // if within range, then done
            if (Number < next)
                return TRUE;

            // if passed the range by 1, try to expand the range to include it
            if (Number == next) {
                p->Length += 1;
                _card += 1;
                // see if the next range can be merged with the expanded range
                if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {
                   if (pn->Start == Number + 1) {
                       p->Length += pn->Length;
                       pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                       DELETE(pn);
                   }
                }
                p = (PNUMBER_EXTENT)_iterator->GetPrevious();
                return TRUE;
            }

            // if less than the next range by 1, try to expand the range to
            // include it.  There won't be a merge as there must be more than
            // one hole in between the two ranges
            if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
                if (p->Start <= Number)
                    continue;
                if ((Number+1) == p->Start) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
            }
            break;
        } else {
            // search backwards
            p = (PNUMBER_EXTENT) _iterator->GetPrevious();
            if (p == NULL) {
                p = (PNUMBER_EXTENT) _iterator->GetNext();
                DebugAssert(p);
                if (p && ((Number+1) == p->Start)) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
                break;
            }
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    )
/*++

Routine Description:

    This routine adds the range of numbers to the set.

Arguments:

    Start   - Supplies the first number to add to the set.
    Length  - Supplies the length of the run to add.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT i, sup;
    BOOLEAN r;

    sup = Start + Length;

    r = TRUE;
    for (i = Start; i < sup; i += 1) {
        r = Add(i) && r;
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  PCNUMBER_SET    NumberSet
    )
/*++

Routine Description:

    This routine adds all of the elements in the given number set to
    this one.

Arguments:

    NumberSet   - Supplies the numbers to add.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, n;
    BIG_INT s, l;

    n = NumberSet->QueryNumDisjointRanges();

    for (i = 0; i < n; i++) {

        NumberSet->QueryDisjointRange(i, &s, &l);

        if (!Add(s, l)) {
            return FALSE;
        }
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::CheckAndAdd(
    IN  BIG_INT   Number,
    OUT PBOOLEAN  Duplicate
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number  - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);
    DebugAssert(Duplicate);

    *Duplicate = FALSE;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (p) {

        next = p->Start + p->Length;

        if (Number < next) {
            *Duplicate = TRUE;
            return TRUE;
        }

        if (Number == next) {

            p->Length += 1;
            _card += 1;

            if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {

                if (pn->Start == Number + 1) {

                    p->Length += pn->Length;
                    pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                    DELETE(pn);
                }
            }

            return TRUE;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        if (Number + 1 == p->Start) {

            p->Start = Number;
            p->Length += 1;
            _card += 1;
            return TRUE;
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  BIG_INT     Number
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number  - Supplies the number to remove.

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next, new_length;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
        if (p->Start > Number) {
            break;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {

        next = p->Start + p->Length;

        if (p->Start == Number) {
            p->Start += 1;
            p->Length -= 1;
            _card -= 1;

            if (p->Length == 0) {
                p = (PNUMBER_EXTENT) _list.Remove(_iterator);
                DELETE(p);
            }

            return TRUE;
        }

        if (Number + 1 == next) {
            p->Length -= 1;
            _card -= 1;
            return TRUE;
        }

        if (Number < next) {

            if (!(new_extent = NEW NUMBER_EXTENT)) {
                return FALSE;
            }

            _iterator->GetNext();

            if (!_list.Insert(new_extent, _iterator)) {
                DELETE(new_extent);
                return FALSE;
            }

            new_length = Number - p->Start;

            new_extent->Start = Number + 1;
            new_extent->Length = p->Length - 1 - new_length;

            p->Length = new_length;

            _card -= 1;
        }
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::RemoveAll(
     )
{
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    if ((p = (PNUMBER_EXTENT) _iterator->GetNext()))
        do {
            p = (PNUMBER_EXTENT) _list.Remove(_iterator);
            DELETE(p);
        } while ((p=(PNUMBER_EXTENT)_iterator->GetCurrent()));
    _card = 0;
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::CheckAndRemove(
    IN  BIG_INT     Number,
     OUT PBOOLEAN   DoesExists
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number      - Supplies the number to remove.
     DoesExists - TRUE if Number was found in the set

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next, new_length;

    DebugAssert(_iterator);
    DebugAssert(DoesExists);

    *DoesExists = FALSE;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
        if (p->Start > Number) {
            break;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {

        next = p->Start + p->Length;

        if (p->Start == Number) {
            p->Start += 1;
            p->Length -= 1;
            _card -= 1;
            *DoesExists = TRUE;

            if (p->Length == 0) {
                p = (PNUMBER_EXTENT) _list.Remove(_iterator);
                DELETE(p);
            }

            return TRUE;
        }

        if (Number + 1 == next) {
            p->Length -= 1;
            _card -= 1;
            *DoesExists = TRUE;
            return TRUE;
        }

        if (Number < next) {

            if (!(new_extent = NEW NUMBER_EXTENT)) {
                return FALSE;
            }

            _iterator->GetNext();

            if (!_list.Insert(new_extent, _iterator)) {
                DELETE(new_extent);
                return FALSE;
            }

            new_length = Number - p->Start;

            new_extent->Start = Number + 1;
            new_extent->Length = p->Length - 1 - new_length;

            p->Length = new_length;

            _card -= 1;
            *DoesExists = TRUE;
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    )
/*++

Routine Description:

    This routine removes the given range from the number set.

Arguments:

    Start   - Supplies the beginning of the range.
    Length  - Supplies the length of the range.

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT i, sup;
    BOOLEAN r;

    sup = Start + Length;

    r = TRUE;
    for (i = Start; i < sup; i += 1) {
        r = Remove(i) && r;
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  PCNUMBER_SET    NumberSet
    )
/*++

Routine Description:

    This routine removes all of the elements in the given number set from
    this one.

Arguments:

    NumberSet   - Supplies the numbers to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, n;
    BIG_INT s, l;

    n = NumberSet->QueryNumDisjointRanges();
    for (i = 0; i < n; i++) {

        NumberSet->QueryDisjointRange(i, &s, &l);

        if (!Remove(s, l)) {
            return FALSE;
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BIG_INT
NUMBER_SET::QueryNumber(
    IN  BIG_INT Index
    ) CONST
/*++

Routine Description:

    This routine returns the Nth number contained in this set.

Arguments:

    Index   - Supplies a zero-based index into the ordered set.

Return Value:

    The Nth number in this set.

--*/
{
    PNUMBER_EXTENT  p;
    BIG_INT         r;
    BIG_INT         count;

    DebugAssert(Index < _card);

    _iterator->Reset();
    count = 0;
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        count += p->Length;

        if (count > Index) {
            break;
        }
    }

    DebugAssert(p);

    return p->Start + Index - (count - p->Length);
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::DoesIntersectSet(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the range specified intersects
    the current number set.  This routine will return FALSE if the
    intersection is empty, TRUE otherwise.

Arguments:

    Start   - Supplies the start of the range.
    Length  - Supplies the length of the range.

Return Value:

    FALSE   - The specified range does not intersect the number set.
    TRUE    - The specified range makes a non-empty intersection with
                the number set.

--*/
{
    PNUMBER_EXTENT  p;
    BIG_INT         pnext, next;

    DebugAssert(_iterator);

    if (Length == 0) {
        return FALSE;
    }

    next = Start + Length;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        pnext = p->Start + p->Length;

        if (Start >= p->Start) {

            if (Start < pnext) {
                return TRUE;
            }
        } else {

            if (next > p->Start) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
VOID
NUMBER_SET::QueryDisjointRange(
    IN  ULONG       Index,
    OUT PBIG_INT    Start,
    OUT PBIG_INT    Length
    ) CONST
/*++

Routine Description:

    This routine returns the 'Index'th disjoint range.  (This is zero
    based).

Arguments:

    Index   - Supplies the index of the disjoint range.
    Start   - Returns the start of the disjoint range.
    Length  - Returns the length of the disjoint range.

Return Value:

    None.

--*/
{
    ULONG           i;
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    for (i = 0; i <= Index; i++) {
        p = (PNUMBER_EXTENT) _iterator->GetNext();
    }

    DebugAssert(p);
    DebugAssert(Start);
    DebugAssert(Length);

    *Start = p->Start;
    *Length = p->Length;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::QueryContainingRange(
    IN  BIG_INT     Number,
    OUT PBIG_INT    Start,
    OUT PBIG_INT    Length
    ) CONST
/*++

Routine Description:

    This routine returns the range that contains the given number.

Arguments:

    Number  - Supplies the number.
    Start   - Returns the start of the range.
    Length  - Returns the length of the range.

Return Value:

    FALSE   - The given number was not in the set.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (!p || Number >= p->Start + p->Length) {
        return FALSE;
    }

    *Start = p->Start;
    *Length = p->Length;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\membmgr.cxx ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    membmgr.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "membmgr.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR( STATIC_MEM_BLOCK_MGR, OBJECT );


STATIC_MEM_BLOCK_MGR::~STATIC_MEM_BLOCK_MGR(
    )
/*++

Routine Description:

    Destructor for STATIC_MEM_BLOCK_MGR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
STATIC_MEM_BLOCK_MGR::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _heap = NULL;
    _num_blocks = 0;
    _block_size = 0;
    _num_allocated = 0;
    _next_alloc = 0;
}


VOID
STATIC_MEM_BLOCK_MGR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_heap);
    _num_blocks = 0;
    _block_size = 0;
    _num_allocated = 0;
    _next_alloc = 0;
}


BOOLEAN
STATIC_MEM_BLOCK_MGR::Initialize(
    IN  ULONG   MemBlockSize,
    IN  ULONG   NumBlocks
    )
/*++

Routine Description:

    This routine initializes this object to a usable initial state.

Arguments:

    MemBlockSize    - Supplies the number of bytes per mem block.
    NumBlocks       - Supplies the number of mem blocks to be
                        contained by this object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(MemBlockSize);

    if (!(_heap = (PCHAR) MALLOC(NumBlocks*MemBlockSize)) ||
        !_bitvector.Initialize(NumBlocks)) {

        Destroy();
        return FALSE;
    }

    _num_blocks = NumBlocks;
    _block_size = MemBlockSize;

    return TRUE;
}


PVOID
STATIC_MEM_BLOCK_MGR::Alloc(
    )
/*++

Routine Description:

    This routine allocates a single memory block and returns its
    pointer.

Arguments:

    None.

Return Value:

    A pointer to a mem block.

--*/
{
    if (_num_allocated == _num_blocks) {
        return NULL;
    }

    for (;;) {

        if (!_bitvector.IsBitSet(_next_alloc)) {

            _bitvector.SetBit(_next_alloc);
            _num_allocated++;
            return &_heap[_next_alloc*_block_size];
        }

        _next_alloc = (_next_alloc + 1) % _num_blocks;
    }
}


BOOLEAN
STATIC_MEM_BLOCK_MGR::Free(
    OUT PVOID   MemBlock
    )
/*++

Routine Description:

    This routine frees the given mem block for use by other clients.

Arguments:

    MemBlock    - Supplies a pointer to the mem block to free.

Return Value:

    FALSE   - The mem block was not freed.
    TRUE    - Success.

--*/
{
    ULONG   i;

    if (!MemBlock) {
        return TRUE;
    }

    i = (ULONG)((PCHAR) MemBlock - _heap)/_block_size;
    if (i >= _num_blocks) {
        return FALSE;
    }

    DebugAssert(((PCHAR) MemBlock - _heap)%_block_size == 0);

    _bitvector.ResetBit(i);
    _num_allocated--;
    _next_alloc = i;
    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( MEM_BLOCK_MGR, OBJECT, ULIB_EXPORT );


VOID
MEM_BLOCK_MGR::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(_static_mem_list, 0, 32*sizeof(PVOID));
}


VOID
MEM_BLOCK_MGR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    for (i = 0; _static_mem_list[i]; i++) {
        DELETE(_static_mem_list[i]);
    }
}


ULIB_EXPORT
MEM_BLOCK_MGR::~MEM_BLOCK_MGR(
    )
/*++

Routine Description:

    Destructor for MEM_BLOCK_MGR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
MEM_BLOCK_MGR::Initialize(
    IN  ULONG   MemBlockSize,
    IN  ULONG   InitialNumBlocks
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    MemBlockSize        - Specifies the size of the memory blocks to
                            be allocated from this object.
    InitialNumBlocks    - Specifies the initial number of blocks
                            to be allocated by this object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!(_static_mem_list[0] = NEW STATIC_MEM_BLOCK_MGR) ||
        !_static_mem_list[0]->Initialize(MemBlockSize, InitialNumBlocks)) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


ULIB_EXPORT
PVOID
MEM_BLOCK_MGR::Alloc(
    )
/*++

Routine Description:

    This routine allocates a mem blocks and returns its pointer.

Arguments:

    None.

Return Value:

    A pointer to a mem block.

--*/
{
    ULONG   i;
    PVOID   r;

    for (i = 0; _static_mem_list[i]; i++) {
        if (r = _static_mem_list[i]->Alloc()) {
            return r;
        }
    }

    // At this point all of the current buffers are full so
    // start another one.

    if (!(_static_mem_list[i] = NEW STATIC_MEM_BLOCK_MGR) ||
        !_static_mem_list[i]->Initialize(
                _static_mem_list[i - 1]->QueryBlockSize(),
                2*_static_mem_list[i - 1]->QueryNumBlocks())) {

        DELETE(_static_mem_list[i]);
        return NULL;
    }

    return _static_mem_list[i]->Alloc();
}


ULIB_EXPORT
BOOLEAN
MEM_BLOCK_MGR::Free(
    IN OUT  PVOID   MemPtr
    )
/*++

Routine Description:

    This routine frees the given memory block.

Arguments:

    MemPtr  - Supplies a pointer to the buffer to free.

Return Value:

    This function returns TRUE if the memory was successfully
    freed.

--*/
{
    ULONG   i;

    for (i = 0; _static_mem_list[i]; i++) {
        if (_static_mem_list[i]->Free(MemPtr)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\message.cxx ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    message.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "message.hxx"
#include "hmem.hxx"

#if !defined( _EFICHECK_ )

extern "C" {
#include "stdio.h"

#if defined(_AUTOCHECK_)
#include "ntos.h"
#endif

}

#endif

DEFINE_EXPORTED_CONSTRUCTOR(MESSAGE, OBJECT, ULIB_EXPORT);


MESSAGE::~MESSAGE(
    )
/*++

Routine Description:

    Destructor for MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _logged_chars = 0;
    _next_message_offset = 0;
    _logging_enabled = FALSE;
    _msgid = 0;
    _inuse = 0;
    _timeout.QuadPart = 0;
}


VOID
MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _logged_chars = 0;
    _next_message_offset = 0;
    _logging_enabled = FALSE;
    _msgid = 0;
    _inuse = 0;
    _timeout.QuadPart = 0;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::Initialize(
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - Autochk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _timeout.QuadPart = -10000;
    return _log_buffer.Initialize();
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsSuppressedMessage(
    )
/*++

Routine Description:

    This function determines whether the specified message ID
    should be suppressed, i.e. not recorded in the message log.

Arguments:

    MessageId   --  Supplies the Message ID in question.

Return Value:

    TRUE if this message ID is in the set which is not recorded
    in the message log.

--*/
{
    BOOLEAN result;

    switch( _msgid ) {

    case MSG_HIDDEN_STATUS:
    case MSG_PERCENT_COMPLETE:
    case MSG_PERCENT_COMPLETE2:
#if !defined( _EFICHECK_ )
    case MSG_CHK_NTFS_CHECKING_FILES:
    case MSG_CHK_NTFS_CHECKING_INDICES:
    case MSG_CHK_NTFS_INDEX_VERIFICATION_COMPLETED:
    case MSG_CHK_NTFS_FILE_VERIFICATION_COMPLETED:
    case MSG_CHK_NTFS_CHECKING_SECURITY:
    case MSG_CHK_NTFS_SECURITY_VERIFICATION_COMPLETED:
#endif
    case MSG_CHK_VOLUME_CLEAN:
    case MSG_CHK_CHECKING_FILES:
    case MSG_CHK_DONE_CHECKING:

        result = TRUE;
        break;

    default:
        result = FALSE;
        break;
    }

    return result;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::Display(
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    // unreferenced parameters
    (void)(this);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::DisplayMsg(
    IN  MSGID   MsgId,
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::DisplayMsg(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual,
    IN  PCSTR           Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId, MessageType, MessageVisual);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::LogMsg(
    IN  MSGID   MsgId,
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId);

    va_start(ap, Format);
    r = LogV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::Log(
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    // unreferenced parameters
    (void)(this);

    va_start(ap, Format);
    r = LogV(Format, ap);
    va_end(ap);

    return r;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::DumpDataToLog(
    IN  PVOID   Data,
    IN  ULONG   Length
    )
/*++

Routine Description:

    This routine dumps the binary data to the log.

Arguments:

    Data       - Supplies a pointer to the data to be dumped
    Length     - Supplies the number of bytes to dump

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if !defined( _EFICHECK_ )

    PUCHAR  pdata = (PUCHAR)Data;
    ULONG   block;
    BOOLEAN rst = TRUE;
    WCHAR    buffer[50], buffer2[20];
    USHORT  i;

    block = ((Length + 0xf) >> 4) + 1;
    Set(MSG_CHKLOG_DUMP_DATA);

    while (rst && block--) {

        for (i=0; i<16; i++) {
            __try {
                swprintf(buffer+i*3, L"%02x ", pdata[i]);
                if (isprint(pdata[i]))
                    swprintf(buffer2+i, L"%c", pdata[i]);
                else
                    buffer2[i] = '.';
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                buffer[i*3] = '?';
                buffer[i*3+1] = '?';
                buffer[i*3+2] = ' ';
                buffer2[i] = '.';
            }
        }
        buffer[48] = ' ';
        buffer[49] = 0;
        buffer2[16] = 0;

        pdata += 0x10;
        rst = rst && Log("%ws%ws", buffer, buffer2);
    }

    return rst;
#else
    return FALSE;
#endif
}

BOOLEAN
MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

Arguments:

    Format      - Supplies a printf style list of arguments.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);
    (void)(Format);
    (void)(VarPointer);

    return TRUE;
}


BOOLEAN
MESSAGE::LogV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.

Arguments:

    Format      - Supplies a printf style list of arguments.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING         display_string;
    CHAR            buffer[512];

    if (IsLoggingEnabled()) {

        if (!BASE_SYSTEM::QueryResourceStringV(&display_string, _msgid, Format,
                                               VarPointer)) {
            return FALSE;
        }

        if (display_string.QuerySTR(0, TO_END, buffer, 512, TRUE)) {
            DebugPrintTrace(("%s", buffer));
        }

        return LogMessage(&display_string);
    }

    return TRUE;
}


PMESSAGE
MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    // unreferenced parameters
    (void)(this);

    return NEW MESSAGE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries to see if the response to a message is either
    yes or no.

Arguments:

    Default - Supplies a default answer to the question.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    // unreferenced parameters
    (void)(this);

    return Default;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return String->Initialize("");
}



ULIB_EXPORT
MSGID
MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Descriptions:

    This routine queries a response from the user.  It returns the
    message id of the response inputted.

Arguments:

    NumberOfSelections  - Supplies the number of possible message
                            responses.

    ... - Supplies 'NumberOfSelections' message identifiers.

Return Value:

    The first message id on the list.

--*/
{
    va_list ap;
    MSGID   msg;

    // unreferenced parameters
    (void)(this);

    va_start(ap, NumberOfSelections);
    msg = va_arg(ap, MSGID);
    va_end(ap);
    return msg;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return FALSE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate no
    key has been pressed.

Arguments:

    None.

Return Value:

    FALSE   - No key is pressed within the time out period.

--*/
{
    // unreferenced parameters
    (void)(this);
    UNREFERENCED_PARAMETER( MsgId );
    UNREFERENCED_PARAMETER( TimeOutInSeconds );

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::SetDotsOnly(
    IN  BOOLEAN DotsState
    )
{
    // unreferenced parameters
    (void)this;
    (void)DotsState;

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::QueryPackedLog(
    IN OUT  PHMEM   Mem,
    OUT     PULONG  PackedDataLength
    )
/*++

Routine Description:

Arguments:

    Mem                 --  Supplies a container for the packed log.
    PackedDataLength    --  Receives the number of bytes written to Mem.

Return Value:

    TRUE upon successful completion.

--*/
{
    FSTRING CurrentString;
    PWCHAR  Buffer;
    ULONG   NewBufferSize, CurrentOffset;

    if( !IsLoggingEnabled() ) {

        return FALSE;
    }

    ResetLoggingIterator();
    CurrentOffset = 0;

    while( QueryNextLoggedMessage( &CurrentString ) ) {

        NewBufferSize = (CurrentOffset + CurrentString.QueryChCount()) * sizeof(WCHAR);
        if( NewBufferSize > Mem->QuerySize() &&
            !Mem->Resize( (NewBufferSize + 1023)/1024 * 1024, 0x1 ) ) {

            return FALSE;
        }

        Buffer = (PWCHAR)Mem->GetBuf();
        memcpy( Buffer + CurrentOffset,
                CurrentString.GetWSTR(),
                CurrentString.QueryChCount() * sizeof(WCHAR) );

        CurrentOffset += CurrentString.QueryChCount();
    }

    *PackedDataLength = CurrentOffset * sizeof(WCHAR);
    return TRUE;
}

BOOLEAN
MESSAGE::QueryNextLoggedMessage(
    OUT PFSTRING    MessageText
    )
{
    PWCHAR Buffer = (PWCHAR)_log_buffer.GetBuf();
    BOOLEAN Result;

    if( _next_message_offset >= _logged_chars ) {

        // No more logged messages.
        //
        return FALSE;
    }

    Result = (MessageText->Initialize( Buffer + _next_message_offset ) != NULL) ?
             TRUE : FALSE;

    // Push _next_message_offset to the next message.  Note
    // that _next_message_offset is also incremented if this
    // loop terminates because a zero was found, so that it
    // will be one character past the next NULL character.
    //
    while( _next_message_offset < _logged_chars &&
           Buffer[_next_message_offset++] );

    return Result;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::LogMessage(
    PCWSTRING   Message
    )
{
    ULONG NewBufferSize;
    PWCHAR Buffer;

    // The buffer must be large enough to accept this message plus
    // a trailing null.  To cut down the number of memory allocation
    // calls, grow the buffer by 1K chunks.
    //
    NewBufferSize = (_logged_chars + Message->QueryChCount() + 1) * sizeof(WCHAR);

    // Don't allow the buffer to grow more than 0.5MB
    // otherwise we may use up all the pages.

    if (NewBufferSize > 512000)
        return FALSE;

    if( _log_buffer.QuerySize() < NewBufferSize &&
        !_log_buffer.Resize( (NewBufferSize + 1023)/1024 * 1024, 0x1 ) ) {
        return FALSE;
    }

    Buffer = (PWCHAR)_log_buffer.GetBuf();

    // QueryWSTR will append a trailing NULL.
    //
    Message->QueryWSTR( 0, TO_END,
                        Buffer + _logged_chars,
                        _log_buffer.QuerySize()/sizeof(WCHAR) - _logged_chars );

    _logged_chars += Message->QueryChCount() + 1;

    return TRUE;
}

ULIB_EXPORT
VOID
MESSAGE::Lock(
    )
{
    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }
}

ULIB_EXPORT
VOID
MESSAGE::Unlock(
    )
{
    InterlockedDecrement(&_inuse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\rcache.cxx ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    rcache.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "rcache.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( READ_CACHE, DRIVE_CACHE, IFSUTIL_EXPORT );


READ_CACHE::~READ_CACHE(
    )
/*++

Routine Description:

    Destructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
READ_CACHE::Construct (
        )
/*++

Routine Description:

    Contructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
READ_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
READ_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      ULONG           NumberOfCacheBlocks
    )
/*++

Routine Description:

    This routine initializes a READ_CACHE object.

Arguments:

    Drive   - Supplies the drive to cache for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DRIVE_CACHE::Initialize(Drive)) {
        Destroy();
        return FALSE;
    }

    if (!_cache.Initialize(Drive->QuerySectorSize(),
                           NumberOfCacheBlocks)) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
READ_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, j;
    ULONG   sector_size;
    PCHAR   buf;

    // Bypass the cache for large reads.

    if (NumberOfSectors > _cache.QueryMaxNumBlocks()) {
        return HardRead(StartingSector, NumberOfSectors, Buffer);
    }

    sector_size = _cache.QueryBlockSize();
    buf = (PCHAR) Buffer;

    for (i = 0; i < NumberOfSectors; i++) {

        for (j = i; j < NumberOfSectors; j++) {

            if (_cache.Read(StartingSector + j, &buf[j*sector_size])) {

                break;
            }
        }


        // Now do a hard read on everything from i to j and add these
        // blocks to the cache.

        if (j - i) {

            if (!HardRead(StartingSector + i, j - i, &buf[i*sector_size])) {

                return FALSE;
            }

            for (; i < j; i++) {

                _cache.AddBlock(StartingSector + i, &buf[i*sector_size]);
            }
        }
    }

    return TRUE;
}


BOOLEAN
READ_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _cache.Empty();
    return HardWrite(StartingSector, NumberOfSectors, Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\object.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    object.cxx

Abstract:

    This module contains the definitions for the non-inline member functions
    for the class OBJECT, the root of the Ulib hierarchy. OBJECT's
    constructor merely initializes it's internal CLASS_DESCRIPTOR to point
    to the static descriptor for the class at the beginning of this
    construction chain.

Environment:

    ULIB, User Mode

[Notes:]

    optional-notes

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"

OBJECT::OBJECT(
    )
{
}

OBJECT::~OBJECT(
    )
{
}


LONG
OBJECT::Compare (
    IN PCOBJECT Object
    ) CONST

/*++

Routine Description:

    Compare two objects based on their CLASS_ID's

Arguments:

    Object - Supplies the object to compare with.

Return Value:

    LONG     < 0    - supplied OBJECT has a higher CLASS_ID
            == 0    - supplied object has same CLASS_ID
             > 0    - supplied OBJECT has a lower CLASS_ID

Notes:

    It is expected that derived classes will overload this method and supply
    an implementation that is more meaningful (i.e. class specific). This
    implementation is ofeered as a default but is fairly meaningless as
    CLASS_IDs are allocated randomly (but uniquely) at run-time by
    CLASS_DESCRIPTORs. Therefore comparing two CLASS_IDs is not very
    interesting (e.g. it will help if an ORDERED_CONTAINER of homogenous
    objects is sorted).

--*/

{
    LONG    r;

    DebugPtrAssert( Object );

    r = (LONG)(QueryClassId() - Object->QueryClassId());

    return r ? r : (LONG)(this - Object);
}


DEFINE_OBJECT_DBG_FUNCTIONS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\rootdir.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    rootdir.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( ROOTDIR, FATDIR, UFAT_EXPORT );

VOID
ROOTDIR::Construct (
        )
/*++

Routine Description:

    Constructor for ROOTDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
        _number_of_entries = 0;
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
ROOTDIR::~ROOTDIR(
    )
/*++

Routine Description:

    Destructor for ROOTDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
ROOTDIR::Initialize(
    IN      PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartingSector,
    IN      LONG                NumberOfEntries
    )
/*++

Routine Description:

    This routine initializes the ROOTDIR object by specifying a drive,
    a position and a size.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive where the root directory is.
    StartingSector  - Supplies the starting sector of the root directory.
    NumberOfEntries - Supplies the number of entries in the root directory.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG        sector_size;
    SECTORCOUNT n;

    Destroy();

    if (!Drive || !(sector_size = Drive->QuerySectorSize())) {
                perrstk->push(ERR_NOT_INIT, QueryClassId());
        Destroy();
        return FALSE;
    }

    _number_of_entries = NumberOfEntries;

    n = (BytesPerDirent*NumberOfEntries - 1)/sector_size + 1;

    if (!_secrun.Initialize(Mem, Drive, StartingSector, n)) {
    perrstk->push(ERR_NOT_INIT, QueryClassId());
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
ROOTDIR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.  Init must be
    called for this routine to be useful again.  This routine will
    free up memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\rfatsa.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    rfatsa.cxx

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "cmem.hxx"
#include "error.hxx"
#include "rtmsg.h"
#include "drive.hxx"
#include "bpb.hxx"
#include "bitvect.hxx"

#if !defined( _EFICHECK_ )

extern "C" {
    #include <stdio.h>
}

#endif

#if defined(FE_SB) && defined(_X86_)
// PC98 boot strap code no use disk bios, PC98's boot strap code select.
extern UCHAR PC98FatBootCode[512];
extern UCHAR PC98Fat32BootCode[512*3];
#endif
// vjz   extern UCHAR FatBootCode[512];
// vjz   extern UCHAR Fat32BootCode[512*3];
UCHAR FatBootCode[512];           // vjz
UCHAR Fat32BootCode[512*3];       // vjz


#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_) && !defined( _EFICHECK_ )
#include "timeinfo.hxx"
#endif

// Control-C handling is not necessary for autocheck.
#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_) && !defined( _EFICHECK_ )

#include "keyboard.hxx"

#endif

#define CSEC_FAT32MEG            65536
#define CSEC_FAT16BIT            32680

#define MAX_CLUS_SMALL     4086     // Maximum number of clusters for FAT12 2^12 - 8 - 2
#define MAX_CLUS_ENT_SMALL 4087     // Largest fat entry for FAT12
#define MIN_CLUS_BIG       4087
#define MAX_CLUS_BIG       65526    // Maximum number of clusters for FAT16 2^16 - 8 - 2
#define MAX_CLUS_ENT_BIG   65527    // Largest fat entry for FAT16
#define MIN_CLUS_BIG32     65527
#define MAX_CLUS_BIG32     0x0FFFFFF6  // Maximum number of clusters for FAT32 2^28 - 8 - 2
#define MAX_CLUS_ENT_BIG32 0x0FFFFFF7  // Largest fat entry for FAT32
#define sigSUPERSEC1 (UCHAR)0x55    // signature first byte
#define sigSUPERSEC2 (UCHAR)0xAA    // signature second byte

#define FAT_FIRST_DATA_CLUSTER_ALIGNMENT    (4*1024)    // data clusters starting alignment
#define NUMBER_OF_FATS                      (2)

//
//  The following macro computes the rounded up quotient of a number
//  divided by another number.
//

#define RoundUpDiv(num,div)  ((num) / (div) + ((num) % (div) ? 1 : 0))

//
//  The following macros maps a logical sector number to the corresponding
//  cluster on a volume based on the starting data Lbn and the number of
//  sectors per cluster.
//

#define MapSectorToCluster( sector, sec_per_clus, start_data_lbn ) \
    ((((sector) - (start_data_lbn)) / (sec_per_clus)) + FirstDiskCluster)

//
//  Internal function prototypes
//

ULONG
ComputeClusters(ULONG, ULONG, ULONG, ULONG, ULONG, FATTYPE);

//
//  Functions for supporting the reduced memory consumption FAT (Reduced FAT)
//  format.
//

VOID SetEarlyEntries( PUCHAR, UCHAR, FATTYPE );
VOID SetEndOfChain( PUCHAR, ULONG, ULONG, FATTYPE );
VOID SetClusterBad( PUCHAR, ULONG, ULONG, FATTYPE );
VOID Set( PUCHAR, ULONG, ULONG, ULONG, FATTYPE );
VOID Set12( PUCHAR, ULONG, ULONG, ULONG);
VOID Set16( PUCHAR, ULONG, ULONG, ULONG);
VOID Set32( PUCHAR, ULONG, ULONG, ULONG);

//
//  End of internal function prototypes
//

DEFINE_EXPORTED_CONSTRUCTOR( REAL_FAT_SA, FAT_SA, UFAT_EXPORT );

BOOLEAN
REAL_FAT_SA::DosSaInit(
    IN OUT PMEM               Mem,
    IN OUT PLOG_IO_DP_DRIVE   Drive,
    IN     SECTORCOUNT        NumberOfSectors,
    IN OUT PMESSAGE           Message
    )
/*++

Routine Description:

    This routine simply initializes the underlying SUPERAREA structure
    and sets up a private pointer to the boot sector signature which is
    the last two bytes of the first sector. Note that the line for
    initializing the boot sector signature assumes that the sector size
    is 512 bytes.

Arguments:

    Mem - Supplies a pointer to a MEM which provides the memory for the
        REAL_FAT_SA object.

    Dive - Supplies a pointer the dirve object in which this super
        area object is found.

    NumberOfSectors - Supplies the total number of sectors on the
        volume.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE - Success.

    FALSE - Failure. The failure is probably caused by a lack of
        memory.

--*/
{

    //
    //  Class inheritance chain for REAL_FAT_SA:
    //  OBJECT<-SECRUN<-SUPERAREA<-FAT_SA<-REAL_FAT_SA
    //

    //
    //  Note that SUPERAREA::Initialize will initialize the
    //  _drive member. SUPERAREA::Initialize itself will call
    //  SECRUN::Initialize which aquires memory from the Mem
    //  object and marks the boundary of the superarea on the
    //  disk.
    //

    if (!SUPERAREA::Initialize(Mem, Drive, NumberOfSectors, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    //
    //  Note that the following line of code depends on a sector size
    //  of twelve but changing the code based on the real sector size
    //  may break the boot code.
    //

    _sector_sig = (UCHAR *)SECRUN::GetBuf() + 510;

    return TRUE;
}


BOOLEAN
REAL_FAT_SA::DosSaSetBpb(
    )
/*++

Routine Description:

    This routine sets up the common fields in the FAT Bpb. More elaborate
    initialization of the Bpb is done in REAL_FAT_SA::SetBpb.

Arguments:

    NONE.

Return Values:

    TRUE - This method cannot fail.

--*/
{
#if defined _SETUP_LOADER_
    return FALSE;
#else
    ULONG Sec32Meg;        // num sectors in 32mb

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectors().GetHighPart() == 0);
    DebugAssert(_drive->QueryHiddenSectors().GetHighPart() == 0);


    //
    //  Sets up the bytes per sector field in the Bpb.
    //

    _sector_zero.Bpb.BytesPerSector = (USHORT)_drive->QuerySectorSize();

    //
    //  Theoretically, having 32megs of 128 bytes sectors will overflow the
    //  16-bit integer in the Sectors field of the Bpb so the following
    //  code is not absolutely fool-proof.
    //

    Sec32Meg = (32<<20) / _drive->QuerySectorSize();

    if (_drive->QuerySectors() >= Sec32Meg) {

        //
        //  >= 32Mb -- set BPB for large partition
        //

        DEBUG((D_INFO, (CHAR8*)"REAL_FAT_SA::DosSaSetBpb: Large Partition\n"));

        _sector_zero.Bpb.Sectors = 0;
        _sector_zero.Bpb.LargeSectors = _drive->QuerySectors().GetLowPart();

    } else {

        //
        //  Size of DOS0 partition is < 32Mb
        //

        _sector_zero.Bpb.Sectors = (USHORT)_drive->QuerySectors().GetLowPart();
        _sector_zero.Bpb.LargeSectors = 0;

        DEBUG((D_INFO, (CHAR8*)"REAL_FAT_SA::DosSaSetBpb: Small Partition %x\n", _sector_zero.Bpb.Sectors));
    }


    //
    //  The following block of code sets up the phycical characterics of the
    //  volume in the bpb.
    //

    _sector_zero.Bpb.Media = _drive->QueryMediaByte();
    _sector_zero.Bpb.SectorsPerTrack = (USHORT)_drive->QuerySectorsPerTrack();
    _sector_zero.Bpb.Heads = (USHORT)_drive->QueryHeads();
#if defined(FE_SB) && defined(_X86_)
    //  PC98 Oct.21.1995 ATAcard add
    //  PC98 Floppy disk should be treated same as PC/AT
    if (IsPC98_N() && !_drive->IsATformat() && !_drive->IsFloppy() && !_drive->IsSuperFloppy()){
        _sector_zero.Bpb.HiddenSectors = _drive->QueryPhysicalHiddenSectors().GetLowPart();
    } else
#endif
    _sector_zero.Bpb.HiddenSectors = _drive->QueryHiddenSectors().GetLowPart();

    DEBUG((D_INFO, (CHAR8*)"REAL_FAT_SA::DosSaSetBpb: Media %x\n", _sector_zero.Bpb.Media));

    return TRUE;
#endif // _SETUP_LOADER_
}

VOID
REAL_FAT_SA::Construct (
    )
/*++

Routine Description:

    Constructor for FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat          = NULL;
    _dir          = NULL;
    _dirF32       = NULL;
    _hmem_F32     = NULL;
    _ft           = INVALID_FATTYPE;
    _StartDataLbn = 0;
    _ClusterCount = 0;
    _sysid        = SYSID_NONE;
    _data_aligned = FALSE;
    _AdditionalReservedSectors = MAXULONG;
}


UFAT_EXPORT
REAL_FAT_SA::~REAL_FAT_SA(
    )
/*++

Routine Description:

    Destructor for REAL_FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Formatted
    )
/*++

Routine Description:

    This routine initializes the FAT super area to an initial state.  It
    does so by first reading in the boot sector and verifying it with
    the methods of REAL_FAT_SA.  Upon computing the super area's actual size,
    the underlying SECRUN will be set to the correct size.

    If the caller needs to format this volume, then this method should
    be called with the Formatted parameter set to FALSE.

Arguments:

    Drive       - Supplies the drive where the super area resides.
    Message     - Supplies an outlet for messages
    Formatted   - Supplies a boolean which indicates whether or not
                    the volume is formatted.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    BIG_INT     data_offset;

    //
    //  Reset the state of the REAL_FAT_SA object.
    //

    Destroy();

    //
    //  Make sure that the boot sector(s) is(are) at least 512 bytes
    //  in size. Note that the boot area for a FAT32 volume is of size at least
    //  32 * 512 bytes but that adjustment will be made later. The first
    //  512 bytes of a FAT volume should contain the whole Bpb and that is all we
    //  care for the moment.
    //

    _sec_per_boot = max(1, BYTES_PER_BOOT_SECTOR/Drive->QuerySectorSize());

    if (!Formatted) {
        return _mem.Initialize() &&
               DosSaInit(&_mem, Drive, _sec_per_boot, Message);
    }

    //
    //  Do some quick parameter checking, initialize the underlying
    //  SUPERAREA and SECRUN structure, and read in the Bpb.
    //

    if (!Drive ||
        !(Drive->QuerySectorSize()) ||
        !_mem.Initialize() ||
        !DosSaInit(&_mem, Drive, _sec_per_boot, Message) ||
        !SECRUN::Read()) {

        Message->Set(MSG_CANT_READ_BOOT_SECTOR);
        Message->Display("");
        Destroy();
        return FALSE;

    }

    //
    //  Unpack the bpb in the SECRUN buffer into the _sector_zero
    //  member for easier access to the fields within the bpb.
    //

    UnpackExtendedBios(&_sector_zero,
        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    //
    //  Have a really quick check on the unpacked Bpb.
    //

    if (!VerifyBootSector() || !_sector_zero.Bpb.Fats) {
        Destroy();
        return FALSE;
    }

    //
    //  Determine the FAT type and the number of clusters on the volume
    //  depending on the
    //

    _ClusterCount = DetermineClusterCountAndFatType ( &_StartDataLbn,
                                                      &_ft );

    //
    // figured out if the data clusters are aligned
    //
    data_offset = QuerySectorsPerFat()*QueryFats()+QueryReservedSectors();
    data_offset = data_offset * Drive->QuerySectorSize();
    data_offset += QueryRootEntries()*BytesPerDirent;
    DebugAssert(FAT_FIRST_DATA_CLUSTER_ALIGNMENT <= MAXULONG);
    _data_aligned = ((data_offset.GetLowPart() & (FAT_FIRST_DATA_CLUSTER_ALIGNMENT - 1)) == 0);

    //
    //  Determine the partition id.
    //

    if (_ft == SMALL) {
        _sysid = SYSID_FAT12BIT;
    } else if (QueryVirtualSectors() < CSEC_FAT32MEG) {
        _sysid = SYSID_FAT16BIT;
    } else if (_ft == LARGE32) {
        _sysid = SYSID_FAT32BIT;
    } else {
        _sysid = SYSID_FAT32MEG;
    }

    //
    //  Adjust the _sector_per_boot member if the volume
    //  is a FAT32 volume and also in the case of a FAT32 drive
    //  only set up the super area to include memory for one FAT.
    //  On FAT32 drives the FAT can be much larger than on a FAT16 drive
    //  and we do not want to carry around the second FAT in memory as
    //  extra baggage.
    //

    if ( _ft == LARGE32 ) {
    //
    // FAT32 drives have a variable reserved area size so we do not want this
    // number hard wired at 32 unless it is not set yet (BPB value is 0 or 1)
    //
    if(_sector_zero.Bpb.ReservedSectors > 1) {
        _sec_per_boot = _sector_zero.Bpb.ReservedSectors;
    } else {
        _sec_per_boot = max((32 * 512)/_drive->QuerySectorSize(), 32);
    }
    if(!_mem.Initialize() || !DosSaInit(&_mem, Drive,
                        _sector_zero.Bpb.ReservedSectors + _sector_zero.Bpb.BigSectorsPerFat,
                        Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        Destroy();
        return FALSE;
    }
    } else {
    //
    //  The main idea behind the following code segment is to allocate
    //  memory for the whole super area including the boot area, all copies
    //  of the FAT, and the root directory for FAT12/16 volume and to initialize
    //  the underlying SECRUn object to cover the whole superarea on the
    //  disk.
    //
    if(!_mem.Initialize() || !DosSaInit(&_mem, Drive, _StartDataLbn, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        Destroy();
        return FALSE;
    }
    }
    //
    //  Initialize the root directory of the volume.
    //

    if (!(InitializeRootDirectory(Message))) {
        return FALSE;
    }

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::InitFATChkDirty(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine initializes the _fat pointer in the FAT super area
    to point to the first sector of one of the FATs so that the dirty bits in the FAT[1]
    entry can be looked at.

Arguments:

    Drive   - Supplies the drive.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UINT    StartSec;


    UnpackExtendedBios(&_sector_zero,
               (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    if (!VerifyBootSector() || !_sector_zero.Bpb.Fats) {
        return FALSE;
    }

    _ClusterCount = DetermineClusterCountAndFatType ( &_StartDataLbn,
                                                      &_ft );

    StartSec =  _sector_zero.Bpb.ReservedSectors;

    if(!_mem2.Initialize()) {
    return FALSE;
    }

    DELETE(_fat);
    if (!(_fat = NEW FAT)) {
    return FALSE;
    }

    if (!_fat->Initialize(&_secrun2, &_mem2, Drive, StartSec, _ClusterCount, 1)) {
    DELETE(_fat);
    return FALSE;
    }

    if(!_secrun2.Read()) {
    if(_sector_zero.Bpb.SectorsPerFat == 0) {
        StartSec += _sector_zero.Bpb.BigSectorsPerFat;
    } else {
        StartSec += (UINT)_sector_zero.Bpb.SectorsPerFat;
    }
    if (!_fat->Initialize(&_secrun2, &_mem2, Drive, StartSec, _ClusterCount, 1)) {
        DELETE(_fat);
        return FALSE;
    }
    if(!_secrun2.Read()) {
        DELETE(_fat);
        return FALSE;
    }
    }

    return TRUE;
}

ULONG
REAL_FAT_SA::DetermineClusterCountAndFatType (
    IN OUT  PULONG      StartingDataLbn,
    IN OUT  FATTYPE     *FatType
    )
/*++

Routine Description:

    This routine computes the number of clusters and fat type of a volume
    based on the total number of sectors on the volume and data in the Bpb.

    Note that this method assumes that the _sector_zero member has beeen
    initialized properly.

Arguments:

    StartingDataLbn - Supplies the address at which the starting data
        Lbn should be returned to the caller.

    FatType  - Supplies the address at which the Fat type should be
        returned to the caller.

Return Values:

    Number of clusters on the volume. Note that this number includes the
    first two entries.

--*/
{
    ULONG   cluster_count;      //  Number of clusters on the volume
    ULONG   sectors;            //  Number of sectors on the volume.
    ULONG   starting_data_lbn;  //  The first data sector on the FAT volume.
    FATTYPE fat_type;           //  FAT type.
    ULONG   sector_size;        //  Sector size.

    sectors = QueryVirtualSectors();
    starting_data_lbn = ComputeStartDataLbn();
    sector_size = _drive->QuerySectorSize();

    //
    //  Use the naive formula to compute a preliminary cluster count
    //  on the volume.
    //

    cluster_count = (sectors - starting_data_lbn) / (ULONG)QuerySectorsPerCluster() +
                    FirstDiskCluster;

    //
    //  We can determine the fat type now, note that we are assuming
    //  that subsequent adjustment to the cluster count will not affect the
    //  fat type which is fairly reasonable.
    //

    fat_type = cluster_count > MAX_CLUS_ENT_SMALL ? LARGE16 : SMALL;

    //
    //  It is possible to have a FAT16 volume that doesn't use up all
    //  the space on the disk so we should check whether _sector_zero.Bpb
    //  .SectorsPerfat == 0 in order to make sure that the volume is really
    //  a FAT32 volume.
    //

    if (cluster_count > MAX_CLUS_ENT_BIG) {
        if ( _sector_zero.Bpb.SectorsPerFat == 0 ) {
            fat_type = LARGE32;
        } else {
            cluster_count = MAX_CLUS_ENT_BIG;
        }
    }

    //
    // Check to make sure the FAT size in the BPB is actually big enough to hold this
    //  many clusters, adjust the cluster_count down if it is not.
    //

    switch(fat_type) {
    case SMALL:
        if (RoundUpDiv(cluster_count * 12, sector_size * 8) > _sector_zero.Bpb.SectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.SectorsPerFat * sector_size * 8) / 12;
        }
        break;
    case LARGE16:
        if (RoundUpDiv(cluster_count * 2, sector_size) > _sector_zero.Bpb.SectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.SectorsPerFat * sector_size) / 2;
        }
        break;
    case LARGE32:
        if (RoundUpDiv(cluster_count * 4, sector_size) > _sector_zero.Bpb.BigSectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.BigSectorsPerFat * sector_size) / 4;
        }
        break;
    default:
        DebugPrintTrace(("Bad FAT type.\n"));
    }

    //
    //  Make sure that the caller gets what it wants.
    //

    *FatType = fat_type;
    *StartingDataLbn = starting_data_lbn;
    return cluster_count;

}

BOOLEAN
REAL_FAT_SA::InitializeRootDirectory (
    IN  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine initializes the root directory structure in the
    FAT super area object after the boot sector has been read from the
    disk.

Arguments:

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The opreation is completed successfully.
    FALSE - This routine fails to complete the intended operation.

--*/
{

    //
    //  Note that the root directory for a FAT32 volume is a cluster
    //  chain while the FAT16/12 root directory is a fixed size area
    //  that comes right after the FATs.
    //

    if ( _ft == LARGE32 ) {

        if (!(_dirF32 = NEW FILEDIR)) {
            Destroy();
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;
        }

        //
        //  Complete initialization of _dirF32 is deffered until
        //  REAL_FAT_SA::read is called because the FAT
        //  is needed.
        //

    } else {

        CONT_MEM    cmem;           //  This CONT_MEM object piggybacks onto the
                                    //  the root directory section of the
                                    //  super area SECRUN buffer.
        ULONG       root_size;      //  Size of the root directory in number of sectors.
        ULONG       sector_size;    //  Well, it's kind of obvious isn't it.

        sector_size = _drive->QuerySectorSize();

        if (!(_dir = NEW ROOTDIR)) {

            Destroy();
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;

        } else {

            ULONG   root_offset;    //  Sector offset of the root directory from the
                                    //  beginning of the disk.

            //
            //  Computes the sector offset of the root directory.
            //

            root_offset = _sector_zero.Bpb.ReservedSectors +
                          _sector_zero.Bpb.SectorsPerFat *
                          _sector_zero.Bpb.Fats;

            //
            //  Size of the root directory in number of bytes. Note that the
            //  result is rounded up to the nearest size size.
            //

            root_size = ((_sector_zero.Bpb.RootEntries * BytesPerDirent - 1)
                         / sector_size + 1) * sector_size;

            //
            //  Now it's time to initialize the root directory. Note that this operation
            //  shouldn't fail because REAL_FAT_SA::Initialize should have allocated
            //  enough memory for the root directory through REAL_FAT_SA::DosSaInit.
            //

            if(!cmem.Initialize((PCHAR) SECRUN::GetBuf() + (root_offset * sector_size), root_size) ||
               !_dir->Initialize(&cmem, _drive, root_offset, _sector_zero.Bpb.RootEntries)) {
                DebugPrintTrace(("The secrun buffer should have enough space, big bug in code.\n"));
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        Destroy();
                return FALSE;
            }
        }
    }

    return TRUE;

}



BOOLEAN
REAL_FAT_SA::CreateBootSector(
    IN  ULONG    ClusterSize,
    IN  BOOLEAN  BackwardCompatible,
    IN  PMESSAGE Message
    )
/*++

Routine Description:

    This routine updates fields in sector 0.

Arguments:

    ClusterSize - Supplies the desired number of bytes per cluster.
    BackwardCompatible - Supplies whether the volume should be
                         compatible with FAT16.
    Message - Supplies an outlet for messages.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure.

--*/
{
#if defined _SETUP_LOADER_

    return FALSE;

#else

    SetVolId(ComputeVolId());

    return SetBpb(ClusterSize, BackwardCompatible, Message) &&
           SetBootCode() &&
           SetPhysicalDriveType(_drive->IsRemovable() ?
                                PHYS_REMOVABLE : PHYS_FIXED) &&
           SetOemData() &&
           SetSignature();

#endif // _SETUP_LOADER_
}

VALIDATION_STATUS
REAL_FAT_SA::ValidateClusterSize(
    IN     ULONG    ClusterSize,
    IN     ULONG    Sectors,
    IN     ULONG    SectorSize,
    IN     ULONG    Fats,
    IN OUT FATTYPE  *FatType,
    OUT    PULONG   FatSize,
    OUT    PULONG   ClusterCount
    )
/*++

Routine Description:

   This routine validates whether a given cluster size is
valid for a particular FAT type. If the fat type provided is
INVALID_FATTYPE, this routine would determine whether FAT12 or
FAT16 should be used.

Arguments:

    ClusterSize - Supplies the cluster size to be validated.

    Sectors - Supplies the total number of sectors on the volume.

    SectorSize - Supplies the number of bytes per sector.

    Fats - Supplies the number of FATs in the volume.

    FatType - Supplies the FAT type that the volume is going to be
        formatted. The caller will supply INVALID_FATTYPE if
        it is unsure whether the volume should be formatted
        as a FAT16 volume or a FAT12 volume and let this function
        to make the descision.

    FatSize - Supplies a location where the size of a fat in number
        of sectors can be passed back to the caller if the
        cluster size is valid.

    ClusterCounter - Supplies a location where the total number
        of clusters can be passed back to the caller if the
        given cluster size is valid.

Return Values:

   VALIDATION_STATUS

   VALID     - The given cluster size is valid.
   TOO_SMALL - The given cluster size is too small (Too many clusters).
   TOO_BIG   - The given cluster size is too big. (Too few clusters).

++*/
{
    ULONG   min_sec_req;    //  Minimum number of sectors required.
    ULONG   min_fat_size;   //  Minimum size of the FATs in number
                            //  of sectors.
    ULONG   fat_entry_size; //  Number of bytes per fat entry.
    ULONG   sec_per_clus;   //  Number of sectors per cluster.
    ULONG   clusters;       //  Number of clusters.
    FATTYPE fat_type;       //  Local fat type.

    ULONG   initial_data_sector_offset;
    ULONG   data_sector_offset;
    ULONG   pad;            // Padding to be added to the reserved sectors
                            // for data alignment

    DebugAssert(ClusterSize);

    //
    // Check for absolute minumum (one sector per cluster)
    //

    if (ClusterSize < SectorSize) {
        return TOO_SMALL;
    }

    //
    //  Compute the number of sectors per cluster.
    //

    sec_per_clus = ClusterSize / SectorSize;

    //
    //  Make sure that sec_per_clus <= 128
    //

    if (sec_per_clus > 128) {
        return TOO_BIG;
    }

    fat_type = *FatType;
    if (fat_type == INVALID_FATTYPE) {

        //  If the caller doesn't specify the fat type,
        //  try FAT16 first unless the volume is > 2Gig bytes
        //  in size (512 byte sectors only).

        if((SectorSize == 512) && (Sectors > (4 * 1024 * 1024))) {
            fat_type = LARGE32;
        } else {
            fat_type = LARGE16;
        }
    }

    //
    //  Compute the minimum number of sectors required by the
    //  FAT(s)
    //  The minimum number of sectors that the fats on a volume will
    //  occupy is given by: RoundUp(Number of fats * (minimum number of
    //  clusters + 2) * bytes per fat entry / sector size).
    //

    if (fat_type == LARGE32) {

        fat_entry_size = 4;
        min_fat_size = RoundUpDiv( Fats * (MIN_CLUS_BIG32 + 2) * fat_entry_size,
                                   SectorSize);
        min_sec_req = min_fat_size + MIN_CLUS_BIG32 * sec_per_clus;

        if (Sectors > min_sec_req) { // Meets the minimum requirement

            //
            //  Compute the number of clusters
            //

            initial_data_sector_offset = max(32, _sec_per_boot);

            for (pad=0; ; pad++) {

                data_sector_offset = initial_data_sector_offset + pad;

                clusters = ComputeClusters( ClusterSize,
                                            Sectors,
                                            SectorSize,
                                            data_sector_offset,
                                            Fats,
                                            fat_type);

                *FatSize = RoundUpDiv((clusters+2) * fat_entry_size , SectorSize);

                data_sector_offset += (*FatSize * Fats);

                if (_drive->IsFloppy() ||
                    ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                      (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                    _AdditionalReservedSectors = pad;
                    break;
                }
            }

            //
            //  Check to see if the cluster size is too small
            //

            if ( clusters > MAX_CLUS_BIG32 ) {
                return TOO_SMALL;
            }

            //
            //  See if this cluster size makes the FAT too big. Win95's FAT32
            //  support does not support FATs > 16Meg - 64k bytes in size because
            //  the GUI version of SCANDISK is a 16-bit windows application that
            //  has this limit on its allocation block size. This value is also
            //  a quite reasonable lid on FAT size.
            //

            if ((clusters * 4) > ((16 * 1024 * 1024) - (64 * 1024))) {
                return TOO_SMALL;
            }

            //
            //  Return the fat type if the caller
            //  doesn't specify it.
            //

            if (*FatType == INVALID_FATTYPE) {
                *FatType = LARGE32;
            }

            //
            //  Compute the fat size and return it to the caller
            //

            *ClusterCount = clusters + FirstDiskCluster;
            return VALID;
        }

        // Volume is too small for FAT32
        return TOO_BIG;

    }

    //
    //  The code in this function may look a bit asymmetrical
    //  but that's because we treat FAT32 separately from
    //  FAT16/12.
    //

    if (fat_type == LARGE16) {

        //
        //  Again, we compute the minimum number of sectors required if the
        //  if the volume is formatted as a FAT16 volume.
        //

        fat_entry_size = 2;
        min_fat_size = RoundUpDiv( Fats * (MIN_CLUS_BIG + 2) * fat_entry_size, SectorSize);
        min_sec_req = min_fat_size + MIN_CLUS_BIG * sec_per_clus;

        if (Sectors > min_sec_req) { // Meets the minimum requirement

            //
            //  Compute the number of clusters
            //

            initial_data_sector_offset = _sec_per_boot +
                                         (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                                         SectorSize + 1;

            for (pad=0; ; pad++) {

                data_sector_offset = initial_data_sector_offset + pad;

                clusters = ComputeClusters( ClusterSize,
                                            Sectors,
                                            SectorSize,
                                            data_sector_offset,
                                            Fats,
                                            fat_type );

                *FatSize = RoundUpDiv((clusters + 2) * fat_entry_size, SectorSize);

                data_sector_offset += (*FatSize * Fats);

                if (_drive->IsFloppy() ||
                    ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                      (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                    _AdditionalReservedSectors = pad;
                    break;
                }
            }

            if (clusters > MAX_CLUS_BIG) {

                return TOO_SMALL;

            } else {

                //
                //  Return the fat type if the caller
                //  doesn't specify it.
                //

                if (*FatType == INVALID_FATTYPE) {
                    *FatType = LARGE16;
                }

                //
                //  Compute and return the fat size to the caller.
                //

                *ClusterCount = clusters + FirstDiskCluster;
                return VALID;

            }

        } else {

            //
            //  Don't bother to fall over to the FAT12 section if the
            //  volume has more that 32679 sectors.
            //

            if (*FatType == INVALID_FATTYPE && Sectors < CSEC_FAT16BIT ) {

                //
                //  Fall over to the FAT12 section
                //

                fat_type = SMALL;

            } else {

                return TOO_BIG;

            }

        }

    }

    //
    //  A volume is never too small for FAT12 so we just
    //  check whether it is too big.
    //

    if (fat_type == SMALL) {

        initial_data_sector_offset = _sec_per_boot +
                                     (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                                     SectorSize + 1;

        for (pad=0; ; pad++) {

            data_sector_offset = initial_data_sector_offset + pad;

            clusters = ComputeClusters( ClusterSize,
                                        Sectors,
                                        SectorSize,
                                        data_sector_offset,
                                        Fats,
                                        fat_type );

            *FatSize = RoundUpDiv(RoundUpDiv((clusters + 2) * 3, 2), SectorSize);

            data_sector_offset += (*FatSize * Fats);

            if (_drive->IsFloppy() ||
                ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                  (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                _AdditionalReservedSectors = pad;
                break;
            }
        }

        if (clusters > MAX_CLUS_SMALL) {
            return TOO_SMALL;
        }

        //
        //  Return fat type to caller if necessary
        //

        if (*FatType == INVALID_FATTYPE) {
            *FatType = SMALL;
        }

        //
        //  Compute and return the FAT size
        //

        *ClusterCount = clusters + FirstDiskCluster;
        return VALID;

    }

    DebugAbort("This line should never be executed.\n");
    return TOO_BIG;

}

ULONG
ComputeClusters(
    IN  ULONG        ClusterSize,
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats,
    IN  FATTYPE      FatType
    )
/*++

Routine Description:

    This routine computes the number of clusters on a volume given
    the cluster size, volume size and the fat type.

Arguments:

    ClusterSize - Supplies the size of a cluster in number of bytes.

    Sectors - Supplies the total number of sectors in the volume.

    SectorSize - Supplies the size of a sector in number of bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of copies of fat for this volume.

    FatType - Supplies the fat type.

Return Value:

    ULONG - The total number of clusters for the given configuration.

++*/
{
    ULONG entries_per_sec; //  Number of FAT entries per sector.
    ULONG fat_entry_size;  //  Size of each FAT entry in number of BITS.
    ULONG sectors_left;    //  Number of sectors left for consideration.
    ULONG residue;         //  The residue number of bits per sector.
    ULONG acc_residue = 0; //  The accumulated residue number of FAT entry
                           //  bits.
    ULONG sec_per_clus;    //  Sectors per cluster.
    ULONG increment = 1;   //  Increment step size in number of FAT sectors.
    ULONG additional_clus; //  Number of additional clusters possible due to
                           //  the accumulated residue bits in the fat.
    ULONG clusters = 0;    //  Number of clusters in total.
    ULONG temp;            //  Temporary place-holder for optimizing certain
                           //  computations.

    sectors_left = Sectors - ReservedSectors;
    sec_per_clus = ClusterSize / SectorSize;

    //
    //  Determine the Fat entry size in number of bits based on the
    //  fat type.
    //

    switch (FatType) {
        case SMALL:
            fat_entry_size = 12;
            break;
        case LARGE16:
            fat_entry_size = 16;
            break;
        case LARGE32:
            fat_entry_size = 32;
            break;
    }

    //
    //  Compute the number of FAT entries a sector can hold.
    //    NOTE that fat_entry_size is the size in BITS,
    //    this is the reason for the "* 8" (bits per byte).
    //

    entries_per_sec = (SectorSize * 8) / fat_entry_size;

    //
    //  If the FAT entry size doesn't divide the sector
    //  size evenly, we want to know the residue.
    //

    residue = (SectorSize * 8) % fat_entry_size;

    //
    //  Compute a sensible increment step size to begin with.
    //

    while (Sectors / (increment * entries_per_sec * sec_per_clus) > 1) {
        increment *= 2;
    }

    //
    //  We have to handle the first sector of FAT entries
    //  separately because the first two entries are reserved.
    //

    temp = Fats + ((entries_per_sec - 2) * sec_per_clus);
    if (sectors_left < temp) {

        return (sectors_left - Fats) / sec_per_clus;

    } else {

        sectors_left -= temp;
        acc_residue += residue;
        clusters += entries_per_sec - 2;

        while (increment && sectors_left) {

            additional_clus = (acc_residue + (increment * residue)) / fat_entry_size;
            temp = (Fats + entries_per_sec * sec_per_clus) * increment + additional_clus * sec_per_clus;

            if (sectors_left < temp) {

                //
                //  If the increment step is only one, try to utilize the remaining sectors
                //  as much as possible.
                //

                if (increment == 1) {

                    //
                    // Exhaust the residue fat entries first
                    //

                    temp = acc_residue / fat_entry_size;
                    if (temp <= sectors_left / sec_per_clus) {

                        clusters += temp;
                        sectors_left -= temp * sec_per_clus;

                    } else {

                        clusters += sectors_left / sec_per_clus;
                        sectors_left -= sectors_left / sec_per_clus;

                    }

                    //
                    // Additional clusters may be possible after allocating
                    // one more sector of fat.
                    //
                    if ( sectors_left > Fats) {
                        temp = (sectors_left - Fats) / sec_per_clus;
                        if (temp > 0) {
                            clusters += temp;
                        }
                    }

                }

                //
                // Cut the increment step by half if it is too big.
                //

                increment /= 2;

            } else {

                if (additional_clus) {
                    acc_residue = (acc_residue + (increment * residue)) % (additional_clus * fat_entry_size);
                } else {
                    acc_residue += increment * residue;
                }
                sectors_left -= temp;
                clusters += increment * entries_per_sec + additional_clus;

            }

        }
        return clusters;
    }

    DebugAbort("This line should never be executed.");
    return 0;
}

ULONG
REAL_FAT_SA::ComputeDefaultClusterSize(
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats,
    IN  MEDIA_TYPE   MediaType,
    IN  FATTYPE      FatType,
    OUT PULONG       FatSize,
    OUT PULONG       ClusterCount
    )
/*++

Routine Description:

    This routine computes a default cluster size given the total number
    of free sectors and fat type.

Arguments:

    Sectors - Supplies the total number of sectors on the volume.

    SectorSize - Supplies the size of a sector in bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of fats.

    MediaType - Supplies the media type.

    FatType - Supplies the fat type.

    FatSize - Supplies a location for this routine to pass back the
        size of a FAT in number of sectors back to the caller.

    ClusterCount - Supplies a location for this routine to pass back
        the total number of clusters on the volume.


Return Values:

    ULONG - The number of clusters that should on the volume computed
            by the default algorithm.

++*/
{
    ULONG             fat_size;      //  Number of sectors per fat.
    ULONG             sec_per_clus;  //  Number of sectors per cluster.
    VALIDATION_STATUS result;        //  Result after validating
                                     //  the cluster size.

    //
    //  Assign a reasonable value to sec_per_clus
    //  base on the number of sectors in total.
    //

    switch (FatType) {
        case LARGE32:
        //
        // The numbers in this may look a bit odd and arbitrary, they are.
        // They match the ones that MS-DOS/Win95 use for FAT32 drives, at least
        // for 512 byte sectors. NOTE than in the case of other sector sizes
        //
        if (Sectors >= 64*1024*1024) {    // >= 32GB
        sec_per_clus = 64;        //   32k cluster @ 512 byt/sec
        } else if (Sectors >= 32*1024*1024) { // >= 16GB
        sec_per_clus = 32;        //   16k cluster @ 512 byt/sec
        } else if (Sectors >= 16*1024*1024) { // >=  8GB
        sec_per_clus = 16;        //    8k cluster @ 512 byt/sec
        } else {                  // else
        sec_per_clus = 8;         //    4k cluster @ 512 byt/sec
        }
            break;

        case LARGE16:
            sec_per_clus = 1;
            break;

        case SMALL:
            sec_per_clus = 1;
            break;

        default:
            DebugAbort("This cannot happen.");
    }

    //
    //  If this is a floppy disk, we just choose a default value.
    //

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    //
    // Validate the assigned number of sectors per
    // cluster and readjust them if necessary.
    //

    result = ValidateClusterSize( sec_per_clus * SectorSize,
                                  Sectors,
                                  SectorSize,
                                  Fats,
                                  &_ft,
                                  &fat_size,
                                  ClusterCount);

    switch (result) {

        case TOO_SMALL:

            //
            //  If the cluster size is too small, keep enlarging
            //  it by a factor of 2 until it is valid.
            //

            do {
                sec_per_clus *= 2;
                if ( sec_per_clus > 128 ) {
                    return (sec_per_clus * SectorSize);
                }
            } while (ValidateClusterSize( sec_per_clus * SectorSize,
                                          Sectors,
                                          SectorSize,
                                          Fats,
                                          &_ft,
                                          &fat_size,
                                          ClusterCount) != VALID);

            break;

        case TOO_BIG:

            //
            //  If the cluster size is too big, keep reducing it
            //  by half until it is valid.
            //

            do {
                sec_per_clus /= 2;
                if ( sec_per_clus == 0 ) {
                    return (sec_per_clus * SectorSize);
                }
            } while (ValidateClusterSize( sec_per_clus * SectorSize,
                                          Sectors,
                                          SectorSize,
                                          Fats,
                                          &_ft,
                                          &fat_size,
                                          ClusterCount) != VALID);

            break;

        case VALID:
            break;
        default:
            DebugAbort("This should never happen.");
            break;
    }

    *FatSize = fat_size;
    return (sec_per_clus * SectorSize);

}


BOOLEAN
REAL_FAT_SA::SetBpb(
     )
{
   DebugAbort("This method should never be called.");
   return FALSE;
}

BOOLEAN
REAL_FAT_SA::SetBpb(
    IN  ULONG    ClusterSize,
    IN  BOOLEAN  BackwardCompatible,
    IN  PMESSAGE Message
    )
/*++

Routine Description:

    This routine sets up the BPB from scratch for the FAT file system.

Arguments:

    ClusterSize - Supplies the desired number of bytes per cluster.

    BackwardCompatible - Supplies whether the volume should remain
        FAT16/12 compatible.

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_

    SECTORCOUNT sectors;          //  Total number of sectors.
    ULONG       sector_size;      //  Size of each sector in bytes.
    USHORT      sec_per_clus = 0; //  Sectors per cluster
    ULONG       cluster_size = 0; //  Size of each cluster in bytes.
    VALIDATION_STATUS result;     //  Return code from ValidateClusterSize.
    ULONG       fat_size;         //  Size of each fat in number of
                                  //  sectors.
#if DBG
    BIG_INT     data_offset;      // the offset to first data cluster
#endif

    //
    //  Call DosSaSeetBpb to perform some very rudimentary bpb setup.
    //

    if (!DosSaSetBpb()) {
        DebugPrintTrace(("Could not do a REAL_FAT_SA::DosSaSetBpb.\n"));
        return FALSE;
    }

    //
    //  A volume cannot have more than 4gig sectors.
    //
    DebugAssert(_drive->QuerySectors().GetHighPart() == 0);

    sectors = _drive->QuerySectors().GetLowPart();
    sector_size = _drive->QuerySectorSize();

    PCHAR fattypestr;
    if (!BackwardCompatible) {

        //
        //  If BackwardCompatible is false, then the user must have
        //  specified the /fs:FAT32 switch or the existing volume
        //  must be a FAT32 volume when a quik format is performed.
        //

        _ft = LARGE32;
        fattypestr = "FAT32";

    } else {

        //
        //  At this moment, we don't know whether FAT16 or FAt12
        //  is appropriate for this volume.
        //

        _ft = INVALID_FATTYPE;
        fattypestr = "FAT16/12";

    }

    if (_drive->QuerySectors().GetHighPart() != 0) {
    Message->Set(MSG_FMT_VOL_TOO_BIG);
    Message->Display("%s", fattypestr);
    return FALSE;
    }

    //
    //  The boot area of a FAt32 volume is at least 32 sectors large
    //  and at least 32 * 512 bytes in size.
    //

    if (_ft == LARGE32) {
        _sec_per_boot = max((32 * 512) / sector_size,32);
    }

    //
    //  Set up the number of reserved sectors and the number of
    //  FATs in the boot sector. Note that ValidateClusterSize and
    //  ComputeDefaultClusterSize depend on these values so don't move
    //  the following lines to anywhere else.
    //

    _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;
    _sector_zero.Bpb.Fats = 2;

    //
    //  Try to honor the cluster size provided by the user.
    //

    if (ClusterSize) {

        //
        //  If the cluster size specified by the user is not
        //  of the form sector_size * 2^n where n is an integer
        //  then choose a cluster size which is of the form 2^n
        //  * sector size and is just bigger than the cluster
        //  size specified by the user.
        //

        cluster_size = sector_size;
        sec_per_clus = 1;

        //
        // Check that the user specified cluster size is at least as big as
        // the minimum allowed cluster size as determined by the sector size.
        //

        if (ClusterSize < cluster_size) {
            Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN);
            Message->Display("%u", sector_size);
                return FALSE;
        }

        while (cluster_size < ClusterSize && sec_per_clus < 256) {
            cluster_size *= 2;
            sec_per_clus *= 2;
        }

        //
        //  Make sure that the cluster size provided by the user
        //  is not too big.
        //

        if ( sec_per_clus > MaxSecPerClus) {

            Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
            Message->Display("%s", fattypestr);
            return FALSE;
        }

        //
        //  Issue a warning if the cluster size computed is not
        //  equal to the cluster size provided by the user.
        //

        if ( cluster_size != ClusterSize ) {
            Message->Set(MSG_FMT_CLUSTER_SIZE_MISMATCH);
            Message->Display("%u", cluster_size);
            if (!Message->IsYesResponse(FALSE)) {
                return FALSE;
            }
        }
    }

    _sector_zero.Bpb.RootEntries = (USHORT)ComputeRootEntries();

    if (cluster_size) {

        //
        //  Make sure that the cluster size is valid for a
        //  FAT volume.
        //

        result = ValidateClusterSize( cluster_size,
                                      sectors,
                                      sector_size,
                                      NUMBER_OF_FATS,
                                      &_ft,
                                      &fat_size,
                                      &_ClusterCount );

        //
        //  Tell the user the cluster size specified is invalid
        //  for the FAT type chosen.
        //

        switch (result) {
            case TOO_SMALL:
                Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL);
                Message->Display("%s", fattypestr);
                return FALSE;
            case TOO_BIG:
                Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
                Message->Display("%s", fattypestr);
                return FALSE;
        }

    }


    if (BackwardCompatible && _ft == INVALID_FATTYPE) {

        //
        //  Use CSEC_16BIT as a cut-off point for determining
        //  whether the FAT should be 16-bit or 12-bit.
        //

        if (sectors < CSEC_FAT16BIT) {
            _ft = SMALL;
        } else {
            _ft = LARGE16;
        }
    }

    //
    //  If the user doesn't provide a cluster size, we have
    //  to compute a default cluster size.
    //
    if (!cluster_size) {

        cluster_size = ComputeDefaultClusterSize( sectors,
                                                  sector_size,
                                                  _sector_zero.Bpb.ReservedSectors,
                                                  NUMBER_OF_FATS,
                                                  _drive->QueryMediaType(),
                                                  _ft,
                                                  &fat_size,
                                                  &_ClusterCount);
        if (cluster_size == 0) {
            Message->Set(MSG_FMT_VOL_TOO_SMALL);
            Message->Display("%s", fattypestr);
            return FALSE;

        } else if (cluster_size > 128 * sector_size) {
            Message->Set(MSG_FMT_VOL_TOO_BIG);
            Message->Display("%s", fattypestr);
            return FALSE;

        }

    }

    //
    // Check for volume limits.
    //
    //  If volume is > 32Gig, say we won't do FAT
    //  If cluster size is 64k warn about compatibility issues
    //

    if((sectors / ((1024 * 1024) / sector_size)) > (32 * 1024)) {
        Message->Set(MSG_FMT_VOL_TOO_BIG);
        Message->Display("%s", fattypestr);
        return FALSE;
    }

    if(cluster_size >= (64 * 1024)) {
        Message->Set(MSG_FMT_CLUSTER_SIZE_64K);
        Message->Display("");
        if (!Message->IsYesResponse(TRUE)) {
            return FALSE;
        }
    }

    //
    //  Compute the number of sectors per clusters.
    //

    _sector_zero.Bpb.SectorsPerCluster = (UCHAR) (cluster_size / sector_size);
    if (_ft == LARGE32) {
        _sector_zero.Bpb.SectorsPerFat = 0;
        _sector_zero.Bpb.BigSectorsPerFat = fat_size;
    } else {
        _sector_zero.Bpb.SectorsPerFat = (USHORT)fat_size;
        _sector_zero.Bpb.BigSectorsPerFat = 0;
    }

    if (_ft == SMALL) {
        memcpy(_sector_zero.SystemIdText, "FAT12   ", cSYSID);
    } else if (_ft == LARGE32) {
        memcpy(_sector_zero.SystemIdText, "FAT32   ", cSYSID);
    } else {
        memcpy(_sector_zero.SystemIdText, "FAT16   ", cSYSID);
    }

    memcpy(_sector_zero.Label, "NO NAME    ", cLABEL);

    _sector_zero.CurrentHead = 0;

    //
    //  Initialize the additional fields in the FAT32 boot
    //  sector.
    //

    if (_ft == LARGE32) {
        //
        // Recompute RootEntries, _sec_per_boot, and ReservedSectors
        // in case _ft changes
        //
        _sector_zero.Bpb.RootEntries = (USHORT)ComputeRootEntries();
        _sec_per_boot = max((32 * 512) / _drive->QuerySectorSize(), 32);
        _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;

        _sector_zero.Bpb.ExtFlags = 0;
        _sector_zero.Bpb.FS_Version = 0;
        _sector_zero.Bpb.RootDirStrtClus = 2;
        _sector_zero.Bpb.FSInfoSec = 1;
        _sector_zero.Bpb.BkUpBootSec = max(6, (USHORT)((6 * 512) / sector_size));
    }

    DebugAssert(_AdditionalReservedSectors != MAXULONG);
    _sec_per_boot += _AdditionalReservedSectors;
    _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;

#if DBG
    data_offset = ((BIG_INT)(fat_size*NUMBER_OF_FATS + _sec_per_boot))*sector_size +
                  (_sector_zero.Bpb.RootEntries*BytesPerDirent);
    DebugAssert (_drive->IsFloppy() ||
                 ((data_offset.GetLowPart() & (FAT_FIRST_DATA_CLUSTER_ALIGNMENT - 1)) == 0));
#endif

    return TRUE;

#endif // _SETUP_LOADER_
}

#if defined( _AUTOCHECK_ ) || defined( _EFICHECK_ )

#define LOCALE_STHOUSAND              0x0000000F   // thousand separator

typedef unsigned int        UINT;
typedef unsigned int        *PUINT;
typedef unsigned int        *LPUINT;

int
ChkGetLocaleInfoW(
    UINT     Locale,
    UINT     LCType,
    LPWSTR   lpLCData,
    int      cchData)
{
    //
    //  For AUTOCHK we do not do thousand seperators. The NLS APIs are not
    //  around, and the registry isn't really set up either so there is no standard
    //  language place available to determine what the thousand seperator is.
    //
    return 0;
}

UINT
ChkGetUserDefaultLCID(void)
{
    return 0;
}

#else
#define ChkGetLocaleInfoW   GetLocaleInfoW
#define ChkGetUserDefaultLCID   GetUserDefaultLCID
#endif


VOID
InsertSeparators(
    LPCWSTR OutWNumber,
    char * InANumber,
    ULONG  Width
    )
{
    WCHAR szSeparator[10];
    WCHAR Separator;
    LPWSTR lpWNumber;

    lpWNumber = (LPWSTR)OutWNumber;

    if (0 != ChkGetLocaleInfoW(
                   ChkGetUserDefaultLCID(),
                   LOCALE_STHOUSAND,
                   szSeparator,
                   10
                  ))
    {
        Separator = szSeparator[0];
    }
    else
    {
    Separator = L'\0';  // If we can't get the thousand separator, do not use one.
    }

    WCHAR Buffer[100];
    ULONG cchNumber = strlen((LPCSTR)InANumber);
    UINT Triples = 0;

    Buffer[99] = L'\0';
    PWCHAR pch = &Buffer[98];

    while (cchNumber > 0)
    {
    *pch-- = InANumber[--cchNumber];

        ++Triples;
    if ( (Separator != L'\0') && (0 == (Triples % 3)) && (cchNumber > 0) )
        {
            *pch-- = Separator;
        }
    }

    cchNumber = wcslen((pch + 1));
    if(cchNumber < Width) {
    UINT i;

    cchNumber = Width - cchNumber;
    for(i = 0; i < cchNumber; i++) {
        lpWNumber[i] = L' ';
    }
    } else {
    cchNumber = 0;
    }

    wcscpy(lpWNumber + cchNumber, pch + 1); // the Number buffer better be able to handle it!
}

#if 0
BOOLEAN
REAL_FAT_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      BOOLEAN         BackwardCompatible,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSize
    )
/*++

Routine Description:

    This routine initializes the FAT file system.

Arguments:

    BadSectors  - Supplies a list of the bad sectors on the volume.
    Message     - Supplies an outlet for messages.
    Label       - Supplies an optional label.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes: FAT32 root directory uses the FILEDIR structure as
       opposed to the ROOTDIR structure used in FAT16/12.
--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else

    USHORT      sector_size;   // Number of bytes per sector, this is directly
                               // queried from the drive
    SECTORCOUNT sec_per_root;  // Number of sectors for the root directory
    CONT_MEM    cmem;          // This acts as a pointer to various
    PUSHORT     p;             // Pointer to the volume serial number.
    ULONG       cluster_count; // Number of clusters on the volume.
    ULONG       cluster_size;  // Cluster size in bytes.
    LBN         lbn;
    ULONG       i;
    DSTRING     label;
    ULONG       free_count;
    ULONG       bad_count;
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK
                SourceBootSector, TargetBootSector;
    ULONG       BootCodeOffset;
    ULONG       allocation_size;
    BIG_INT temp_big_int;
    ULONG   temp_ulong;
    BOOLEAN KSize;
    char    wdAstr[14];
    DSTRING wdNum1;

    //
    // CreateBootSector initializes the private member
    // _sector_zero which mirrors the boot sector.
    // Note that the new boot sector has not been written to
    // the disk yet at this point.
    //
    if (!CreateBootSector(ClusterSize, BackwardCompatible, Message)) {
       return FALSE;
    }

    // Calculate the actual cluster size in number of bytes.
    allocation_size = _sector_zero.Bpb.SectorsPerCluster *
                      _drive->QuerySectorSize();


#if defined(FE_SB) && defined(_X86_)
    //
    //  Set the appropriate boot code according to environment.
    //  This must be here because _ft is fixed at CreateBootSector().
    //
    if (IsPC98_N() && !_drive->IsATformat()) {
    if ( _ft == LARGE32 ) {
        _bootcode = PC98Fat32BootCode;
        _bootcodesize = sizeof(PC98Fat32BootCode);
    }
    else {
        _bootcode = PC98FatBootCode;
        _bootcodesize = sizeof(PC98FatBootCode);
    }
    }
    else {
#endif
    if ( _ft == LARGE32 ) {
        _bootcode = Fat32BootCode;
        _bootcodesize = sizeof(Fat32BootCode);
    }
    else {
        _bootcode = FatBootCode;
        _bootcodesize = sizeof(FatBootCode);
    }
#if defined(FE_SB) && defined(_X86_)
    }
#endif

    //
    // Check that the REAL_FAT_SA object is initialized
    // properly before this method is called. Also compute the
    // appropriate partition id.
    //
    if (!_drive ||
        !(sector_size = (USHORT) _drive->QuerySectorSize()) ||
        (_sysid = ComputeSystemId()) == SYSID_NONE) {
       return FALSE;
    }

    //
    // Compute the number of sectors per root directory and
    // the offset into the data area.
    //
    if (_ft == LARGE32) {

       sec_per_root = 0; // FAT32 root directory can be of any
                         // arbitrary size
       _StartDataLbn = _sector_zero.Bpb.ReservedSectors +
                       _sector_zero.Bpb.Fats *
                       _sector_zero.Bpb.BigSectorsPerFat;

    } else {

       sec_per_root = (_sector_zero.Bpb.RootEntries*BytesPerDirent - 1)/
                      sector_size + 1;

       _StartDataLbn = _sector_zero.Bpb.ReservedSectors +
                       _sector_zero.Bpb.Fats*_sector_zero.Bpb.SectorsPerFat +
                       sec_per_root;
    }


    if (_drive->QuerySectors().GetHighPart() != 0) {
    // This should be checked before calling this procedure.
    DebugAbort("Number of sectors exceeds 32 bits");
    return FALSE;
    }

    // The whole point of the following call is to grab more memory.
    if (_ft == LARGE32) {
    if (!_mem.Initialize() ||
        !DosSaInit(&_mem, _drive,
               _sector_zero.Bpb.ReservedSectors + _sector_zero.Bpb.BigSectorsPerFat,
               Message)) {

       return FALSE;
    }
    } else {
    if (!_mem.Initialize() ||
        !DosSaInit(&_mem, _drive, _StartDataLbn, Message)) {

       Message->Set(MSG_FMT_NO_MEMORY);
       Message->Display("");
       return FALSE;
    }
    }

    // Zero fill the super area.
    memset(_mem.GetBuf(), 0, (UINT) _mem.QuerySize());

    //
    // Make sure the disk is not write-protected.
    //
    // Also initialize the super area on the physical disk to
    // zero.
    //
    if (!_drive->Write(0, 1, _mem.GetBuf())) {

       if (_drive->QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED) {
          Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);
       } else {
          Message->Set(MSG_UNUSABLE_DISK);
       }
       Message->Display("");
       return FALSE;

    }

    //
    // Set file system id in the corresponding PARTITION
    // TABLE ENTRY.
    //
    if (!SetSystemId()) {

       Message->Set(MSG_WRITE_PARTITION_TABLE);
       Message->Display("");
       return FALSE;

    }

    //
    // NOTE that the following only initializes the memory for the FIRST FAT.
    // This is all we need to do because of the way the superarea is
    // written out (note also that in the case of FAT32, there only
    // is one FAT in memory).
    //
    if (_ft == LARGE32) {

       if (!cmem.Initialize((PCHAR) SECRUN::GetBuf() +
                           _sector_zero.Bpb.ReservedSectors*sector_size,
                           _sector_zero.Bpb.BigSectorsPerFat*sector_size)) {
      Message->Set(MSG_FMT_NO_MEMORY);
      Message->Display("");
      return FALSE;
       }

    } else {

       if (!cmem.Initialize((PCHAR) SECRUN::GetBuf() +
                           _sector_zero.Bpb.ReservedSectors*sector_size,
                           _sector_zero.Bpb.SectorsPerFat*sector_size)) {
       Message->Set(MSG_FMT_NO_MEMORY);
       Message->Display("");
       return FALSE;
       }

    }

    //
    // These "Hidden Status" messages are a hack to allow WinDisk to
    // cancel a quick format, which ordinarily doesn't send any status
    // messages, but which might take a while and for which there is a
    // cancel button.  When using format.com, no message will be displayed
    // for this.
    //
    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Delete old FAT.
    DELETE(_fat);

    // Create the new FAT. Note that we always set this up to be the first FAT.
    if (!(_fat = NEW FAT)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (!_fat->Initialize(&cmem, _drive, _sector_zero.Bpb.ReservedSectors,
                          _ClusterCount)) {
    Message->Set(MSG_FMT_NO_MEMORY);
    Message->Display("");
    return FALSE;
    }


    // Set the first two entries in the FAT as required.
    _fat->SetEarlyEntries(_sector_zero.Bpb.Media);

    // Set the FAT12/16 root directory
    if (_ft != LARGE32) {
       if (!cmem.Initialize((PCHAR) SECRUN::GetBuf() +
                           (_sector_zero.Bpb.ReservedSectors +
                           _sector_zero.Bpb.Fats*_sector_zero.Bpb.SectorsPerFat)*
                           sector_size, sec_per_root*sector_size)) {
      Message->Set(MSG_FMT_NO_MEMORY);
      Message->Display("");
      return FALSE;
       }
    }

    //
    // The following block of code sets up the root directory
    // of FAT32 and FAT16/12
    //
    if (LARGE32 == _ft) {

        DELETE(_dirF32);
        if (NULL != _dir) {

           DELETE(_dir);

        }
        if (NULL == (_dirF32 = NEW FILEDIR) ||
            NULL == ( _hmem_F32 = NEW HMEM )) {

           Message->Set(MSG_FMT_NO_MEMORY);
           Message->Display("");
           return FALSE;

        }
        if (!_hmem_F32->Initialize()) {
       Message->Set(MSG_FMT_NO_MEMORY);
       Message->Display("");
       return FALSE;
        }
        if (!_dirF32->Initialize(_hmem_F32, _drive, this, _fat,
                                 _sector_zero.Bpb.RootDirStrtClus)) {
       Message->Set(MSG_FMT_NO_MEMORY);
       Message->Display("");
       return FALSE;
        }
        if (!_dirF32->Read()) {
           return FALSE;
        }
        // Zero-fill the root directory entries
        RtlZeroMemory(_dirF32->GetDirEntry(0),
                      _sector_zero.Bpb.SectorsPerCluster*sector_size);

        if (!_dirF32->Write()) {
           return FALSE;
        }

    } else {

       DELETE(_dir);
       if (!(_dir = NEW ROOTDIR)) {
          Message->Set(MSG_FMT_NO_MEMORY);
          Message->Display("");
          return FALSE;
       }
       if (!_dir->Initialize(&cmem, _drive, _sector_zero.Bpb.ReservedSectors +
                            _sector_zero.Bpb.Fats*_sector_zero.Bpb.SectorsPerFat,
                            _sector_zero.Bpb.RootEntries)) {
      Message->Set(MSG_FMT_NO_MEMORY);
      Message->Display("");
      return FALSE;
       }
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    // Mark all the bad clusters. The volume is unusable if
    // any one of the sectors in the superarea cluster(s) is bad.
    //
    for (i = 0; i < BadSectors->QueryCardinality(); i++) {
        if ((lbn = BadSectors->QueryNumber(i).GetLowPart()) < _StartDataLbn) {
            Message->Set(MSG_UNUSABLE_DISK);
            Message->Display("");
            return FALSE;
        } else {
            _fat->SetClusterBad(((lbn - _StartDataLbn)/
                                 QuerySectorsPerCluster()) +
                                FirstDiskCluster );
        }
    }
    Message->Set(MSG_FORMAT_COMPLETE);
    Message->Display("");

    if (_drive->QueryMediaType() != F5_160_512 &&
        _drive->QueryMediaType() != F5_320_512) {

        if (Label) {
            if (!label.Initialize(Label)) {
               Message->Set(MSG_FMT_INIT_LABEL_FAILED);
               Message->Display("");
               return FALSE;
            }
        } else {
            switch (_drive->QueryRecommendedMediaType()) {
                case F5_360_512:
                case F5_320_512:
                case F5_180_512:
                case F5_160_512:
                    //
                    // These disk drives cannot
                    // take the spin down without a verify
                    // so don't prompt for the label.
                    // This will avoid FORMAT failing.
                    //
                    label.Initialize();
                    break;

                default:
                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display("");
                    Message->QueryStringInput(&label);
                    break;

            }
        }

        while (!SetLabel(&label)) {

            Message->Set(MSG_INVALID_LABEL_CHARACTERS);
            Message->Display("");

            Message->Set(MSG_VOLUME_LABEL_PROMPT);
            Message->Display("");
            Message->QueryStringInput(&label);
        }
    }

    if (_ft == LARGE32) {
        if (!_dirF32->Write()) {  // commit volume label
           Message->Set(MSG_FMT_ROOTDIR_WRITE_FAILED);
           Message->Display("");
           return FALSE;
        }
    }

    //
    // Copy the boot code into the secrun's buffer.
    // This is complicated by the fact that DOS_SA::Write
    // packs the data from the unpacked boot sector into
    // the packed boot sector, so we have to set the
    // first few fields in the unpacked version.
    //
    SourceBootSector = (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)_bootcode;

    CopyUchar2(&_sector_zero.BootStrapJumpOffset,
                    SourceBootSector->BootStrapJumpOffset);
    CopyUchar1(&_sector_zero.IntelNearJumpCommand,
                    SourceBootSector->IntelNearJumpCommand);

    //
    // Copy the remainder of the boot code directly into
    // the secrun.
    //
    TargetBootSector = (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf();
    BootCodeOffset = FIELD_OFFSET( PACKED_EXTENDED_BIOS_PARAMETER_BLOCK,
         StartBootCode );

    if (_ft == LARGE32) {

        //
        // The FAT32 spec. defines all unused sectors in the
        // reserved area has to be zeroed.
        //
        memset ( (PUCHAR)TargetBootSector + _sector_zero.Bpb.BytesPerSector, 0,
                 (_sector_zero.Bpb.ReservedSectors - 1) *
                 _sector_zero.Bpb.BytesPerSector);

#if defined(FE_SB) && defined(_X86_)
        // The hardcoded 512 is NO GOOD. #if 0 anyway, check with NEC later!
#endif
        //
        // bug bug this hard codes the  size of the second
        // sector..but it has to be anyway..
        //
    memcpy( (PUCHAR)TargetBootSector + BootCodeOffset,
            (PUCHAR)SourceBootSector + BootCodeOffset,
        _bootcodesize - 512 - BootCodeOffset );

        //
        // our code, though org'd to run contigously, needs
        // to be split to sector 12 to allow for easy fat16 style
        // dual booting
        //
        memcpy( (PUCHAR)TargetBootSector + (sector_size * 12),
                (PUCHAR)SourceBootSector + 1024, 512);

        //
        // Duplicate the boot sectors
        //
        memcpy( (PUCHAR)SECRUN::GetBuf() + 3 * sector_size,
                (PUCHAR)TargetBootSector,
                3 * sector_size);
        //
        // Note: Do we want to backup sector 12 also?
        //

        //
        // Pack the Bpb into the backup boot sector
        // since Write doesn't do that.
        //
        PackExtendedBios( &_sector_zero,
                          (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)((PUCHAR)(SECRUN::GetBuf()) + (3 * sector_size)));

    } else {

        memcpy( (PUCHAR)TargetBootSector + BootCodeOffset,
                (PUCHAR)SourceBootSector + BootCodeOffset,
                _bootcodesize - BootCodeOffset );

    }

    //
    // Finally, write the changes to disk.
    //
    // Write duplicates the FATs before writing to disk.
    //
    if (!Write(Message)) {
        if (_drive->QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED) {
            Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);
        } else {
            Message->Set(MSG_UNUSABLE_DISK);
        }
        Message->Display("");
        return FALSE;
    }

    if (!wdNum1.Initialize("             ")) {
    Message->Set(MSG_FMT_NO_MEMORY);
    Message->Display("");
    return FALSE;
    }

    //
    // Print an informative report.
    //
    cluster_count = QueryClusterCount() - FirstDiskCluster;
    cluster_size = sector_size*QuerySectorsPerCluster();

    temp_big_int = cluster_size * cluster_count;
    if (tmp_big_int.GetHighPart() || (tmp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
    KSize = TRUE;
    } else {
    KSize = FALSE;
    }

    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
    Message->Set(MSG_TOTAL_KILOBYTES);
    } else {
        temp_ulong = temp_big_int.GetLowPart();
    Message->Set(MSG_TOTAL_DISK_SPACE);
    }

    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (bad_count = _fat->QueryBadClusters()) {
    temp_big_int = cluster_size * bad_count;
    if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        Message->Set(MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB);
        } else {
            temp_ulong = temp_big_int.GetLowPart();
        Message->Set(MSG_BAD_SECTORS);
        }
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = _fat->QueryFreeClusters();

    temp_big_int = free_count * cluster_size;
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
    Message->Set(MSG_AVAILABLE_KILOBYTES);
    } else {
        temp_ulong = temp_big_int.GetLowPart();
    Message->Set(MSG_AVAILABLE_DISK_SPACE);
    }
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_BLANK_LINE);
    Message->Display();

    Message->Set(MSG_FMT_FAT_ENTRY_SIZE);
    switch(_ft) {

      case SMALL:
     Message->Display("%13u", 12ul);
         break;

      case LARGE16:
     Message->Display("%13u", 16ul);
         break;

      case LARGE32:
     Message->Display("%13u", 32ul);
         break;

      default:
         ;
    }

    if (QueryVolId()) {
        Message->Set(MSG_BLANK_LINE);
        Message->Display();
        p = (PUSHORT) &_sector_zero.SerialNumber;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", p[1], p[0]);
    }

    return TRUE;

#endif
}

#else

BOOLEAN
REAL_FAT_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      BOOLEAN         BackwardCompatible,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSize
    )
/*++

Routine Description:

    This routine initializes the FAT file system.

Arguments:

    BadSectors - Supplies a list of the bad sectors on the volume.

    Message - Supplies an outlet for messages.

    Label - Supplies an optional label.

    BackwardCompatible - Supplies whether or not the newly formatted
         volume should remain compatible with FAT16/12.

    ClusterSize - Supplies the cluster size specified by the user. If
        the user doesn't specify a cluster size, this parameter will
        be zero.

    VirtualCluster - Not used.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

Notes: FAT32 root directory uses the FILEDIR structure as
       opposed to the ROOTDIR structure used in FAT16/12.
--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else

    ULONG bad_clusters;

    //
    //  CreateBootSector initializes the private member
    //  _sector_zero which mirrors the boot sector.
    //  Note that the new boot sector has not been written to
    //  the disk yet at this point.
    //

    if (!CreateBootSector(ClusterSize, BackwardCompatible, Message)) {
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    //
    //  Set the appropriate boot code according to environment.
    //  This must be here because _ft is fixed at CreateBootSector().
    //
    if (IsPC98_N() && !_drive->IsATformat()) {
    if ( _ft == LARGE32 ) {
        _bootcode = PC98Fat32BootCode;
        _bootcodesize = sizeof(PC98Fat32BootCode);
    }
    else {
        _bootcode = PC98FatBootCode;
        _bootcodesize = sizeof(PC98FatBootCode);
    }
    }
    else {
#endif
    if ( _ft == LARGE32 ) {
        _bootcode = Fat32BootCode;
        _bootcodesize = sizeof(Fat32BootCode);
    }
    else {
        _bootcode = FatBootCode;
        _bootcodesize = sizeof(FatBootCode);
    }
#if defined(FE_SB) && defined(_X86_)
    }
#endif

    //
    //  Check that the REAL_FAT_SA object is initialized
    //  properly before this method is called. Also compute the
    //  appropriate partition id.
    //

    if (!_drive ||
        (_sysid = ComputeSystemId()) == SYSID_NONE) {
        return FALSE;
    }

    //
    //  These "Hidden Status" messages are a hack to allow WinDisk to
    //  cancel a quick format, which ordinarily doesn't send any status
    //  messages, but which might take a while and for which there is a
    //  cancel button.  When using format.com, no message will be displayed
    //  for this.
    //

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  DiskIsUsable will compute the proper value for the _StartDataLbn
    //  member.
    //

    if (!DiskIsUsable(BadSectors, Message)) {
        return FALSE;

    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  WriteNewFats will initialize _sector_zero.Bpb.RootDirStrtClus to the
    //  first error-free cluster on a FAT32 volume.
    //

    if (!WriteNewFats( BadSectors, &bad_clusters, Message)){
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  Initialize new root directory on the disk.
    //

    if (!WriteNewRootDirAndVolumeLabel( Label, Message )) {
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  Initialize new boot sector and setup boot code.
    //

    if (!WriteNewBootArea(Message)) {
        return FALSE;
    }

    //
    //  Set file system id in the corresponding PARTITION
    //  TABLE ENTRY.
    //

    if (!SetSystemId()) {

       Message->Set(MSG_WRITE_PARTITION_TABLE);
       Message->Display("");
       return FALSE;

    }

    Message->Set(MSG_FORMAT_COMPLETE);
    Message->Display("");


    //
    //  Print an informative report.
    //

    PrintFormatReport( bad_clusters, Message );

    return TRUE;


#endif
}

BOOLEAN
REAL_FAT_SA::DiskIsUsable (
    IN  PCNUMBER_SET    BadSectors,
    IN  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine checks whether the volume is write-protected and whether there
    are any bad sectors in the critical area(boot sector, fats, and rootdir for FAT16).
    Note that this routine will initialize the _StartDataLbn member to a proper value
    when it is done.


Arguments:

    BadSectors - Supplies the set of bad sectors on the volume.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The volume is usable.

    FALSE - The volume is either write-protected or one of the sectors
        in the critical area is bad.

--*/
{
    //
    //  Computes the first data sector which also serves as the
    //  boundary of the FAT critical area.
    //

    _StartDataLbn = ComputeStartDataLbn();

    //
    //  Since the set of bad sectors is sorted in ascending order,
    //  we only have to check whether the first bad sectors is in the
    //  critical area.
    //

    if (BadSectors->QueryCardinality().GetLowPart()) {

        if (BadSectors->QueryNumber(0).GetLowPart() < _StartDataLbn ) {

            Message->Set(MSG_UNUSABLE_DISK);
            Message->Display("");
            return FALSE;

        }

    }

    //
    //  Check to see if the disk is write protected by trying to
    //  write to the first sector. Note that REAL_FAT_SA::Initialize
    //  has already allocated memory for the boot sector.
    //

    // wipe out signature so as not to confuse the system when dealing with superfloppy

    *_sector_sig = 0;
    *(_sector_sig+1) = 0;

    if (!_drive->Write( 0, 1, _mem.GetBuf())) {

        if( _drive->QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED) {

            Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);

        } else {

            Message->Set(MSG_UNUSABLE_DISK);

        }

        Message->Display("");
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::WriteNewFats (
    IN     PCNUMBER_SET BadSectors,
    IN OUT PULONG       BadClusters,
    IN     PMESSAGE     Message

)
/*++

Routine Description:

    This routine writes brand new copies of the fat to the disk in
    a piecemeal manner. As a side effect, this routine will also allocate
    the first available cluster to the FAT32 root directory.

Arguments:

    BadSectors  - Supplies the set of bad sectors on the volume.

    BadClusters - Supplies the location where this routine can return
        the number of bad clusters on the volume to the caller.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - Success.

    FALSE - Failure. Probably runs out of memory.

--*/
{
    ULONG    sectors;               //  Total number of sectors on the volume.
    BIG_INT  bad_sector;            //  The current bad sector under consideration.
    ULONG    i,j;                   //  Generic indices.
    ULONG    segment_size;          //  The size of a fat segment in number of sectors.
    ULONG    entries_per_segment;   //  Number of fat entries in each segment.
    ULONG    granularity_factor;    //  The number of sectors required to avoid
                                    //  having fat entries straddling on a
                                    //  segment boundary.
    ULONG    root_dir_strt_clus;    //  The first cluster of the FAT32 root directory.
    HMEM     segment_hmem;          //  Memory object for the fat segment.
    SECRUN   segment_secrun;        //  The run of sectors representing the current
                                    //  fat segment on the disk.
    ULONG    segment_offset;        //  The starting offset of the current fat segment
                                    //  on the volume in sectors.
    ULONG    segment_start_entry;   //  Number of fat entries in each fat segment.
    ULONG    segment_last_entry;    //  The last fat entry in the current segment
    ULONG    curr_bad_clus;         //  The current bad cluster.
    ULONG    prev_bad_clus;
    ULONG    sector_size;
    ULONG    mult_factor;           //  Number of "grains" per segment;
    ULONG    sectors_per_fat;
    ULONG    sectors_per_cluster;
    ULONG    num_of_fats;
    ULONG    num_of_fat_sec_remain; //  Number of sectors remain uninitialized in the current fat.
    ULONG    curr_segment_size;

    DebugAssert(_ft != INVALID_FATTYPE);


    sector_size = _drive->QuerySectorSize();
    sectors     = _drive->QuerySectors().GetLowPart();
    sectors_per_cluster = QuerySectorsPerCluster();
    sectors_per_fat = QuerySectorsPerFat();
    num_of_fats     = _sector_zero.Bpb.Fats;

    //
    //  The more generic way of figuring out the granularity factor
    //  is to use the formula: granularity factor = LCM(sector size in bits, LCM(fat entry size in bits , 8 (bits per byte))
    //  but since it is reasonable to assume that sector size in bytes is divisible by 4, the
    //  granularity factors are hard-coded.
    //

    switch (_ft) {
        case SMALL:
            granularity_factor = 3;
            break;
        case LARGE16:
            granularity_factor = 1;
            break;
        case LARGE32:
            granularity_factor = 1;
            break;
    }

    //
    //  We don't want to be a pig grabbing too much memory from the system
    //  even with virtual memory enabled so we limit ourselves to 512kb
    //  per fat segment.
    //

    mult_factor = min( (sectors_per_fat - 1) / granularity_factor + 1, ((1ul << 19) / sector_size) / granularity_factor);

    if(!segment_hmem.Initialize()){

        DebugPrintTrace(("Unable to initialize hmem object.\n"));
        return FALSE;

    }

    while (!segment_secrun.Initialize( &segment_hmem,
                                       _drive,
                                       _sector_zero.Bpb.ReservedSectors,
                                       mult_factor * granularity_factor)) {


        //
        //  Reduce the segment size util there is enough memory.
        //

        mult_factor /= 2;

        if (!mult_factor) {

            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;

        }

    }

    segment_size = min(sectors_per_fat, mult_factor * granularity_factor);

    //
    // Computes the number of fat entries per fat segment.
    //

    switch (_ft) {
        case SMALL:
            entries_per_segment = (segment_size * sector_size * 2) / 3;
            break;
        case LARGE16:
            entries_per_segment = (segment_size * sector_size) / 2;
            break;
        case LARGE32:
            entries_per_segment = (segment_size * sector_size) / 4;
            break;
    }

    //
    // Allocate the first available cluster for a FAT32 volume root directory.
    //

    if (_ft == LARGE32) {

        root_dir_strt_clus = _sector_zero.Bpb.RootDirStrtClus;

        //
        //  Scan for the first non-bad cluster for the root
        //  directory.
        //

        for (i = 0; i < BadSectors->QueryCardinality().GetLowPart(); i++) {
            bad_sector = BadSectors->QueryNumber(i);


            curr_bad_clus = MapSectorToCluster(bad_sector.GetLowPart(), sectors_per_cluster, _StartDataLbn);

            if (curr_bad_clus == _ClusterCount) {

                //
                //  All clusters are bad, there is no point to go on.
                //

                Message->Set(MSG_UNUSABLE_DISK);
                Message->Display("");
                return FALSE;
            }

            if (curr_bad_clus  == root_dir_strt_clus) {
                root_dir_strt_clus++;
            } else if (curr_bad_clus > root_dir_strt_clus) {
                break;
            }
        }
    }

    //
    //  Preparations for the FAT initialization progress meter.
    //

    ULONG percent = 0;
    ULONG    total_num_fat_sec;     //  Total number of FAT sectors.
    total_num_fat_sec = sectors_per_fat * _sector_zero.Bpb.Fats;
    Message->Set(MSG_FMT_INITIALIZING_FATS);
    Message->Display("");


#if 0 // Remove the extra progress meter.
    Message->Set(MSG_PERCENT_COMPLETE);
    Message->Display("%d", percent);
#endif

    //
    // For each fat...
    //

    *BadClusters = 0;
    for (i = 0; i < _sector_zero.Bpb.Fats; i++) {

        segment_last_entry  = entries_per_segment - 1;
        segment_start_entry = 0;
        segment_offset      = i * sectors_per_fat + _sector_zero.Bpb.ReservedSectors;
        curr_segment_size   = segment_size;
        num_of_fat_sec_remain = sectors_per_fat;
        prev_bad_clus         = 0;

        //
        // Initialize the first two entries of the first segment.
        //
        if (!segment_hmem.Initialize() ||
            !segment_secrun.Initialize( &segment_hmem,
                                        _drive,
                                        segment_offset,
                                        segment_size) ){

            //
            // Shouldn't fail
            //
            DebugPrintTrace(("Unable to initialize secrun object.\n"));
            return FALSE;
        }

        memset(segment_secrun.GetBuf(), 0, segment_size * sector_size);

        SetEarlyEntries( (PUCHAR)segment_secrun.GetBuf(),
                         _sector_zero.Bpb.Media,
                         _ft );

        j = 0;
        while (num_of_fat_sec_remain) {

            //
            //  Mark all the bad clusters in the current segment
            //  and keep track of the bad clusters counter.
            //

            for (;j < BadSectors->QueryCardinality().GetLowPart(); j++) {
                bad_sector = BadSectors->QueryNumber(j);

                curr_bad_clus = MapSectorToCluster( bad_sector.GetLowPart(), sectors_per_cluster, _StartDataLbn );

                if (curr_bad_clus > segment_last_entry) {
                    break; // j is not incremented
                } else if (curr_bad_clus > prev_bad_clus) {
                    prev_bad_clus = curr_bad_clus;
                    SetClusterBad( (PUCHAR)segment_secrun.GetBuf(),
                                   curr_bad_clus,
                                   segment_start_entry,
                                   _ft );
                    (*BadClusters)++;

                }
            }

            if ( _ft == LARGE32 ) {

                //
                //  Allocate the root cluster if it is in the
                //  current segment.
                //

                if (root_dir_strt_clus >= segment_start_entry &&
                    root_dir_strt_clus <= segment_last_entry ) {
                    SetEndOfChain( (PUCHAR)segment_secrun.GetBuf(),
                                   root_dir_strt_clus,
                                   segment_start_entry,
                                   _ft );

                }

            }

            //
            //  Write the current segment to the disk.
            //
            //  We don't care whether the write operation is successful
            //  or not because we can rely on the inherent redundancy
            //  of multiple fats.
            //

            if (!segment_secrun.Write()) {
                DebugPrintTrace(("Unable to write fat segment to disk.\n"));
            }

            //
            //  Decrement the number of fat sectors remain.
            //

            num_of_fat_sec_remain -= curr_segment_size;

#if 0   // No FAT initialization progress meter for now.
            num_sec_completed += curr_segment_size;
            percent = (num_sec_completed * 100) / total_num_fat_sec;

            Message->Display("%d", percent);
#endif
            //
            //  Increment the segment offset, start entry.
            //

            segment_offset += curr_segment_size;
            segment_start_entry += entries_per_segment;

            //
            //  Compute the new segment size.
            //
            curr_segment_size = min( segment_size, num_of_fat_sec_remain );

            //
            //  Increment the last segment entry.
            //
            segment_last_entry += entries_per_segment * curr_segment_size / segment_size;

            //
            //  Reintialize the secrun object to point to the next
            //  fat segment on the disk.
            //

            if (curr_segment_size) {
                if (!segment_hmem.Initialize() ||
                    !segment_secrun.Initialize( &segment_hmem,
                                                _drive,
                                                segment_offset,
                                                curr_segment_size )) {
                    //
                    //  Shouldn't fail.
                    //
                    DebugAbort("Unable to initialize secrun object.\n");
                }

                //
                //  Zero the secrun buffer for the next iteration.
                //

                memset(segment_secrun.GetBuf(), 0, curr_segment_size * sector_size);

            }
        }

    }

#if 0   // No FAT initialization progress meter for now.
    Message->Display("%d", 100);
#endif
    _sector_zero.Bpb.RootDirStrtClus = root_dir_strt_clus;
    (*BadClusters) /= _sector_zero.Bpb.Fats;
    return TRUE;
}


BOOLEAN
REAL_FAT_SA::WriteNewRootDirAndVolumeLabel (
    IN PCWSTRING    Label,
    IN PMESSAGE     Message
)
/*++

Routine Description:

    This routine initializes the root directory as an empty structure
    and then sets up the volume label if neccessary.

Arguments:

    Label   - Supplies the volume label that the user has specified
        at the command line.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The operation is completed successfully.
    FALSE - This routine encounters unrecoverable errors while
            carrying out the operation.
--*/
{
    HMEM    root_dir_hmem;  //  Memory object for the root directory
    ULONG   root_size;      //  Size of the root directory.
    SECRUN  root_secrun;    //  A run of sectors that represents the
                            //  the root directory. Note that the
                            //  FAT32 root directory is initially one
                            //  cluster long which is a contagious run
                            //  of sectors. Note that we don't use the
                            //  the higher level FILEDIR and ROOTDIR
                            //  structures because we don't have the whole
                            //  fat in memory to initialize them.
    ULONG   root_dir_offset;//  The location of the root directory on the
                            //  disk.
    FAT_DIRENT label_dirent;//  Directory entry for the label.
    DSTRING    label;       //  Volume label.

    DebugAssert(_ft != INVALID_FATTYPE);

    if (!root_dir_hmem.Initialize()) {
        //
        //  Shouldn't fail.
        //
        DebugPrintTrace(("Failed to initialize HMEM object.\n"));
    }

    //
    //  Initialize the root directory secrun according to the Fat type.
    //

    if (_ft == LARGE32) {

        //
        //  Note that the following lines depends on the fact that
        //  WriteNewFats has set up _sector_zero.Bpb.RootDirStrtClus.
        //
        root_size = 0;
        root_dir_offset = QuerySectorFromCluster( _sector_zero.Bpb.RootDirStrtClus,
                                                  (PUCHAR)&root_size);


    } else {

        //
        //  Compute the sector offset of the FAT16/12 root directory.
        //

        root_dir_offset = _sector_zero.Bpb.ReservedSectors +
                          _sector_zero.Bpb.Fats * _sector_zero.Bpb.SectorsPerFat;

        //
        //  Compute the size of the FAT16/12 root direcctory.
        //

        root_size = (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                    _drive->QuerySectorSize() + 1;


    }

    //
    //  Initialize and zero out the secrun buffer.
    //

    if (!root_secrun.Initialize( &root_dir_hmem,
                                 _drive,
                                 root_dir_offset,
                                 root_size)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    memset( root_secrun.GetBuf(), 0, root_size * _drive->QuerySectorSize());

    //
    //  Maybe someone should consider breaking the volume label
    //  code out as a separate function.
    //
    //
    //  Prompt the user for a volume label.
    //

    if (_drive->QueryMediaType() != F5_160_512 &&
        _drive->QueryMediaType() != F5_320_512) {

        if (Label) {

            if (!label.Initialize(Label)) {
                Message->Set(MSG_FMT_INIT_LABEL_FAILED);
                Message->Display("");
                return FALSE;
            }

        } else {
            switch (_drive->QueryRecommendedMediaType()) {
                case F5_360_512:
                case F5_320_512:
                case F5_180_512:
                case F5_160_512:
                    //
                    //  These disk drives cannot
                    //  take the spin down without a verify
                    //  so don't prompt for the label.
                    //  This will avoid FORMAT failing.
                    //
                    label.Initialize();
                    break;

                default:
                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display("");
                    Message->QueryStringInput(&label);
                    break;

            }

        }

        for (;;) {

            if ( IsValidString(&label) &&
                 label.Strupr()) {
                if (label.QueryChCount()) {

                    //
                    //  Now set the volume label into the first directory
                    //  entry of the root directory. Note that the first
                    //  directory entry of the root directory must be free.
                    //

                    if (!(label_dirent.Initialize((PUCHAR)(root_secrun.GetBuf()), _ft))) {

                        //
                        //  Shouldn't fail.
                        //

                        DebugPrintTrace(("Failed to initialize directory entry for volume label.\n"));
                        return FALSE;

                    } else {

                        label_dirent.SetVolumeLabel();

                        if (!(label_dirent.SetLastWriteTime() &&  label_dirent.SetName(&label))) {

                            Message->Set(MSG_FMT_INIT_LABEL_FAILED);
                            Message->Display("");

                        } else {

                            break;
                        }
                    }

                } else {

                    break;

                }

            }

            Message->Set(MSG_INVALID_LABEL_CHARACTERS);
            Message->Display("");

            Message->Set(MSG_VOLUME_LABEL_PROMPT);
            Message->Display("");
            Message->QueryStringInput(&label);

        }
    }


    //
    //  We can now write the root directory to the disk.
    //

    if (!root_secrun.Write()) {

        Message->Set(MSG_UNUSABLE_DISK);
        Message->Display("");
        return FALSE;

    }

    return TRUE;
}


BOOLEAN
REAL_FAT_SA::WriteNewBootArea (
    IN  PMESSAGE    Message
)
/*++

Routine Description:

    This routine initializes the boot area, which includes the boot code and
    the bpb, of a new volume.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    TRUE  - The operation is completed successfully.

    FALSE - Either the system rans out of memory or the boot area
            cannot be written to the disk.

++*/
{

    ULONG   boot_area_size; // Size of the whole boot area in bytes.
    ULONG   pseudo_sector_size;


    pseudo_sector_size = max(512, _drive->QuerySectorSize());
    boot_area_size = _sector_zero.Bpb.ReservedSectors * _drive->QuerySectorSize();

    //
    //  Call DosSaInit to make sure that the secrun buffer is
    //  large enough to hold the boot sector(s).
    //

    if(!_mem.Initialize() || !DosSaInit(&_mem, _drive, _sector_zero.Bpb.ReservedSectors, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }


    //
    //  Zero out the reserved area
    //

    memset ( (PUCHAR)SECRUN::GetBuf(), 0,  boot_area_size );


    //
    //  We always assume that the sector size is at least 512 bytes when we copy the
    //  the boot code to the disk. If this is not the case, the boot code has
    //  to be smart enough to load itself up.
    //

    if  (_ft == LARGE32) {

        //
        //  We just copy the whole boot code (which includes the boot sector) directly
        //  into the secrun buffer and then pack the Bpb at a later time.
        //

        //
        //  Copy the first 1k of the bootcode into the secrun buffer.
        //

        memcpy ( SECRUN::GetBuf(), _bootcode, 1024);


        //
        //  Copy the last four byte signature onto sector 2 as well
        //
        memcpy ( (PUCHAR)SECRUN::GetBuf() + (3 * pseudo_sector_size - 4),
                 _bootcode + (3 * pseudo_sector_size - 4), 4 );
        //
        //  Copy the last 512 bytes of the boot code into the
        //  12th pseudo sector.
        //

        memcpy ( (PUCHAR)SECRUN::GetBuf() + (12 * pseudo_sector_size), _bootcode + 1024, 512 );

    } else {

        memcpy ( SECRUN::GetBuf(), _bootcode, 512 );

    }


    //
    //  Pack the bpb into the secrun buffer.
    //

    PackExtendedBios( &_sector_zero,
                      (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)(SECRUN::GetBuf()));


    //
    //  Backup the first 3 sectors to sectors 6-8 if the
    //  volume is a FAT32 volume.
    //

    if (_ft == LARGE32) {
        memcpy ((PUCHAR)SECRUN::GetBuf() + 6 * pseudo_sector_size, SECRUN::GetBuf(), 3 * pseudo_sector_size);
    }

    //
    //  Write the boot area to the disk.
    //

    if (!SECRUN::Write()) {
        Message->Set(MSG_UNUSABLE_DISK);
        Message->Display("");
        return FALSE;
    }
    return TRUE;
}


VOID
REAL_FAT_SA::PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message
    )
/*++

Routine Description:

    This routine prints an informative format report to the console.

Arguments:

    BadClustrers - Supplies the number of bad clusters on the disk.

    Message      - Supplies an outlet for messages.

Return Value:

    None.

--*/
{

    BIG_INT   free_count;
    BIG_INT   cluster_size;
    BIG_INT   sector_size;
    PUSHORT   serial_number;
    BIG_INT   temp_big_int;
    ULONG     temp_ulong;
    MSGID     message_id;
    BOOLEAN   KSize;
    char      wdAstr[14];
    DSTRING   wdNum1;

    if (!wdNum1.Initialize("             ")) {
    Message->Set(MSG_FMT_NO_MEMORY);
    Message->Display("");
    return;
    }

    sector_size = _drive->QuerySectorSize();
    cluster_size = sector_size*QuerySectorsPerCluster();

    // Compute whether reporting size in bytes or kilobytes
    //
    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility
    //
    temp_big_int = cluster_size * (_ClusterCount - FirstDiskCluster) ;
    if (temp_big_int.GetHighPart() || (temp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
    KSize = TRUE;
    } else {
    KSize = FALSE;
    }

    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_TOTAL_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_TOTAL_DISK_SPACE;
    }

    Message->Set(message_id);

    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (BadClusters) {
        temp_big_int = cluster_size * BadClusters;
    if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_BAD_SECTORS;
        }
        Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = _ClusterCount;
    free_count -= BadClusters + FirstDiskCluster;

    if (_ft == LARGE32) {
        free_count -= 1;
    }

    temp_big_int = free_count * cluster_size.GetLowPart();
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_AVAILABLE_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_AVAILABLE_DISK_SPACE;
    }
    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_BLANK_LINE);
    Message->Display();

    Message->Set(MSG_FMT_FAT_ENTRY_SIZE);
    switch(_ft) {

      case SMALL:
     Message->Display("%13u", 12ul);
         break;

      case LARGE16:
     Message->Display("%13u", 16ul);
         break;

      case LARGE32:
     Message->Display("%13u", 32ul);
         break;

      default:
         ;
    }

    if (QueryVolId()) {
        Message->Set(MSG_BLANK_LINE);
        Message->Display();
        serial_number = (PUSHORT) &_sector_zero.SerialNumber;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", serial_number[1], serial_number[0]);
    }

}

//
// The following routines are slightly modified versions of the
// methods found in fat.hxx
//

//
// Fat macros
//
#define FAT12_MASK      0x00000FFF
#define FAT16_MASK      0x0000FFFF
#define FAT32_MASK      0x0FFFFFFF
#define END_OF_CHAIN    0x0FFFFFFF
#define BAD_CLUSTER     0x0FFFFFF7

VOID
SetEarlyEntries(
    IN OUT PUCHAR   FatBuf,
    IN     UCHAR    MediaByte,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the first two FAT entries as required by the
    FAT file system.  The first byte gets set to the media descriptor.
    The remaining bytes gets set to FF.

Arguments:

    FatBuf - Supplies a pointer to the first FAt segment.

    MediaByte   - Supplies the media byte for the volume.

    FatType - Supplies the FAT type.

Return Value:

    None.

--*/
{
    DebugAssert(FatType != INVALID_FATTYPE);

    FatBuf[0] = MediaByte;
    FatBuf[1] = FatBuf[2] = 0xFF;

    if (FatType != SMALL) {
        FatBuf[3] = 0xFF;
    }

    if (FatType == LARGE32) {
        ((PULONG)FatBuf)[1] = FAT32_MASK;
    }
    return;
}

VOID
SetEndOfChain (
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the cluster ClusterNumber to the end of its cluster
    chain.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the cluster to be set to end of chain.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{
    Set( FatBuf, ClusterNumber, END_OF_CHAIN, StartingEntry, FatType );
    return;
}

VOID
SetClusterBad(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the cluster ClusterNumber to bad on the FAT.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the cluster number to mark bad.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{
    Set( FatBuf, ClusterNumber, BAD_CLUSTER, StartingEntry, FatType );
    return;
}


VOID
Set(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit, 16 bit or 32 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{

    DebugAssert(FatType != INVALID_FATTYPE);

    switch (FatType) {
        case SMALL:
            Set12( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
        case LARGE16:
            Set16( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
        case LARGE32:
            Set32( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
    }
    return;
}

VOID
Set12(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    ULONG  n;

    Value = Value & FAT12_MASK;

    n = (ClusterNumber - StartingEntry) * 3;

    if (n%2) {
        FatBuf[n/2] = (FatBuf[n/2]&0x0F) | (((UCHAR)Value&0x000F)<<4);
        FatBuf[n/2 + 1] = (UCHAR)((Value&0x0FF0)>>4);
    } else {
        FatBuf[n/2] = (UCHAR)Value&0x00FF;
        FatBuf[n/2 + 1] = (FatBuf[n/2 + 1]&0xF0) | (UCHAR)((Value&0x0F00)>>8);
    }
    return;
}

VOID
Set16(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 16 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    Value = Value & FAT16_MASK;
    ((PUSHORT)FatBuf)[ClusterNumber - StartingEntry] = (USHORT)Value;
    return;
}

VOID
Set32(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 16 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    Value = Value & FAT32_MASK;
    ((PULONG)FatBuf)[ClusterNumber - StartingEntry] = Value;
    return;

}

#endif
BOOLEAN
REAL_FAT_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine runs through the clusters for the file described by
    'FileName' and takes out bad sectors.

Arguments:

    FullPathFileName    - Supplies a full path name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    HMEM        hmem;
    ULONG       clus;
    BOOLEAN     changes;
    PFATDIR     fatdir;
    BOOLEAN     need_delete;
    FAT_DIRENT  dirent;
    ULONG       old_file_size;
    ULONG       new_file_size;

    if ((clus = QueryFileStartingCluster(FullPathFileName,
                                         &hmem,
                                         &fatdir,
                                         &need_delete,
                                         &dirent)) == 1) {

       Message->Set(MSG_FILE_NOT_FOUND);
       Message->Display("%W", FullPathFileName);
       return FALSE;

    }

    if (clus == 0xFFFFFFFF) {

       Message->Set(MSG_CHK_NO_MEMORY);
       Message->Display("");
       return FALSE;

    }

    if (clus == 0) {

       Message->Set(MSG_FILE_NOT_FOUND);
       Message->Display("%W", FullPathFileName);
       return FALSE;

    }

    if (dirent.IsDirectory()) {
        old_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        old_file_size = dirent.QueryFileSize();
    }

    if (!RecoverChain(&clus, &changes)) {

       Message->Set(MSG_CHK_NO_MEMORY);
       Message->Display("");
       return FALSE;

    }

    if (dirent.IsDirectory() || changes) {
       new_file_size = _drive->QuerySectorSize()*
                       QuerySectorsPerCluster()*
                       _fat->QueryLengthOfChain(clus);
    } else {
        new_file_size = old_file_size;
    }

    if (changes) {


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ ) && !defined( _EFICHECK_ )

        // Disable contol-C handling and

        if (!KEYBOARD::EnableBreakHandling()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

#endif


        // Lock the drive in preparation for writes.
        if (!_drive->Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

        dirent.SetStartingCluster(clus);

        dirent.SetFileSize(new_file_size);

        if (!fatdir->Write()) {
            return FALSE;
        }

        if (!Write(Message)) {
            return FALSE;
        }


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ ) && !defined( _EFICHECK_ )

        KEYBOARD::DisableBreakHandling();

#endif


    }

    Message->Set(MSG_RECOV_BYTES_RECOVERED);
    Message->Display("%d%d", new_file_size, old_file_size);

    if (need_delete) {
        DELETE(fatdir);
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::Read(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads the super area.  It will succeed if it can
    read the boot sector, the root directory, and at least one of
    the FATs.

    If the position of the internal FAT has not yet been determined,
    this routine will attempt to map it to a readable FAT on the disk.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SECRUN      secrun;
    CONT_MEM    cmem;
    LBN         fat_lbn;
    ULONG       sector_size;
    PCHAR       fat_pos;
    SECTORCOUNT sec_per_fat;
    SECTORCOUNT num_res;
    ULONG       i;
    PFAT        fat;

    if (!SECRUN::Read()) {

        // Possibly cannot read one of the fats

        // Check to see if super area was allocated as formatted.
        if (QueryLength() <= _sec_per_boot) {

            Message->Set(MSG_CANT_READ_BOOT_SECTOR);
            Message->Display("");
            return FALSE;
        }

        // Check the boot sector.
        if (!secrun.Initialize(&_mem, _drive, 0, _sec_per_boot) ||
            !secrun.Read()) {

            //BUGBUG msliger We just failed to read this.  Why unpack it?

            UnpackExtendedBios(&_sector_zero,
                               (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

            Message->Set(MSG_CANT_READ_BOOT_SECTOR);
            Message->Display("");
            return FALSE;
        }

        //BUGBUG t-raymak Personally, I think it is safer to re-unpack the bios here

        UnpackExtendedBios(&_sector_zero,
                           ((PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)secrun.GetBuf()));

        //
        // Note: Make sure that the fat is initialized
        // before the root directory.
        //

        // Check for one good FAT.
        if (_fat) {

            if (!_fat->Read()) {

                Message->Set(MSG_DISK_ERROR_READING_FAT);
                Message->Display("%d", 1 +
                                 (_fat->QueryStartLbn() - _sector_zero.Bpb.ReservedSectors)/
                                 _sector_zero.Bpb.SectorsPerFat);
                return FALSE;

            } else {

                Message->Set(MSG_SOME_FATS_UNREADABLE);
                Message->Display("");

            }

        } else {

            sector_size = _drive->QuerySectorSize();

            num_res = _sector_zero.Bpb.ReservedSectors;

        fat_pos = (PCHAR) SECRUN::GetBuf() + (num_res * sector_size);

            if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {
                sec_per_fat = _sector_zero.Bpb.BigSectorsPerFat;
            } else {
                sec_per_fat = _sector_zero.Bpb.SectorsPerFat;
            }

            for (i = 0; i < QueryFats(); i++) {
                fat_lbn = num_res + (i * sec_per_fat);

                //
                // The FAT32 super area only has one in memory FAT which is always
                // at fat_pos, computed above, regardless of which FAT it happens to be.
                //
                // FAT12/16 drives have all of the FAT(s) in memory.
                //
                if (LARGE32 == _ft) {
                    if (!cmem.Initialize(fat_pos, sec_per_fat * sector_size)) {
                        Message->Set(MSG_FMT_NO_MEMORY);
                        Message->Display("");
                        return FALSE;
                    }
                } else if (!cmem.Initialize(fat_pos + i * sec_per_fat * sector_size,
                                            sec_per_fat * sector_size)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }

                if (!(fat = NEW FAT)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }

                if (!fat->Initialize(&cmem, _drive, fat_lbn, _ClusterCount)) {

                    return FALSE;
                }

                if (!fat->Read()) {

                    Message->Set(MSG_DISK_ERROR_READING_FAT);
                    Message->Display("%d", 1 +
                                     (fat->QueryStartLbn() - _sector_zero.Bpb.ReservedSectors)/
                                     _sector_zero.Bpb.SectorsPerFat);
                    DELETE(fat);
                }

                // Break out as soon as there is a good fat
                if (fat) {

                    _fat = fat;
                    break;

                }
            }

            if (!_fat) {
                Message->Set(MSG_CANT_READ_ANY_FAT);
                Message->Display("");

                return FALSE;
            }
        }

        // Check the root directory.
        if ( _dirF32 ) {

            //
            // If _hmem_F32 has not been allocated, _dirF32 has not been properly
            // initialized.
            //
            if (!_hmem_F32) {

                if (!(_hmem_F32 = NEW HMEM)) {

                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;

                }

                if (!_hmem_F32->Initialize()) {
                    Destroy();
                    return FALSE;
                }

                if (!_dirF32->Initialize( _hmem_F32, _drive,
                                          this, _fat,
                                          _sector_zero.Bpb.RootDirStrtClus)) {
                    Destroy();
                    return FALSE;
                }

            }

            if (!_dirF32->Read()) {

                //
                //  Don't bail out immediately after a bad FAT32 root directory
                //  read. Chkdsk may be able to recover part of a damaged
                //  root directory
                //
                DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
            }

        } else {
            if (!_dir || !_dir->Read()) {

                Message->Set(MSG_BAD_DIR_READ);
                Message->Display("%s","\\");
                return FALSE;
            }
        }

    } else {

        UnpackExtendedBios(&_sector_zero,
                           (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

        // Changed to allow FAT 32 passage, KLUDGE?
        if (!_fat && ( ( _dirF32 ) || (QueryLength() > _sec_per_boot))) {
            fat_lbn = _sector_zero.Bpb.ReservedSectors;
            sector_size = _drive->QuerySectorSize();

        //
        // In the case where the SECRUN::Read works for the whole superarea we
        //  simply initialize _fat to point at the first FAT.
        //
        if (!cmem.Initialize((PCHAR) SECRUN::GetBuf() + fat_lbn*sector_size,
                                 QuerySectorsPerFat()*sector_size)) {

        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
            }

            if (!(_fat = NEW FAT)) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            if (!_fat->Initialize(&cmem, _drive, fat_lbn, _ClusterCount,
                                  QuerySectorsPerFat())) {

        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
            }

            // Complete "FAT_32_Root" FILEDIR initialization after NEW FAT above
            if (LARGE32 == _ft) {

                if (!(_hmem_F32 = NEW HMEM)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }
                // This is part two of init above, we needed _fat defined first !!!!
                if (!_hmem_F32->Initialize()) {

                    Destroy();
                    return FALSE;

                }
                // This is part two of init above, we needed _fat defined first !!!!
                if (!_dirF32->Initialize( _hmem_F32, _drive,
                                          this, _fat,
                                          _sector_zero.Bpb.RootDirStrtClus)) {
                    //
                    //  Don't bail out immediately after a bad FAT32 root directory
                    //  initialization. Chkdsk may be able to recover part of a damaged
                    //  root directory
                    //
                    DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
                    return TRUE;
                }

                if (!_dirF32->Read()) {
                    //
                    //  Don't bail out immediately after a bad FAT32 root directory
                    //  read. Chkdsk may be able to recover part of a damaged
                    //  root directory
                    //
                    DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
                }
            }

        }
    }
    return TRUE;
}


BOOLEAN
REAL_FAT_SA::Write(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine writes the super area.  It will succeed if it can
    write the boot sector, the root directory, and at least one of
    the FATs.

    This routine will duplicate the working FAT to all other FATs
    in the super area.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SECRUN  secrun;
    CONT_MEM    cmem;
    ULONG   i;
    ULONG   fat_size;
    ULONG   sector_size;
    SECTORCOUNT num_res;
    SECTORCOUNT sec_per_fat;
    BOOLEAN FATok;


    // Dup the first FAT in the in memory superarea into all of the other
    // FATs in the in memory super area.
    if (_ft != LARGE32) {
    DupFats();
    }

    PackExtendedBios(&_sector_zero,
        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    // Writing the boot sector.
    if (!SECRUN::Write()) {

       if (!_fat || (!_dir && !_dirF32)) {

          Message->Set(MSG_CANT_WRITE_BOOT_SECTOR);
          Message->Display("");
          return FALSE;

       }

       PackExtendedBios(&_sector_zero,
                        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

       // Writing the bootstrap code
       if (!secrun.Initialize(&_mem, _drive, 0, _sec_per_boot) ||
           !secrun.Write()) {

          Message->Set(MSG_CANT_WRITE_BOOT_SECTOR);
          Message->Display("");
          return FALSE;
       }


       // Writing the root directory
       if ( !_dir ) {

          if (!_dirF32->Write()) {

             Message->Set(MSG_CANT_WRITE_ROOT_DIR);
             Message->Display("");
             return FALSE;
          }

       } else {

          if (!_dir->Write()) {

             Message->Set(MSG_CANT_WRITE_ROOT_DIR);
             Message->Display("");
             return FALSE;
          }
       }

       // Write the fat(s).

       FATok = FALSE;

       if (_fat->Write()) {
       FATok = TRUE;
       }
       sector_size = _drive->QuerySectorSize();
       num_res = _sector_zero.Bpb.ReservedSectors;
       sec_per_fat = QuerySectorsPerFat();
       fat_size = sec_per_fat*sector_size;
       for (i = 0; i < QueryFats(); i++) {
       if (num_res + (i*sec_per_fat) != _fat->QueryStartLbn()) {


        if(cmem.Initialize((PCHAR)_fat->GetBuf(),fat_size) &&
           secrun.Initialize(&cmem, _drive, num_res + (i*sec_per_fat), sec_per_fat) &&
           secrun.Write()) {

            FATok = TRUE;
        }
       }
       }
       if (!FATok) {
          Message->Set(MSG_BAD_FAT_WRITE);
          Message->Display("");
          return FALSE;
       } else {
          Message->Set(MSG_SOME_FATS_UNWRITABLE);
          Message->Display("");
       }
    } else if (_ft == LARGE32) {
    // SECRUN::Write doesn't write all of the FATs or the FAT32 root directory.

    // Write out the other FATs. Note that any failures on these writes
    // are basically ignored (except for MSG_SOME_FATS_UNWRITABLE) since
    // we already have the first FAT fully written out via SECRUN::Write

    FATok = TRUE;
    sector_size = _drive->QuerySectorSize();
    num_res = _sector_zero.Bpb.ReservedSectors;
    sec_per_fat = QuerySectorsPerFat();
    fat_size = sec_per_fat*sector_size;
    // NOTE that following loop starts at 1 not 0 as FAT 0 is already written out
    for (i = 1; i < QueryFats(); i++) {
        if(!cmem.Initialize((PCHAR) SECRUN::GetBuf() + (num_res * sector_size),fat_size) ||
           !secrun.Initialize(&cmem, _drive, num_res + (i*sec_per_fat), sec_per_fat) ||
           !secrun.Write()) {

            FATok = FALSE;
        }
    }
    if (!FATok) {
        Message->Set(MSG_SOME_FATS_UNWRITABLE);
        Message->Display("");
    }

    // Write out the FAT32 root directory

    if(_dirF32) {
        if (!_dirF32->Write()) {
        Message->Set(MSG_CANT_WRITE_ROOT_DIR);
        Message->Display("");
        return FALSE;
        }
    }
    }

    return TRUE;
}


UFAT_EXPORT
SECTORCOUNT
REAL_FAT_SA::QueryFreeSectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number of unused sectors on disk.

Arguments:

    None.

Return Value:

    The number of free sectors on disk.

--*/
{
    if (!_fat) {
        perrstk->push(ERR_NOT_READ, QueryClassId());
        return 0;
    }

    return _fat->QueryFreeClusters()*QuerySectorsPerCluster();
}


FATTYPE
REAL_FAT_SA::QueryFatType(
    ) CONST
/*++

Routine Description:

    This routine computes the FATTYPE of the FAT for this volume.

Arguments:

    None.

Return Value:

    The FATTYPE for the FAT.

--*/
{
    return _ft;
}


VOID
REAL_FAT_SA::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the local data in the fat super area.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_fat);
    DELETE(_dir);
    DELETE(_dirF32);
    _StartDataLbn = 0;
    _ClusterCount = 0;
    _sysid = SYSID_NONE;
    _data_aligned = FALSE;
    _AdditionalReservedSectors = MAXULONG;
}

BOOLEAN
REAL_FAT_SA::DupFats(
    )
/*++

Routine Description:

    This routine will duplicate the current FAT to all other FATs
    in the IN MEMORY super area.

    DO NOT call this on FAT32 drives since there is only one in memory FAT
    on FAT32 drives!!!!!!!

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    PCHAR       fat_pos;
    ULONG       fat_size;
    ULONG       sector_size;
    SECTORCOUNT num_res;
    SECTORCOUNT sec_per_fat;

    num_res = _sector_zero.Bpb.ReservedSectors;
    if (!_fat || !_drive || !(sector_size = _drive->QuerySectorSize())) {
        return FALSE;
    }

    if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {
           sec_per_fat = _sector_zero.Bpb.BigSectorsPerFat;
    } else {
        sec_per_fat = _sector_zero.Bpb.SectorsPerFat;
    }
    fat_size = sec_per_fat*sector_size;
    fat_pos = (PCHAR) SECRUN::GetBuf() + num_res*sector_size;

    for (i = 0; i < QueryFats(); i++) {
        if (num_res + i*sec_per_fat != _fat->QueryStartLbn()) {
            memcpy(fat_pos + i*fat_size, _fat->GetBuf(), (UINT) fat_size);
        }
    }

    return TRUE;
}


LBN
REAL_FAT_SA::ComputeStartDataLbn(
    ) CONST
/*++

Routine Description:

    This routine computes the first LBN of the data part of a FAT disk.
    In other words, the LBN of cluster 2.

Arguments:

    None.

Return Value:

    The LBN of the start of data.

--*/
{

    if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {

       return  _sector_zero.Bpb.ReservedSectors +
               _sector_zero.Bpb.Fats*_sector_zero.Bpb.BigSectorsPerFat;
    } else {

       return  _sector_zero.Bpb.ReservedSectors +
               _sector_zero.Bpb.Fats*_sector_zero.Bpb.SectorsPerFat +
               (_sector_zero.Bpb.RootEntries*BytesPerDirent - 1)/
               _drive->QuerySectorSize() + 1;
    }

}


#if !defined(_SETUP_LOADER_)

ULONG
REAL_FAT_SA::ComputeRootEntries(
    ) CONST
/*++

Routine Description:

    This routine uses the size of the disk and a standard table in
    order to compute the required number of root directory entries.

Arguments:

    None.

Return Value:

    The required number of root directory entries.

--*/
{

    if (_ft == LARGE32) {
        return 0;
    }

    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
#endif
            return 112;

        case F5_1Pt2_512:
        case F3_1Pt44_512:
#if defined(FE_SB) && defined(_X86_)
        case F3_1Pt2_512:
#endif
            return 224;

        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return 240;

#if defined(FE_SB) && defined(_X86_)
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
             return 192;

        case F8_256_128:
            return 68;
#endif
    }

    return 512;
}


USHORT
REAL_FAT_SA::ComputeSecClus(
    IN  SECTORCOUNT Sectors,
    IN  FATTYPE     FatType,
#if defined(FE_SB) && defined(_X86_)
    IN  MEDIA_TYPE  MediaType,
    IN  ULONG       SectorSize
#else
    IN  MEDIA_TYPE  MediaType
#endif
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster required
    based on the actual number of sectors.

Arguments:

    Sectors     - Supplies the total number of sectors on the disk.
    FatType     - Supplies the type of FAT.
    MediaType   - Supplies the type of the media.

Return Value:

    The required number of sectors per cluster.

--*/
{
    USHORT      sec_per_clus;
    SECTORCOUNT threshold;

    if (FatType == LARGE32) {

        if (Sectors >= 64*1024*1024) {
            sec_per_clus = 64;                  /* over 32GB -> 32K */
        } else if (Sectors >= 32*1024*1024) {
            sec_per_clus = 32;                  /* up to 32GB -> 16K */
        } else if (Sectors >= 16*1024*1024) {
            sec_per_clus = 16;                  /* up to 16GB -> 8K */
        } else {
            sec_per_clus = 8;                   /* up to 8GB -> 4K */
        }

        return sec_per_clus;
    }

    if (FatType == SMALL) {
        threshold = MIN_CLUS_BIG;
        sec_per_clus = 1;
    } else {
        threshold = MAX_CLUS_BIG;
        sec_per_clus = 1;
    }

    while (Sectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    return sec_per_clus;
}

#endif // _SETUP_LOADER_

extern VOID DoInsufMemory(VOID);

BOOLEAN
REAL_FAT_SA::RecoverChain(
    IN OUT  PULONG      StartingCluster,
    OUT     PBOOLEAN    ChangesMade,
    IN      ULONG       EndingCluster,
    IN      BOOLEAN     Replace
    )
/*++

Routine Description:

    This routine will recover the chain beginning with 'StartingCluster'
    in the following way.  It will verify the readability of every cluster
    until it reaches 'EndingCluster' or the end of the chain.  If a cluster
    is not readable then 'ChangesMade' will be set to TRUE, the FAT will
    be marked to indicate that the cluster is bad, and the cluster will be
    taken out of the chain.  Additionally, if 'Replace' is set to TRUE,
    the FAT will be scanned for a readable free cluster to replace the lost
    ones with.  Failure to accomplish this will result in a return value
    of FALSE being returned.

    If the very first cluster of the chain was bad then then
    'StartingCluster' will be set with the new starting cluster of the
    chain even if this starting cluster is past 'EndingCluster'.  If the
    chain is left empty then 'StartingCluster' will be set to zero.

Arguments:

    StartingCluster - Supplies the first cluster of the chain to recover.
    ChangesMade     - Returns TRUE if changes to the chain were made.
    EndingCluster   - Supplies the final cluster to recover.
    Replace         - Supplies whether or not to replace bad clusters with
                      new ones.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST           max_transfer_bytes  = 65536;
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           clus, prev;
    ULONG           replacement;
    BOOLEAN         finished;
    ULONG           max_clusters;
    ULONG           chain_length;
    ULONG           i;

    DebugAssert(_fat);
    DebugAssert(ChangesMade);
    DebugAssert(StartingCluster);

    if (!hmem.Initialize()) {
    DoInsufMemory();
        return FALSE;
    }

    *ChangesMade = FALSE;
    finished = TRUE;

    max_clusters = (USHORT)(max_transfer_bytes /
                   QuerySectorsPerCluster() /
                   _drive->QuerySectorSize());

    if (!max_clusters) {
        max_clusters = 1;
    }

    chain_length = _fat->QueryLengthOfChain(*StartingCluster);

    for (i = 0; i < chain_length; i += max_clusters) {

        if (!cluster.Initialize(&hmem, _drive, this, _fat,
                                _fat->QueryNthCluster(*StartingCluster, i),
                                min(max_clusters, chain_length - i))) {

            DebugPrintTrace(("Unable to initialize cluster object. i = %d\n, chain_length = %d\n, max_clusters = %d\n", i, chain_length, max_clusters));
            return FALSE;
        }

        if (!cluster.Read()) {

            // Since the quick analysis detected some errors do the slow
            // analysis to pinpoint them.

            finished = FALSE;
            break;
        }
    }

    prev = 0;
    clus = *StartingCluster;

    if (!clus) {
        return TRUE;
    }

    while (!finished) {
        if (!cluster.Initialize(&hmem, _drive, this, _fat, clus, 1)) {
            DebugPrintTrace(("Unable to initialize cluster object.1\n"));
            return FALSE;
        }

        finished = (BOOLEAN) (_fat->IsEndOfChain(clus) || clus == EndingCluster);

        if (!cluster.Read()) {

            // There is a bad cluster so indicate that changes will be made.

            *ChangesMade = TRUE;


            // Take the bad cluster out of the cluster chain.

            if (prev) {

               _fat->SetEntry(prev, _fat->QueryEntry(clus));
               _fat->SetClusterBad(clus);
               clus = prev;

            } else {

               *StartingCluster = _fat->IsEndOfChain(clus) ? 0 :
                                  _fat->QueryEntry(clus);
               _fat->SetClusterBad(clus);
               clus = 0;

            }


            // If a replacement cluster is wanted then get one.

            if (Replace) {

                if (!(replacement = _fat->AllocChain(1))) {
                    DebugPrintTrace(("Unable to allocate replacement cluster.\n"));
                    return FALSE;
                }


                // Zero fill and write the replacement.

                cluster.Initialize(&hmem, _drive, this, _fat, replacement, 1);
                memset(hmem.GetBuf(), 0, (UINT) hmem.QuerySize());
                cluster.Write();


                if (finished) {
                    EndingCluster = replacement;
                    finished = FALSE;
                }


                // Link in the replacement.

                if (prev) {
                    _fat->InsertChain(replacement, replacement, prev);
                } else {
                    if (*StartingCluster) {
                        _fat->SetEntry(replacement, *StartingCluster);
                    }
                    *StartingCluster = replacement;
                }
            }
        }

        prev = clus;
        clus = clus ? _fat->QueryEntry(clus) : *StartingCluster;
    }

    return TRUE;
}

ULONG
REAL_FAT_SA::QueryFat32RootDirStartingCluster (
    )
/*++

Routine Description:

    This routine queries the root directory starting cluster from the FAT32 bpb.

Arguments:

    None.

Return Value:

    ULONG - The FAT32 root directory starting cluster.

--*/

{

    // Only FAT32 related code should call this function.
    DebugAssert(_ft == LARGE32);

    return _sector_zero.Bpb.RootDirStrtClus;

}


VOID
REAL_FAT_SA::SetFat32RootDirStartingCluster (
    IN  ULONG   RootCluster
    )
/*++

Routine Description:

    This routine sets the root directory starting cluster in the FAT32 bpb.

Arguments:

    RootCluster - Supplies the new root directory starting cluster.

Return Value:

    None.

--*/

{

    // Only FAT32 related code should call this function.
    DebugAssert(_ft == LARGE32);

    _sector_zero.Bpb.RootDirStrtClus = RootCluster;

}

ULONG
REAL_FAT_SA::SecPerBoot()
{
    return _sec_per_boot;
}

BOOLEAN
REAL_FAT_SA::SetBootCode(
    )
/*++

Routine Description:

    This routine sets the boot code in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _sector_zero.IntelNearJumpCommand = 0xEB;
    if (_ft == LARGE32)
    _sector_zero.BootStrapJumpOffset  = 0x9058;
    else
    _sector_zero.BootStrapJumpOffset  = 0x903C;
    SetBootSignature();
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::SetPhysicalDriveType(
    IN  PHYSTYPE    PhysType
    )
/*++

Routine Description:

    This routine sets the physical drive type in the super area.

Arguments:

    PhysType    - Supplies the physical drive type.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _sector_zero.PhysicalDrive = (UCHAR)PhysType;
    return TRUE;
}

INLINE
BOOLEAN
REAL_FAT_SA::SetOemData(
    )
/*++

Routine Description:

    This routine sets the OEM data in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    memcpy( (void*)_sector_zero.OemData, (void*)OEMTEXT, OEMTEXTLENGTH);
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::SetSignature(
    )
/*++

Routine Description:

    This routine sets the sector zero signature in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_sector_sig) {
        perrstk->push(ERR_NOT_INIT, QueryClassId());
        return FALSE;
    }

    *_sector_sig = sigSUPERSEC1;
    *(_sector_sig + 1) = sigSUPERSEC2;

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::VerifyBootSector(
    )
/*++

Routine Description:

    This routine checks key parts of sector 0 to insure that the data
    being examined is indeed a zero sector.

Arguments:

    None.

Return Value:

    FALSE   - Invalid sector zero.
    TRUE    - Valid sector zero.

--*/
{
    PUCHAR  p;

// We don't check for 55 AA anymore because we have reason to
// believe that there are versions of FORMAT out there that
// don't put it down.

#if 0
    if (!IsFormatted()) {
        return FALSE;
    }
#endif

    p = (PUCHAR) GetBuf();

#if defined(FE_SB) &&  defined(_X86_)
    return p[0] == 0x49 ||  /* FMR */
           p[0] == 0xE9 ||
          (p[0] == 0xEB && p[2] == 0x90);
#else
    return p[0] == 0xE9 || (p[0] == 0xEB && p[2] == 0x90);
#endif
}

ULONG
REAL_FAT_SA::QuerySectorFromCluster(
    IN  ULONG   Cluster,
    OUT PUCHAR  NumSectors
    )
{
    if (NULL != NumSectors) {
        *NumSectors = (UCHAR)QuerySectorsPerCluster();
    }

    return (Cluster - FirstDiskCluster)*QuerySectorsPerCluster() +
           QueryStartDataLbn();
}

BOOLEAN
REAL_FAT_SA::IsClusterCompressed(
    IN  ULONG
    ) CONST
{
    return FALSE;
}

VOID
REAL_FAT_SA::SetClusterCompressed(
    IN  ULONG,
    IN  BOOLEAN fCompressed
    )
{
    if (fCompressed) {
        DebugAssert("REAL_FAT_SA shouldn't have compressed clusters.");
    }
}

UCHAR
REAL_FAT_SA::QuerySectorsRequiredForPlainData(
        IN      ULONG
        )
{
    DebugAssert("REAL_FAT_SA didn't expect call to QuerySectorsRequiredForPlainData\n");
    return 0;

}

BOOLEAN
REAL_FAT_SA::VerifyFatExtensions(
    FIX_LEVEL, PMESSAGE, PBOOLEAN
    )
{
    //
    // We have no fat extensions, we're real.
    //

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::CheckSectorHeapAllocation(
    FIX_LEVEL, PMESSAGE, PBOOLEAN
    )
{
    //
    // We have no sector heap, we're real.
    //

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::AllocateClusterData(
    ULONG, UCHAR, BOOLEAN, UCHAR
    )
{
    DebugAbort("Didn't expect REAL_FAT_SA::AllocateClusterData to be "
        "called.");
    return FALSE;
}

BOOLEAN
REAL_FAT_SA::FreeClusterData(
    ULONG
    )
{
    DebugAbort("Didn't expect REAL_FAT_SA::FreeClusterData to be "
        "called.");
    return FALSE;
}

BYTE
REAL_FAT_SA::QueryVolumeFlags(
    ) CONST
/*++

Routine Description:

    This routine returns the volume flags byte from the bpb.

Arguments:

    None.

Return Value:

    The flags.

--*/
{
    ULONG clus1;
    BYTE  CurrHd;

    if(_fat) {
    clus1 = _fat->QueryEntry(1);
    } else {
    clus1 = 0x0FFFFFFF;
    }
    CurrHd = _sector_zero.CurrentHead;

    if (_ft == LARGE32) {
        if((!(CurrHd & FAT_BPB_RESERVED_DIRTY)) && (!(clus1 & CLUS1CLNSHUTDWNFAT32))) {
            CurrHd |= FAT_BPB_RESERVED_DIRTY;
        }
        if((!(CurrHd & FAT_BPB_RESERVED_TEST_SURFACE)) && (!(clus1 & CLUS1NOHRDERRFAT32))) {
            CurrHd |= FAT_BPB_RESERVED_TEST_SURFACE;
        }
    } else if (_ft == LARGE16) {
        if((!(CurrHd & FAT_BPB_RESERVED_DIRTY)) && (!(clus1 & CLUS1CLNSHUTDWNFAT16))) {
            CurrHd |= FAT_BPB_RESERVED_DIRTY;
        }
        if((!(CurrHd & FAT_BPB_RESERVED_TEST_SURFACE)) && (!(clus1 & CLUS1NOHRDERRFAT16))) {
            CurrHd |= FAT_BPB_RESERVED_TEST_SURFACE;
        }
    }
    return(CurrHd);
}

VOID
REAL_FAT_SA::SetVolumeFlags(
    BYTE Flags,
    BOOLEAN ResetFlags
    )
/*++

Routine Description:

    This routine sets the volume flags in the bpb.

Arguments:

    Flags       -- flags to set or clear
    ResetFlags  -- if true, Flags are cleared instead of set

Return Value:

    None.

--*/
{
    ULONG clus1;

    if (ResetFlags) {
        _sector_zero.CurrentHead &= ~Flags;
    if(_fat) {
        clus1 = _fat->QueryEntry(1);
        if (_ft == LARGE32) {
        if(Flags & FAT_BPB_RESERVED_DIRTY) {
            clus1 |= CLUS1CLNSHUTDWNFAT32;
        }
        if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
            clus1 |= CLUS1NOHRDERRFAT32;
        }
        } else if (_ft == LARGE16) {
        if(Flags & FAT_BPB_RESERVED_DIRTY) {
            clus1 |= CLUS1CLNSHUTDWNFAT16;
        }
        if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
            clus1 |= CLUS1NOHRDERRFAT16;
        }
        }
        _fat->SetEntry(1, clus1);
    }
    } else {
        _sector_zero.CurrentHead |= Flags;
    if(_fat) {
        clus1 = _fat->QueryEntry(1);
        if (_ft == LARGE32) {
        if(Flags & FAT_BPB_RESERVED_DIRTY) {
            clus1 &= ~CLUS1CLNSHUTDWNFAT32;
        }
        if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
            clus1 &= ~CLUS1NOHRDERRFAT32;
        }
        } else if (_ft == LARGE16) {
        if(Flags & FAT_BPB_RESERVED_DIRTY) {
            clus1 &= ~CLUS1CLNSHUTDWNFAT16;
        }
        if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
            clus1 &= ~CLUS1NOHRDERRFAT16;
        }
        }
        _fat->SetEntry(1, clus1);
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\secrun.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    secrun.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "secrun.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( SECRUN, OBJECT, IFSUTIL_EXPORT );


VOID
SECRUN::Construct (
        )

/*++

Routine Description:

    Constructor for class SECRUN.  This function initializes the
    member variables to "dummy" states.  The member function 'Init'
    must be called to make this class "work".

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _drive = NULL;
    _start_sector = 0;
    _num_sectors = 0;
}


VOID
SECRUN::Destroy(
    )
/*++

Routine Description:

    This routine puts the object back into its initial and empty state.
    It is not necessary to call this function between calls to 'Init'
    as Init will call this function automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _drive = NULL;
    _start_sector = 0;
    _num_sectors = 0;
}


IFSUTIL_EXPORT
SECRUN::~SECRUN(
    )
/*++

Routine Description:

    Destructor of sector run object.  Returns references.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Initialize(
    IN OUT  PMEM            Mem,
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      BIG_INT         StartSector,
    IN      SECTORCOUNT     NumSectors
    )
/*++

Routine Description:

    This member function initializes the class so that reads and writes
    may take place.

Arguments:

    Mem                 - Supplies means by which to acquire sufficient memory.
    Drive               - Supplies drive interface.
    StartSector         - Supplies starting LBN.
    NumSector           - Supplies the number of LBNs.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    ULONG   size;

    Destroy();

    DebugAssert(Drive);
    DebugAssert(Mem);

    _drive = Drive;
    _start_sector = StartSector;
    _num_sectors = NumSectors;
    size = _num_sectors*_drive->QuerySectorSize();
    _buf = Mem->Acquire(size, _drive->QueryAlignmentMask());

    if (!size || !_buf) {
        return FALSE;
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Read(
    )
/*++

Routine Description:

    This member function reads the sectors on disk into memory.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(_buf);
    return _drive->Read(_start_sector, _num_sectors, _buf);
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Write(
    )
/*++

Routine Description:

    This member function writes onto the disk.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(_buf);
    return _drive->Write(_start_sector, _num_sectors, _buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\sortcnt.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    sortcnt.cxx

Abstract:

    This module contains the definition for the SORTABLE_CONTAINER class.

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"
#include "sortcnt.hxx"


DEFINE_CONSTRUCTOR( SORTABLE_CONTAINER, SEQUENTIAL_CONTAINER );

SORTABLE_CONTAINER::~SORTABLE_CONTAINER(
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\sortlist.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    sortlist.cxx

Abstract:

    This module contains the definition for the SORTED_LIST class.
    SORTED_LIST is a concrete implementation of a SORTABLE_CONTAINER, where
    all the elements are maintained in sorted order.

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "sortlist.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( SORTED_LIST, SORTABLE_CONTAINER, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( SORTED_LIST );

VOID
SORTED_LIST::Construct (
    )

/*++

Routine Description:

    Constructor for SORTED_LIST

Arguments:

    None.

Return Value:

    None.

--*/

{
}





ULIB_EXPORT
SORTED_LIST::~SORTED_LIST (
    )

/*++

Routine Description:

    Destructor for SORTED_LIST

Arguments:

    None.

Return Value:

    None.

--*/

{
}



ULIB_EXPORT
BOOLEAN
SORTED_LIST::Initialize (
    IN BOOLEAN  Ascending
    )

/*++

Routine Description:

    Initializes a SORTED_LIST object.

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN - TRUE if the SORTED_LIST is successfully initialized.

--*/

{
    _Ascending = Ascending;

#if DBG==1
    _IteratorCount      = 0;
#endif

    return _Array.Initialize();
}




ULIB_EXPORT
BOOLEAN
SORTED_LIST::DeleteAllMembers (
    )

/*++

Routine Description:

    Deletes all the members of the sorted list

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if all members deleted

--*/

{
    return _Array.DeleteAllMembers();
}





ULIB_EXPORT
BOOLEAN
SORTED_LIST::Put (
    IN OUT  POBJECT Member
    )

/*++

Routine Description:

    Puts an OBJECT in the sorted list, maintaining the list sorted

Arguments:

    Member  -   Supplies the OBJECT to place in the array

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise

--*/

{
    if ( _Array.QueryMemberCount() > 0 ) {
        return _Array.Insert( Member, Search( Member, 0, _Array.QueryMemberCount()-1 ) );
    } else {
        return _Array.Insert( Member, 0 );
    }
}




ULIB_EXPORT
PITERATOR
SORTED_LIST::QueryIterator (
    ) CONST

/*++

Routine Description:

    Creates an iterator object for this sorted-list.

Arguments:

    None.

Return Value:

    PITERATOR - Pointer to an ITERATOR object.

--*/

{



    return (PITERATOR)_Array.QueryIterator();
}



ULIB_EXPORT
ULONG
SORTED_LIST::QueryMemberCount (
    ) CONST

/*++

Routine Description:

    Obtains the number of elements in the list

Arguments:

    None

Return Value:

    ULONG   -   The number of members in the list


--*/

{
    return _Array.QueryMemberCount();
}


POBJECT
SORTED_LIST::Remove (
    IN OUT  PITERATOR   Position
    )

/*++

Routine Description:

    Removes a member from the list

Arguments:

    Position    -   Supplies an iterator whose currency is to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    return _Array.Remove( Position );
}




BOOLEAN
SORTED_LIST::Sort (
    IN  BOOLEAN Ascending
    )

/*++

Routine Description:

    Sorts the array

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN -   TRUE if array sorted, FALSE otherwise


--*/

{
    if ( ( Ascending == _Ascending ) ||
          _Array.Sort( Ascending ) ) {

        _Ascending = Ascending;
        return TRUE;

    } else {

        return FALSE;
    }
}




ULONG
SORTED_LIST::Search(
    IN  PCOBJECT    Key,
    IN  ULONG       FirstIndex,
    IN  ULONG       LastIndex
    )

/*++

Routine Description:

    Searches an element that matches the supplied key.
    If no such element is found, this method returns
    the element one past the largest element less
    than the given element.

Arguments:

    Key         -   Supplies the key
    FirstIndex  -   Supplies lowerbound for the search
    LastIndex   -   Supplies upperbound for the search

Return Value:

    ULONG   -   Index of the element that matched the key, or
                LastIndex+1 if no match

--*/

{
    LONG    First, Middle, Last;
    LONG    Match;

    DebugPtrAssert( Key );
    DebugPtrAssert( FirstIndex < _Array.QueryMemberCount() );
    DebugPtrAssert( (LastIndex == INVALID_INDEX)  ||
                  (LastIndex < _Array.QueryMemberCount()) );
    DebugPtrAssert( FirstIndex <= LastIndex );

    if (LastIndex == INVALID_INDEX) {
        return 0;
    }

    First = FirstIndex;
    Last = LastIndex;
    while (First <= Last) {
        Middle = (First + Last)/2;
        Match = _Array.CompareAscDesc((POBJECT) Key,
                                      _Array.GetAt(Middle),
                                      _Ascending);

        if (!Match) {
            break;
        }

        if (Match < 0) {
            Last = Middle - 1;
        } else {
            First = ++Middle;
        }
    }

    return Middle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\seqcnt.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    seqcnt.cxx

Abstract:

    This module contains the definition for the SEQUENTIAL_CONTAINER class.
    There exists no implementation, merely a constructor that acts as a link
    between derived classes as SEQUENTIAL_CONTAINERs base class CONTAINER.

Environment:

    ULIB, User Mode

[Notes:]

    optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"
#include "seqcnt.hxx"


DEFINE_CONSTRUCTOR( SEQUENTIAL_CONTAINER, CONTAINER );

SEQUENTIAL_CONTAINER::~SEQUENTIAL_CONTAINER(
    )
{
}

ULIB_EXPORT
BOOLEAN
SEQUENTIAL_CONTAINER::DeleteAllMembers(
    )
/*++

Routine Description:

    This routine not only removes all members from the container
    class, but also deletes all the objects themselves.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PITERATOR   iter;
    POBJECT     pobj;

    if (!(iter = QueryIterator())) {
        return FALSE;
    }

    iter->GetNext();
    while (iter->GetCurrent()) {
        pobj = Remove(iter);
        DELETE(pobj);
    }
    DELETE(iter);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\ulib.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    ulib.cxx

Abstract:

    This module contains run-time, global support for the ULIB class library.
    This support includes:

        - creation of CLASS_DESCRIPTORs
        - Global objects
        - Ulib to Win32 API mapping functions

Environment:

    ULIB, User Mode

Notes:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "error.hxx"

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ ) && !defined( _EFICHECK_ )

#include "system.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "bitvect.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "keyboard.hxx"
#include "message.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "pipestrm.hxx"
#include "prtstrm.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "timeinfo.hxx"

#include <locale.h>

#endif // _AUTOCHECK_ || _SETUP_LOADER_


//
// Constants
//

CONST CLASS_ID  NIL_CLASS_ID    = 0;

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#if DBG==1 || defined( EFI_DEBUG )

//
// UlibGlobalFlag is used to selectively enable debugging options at
// run-time.
//

ULONG           UlibGlobalFlag     = 0x00000000;

#ifdef EFI_DEBUG
extern "C" {

ULIB_EXPORT
VOID
__cdecl
DebugPrintfReal(
    IN char*    Format,
    IN ...
    )

#else

ULIB_EXPORT
VOID
DebugPrintfReal(
    IN PCSTR    Format,
    IN ...
    )
#endif
/*++

Routine Description:

    Printf to the debug console.

Arguments:

    Format      - Supplies a printf style format string.

Return Value:

    None.

--*/

{
    va_list     args;

    va_start( args, Format );

#if !defined( _EFICHECK_ )
    vsprintf( Buffer, Format, args );
#else

    #if defined(EFI_DEBUG)
    DEBUG((EFICHK_DBUG_MASK, (CHAR8 *)Format, args));
    #endif

#endif

    va_end( args );

#if !defined( _EFICHECK_ )
    OutputDebugStringA( Buffer );
#endif

}

#if defined( _EFICHECK_ )
}
#endif

#endif // DBG




#if !defined( _EFICHECK_ )
//
// GLobal object pointers.
//

// Clients of the DLL cannot access the DLL's
// global data yet, so I have the delightful hacks to get at it.

ULIB_EXPORT
PSTREAM
Get_Standard_Input_Stream(
 )
{
    return Standard_Input_Stream;
}

ULIB_EXPORT
PSTREAM
Get_Standard_Output_Stream(
 )
{
    return Standard_Output_Stream;
}

ULIB_EXPORT
PSTREAM
Get_Standard_Error_Stream(
 )
{
    return Standard_Error_Stream;
}

PSTREAM     Standard_Input_Stream;
PSTREAM     Standard_Output_Stream;
PSTREAM     Standard_Error_Stream;

#endif // _EFICHECK_

#endif // _AUTOCHECK_ || _SETUP_LOADER_

// Note: Who put this here?  Currently it is being defined
// by applications.  Something has to be done about this.
ERRSTACK* perrstk;


//
//  Declare class descriptors for all classes.
//

DECLARE_CLASS(  CLASS_DESCRIPTOR        );

DECLARE_CLASS(  ARRAY                   );
DECLARE_CLASS(  ARRAY_ITERATOR          );
DECLARE_CLASS(  BITVECTOR               );
DECLARE_CLASS(  CONT_MEM                );
DECLARE_CLASS(  CONTAINER               );
DECLARE_CLASS(  DSTRING                 );
DECLARE_CLASS(  FSTRING                 );
DECLARE_CLASS(  HMEM                    );
DECLARE_CLASS(  ITERATOR                );
DECLARE_CLASS(  LIST                    );
DECLARE_CLASS(  LIST_ITERATOR           );
DECLARE_CLASS(  MEM                     );
DECLARE_CLASS(  MESSAGE                 );
DECLARE_CLASS(  OBJECT                  );
DECLARE_CLASS(  SEQUENTIAL_CONTAINER    );
DECLARE_CLASS(  SORTABLE_CONTAINER      );
DECLARE_CLASS(  SORTED_LIST             );
DECLARE_CLASS(  SORTED_LIST_ITERATOR    );
DECLARE_CLASS(  STACK                   );
DECLARE_CLASS(  WSTRING                 );
DECLARE_CLASS(  STATIC_MEM_BLOCK_MGR    );
DECLARE_CLASS(  MEM_BLOCK_MGR           );

#if !defined( _EFICHECK_ )
 DECLARE_CLASS(  ARGUMENT                );
 DECLARE_CLASS(  ARGUMENT_LEXEMIZER      );
 DECLARE_CLASS(  BSTRING                 );
 DECLARE_CLASS(  BDSTRING                );
 DECLARE_CLASS(  BUFFER_STREAM           );
 DECLARE_CLASS(  BYTE_STREAM             );
 DECLARE_CLASS(  CHKDSK_MESSAGE          );
 DECLARE_CLASS(  COMM_DEVICE             );
 DECLARE_CLASS(  FILE_STREAM             );
 DECLARE_CLASS(  FLAG_ARGUMENT           );
 DECLARE_CLASS(  FSNODE                  );
 DECLARE_CLASS(  FSN_DIRECTORY           );
 DECLARE_CLASS(  FSN_FILE                );
 DECLARE_CLASS(  FSN_FILTER              );
 DECLARE_CLASS(  KEYBOARD                );
 DECLARE_CLASS(  LONG_ARGUMENT           );
 DECLARE_CLASS(  MULTIPLE_PATH_ARGUMENT  );
 DECLARE_CLASS(  PATH                    );
 DECLARE_CLASS(  PATH_ARGUMENT           );
 DECLARE_CLASS(  PIPE                    );
 DECLARE_CLASS(  PIPE_STREAM             );
 DECLARE_CLASS(  PROGRAM                 );
 DECLARE_CLASS(  PRINT_STREAM            );
 DECLARE_CLASS(  REST_OF_LINE_ARGUMENT   );
 DECLARE_CLASS(  SCREEN                  );
 DECLARE_CLASS(  STREAM_MESSAGE          );
 DECLARE_CLASS(  STREAM                  );
 DECLARE_CLASS(  STRING_ARGUMENT         );
 DECLARE_CLASS(  STRING_ARRAY            );
 DECLARE_CLASS(  TIMEINFO                );
 DECLARE_CLASS(  TIMEINFO_ARGUMENT       );
#endif

#if defined( _AUTOCHECK_ )

    DECLARE_CLASS( AUTOCHECK_MESSAGE    );
    DECLARE_CLASS( TM_AUTOCHECK_MESSAGE );

#endif // _AUTOCHECK_

#if defined( _EFICHECK_ )
    DECLARE_CLASS( EFICHECK_MESSAGE );
#endif

//
//  Local prototypes
//
STATIC
BOOLEAN
DefineClassDescriptors (
    );

STATIC
BOOLEAN
UndefineClassDescriptors (
    );

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ ) && !defined( _EFICHECK_ )

BOOLEAN
CreateStandardStreams (
    );

PSTREAM
GetStandardStream (
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    );

#endif // _AUTOCHECK_ || _SETUP_LOADER_


BOOLEAN
InitializeUlib (
    IN HANDLE   DllHandle,
    IN ULONG    Reason,
    IN PVOID    Reserved
    )

/*++

Routine Description:

    Initilize Ulib by constructing and initializing all global objects. These
    include:

        - all CLASS_DESCRIPTORs (class_cd)
        - SYSTEM (System)
        - Standard streams

Arguments:

    DllHandle   - Not used.
    Reason      - Supplies the reason why the entry point was called.
    Reserved    - Not used.

Return Value:

    BOOLEAN - Returns TRUE if all global objects were succesfully constructed
        and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Reserved );

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ ) || defined( _EFICHECK_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Ulib initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_ULIB_MEM_LEAK)
    DebugPrint("ULIB.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG   count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrintTrace(("ULIB.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            //
            // Initialization of ULIB can no longer depend on
            // the initialization of the standard streams since they don't seem
            // to exist for Windows programs (no console...)
            //

            if( !DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Ulib initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_ULIB_MEM_LEAK)
            DebugPrint("ULIB.DLL got attached.\n");
#endif

            CreateStandardStreams();

            {
                UINT Codepage;
                char achCodepage[12] = ".OCP";      // ".", "uint in decimal", null
                if (Codepage = GetConsoleOutputCP()) {
                    wsprintfA(achCodepage, ".%u", Codepage);
                }
                setlocale(LC_ALL, achCodepage);
            }

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrintTrace(("ULIB.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrint("ULIB.DLL got detached.\n");
#endif

                UndefineClassDescriptors();

                DELETE(Standard_Input_Stream);
                DELETE(Standard_Output_Stream);
                DELETE(Standard_Error_Stream);

                count--;
            } else {
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrint("ULIB.DLL detached more than attached\n");
#endif
            }
            break;

        break;

    }
#endif // _AUTOCHECK || _SETUP_LOADER_

    return( TRUE );

}

STATIC
BOOLEAN
DefineClassDescriptors (
    )

/*++

Routine Description:

    Defines all the class descriptors used by ULIB

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/

{

    // This is broken up into many ifs because of compiler limitations.

    BOOLEAN Success = TRUE;

    if (Success                                               &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    ARGUMENT                ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARGUMENT_LEXEMIZER      ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    ARRAY                   ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARRAY_ITERATOR          ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    BDSTRING                ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    BITVECTOR               ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    BYTE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    CHKDSK_MESSAGE          ) &&
        DEFINE_CLASS_DESCRIPTOR(    COMM_DEVICE             ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    CONTAINER               ) &&
        DEFINE_CLASS_DESCRIPTOR(    DSTRING                 ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    FLAG_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSNODE                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_DIRECTORY           ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_FILE                ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_FILTER              ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    ITERATOR                ) &&
        DEFINE_CLASS_DESCRIPTOR(    LIST                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    LIST_ITERATOR           ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    LONG_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    MULTIPLE_PATH_ARGUMENT  ) &&
        DEFINE_CLASS_DESCRIPTOR(    PATH                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    PATH_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    PROGRAM                 ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    SEQUENTIAL_CONTAINER    ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTABLE_CONTAINER      ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTED_LIST             ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTED_LIST_ITERATOR    ) &&
        DEFINE_CLASS_DESCRIPTOR(    WSTRING                 ) &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    BSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    STRING_ARGUMENT         ) &&
        DEFINE_CLASS_DESCRIPTOR(    STRING_ARRAY            ) &&
        DEFINE_CLASS_DESCRIPTOR(    TIMEINFO                ) &&
        DEFINE_CLASS_DESCRIPTOR(    TIMEINFO_ARGUMENT       ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    MESSAGE                 ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }


    if (Success                                               &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    BUFFER_STREAM           ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    CONT_MEM                ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    FILE_STREAM             ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    FSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    HMEM                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    STATIC_MEM_BLOCK_MGR    ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM_BLOCK_MGR           ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    KEYBOARD                ) &&
#endif
        DEFINE_CLASS_DESCRIPTOR(    MEM                     ) &&

#ifndef _EFICHECK_
        DEFINE_CLASS_DESCRIPTOR(    PIPE                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    PIPE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    PRINT_STREAM            ) &&
        DEFINE_CLASS_DESCRIPTOR(    REST_OF_LINE_ARGUMENT   ) &&
        DEFINE_CLASS_DESCRIPTOR(    SCREEN                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    STREAM                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    STREAM_MESSAGE          ) &&
#endif

#if defined( _AUTOCHECK_ )

        DEFINE_CLASS_DESCRIPTOR(    AUTOCHECK_MESSAGE       ) &&
        DEFINE_CLASS_DESCRIPTOR(    TM_AUTOCHECK_MESSAGE    ) &&

#endif // _AUTOCHECK_

#if defined( _EFICHECK_ )
        DEFINE_CLASS_DESCRIPTOR(    EFICHECK_MESSAGE        ) &&
#endif
        TRUE ) {
    } else {
        Success = FALSE;
    }


    if  (!Success) {
        DebugPrint( "Could not initialize class descriptors!");
    }
    return Success;

}


STATIC
BOOLEAN
UndefineClassDescriptors (
    )

/*++

Routine Description:

    Defines all the class descriptors used by ULIB

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/

{

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    ARGUMENT                );
    UNDEFINE_CLASS_DESCRIPTOR(    ARGUMENT_LEXEMIZER      );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    ARRAY                   );
    UNDEFINE_CLASS_DESCRIPTOR(    ARRAY_ITERATOR          );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    BDSTRING                );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    BITVECTOR               );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    BYTE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    CHKDSK_MESSAGE          );
    UNDEFINE_CLASS_DESCRIPTOR(    COMM_DEVICE             );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    CONTAINER               );
    UNDEFINE_CLASS_DESCRIPTOR(    DSTRING                 );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    FLAG_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    FSNODE                  );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_DIRECTORY           );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_FILE                );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_FILTER              );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    ITERATOR                );
    UNDEFINE_CLASS_DESCRIPTOR(    LIST                    );
    UNDEFINE_CLASS_DESCRIPTOR(    LIST_ITERATOR           );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    LONG_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    MULTIPLE_PATH_ARGUMENT  );
    UNDEFINE_CLASS_DESCRIPTOR(    PATH                    );
    UNDEFINE_CLASS_DESCRIPTOR(    PATH_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    PROGRAM                 );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    SEQUENTIAL_CONTAINER    );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTABLE_CONTAINER      );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTED_LIST             );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTED_LIST_ITERATOR    );
    UNDEFINE_CLASS_DESCRIPTOR(    WSTRING                 );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    BSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    STRING_ARGUMENT         );
    UNDEFINE_CLASS_DESCRIPTOR(    STRING_ARRAY            );
    UNDEFINE_CLASS_DESCRIPTOR(    TIMEINFO                );
    UNDEFINE_CLASS_DESCRIPTOR(    TIMEINFO_ARGUMENT       );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    MESSAGE                 );

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    BUFFER_STREAM           );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    CONT_MEM                );

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    FILE_STREAM             );
#endif
    UNDEFINE_CLASS_DESCRIPTOR(    FSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    HMEM                    );
    UNDEFINE_CLASS_DESCRIPTOR(    STATIC_MEM_BLOCK_MGR    );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM_BLOCK_MGR           );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM                     );

#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR(    KEYBOARD                );
    UNDEFINE_CLASS_DESCRIPTOR(    PIPE                    );
    UNDEFINE_CLASS_DESCRIPTOR(    PIPE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    PRINT_STREAM            );
    UNDEFINE_CLASS_DESCRIPTOR(    REST_OF_LINE_ARGUMENT   );
    UNDEFINE_CLASS_DESCRIPTOR(    SCREEN                  );
    UNDEFINE_CLASS_DESCRIPTOR(    STREAM                  );
    UNDEFINE_CLASS_DESCRIPTOR(    STREAM_MESSAGE          );
#endif

#if defined( _AUTOCHECK_ )

    UNDEFINE_CLASS_DESCRIPTOR(    AUTOCHECK_MESSAGE       );
    UNDEFINE_CLASS_DESCRIPTOR(    TM_AUTOCHECK_MESSAGE    );

#endif // _AUTOCHECK_

#if defined( _EFICHECK_ )
    UNDEFINE_CLASS_DESCRIPTOR(    EFICHECK_MESSAGE        );
#endif
    return TRUE;

}


#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ ) && !defined( _EFICHECK_ )

BOOLEAN
CreateStandardStreams (
    )

/*++

Routine Description:

    Creates the standard streams

Arguments:

    None.

Return Value:

    TRUE if the streams were successfully created,
    FALSE otherwise

--*/

{

    Standard_Input_Stream   = GetStandardStream( GetStdHandle( STD_INPUT_HANDLE),
                                                 READ_ACCESS );

    Standard_Output_Stream  = GetStandardStream( GetStdHandle( STD_OUTPUT_HANDLE),
                                                 WRITE_ACCESS );

    Standard_Error_Stream   = GetStandardStream( GetStdHandle( STD_ERROR_HANDLE),
                                                 WRITE_ACCESS );


    return ( (Standard_Input_Stream  != NULL) &&
             (Standard_Output_Stream != NULL) &&
             (Standard_Error_Stream  != NULL) );
}

PSTREAM
GetStandardStream (
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Creates a standard stream out of a standard handle

Arguments:

    Handle  -   Supplies the standard handle
    Access  -   Supplies the access.

Return Value:

    Pointer to the stream object created.

--*/


{
    PSTREAM         Stream = NULL;
    PFILE_STREAM    FileStream;
    PPIPE_STREAM    PipeStream;
    PKEYBOARD       Keyboard;
    PSCREEN         Screen;


    switch ( GetFileType( Handle ) ) {

    case (DWORD)FILE_TYPE_DISK:

        if ((FileStream = NEW FILE_STREAM) != NULL ) {
            if ( !FileStream->Initialize( Handle, Access ) ) {
                DELETE( FileStream );
            }
            Stream = (PSTREAM)FileStream;
        }
        break;


    case (DWORD)FILE_TYPE_CHAR:

        //
        //  BUGBUG   this type refers to all character devices, not
        //          just the console.  I will add some hacks to see if
        //          the handle refers to the console or not. This
        //          information should be given in a clean way by the
        //          API (talk with MarkL)
        //
        switch ( Access ) {

        case READ_ACCESS:

            //
            //  BUGBUG  Jaimes See if this is a console handle
            //
            {
                DWORD   Mode;
                if (!GetConsoleMode( Handle, &Mode )) {
                    //
                    //  This is not a console, but some other character
                    //  device. Create a pipe stream for it.
                    //
                    if ((PipeStream = NEW PIPE_STREAM) != NULL ) {
                        if ( !PipeStream->Initialize( Handle, Access ) ) {
                            DELETE( PipeStream );
                        }
                        Stream = (PSTREAM)PipeStream;
                    }
                    break;
                }
            }
            if ((Keyboard = NEW KEYBOARD) != NULL ) {
                if ( !Keyboard->Initialize() ) {
                    DELETE( Keyboard );
                }
                Stream = (PSTREAM)Keyboard;
            }
            break;

        case WRITE_ACCESS:

            //
            //  BUGBUG  See if this is a console handle
            //
            {
                DWORD   Mode;
                if (!GetConsoleMode( Handle, &Mode )) {
                    //
                    //  This is not a console, but some other character
                    //  device. Create a file stream for it.
                    //
                    if ((FileStream = NEW FILE_STREAM) != NULL ) {
                        if ( !FileStream->Initialize( Handle, Access ) ) {
                            DELETE( FileStream );
                        }
                        Stream = (PSTREAM)FileStream;
                    }
                    break;
                }
            }

            if ((Screen = NEW SCREEN) != NULL ) {
                if ( !Screen->Initialize() ) {
                    DELETE( Screen );
                }
                Stream = (PSTREAM)Screen;
            }
            break;

        default:
            break;
        }

        break;

    case (DWORD)FILE_TYPE_PIPE:

        if ((PipeStream = NEW PIPE_STREAM) != NULL ) {
            if ( !PipeStream->Initialize( Handle, Access ) ) {
                DELETE( PipeStream );
            }
            Stream = (PSTREAM)PipeStream;
        }
        break;

    case (DWORD)FILE_TYPE_UNKNOWN:
        // Probably a windows app. Don't print anything to debug.
        break;

    default:
        DebugPrintTrace(("ERROR: FileType for standard stream %lx is invalid (%lx)\n", Handle, GetFileType(Handle)));
        break;

    }

    return Stream;

}

NONVIRTUAL
ULIB_EXPORT
HANDLE
FindFirstFile (
    IN  PCPATH              Path,
    OUT PWIN32_FIND_DATA     FileFindData
    )

/*++

Routine Description:

    Perform a FindFirst file given a PATH rather tha a PSTR.

Arguments:

    Path         - Supplies a pointer to the PATH to search.
    FileFindData - Supplies a pointer where the results of the find is
        returned.

Return Value:

    HANDLE - Returns the results of the call to the Win32 FindFirstFile API.

--*/

{
    PWSTR           p;

    //
    // If the supplied pointers are non-NULL and an OEM representation
    // (i.e. API ready) of the PATH is available, return the
    // HANDLE returned by the Win32 FindFirstFile API
    //

    DebugPtrAssert( Path );
    DebugPtrAssert( FileFindData );
    if (!Path || !FileFindData) {
        return INVALID_HANDLE_VALUE;
    }

    p = (PWSTR) Path->GetPathString()->GetWSTR();
    if (!p) {
        return INVALID_HANDLE_VALUE;
    }

    return FindFirstFile(p, FileFindData);
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\volume.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    volume.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"
#include "error.hxx"
#include "volume.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"

#if !defined(_EFICHECK_)

#include "autoreg.hxx"

#if !defined(_AUTOCHECK_)
#include "path.hxx"
#endif

extern "C" {
#if !defined(_AUTOCHECK_)
    #include <stdio.h>
#endif // _AUTOCHECK_
    #include "bootreg.h"
}

#endif // _EFICHECK_

DEFINE_EXPORTED_CONSTRUCTOR( VOL_LIODPDRV, LOG_IO_DP_DRIVE, IFSUTIL_EXPORT );

VOID
VOL_LIODPDRV::Construct (
    )
/*++

Routine Description:

    Constructor for VOL_LIODPDRV.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _sa = NULL;
}

IFSUTIL_EXPORT
VOL_LIODPDRV::~VOL_LIODPDRV(
    )
/*++

Routine Description:

    Destructor for VOL_LIODPDRV.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
VOL_LIODPDRV::Destroy(
    )
/*++

Routine Description:

    This routine returns a VOL_LIODPDRV to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _sa = NULL;
}


IFSUTIL_EXPORT
FORMAT_ERROR_CODE
VOL_LIODPDRV::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PSUPERAREA  SuperArea,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine initializes a VOL_LIODPDRV to a valid state.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    SuperArea       - Supplies the superarea for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   MaxSectorsInVerify = 512;

    BIG_INT             chunk;
    BIG_INT             amount_to_verify;
    BIG_INT             i;
    BIG_INT             sectors;
    ULONG               percent;

    FORMAT_ERROR_CODE   errcode;

    Destroy();

    DebugAssert(NtDriveName);
    DebugAssert(SuperArea);

#if defined(FE_SB) && defined(_X86_)
    // PC98 Nov.01.1994
    // We need to notify DP_DRIVE::Initialize() through ForceFormat()
    // that we will format target madia.

    if (IsPC98_N() && MediaType) {
        ForceFormat(ANY);
    }
#endif // JAPAN && _X86_

    if (!LOG_IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite)) {
        return GeneralError;
    }

    if (!_bad_sectors.Initialize()) {
        return GeneralError;
    }

    _sa = SuperArea;

// BUGBUG EFI can we ignore unknown media type?

//    if (QueryMediaType() == Unknown && MediaType == Unknown) {
//        Message ? Message->DisplayMsg(MSG_DISK_NOT_FORMATTED) : 1;
//        return GeneralError;
//    }

    if (!FormatMedia &&
        (QueryMediaType() == Unknown ||
        (MediaType != Unknown && MediaType != QueryMediaType()))) {
        Message ? Message->DisplayMsg(MSG_CANT_QUICKFMT) : 1;
        if (Message ? Message->IsYesResponse(FALSE) : FALSE) {
            FormatMedia = TRUE;
        } else {
            return GeneralError;
        }
    }

    if (FormatMedia) {
        if (!Lock()) {
//            Message ? Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE) : 1;
            return LockError;
        }

        //
        //  We make a weird exception here for the Compaq 120MB floppy,
        //  because it wants to be formatted as if it were a hard disk.
        //

        if (IsFloppy() && MediaType != F3_120M_512) {

            BOOLEAN     rst;

#if !defined( _EFICHECK_ )

            es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                  ES_DISPLAY_REQUIRED|
                                                  ES_SYSTEM_REQUIRED,
                                                  &prev_state);

            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
            }

#endif

            rst = FormatVerifyFloppy(MediaType, &_bad_sectors, Message);

#if !defined( _EFICHECK_ )
            if (NT_SUCCESS(es_status)) {

                es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", es_status));
                }
            }
#endif
            if (!rst)
                return GeneralError;

        } else {

            sectors = QuerySectors();
            chunk = min( sectors/20 + 1, MaxSectorsInVerify );

            percent = 0;
            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return GeneralError;
            }

#if !defined(_EFICHECK_)
            es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                  ES_DISPLAY_REQUIRED|
                                                  ES_SYSTEM_REQUIRED,
                                                  &prev_state);

            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
            }
#endif
            errcode = NoError;
            for (i = 0; i < sectors; i += chunk) {

                if ((i.GetLowPart() & 0x3ff) == 0) {
                    if (!Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                        errcode = GeneralError;
                        break;
                    }
                }

                if (i*100/sectors > percent) {
                    percent = ((i*100)/sectors).GetLowPart();
                    if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                        errcode = GeneralError;
                        break;
                    }
                }

                amount_to_verify = min(chunk, sectors - i);

                if (!Verify(i, amount_to_verify, &_bad_sectors)) {
                    if (Message) {
                        Message->DisplayMsg( (QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE) ?
                                                MSG_FORMAT_NO_MEDIA_IN_DRIVE :
                                                MSG_CHK_NO_MEMORY );
                    }
                    errcode = GeneralError;
                    break;
                }
            }

#if !defined(_EFICHECK_)
            if (NT_SUCCESS(es_status)) {
                es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", es_status));
                }
            }
#endif

            if (errcode != NoError)
                return errcode;

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
                return GeneralError;
            }

        }
    }


    if (QuerySectors() == 0) {
        DebugAbort("Sectors is 0");
        return GeneralError;
    }

    return NoError;
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN      PSUPERAREA  SuperArea,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a VOL_LIODPDRV for a hosted
    volume, i.e. one that is implemented as a file on
    another volume.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    HostFileName    - Supplies the drive name for the host file.
    SuperArea       - Supplies the superarea for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    DebugAssert(HostFileName);
    DebugAssert(SuperArea);

    if (!LOG_IO_DP_DRIVE::Initialize(NtDriveName,
                                     HostFileName,
                                     Message,
                                     ExclusiveWrite)) {

        return FALSE;
    }

    if (!_bad_sectors.Initialize()) {
        return FALSE;
    }

    _sa = SuperArea;

    return TRUE;
}


IFSUTIL_EXPORT
FORMAT_ERROR_CODE
VOL_LIODPDRV::Format(
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       ClusterSize,
    IN      ULONG       VirtualSectors
    )
/*++

Routine Description:

    This routine formats a volume.

Arguments:

    Label   - Supplies an optional label for the volume.
    Message - Supplies an outlet for messages.
    flags   - Supplies flags to control behavior of format
    ClusterSize
            - supplies the cluster size for the volume.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return GeneralError;
    }

    if (!Lock()) {
        return LockError;
    }

    if (_sa->Create(&_bad_sectors,
                    Message, Label,
                    (Flags & FORMAT_BACKWARD_COMPATIBLE) ? TRUE : 0,
                    ClusterSize,
                    VirtualSectors)) {

        if (!DismountAndUnlock()) {
            return GeneralError;
        } else {

            PWSTRING    pLabel;
            DSTRING     label;
            NTSTATUS    status;

            pLabel = NULL;
            while (!NT_SUCCESS(status = _sa->FormatNotification(pLabel))) {
                if (status == STATUS_INVALID_VOLUME_LABEL) {

                    Message->Set(MSG_INVALID_LABEL_CHARACTERS);
                    Message->Display();

                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display();
                    Message->QueryStringInput(&label);

                    pLabel = &label;
                } else {
                    return GeneralError;
                }
            }
            return NoError;
        }
    } else
        return GeneralError;
}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::ChkDsk(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine checks the integrity of the file system on the volume.
    If there are any problems, this routine will attempt to fix them
    to the degree specified in 'FixLevel'.

Arguments:

    FixLevel            - Supplies the level to which the volume should be fixed.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies the flags that controls the behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Tells what logfile size the user wants.
    ExitStatus          - Returns and indication of how the chkdsk went.
    DriveLetter         - For autochk, tells which drive letter we're checking.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;
    ULONG exit_status;

    if (!Message) {
        Message = &msg;
    }

    if (NULL == ExitStatus) {
        ExitStatus = &exit_status;
    }

    if (!_sa) {
        return FALSE;
    }

    return _sa->VerifyAndFix(FixLevel,
                             Message,
                             Flags,
                             DesiredLogFileSize,
                             ExitStatus,
                             DriveLetter);
}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::Recover(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine searches the named file for bad allocation units.
    It removes these allocation units from the file and marks them
    as bad in the file system.

Arguments:

    FullPathFileName    - Supplies the name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return FALSE;
    }

    return _sa->RecoverFile(FullPathFileName, Message);
}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::ForceAutochk(
    IN  BOOLEAN     Fix,
    IN  ULONG       Options,
    IN  ULONG       LogFileSize,
    IN  PCWSTRING   Name
    )
/*++

Routine Description:

    This method schedules Autochk to be run at next boot.  If the client
    has not requested bad sector detection or logfile resizing, this
    scheduling is done simply by marking the volume dirty.  If bad sector
    detection or logfile resizing has been requested, the appropriate entry
    is put into the registry to force autochk to run.

Arguments:

    Fix             -- Supplies if chkdsk /f is being implied.
    Options         -- Supplies flags
                          CHKDSK_RECOVER
                          CHKDSK_RESIZE_LOGFILE
                          CHKDSK_SKIP_INDEX_SCAN
                          CHKDSK_SKIP_CYCLE_SCAN
    LogFileSize     -- If CHKDSK_RESIZE_LOGFILE, tells the desired size in bytes.
    Name            -- Supplies the volume's NT name.

Return Value:

    TRUE upon successful completion.

--*/
{
#if !defined( _AUTOCHECK_ ) && !defined( _EFICHECK_ )

    DSTRING             CommandLine;
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             nt_drive_name;
    DSTRING             drive_path_string;
    PATH                fullpath;
    PATH                dos_path;
    PCWSTRING           name;
    PATH_ANALYZE_CODE   rst;

    if (!CommandLine.Initialize( "autocheck autochk " )) {
        return FALSE;
    }

#if 0
    if (!(Options & (CHKDSK_RECOVER |
                     CHKDSK_SKIP_INDEX_SCAN |
                     CHKDSK_SKIP_CYCLE_SCAN |
                     CHKDSK_RESIZE_LOGFILE))) {

        DSTRING     all_drives;

        // The client has not asked for autochk /r, /l, or /i so it
        // suffices to mark the volume dirty.  Before we do that,
        // make sure there is an entry in the registry to look for
        // dirty volume.
        //

        if (!all_drives.Initialize("*"))
            return FALSE;

        if (AUTOREG::IsEntryPresent(&CommandLine, &all_drives))
            return ForceDirty();

        if (!CommandLine.Strcat(&all_drives))
            return FALSE;

        if (!AUTOREG::AddEntry(&CommandLine))
            return FALSE;

        return ForceDirty();
    }
#endif

    //
    // Let's schedule an explicit autochk.
    //

    //
    // Remove any previous entry of Name from the registry
    //

    if (!AUTOREG::DeleteEntry(&CommandLine, Name))
        return FALSE;

    //
    // Get the alternate name of the drive and remove any previous entry
    // for it from the registry
    //
    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(Name, &dos_drive_name) ||
        !dos_path.Initialize(&dos_drive_name))
        return FALSE;

    rst = dos_path.AnalyzePath(&volume_name,
                               &fullpath,
                               &drive_path_string);

    switch (rst) {
        case PATH_OK:
            DebugAssert(drive_path_string.QueryChCount() == 0);

            if (dos_path.GetPathString()->Stricmp(&volume_name) != 0) {
                // use volume_name as the alternate name
                name = &volume_name;
            } else {
                // try to use fullpath as the alternate name
                name = fullpath.GetPathString();

                if (name->QueryChCount() != 2)
                    break;  // alternate name not drive letter so done
            }

            if (!IFS_SYSTEM::DosDriveNameToNtDriveName(name, &nt_drive_name))
                return FALSE;

            if (!AUTOREG::DeleteEntry(&CommandLine, &nt_drive_name))
                return FALSE;

            break;

        default:
            return FALSE;
    }

    if (Options & CHKDSK_RECOVER) {

        DSTRING R_Option;

        if (!R_Option.Initialize( "/r " ) ||
            !CommandLine.Strcat( &R_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_SKIP_INDEX_SCAN) {

        DSTRING I_Option;

        if (!I_Option.Initialize( "/i " ) ||
            !CommandLine.Strcat( &I_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_SKIP_CYCLE_SCAN) {

        DSTRING C_Option;

        if (!C_Option.Initialize( "/c " ) ||
            !CommandLine.Strcat( &C_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_RESIZE_LOGFILE) {

        DSTRING L_Option;
        CHAR buf[20];

        sprintf(buf, "/l:%d ", LogFileSize / 1024);

        if (!L_Option.Initialize( buf ) ||
            !CommandLine.Strcat( &L_Option )) {

            return FALSE;
        }
    }

    //
    // if /f specified but it's not because of /r, /i, or /c, then
    // specify /p as well.  The options /r, /i, or /c implies /p
    // for autochk.
    //
    if (Fix &&
        !(Options & (CHKDSK_RECOVER |
                     CHKDSK_SKIP_INDEX_SCAN |
                     CHKDSK_SKIP_CYCLE_SCAN))) {
        DSTRING P_Option;

        if (!P_Option.Initialize( "/p " ) ||
            !CommandLine.Strcat( &P_Option )) {

            return FALSE;
        }
    }

    return CommandLine.Strcat( Name ) &&
           AUTOREG::PushEntry( &CommandLine );
#else

    return FALSE;

#endif // _AUTOCHECK_
}


#if defined(FE_SB) && defined(_X86_)

USHORT  VOL_LIODPDRV::_force_format = NONE;
BOOLEAN VOL_LIODPDRV::_force_convert_fat = FALSE;

IFSUTIL_EXPORT
VOID
VOL_LIODPDRV::ForceFormat(
    IN  USHORT FileSystem
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    if (FileSystem != ANY || _force_format == NONE)
        _force_format = FileSystem;
}

USHORT
VOL_LIODPDRV::QueryForceFormat(
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    return _force_format;
}

VOID
VOL_LIODPDRV::ForceConvertFat(
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    _force_convert_fat = TRUE;
}

BOOLEAN
VOL_LIODPDRV::QueryConvertFat(
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    return _force_convert_fat;
}

#endif // FE_SB && _X86_


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::QueryAutochkTimeOut(
    OUT PULONG      TimeOut
    )
/*++

Routine Description:

    This routine returns the count down time before autochk
    resumes.

Arguments:

    TimeOut     -- Supplies the location to store the timeout value.

Return Value:

    TRUE if successful.

--*/
{
#if !defined( _EFICHECK_ )
    return QueryTimeOutValue(TimeOut);
#else
    return FALSE;
#endif
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::SetAutochkTimeOut(
    IN  ULONG      TimeOut
    )
/*++

Routine Description:

    This routine sets the count down time before autochk
    resumes.

Arguments:

    TimeOut     -- Supplies the count down time in seconds

Return Value:

    TRUE if successful.

--*/
{
#if !defined( _EFICHECK_ )
    return SetTimeOutValue(TimeOut);
#else
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\ufat.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

        ufat.cxx

Abstract:

        This module contains run-time, global support for the
        FAT IFS Utilities library (UFAT).       This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ulib.hxx"
#include "ufat.hxx"

#include "error.hxx"

extern "C" {
    #include "rtmsg.h"
}


#if defined( _AUTOCHECK_ ) || defined( _EFICHECK_ )

BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    );

#else

ERRSTACK* perrstk;

#endif // _AUTOCHECK_

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

BOOLEAN
PatchFatAndFat32BootCodeMessages(
    VOID
    );

extern "C"
UFAT_EXPORT
BOOLEAN
InitializeUfat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

UFAT_EXPORT
BOOLEAN
InitializeUfat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined(FE_SB) && defined(_X86_)
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize Machine Id
        //
        InitializeMachineData();
    }
#endif

#if defined( _AUTOCHECK_ ) || defined( _EFICHECK_ )

    UNREFERENCED_PARAMETER( Reason );

    if(!PatchFatAndFat32BootCodeMessages()) {
        DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
        return(FALSE);
    }

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Ufat initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UFAT_MEM_LEAK)
    DebugPrint("UFAT.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchFatAndFat32BootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UFAT.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrintTrace(("UFAT.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Ufat initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UFAT_MEM_LEAK)
            DebugPrint("UFAT.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrintTrace(("UFAT.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrint("UFAT.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrint("UFAT.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif _AUTOCHECK_ || _SETUP_LOADER_

    return TRUE;
}



DECLARE_CLASS(  CLUSTER_CHAIN           );
DECLARE_CLASS(  EA_HEADER               );
DECLARE_CLASS(  EA_SET                  );
DECLARE_CLASS(  FAT                     );
DECLARE_CLASS(  FATDIR                  );
DECLARE_CLASS(  FAT_DIRENT              );
DECLARE_CLASS(  FAT_SA                  );
DECLARE_CLASS(  FAT_VOL                 );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  FATDB_VOL               );
#endif // DBLSPACE_ENABLED
DECLARE_CLASS(  FILEDIR                 );
DECLARE_CLASS(  HASH_INDEX              );
DECLARE_CLASS(  ROOTDIR                 );
#ifndef _EFICHECK_
DECLARE_CLASS(  RELOCATION_CLUSTER      );
#endif
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  CVF_FAT_EXTENS          );
#endif // DBLSPACE_ENABLED
DECLARE_CLASS(  REAL_FAT_SA             );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  FATDB_SA                );
#endif // DBLSPACE_ENABLED


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if( DEFINE_CLASS_DESCRIPTOR( CLUSTER_CHAIN          ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( CVF_FAT_EXTENS         ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( EA_HEADER              ) &&
            DEFINE_CLASS_DESCRIPTOR( EA_SET                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT                    ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDB_SA               ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDIR                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_DIRENT             ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_SA                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_VOL                ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDB_VOL              ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FILEDIR                ) &&
            DEFINE_CLASS_DESCRIPTOR( HASH_INDEX             ) &&
#ifndef _EFICHECK_
            DEFINE_CLASS_DESCRIPTOR( RELOCATION_CLUSTER     ) &&
#endif
            DEFINE_CLASS_DESCRIPTOR( REAL_FAT_SA            ) &&
            DEFINE_CLASS_DESCRIPTOR( ROOTDIR                )
        ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR( CLUSTER_CHAIN          );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( CVF_FAT_EXTENS         );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( EA_HEADER              );
    UNDEFINE_CLASS_DESCRIPTOR( EA_SET                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT                    );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDB_SA               );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDIR                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_DIRENT             );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_SA                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_VOL                );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDB_VOL              );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FILEDIR                );
    UNDEFINE_CLASS_DESCRIPTOR( HASH_INDEX             );
#ifndef _EFICHECK_
    UNDEFINE_CLASS_DESCRIPTOR( RELOCATION_CLUSTER     );
#endif
    UNDEFINE_CLASS_DESCRIPTOR( REAL_FAT_SA            );
    UNDEFINE_CLASS_DESCRIPTOR( ROOTDIR                );
    return TRUE;
}


BOOLEAN
PatchFatAndFat32BootCodeMessages(
    VOID
    )
{
#if defined( _EFICHECK_ )

    // we don't need to patch boot messages for an EFI partition, since
    // we don't use the boot sector on an EFI partition
    return(TRUE);

#else // defined( _EFICHECK_ )

    CHAR NtldrMissing[100];
    CHAR DiskError[100];
    CHAR PressKey[100];

    extern UCHAR FatBootCode[512];
    extern UCHAR Fat32BootCode[512*3];

    //
    // Get message text.
    //
#if defined( _AUTOCHECK_ )
    //
    // ntlib.lib, messages are in the binary being run.
    //
    {
        BOOLEAN b;

        b = SimpleFetchMessageTextInOemCharSet(
                MSG_BOOT_FAT_NTLDR_MISSING,
                NtldrMissing,
                sizeof(NtldrMissing)
                );

        if(b) {
            b = SimpleFetchMessageTextInOemCharSet(
                    MSG_BOOT_FAT_IO_ERROR,
                    DiskError,
                    sizeof(DiskError)
                    );

            if(b) {
                b = SimpleFetchMessageTextInOemCharSet(
                        MSG_BOOT_FAT_PRESS_KEY,
                        PressKey,
                        sizeof(PressKey)
                        );
            }
        }

        if(!b) {
            return(FALSE);
        }

    }
#else
    //
    // Win32 case, messages are in ulib.dll.
    //
    {
        HINSTANCE h;
        DWORD d;

        h = LoadLibraryEx(TEXT("ULIB"),NULL,LOAD_LIBRARY_AS_DATAFILE);
        if(!h) {
            return(FALSE);
        }

        d = FormatMessageA(
                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                h,
                MSG_BOOT_FAT_NTLDR_MISSING,
                0,
                NtldrMissing,
                sizeof(NtldrMissing),
                NULL
                );

        if(d) {

            d = FormatMessageA(
                    FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    h,
                    MSG_BOOT_FAT_IO_ERROR,
                    0,
                    DiskError,
                    sizeof(DiskError),
                    NULL
                    );

            if(d) {
                d = FormatMessageA(
                        FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                        h,
                        MSG_BOOT_FAT_PRESS_KEY,
                        0,
                        PressKey,
                        sizeof(PressKey),
                        NULL
                        );
            }
        }

        FreeLibrary(h);
        if(!d) {
            return(FALSE);
        }

        CharToOemA(NtldrMissing,NtldrMissing);
        CharToOemA(DiskError,DiskError);
        CharToOemA(PressKey,PressKey);
    }
#endif

    //
    // Call code in patchbc.lib to do the patching now that we've got
    // the translated message text.
    //
    if(!PatchMessagesIntoFatBootCode(FatBootCode,FALSE,NtldrMissing,DiskError,PressKey)
    || !PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,NtldrMissing,DiskError,PressKey)) {

        return(FALSE);
    }
    return(TRUE);

#endif // defined( _EFICHECK_ )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\supera.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    supera.cxx

--*/

#include <pch.cxx>

#if i386
//
// Temporarily disable optimizations until cl386 Drop 077 is fixed.
//
#pragma optimize("",off)
#endif

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "supera.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ifssys.hxx"

#define MaxLabelLength      1024

DEFINE_EXPORTED_CONSTRUCTOR( SUPERAREA, SECRUN, IFSUTIL_EXPORT );

IFSUTIL_EXPORT
SUPERAREA::~SUPERAREA(
    )
/*++

Routine Description:

    Destructor for SUPERAREA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
SUPERAREA::Construct(
        )
/*++

Routine Description:

        Constructor for SUPERAREA.

Arguments:

        None.

Return Value:

        None.

--*/
{
    _drive = NULL;
}


VOID
SUPERAREA::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state freeing up
    any memory in the process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


IFSUTIL_EXPORT
BOOLEAN
SUPERAREA::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      SECTORCOUNT         NumberOfSectors,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine initializes the SUPERAREA for the given drive.

Arguments:

    Mem             - Supplies necessary memory for the underlying sector run.
    Drive           - Supplies the drive where the superarea resides.
    NumberOfSectors - Supplies the number of sectors in the superarea.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(Drive);
    DebugAssert(NumberOfSectors);

    if (!SECRUN::Initialize(Mem, Drive, 0, NumberOfSectors)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    _drive = Drive;

    return TRUE;
}


IFSUTIL_EXPORT
VOLID
SUPERAREA::ComputeVolId(
    IN  VOLID   Seed
    )
/*++

Routine Description:

    This routine computes a new and unique volume identifier.

Arguments:

    None.

Return Value:

    A unique volume id.

--*/
{
    VOLID           volid;
    PUCHAR          p;
    INT             i;
    LARGE_INTEGER   NtfsTime;

    if (Seed) {
        volid = Seed;
    } else {
        volid = 0;
    }

    do {

        if (!volid) {
            IFS_SYSTEM::QueryNtfsTime( &NtfsTime );
            if (NtfsTime.LowPart) {
                volid = (VOLID) NtfsTime.LowPart;
            } else {
                volid = (VOLID) NtfsTime.HighPart;
            }

            if (volid == 0) { // This should never happen.
                volid = 0x11111111;
            }
        }

        p = (PUCHAR) &volid;
        for (i = 0; i < sizeof(VOLID); i++) {
            volid += *p++;
            volid = (volid >> 2) + (volid << 30);
        }

    } while (!volid);

    return volid;
}

NTSTATUS
SUPERAREA::FormatNotification(
    PWSTRING        Label
    )
/*++

Routine Description:

    This routine computes a new and unique volume identifier.

Arguments:

    None.

Return Value:

    A unique volume id.

--*/
{
#if !defined( _EFICHECK_ ) // volume ids are handled  differently under EFI

    CONST                       vollen = sizeof(FILE_FS_VOLUME_INFORMATION) +
                                         MaxLabelLength;
    CONST                       lablen = sizeof(FILE_FS_LABEL_INFORMATION) +
                                         MaxLabelLength;
    PFILE_FS_VOLUME_INFORMATION volinfo;
    PFILE_FS_LABEL_INFORMATION  labinfo;
    STR                         vol_info_buf[vollen];
    STR                         lab_info_buf[lablen];

    IO_STATUS_BLOCK             status_block;
    NTSTATUS                    status;

    PCWSTRING                   ntDriveName;
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      handle;

    //
    // Close the current drive handle first
    //
    _drive->CloseDriveHandle();

    ntDriveName = _drive->GetNtDriveName();

    string.Length = (USHORT) ntDriveName->QueryChCount() * sizeof(WCHAR);
    string.MaximumLength = string.Length;
    string.Buffer = (PWSTR)ntDriveName->GetWSTR();

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("IFSUTIL: Unable to open handle with status %x\n", status));
        return status;
    }

    if (Label == NULL) {
        volinfo = (PFILE_FS_VOLUME_INFORMATION) vol_info_buf;

        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              volinfo,
                                              vollen,
                                              FileFsVolumeInformation);
    }

    if (NT_SUCCESS(status)) {

        labinfo = (PFILE_FS_LABEL_INFORMATION)lab_info_buf;

        if (Label == NULL) {
            labinfo->VolumeLabelLength = volinfo->VolumeLabelLength;
            memcpy(labinfo->VolumeLabel, volinfo->VolumeLabel, labinfo->VolumeLabelLength);
        } else {
            labinfo->VolumeLabelLength = Label->QueryChCount()*sizeof(WCHAR);
            memcpy(labinfo->VolumeLabel, Label->GetWSTR(), labinfo->VolumeLabelLength);
        }

        status = NtSetVolumeInformationFile(handle,
                                            &status_block,
                                            labinfo,
                                            lablen,
                                            FileFsLabelInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to set volume label with status %x\n", status));
        }

    } else
        DebugPrintTrace(("IFSUTIL: Unable to query volume label with status %x\n", status));

    NtClose(handle);
    return status;

#else // _EFICHECK_

    return STATUS_SUCCESS;

#endif // _EFICHECK_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\sortlit.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    sortlit.cxx

Abstract:

    This file contains the definitions for the SORTED_LIST_ITERATOR class.
    SORTED_LIST_ITERATOR is a concrete implementation of the abstract ITERATOR
    class.

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"


DEFINE_CAST_MEMBER_FUNCTION( SORTED_LIST_ITERATOR );

DEFINE_CONSTRUCTOR( SORTED_LIST_ITERATOR, ITERATOR );


VOID
SORTED_LIST_ITERATOR::Construct (
    )

/*++

Routine Description:

    Construct a SORTED_LIST_ITERATOR

Arguments:

    None.

Return Value:

    None.

--*/

{
    _List = NULL;
}



SORTED_LIST_ITERATOR::~SORTED_LIST_ITERATOR (
    )
/*++

Routine Description:

    Destructor for the SORTED_LIST_ITERATOR class

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG==1
    if ( _List ) {
        _List->_IteratorCount--;
    }
#endif
}


POBJECT
SORTED_LIST_ITERATOR::FindNext(
    IN  PCOBJECT    Key
    )
/*++

Routine Description:

    Finds the next object in the list that matches the given key

Arguments:

    Key -   Supplies the key

Return Value:

    POBJECT -   Pointer to next member of the list that matches the key

--*/

{

    ULONG   Index;

    //
    //  Wrap if necessary
    //
    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = 0;
    }

    //
    //  If we are not at the end of the list, look for the next object
    //  that matches the key.
    //
    if ( _CurrentIndex < _List->QueryMemberCount()-1 ) {

        Index = _List->Search( Key, _CurrentIndex+1, _List->QueryMemberCount()-1 );

        //
        //  If an object was found, set our currency and return the object
        //
        if ( Index < _List->QueryMemberCount() &&
             !Key->Compare(_List->_Array.GetAt( Index )))  {

            _CurrentIndex = Index;
            return _List->_Array.GetAt( Index );
        }
    }

    //
    //  No match, return NULL
    //
    _CurrentIndex = INVALID_INDEX;
    return NULL;
}


POBJECT
SORTED_LIST_ITERATOR::GetCurrent(
    )
/*++

Routine Description:

    Gets current member

Arguments:

    None

Return Value:

    POBJECT -   Pointer to current member in  the array

--*/

{
    if ( _CurrentIndex == INVALID_INDEX ) {
        return NULL;
    } else {
        return _List->_Array.GetAt( _CurrentIndex );
    }
}




POBJECT
SORTED_LIST_ITERATOR::GetNext(
    )
/*++

Routine Description:

    Gets next member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to next member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that INVALID_INDEX + 1 == 0
    //
    _CurrentIndex++;

    if ( _CurrentIndex >= _List->_Array.QueryMemberCount() ) {
        _CurrentIndex = INVALID_INDEX;
    }

    //
    //  Get next
    //
    return _List->_Array.GetAt( _CurrentIndex );
}


POBJECT
SORTED_LIST_ITERATOR::GetPrevious(
    )
/*++

Routine Description:

    Gets previous member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to previous member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that 0 - 1 == INVALID_INDEX
    //
    _CurrentIndex--;

    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = _List->_Array.QueryMemberCount() - 1;
    }

    //
    //  Get next
    //
    return _List->_Array.GetAt( _CurrentIndex );
}



VOID
SORTED_LIST_ITERATOR::Reset(
    )

/*++

Routine Description:

    Resets the iterator

Arguments:

    None

Return Value:

    None

--*/

{
    _CurrentIndex = INVALID_INDEX;
}




BOOLEAN
SORTED_LIST_ITERATOR::Initialize (
    IN PSORTED_LIST List
    )

/*++

Routine Description:

    Associate a SORTED_LIST with this SORTED_LIST_ITERATOR and
    reset the current index

Arguments:

    List   -   Supplies pointer to the sorted list object

Return Value:

    BOOLEAN - Returns TRUE if the initialization was succesful.

--*/

{
    DebugPtrAssert( List );

#if DBG==1
    if ( _List ) {
        _List->_IteratorCount--;
    }
    List->_IteratorCount++;
#endif
    _List           = List;
    _CurrentIndex   = INVALID_INDEX;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\efintldr.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    efintldr.h

Abstract:

    

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#ifndef __EFINTLDR_H__
#define __EFINTLDR_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define BOOT_SPART "SYSTEMPARTITION="
#define BOOT_OSLDR "OSLOADER="
#define BOOT_LPART "OSLOADPARTITION="
#define BOOT_FILEN "OSLOADFILENAME="
#define BOOT_IDENT "LOADIDENTIFIER="
#define BOOT_LDOPT "OSLOADOPTIONS="
#define BOOT_CNTDW "COUNTDOWN="
#define BOOT_LASTK "LASTKNOWNGOOD="
#define BOOT_TOKEN ";\n\r"
#define BOOT_COUNT 30
#define BOOT_MAX   10

#define BOOT_NVR   L"\\boot.nvr"
#define BACKUP_NVR L"\\boot.nvr.efintldr"
#define REGISTER1  L"*register"
#define REGISTER2  L"*register*"
#define STARTFILE  L"startup.nsh"
#define THISFILE   L"efintldr\r\n"
#define EFIEXT     ".efi"
#define LOADFILE   "\\ia64ldr.efi"
#define LAST_FALSE "LASTKNOWNGOOD=False\r\n"
#define LAST_TRUE  "LASTKNOWNGOOD=True\r\n;"
#define SPACEC     ' '
#define SPACES     " "

typedef struct _BOOT_DATA
{
    char* pszSPart[BOOT_MAX];
    char* pszOSLdr[BOOT_MAX];
    char* pszLPart[BOOT_MAX];
    char* pszFileN[BOOT_MAX];
    char* pszIdent[BOOT_MAX + 1];
    char* pszShort[BOOT_MAX + 1];
    char* pszLoadOpt;
    UINTN dwLastKnown;
    UINTN dwCount;
    UINTN dwIndex;

} BOOT_DATA;

#endif //__EFINTLDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\efintldr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    efintldr.c

Abstract:

    

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#include "precomp.h"

//
// Open the IA64LDR.EFI image and load the OS
//
BOOLEAN
LaunchOS(
    IN char*             String,
    IN EFI_HANDLE        ImageHandle,
    IN EFI_FILE_HANDLE*  CurDir,
    IN EFI_LOADED_IMAGE* LoadedImage
    )
{
    CHAR16*          uniBuf     = NULL;
    BOOLEAN          bError     = TRUE;
    EFI_STATUS       Status;
    EFI_HANDLE       exeHdl     = NULL;
    EFI_INPUT_KEY    Key;
    EFI_FILE_HANDLE  FileHandle = NULL;
    EFI_DEVICE_PATH* ldrDevPath = NULL;

    do
    {
        //
        // Convert OS path to unicode from ACSII
        //
        uniBuf = RutlUniStrDup(String);
        if (!uniBuf)
        {
            break;
        }
        //
        // Open the ia64ldr.efi
        //
        Status = (*CurDir)->Open(
                            *CurDir,
                            &FileHandle,
                            uniBuf,
                            EFI_FILE_MODE_READ,
                            0);
        if (EFI_ERROR(Status))
        {
            break;
        }

        ldrDevPath = FileDevicePath(LoadedImage->DeviceHandle, uniBuf);
        if (!ldrDevPath)
        {
            break;
        }

        Status = BS->LoadImage(
                    FALSE,
                    ImageHandle,
                    ldrDevPath,
                    NULL,
                    0,
                    &exeHdl);
        if (EFI_ERROR(Status))
        {
            break;
        }

        Print (L"\nAttempting to launch... %s\n", uniBuf);
        WaitForSingleEvent(ST->ConIn->WaitForKey, 5000000);
        ST->ConIn->ReadKeyStroke(ST->ConIn, &Key);
        //
        // Clean up
        //
        ldrDevPath = RutlFree(ldrDevPath);
        uniBuf = RutlFree(uniBuf);
        String = RutlFree(String);
        //
        // Disable the cursor
        //
        ST->ConOut->EnableCursor(ST->ConOut, FALSE);
        bError = FALSE;
        //
        // Start the OS baby!!
        //
        BS->StartImage(exeHdl, 0, NULL);
        //
        // If we get here the OS failed to load
        //
        bError = TRUE;
        //
        // Re-enable the cursor
        //
        ST->ConOut->EnableCursor(ST->ConOut, TRUE);

    } while (FALSE);
    //
    // Clean up
    //
    if (ldrDevPath)
    {
        ldrDevPath = RutlFree(ldrDevPath);
    }
    if (uniBuf)
    {
        uniBuf = RutlFree(uniBuf);
    }
    if (FileHandle)
    {
        FileHandle->Close(FileHandle);
    }
    if (String)
    {
        String = RutlFree(String);
    }
//
// Where the heck is the lib for this?
//
//    if (exeHdl)
//        UnloadImage(&exeHdl);

    return bError;
}

//
// Struct Cleanup
//
BOOLEAN
FreeBootData(
    IN VOID* hBootData
    )
{
    UINTN      i;
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    if (!pBootData)
    {
        return TRUE;
    }

    for (i = 0; i < pBootData->dwIndex; i++)
    {
        pBootData->pszSPart[i] = RutlFree(pBootData->pszSPart[i]);
        pBootData->pszOSLdr[i] = RutlFree(pBootData->pszOSLdr[i]);
        pBootData->pszLPart[i] = RutlFree(pBootData->pszLPart[i]);
        pBootData->pszFileN[i] = RutlFree(pBootData->pszFileN[i]);
        pBootData->pszIdent[i] = RutlFree(pBootData->pszIdent[i]);
        pBootData->pszShort[i] = RutlFree(pBootData->pszShort[i]);
    }

    pBootData->pszShort[pBootData->dwIndex] =
        RutlFree(pBootData->pszShort[pBootData->dwIndex]);

    pBootData->pszIdent[pBootData->dwIndex] =
        RutlFree(pBootData->pszIdent[pBootData->dwIndex]);

    if (pBootData->pszLoadOpt)
    {
        pBootData->pszLoadOpt = RutlFree(pBootData->pszLoadOpt);
    }

    pBootData->dwLastKnown = 0;
    pBootData->dwIndex = 0;
    pBootData->dwCount = 0;

    return FALSE;
}

//
// Sort the load options based placing the passed option first
//
BOOLEAN
SortLoadOptions(
    IN VOID*            hBootData,
    IN char*            Buffer,
    IN UINTN*           dwSize,
    IN UINTN*           dwOption,
    IN UINTN*           dwMax,
    IN EFI_FILE_HANDLE* FileHandle
    )
{
    char       *FndTok[BOOT_MAX],
               *Start    = NULL,
               *End      = NULL,
               *NewOpt   = NULL,
               *Sortme   = NULL,
               *Token    = NULL,
               *Last     = NULL,
               *Find     = NULL;
    UINTN      i         = 0,
               j         = 0,
               dwIndex   = 0,
               dwStLen   = 0,
               dwOrigLen = 0,
               dwLen     = 0;
    BOOLEAN    bError    = FALSE;
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    do
    {
        //
        // Find the BOOT_LDOPT option
        //
        Start = strstr(Buffer, BOOT_LDOPT);
        if (!Start)
        {
            bError = TRUE;
            break;
        }
        //
        // Find the end of the option
        //
        End = (Start += strlena(BOOT_LDOPT));
        while (*(End++) != '\r')
            ;
        dwOrigLen = (End - Start) - 1;
        //
        // Create buffer to use for temp sort storage
        //
        NewOpt = AllocateZeroPool(dwOrigLen + 1);
        if (!NewOpt)
        {
            bError = TRUE;
            break;
        }
        //
        // Copy only that option to a new buffer
        //
        CopyMem(NewOpt, Start, dwOrigLen);
        //
        // Replace any leading ';' with a nodebug
        //
        while ((NewOpt[i] == ';') && (i < *dwMax))
        {
            FndTok[i] = RutlStrDup(BL_DEBUG_NONE);
            if (!FndTok[i])
            {
                bError = TRUE;
                break;
            }

            dwIndex += strlena(FndTok[i++]);
        }
        //
        // Remove tokens
        //
        Token = strtok(NewOpt, BOOT_TOKEN);

        while ((Token != NULL) &&
               (Token < (NewOpt + dwOrigLen)) &&
               (i < *dwMax)
              )
        {
            if (Find = FindAdvLoadOptions(Token))
            {
                //
                // User has booted using adv options, clearing them out
                //
                // Add a NULL at the location of the adv opt
                //
                *Find = '\0';

                FndTok[i] = RutlStrDup(Token);
            }
            else
            {
                FndTok[i] = RutlStrDup(Token);
                if (!FndTok[i])
                {
                    bError = TRUE;
                    break;
                }
            }

            dwIndex += strlena(FndTok[i++]);
            Token = strtok(NULL, BOOT_TOKEN);
        }

        while (i < *dwMax)
        {
            FndTok[i] = RutlStrDup(BL_DEBUG_NONE);
            if (!FndTok[i])
            {
                bError = TRUE;
                break;
            }

            dwIndex += strlena(FndTok[i++]);
        }
        //
        // Create buffer to store sorted data
        //
        Sortme = AllocateZeroPool(dwLen = dwIndex + *dwMax + 1);
        if (!Sortme)
        {
            bError = TRUE;
            break;
        }

        //
        // Copy selected option as the first option
        //
        if (pBootData->pszLoadOpt)
        {
            //
            // if user has selected an adv boot option, it is plum'd here
            //
            dwStLen = strlena(pBootData->pszLoadOpt) + dwLen + strlena(SPACES);

            Sortme = ReallocatePool(Sortme, dwLen, dwStLen);
            if (!Sortme)
            {
                bError = TRUE;
                break;
            }
            //
            // they will need to match up later
            //
            dwLen = dwStLen;

            dwIndex = strlena(FndTok[*dwOption]);
            CopyMem(Sortme, FndTok[*dwOption], dwIndex);
            dwStLen = dwIndex;

            dwIndex = strlena(SPACES);
            CopyMem(Sortme + dwStLen, SPACES, dwIndex);
            dwStLen += dwIndex;

            dwIndex = strlena(pBootData->pszLoadOpt);
            CopyMem(Sortme + dwStLen, pBootData->pszLoadOpt, dwIndex);
            dwStLen += dwIndex;
        }
        else
        {
            CopyMem(Sortme, FndTok[*dwOption], strlena(FndTok[*dwOption]));
            dwStLen = strlena(FndTok[*dwOption]);
        }
        //
        // Append a seperator
        //
        *(Sortme + (dwStLen++)) = ';';
        //
        // Smash the rest of the options back in
        //
        for (j = 0; j < i; j++)
        {
            //
            // Skip the option that was moved to the front
            //
            if (j == *dwOption)
            {
                continue;
            }

            CopyMem(Sortme + dwStLen, FndTok[j], strlena(FndTok[j]));
            dwStLen += strlena(FndTok[j]);
            //
            // Append a seperator
            //
            *(Sortme + (dwStLen++)) = ';';
        }

        dwStLen--;
        *(Sortme + dwStLen++) = '\r';
        *(Sortme + dwStLen++) = '\n';

        if (dwLen != dwStLen)
        {
            bError = TRUE;
            break;
        }
        //
        // Write new sorted load options to file
        //
        (*FileHandle)->SetPosition(*FileHandle, (Start - Buffer));
        (*FileHandle)->Write(*FileHandle, &dwStLen, Sortme);
        //
        // Write options that following load options back to file
        //
        (*FileHandle)->SetPosition(*FileHandle, (Start - Buffer) + dwStLen - 1);
        dwStLen = *dwSize - (End - Buffer);
        (*FileHandle)->Write(*FileHandle, &dwStLen, End);
        //
        // Set last known good
        //
        if (Last = strstr(End, BOOT_LASTK))
        {
            (*FileHandle)->SetPosition(
                                *FileHandle,
                                (Start - Buffer) + dwLen + (Last - End) - 1);

            if (pBootData->dwLastKnown)
            {
                dwIndex = strlena(LAST_TRUE);
                (*FileHandle)->Write(*FileHandle, &dwIndex, LAST_TRUE);
            }
            else
            {
                dwIndex = strlena(LAST_FALSE);
                (*FileHandle)->Write(*FileHandle, &dwIndex, LAST_FALSE);
            }
        }
        //
        // Subtract the terminators
        //
        dwLen -= 2;

        if (dwOrigLen <= dwLen)
        {
            break;
        }
        //
        // append semi-colon's at the end of the file if we have left over room
        //
        // don't reuse 'i', need it below to free
        //
        for (j = 0; j < (dwOrigLen - dwLen); j++)
        {
            dwStLen = 1;
            (*FileHandle)->Write(*FileHandle, &dwStLen, ";");
        }

    } while (FALSE);

    if (Sortme)
    {
        Sortme = RutlFree(Sortme);
    }

    for (j = 0; j < i; j++)
    {
        FndTok[j] = RutlFree(FndTok[j]);
    }

    if (NewOpt)
    {
        NewOpt = RutlFree(NewOpt);
    }

    return bError;
}

//
// Sort the boot options based placing the passed option first
//
BOOLEAN
SortBootData(
    IN char*  Option,
    IN char*  StrArr[],
    IN UINTN* dwOption,
    IN UINTN* dwMax,
    IN char*  Buffer
    )
{
    char    *Start  = NULL,
            *End    = NULL,
            *NewOpt = NULL;
    UINTN   i,
            dwIndex = 0,
            dwLen   = 0;
    BOOLEAN bError = TRUE;

    do
    {
        //
        // Find the option header
        //
        Start = strstr(Buffer, Option);
        if (!Start)
        {
            break;
        }
        //
        // Find the end of the option
        //
        End = (Start += strlena(Option));
        while (*(End++) != '\n')
            ;
        dwLen = End - Start;
        //
        // Create buffer to use for temp sort storage
        //
        NewOpt = AllocateZeroPool(dwLen);
        if (!NewOpt)
        {
            break;
        }
        //
        // Copy only that option to a new buffer
        //
        CopyMem(NewOpt, StrArr[*dwOption], strlena(StrArr[*dwOption]));
        dwIndex += strlena(StrArr[*dwOption]);
        //
        // Append a seperator
        //
        *(NewOpt+(dwIndex++)) = ';';

        for (i = 0; i < *dwMax; i++)
        {
            if (i == *dwOption)
            {
                continue;
            }

            CopyMem(NewOpt + dwIndex, StrArr[i], strlena(StrArr[i]));
            dwIndex += strlena(StrArr[i]);
            *(NewOpt+(dwIndex++)) = ';';
        }

        while (dwIndex++ < (dwLen - 1))
        {
            *(NewOpt + (dwIndex - 1)) = ';';
        }

        *(NewOpt + (dwLen - 2)) = '\r';
        *(NewOpt + dwLen - 1) = '\n';

        if (dwIndex != dwLen)
        {
            break;
        }
        //
        // Copy new sorted data in the buffer
        //
        CopyMem(Start, NewOpt, dwIndex);

        bError = FALSE;

    } while (FALSE);

    if (NewOpt)
    {
        NewOpt = RutlFree(NewOpt);
    }

    return bError;
}

//
// Parse options from file data
//
BOOLEAN
OrderBootFile(
    IN UINTN dwOption,
    IN char* Buffer,
    IN VOID* hBootData
    )
{
    BOOLEAN    bError    = TRUE;
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    do
    {
        //
        // Find/sort the BOOT_SPART option
        //
        if (SortBootData(
                    BOOT_SPART,
                    pBootData->pszSPart,
                    &dwOption,
                    &(pBootData->dwIndex),
                    Buffer))
        {
            Print(L"OrderBootFile() failed for BOOT_SPART option!\n");
            break;
        }
        //
        // Find/sort the BOOT_OSLDR option
        //
        if (SortBootData(
                    BOOT_OSLDR,
                    pBootData->pszOSLdr,
                    &dwOption,
                    &(pBootData->dwIndex),
                    Buffer))
        {
            Print(L"OrderBootFile() failed for BOOT_OSLDR option!\n");
            break;
        }
        //
        // Find/sort the BOOT_LPART option
        //
        if (SortBootData(
                    BOOT_LPART,
                    pBootData->pszLPart,
                    &dwOption,
                    &(pBootData->dwIndex),
                    Buffer))
        {
            Print(L"OrderBootFile() failed for BOOT_LPART option!\n");
            break;
        }
        //
        // Find/sort the BOOT_FILEN option
        //
        if (SortBootData(
                    BOOT_FILEN,
                    pBootData->pszFileN,
                    &dwOption,
                    &(pBootData->dwIndex),
                    Buffer))
        {
            Print(L"OrderBootFile() failed for BOOT_FILEN option!\n");
            break;
        }
        //
        // Find/sort the BOOT_IDENT option
        //
        if (SortBootData(
                    BOOT_IDENT,
                    pBootData->pszIdent,
                    &dwOption,
                    &(pBootData->dwIndex),
                    Buffer))
        {
            Print(L"OrderBootFile() failed for BOOT_IDENT option!\n");
            break;
        }

        bError = FALSE;

    } while (FALSE);

    return bError;
}

//
// Chop-up name to be short to 'pretty up' the menu
//
BOOLEAN
CreateShortNames(
    IN VOID* hBootData
    )
{
    char       *start    = NULL,
               *end      = NULL;
    UINTN      i,
               Len       = 0;
    BOOLEAN    bError    = FALSE;
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    do
    {
        for (i = 0; i < pBootData->dwIndex; i++)
        {
            start = strstr(pBootData->pszOSLdr[i], wacks);
            end = strstr(pBootData->pszOSLdr[i], EFIEXT);
            //
            // check for foo case (thx jhavens)
            //
            if ((end == NULL) ||
                (start == NULL)
               )
            {
                start = pBootData->pszOSLdr[i];
                end = start;
                while (*(end++) != '\0')
                    ;
                Len = end - start;
            }
            //
            // Non-foo case, person has atleast one '\' && '.efi'
            //
            if (!Len)
            {
                start += 1;

                while (*end != wackc)
                {
                    if (end <= start)
                    {
                        start = pBootData->pszOSLdr[i];
                        end = strstr(pBootData->pszOSLdr[i], wacks);
                        break;
                    }

                        end--;
                }

                Len = end - start;
            }

            if ((end == NULL)   ||
                (start == NULL) ||
                (Len < 1)
               )
            {
                bError = TRUE;
                break;
            }

            pBootData->pszShort[i] = AllocateZeroPool(Len + 1);
            if (!pBootData->pszShort[i])
            {
                bError = TRUE;
                break;
            }

            CopyMem(pBootData->pszShort[i], start, end - start);

            Len = 0;
            start = NULL;
            end = NULL;
        }

    } while (FALSE);

    return bError;
}

//
// Find the passed option from the file data
//
BOOLEAN
FindOpt(
    IN  char*  pszOption,
    IN  char*  Buffer,
    OUT char*  pszArray[],
    OUT UINTN* dwCount
    )
{
    char    *Start  = NULL,
            *End    = NULL,
            *Option = NULL,
            *Token  = NULL;
    UINTN   dwIndex = 0;
    BOOLEAN bError  = TRUE;

    do
    {
        //
        // Find the option
        //
        Start = strstr(Buffer, pszOption);
        if (!Start)
        {
            break;
        }
        //
        // Find the end of the option
        //
        Start += strlena(pszOption);
        End = Start;
        while (*(End++) != '\r')
            ;

        Option = AllocateZeroPool((End-Start));
        if (!Option)
        {
            break;
        }
        //
        // Copy only that option to a new buffer
        //
        CopyMem(Option, Start, (End-Start)-1);
        *(Option+((End-Start)-1)) = 0x00;
        //
        // Remove tokens
        //
        Token = strtok(Option, BOOT_TOKEN);
        if (!Token)
        {
            break;
        }

        if (!(*dwCount))
        {
            while ((Token != NULL) &&
                   (dwIndex < BOOT_MAX)
                  )
            {
                pszArray[(dwIndex)++] = RutlStrDup(Token);
                Token = strtok(NULL, BOOT_TOKEN);
            }

            *dwCount = dwIndex;
        }
        else
        {
            while ((Token != NULL) &&
                   (dwIndex < *dwCount)
                  )
            {
                pszArray[(dwIndex)++] = RutlStrDup(Token);
                Token = strtok(NULL, BOOT_TOKEN);
            }
        }

        if (dwIndex == 0)
        {
            break;
        }

        bError = FALSE;

    } while (FALSE);

    if (Option)
    {
        Option = RutlFree(Option);
    }

    return bError;
}

//
// Get the options in their entirety from the file data
//
BOOLEAN
GetBootData(
    IN VOID* hBootData,
    IN char* Buffer
    )
{
    UINTN      i;
    char*      TempStr   = NULL;
    CHAR16*    UniStr    = NULL;
    BOOLEAN    bError    = TRUE;
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    do
    {
        //
        // Find the BOOT_IDENT option
        //
        if (FindOpt(
                BOOT_IDENT,
                Buffer,
                pBootData->pszIdent,
                &pBootData->dwIndex))
        {
            break;
        }

        pBootData->pszIdent[pBootData->dwIndex] = RutlStrDup(BL_EXIT_EFI1);
        if (!pBootData->pszIdent[pBootData->dwIndex])
        {
            break;
        }
        //
        // Find the BOOT_SPART option
        //
        if (FindOpt(
                BOOT_SPART,
                Buffer,
                pBootData->pszSPart,
                &pBootData->dwIndex))
        {
            break;
        }
        //
        // Find the BOOT_OSLDR option
        //
        if (FindOpt(
                BOOT_OSLDR,
                Buffer,
                pBootData->pszOSLdr,
                &pBootData->dwIndex))
        {
            break;
        }

        if (CreateShortNames(pBootData))
        {
            break;
        }
        //
        // Append 'exit' to the end of the menu
        //
        pBootData->pszShort[pBootData->dwIndex] = RutlStrDup(BL_EXIT_EFI2);
        if (!pBootData->pszShort[pBootData->dwIndex])
        {
            break;
        }
        //
        // Find the BOOT_LPART option
        //
        if (FindOpt(
                BOOT_LPART,
                Buffer,
                pBootData->pszLPart,
                &pBootData->dwIndex))
        {
            break;
        }
        //
        // Find the BOOT_FILEN option
        //
        if (FindOpt(
                BOOT_FILEN,
                Buffer,
                pBootData->pszFileN,
                &pBootData->dwIndex))
        {
            break;
        }
        //
        // Find the BOOT_CNTDW option
        //
        if (TempStr = strstr(Buffer, BOOT_CNTDW))
        {
            UniStr = RutlUniStrDup(TempStr + strlena(BOOT_CNTDW));

            if ((UniStr != NULL)   &&
                (Atoi(UniStr) > 0) &&
                (Atoi(UniStr) < BOOT_COUNT)
               )
            {
                pBootData->dwCount = Atoi(UniStr);
                bError = FALSE;
                break;
            }
        }
        //
        // Set the count to the default if setting it failed
        //
        if (!pBootData->dwCount)
        {
            pBootData->dwCount = BOOT_COUNT;
        }

        bError = FALSE;

    } while (FALSE);

    if (UniStr)
    {
        UniStr = RutlFree(UniStr);
    }

    return bError;
}

//
// fill out startup.nsh with the name of this program
//
void
PopulateStartFile(
    IN EFI_FILE_HANDLE* StartFile
    )
{
    UINTN  size;
    CHAR16 UnicodeMarker = UNICODE_BYTE_ORDER_MARK;

    size = sizeof(UnicodeMarker);
    (*StartFile)->Write(*StartFile, &size, &UnicodeMarker);

    size = (StrLen(THISFILE)) * sizeof(CHAR16);
    (*StartFile)->Write(*StartFile, &size, THISFILE);

    return;
}

//
// Parse cmdline params
//
void
ParseArgs(
    IN EFI_FILE_HANDLE*  CurDir,
    IN EFI_LOADED_IMAGE* LoadedImage
    )
{
    EFI_STATUS      Status;
    EFI_FILE_HANDLE StartFile = NULL;

    do
    {
        if (MetaiMatch(LoadedImage->LoadOptions, REGISTER1) ||
            MetaiMatch(LoadedImage->LoadOptions, REGISTER2)
           )
        {
            Status = (*CurDir)->Open(
                                *CurDir,
                                &StartFile,
                                STARTFILE,
                                EFI_FILE_MODE_READ |
                                    EFI_FILE_MODE_WRITE |
                                    EFI_FILE_MODE_CREATE,
                                0);
            if (EFI_ERROR(Status))
            {
                break;
            }

            Status = StartFile->Delete(StartFile);
            if (EFI_ERROR(Status))
            {
                break;
            }

            StartFile = NULL;

            Status = (*CurDir)->Open(
                                *CurDir,
                                &StartFile,
                                STARTFILE,
                                EFI_FILE_MODE_READ |
                                    EFI_FILE_MODE_WRITE |
                                    EFI_FILE_MODE_CREATE,
                                0);
            if (!EFI_ERROR(Status))
            {
                PopulateStartFile(&StartFile);
            }
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (StartFile)
    {
        StartFile->Close(StartFile);
    }

    return;
}

//
// Read in BOOT.NVR and return buffer of contents
//
void*
ReadBootFile(
    IN UINTN*           Size,
    IN EFI_FILE_HANDLE* FileHandle
    )
{
    char*          Buffer   = NULL;
    EFI_STATUS     Status;
    EFI_FILE_INFO* BootInfo = NULL;

    do
    {
        *Size = (SIZE_OF_EFI_FILE_INFO + 255) * sizeof(CHAR16);

        BootInfo = AllocateZeroPool(*Size);
        if (!BootInfo)
        {
            break;
        }

        Status = (*FileHandle)->GetInfo(
                    *FileHandle,
                    &GenericFileInfo,
                    Size,
                    BootInfo);
        if (EFI_ERROR(Status))
        {
            break;
        }
        //
        // Find out how much we will need to alloc
        //
        *Size = (UINTN) BootInfo->FileSize;

        Buffer = AllocateZeroPool((*Size) + 1);
        if (!Buffer)
        {
            break;
        }

        Status = (*FileHandle)->Read(*FileHandle, Size, Buffer);
        if (EFI_ERROR(Status))
        {
            Buffer = RutlFree(Buffer);
            break;
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (BootInfo)
    {
        BootInfo = RutlFree(BootInfo);
    }

    return Buffer;
}

//
// Remove any extra semi-colons from BOOT.NVR
//
BOOLEAN
CleanBootFile(
    IN EFI_FILE_HANDLE* FileHandle,
    IN EFI_FILE_HANDLE* CurDir
    )
{
    char            *Buffer   = NULL,
                    *CpBuffer = NULL;
    UINTN           i,
                    Size      = 0,
                    NewSize   = 0;
    BOOLEAN         bError    = TRUE;
    EFI_STATUS      Status;
    EFI_FILE_HANDLE NewFile   = NULL;

    do
    {
        (*FileHandle)->SetPosition(*FileHandle, 0);

        Buffer = ReadBootFile(&Size, FileHandle);
        if (!Buffer)
        {
            break;
        }

        CpBuffer = AllocateZeroPool(Size);
        if (!CpBuffer)
        {
            break;
        }

        for (i = 0; i < Size; i++)
        {
            if ((*(Buffer + i) == ';')       &&
                ((*(Buffer + i + 1) == ';')  ||
                 (*(Buffer + i + 1) == '\r') ||
                 (i + 1 == Size)
                )
               )
            {
                continue;
            }

            *(CpBuffer + NewSize) = *(Buffer + i);
            NewSize++;
        }
        //
        // Remove the exisiting BOOT.NVR
        //
        Status = (*FileHandle)->Delete(*FileHandle);
        if (EFI_ERROR(Status))
        {
            break;
        }

        *FileHandle = NULL;

        Status = (*CurDir)->Open(
                            *CurDir,
                            &NewFile,
                            BOOT_NVR,
                            EFI_FILE_MODE_READ |
                                EFI_FILE_MODE_WRITE |
                                EFI_FILE_MODE_CREATE,
                            0);
        if (EFI_ERROR(Status))
        {
            break;
        }

        Status = NewFile->Write(NewFile, &NewSize, CpBuffer);
        if (EFI_ERROR(Status))
        {
            break;
        }

        bError = FALSE;

    } while (FALSE);
    //
    // Clean up
    //
    if (NewFile)
    {
        NewFile->Close(NewFile);
    }

    if (CpBuffer)
    {
        CpBuffer = RutlFree(CpBuffer);
    }

    if (Buffer)
    {
        Buffer = RutlFree(Buffer);
    }

    return bError;
}

//
// Backup the BOOT.NVR so we have a fall back
//
BOOLEAN
BackupBootFile(
    IN char*            Buffer,
    IN UINTN*           Size,
    IN EFI_FILE_HANDLE* CurDir
    )
{
    BOOLEAN         bError = FALSE;
    EFI_STATUS      Status;
    EFI_FILE_HANDLE FileHandle = NULL;

    do
    {
        //
        // Delete the backup file if already exists
        //
        Status = (*CurDir)->Open(
                            *CurDir,
                            &FileHandle,
                            BACKUP_NVR,
                            EFI_FILE_MODE_READ |
                                EFI_FILE_MODE_WRITE,
                            0);
        if (!EFI_ERROR(Status))
        {
            Status = FileHandle->Delete(FileHandle);
            if (EFI_ERROR(Status))
            {
                break;
            }
        }

        FileHandle = NULL;
        //
        // Copy current file data to a newly created backup file
        //
        Status = (*CurDir)->Open(
                            *CurDir,
                            &FileHandle,
                            BACKUP_NVR,
                            EFI_FILE_MODE_READ |
                                EFI_FILE_MODE_WRITE |
                                EFI_FILE_MODE_CREATE,
                            0);
        if (!EFI_ERROR(Status))
        {
            Status = FileHandle->Write(FileHandle, Size, Buffer);
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (FileHandle)
    {
        FileHandle->Close(FileHandle);
    }

    if (EFI_ERROR(Status))
    {
        bError = TRUE;
    }

    return bError;
}

//
// EFI Entry Point
//
EFI_STATUS
EfiMain(
    IN EFI_HANDLE        ImageHandle,
    IN EFI_SYSTEM_TABLE* ST
    )
{
    char*             Buffer      = NULL;
    char*             OSPath      = NULL;
    UINTN             Size        = 0,
                      Launch      = 0,
                      Menu        = 0;
    BOOT_DATA*        pBootData   = NULL;
    EFI_STATUS        Status;
    EFI_FILE_HANDLE   FileHandle  = NULL,
                      RootFs      = NULL;
    EFI_DEVICE_PATH*  DevicePath  = NULL;
    EFI_LOADED_IMAGE* LoadedImage = NULL;

    do
    {
        InitializeLib(ImageHandle, ST);
        //
        // Get the device handle and file path to the EFI OS Loader itself.
        //
        Status = BS->HandleProtocol(
                    ImageHandle,
                    &LoadedImageProtocol,
                    &LoadedImage);
        if (EFI_ERROR(Status))
        {
            Print(L"Can not retrieve LoadedImageProtocol handle\n");
            break;
        }

        Status = BS->HandleProtocol(
                    LoadedImage->DeviceHandle,
                    &DevicePathProtocol,
                    &DevicePath);
        if (EFI_ERROR(Status) || DevicePath == NULL)
        {
            Print(L"Can not find DevicePath handle\n");
            break;
        }
        //
        // Open volume for the device where the EFI OS Loader was loaded from
        //
        RootFs = LibOpenRoot(LoadedImage->DeviceHandle);
        if (!RootFs)
        {
            Print(L"Can not open the volume for the file system\n");
            break;
        }
        //
        // Look for any cmd line params
        //
        ParseArgs(&RootFs, LoadedImage);
        //
        // Attempt to open the boot.nvr
        //
        Status = RootFs->Open(
                            RootFs,
                            &FileHandle,
                            BOOT_NVR,
                            EFI_FILE_MODE_READ |
                                EFI_FILE_MODE_WRITE,
                            0);
        if (EFI_ERROR(Status))
        {
            Print(L"Can not open the file %s\n", BOOT_NVR);
            break;
        }

        Buffer = ReadBootFile(&Size, &FileHandle);
        if (!Buffer)
        {
            Print(L"ReadBootFile() failed!\n");
            break;
        }

        if (BackupBootFile(Buffer, &Size, &RootFs))
        {
            Print(L"BackupBootFile() failed!\n");
            break;
        }
        //
        // Alloc for boot file data struct
        //
        pBootData = (BOOT_DATA*) AllocateZeroPool(sizeof(BOOT_DATA));
        if (!pBootData)
        {
            Print(L"Failed to allocate memory for BOOT_DATA!\n");
            break;
        }

        if (GetBootData(pBootData, Buffer))
        {
            Print(L"Failed in GetBootData()!\n");
            break;
        }

        Menu = DisplayMenu(pBootData);

        if (Menu < pBootData->dwIndex)
        {
            if (!OrderBootFile(Menu, Buffer, pBootData))
            {
                FileHandle->SetPosition(FileHandle, 0);
                FileHandle->Write(FileHandle, &Size, Buffer);

                if (SortLoadOptions(
                        pBootData,
                        Buffer,
                        &Size,
                        &Menu,
                        &(pBootData->dwIndex),
                        &FileHandle)
                   )
                {
                    Print(L"Failed to SortLoadOptions()!\n");
                    break;
                }

                if (CleanBootFile(&FileHandle, &RootFs))
                {
                    Print(L"Failed to CleanBootFile()!\n");
                    break;
                }
            }
            else
            {
                Print(L"Failed to OrderBootFile()!\n");
                break;
            }
        }
        else
        {
            break;
        }

        OSPath = RutlStrDup(strstr(pBootData->pszOSLdr[Menu], wacks) + 1);
        if (!OSPath)
        {
            Print(L"Failed to allocate memory for OSPath!\n");
            break;
        }

        Launch = 1;

    } while (FALSE);
    //
    // Clean up
    //
    if (pBootData)
    {
        if (pBootData->dwIndex)
        {
            FreeBootData(pBootData);
        }

        pBootData = RutlFree(pBootData);
    }

    if (Buffer)
    {
        Buffer = RutlFree(Buffer);
    }

    if (FileHandle)
    {
        FileHandle->Close(FileHandle);
    }

    if (Launch)
    {
        if (LaunchOS(OSPath, ImageHandle, &RootFs, LoadedImage))
        {
            Print (L"Failed to LaunchOS()!\n");
        }
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\efintldr.obj \
     $(O)\utils.obj    \
     $(O)\menu.obj

EFI_LIBS=$(EFI_SOURCE)\build\$(LIBSRC)\output\lib\lib.lib

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP

$(O)\$(TARGETNAME).efi: $(OBJS) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\precomp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    includes

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <efi.h>
#include <efilib.h>

#include "efintldr.h"
#include "utils.h"
#include "menu.h"

#define wackc '\\'
#define wacks "\\"

#endif // __PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\menu.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    menu.h

Abstract:

    

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#ifndef __MENU_H__
#define __MENU_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define HIGHLT_MAIN_INIT  1
#define HIGHLT_MAIN_LOOP  2
#define HIGHLT_ADVND_INIT 3
#define HIGHLT_ADVND_LOOP 4

#define BL_SELECT_OS             L"Please select the operating system to start:"
#define BL_MOVE_HIGHLIGHT1       L"Use "
#define BL_MOVE_HIGHLIGHT2       L" and "
#define BL_MOVE_HIGHLIGHT3       L" to move the highlight to your choice.\nPress Enter to choose."
#define BL_TIMEOUT_COUNTDOWN     L"Seconds until highlighted choice will be started automatically: "
#define BL_ADVANCED_BOOT_MESSAGE L"For troubleshooting and advanced startup options for Windows 2000, press F8."
#define BL_ENABLED_KD_TITLE      L" [debugger enabled]"
#define BL_ADVANCEDBOOT_TITLE    L"Windows 2000 Advanced Options Menu\nPlease select an option:"
#define BL_SAFEBOOT_OPTION1      L"Safe Mode"
#define BL_SAFEBOOT_OPTION2      L"Safe Mode with Networking"
#define BL_SAFEBOOT_OPTION4      L"Safe Mode with Command Prompt"
#define BL_SAFEBOOT_OPTION6      L"Directory Services Restore Mode (Windows 2000 domain controllers only)"
#define BL_BOOTLOG               L"Enable Boot Logging"
#define BL_BASEVIDEO             L"Enable VGA Mode"
#define BL_LASTKNOWNGOOD_OPTION  L"Last Known Good Configuration"
#define BL_DEBUG_OPTION          L"Debugging Mode"
#define BL_MSG_BOOT_NORMALLY     L"Boot Normally"
#define BL_MSG_OSCHOICES_MENU    L"Return to OS Choices Menu"
#define BL_SAFEBOOT_OPTION1M     "SAFEBOOT:MINIMAL SOS BOOTLOG NOGUIBOOT"
#define BL_SAFEBOOT_OPTION2M     "SAFEBOOT:NETWORK SOS BOOTLOG NOGUIBOOT"
#define BL_SAFEBOOT_OPTION4M     "SAFEBOOT:MINIMAL(ALTERNATESHELL) SOS BOOTLOG NOGUIBOOT"
#define BL_SAFEBOOT_OPTION6M     "SAFEBOOT:DSREPAIR SOS"
#define BL_BOOTLOGM              "BOOTLOG"
#define BL_BASEVIDEOM            "BASEVIDEO"
#define BL_DEBUG_OPTIONM         "DEBUG"
#define BL_DEBUG_NONE            "NODEBUG"
#define BL_EXIT_EFI1             "Exit"
#define BL_EXIT_EFI2             "EFI Shell"
#define BL_NUMBER_OF_LINES       10
#define BL_MENU_ITEM             1
#define BL_MENU_BLANK_LINE       2

typedef struct _ADVANCEDBOOT_OPTIONS
{
    UINTN   MenuType;
    CHAR16* MsgId;
    char*   LoadOptions;

} ADVANCEDBOOT_OPTIONS, PADVANCEDBOOT_OPTIONS;

char*
FindAdvLoadOptions(
    IN char* String
    );

UINTN
DisplayMenu(
    IN VOID* hBootData
    );

#endif //__MENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\utils.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#ifndef __UTILS_H__
#define __UTILS_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

VOID*
RutlFree(
    IN VOID* pvData
    );

char*
RutlStrDup(
    IN char* pszSrc
    );

CHAR16*
RutlUniStrDup(
    IN char* pszSrc
    );

char* __cdecl
strtok(
    IN char*       string,
    IN const char* control
    );

char* __cdecl
strstr(
    IN const char* str1,
    IN const char* str2
    );

EFI_FILE_HANDLE
OpenFile(
    IN UINT64            OCFlags,
    IN EFI_LOADED_IMAGE* LoadedImage,
    IN EFI_FILE_HANDLE*  CurDir,
    IN CHAR16*           String
    );

#endif //__UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\utils.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#include "precomp.h"

//
// Conditionally free's a pointer if it is non-null
//
VOID*
RutlFree(
    IN VOID* pvData
    )
{
    if (pvData)
    {
        FreePool(pvData);
    }

    return NULL;
}

//
// Uses AllocateZeroPool to copy a string
//
char*
RutlStrDup(
    IN char* pszSrc
    )
{
    char* pszRet = NULL;
    UINTN dwLen  = 0;

    if ((pszSrc == NULL) ||
        ((dwLen = strlena(pszSrc)) == 0)
       )
    {
        return NULL;
    }

    pszRet = AllocateZeroPool(dwLen + 1);

    if (pszRet)
    {
        CopyMem(pszRet, pszSrc, dwLen);
    }

    return pszRet;
}

//
// Uses AllocateZeroPool to copy an ASCII string to unicode
//
CHAR16*
RutlUniStrDup(
    IN char* pszSrc
    )
{
    UINTN   i,
            dwLen  = 0;
    char*   t      = NULL;
    CHAR16* pszRet = NULL;

    if ((pszSrc == NULL) ||
        ((dwLen = strlena(pszSrc)) == 0)
       )
    {
        return NULL;
    }

    pszRet = AllocateZeroPool((dwLen + 1) * sizeof(CHAR16));
    if (pszRet != NULL)
    {
        t = (char*) pszRet;
        //
        // Convert the buffer to a hacked unicode.
        //
        for (i = 0; i < dwLen; i++)
        {
            *(t + i * 2) = *(pszSrc + i);
        }
    }

    return pszRet;
}

//
// Find next token in string
// Stolen from: ..\base\crts\crtw32\string\strtok.c
//
char* __cdecl
strtok(
    IN char*       string,
    IN const char* control
    )
{
    unsigned char*       str;
    const unsigned char* ctrl = control;
    unsigned char        map[32];
    int                  count;
    static char*         nextoken;

    /* Clear control map */
    for (count = 0; count < 32; count++)
    {
        map[count] = 0;
    }

    /* Set bits in delimiter table */
    do {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    /* Initialize str. If string is NULL, set str to the saved
     * pointer (i.e., continue breaking tokens out of the string
     * from the last strtok call) */
    if (string)
    {
        str = string;
    }
    else
    {
        str = nextoken;
    }

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token iff this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ((map[*str >> 3] & (1 << (*str & 7))) && *str)
    {
        str++;
    }

    string = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for (; *str; str++)
    {
        if (map[*str >> 3] & (1 << (*str & 7)))
        {
            *str++ = '\0';
            break;
        }
    }

    /* Update nextoken (or the corresponding field in the per-thread data
     * structure */
    nextoken = str;

    /* Determine if a token has been found. */
    if (string == str)
    {
        return NULL;
    }
    else
    {
        return string;
    }
}

//
// Find a substring
// Stolen from: ..\base\crts\crtw32\string\strstr.c
//
char* __cdecl
strstr(
    IN const char* str1,
    IN const char* str2
    )
{
    char* cp = (char*) str1;
    char* s1, *s2;

    if (!*str2)
    {
        return((char*)str1);
    }

    while (*cp)
    {
        s1 = cp;
        s2 = (char*) str2;

        while (*s1 && *s2 && !(*s1-*s2))
        {
            s1++, s2++;
        }

        if (!*s2)
        {
            return(cp);
        }

        cp++;
    }

    return(NULL);
}

//
// Open a file, return a handle
//
EFI_FILE_HANDLE
OpenFile(
    IN UINT64            OCFlags,
    IN EFI_LOADED_IMAGE* LoadedImage,
    IN EFI_FILE_HANDLE*  CurDir,
    IN CHAR16*           String
    )
{
    UINTN           i;
    CHAR16          FileName[128];
    CHAR16*         DevicePathAsString = NULL;
    EFI_STATUS      Status;
    EFI_FILE_HANDLE FileHandle         = NULL;

    DevicePathAsString = DevicePathToStr(LoadedImage->FilePath);

    if (!DevicePathAsString)
    {
        return NULL;
    }

    StrCpy(FileName, DevicePathAsString);
    DevicePathAsString = RutlFree(DevicePathAsString);

    for(i = StrLen(FileName); i > 0 && FileName[i] != wackc; i--)
        ;
    FileName[i] = 0;
    StrCat(FileName, String);

    Status = (*CurDir)->Open(
                        *CurDir,
                        &FileHandle,
                        FileName,
                        OCFlags,
                        0);
    if (EFI_ERROR(Status))
    {
        return NULL;
    }

    return FileHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efintldr\menu.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    menu.c

Abstract:

    

Revision History:

    Jeff Sigman             05/01/00  Created
    Jeff Sigman             05/10/00  Version 1.5 released
    Jeff Sigman             10/18/00  Fix for Soft81 bug(s)

--*/

#include "precomp.h"

ADVANCEDBOOT_OPTIONS AdvancedBootOptions[] =
{
    {BL_MENU_ITEM,       BL_SAFEBOOT_OPTION1,     BL_SAFEBOOT_OPTION1M},
    {BL_MENU_ITEM,       BL_SAFEBOOT_OPTION2,     BL_SAFEBOOT_OPTION2M},
    {BL_MENU_ITEM,       BL_SAFEBOOT_OPTION4,     BL_SAFEBOOT_OPTION4M},
    {BL_MENU_BLANK_LINE, NULL,                    NULL},
    {BL_MENU_ITEM,       BL_BOOTLOG,              BL_BOOTLOGM},
    {BL_MENU_ITEM,       BL_BASEVIDEO,            BL_BASEVIDEOM},
    {BL_MENU_ITEM,       BL_LASTKNOWNGOOD_OPTION, NULL},
    {BL_MENU_ITEM,       BL_SAFEBOOT_OPTION6,     BL_SAFEBOOT_OPTION6M},
    {BL_MENU_ITEM,       BL_DEBUG_OPTION,         BL_DEBUG_OPTIONM},
    {BL_MENU_BLANK_LINE, NULL,                    NULL},
    {BL_MENU_ITEM,       BL_MSG_BOOT_NORMALLY,    NULL},
    {BL_MENU_ITEM,       BL_MSG_OSCHOICES_MENU,   NULL}
};

#define MaxAdvancedBootOptions (sizeof(AdvancedBootOptions)/sizeof(ADVANCEDBOOT_OPTIONS))

//
//
//
char*
FindAdvLoadOptions(
    IN char* String
    )
{
    char* find = NULL;
    UINTN i;

    for (i = 0; i < MaxAdvancedBootOptions; i++)
    {
        if (!AdvancedBootOptions[i].LoadOptions)
        {
            continue;
        }

        if (find = strstr(String, AdvancedBootOptions[i].LoadOptions))
        {
            if (*(find - 1) == SPACEC)
            {
                find--;
                break;
            }
            else
            {
                find = NULL;
                continue;
            }
        }
    }

    return find;
}

//
//
//
void
MenuEraseLine(
    IN UINTN  x,
    IN UINTN  y,
    IN UINTN* Width
    )
{
    UINTN i;

    ST->ConOut->SetCursorPosition(ST->ConOut, x, y);

    for (i = 0; i < *Width; i++)
    {
        Print(L" ");
    }

    ST->ConOut->SetCursorPosition(ST->ConOut, x, y);

    return;
}

//
//
//
void
MenuHighlightOn(
    )
{
    ST->ConOut->SetAttribute(ST->ConOut, EFI_BACKGROUND_LIGHTGRAY);

    return;
}

//
//
//
void
MenuHighlightOff(
    )
{
    ST->ConOut->SetAttribute(ST->ConOut,
        EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_BLACK));

    ST->ConOut->SetAttribute(ST->ConOut, EFI_BACKGROUND_BLACK);

    return;
}

//
//
//
void
MenuHighlight(
    IN UINTN  Flag,
    IN UINTN* Highlight,
    IN UINTN* Width,
    IN UINT16 Key,
    IN VOID*  hBootData
    )
{
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    do
    {
        if (Flag == HIGHLT_MAIN_INIT) 
        {
            MenuHighlightOn();

            Print(L"    %a (%a)\n", pBootData->pszIdent[*Highlight],
                  pBootData->pszShort[*Highlight]);

            MenuHighlightOff();
            break;
        }
        else if (Flag == HIGHLT_MAIN_LOOP)
        {
            MenuEraseLine(0, (*Highlight) + 5, Width);

            Print(L"    %a (%a)\n", pBootData->pszIdent[*Highlight],
                  pBootData->pszShort[*Highlight]);

            switch (Key)
            {
            case SCAN_UP:
                if (*Highlight == 0)
                {
                    *Highlight = pBootData->dwIndex;
                }
                else
                {
                    (*Highlight)--;
                }
                break;
            case SCAN_DOWN:
                if (*Highlight == pBootData->dwIndex)
                {
                    *Highlight = 0;
                }
                else
                {
                    (*Highlight)++;
                }
                break;
            }

            MenuEraseLine(0, (*Highlight) + 5, Width);
            MenuHighlightOn();

            Print(L"    %a (%a)\n", pBootData->pszIdent[*Highlight],
                  pBootData->pszShort[*Highlight]);

            MenuHighlightOff();
            break;
        }
        else if (Flag == HIGHLT_ADVND_INIT)
        {
            MenuHighlightOn();
            Print(L"    %s\n", AdvancedBootOptions[*Highlight].MsgId);
            MenuHighlightOff();
            break;
        }
        else if (Flag == HIGHLT_ADVND_LOOP)
        {
            MenuEraseLine(0, (*Highlight) + 4, Width);
            Print(L"    %s\n", AdvancedBootOptions[*Highlight].MsgId);

            switch (Key)
            {
            case SCAN_UP:
                if (*Highlight == 0)
                {
                    *Highlight = MaxAdvancedBootOptions - 1;
                }
                else
                {
                    (*Highlight)--;
                }
                //
                // Check for space
                //
                if (AdvancedBootOptions[*Highlight].MsgId == NULL)
                {
                    if (*Highlight == 0)
                    {
                        *Highlight = MaxAdvancedBootOptions - 1;
                    }
                    else
                    {
                        (*Highlight)--;
                    }
                }
                break;
            case SCAN_DOWN:
                if (*Highlight == MaxAdvancedBootOptions - 1)
                {
                    *Highlight =0;
                }
                else
                {
                    (*Highlight)++;
                }
                //
                // Check for space
                //
                if (AdvancedBootOptions[*Highlight].MsgId == NULL)
                {
                    if (*Highlight == MaxAdvancedBootOptions - 1)
                    {
                        *Highlight = 0;
                    }
                    else
                    {
                        (*Highlight)++;
                    }
                }
                break;
            }

            MenuEraseLine(0, (*Highlight) + 4, Width);
            MenuHighlightOn();

            Print(L"    %s\n", AdvancedBootOptions[*Highlight].MsgId);

            MenuHighlightOff();
            break;
        }

    } while (FALSE);

    return;
}

//
//
//
UINTN
DrawAdvancedBoot(
    IN UINTN* Width,
    IN VOID*  hBootData
    )
{
    UINTN         i,
                  Highlight = 0,
                  Exit      = 0;
    BOOT_DATA*    pBootData = (BOOT_DATA*) hBootData;
    EFI_INPUT_KEY Key;

    //
    // Clear the screen
    //
    ST->ConOut->ClearScreen(ST->ConOut);

    Print(L"\n%s\n\n", BL_ADVANCEDBOOT_TITLE);

    for (i = 0; i < MaxAdvancedBootOptions; i++)
    {
        if (i == Highlight)
        {
            MenuHighlight(HIGHLT_ADVND_INIT, &Highlight, NULL, 0, pBootData);
            continue;
        }

        if (!(AdvancedBootOptions[i].MsgId))
        {
            Print(L"\n");
            continue;
        }

        Print(L"    %s\n", AdvancedBootOptions[i].MsgId);
    }

     Print(L"\n%s%c%s%c%s\n", BL_MOVE_HIGHLIGHT1, ARROW_UP,
        BL_MOVE_HIGHLIGHT2, ARROW_DOWN, BL_MOVE_HIGHLIGHT3);
     //
     // Loop through menu options until user hits enter/esc
     //
     while (!Exit)
     {
         WaitForSingleEvent(ST->ConIn->WaitForKey, 0);
         ST->ConIn->ReadKeyStroke(ST->ConIn, &Key);

         switch (Key.UnicodeChar)
         {
         case CHAR_CARRIAGE_RETURN:
             Exit = 1;
             continue;
         case 0:
             switch (Key.ScanCode)
             {
             case SCAN_UP:
                 MenuHighlight(
                     HIGHLT_ADVND_LOOP,
                     &Highlight,
                     Width,
                     SCAN_UP,
                     pBootData);
                 break;
             case SCAN_DOWN:
                 MenuHighlight(
                     HIGHLT_ADVND_LOOP,
                     &Highlight,
                     Width,
                     SCAN_DOWN,
                     pBootData);
                 break;
             case SCAN_ESC:
                 Highlight = 11;
                 Exit = 1;
                 continue;
             }
         }
     }

     return Highlight;
}

//
//
//
void
DrawChoices(
    IN UINTN* Highlight,
    IN VOID*  hBootData
    )
{
    int        i;
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    //
    // Clear the screen
    //
    ST->ConOut->ClearScreen(ST->ConOut);

    Print(L"\n\n%s\n\n\n", BL_SELECT_OS);

    for (i = 0; i <= pBootData->dwIndex; i++)
    {
        if (*Highlight == i)
        {
            MenuHighlight(HIGHLT_MAIN_INIT, Highlight, NULL, 0, pBootData);
            continue;
        }

        Print(L"    %a (%a)\n", pBootData->pszIdent[i],
              pBootData->pszShort[i]);
    }

    Print(L"\n%s%c%s%c%s\n", BL_MOVE_HIGHLIGHT1, ARROW_UP,
        BL_MOVE_HIGHLIGHT2, ARROW_DOWN, BL_MOVE_HIGHLIGHT3);

    return;
}

//
//
//
void
EnableAdvOpt(
    IN VOID*  hBootData,
    IN UINTN* Index
    )
{
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    if (AdvancedBootOptions[*Index].LoadOptions)
    {
        pBootData->pszLoadOpt =
            RutlStrDup(AdvancedBootOptions[*Index].LoadOptions);
    }
    else
    {
        pBootData->dwLastKnown = 1;
    }

    return;
}

//
//
//
void
DisableAdvOpt(
    IN VOID* hBootData
    )
{
    BOOT_DATA* pBootData = (BOOT_DATA*) hBootData;

    if (pBootData->pszLoadOpt)
        pBootData->pszLoadOpt = RutlFree(pBootData->pszLoadOpt);

    pBootData->dwLastKnown = 0;

    return;
}

//
//
//
UINTN
DisplayMenu(
    IN VOID* hBootData
    )
{
    int           i;
    UINTN         j,
                  Highlight = 0,
                  Width     = 0,
                  Height    = 0,
                  Exit      = 0,
                  Advanced  = 0;
    BOOT_DATA*    pBootData = (BOOT_DATA*) hBootData;
    EFI_STATUS    Status;
    EFI_INPUT_KEY Key;

    //
    // Set the screen to 80 x 25 mode
    //
    ST->ConOut->SetMode(ST->ConOut, 0);
    //
    // Get the height and width of the screen
    //
    ST->ConOut->QueryMode(ST->ConOut, ST->ConOut->Mode->Mode, &Width, &Height);
    //
    // Disable the cursor
    //
    ST->ConOut->EnableCursor(ST->ConOut, FALSE);

    DrawChoices(&Highlight, pBootData);

    Print(L"%s", BL_TIMEOUT_COUNTDOWN);

    for (i = (int)pBootData->dwCount; i >= 0; i--)
    {
        Print(L"\n\n\n%s", BL_ADVANCED_BOOT_MESSAGE);

        ST->ConOut->SetCursorPosition(
                        ST->ConOut,
                        StrLen(BL_TIMEOUT_COUNTDOWN),
                        BL_NUMBER_OF_LINES + pBootData->dwIndex - 1);

        Print(L"%d ", i);
        //
        // Wait 1 second, stop waiting if a key is pressed
        //
        Status = WaitForSingleEvent(ST->ConIn->WaitForKey, 10000000);
        //
        // Get the key from the buffer
        //
        ST->ConIn->ReadKeyStroke(ST->ConIn, &Key);

        if (Status == EFI_TIMEOUT)
        {
            Exit = 1;
            continue;
        }
        else
        {
            Exit = 0;
            //
            // Erase the the timeout message
            //
            MenuEraseLine(
                0,
                BL_NUMBER_OF_LINES + pBootData->dwIndex - 1,
                &Width);

            break;
        }
    }
    //
    // Loop through menu options until user hits enter
    //
    while (!Exit)
    {
        switch (Key.UnicodeChar)
        {
        case CHAR_CARRIAGE_RETURN:
            Exit = 1;
            continue;
        case 0:
            switch (Key.ScanCode)
            {
            case SCAN_UP:
                MenuHighlight(
                    HIGHLT_MAIN_LOOP,
                    &Highlight,
                    &Width,
                    SCAN_UP,
                    pBootData);
                break;
            case SCAN_DOWN:
                MenuHighlight(
                    HIGHLT_MAIN_LOOP,
                    &Highlight,
                    &Width,
                    SCAN_DOWN,
                    pBootData);
                break;
            case SCAN_F8:
                Advanced = DrawAdvancedBoot(&Width, pBootData);
                //
                // If user already selected another option, we kill it
                //
                DisableAdvOpt(pBootData);

                if (Advanced == 10)
                {
                    Exit = 1;
                    continue;
                }
                else
                {
                    DrawChoices(&Highlight, pBootData);
                    Print(L"\n\n\n%s", BL_ADVANCED_BOOT_MESSAGE);

                    if (Advanced < 9)
                    {
                        EnableAdvOpt(pBootData, &Advanced);

                        ST->ConOut->SetAttribute(ST->ConOut,
                            EFI_TEXT_ATTR(EFI_LIGHTBLUE, EFI_BLACK));

                        Print(L"\n\n%s", AdvancedBootOptions[Advanced].MsgId);
                        MenuHighlightOff();
                        break;
                    }
                }
                break;
            }
        }

        WaitForSingleEvent(ST->ConIn->WaitForKey, 0);
        ST->ConIn->ReadKeyStroke(ST->ConIn, &Key);
    }
    //
    // Clear the screen
    //
    ST->ConOut->ClearScreen(ST->ConOut);
    //
    // Re-enable the cursor
    //
    ST->ConOut->EnableCursor(ST->ConOut, TRUE);

    return Highlight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\global.c ===
/*++

Module Name:

    global.c

Abstract:

    

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/
#include <precomp.h>

//
// Globals for stdout
//
SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;

EFI_TEXT_CLEAR_SCREEN           ClearScreen;
EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
EFI_TEXT_SET_MODE               SetMode;
EFI_TEXT_ENABLE_CURSOR          EnableCursor;
int                             CursorRow, CursorColumn;

SIMPLE_INPUT_INTERFACE          *ConIn;

//
// Globals for protocol handler
//

EFI_HANDLE_PROTOCOL             HandleProtocol;
EFI_LOCATE_HANDLE               LocateHandle;
EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
EFI_IMAGE_LOAD                  LoadImage;
EFI_IMAGE_START                 StartImage;
EFI_SET_VARIABLE                SetVariable;
EFI_HANDLE                      MenuImageHandle;
EFI_LOADED_IMAGE                *ExeImage;

//
// Global GUIDs
//

// #define VEN_EFI      \
//    { 0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c }


EFI_GUID VenEfi                 = EFI_GLOBAL_VARIABLE;
//EFI_GUID EfiESPProtocol         = SYSTEM_PART_PROTOCOL;
EFI_GUID EfiESPProtocol         = BLOCK_IO_PROTOCOL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\console.c ===
#include <precomp.h>

//
// Global Coordinates
//
#define COL_TITLE               0
#define ROW_TITLE               0
#define COL_OSOPTIONS           2
#define ROW_OSOPTIONS           2
#define COL_PROMPT              0
#define ROW_PROMPT              2
#define CLEAR_LINE              L"                                                                               "
#define PROMPT                  L"Select> "
#define NUMBER_OF_USER_OPTIONS  3               // options, plus a space seperator
#define MAX_OPTIONS_PER_VAR     7

#define BACKUPNVRFILE           L"\\bootentries.bak"

BOOLEAN AllowExpertCommands = FALSE;
  
VOID
InitializeStdOut(
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    )
{
    //
    // Stash some of the efi stdout pointers
    //

    ConOut = SystemTable->ConOut;

    ClearScreen         = ConOut->ClearScreen;
    SetCursorPosition   = ConOut->SetCursorPosition;
    SetMode             = ConOut->SetMode;
    CursorRow           = ConOut->Mode->CursorRow;
    CursorColumn        = ConOut->Mode->CursorColumn;
    EnableCursor        = ConOut->EnableCursor;

    ConIn = SystemTable->ConIn;

    //
    // Set the mode to 80, 25 and clear the screen
    //
    SetMode( ConOut, 0 );
}

VOID
PrintTitle(
    )
{
    CHAR16 Buffer[256];
    
    ClearScreen( ConOut );
#if 0
    PrintAt( 0, 30, L"%H%s%N\n", TITLE1 );
    PrintAt( 0, 30, L"%H%s%N",   VER_PRODUCTBUILD );
#endif    

    SPrint(
        Buffer,
        sizeof(Buffer),
        L"%s [Version %d.%d.%d]",
        TITLE1,
        VER_PRODUCTMAJORVERSION,
        VER_PRODUCTMINORVERSION,
        VER_PRODUCTBUILD
        );

    PrintAt(0, 0, L"%H%s%N\n", Buffer);
}

BOOLEAN
isWindowsOsUserSelection(
    UINTN   userSelection
    )
{
    BOOLEAN status;

    status = isWindowsOsBootOption((char*)LoadOptions[userSelection],
                                   LoadOptionsSize[userSelection]
                                   );

    return status;
}


INTN
BackupBootOptions(
    CHAR16*         filePath
    )
{
    INTN    status;

    //
    // backup current boot options
    //

    Print(L"\nBacking up boot options...\n");

    status = SaveAllBootOptions(filePath);

    if(status != -1) {
        Print(L"Backed up Boot Options to file: %H%s%N\n",filePath);
        Print(L"Use %HImport%N command to retrieve saved boot options\n");
    } else {
        Print(L"Could not backup Boot Options to file: %H%s%N!\n",filePath);
    }

    return status;
}

VOID
DisplayMainMenu(
    )
{
    UINT32 done = FALSE;
    UINT32 nUserSelection, nSubUserSelection, nModifyVar;
    CHAR16 szUserSelection[1024];
    CHAR16 szOsLoader[1024];
    CHAR16 szInput[512];
    VOID* SourceBuffer = NULL;
    UINT32 PartitionCount;
    EFI_DEVICE_PATH *FilePath;

    //
    // Display boot options from nvram.
    //
    PrintTitle();
    GetBootManagerVars();
    DisplayBootOptions();

    //
    // Process user input.
    //
    while( !done )  {

        GetUserSelection( szUserSelection );
        
        //
        // Handle char string commands
        //
        if( (!StriCmp( szUserSelection, L"q")) || (!StriCmp( szUserSelection, L"quit"))
            || (!StriCmp( szUserSelection, L"Q")) || (!StriCmp( szUserSelection, L"exit")) ) {

            //
            // Quit
            //
            done = TRUE;

        }
        else if( (!StriCmp( szUserSelection, L"d")) || (!StriCmp( szUserSelection, L"D"))
            || (!StriCmp( szUserSelection, L"display")) ) {
            //
            // Display command
            //

            //
            // Choose selection
            //
            Print( L"\n" );
            nSubUserSelection = GetSubUserSelection( L"Enter boot option to display: ", (UINT32) GetOsBootOptionsCount() );

            if( nSubUserSelection != 0 ) {
                nSubUserSelection--;

                if (isWindowsOsUserSelection(nSubUserSelection) == FALSE) {
                
                    Print (L"\n\nThis tool only displays Windows OS boot options\n");

                } else {
                    
                    if(DisplayExtended( nSubUserSelection ))
                        ;
                    else {
                        Print( L"\n" );
                        Print( L"Wrong Boot Option %d Selected\n", nSubUserSelection+1 );
                    }

                }

                Print( L"\n" );
                Input( L"Press enter to continue", szInput, sizeof(szInput) );
            }

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        }
        else if( (!StriCmp( szUserSelection, L"e")) || (!StriCmp( szUserSelection, L"E"))
            || (!StriCmp( szUserSelection, L"erase")) ) {
            //
            // Erase command
            //

            BOOLEAN     selectedAll;    

            //
            // Choose selection
            //
            Print( L"\n" );
            nSubUserSelection = GetSubUserSelectionOrAll( L"Enter OS boot option to erase (* = All - Maximum of 30): ", 
                                                          (UINT32) GetOsBootOptionsCount(),
                                                          &selectedAll
                                                          );
            //
            // choose the path based on if the user wants all the os boot options whacked or not
            //

            if (selectedAll) {
            
                UINTN OsBootOptionsCount = GetOsBootOptionsCount();

                //
                // get user confirmation
                //
                Print( L"\n" );
                Input( L"This will erase all OS boot options. Are you Sure? ", szInput, sizeof(szInput) );
                
                if( (!StriCmp( szInput, L"y")) || (!StriCmp( szInput, L"Y"))) {
                    
                    //
                    // backup current boot options first
                    //
                    if (BackupBootOptions(BACKUPNVRFILE) != -1) {
                      
                        if(EraseAllOsBootOptions()) {
                            
                            Print(L"\n%d Boot Options Erased.\n", OsBootOptionsCount);
                            GetBootManagerVars();
                        
                        }
                        else {
                            
                            Print(L"\nThere are no OS Boot Options to Erase.\n");
                        
                        }
                    }
                    
                    Print( L"\n" );
                    Input( L"Press enter to continue", szInput, sizeof(szInput) );
                }
            
            } else {

                CHAR16  buf[256];

                if( nSubUserSelection > 0 ) {
                    
                    SPrint (buf, sizeof(buf), L"This will erase OS boot option %d. Are you Sure? ", nSubUserSelection);

                    // get user confirmation
                    //
                    Print( L"\n" );
                    Input( buf, szInput, sizeof(szInput) );

                    if( (!StriCmp( szInput, L"y")) || (!StriCmp( szInput, L"Y"))) {
                        nSubUserSelection--;

                        if(EraseOsBootOption(nSubUserSelection)) {

                           Print(L"\nBoot Option %d erased.\n", nSubUserSelection + 1);

                           FreeBootManagerVars();
                           GetBootManagerVars();

                        }
                        else {
                           Print(L"\nInvalid OS Boot Options specified.\n");
                        }

                        Print( L"\n" );
                        Input( L"Press enter to continue", szInput, sizeof(szInput) );
                    }
                }
            }

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        } else if( (!StriCmp( szUserSelection, L"p")) || (!StriCmp( szUserSelection, L"P"))
            || (!StriCmp( szUserSelection, L"push")) ) {
            //
            // Push command
            //

            //
            // Choose selection
            //
            Print( L"\n" );
            nSubUserSelection = GetSubUserSelection( L"Enter the boot option you want to push to top? ", (UINT32) GetOsBootOptionsCount() );

            if( nSubUserSelection > 0 ) {
                nSubUserSelection--;
                if(PushToTop( nSubUserSelection )) {
                    FreeBootManagerVars();
                    GetBootManagerVars();
                    Print( L"\n" );
                    Print( L"OS Boot Option %d pushed to top of boot order\n", nSubUserSelection+1 );
                }
                else {
                    Print( L"\n" );
                    Print( L"Wrong Boot Option %d Selected\n", nSubUserSelection+1 );
                }
                Input( L"Press enter to continue", szInput, sizeof(szInput) );
            }
            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        } else if( (!StriCmp( szUserSelection, L"c")) || (!StriCmp( szUserSelection, L"C"))
            || (!StriCmp( szUserSelection, L"copy")) ) {

            //
            // Copy command
            //

            //
            // Choose selection
            //
            Print( L"\n" );
            nSubUserSelection = GetSubUserSelection( L"Enter OS boot option to copy: ", (UINT32) GetOsBootOptionsCount() );

            if( nSubUserSelection != 0 ) {

                nSubUserSelection--;
                if(!CopyVar( nSubUserSelection )) {
                    Print( L"\n" );
                    Print( L"Could not Copy Boot Option %d\n",nSubUserSelection+1);
                }
                else {
                    SetBootManagerVars();
                    FreeBootManagerVars();
                    GetBootManagerVars();
                    Print( L"\n" );
                    Print( L"Boot Option %d Copied. ",nSubUserSelection+1);
                 }
                
                Print( L"\n" );
                Input( L"Press enter to continue", szInput, sizeof(szInput) );
            }

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        } else if( (!StriCmp( szUserSelection, L"x")) || (!StriCmp( szUserSelection, L"X"))
            || (!StriCmp( szUserSelection, L"export")) ) {
            //
            // Save command
            //
            
            CHAR16      filePath[512];
            BOOLEAN     selectedAll;    

            //
            // Choose selection
            //
            Print( L"\n" );
            nSubUserSelection = GetSubUserSelectionOrAll( L"Enter OS boot option to export (* = All - Maximum of 30): ", 
                                                          (UINT32) GetOsBootOptionsCount(),
                                                          &selectedAll
                                                          );
            if (nSubUserSelection > 0 || selectedAll) {
                
                Print( L"\n" );
                Input( L"Enter EXPORT file path: ", filePath, sizeof(filePath) );
                
                if (StrLen(filePath) > 0) {

                    //
                    // choose the path based on if the user wants all the os boot options exported or just one
                    //

                    if (selectedAll) {


                        Print(L"\nSaving %d boot options...\n", GetOsBootOptionsCount());

                        if(SaveAllBootOptions(filePath) != -1) {
                            Print(L"Saved Boot Options to file: %H%s%N\n",filePath);
                            Print(L"Use %HImport%N command to retrieve saved boot options\n");
                        } else {
                            Print(L"Could not save Boot Options to file: %H%s%N!\n",filePath);
                        }

                    } else {

                        Print(L"\nSaving boot option %d...\n", nSubUserSelection);

                        if(SaveBootOption(filePath, nSubUserSelection-1) != -1) {
                            Print(L"Saved Boot Option %d to file: %H%s%N\n",nSubUserSelection, filePath);
                            Print(L"Use %HImport%N command to retrieve saved boot option\n");
                        } else {
                            Print(L"Could not save Boot Option to file: %H%s%N!\n",filePath);
                        }

                    }
                }
            }

            Print( L"\n" );
            Input( L"Press enter to continue", szInput, sizeof(szInput) );
            
            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        } else if( (!StriCmp( szUserSelection, L"i")) || (!StriCmp( szUserSelection, L"I"))
            || (!StriCmp( szUserSelection, L"import")) ) {
            //
            // Restore command
            //

            CHAR16  filePath[512];

            Print( L"\n" );
            Input( L"Enter IMPORT file path: ", filePath, sizeof(filePath) );

            if (StrLen(filePath) > 0) {
                if(RestoreFileExists(filePath) == TRUE) {

                    if(RestoreNvr(filePath) != -1) {

                        Print( L"\n" );
                        Print(L"Imported Boot Options from file: %H%s%N\n",filePath);

                        FreeBootManagerVars();
                        GetBootManagerVars();   

                    }
                    else {

                        Print(L"Restore failed!\n");

                    }

                } else {

                    Print(L"\n\nError: Restore file not found: %s\n\n", filePath);
                
                }
            }

            Print( L"\n" );
            Input( L"Press enter to continue", szInput, sizeof(szInput) );

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        } 
#if 0
        else if( (!StriCmp( szUserSelection, L"a")) || (!StriCmp( szUserSelection, L"A"))
            || (!StriCmp( szUserSelection, L"add")) ) {
            //
            // Add command
            //

            //
            // Get EFI system partition
            //
            PartitionCount = GetPartitions();

            if( PartitionCount > 0 ) {
                    Print( L"\n" );
                    Input( L"Name of New BootOption: ", szInput, sizeof(szInput) );

                    FilePath = FileDevicePath( 
                                GetDeviceHandleForPartition(), 
                                L"os\\winnt50\\ia64ldr.efi" 
                                );

                    PackAndWriteToNvr(
                        -1,
                        "multi(0)disk(0)rdisk(0)partition(1)",
                        "multi(0)disk(0)rdisk(0)partition(1)\\os\\winnt50\\ia64ldr.efi",
                        "multi(0)disk(0)rdisk(0)partition(2)",
                        "\\WINNT64",
                        szInput[0] ? szInput : L"New Boot Option",
                        "",
                        (char*) FilePath
                        );

                    Print( L"\nAdded %H%s%N. Use %HModify%N command to change any of the default values.\n", 
                        szInput[0] ? szInput : L"New Boot Option" );
                    Input( L"Press enter to continue", szInput, sizeof(szInput) );

                    FreeBootManagerVars();
                    GetBootManagerVars();
            } else {
                Print( L"No partitions found. To use this option, you must have an EFI or FAT16\n" );
                Print( L"partition that will be used as your System Partition.\n" ); 
                Input( L"Press enter to continue", szInput, sizeof(szInput) );
            }

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        } 
#endif 
        else if( (!StriCmp( szUserSelection, L"h")) || (!StriCmp( szUserSelection, L"H"))
            || (!StriCmp( szUserSelection, L"help")) ) {
            //
            // Help command
            //

            PrintTitle();

            //
            // Display Help text.
            //
            Print( L"\n" );
            if ( AllowExpertCommands )  {
                Print( L"ExpertCommands Mode enabled.\n\n" );
            }
            Print( L"%HDisplay%N - Display an OS boot option's environment variables.\n" );
            Print( L"%HModify%N  - Modify an OS boot option's environment variable.\n" );
            Print( L"%HCopy%N    - Copy (duplicate) an OS boot option.\n" );
            Print( L"%HExport%N  - Export all/one OS boot option(s) to disk.\n" );
            Print( L"%HImport%N  - Import (and append) OS boot option(s) from disk.\n" );
            Print( L"%HErase%N   - Erase all OS boot options from NVRAM.\n" );
            Print( L"%HPush%N    - Push a OS boot option to top of boot order.\n" );
            Print( L"%HHelp%N    - This display.\n" );
            Print( L"%HQuit%N    - Quit.\n" );
            Print( L"\n");
            Print( L"Note: When importing/exporting boot options, all specified file paths\n");
            Print( L"      are absolute and relative to the current disk device.\n");
            Print( L"\n");
            Print( L"      Example: To import Boot0000 from the Windows loader directory WINNT50.0\n");
            Print( L"               on fs1, you would run nvrboot.efi on fs1 and use the path:\n");
            Print( L"\n");
            Print( L"               \\EFI\\Microsoft\\WINNT50.0\\Boot0000\n");
            Print( L"\n");
            Input( L"Press enter to continue", szInput, sizeof(szInput) );

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();

        }
        else if( (!StriCmp( szUserSelection, L"a")) || (!StriCmp( szUserSelection, L"Advanced")) ) {
            AllowExpertCommands = TRUE;
        }
        else if( (!StriCmp( szUserSelection, L"m")) || (!StriCmp( szUserSelection, L"M")) 
            || (!StriCmp( szUserSelection, L"modify")) ) {
            //
            // Modify command
            //
            
            //
            // Choose selection
            //
            Print( L"\n" );
            nSubUserSelection = GetSubUserSelection( L"Enter OS boot option to modify: ", (UINT32) GetOsBootOptionsCount() );

                               
            if( nSubUserSelection > 0 ) {
                
                nSubUserSelection--;

                if (isWindowsOsUserSelection(nSubUserSelection) == FALSE) {

                    Print( L"\n\nThis tool only modifies Windows OS boot options\n" );
                
                } else {
                    
                    if(DisplayExtended( nSubUserSelection )) {
                        
                        //
                        // Choose var
                        //
                        nModifyVar = GetSubUserSelection( L"Enter var to modify: ", MAX_OPTIONS_PER_VAR );
                        
                        if( nModifyVar > 0) {
                            Print( L"\n" );
                        
                            //
                            // Map variable to env var
                            //
                            switch( nModifyVar ) {
                        
                            case 1:
                                Input( L"LoadIdentifier = ", szInput, sizeof(szInput) );
                                nModifyVar = DESCRIPTION;
                                break;
                            case 2:
                                Input( L"OsLoadOptions = ", szInput, sizeof(szInput) );
                                nModifyVar = OSLOADOPTIONS;
                                break;
                            case 3:
                                if (!AllowExpertCommands) {
                                    Print (L"This field currently not modifiable\n");
                                    nModifyVar = 0;
                                } else {
                                    Input( L"EfiOsLoaderFilePath = ", szInput, sizeof(szInput) );
                                    nModifyVar = EFIFILEPATHLIST;
                                }
                                break;
                            case 4:
                                if (!AllowExpertCommands) {
                                    Print (L"This field currently not modifiable\n");
                                    nModifyVar = 0;
                                } else {
                                    Input( L"OsLoaderFilePath = ", szInput, sizeof(szInput) );
                                    nModifyVar = OSFILEPATHLIST;
                                }
                                break;                        
                            default:
                                break;
                            }
                        
                            if (nModifyVar != 0) {
                                //
                                // Write all vars to NV-RAM
                                //
                                SetFieldFromLoadOption(
                                    nSubUserSelection,
                                    nModifyVar,
                                    szInput
                                    );
                                
                                DisplayExtended(nSubUserSelection);
    
                                FreeBootManagerVars();
                                GetBootManagerVars();
                            }
                        }
                        
                        Print( L"\n" );

                    }
                }

                Input( L"Press enter to continue", szInput, sizeof(szInput) );
            }
            
        }

            //
            // Display boot options from nvram
            //
            PrintTitle();
            DisplayBootOptions();
    }
}

UINT32
GetConfirmation(
    IN CHAR16 *szConfirm
    )
{
    CHAR16 szIn[80];
    UINT32 saveRow;

    Print( L"\n" );

    saveRow = CursorRow;

    if( szConfirm ) {
        Input( szConfirm, szIn, sizeof(szIn) );
    } else {
        Input( L"Are you sure? ", szIn, sizeof(szIn) );
    }

    // Clear previous input
    SetCursorPosition( ConOut, 0, saveRow );
    PrintAt( 0, saveRow, CLEAR_LINE );

    if( (!StriCmp( szIn, L"y")) || (!StriCmp( szIn, L"yes")) )
        return TRUE;

    return FALSE;
}

VOID
GetUserSelection(
    OUT CHAR16 *szUserSelection
    )
{
    UINT32 numSelections;
    UINT32 row, col;

    numSelections = (UINT32) GetOsBootOptionsCount();

    numSelections += NUMBER_OF_USER_OPTIONS;

    // note, we use ROW_PROMPT as an offset
    row = ROW_OSOPTIONS + numSelections + ROW_PROMPT;
    col = COL_PROMPT;

    // Clear previous input
    //SetCursorPosition( ConOut, col, row );
    //PrintAt( col, row, CLEAR_LINE );

    // Get the input
    //SetCursorPosition( ConOut, col, row );
    Print(L"\n");
    Input( PROMPT, szUserSelection, 1024 );
}

//
// jamschw: got rid of the column settings in the PrintAt's.  PrintAt
// attempts to set the cursor position.  When it fails, it simply 
// prints at the next location.  Take this into account since the
// vmode was set to 80x25, but nobody wrote anything special to 
// make this a 25 line app.  So instead of having inconsistent UI,
// just let the information scroll off the screen in a consistent
// mannar.
//
VOID
DisplayBootOptions(
    )
{
    UINT32 i;
    UINT32 j;
    CHAR16 LoadIdentifier[200];
    UINTN   bootOrderCount;

    bootOrderCount = GetBootOrderCount();

    if (bootOrderCount > 0) {

        for ( i=0,j=0; i<GetOsBootOptionsCount(); i++ ) {

            if(LoadOptionsSize[i] == 0) {
                //
                // It's possible a null load option could be in the list
                // we naturally want to catch this...
                //
#if EFI_DEBUG
                Print(L"\nNVRAM Boot Entry %d has 0 length!\n", i);
                ASSERT(LoadOptionsSize[i] > 0);
#endif

                //
                // if we are not in debug mode, just let the use know what is
                // going on other wise the menu may be screwed up
                //
                PrintAt( 0, ROW_OSOPTIONS + j, L"  %2d. (0 length Boot Entry)\n", i+1);
            } else if(GetLoadIdentifier( i, LoadIdentifier)) {

                if (isWindowsOsBootOption((char*)LoadOptions[i], LoadOptionsSize[i]) == TRUE)
                {
                    PrintAt( 0, ROW_OSOPTIONS + j, L" *%2d. %s\n", i+1, LoadIdentifier );
                }
                else {

                    PrintAt( 0, ROW_OSOPTIONS + j, L"  %2d. %s\n", i+1, LoadIdentifier );
                }
                j++;
            }
        }

        if (GetBootOrderCount() != GetOsBootOptionsCount()) {
            PrintAt( 0, ROW_OSOPTIONS + ++j, L"  [Nvrboot does not support more than %d Boot Entries]\n", MAXBOOTVARS);
        }

        Print(L"\n");
        PrintAt( 0, ROW_OSOPTIONS + ++j, L"  * = Windows OS boot option\n" );
        Print(L"\n");
        j++;
    
    } else {

        PrintAt( 0, ROW_OSOPTIONS, L"  [No Boot Entries Present]\n");
        
        j = 2;

    }

    //
    // Display Maitainence Menu
    //
#if 0
    PrintAt( COL_OSOPTIONS, ROW_OSOPTIONS + ++j, L"%H(D)%Nisplay %H(M)%Nodify %H(C)%Nopy\n" );
    PrintAt( COL_OSOPTIONS, ROW_OSOPTIONS + ++j, L"%H(S)%Nave %H(R)%Nestore %H(E)%Nrase\n" );
//    PrintAt( COL_OSOPTIONS, ROW_OSOPTIONS + ++j, L"%H(A)%Ndd %H(P)%Nush %H(H)%Nelp   %H(Q)%Nuit\n" );
    PrintAt( COL_OSOPTIONS, ROW_OSOPTIONS + ++j, L"%H(P)%Nush %H(H)%Nelp   %H(Q)%Nuit\n" );
#endif
    
    PrintAt( 0, ROW_OSOPTIONS + ++j, L"  %H(D)%Nisplay %H(M)%Nodify %H(C)%Nopy E%H(x)%Nport %H(I)%Nmport %H(E)%Nrase %H(P)%Nush %H(H)%Nelp %H(Q)%Nuit\n" );
}

#if 0
#define L_SYSTEMPARTITION   L"SystemPartition"
#define L_OSLOADER          L"OsLoader"
#define L_OSLOADPARTITION   L"OsLoadPartition"
#define L_OSLOADFILENAME    L"OsLoadFilename"
#define L_LOADIDENTIFIER    L"LoadIdentifier"
#define L_OSLOADOPTIONS     L"OsLoadOptions"
#define L_OSLOADPATH        L"OsLoadOptions"
#define L_EFIFILEPATH       L"EfiOsLoaderFilePath"
#define L_COUNTDOWN         L"COUNTDOWN"
#define L_AUTOLOAD          L"AUTOLOAD"
#define L_LASTKNOWNGOOD     L"LastKnownGood"
#define L_BOOTSELECTION     L"BootSelection"
#endif

BOOLEAN
DisplayExtended(
    IN UINT32 Selection
    )
{
    char                OsLoadOptions[200];
    CHAR16              LoadIdentifier[200];
    unsigned char       EfiFilePath[1024];
    unsigned char       OsLoadPath[1024];
    CHAR16              FilePathShort[200];
    BOOLEAN             status;
    PFILE_PATH          pFilePath;
    EFI_GUID            DiskGuid;
    
#if DEBUG_PACK
    DisplayELOFromLoadOption(Selection);
#endif

    status = GetOsLoadOptionVars(
                Selection,
                LoadIdentifier,
                OsLoadOptions,
                EfiFilePath,
                OsLoadPath
                );
    if (status == FALSE) {
        return status;
    }
    
    Print( L"\n" );
    Print( L"1. LoadIdentifier = %s\n", LoadIdentifier );
    Print( L"2. OsLoadOptions = %s\n", OsLoadOptions );
    
    GetFilePathShort( (EFI_DEVICE_PATH*) EfiFilePath, FilePathShort );
    GetDiskGuidFromPath( (EFI_DEVICE_PATH*) EfiFilePath, &DiskGuid );
    Print( L"3. EfiOsLoaderFilePath = %g :: %s\n", &DiskGuid, FilePathShort );
    
    pFilePath = (FILE_PATH*)OsLoadPath;

    GetFilePathShort( (EFI_DEVICE_PATH*)pFilePath->FilePath, FilePathShort );
    GetDiskGuidFromPath( (EFI_DEVICE_PATH*) pFilePath->FilePath, &DiskGuid );
    Print( L"4. OsLoaderFilePath = %g :: %s\n", &DiskGuid, FilePathShort );
    
    return TRUE;
}

UINT32
GetSubUserSelectionOrAll(
    IN  CHAR16*     szConfirm,
    IN  UINT32      MaxSelection,
    OUT BOOLEAN*    selectedAll
    )
{
    CHAR16 szIn[80];
    UINT32 nUserSelection = 0;

    if( szConfirm ) {
        Input( szConfirm, szIn, sizeof(szIn) );
    } else {
        Input( L"Enter Selection (* = ALL - Maximum of 30)? ", szIn, sizeof(szIn) );
    }

    *selectedAll = FALSE;

    if (StrCmp(szIn, L"*") == 0) {
        
        *selectedAll = TRUE;
    
    } else {

        nUserSelection = (int) Atoi( szIn );

        if(( nUserSelection>0 ) && ( nUserSelection <= MaxSelection))
            return nUserSelection;
    
    }

    return 0;
}


UINT32
GetSubUserSelection(
    IN CHAR16 *szConfirm,
    IN UINT32 MaxSelection
    )
{
    CHAR16 szIn[80];
    UINT32 nUserSelection = 0;

    if( szConfirm ) {
        Input( szConfirm, szIn, sizeof(szIn) );
    } else {
        Input( L"Enter Selection? ", szIn, sizeof(szIn) );
    }

    nUserSelection = (int) Atoi( szIn );

    if(( nUserSelection>0 ) && ( nUserSelection <= MaxSelection))
        return nUserSelection;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\console.h ===
/*++

Module Name:

    console.h

Abstract:

    Console I/O header

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/

VOID
InitializeStdOut(
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
PrintTitle(
    );

VOID
DisplayMainMenu(
    );

VOID
GetUserSelection(
    OUT CHAR16 *szUserSelection
    );

UINT32
GetConfirmation(
    IN CHAR16 *szConfirm
    );

VOID
DisplayBootOptions(
    );

BOOLEAN
DisplayExtended(
    IN UINT32 Selection
    );

UINT32
GetSubUserSelection(
    IN CHAR16 *szConfirm,
    IN UINT32 MaxSelection
    );

UINT32
GetSubUserSelectionOrAll(
    IN  CHAR16*     szConfirm,
    IN  UINT32      MaxSelection,
    OUT BOOLEAN*    selectedAll
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\nvrboot.c ===
/*++

Module Name:

    nvrboot.c

Abstract:

    

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/
#include <precomp.h>


EFI_STATUS
InitializeNvrutilApplication(
    IN EFI_HANDLE                   ImageHandle,
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    )
{
    //
    // Initialize EFI routines
    //
    InitializeProtocols( SystemTable );
    InitializeStdOut( SystemTable );
    InitializeLib( ImageHandle, SystemTable );

    //
    // Save Image Handle
    // 
    MenuImageHandle = ImageHandle;


	BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, &ExeImage);
    //
    // Display the OS options
    //
    DisplayMainMenu();

    //
    // Clean-up and exit
    //
    ClearScreen( ConOut );

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\nvrboot.obj


EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
     $(O)\nvrboot.lib \
     $(O)\nvrboot.res
     

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-fixed
-entry:InitializeNvrutilApplication
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\nvrboot.efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\global.h ===
/*++

Module Name:

    global.h

Abstract:

    Global stuff

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/

//
// Version Info
//

#define TITLE1                        L"NVRBOOT: OS Boot Options Maintenance Tool"

//
// Globals for stdout
//

extern SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;

extern EFI_TEXT_CLEAR_SCREEN           ClearScreen;
extern EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
extern EFI_TEXT_SET_MODE               SetMode;
extern EFI_TEXT_ENABLE_CURSOR          EnableCursor;
extern int                             CursorRow, CursorColumn;

extern SIMPLE_INPUT_INTERFACE          *ConIn;

// 
// Globals for protocol handler
//

extern EFI_HANDLE_PROTOCOL             HandleProtocol;
extern EFI_LOCATE_HANDLE               LocateHandle;
extern EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
extern EFI_IMAGE_LOAD                  LoadImage;
extern EFI_IMAGE_START                 StartImage;
extern EFI_SET_VARIABLE                SetVariable;
extern EFI_HANDLE                      MenuImageHandle;
extern EFI_LOADED_IMAGE                *ExeImage;
//
// Global GUIDS
//

extern EFI_GUID VenEfi;
extern EFI_GUID EfiESPProtocol;

EFI_STATUS
WritePackedDataToNvr(
    UINT16 BootNumber,
    VOID  *BootOption,
    UINT32 BootSize
    );


#define MAXBOOTVARS   30
extern VOID*  LoadOptions     [MAXBOOTVARS];
extern UINT64 LoadOptionsSize [MAXBOOTVARS];
extern VOID*  BootOrder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\precomp.h ===
#include <efi.h>
#include <efilib.h>
#include <stdio.h>
#include <global.h>
#include <console.h>
#include <protocol.h>
#include <nvrio.h>
#include <savrstor.h>
#include <ntverp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\protocol.c ===
/*++

Module Name:

    protocol.c

Abstract:

    

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/
#include <precomp.h>

void
InitializeProtocols(
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    )
{

    EFI_BOOT_SERVICES    *bootServices;
    EFI_RUNTIME_SERVICES *runtimeServices;

    // 
    // Stash some of the handle protocol pointers
    //

    bootServices = SystemTable->BootServices;

    HandleProtocol      = bootServices->HandleProtocol;
    LocateHandle        = bootServices->LocateHandle;
    LocateDevicePath    = bootServices->LocateDevicePath;

    LoadImage           = bootServices->LoadImage;
    StartImage          = bootServices->StartImage;

    //
    // Stash some of the Runtime services pointers
    //
    
    runtimeServices = SystemTable->RuntimeServices;

    SetVariable = runtimeServices->SetVariable;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\nvrio.h ===
/*++

Module Name:

    nvrio.h

Abstract:

    Access function to r/w environment variables from NVRAM

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/
#define MAXBOOTVARS         30
#define MAXBOOTVARSIZE      1024

#ifndef ANYSIZE_ARRAY
    #define ANYSIZE_ARRAY 1       // winnt
#endif

#define GLOBAL_DEBUG 0
#define DEBUG_PACK GLOBAL_DEBUG

#if DEBUG_PACK
VOID
DisplayELOFromLoadOption(
    IN UINT32 OptionNum
    );

VOID
DisplayELO(
    char*       elo,
    UINT64      eloSize
    );

#endif

enum OptionalDataFields {
    OSLOADFILENAME,
    OSLOADOPTIONS,
    OSLOADPATH
};

enum EfiLoadOptionFields {
    ATTRIBUTE = 10,
    FILEPATHLISTLENGTH,
    DESCRIPTION,
    EFIFILEPATHLIST,
    OSFILEPATHLIST,
    OPTIONALDATA
};

//
// from EFI spec, ch. 17
//

typedef struct _EFI_LOAD_OPTION {
    UINT32 Attributes;
    UINT16 FilePathListLength;
    CHAR16 Description[1];
    //EFI_DEVICE_PATH FilePath[];
    //UINT8 OptionalData[];
} EFI_LOAD_OPTION, *PEFI_LOAD_OPTION;

typedef struct _WINDOWS_OS_OPTIONS {
    UINT8 Signature[8];
    UINT32 Version;
    UINT32 Length;
    UINT32 OsLoadPathOffset;
    CHAR16 OsLoadOptions[ANYSIZE_ARRAY];
    //FILE_PATH OsLoadPath;
} WINDOWS_OS_OPTIONS, *PWINDOWS_OS_OPTIONS;

typedef struct _FILE_PATH {
    UINT32 Version;
    UINT32 Length;
    UINT32 Type;
    CHAR8  FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

#define FILE_PATH_TYPE_ARC           1
#define FILE_PATH_TYPE_ARC_SIGNATURE 2
#define FILE_PATH_TYPE_NT            3
#define FILE_PATH_TYPE_EFI           4

//
// from public/sdk/inc/ntexapi.h
//
/*
typedef struct _WINDOWS_OS_OPTIONS {
    UCHAR Signature[8];
    ULONG Version;
    ULONG Length;
    ULONG OsLoadPathOffset;
    WCHAR OsLoadOptions[ANYSIZE_ARRAY];
    //FILE_PATH OsLoadPath;
} WINDOWS_OS_OPTIONS, *PWINDOWS_OS_OPTIONS;
*/

#define WINDOWS_OS_OPTIONS_SIGNATURE "WINDOWS"
#define WINDOWS_OS_OPTIONS_VERSION 1



/* 
** BUGBUG: temp prototypes - move to efilib.h later
*/
VOID
RUNTIMEFUNCTION
StrCpyA (
    IN CHAR8   *Dest,
    IN CHAR8    *Src
    );


VOID
RUNTIMEFUNCTION
StrCatA (
    IN CHAR8   *Dest,
    IN CHAR8   *Src
    );

UINTN
RUNTIMEFUNCTION
StrLenA (
    IN CHAR8   *s1
    );

UINTN
RUNTIMEFUNCTION
StrSizeA (
    IN CHAR8   *s1
    );

CHAR8 *
RUNTIMEFUNCTION
StrDuplicateA (
    IN CHAR8   *Src
    );
// temp protos end

VOID
GetBootManagerVars(
    );

BOOLEAN
EraseOsBootOption(
                    UINTN   BootVarNum
    );

BOOLEAN
EraseAllOsBootOptions(
    );

BOOLEAN
PushToTop(
    IN UINT32 BootVarNum
    );

UINT64
GetBootOrderCount(
    );

UINT64
GetOsBootOptionsCount(
    );

VOID
InsertString(
    IN OUT char* Dest,
    IN UINT32 Start,
    IN UINT32 End,
    IN char* InsertString
    );

VOID
SubString(
    IN OUT char* Dest,
    IN UINT32 Start,
    IN UINT32 End,
    IN char* Src
);

VOID
SetEnvVar(
    IN CHAR16* szVarName,
    IN CHAR16* szVarValue,
    IN UINT32   deleteFlag
    );

BOOLEAN
GetLoadIdentifier(
    IN UINT32 BootVarNum,
    OUT CHAR16* LoadIdentifier
    );

VOID
GetOptionalDataValue(
    IN UINT32 BootVarNum,
    IN UINT32 Selection,
    OUT char* OptionalDataValue
    );

BOOLEAN
GetOsLoadOptionVars(
    IN UINT32 BootVarNum,
    OUT CHAR16* LoadIdentifier,
    OUT char* OsLoadOptions,
    OUT char* EfiFilePath,
    OUT char* OsFilePath
    );

VOID
PackLoadOption(
    IN UINT32 BootVarNum,
    IN CHAR16* LoadIdentifier,
    IN CHAR16* OsLoadOptions,
    IN char*  EfiFilePath,
    IN UINT16 EfiFilePathLength,
    IN char*  OsLoadPath,
    IN UINT16 OsLoadPathLength
    );

VOID
SetFieldFromLoadOption(
    IN UINT32 BootVarNum,
    IN UINT32 FieldType,
    IN VOID* Data
    );

VOID
GetFieldFromLoadOption(
    IN UINT32 OptionNum,
    IN UINT32 FieldType,
    OUT VOID* Data,
    OUT UINT64* DataSize
    );

VOID
FreeBootManagerVars(
    );

BOOLEAN
CopyVar(
    IN UINT32 VarNum
    );

VOID
SetBootManagerVars(
    );

VOID
GetFilePathShort(
    EFI_DEVICE_PATH *FilePath,
    CHAR16 *FilePathShort
    );

VOID
GetDiskGuidFromPath( 
    EFI_DEVICE_PATH *FilePath, 
    EFI_GUID *DiskGuid
    );

UINT16
SetFilePathFromShort(
    EFI_DEVICE_PATH *FilePath,
    CHAR16* FilePathShort
    );

UINTN
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

CHAR16
FindFreeBootOption(
    );

UINT32
GetPartitions(
    );

EFI_HANDLE
GetDeviceHandleForPartition(
    );

VOID
DisplayOsOptions(
                char*           osOptions
                );

BOOLEAN
isWindowsOsBootOption(
    char*       elo, 
    UINT64      eloSize
    );

char*
GetAlignedOsOptions(
                char*   elo,
                UINT64  eloSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\hello\hello.c ===
#include <efi.h>
#include <efilib.h>


EFI_STATUS
EfiMain (    IN EFI_HANDLE           ImageHandle,
             IN EFI_SYSTEM_TABLE     *SystemTable)
{

	InitializeLib (ImageHandle, SystemTable);
	
    Print(L"Hello World\n");

	return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\savrstor.c ===
/*++

Module Name:

    savrstor.c

Abstract:

    Save/Restore boot options to/from disk

Author:

    Raj Kuramkote (v-rajk) 07-12-00

Revision History:

--*/
#include <precomp.h>

//
// externs
//
VOID
UtoA(
    OUT CHAR8* c,
    IN CHAR16* u
     );


#define EFINVRAM_DEBUG 0

//
// Writes boot options data to file
//
EFI_STATUS
PopulateNvrFile (
    EFI_FILE_HANDLE     NvrFile, 
    CHAR8*              bootoptions, 
    UINT32              buffersize
    )
{
	UINTN size;

	size= buffersize;   
	
	NvrFile->Write (NvrFile,&size,bootoptions);

    NvrFile->Close(NvrFile);
    
    return EFI_SUCCESS;

}

INTN
ParseNvrFile (
    EFI_FILE_HANDLE NvrFile
    )
{
	EFI_STATUS Status;
	CHAR8 *buffer;
	UINTN i,j,k,size;
    
    UINT64 BootNumber;
    UINT64 BootSize;
    UINT16 FreeBootNumber;
    VOID  *BootOption;
	UINTN  blockBegin;

    EFI_DEVICE_PATH *FilePath;
    EFI_FILE_INFO *fileInfo;
    EFI_STATUS status;

    size= SIZE_OF_EFI_FILE_INFO+255*sizeof (CHAR16);
	
	fileInfo = AllocatePool (size);

	if (fileInfo == NULL) {
        Print(L"\n");
		Print (L"Failed to allocate memory for File Info buffer!\n");
		return -1;
	}
	
	Status = NvrFile->GetInfo(NvrFile,&GenericFileInfo,&size,fileInfo);

	size=(UINTN) fileInfo->FileSize;
	
	FreePool (fileInfo);

	buffer = AllocatePool ((size+1));

	if (buffer == NULL) {
        Print(L"\n");
		Print (L"Failed to allocate memory for File buffer!\n");
		return -1;
	}

	Status = NvrFile->Read(NvrFile,&size,buffer);
    	
    NvrFile->Close (NvrFile);
	
	if (EFI_ERROR (Status)) {
        Print(L"\n");
		Print (L"Failed to read nvr file!\n");
		FreePool (buffer);
		return -1;
	}

#if EFINVRAM_DEBUG
	Print (L"\nRestoring NVRAM. Filesize = %x\n",
		   size
		   );
#endif

    //
    // One ugly hack! Needs to be cleaned up..
    // 
    k=0;
    
	while(k < size ) {
        
		blockBegin = k;

		CopyMem( &BootNumber, &buffer[k], sizeof(BootNumber));
        k += sizeof(UINT64);

        CopyMem( &BootSize, &buffer[k], sizeof(BootSize));
        k += sizeof(UINT64);
        
        BootOption = (VOID *)((CHAR8*)buffer + k);
        k += BootSize;
		
#if EFINVRAM_DEBUG
		Print (L"Boot%04x: start = %x, end = %x, options size %x, ptr = %x\n",
               BootNumber, 
			   blockBegin,
			   k-1,
			   BootSize, 
			   BootOption
			   );
#endif

        //
        // We don't use the incoming BootNumber because that number
        // is relative to the boot options that were present when 
        // it was saved.  Hence, we need to find a new boot entry #
        // relative to the current boot option table
        //
        FreeBootNumber = FindFreeBootOption();

        //
        // write the current boot entry into the table at the 
        // free boot entry location
        //
        status = WritePackedDataToNvr(
                    FreeBootNumber,
                    BootOption,
                    (UINT32)BootSize
                    );
        if (status != EFI_SUCCESS) {
            Print (L"Failed to write to NVRAM\n");
            return -1;
        }
    }

    FreePool (buffer);
    return 0;

}


EFI_STATUS
OpenCreateFile (
    UINT64              OCFlags,
    EFI_FILE_HANDLE*    StartHdl,
    CHAR16*             Name
    )
{
    EFI_FILE_IO_INTERFACE   *Vol;
    EFI_FILE_HANDLE         RootFs;
    EFI_FILE_HANDLE         CurDir;
    EFI_FILE_HANDLE         FileHandle;
    CHAR16                  FileName[100],*DevicePathAsString;
    UINTN                   i;
	EFI_STATUS 				Status;

    //
    // Open the volume for the device where the nvrutil was started.
    //
    Status = BS->HandleProtocol (ExeImage->DeviceHandle,
                                 &FileSystemProtocol,
                                 &Vol
                                 );

    if (EFI_ERROR(Status)) {
        Print(L"\n");
        Print(L"Can not get a FileSystem handle for %s DeviceHandle\n",ExeImage->FilePath);
        return Status;
    }

    Status = Vol->OpenVolume (Vol, &RootFs);

    if (EFI_ERROR(Status)) {
        Print(L"\n");
        Print(L"Can not open the volume for the file system\n");
        return Status;
    }

    CurDir = RootFs;

    //
    // Open saved boot options file 
    //
    FileName[0] = 0;

    DevicePathAsString = DevicePathToStr(ExeImage->FilePath);
    if (DevicePathAsString!=NULL) {
        StrCpy(FileName,DevicePathAsString);
        FreePool(DevicePathAsString);
    }

//    for(i=StrLen(FileName);i>0 && FileName[i]!='\\';i--);
//    FileName[i+1] = 0;

    StrCpy(FileName, L".\\");
    StrCat(FileName,Name);


    Status = CurDir->Open (CurDir,
                           &FileHandle,
                           FileName,
                           OCFlags,
                           0
                           );

	*StartHdl=FileHandle;

	return Status;
}

EFI_STATUS
DeleteFile (
    CHAR16 *FileName
    )
{
	EFI_FILE_HANDLE     FileHandle;
	EFI_STATUS 			Status;

	//
	// Get the file handle
	//
	Status = OpenCreateFile (
				EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
				&FileHandle,
				FileName
				);
	if (EFI_ERROR(Status)) {
		return Status;
    }

	//
	// do the delete
	//
	Status = FileHandle->Delete(FileHandle);
    if (EFI_ERROR(Status)) {
        Print(L"\n");
        Print(L"Can not delete the file %s\n",FileName);
        return Status;
    }

	return Status;
}

EFI_STATUS
InitializeNvrSaveFile(
    CHAR16*             fileName,
    EFI_FILE_HANDLE*    nvrFile
    )
{
	EFI_STATUS      status;

    //
    // we need to delete the existing NVRFILE so that we avoid
	// the problem of the new data buffer being smaller than the 
	// existing file length.  If this happens, the remains of the
	// previous osbootdata exist after the new buffer and before the 
	// EOF.
	//
	status = DeleteFile (fileName);
    if (EFI_ERROR(status) && status != EFI_NOT_FOUND) {
		return status;
    }

	status = OpenCreateFile (EFI_FILE_MODE_READ|EFI_FILE_MODE_WRITE|EFI_FILE_MODE_CREATE,nvrFile,fileName);
    if (EFI_ERROR (status)) {
        return status;
    }

    return status;
}

INTN
SaveBootOption (
    CHAR16*         fileName,
    UINT64          bootEntryNumber
    )
{
	EFI_STATUS      status;
	EFI_FILE_HANDLE nvrFile;
    UINT32          k;
    CHAR8*          buffer;
    UINT64          BootNumber;
    UINT64          BootSize;
    INTN            val;
    UINT64          bufferSize;
    
    if(bootEntryNumber > (UINT32)GetOsBootOptionsCount()) {
        return -1;
    }

    // 
    // open the save file
    //
    status = InitializeNvrSaveFile(fileName, &nvrFile);
    if (EFI_ERROR (status)) {
		Print(L"\nCan not open the file %s\n",fileName);
        return status;
    }


    BootNumber = ((CHAR16*)BootOrder)[bootEntryNumber];
    BootSize = LoadOptionsSize[bootEntryNumber];

    ASSERT(LoadOptions[bootEntryNumber] != NULL);
    ASSERT(LoadOptionsSize[bootEntryNumber] > 0);

    //
    // Sanity checking for the the load options
    //

    bufferSize = BootSize + sizeof(BootNumber) + sizeof(BootSize);
    ASSERT(bufferSize <= MAXBOOTVARSIZE);

    buffer = AllocatePool(bufferSize);
        
    k = 0;

    CopyMem( &buffer[k], &BootNumber, sizeof(BootNumber));
    k += sizeof(BootNumber);
    
    CopyMem( &buffer[k], &BootSize, sizeof(BootSize));
    k += sizeof(BootSize);
    
    CopyMem( &buffer[k], LoadOptions[bootEntryNumber], LoadOptionsSize[bootEntryNumber] );
    k += (UINT32)LoadOptionsSize[bootEntryNumber];
		
#if EFINVRAM_DEBUG
    Print(L"Boot%04x: options size = %x, total size = %x\n",
          BootNumber,
          BootSize,
          k
          );
#endif

    ASSERT(k == bufferSize);

	val = PopulateNvrFile (nvrFile, buffer, (UINT32)bufferSize );
        
    FreePool(buffer);

    return val;
}

INTN
SaveAllBootOptions (
    CHAR16*     fileName
    )
{
	EFI_STATUS      status;
	EFI_FILE_HANDLE nvrFile;
    UINT32          i, j, k;
    INTN            val;
    CHAR8*          buffer;
	UINT32          beginBlock;

    j = (UINT32)GetOsBootOptionsCount();
    if(j == 0) {
        return -1;
    }
    
    buffer = AllocatePool( j * MAXBOOTVARSIZE );
    if(buffer == NULL) {
        return -1;
    }

    // 
    // open the save file
    //
    status = InitializeNvrSaveFile(fileName, &nvrFile);
    if (EFI_ERROR (status)) {
		Print(L"\nCan not open the file %s\n",fileName);
        return status;
    }

    k = 0;
    
    //
    // get boot option env variables
    //
    for ( i = 0; i < j; i++ ) {
        
		UINT64 BootNumber;
        UINT64 BootSize;
        
		beginBlock = k;

        BootNumber = ((CHAR16*)BootOrder)[i];
        CopyMem( &buffer[k], &BootNumber, sizeof(BootNumber));
        k += sizeof(BootNumber);
        
        BootSize = LoadOptionsSize[i];
        CopyMem( &buffer[k], &BootSize, sizeof(BootSize));
        k += sizeof(BootSize);
		
        CopyMem( &buffer[k], LoadOptions[i], LoadOptionsSize[i] );
        k += (UINT32)LoadOptionsSize[i];
		
#if EFINVRAM_DEBUG
		Print(L"Boot%04x: begin = %x, end = %x, options size = %x\n",
			  BootNumber,
			  beginBlock,
			  k-1,
			  BootSize
			  );
#endif
                
    }

#if EFINVRAM_DEBUG
	Print(L"Total size = %x\n", k);
#endif

    ASSERT(k <= j*MAXBOOTVARSIZE);

	val = PopulateNvrFile (nvrFile, buffer, k );

    FreePool(buffer);

    return val;
}

BOOLEAN
RestoreFileExists(
    CHAR16*     fileName
    )
{

	EFI_STATUS Status;
    EFI_FILE_HANDLE nvrFile;

	//
	// Read from saved boot options file
    //
	Status = OpenCreateFile (EFI_FILE_MODE_READ,&nvrFile,fileName);
    if (EFI_ERROR (Status)) {
		return FALSE;
    }

    nvrFile->Close(nvrFile);

    return TRUE;
}


INTN
RestoreNvr (
    CHAR16*     fileName
   )
{
	EFI_STATUS Status;
    EFI_FILE_HANDLE nvrFile;

	//
	// Read from saved boot options file
    //
	Status = OpenCreateFile (EFI_FILE_MODE_READ,&nvrFile,fileName);
    if (EFI_ERROR (Status)) {
		Print(L"\nCan not open the file %s\n",fileName);
		return Status;
    }
    
    //
    // This updates nvram with saved boot options
    //
	return (ParseNvrFile (nvrFile));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\nvrio.c ===
/*++

Module Name:

    nvrio.c

Abstract:

    Access function to r/w environment variables from NVRAM

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/
#include <precomp.h>

#define FIELD_OFFSET(type, field)    ((UINT32)(UINTN)&(((type *)0)->field))

#define ALIGN_DOWN(length, type) \
    ((UINT32)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((UINT32)(length) + sizeof(type) - 1), type))

#define EFI_ATTR     EFI_VARIABLE_NON_VOLATILE  | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS

#if !defined(_WIN64)
typedef unsigned long    ULONG_PTR, *PULONG_PTR;
#else
typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
#endif

#ifndef POINTER_IS_ALIGNED
// BOOL
// POINTER_IS_ALIGNED(
//     IN LPVOID Ptr,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((ULONG_PTR)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )
#endif // !POINTER_IS_ALIGNED

VOID*  LoadOptions     [MAXBOOTVARS];
UINT64 LoadOptionsSize [MAXBOOTVARS];

VOID* BootOrder;
UINT64 BootOrderCount;
UINT64 OsBootOptionCount;

#define LOAD_OPTION_ACTIVE            0x00000001

//
// local routines
//
BOOLEAN
SetBootManagerVar(
                UINTN    BootVarNum
                );

BOOLEAN
SetBootManagerVarCheck(
                UINTN    BootVarNum
                );



INT32
SafeWcslen (
           CHAR16 *String,
           CHAR16 *Max
           )
{
    CHAR16 *p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return(UINT32)(p - String);
    }

    return -1;

} // SafeWclen

#define ISWINDOWSOSCHECK_DEBUG 0


BOOLEAN
isWindowsOsBootOption(
    char*       elo, 
    UINT64      eloSize
    )
//
// Purpose:     determine if the EFI_LOAD_OPTION structure in question is referring to 
//              a Windows OS boot option
// 
// Return:
// 
//      TRUE    elo refers to a Windows OS option
//
{
    CHAR16              *max;
    INT32               l;
    UINTN               length;
    PEFI_LOAD_OPTION    pElo;
    char*               devicePath;
    char*               osOptions;
    PWINDOWS_OS_OPTIONS pOsOptions;
    char*               aOsOptions;
    BOOLEAN             status;

    status = TRUE;
    aOsOptions = NULL;

    pElo = (EFI_LOAD_OPTION*)elo;

    if ( eloSize < sizeof(EFI_LOAD_OPTION) ) {
        status = FALSE;
        goto Done;
    }    

#if ISWINDOWSOSCHECK_DEBUG
    Print( L"Is %s a Windows OS boot option?\n", pElo->Description );
#endif

    //
    // Is the description properly terminated?
    //

    max = (CHAR16 *)(elo + eloSize);
    
    l = SafeWcslen( pElo->Description, max );
    if ( l < 0 ) {
#if ISWINDOWSOSCHECK_DEBUG
        Print (L"Failed: SafeWcslen( pElo->Description, max )\n");
#endif        
        status = FALSE;
        goto Done;
    }

    //
    // get the WINDOWS_OS_OPTIONS structure from the OptionalData field
    //
    
    osOptions = elo + 
                    FIELD_OFFSET(EFI_LOAD_OPTION,Description) +
                    StrSize(pElo->Description) +
                    pElo->FilePathListLength;
    
    length = (UINTN)eloSize;
    length -= (UINTN)(osOptions - elo);
    
#if ISWINDOWSOSCHECK_DEBUG
    Print (L"length = %x\n", length);
#endif

    //
    // make sure osOptions are atleast the size of the 
    // WINDOWS_OS_OPTIONS header
    // 
    //

    if ( length < FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions) ) {
#if ISWINDOWSOSCHECK_DEBUG
        Print (L"Failed: invalid length: %x\n", length);
#endif
        status = FALSE;
        goto Done;
    }

    //
    // align the os options
    //
    
    aOsOptions = GetAlignedOsOptions(elo, eloSize);
    pOsOptions = (WINDOWS_OS_OPTIONS*)aOsOptions;

#if ISWINDOWSOSCHECK_DEBUG
    DisplayOsOptions(aOsOptions);
#endif

    //
    // Does the OsOptions structure look like a WINDOWS_OS_OPTIONS structure?
    //
    
    if ( (length != pOsOptions->Length) ||
         (WINDOWS_OS_OPTIONS_VERSION != pOsOptions->Version) ||
         (strcmpa(pOsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) != 0) ) {
#if ISWINDOWSOSCHECK_DEBUG
        Print (L"Failed: OsOptions doesn't look like WINDOWS_OS_OPTIONS structure.\n");
        Print (L"test1: %x\n", length != pOsOptions->Length);
        Print (L"test2: %x\n", WINDOWS_OS_OPTIONS_VERSION != pOsOptions->Version);
        Print (L"test3: %x\n", strcmpa(pOsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) != 0 );
#endif        
        status = FALSE;
        goto Done;
    }
    
    //
    // Is the OsLoadOptions string properly terminated?
    //
    
    //
    // create a new max ptr to accomodate the fact that we are
    // now using an aligned copy of OsOptions from the Pool
    //
    max = (CHAR16*)(aOsOptions + pOsOptions->Length);

#if ISWINDOWSOSCHECK_DEBUG
    Print (L"max = %x, osloadoptions = %x, diff = %x, strsize=%x\n", 
           max, 
           pOsOptions->OsLoadOptions,
           (char*)max - (char*)pOsOptions->OsLoadOptions,
           StrSize(pOsOptions->OsLoadOptions)
           );
#endif    
    
    l = SafeWcslen( pOsOptions->OsLoadOptions, max );
    if ( l < 0 ) {
#if ISWINDOWSOSCHECK_DEBUG
        Print (L"Failed: SafeWcslen( osLoadOptions, max ) = %x\n", l);
#endif        
        status = FALSE;
        goto Done;
    }

Done:
    
    //
    // we are done with the os options
    //
    
    if (aOsOptions != NULL) {
        FreePool(aOsOptions);
    }

    return status;
}

#define GETBOOTVARS_DEBUG GLOBAL_DEBUG

VOID
GetBootManagerVars(
                  )
{
    UINT32 i,j;
    CHAR16 szTemp[10];
    VOID* bootvar;
    UINT64 BootOrderSize = 0;
    UINT64 maxBootCount;

    //
    // Initialize EFI LoadOptions.
    //
    BootOrderSize = 0;
    BootOrderCount = 0;
    OsBootOptionCount = 0;
    BootOrder = NULL;

#if 1
    ZeroMem( LoadOptions, sizeof(VOID*) * MAXBOOTVARS );
    ZeroMem( LoadOptionsSize, sizeof(UINT64) * MAXBOOTVARS );
#endif

    //
    // Ensure that the Load Options have been freed
    //
    ASSERT(BootOrderCount == 0);

    //
    // Get BootOrder.
    //
    BootOrder = LibGetVariableAndSize( L"BootOrder", &VenEfi, &BootOrderSize );

    if ( BootOrder ) {

        BootOrderCount = BootOrderSize / sizeof(CHAR16);

#if GETBOOTVARS_DEBUG
        Print (L"BootOrderCount = %x\n", BootOrderCount);
#endif

        maxBootCount = (MAXBOOTVARS < BootOrderCount) ? MAXBOOTVARS : BootOrderCount;
        //
        // Get the boot options.
        //
        for ( i=0; i<maxBootCount; i++ ) {
            SPrint( szTemp, sizeof(szTemp), L"Boot%04x", ((CHAR16*) BootOrder)[i] );

            ASSERT(LoadOptions[i] == NULL);
            ASSERT(LoadOptionsSize[i] == 0);

            LoadOptions[i] = LibGetVariableAndSize( szTemp, &VenEfi, &(LoadOptionsSize[i]) );

            //
            // The NVRAM variables are case sensitive.  The boot order variable said this
            // entry should exist.  If we did not find it, try again with uppercase
            // hexadecimal string
            //
            if (LoadOptions[i] == NULL && LoadOptionsSize[i] == 0) {
                SPrint( szTemp, sizeof(szTemp), L"Boot%04X", ((CHAR16*) BootOrder)[i] );
            
                LoadOptions[i] = LibGetVariableAndSize( szTemp, &VenEfi, &(LoadOptionsSize[i]) );
            }

#if GETBOOTVARS_DEBUG
            Print (L"i = %x, szTemp = %s, BOCnt = %x, LOptions = %x, BSize = %x\n", 
                   i,
                   szTemp,
                   OsBootOptionCount,
                   LoadOptions[i],
                   LoadOptionsSize[i]
                   );
#endif            
            

            OsBootOptionCount++;
        }
    }
#if GETBOOTVARS_DEBUG
    Print(L"BootOrderCount: %d OsBootOptionCount: %d\n", BootOrderCount, OsBootOptionCount);
#endif
}


#define ERASEBOOTOPT_DEBUG GLOBAL_DEBUG

BOOLEAN
EraseOsBootOption(
                    UINTN       BootVarNum
                  )
{
    UINTN   j;
    CHAR16  szTemp[10];
    CHAR16* tmpBootOrder;
    VOID*   bootvar;
    UINT64  BootOrderSize = 0;
    VOID*   pDummy;
    UINTN   dummySize;

    //
    // validate BootVarNum
    //
    if (MAXBOOTVARS <= BootVarNum) {
        return FALSE;
    }

    //
    // Initialize EFI LoadOptions.
    //
    BootOrderSize = 0;
    BootOrderCount = 0;
    BootOrder = NULL;

    //
    // Get BootOrder.
    //
    BootOrder = LibGetVariableAndSize( L"BootOrder", &VenEfi, &BootOrderSize );

    BootOrderCount = BootOrderSize / sizeof(CHAR16);

    ASSERT(BootVarNum < MAXBOOTVARS);
    ASSERT(BootOrderCount >= 1);
    
#if ERASEBOOTOPT_DEBUG
    Print (L"BootOrderCount = %x\n", BootOrderCount);
    Print (L"BootVarNum = %x\n", BootVarNum);
#endif

    //
    // if the boot option is populated, then erase it
    //
    if (LoadOptions[BootVarNum]) {

        //
        // free the local load option 
        //

        FreePool(LoadOptions[BootVarNum]);

        //
        // zero the local memory for the load options
        // 

        LoadOptions[BootVarNum] = (VOID*)0;
        LoadOptionsSize[BootVarNum] = 0;

        //
        // Get the boot option
        //
        SPrint( szTemp, sizeof(szTemp), L"Boot%04x", ((CHAR16*) BootOrder)[BootVarNum] );

#if ERASEBOOTOPT_DEBUG
        Print (L"BootXXXX = %s\n", szTemp);
#endif

        pDummy = LibGetVariableAndSize( szTemp, &VenEfi, &dummySize );

        //
        // The NVRAM variables are case sensitive.  If we were unable to 
        // find the variable, perhaps the Boot Entry string has uppercase
        // alpha characters in the hexadecimal string.  try again with
        // an uppercase string
        //
        if (pDummy == NULL && dummySize == 0) {
            SPrint( szTemp, sizeof(szTemp), L"Boot%04X", ((CHAR16*) BootOrder)[BootVarNum] );

            pDummy = LibGetVariableAndSize( szTemp, &VenEfi, &dummySize );
        }
        
        //
        // whack the nvram entry
        //

        SetVariable(
                   szTemp, 
                   &VenEfi, 
                   EFI_ATTR, 
                   0, 
                   NULL 
                   );

#if ERASEBOOTOPT_DEBUG
        Print (L"Adjusting boot order [begin]\n");
#endif

        //
        // adjust the counters for os boot options
        //
        OsBootOptionCount--;        
        BootOrderCount--;

        //
        // Shift the remaining entries in the boot order and the load options
        //

        tmpBootOrder = (CHAR16*)BootOrder;

        for (j = BootVarNum; j < BootOrderCount; j++) {
            
            //
            // adjust the boot order for all entries
            //
            tmpBootOrder[j] = tmpBootOrder[j + 1];

            //
            // only have a maximum of MAXBOOTVARS boot entries.
            // only adjust if we can.
            //
            if (j < OsBootOptionCount) {
                LoadOptions[j] = LoadOptions[j + 1]; 
                LoadOptionsSize[j] = LoadOptionsSize[j + 1];
            }

        }
        
        //
        // Set the modified boot order
        //
        SetVariable(
                   L"BootOrder", 
                   &VenEfi, 
                   EFI_ATTR, 
                   BootOrderCount * sizeof(CHAR16), 
                   BootOrder
                   );

#if ERASEBOOTOPT_DEBUG
        Print (L"Adjusting boot order [end]\n");
#endif

        return TRUE;

    }
    return FALSE;
}

BOOLEAN
EraseAllOsBootOptions(
                  )
{
    UINT32  i;
    UINT64  BootOrderSize = 0;
    BOOLEAN status;
    UINT64  maxBootCount;
#if ERASEBOOTOPT_DEBUG
    CHAR16  szInput[1024];
#endif

    //
    // Initialize EFI LoadOptions.
    //
    BootOrderSize = 0;
    BootOrderCount = 0;
    BootOrder = NULL;

    //
    // Get BootOrder.
    //
    BootOrder = LibGetVariableAndSize( L"BootOrder", &VenEfi, &BootOrderSize );
    BootOrderCount = BootOrderSize / sizeof(CHAR16);
    
    //
    // Make sure there is atleast one OS boot option
    //
    if ( BootOrder && OsBootOptionCount) {

        maxBootCount = (MAXBOOTVARS < BootOrderCount) ? MAXBOOTVARS : BootOrderCount;

        //
        // erase invidual boot options.
        //
        for ( i = 0; i < maxBootCount; i++ ) {
        
#if ERASEBOOTOPT_DEBUG
            Print (L"BootOrderCount = %x, Erasing boot option: %x\n", BootOrderCount, i);
#endif

            //
            // remove the boot entry at the head of the list
            //
            status = EraseOsBootOption(0);
            
#if ERASEBOOTOPT_DEBUG
            Input (L"Here!\n", szInput, sizeof(szInput));
            Print(L"\n");
#endif
            
            if (status == FALSE) {

                Print (L"Error: failed to erase boot entry %x\n", i);

                break;

            }
        }
    }
    
    return status;
}


BOOLEAN
PushToTop(
         IN UINT32 BootVarNum
         )
{
    UINT32 i;
    CHAR16 savBootOption;
    CHAR16* tmpBootOrder;
    UINT64 BootOrderSize = 0;

    //
    // check BootVarNum
    //
    if (MAXBOOTVARS <= BootVarNum) {
        return FALSE;
    }

    i=0;
    BootOrderSize = 0;
    BootOrder = NULL;

    //
    // Get BootOrder.
    //
    BootOrder = LibGetVariableAndSize( L"BootOrder", &VenEfi, &BootOrderSize );

    //
    // Make sure there is atleast one OS boot option
    //
    if ( BootOrder && OsBootOptionCount) {

        BootOrderCount = BootOrderSize / sizeof(CHAR16);

        //
        // Get the boot option.
        //
        tmpBootOrder = (CHAR16*)BootOrder;
        savBootOption = tmpBootOrder[BootVarNum];

        
        //
        // Now adjust the boot order
        //
        i=BootVarNum;
        while (i > 0) {
            tmpBootOrder[i] = tmpBootOrder[i-1];
            i--;
        }

        tmpBootOrder[0] = savBootOption;
        //
        // Set the changed boot order
        //
        SetVariable(
                   L"BootOrder", 
                   &VenEfi, 
                   EFI_ATTR, 
                   BootOrderCount * sizeof(CHAR16), 
                   BootOrder
                   );
        return TRUE;
    }
    return FALSE;
}

VOID
FreeBootManagerVars(
                   )
{
    UINTN i;

    for ( i=0; i<OsBootOptionCount; i++ ) {
        if ( LoadOptions[i] ) {
            FreePool( LoadOptions[i] );
        }
    }

    if ( BootOrder ) {
        FreePool( BootOrder );
    }

    //
    // zero the local memory for the load options
    // 
    ZeroMem( LoadOptions, sizeof(VOID*) * MAXBOOTVARS );
    ZeroMem( LoadOptionsSize, sizeof(UINT64) * MAXBOOTVARS );

}

BOOLEAN
CopyVar(
       IN UINT32 VarNum
       )
{
    CHAR16 i;
    BOOLEAN RetVal = FALSE;

    //
    // check to make sure we have room in our static structures
    //
    if (MAXBOOTVARS <= BootOrderCount) {
        return FALSE;
    }

    if ( VarNum < BootOrderCount ) {

        LoadOptions[BootOrderCount] = AllocateZeroPool( LoadOptionsSize[VarNum] );

        if ( LoadOptions[BootOrderCount] && LoadOptions[VarNum] ) {

            CopyMem( LoadOptions[BootOrderCount], LoadOptions[VarNum], LoadOptionsSize[VarNum] );
            LoadOptionsSize[BootOrderCount] = LoadOptionsSize[VarNum];

            BootOrder = ReallocatePool(
                                      (VOID*) BootOrder, 
                                      BootOrderCount * sizeof(CHAR16), 
                                      ( BootOrderCount + 1 ) * sizeof(CHAR16) 
                                      );

            ((CHAR16*) BootOrder)[BootOrderCount] = FindFreeBootOption();

            BootOrderCount++;
            OsBootOptionCount++;

            RetVal = SetBootManagerVar(BootOrderCount - 1);

        } 
    }
    return RetVal;
}

CHAR16
FindFreeBootOption(
                  )
{
    CHAR16 i;
    CHAR16 *BootOptionBitmap = NULL;
    UINT64 maxBootEntry;
    CHAR16 Id = 0xFFFF;

    //
    // use a bitmask to find an open spot.  by the pigeonhole
    // principle, we are guaranteed to find a spot if we 
    // look at BootOrderCount+1 entries
    //
    BootOptionBitmap = AllocateZeroPool( (BootOrderCount+1) * sizeof(CHAR16) );

    if (BootOptionBitmap) {
        for ( i=0; i<BootOrderCount; i++ ) {
            if ( ((CHAR16*)BootOrder)[i] <= BootOrderCount ) {
                BootOptionBitmap[ ((CHAR16*)BootOrder)[i] ] = 1;
            }
        }

        for ( i=0; i <= BootOrderCount; i++ ) {
            if ( BootOptionBitmap[i] == 0 ) {
                Id = i;
                break;
            }
        }

        FreePool(BootOptionBitmap);
    }

    return Id;
}

BOOLEAN
SetBootManagerVar(
                UINTN    BootVarNum
                )
{
    CHAR16  szTemp[50];
    BOOLEAN status;

    //
    // check BootVarNum
    //
    if (MAXBOOTVARS <= BootVarNum) {
        return FALSE;
    }

    status = TRUE;

    SPrint( szTemp, sizeof(szTemp), L"Boot%04x", ((CHAR16*) BootOrder)[BootVarNum] );
    
    if (LoadOptions[BootVarNum]) {
        
        SetVariable(
                   szTemp, 
                   &VenEfi, 
                   EFI_ATTR, 
                   LoadOptionsSize[BootVarNum], 
                   LoadOptions[BootVarNum] 
                   );
        
        SetVariable(
                   L"BootOrder", 
                   &VenEfi, 
                   EFI_ATTR, 
                   BootOrderCount * sizeof(CHAR16), 
                   BootOrder
                   );
    } 
    else
    {
        status = FALSE;
    }

    return status;
}

BOOLEAN
SetBootManagerVarCheck(
                UINTN    BootVarNum
                )
{
    CHAR16  szTemp[50];
    BOOLEAN status;
    VOID*   pDummy;
    UINTN   dummySize;

    //
    // check BootVarNum
    //
    if (MAXBOOTVARS <= BootVarNum) {
        return FALSE;
    }
    
    status = FALSE;

    SPrint( szTemp, sizeof(szTemp), L"Boot%04x", ((CHAR16*) BootOrder)[BootVarNum] );
    
    if (LoadOptions[BootVarNum]) {
        
        //
        // This routine expects to be writing a boot entry that is known 
        // to exist.  We need this routine since we did not track
        // if a hexadecimal string containing an alpha character was
        // uppercase or lowercase
        //
        pDummy = LibGetVariableAndSize( szTemp, &VenEfi, &dummySize );

        //
        // The NVRAM variables are case sensitive.  If we were unable to 
        // find the variable, perhaps the Boot Entry string has uppercase
        // alpha characters in the hexadecimal string.  try again with
        // an uppercase string
        //
        if (pDummy == NULL && dummySize == 0) {
            SPrint( szTemp, sizeof(szTemp), L"Boot%04X", ((CHAR16*) BootOrder)[BootVarNum] );

            pDummy = LibGetVariableAndSize( szTemp, &VenEfi, &dummySize );
        }        

        if (pDummy || dummySize) {
            //
            // the variable exists.  modify it now.
            //
            SetVariable(
                       szTemp, 
                       &VenEfi, 
                       EFI_ATTR, 
                       LoadOptionsSize[BootVarNum], 
                       LoadOptions[BootVarNum] 
                       );

            SetVariable(
                       L"BootOrder", 
                       &VenEfi, 
                       EFI_ATTR, 
                       BootOrderCount * sizeof(CHAR16), 
                       BootOrder
                       );

            status = TRUE;
        }
    } 

    return status;
}


VOID
SetBootManagerVars(
                  )
{
    UINTN   BootVarNum;
    BOOLEAN status;
    UINTN   maxBootCount;

    maxBootCount = (MAXBOOTVARS < BootOrderCount) ? MAXBOOTVARS : BootOrderCount;

    for ( BootVarNum = 0; BootVarNum < maxBootCount; BootVarNum++ ) {

        status = SetBootManagerVarCheck(BootVarNum);

        if (status == FALSE) {
            
            Print (L"ERROR: Attempt to write non-existent boot option to NVRAM!\n");
        
        }
    }
}


UINT64
GetBootOrderCount(
                 )
{
    return BootOrderCount;
}

UINT64
GetOsBootOptionsCount(
                     )
{
    return OsBootOptionCount;
}

VOID
SetEnvVar(
         IN CHAR16* szVarName,
         IN CHAR16* szVarValue,
         IN UINT32 deleteOnly
         )
/*
   deleteOnly
   TRUE     - Env var szVarName is deleted from nvr.
   FALSE    - Env var szVarName overwrites or creates
   
*/
{
    EFI_STATUS status;

    //
    // Erase the previous value
    //
    SetVariable(
               szVarName,
               &VenEfi,
               0,
               0,
               NULL
               );

    if ( !deleteOnly ) {

        //
        // Store the new value
        //
        status = SetVariable(
                            szVarName,
                            &VenEfi,
                            EFI_ATTR,
                            StrSize( szVarValue ),
                            szVarValue
                            );
    }
}

VOID
SubString(
         IN OUT char* Dest,
         IN UINT32 Start,
         IN UINT32 End,
         IN char* Src
         )
{
    UINTN i;
    UINTN j=0;

    for ( i=Start; i<End; i++ ) {
        Dest[ j++ ] = Src[ i ];
    }

    Dest[ j ] = '\0';
}

VOID
InsertString(
            IN OUT char* Dest,
            IN UINT32 Start,
            IN UINT32 End,
            IN char* InsertString
            )
{
    UINT32 i;
    UINT32 j=0;
    char first[1024];
    char last[1024];

    SubString( first, 0, Start, Dest  );
    SubString( last, End, (UINT32) StrLenA(Dest), Dest );

    StrCatA( first, InsertString );
    StrCatA( first, last );

    StrCpyA( Dest, first );
}



VOID
UtoA(
    OUT char* c,
    IN CHAR16* u
    )
{
    UINT32 i = 0;

    while ( u[i] ) {
        c[i] = u[i] & 0xFF;
        i++;
    }

    c[i] = '\0';
}


VOID
AtoU(
    OUT CHAR16* u,
    IN char*    c
    )
{
    UINT32 i = 0;

    while ( c[i] ) {
        u[i] = (CHAR16)c[i];
        i++;
    }

    u[i] = (CHAR16)'\0';
}

VOID
SetFieldFromLoadOption(
                       IN UINT32 BootVarNum,
                       IN UINT32 FieldType,
                       IN VOID* Data
                       )
{
    CHAR16  LoadIdentifier[200];
    char    OsLoadOptions[200];
    char    EfiFilePath[1024];
    char    OsLoadPath[1024];
    BOOLEAN status;
    UINT16 efiFilePathListLength = 0;
    UINT16 osLoadPathListLength  = 0;

    //
    // Make sure it is a valid OS load option
    //

    if (BootVarNum >= BootOrderCount)
        return ;
    if (BootVarNum >= MAXBOOTVARS) 
        return;
    if (LoadOptions[BootVarNum] == NULL)
        return;

    status = GetOsLoadOptionVars(
                       BootVarNum,
                       LoadIdentifier,
                       OsLoadOptions,
                       EfiFilePath,
                       OsLoadPath
                       );
    if (status == FALSE)    {
#ifdef DEBUG_PACK
        Print (L"\nSetFieldFromLoadOption: GetOsLoadOptionVars failed\n");
#endif // DEBUG_PACK
        return;
    }

    //
    // Set the field.
    //
    switch (FieldType) {
    
    case DESCRIPTION:
        StrCpy( LoadIdentifier, Data );
        break;

    case OSLOADOPTIONS:
        StrCpy( (CHAR16*)OsLoadOptions, (CHAR16*)Data );
        break;

#if 1
    case EFIFILEPATHLIST:
        efiFilePathListLength = SetFilePathFromShort( (EFI_DEVICE_PATH*) EfiFilePath, 
                                                      (CHAR16*) Data );
        break;

    case OSFILEPATHLIST: 
        {
        PFILE_PATH          pFilePath;
        
        pFilePath = (FILE_PATH*)OsLoadPath;
        osLoadPathListLength = SetFilePathFromShort( (EFI_DEVICE_PATH*) pFilePath->FilePath, 
                                                     (CHAR16*) Data );
        if ( osLoadPathListLength ) {
            osLoadPathListLength += (UINT16) FIELD_OFFSET( FILE_PATH, FilePath );
        }
        }
        break;
#endif

    default:
        break;

    }

    //
    // Pack the new parameters into the the current load option 
    //

    PackLoadOption(  BootVarNum,
                     LoadIdentifier,
                     (CHAR16*)OsLoadOptions,
                     EfiFilePath,
                     efiFilePathListLength,
                     OsLoadPath,
                     osLoadPathListLength
                     );

    //
    // save the new load option into NVRAM
    //

    SetBootManagerVarCheck(BootVarNum);

}

VOID
GetFilePathShort(
                EFI_DEVICE_PATH *FilePath,
                CHAR16 *FilePathShort
                )
{
    UINT32 i, j, End;
    EFI_DEVICE_PATH *n = FilePath;

    //
    // Advance to FilePath node.
    //
    while (( n->Type    != END_DEVICE_PATH_TYPE           ) &&
           ( n->SubType != END_ENTIRE_DEVICE_PATH_SUBTYPE ) ) {

        if (( n->Type    == MEDIA_DEVICE_PATH ) &&
            ( n->SubType == MEDIA_FILEPATH_DP )) {

            j = 0;
            End = DevicePathNodeLength(n);

            for ( i=sizeof(EFI_DEVICE_PATH); i<End; i++ ) {
                ((char*) FilePathShort)[j++] = ( (char*) n)[i];
            }

            break;
        }

        n = NextDevicePathNode(n);
    }
}


VOID
GetDiskGuidFromPath( 
    EFI_DEVICE_PATH *FilePath, 
    EFI_GUID *DiskGuid
    )
{
    UINT32 i, j, End;
    EFI_DEVICE_PATH *n = FilePath;
    HARDDRIVE_DEVICE_PATH *harddriveDp;

    //
    // Advance to FilePath node.
    //
    while (( n->Type    != END_DEVICE_PATH_TYPE           ) &&
           ( n->SubType != END_ENTIRE_DEVICE_PATH_SUBTYPE ) ) {

        if (( n->Type    == MEDIA_DEVICE_PATH ) &&
            ( n->SubType == MEDIA_HARDDRIVE_DP )) {
            harddriveDp = (HARDDRIVE_DEVICE_PATH *)n;
            CopyMem( DiskGuid, &harddriveDp->Signature, sizeof(harddriveDp->Signature) );

            break;
        }

        n = NextDevicePathNode(n);
    }
}

UINT16 // new FilePathListLength if updated. 0 otherwise.
SetFilePathFromShort(
                    EFI_DEVICE_PATH *FilePath,
                    CHAR16* FilePathShort
                    )
{
    UINT32 i, j, End;
    EFI_DEVICE_PATH *n = FilePath;
    UINT64 DevicePathSize;
    UINT16 length = 0;

    //
    // Advance to FilePath node.
    //
    while (( n->Type    != END_DEVICE_PATH_TYPE           ) &&
           ( n->SubType != END_ENTIRE_DEVICE_PATH_SUBTYPE ) ) {

        if (( n->Type    == MEDIA_DEVICE_PATH ) &&
            ( n->SubType == MEDIA_FILEPATH_DP )) {

#if DEBUG_PACK
            Print (L"SetFilePathFromShort: Entry found...\n");
#endif // DEBUG_PACK

            j = 0;
            End = DevicePathNodeLength(n);

            //
            // Set the new file path
            //
            DevicePathSize = GetDevPathSize(n);
            for ( i=sizeof(EFI_DEVICE_PATH); i<DevicePathSize; i++ ) {
                ((char*) n)[i] = '\0';
            }

            j=sizeof(EFI_DEVICE_PATH);

            for ( i=0; i<StrSize(FilePathShort); i++ ) {
                ((char*)n)[j++] = ((char*)FilePathShort)[i];
            }

            SetDevicePathNodeLength( n, StrSize(FilePathShort) + sizeof(EFI_DEVICE_PATH) );

            n = NextDevicePathNode(n);
            SetDevicePathEndNode(n);
            n = NextDevicePathNode(n);
            length = (UINT16)((ULONG_PTR)n - (ULONG_PTR)FilePath);
            break;
        }

        n = NextDevicePathNode(n);
    }
#if DEBUG_PACK
    if (length == 0) Print (L"SetFilePathFromShort: Entry _NOT_ updated...\n");
#endif // DEBUG_PACK
    return( length );
}

VOID
SetDiskGuidInPath( 
    EFI_DEVICE_PATH *FilePath, 
    EFI_GUID *DiskGuid
    )
{
    UINT32 i, j, End;
    EFI_DEVICE_PATH *n = FilePath;
    HARDDRIVE_DEVICE_PATH *harddriveDp;

    //
    // Advance to FilePath node.
    //
    while (( n->Type    != END_DEVICE_PATH_TYPE           ) &&
           ( n->SubType != END_ENTIRE_DEVICE_PATH_SUBTYPE ) ) {

        if (( n->Type    == MEDIA_DEVICE_PATH ) &&
            ( n->SubType == MEDIA_FILEPATH_DP )) {
            harddriveDp = (HARDDRIVE_DEVICE_PATH *)n;
            CopyMem( &harddriveDp->Signature, DiskGuid, sizeof(harddriveDp->Signature) );

            break;
        }

        n = NextDevicePathNode(n);
    }
}


char*
GetAlignedELOFilePath(
                        char*   elo
    )
{
    UINTN               abufSize;
    char*               abuf;
    PEFI_LOAD_OPTION    pElo;
    
    pElo = (EFI_LOAD_OPTION*)elo;

    abufSize = pElo->FilePathListLength;

    abuf = AllocatePool(abufSize);

    CopyMem(abuf,
            elo + 
            FIELD_OFFSET(EFI_LOAD_OPTION, Description) + 
            StrSize(pElo->Description),  
            abufSize
           );

    return abuf;
}

char*
GetAlignedOptionalData(
                char*   elo,
                UINT64  eloSize,
                UINT64* dataSize
                )
{
    UINTN               abufSize;
    char*               abuf;
    PEFI_LOAD_OPTION    pElo;
    UINTN               offset;
    
    pElo = (EFI_LOAD_OPTION*)elo;

    offset = FIELD_OFFSET(EFI_LOAD_OPTION, Description) + 
                StrSize(pElo->Description) +
                pElo->FilePathListLength;

    abufSize = eloSize - offset;
    
    abuf = AllocatePool(abufSize);

    CopyMem(abuf,
            elo + offset,
            abufSize
            );

    *dataSize = abufSize;

    return abuf;
}

char*
GetAlignedOsOptions(
                char*   elo,
                UINT64  eloSize
    )
{
    UINT64      dummy;
    char*       abuf;

    abuf = GetAlignedOptionalData(elo,
                                  eloSize,
                                  &dummy
                                 );

    return abuf;
}

char*
GetAlignedOsLoadPath(
                IN  char*       osOptions,
                OUT UINTN*      osLoadPathSize
    )
//
// we need to align the FilePath structure because the load options are
// variable in length, so the FilePath structure may not be aligned
//
{
    UINTN               abufSize;
    char*               abuf;
    PWINDOWS_OS_OPTIONS pOsOptions;

    pOsOptions = (WINDOWS_OS_OPTIONS*)osOptions;

    abufSize = pOsOptions->Length - 
                FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions) -
                StrSize(pOsOptions->OsLoadOptions);

    abuf = AllocatePool(abufSize);

    CopyMem(abuf, 
            &osOptions[pOsOptions->OsLoadPathOffset], 
            abufSize
            );

    *osLoadPathSize = abufSize;

    return abuf;
}

VOID
DisplayLoadPath(
                char*           osLoadPath
                )
{
    PFILE_PATH          pFilePath;
    
    pFilePath = (FILE_PATH*)osLoadPath;
    
    Print (L"osOptions->FILE_PATH->Version = %x\n", pFilePath->Version);
    Print (L"osOptions->FILE_PATH->Length = %x\n", pFilePath->Length);
    Print (L"osOptions->FILE_PATH->Type = %x\n", pFilePath->Type);
    
    if (pFilePath->Type == FILE_PATH_TYPE_EFI) {

        CHAR16      FilePathShort[200];

        GetFilePathShort(
                        (EFI_DEVICE_PATH *)pFilePath->FilePath,
                        FilePathShort
                        );

        Print (L"osOptions->FILE_PATH->FilePath(EFI:DP:Short) = %s\n", FilePathShort);

    }
}

VOID
DisplayOsOptions(
                char*           osOptions
                )
{
    PWINDOWS_OS_OPTIONS pOsOptions;
    CHAR16              wideSig[256];    
    char*               aOsLoadPath;
    UINTN               aOsLoadPathSize;

    pOsOptions = (WINDOWS_OS_OPTIONS*)osOptions;

    Print (L">>>>\n");

    //
    // display the attributes
    //

    AtoU(wideSig, pOsOptions->Signature);

    Print (L"osOptions->Signature = %s\n",  wideSig);
    Print (L"osOptions->Version = %x\n", pOsOptions->Version);
    Print (L"osOptions->Length = %x\n", pOsOptions->Length);
    Print (L"osOptions->OsLoadPathOffset = %x\n", pOsOptions->OsLoadPathOffset);

    // display the os load options

    Print (L"osOptions->OsLoadOptions = %s\n", pOsOptions->OsLoadOptions);

    //
    // display the FILE PATH
    //
    
    //
    // we need to align the FilePath structure because the load options are
    // variable in length, so the FilePath structure may not be aligned
    //
    aOsLoadPath = GetAlignedOsLoadPath(osOptions, &aOsLoadPathSize);

    DisplayLoadPath(aOsLoadPath);   

    FreePool(aOsLoadPath);

    Print (L"<<<<\n");

}

VOID
DisplayELO(
    char*       elo,
    UINT64      eloSize
    )
{
    PEFI_LOAD_OPTION        pElo;
#if 0
    UINT64                  eloSize;
#endif    
    CHAR16                  FilePathShort[200];
    char*                   aOsOptions;

    pElo = (EFI_LOAD_OPTION*)elo;

    Print (L"elo->Attributes = %x\n", pElo->Attributes);
    Print (L"elo->FilePathListLength = %x\n", pElo->FilePathListLength);
    Print (L"elo->Description = %s\n", pElo->Description);

    GetFilePathShort(
                    (EFI_DEVICE_PATH *)&elo[FIELD_OFFSET(EFI_LOAD_OPTION, Description) + StrSize(pElo->Description)],
                    FilePathShort
                    );
    Print (L"elo->FilePath(EFI:DP:SHORT) = %s\n", FilePathShort);

#if 0
    eloSize = FIELD_OFFSET(EFI_LOAD_OPTION, Description) + StrSize(pElo->Description) + pElo->FilePathListLength;
    DisplayOsOptions(&elo[eloSize]);
#else

    aOsOptions = GetAlignedOsOptions(
        elo, 
        eloSize
        );

    DisplayOsOptions(aOsOptions);
    
    FreePool(aOsOptions);

#endif

}

VOID
BuildNewOsOptions(
                 IN  CHAR16*                 osLoadOptions,
                 IN  char*                   osLoadPath,
                 OUT char**                  osOptions
                 )
//
//
// Note:    osLoadPath must be aligned
// 
{
    char*                       newOsOptions;
    PWINDOWS_OS_OPTIONS         pNewOsOptions;
    UINT32                      osLoadOptionsLength;
    UINT32                      osOptionsLength;
    PFILE_PATH                  pOsLoadPath;

    //
    // NOTE: aligning the FILE_PATH structure (osLoadPath) works
    //       by aligning the osLoadOptionsLength because the
    //       WINDOWS_OS_OPTIONS structure has a UINT32 variable
    //       before the OsLoadOptions.  If anything changes above
    //       the OsLoadOptions in the WINDOWS_OS_OPTIONS structure
    //       the alignment method may have to change in this structure.
    //

    //
    //
    // determine the size of the os load options (UNICODE) string
    //

    osLoadOptionsLength = (UINT32)StrSize(osLoadOptions);
    osLoadOptionsLength = ALIGN_UP(osLoadOptionsLength, UINT32);

#if DEBUG_PACK
    Print (L"osLoadOptionsLength = %x\n", osLoadOptionsLength);
#endif

    pOsLoadPath = (FILE_PATH*)osLoadPath;

#if DEBUG_PACK
    Print (L"pOsLoadPath->Length = %x\n", pOsLoadPath->Length);
#endif

    //
    // determine the size of the new WINDOWS_OS_OPTIONS structure
    //

    osOptionsLength = FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions) + osLoadOptionsLength + pOsLoadPath->Length; 
#if DEBUG_PACK
    Print (L"osOptionsLength = %x\n", osOptionsLength);
#endif

    //
    // Allocate memory for the WINDOWS_OS_OPTIONS
    //

    newOsOptions = AllocatePool(osOptionsLength);

    ASSERT(newOsOptions != NULL);

    pNewOsOptions = (WINDOWS_OS_OPTIONS*)newOsOptions;

    //
    // populate the new os options
    // 

    StrCpyA((char *)pNewOsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
    pNewOsOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
    pNewOsOptions->Length = (UINT32)osOptionsLength;
    pNewOsOptions->OsLoadPathOffset = FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions) + osLoadOptionsLength;
    StrCpy(pNewOsOptions->OsLoadOptions, osLoadOptions);
    CopyMem( &newOsOptions[pNewOsOptions->OsLoadPathOffset], osLoadPath, pOsLoadPath->Length );
    
    *osOptions = newOsOptions;
}

VOID
PackLoadOption(
                 IN UINT32   BootVarNum,
                 IN CHAR16*  LoadIdentifier,
                 IN CHAR16*  OsLoadOptions,
                 IN char*    EfiFilePath,
                 IN UINT16   EfiFilePathListLength,   // 0 if not updated
                 IN char*    OsLoadPath,
                 IN UINT16   OsLoadPathListLength     // 0 if not updated
                 )
/*
    PackLoadOption
     
    Purpose:   To construct an EFI_LOAD_OPTION structure using user arguments
                and load the structure into into BootXXXX, where XXXX = BootVarNum.
                See EFI spec, ch. 17
     
     Args:
     
        BootVarNum      The boot option being written/modified
        
 
*/
{
    PEFI_LOAD_OPTION        pOldElo;
    PEFI_LOAD_OPTION        pElo;
    char*                   elo;
    char*                   oldElo;
    UINT64                  oldEloSize;
    UINT64                  eloSize;
    UINT8*                  oldEloFilePath;
    UINT64                  TempEfiFilePathListSize;
    char*                   aFilePath;
    UINT16                  filePathListLength;
    UINT16                  loadPathListLength;

#if DEBUG_PACK
    
    CHAR16                  szInput[1024];

    Print (L"BootVarNum = %x\n", BootVarNum);
    Print (L"LoadIdentifier = %s\n", LoadIdentifier);
    Print (L"OsLoadOptions = %s\n", OsLoadOptions);

    Input (L"Here! [Pack begin] \n", szInput, sizeof(szInput));
    Print(L"\n");

#endif

    // 
    // The following code assumes EfiFilePath and OsLoadPath are pointer-aligned
    // if the corresponding length exposes an update by the caller.
    // Checking and failing at the function entry avoids unneeded memory allocations.
    //

    if ( EfiFilePathListLength && !POINTER_IS_ALIGNED(EfiFilePath, sizeof(void *)))  {
        ASSERT( POINTER_IS_ALIGNED(EfiFilePath, sizeof(void *)) );
        Print (L"PackLoadOption: EfiFilePath unaligned.\n");
        return;
    }
    if ( OsLoadPathListLength && !POINTER_IS_ALIGNED(OsLoadPath, sizeof(void *)))  {
        ASSERT( POINTER_IS_ALIGNED(OsLoadPath, sizeof(void *)) );
        Print (L"PackLoadOption: OsLoadPath unaligned.\n");
        return;
    }
    
    oldElo = LoadOptions[BootVarNum];
    oldEloSize = LoadOptionsSize[BootVarNum];

#if DEBUG_PACK

    DisplayELO(oldElo, oldEloSize);
    Input (L"Here! [Pack begin] \n", szInput, sizeof(szInput));
    Print(L"\n");

#endif

    //
    // allocate the elo structure with maximal amount of memory allowed for
    // an EFI_LOAD_OPTION
    //
    elo = AllocatePool(MAXBOOTVARSIZE);
    if (elo == NULL) {
        Print (L"PackLoadOption: elo allocation failed. size=%d\n", MAXBOOTVARSIZE);
        return;
    }

    pElo = (EFI_LOAD_OPTION*)elo;
    pOldElo = (EFI_LOAD_OPTION*)oldElo;

    //
    // Efi Attribute.
    //
    eloSize = sizeof(pElo->Attributes);
    pElo->Attributes = pOldElo->Attributes;

    //
    // FilePathListLength
    //
    eloSize += sizeof(pElo->FilePathListLength);
    filePathListLength = EfiFilePathListLength ? EfiFilePathListLength :  
                                                 pOldElo->FilePathListLength;
    pElo->FilePathListLength = filePathListLength;

    //
    // Description.
    //
    StrCpy( pElo->Description, LoadIdentifier );
    eloSize += StrSize(LoadIdentifier);

    if ( EfiFilePathListLength == 0 )  {
        //
        // copy the FilePath from the old/existing ELO structure
        //
        // Note: we don't actually need an aligned filepath block for this
        //      copy, but there may come a time when we want to modify
        //      the filepath, which will require an aligned block.
        //
    
        aFilePath = GetAlignedELOFilePath(oldElo);
    }
    else  {
        // already checked: ASSERT( POINTER_IS_ALIGNED(EfiFilePath, sizeof(void *)) );
        aFilePath = EfiFilePath; 
    }
    CopyMem( &elo[eloSize],
              aFilePath,
              filePathListLength
           );
    eloSize += filePathListLength;
    if ( EfiFilePathListLength == 0 )  {
        FreePool(aFilePath);
    }

#if DEBUG_PACK
    
    Print (L"eloSize = %x\n", eloSize);
    Input (L"Here! \n", szInput, sizeof(szInput));
    Print(L"\n");

#endif

    //
    // add or modify the boot option
    //
    if ( BootVarNum == -1 ) {

        Print(L"Adding currently disabled\n");

    } else {
        
        char*                   osOptions;
        char*                   aOsLoadPath = NULL;
        char*                   aOldOsOptions;
        PWINDOWS_OS_OPTIONS     pOldOsOptions;
        PWINDOWS_OS_OPTIONS     pOsOptions;
        UINTN                   aOsLoadPathSize;

        //
        // OptionalData.
        //
        // For a Windows OS boot option, the OptionalData field in the EFI_LOAD_OPTION
        // structure is a WINDOWS_OS_OPTION structure.

        //
        // get the WINDOWS_OS_OPTIONS from the old/existing boot entry
        //

        aOldOsOptions = GetAlignedOsOptions(oldElo, oldEloSize);
        pOldOsOptions = (WINDOWS_OS_OPTIONS*)aOldOsOptions;

        //
        // Get the LoadPath from the old/existing WINDOWS_OS_OPTIONS structure
        //
        // we need to align the FilePath structure because the load options are
        // variable in length, so the FilePath structure may not be aligned
        //
        if ( OsLoadPathListLength == 0 ) { 
           aOsLoadPath = GetAlignedOsLoadPath(aOldOsOptions, &aOsLoadPathSize);
        }
        else  {
           FILE_PATH *filePath;
           // already checked: ASSERT( POINTER_IS_ALIGNED(OsLoadPath, sizeof(void *)) );
           aOsLoadPath = OsLoadPath;
           filePath = (FILE_PATH *)aOsLoadPath;
           filePath->Length = OsLoadPathListLength;
        }

        FreePool(aOldOsOptions);
                
        //
        // Construct a new WINDOWS_OS_STRUCTURE with the new values
        //

        BuildNewOsOptions(
                         OsLoadOptions,
                         aOsLoadPath,
                         &osOptions
                         );
        
        if ( OsLoadPathListLength == 0 ) { 
            FreePool(aOsLoadPath);
        }
        
#if DEBUG_PACK
        
        Input (L"build\n", szInput, sizeof(szInput) );
        Print(L"\n");

        DisplayOsOptions(osOptions);
        Input (L"elo freed\n", szInput, sizeof(szInput) );
        Print(L"\n");

#endif

        pOsOptions = (WINDOWS_OS_OPTIONS*)osOptions;

        //
        // Copy the new WINDOWS_OS_OPTIONS structure into the new EFI_LOAD_OPTION structure
        //
        
        CopyMem( &elo[eloSize], osOptions, pOsOptions->Length);

        eloSize += pOsOptions->Length;
        
#if DEBUG_PACK
        
        Print (L"osOptions->Length = %x\n", pOsOptions->Length);
        Print (L"eloSize = %x\n", eloSize);
        
#endif

        FreePool(osOptions);

        //
        // Modify current boot options.
        //
        LoadOptions[BootVarNum] = ReallocatePool( LoadOptions[BootVarNum], LoadOptionsSize[BootVarNum], eloSize );
        LoadOptionsSize[BootVarNum] = eloSize;

        CopyMem( LoadOptions[BootVarNum], elo, eloSize );
    }

    FreePool(elo);

    ASSERT(eloSize < MAXBOOTVARSIZE);

#if DEBUG_PACK
    Input (L"elo freed\n", szInput, sizeof(szInput) );
    Print(L"\n");
    Print (L">>\n");
    DisplayELO((char*)LoadOptions[BootVarNum], LoadOptionsSize[BootVarNum]);
    Print (L"<<\n");
    Input (L"pack done\n", szInput, sizeof(szInput) );
    Print(L"\n");
#endif
}

EFI_STATUS
AppendEntryToBootOrder(
    UINT16 BootNumber
    )
{
    EFI_STATUS  status;
    UINT64      oldBootOrderSize;
    UINT64      newBootOrderSize;
    VOID*       newBootOrder;
    VOID*       oldBootOrder;

    newBootOrder = NULL;
    oldBootOrder = NULL;

    //
    // get the existing boot order array
    //
    oldBootOrder = LibGetVariableAndSize( L"BootOrder", &VenEfi, &oldBootOrderSize );
    if ((!oldBootOrder) && 
        (oldBootOrderSize != 0)
        ) {
        Print(L"\nError: Failed to get old boot order array.\n");
        status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    //
    // allocate the new boot order array
    //
    newBootOrderSize = oldBootOrderSize + sizeof(BootNumber);
    newBootOrder = AllocatePool( newBootOrderSize );
    if (! newBootOrder) {
        Print(L"\nError: Failed to allocate new boot order array.\n");
        status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    //
    // append the new boot entry to the bottom of the list
    //
    CopyMem(
           (CHAR8*)newBootOrder, 
           oldBootOrder,
           oldBootOrderSize
           );
    CopyMem(
           (CHAR8*)newBootOrder + oldBootOrderSize, 
           &BootNumber, 
           sizeof(BootNumber) );

    status = SetVariable(
                        L"BootOrder",
                        &VenEfi,
                        EFI_ATTR,
                        newBootOrderSize,
                        newBootOrder
                        );

Done:

    if (oldBootOrder) {
        FreePool( oldBootOrder );
    }
    
    if (newBootOrder) {
        FreePool(newBootOrder);
    }

    return status;

}

EFI_STATUS
WritePackedDataToNvr(
                    UINT16 BootNumber,
                    VOID  *BootOption,
                    UINT32 BootSize
                    )
{
    EFI_STATUS  status;
    CHAR16      VariableName[10];

    //
    // Don't attempt to write the BootEntry if it has no size.
    // 
    if (BootSize == 0) {
        return EFI_SUCCESS;
    }


    SPrint( VariableName, sizeof(VariableName), L"Boot%04x", BootNumber );
    
    status = SetVariable(
                        VariableName,
                        &VenEfi,
                        EFI_ATTR,
                        BootSize,
                        BootOption
                        );
    if (status == EFI_SUCCESS) {
        
        status = AppendEntryToBootOrder(BootNumber);
        if (status != EFI_SUCCESS) {
        
            Print(L"\nError: Failed to append new boot entry to boot order array\n");

            goto Done;

        }

    } else {

        Print(L"\nError: Failed to set new boot entry variable\n");

        goto Done;
    }

    //
    // repopulate the local info about boot entries
    //
    FreeBootManagerVars();
    GetBootManagerVars();

Done:

    return status;

}

#if DEBUG_PACK
VOID
DisplayELOFromLoadOption(
    IN UINT32 OptionNum
    )
{
    char*               elo;
    PEFI_LOAD_OPTION    pElo;

    //
    // Make sure it is a valid OS load option
    //
    if (OptionNum >= BootOrderCount) {
        return;
    }
    if (OptionNum >= MAXBOOTVARS) {
        return;
    }
    if (LoadOptions[OptionNum] == NULL) {
        return;
    }

    pElo = (EFI_LOAD_OPTION*)LoadOptions[OptionNum];
    elo  = (char*)LoadOptions[OptionNum];

    DisplayELO(elo, LoadOptionsSize[OptionNum]);

}
#endif

VOID
GetFieldFromLoadOption(
                      IN UINT32 OptionNum,
                      IN UINT32 FieldType,
                      OUT VOID* Data,
                      OUT UINT64* DataSize
                      )
{
    char*               elo;
    PEFI_LOAD_OPTION    pElo;

    //
    // Make sure it is a valid OS load option
    //
    if (OptionNum >= BootOrderCount) {
        return;
    }
    if (OptionNum >= MAXBOOTVARS) {
        return;
    }
    if (LoadOptions[OptionNum] == NULL) {
        *DataSize = 0;
        return;
    }

    pElo = (EFI_LOAD_OPTION*)LoadOptions[OptionNum];
    elo  = (char*)LoadOptions[OptionNum];

    switch ( FieldType ) {
    
    case ATTRIBUTE: {

            *((UINT32*) Data) = pElo->Attributes;
            *DataSize = sizeof(UINT32);

            break;
        }
    case FILEPATHLISTLENGTH: {

            *((UINT16*) Data) = pElo->FilePathListLength;
            *DataSize = sizeof(UINT16);

            break;
        }
    case DESCRIPTION: {

            StrCpy((CHAR16*)Data, pElo->Description);
            *DataSize = StrSize(pElo->Description);

            break;
        }
    case EFIFILEPATHLIST: {

            char*       aFilePath;

            aFilePath = GetAlignedELOFilePath(elo);

            CopyMem(Data, 
                    aFilePath,
                    pElo->FilePathListLength
                   );

            FreePool(aFilePath);

            *DataSize = pElo->FilePathListLength;

            break;
        }
    case OPTIONALDATA: {

            char*           aOptionalData;
            UINT64          eloSize;

            eloSize = LoadOptionsSize[OptionNum];

            aOptionalData = GetAlignedOptionalData(elo, 
                                                   eloSize,
                                                   DataSize
                                                   );

            CopyMem(Data, aOptionalData, *DataSize);

            FreePool(aOptionalData);

            break;

        }
    default:

        *DataSize = 0;

        break;
    }
}

BOOLEAN
GetLoadIdentifier(
                 IN UINT32 BootVarNum,
                 OUT CHAR16* LoadIdentifier
                 )
{
    UINT64 DataSize = 0;

    GetFieldFromLoadOption(
                          BootVarNum,
                          DESCRIPTION,
                          LoadIdentifier,
                          &DataSize
                          );
    if (!DataSize)
        return FALSE;
    return TRUE;
}

VOID
GetEfiOsLoaderFilePath(
           IN UINT32 BootVarNum,
           OUT char* FilePath
           )
{
    UINT64 DataSize = 0;

    GetFieldFromLoadOption(
                          BootVarNum,
                          EFIFILEPATHLIST,
                          FilePath,
                          &DataSize
                          );
}

BOOLEAN
GetOsLoadOptionVars(
                   IN      UINT32 BootVarNum,
                   OUT     CHAR16* LoadIdentifier,
                   OUT     char* OsLoadOptions,
                   OUT     char* EfiFilePath,
                   OUT     char* OsLoadPath
                   )
{
    if (BootVarNum >= BootOrderCount)
        return FALSE;
    if (BootVarNum >= MAXBOOTVARS) {
        return FALSE;
    }
    if (!LoadOptions[BootVarNum])
        return FALSE;


    GetLoadIdentifier( BootVarNum, LoadIdentifier );

    GetOptionalDataValue( BootVarNum, OSLOADOPTIONS,    OsLoadOptions );
    
    GetEfiOsLoaderFilePath( BootVarNum, EfiFilePath );

    GetOptionalDataValue( BootVarNum, OSLOADPATH, OsLoadPath);

    return TRUE;
}

VOID
GetOptionalDataValue(
                    IN UINT32 BootVarNum,
                    IN UINT32 Selection,
                    OUT char* OptionalDataValue
                    )
{
    char                osOptions[MAXBOOTVARSIZE];
    UINT64              osOptionsSize;
    PWINDOWS_OS_OPTIONS pOsOptions;

    if (BootVarNum < MAXBOOTVARS) {

        GetFieldFromLoadOption(
                              BootVarNum,
                              OPTIONALDATA,
                              osOptions,
                              &osOptionsSize
                              );

        pOsOptions = (PWINDOWS_OS_OPTIONS)osOptions;

        switch (Selection) {
        case OSLOADOPTIONS: {

                StrCpy( (CHAR16*)OptionalDataValue, pOsOptions->OsLoadOptions );

                break;
            }

        case OSLOADPATH: {
            
                char*               aOsLoadPath;
                UINTN               aOsLoadPathSize;

                aOsLoadPath = GetAlignedOsLoadPath(osOptions, &aOsLoadPathSize);

                CopyMem(OptionalDataValue,
                        aOsLoadPath,
                        aOsLoadPathSize
                        );

                FreePool(aOsLoadPath);

                break;
            }

        default: {

                break;

            }
        }
    }
}

UINTN
GetDevPathSize(
              IN EFI_DEVICE_PATH *DevPath
              )
{
    EFI_DEVICE_PATH *Start;

ASSERT(DevPath->Type != END_DEVICE_PATH_TYPE);

    //
    // Search for the end of the device path structure
    //
    Start = DevPath;
    do  {
        DevPath = NextDevicePathNode(DevPath);
    } while (DevPath->Type != END_DEVICE_PATH_TYPE);

    //
    // Compute the size
    //
    return(UINTN) ((UINT64) DevPath - (UINT64) Start);
}

UINT32
GetPartitions(
             )
{

    EFI_HANDLE EspHandles[100],FSPath;
    UINT64 HandleArraySize = 100 * sizeof(EFI_HANDLE);
    UINT64 CachedDevicePaths[100];
    UINTN i, j;
    UINTN CachedDevicePathsCount;
    UINT64 SystemPartitionPathSize;
    EFI_DEVICE_PATH *dp;
    EFI_STATUS Status;
    UINT32 PartitionCount;
    char AlignedNode[1024];

    //
    // Get all handles that supports the block I/O protocol.
    //
    ZeroMem( EspHandles, HandleArraySize );

    Status = LocateHandle (
                          ByProtocol,
                          &EfiESPProtocol,
                          0,
                          (UINTN *) &HandleArraySize,
                          EspHandles
                          );

    //
    // Cache all of the EFI Device Paths.
    //
    for (i = 0; EspHandles[i] != 0; i++) {

        Status = HandleProtocol (
                                EspHandles[i],
                                &DevicePathProtocol,
                                &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                                );
    }

    //
    // Save the number of cached Device Paths.
    //
    CachedDevicePathsCount = i;
    PartitionCount = 0;

    //
    // Find the first partition on the first hard drive
    // partition. That is our SystemPartition.
    //
    for ( i=0; i<CachedDevicePathsCount; i++ ) {

        dp = (EFI_DEVICE_PATH*) CachedDevicePaths[i];

        while (( DevicePathType(dp)    != END_DEVICE_PATH_TYPE ) &&
               ( DevicePathSubType(dp) != END_ENTIRE_DEVICE_PATH_SUBTYPE )) {

            if (( DevicePathType(dp)    == MEDIA_DEVICE_PATH ) &&
                ( DevicePathSubType(dp) == MEDIA_HARDDRIVE_DP )) {
                CopyMem( AlignedNode, dp, DevicePathNodeLength(dp) );

                HandleProtocol (EspHandles[i],&FileSystemProtocol,&FSPath);
                if ( FSPath != NULL) {
                    PartitionCount++;
                }
            }
            dp = NextDevicePathNode(dp);
        }
    }

    return PartitionCount;
}

EFI_HANDLE
GetDeviceHandleForPartition(
                           )
{
    EFI_HANDLE EspHandles[100],FSPath;
    UINT64 HandleArraySize = 100 * sizeof(EFI_HANDLE);
    UINT64 CachedDevicePaths[100];
    UINTN i, j;
    UINTN CachedDevicePathsCount;
    UINT64 SystemPartitionPathSize;
    EFI_DEVICE_PATH *dp;
    EFI_STATUS Status;
    char AlignedNode[1024];

    //
    // Get all handles that supports the block I/O protocol.
    //
    ZeroMem( EspHandles, HandleArraySize );

    Status = LocateHandle (
                          ByProtocol,
                          &EfiESPProtocol,
                          0,
                          (UINTN *) &HandleArraySize,
                          EspHandles
                          );

    //
    // Cache all of the EFI Device Paths.
    //
    for (i = 0; EspHandles[i] != 0; i++) {

        Status = HandleProtocol (
                                EspHandles[i],
                                &DevicePathProtocol,
                                &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                                );
    }

    //
    // Save the number of cached Device Paths.
    //
    CachedDevicePathsCount = i;

    //
    // Find the first ESP partition on the first hard drive
    // partition. That is our SystemPartition.
    //
    for ( i=0; i<CachedDevicePathsCount; i++ ) {

        dp = (EFI_DEVICE_PATH*) CachedDevicePaths[i];

        while (( DevicePathType(dp)    != END_DEVICE_PATH_TYPE ) &&
               ( DevicePathSubType(dp) != END_ENTIRE_DEVICE_PATH_SUBTYPE )) {

            if (( DevicePathType(dp)    == MEDIA_DEVICE_PATH ) &&
                ( DevicePathSubType(dp) == MEDIA_HARDDRIVE_DP )) {
                CopyMem( AlignedNode, dp, DevicePathNodeLength(dp) );

                HandleProtocol (EspHandles[i],&FileSystemProtocol,&FSPath);
                if ( FSPath != NULL) {
                    //
                    // Found the correct device path partition. 
                    // Return the device handle.
                    //
                    return( EspHandles[i] );

                }
            }

            dp = NextDevicePathNode(dp);
        }
    }

    return NULL;
}

/*
** BUGBUG: These functions need to be eventually placed in lib\str.c
*/
INTN
RUNTIMEFUNCTION
StrCmpA (
        IN CHAR8   *s1,
        IN CHAR8   *s2
        )
/*  compare strings */
{
    while (*s1) {
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
        s2 += 1;
    }

    return *s1 - *s2;
}

VOID
RUNTIMEFUNCTION
StrCpyA (
        IN CHAR8   *Dest,
        IN CHAR8   *Src
        )
/*  copy strings */
{
    while (*Src) {
        *(Dest++) = *(Src++);
    }
    *Dest = 0;
}

VOID
RUNTIMEFUNCTION
StrCatA (
        IN CHAR8   *Dest,
        IN CHAR8   *Src
        )
{   
    StrCpyA(Dest+StrLenA(Dest), Src);
}

UINTN
RUNTIMEFUNCTION
StrLenA (
        IN CHAR8   *s1
        )
/*  string length */
{
    UINTN        len;

    for (len=0; *s1; s1+=1, len+=1) ;
    return len;
}

UINTN
RUNTIMEFUNCTION
StrSizeA (
         IN CHAR8   *s1
         )
/*  string size */
{
    UINTN        len;

    for (len=0; *s1; s1+=1, len+=1) ;
    return(len + 1) * sizeof(CHAR8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\protocol.h ===
/*++

Module Name:

    protocol.h

Abstract:

    

Author:

    Mudit Vats (v-muditv) 12-13-99

Revision History:

--*/

void
InitializeProtocols(
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efinvram\savrstor.h ===
/*++

Module Name:

    savrstor.h

Abstract:

    Prototypes for routines to save/restore boot options
    defined in savrstor.c

Author:

Revision History:

++*/

INTN
SaveNvr (
   VOID
   );

INTN
SaveAllBootOptions (
    CHAR16*     fileName
    );

INTN
SaveBootOption (
    CHAR16*         fileName,
    UINT64          bootEntryNumber
    );

BOOLEAN
RestoreFileExists(
    CHAR16*     fileName
    );

INTN
RestoreNvr (
    CHAR16*     fileName
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\hello\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\hello.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\launcher\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\launcher.obj \
     $(O)\launcher.res

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib
        

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OBJS) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\launcher\launcher.c ===
#include <efi.h>
#include <efilib.h>


//
// Prototype
//
void ParseArgs (EFI_LOADED_IMAGE *ImageHdl);
void Launch (CHAR16 *exePath);
EFI_STATUS OpenCreateFile (UINT64 OCFlags,EFI_FILE_HANDLE *StartHdl,CHAR16 *FileName);
void ParseBootFile (EFI_FILE_HANDLE BootFile);
void PopulateStartFile (EFI_FILE_HANDLE StartFile);
void TrimNonPrint(CHAR16 * str);
CHAR16 * __cdecl mystrstr (const CHAR16 * str1,const CHAR16 * str2);
CHAR16 * ParseLine (CHAR16 *optCopy);

//
//Globals
//
EFI_HANDLE ExeHdl;
EFI_LOADED_IMAGE *ExeImage;

//
// Defines
//
#define REGISTER1 L"*register"
#define REGISTER2 L"*register*"
#define STARTFILE L"startup.nsh"
#define BOOTOFILE L"boot.nvr"
#define OSLOADOPT L"OSLOADER"
#define PARTENT   L"partition"
#define PARTENTRE L"*partition*"


EFI_STATUS
EfiMain (    IN EFI_HANDLE           ImageHandle,
             IN EFI_SYSTEM_TABLE     *SystemTable)
{

	EFI_STATUS Status;
	EFI_FILE_HANDLE bootFile;


	InitializeLib (ImageHandle, SystemTable);
	
	ExeHdl = ImageHandle;
	BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, &ExeImage);

	ParseArgs(ExeImage);

	//
	// Read the bootfile
	//


	Status = OpenCreateFile (EFI_FILE_MODE_READ,&bootFile,BOOTOFILE);

	ParseBootFile (bootFile);

	//
	// If we get here, we failed to load the OS
	//
	return EFI_SUCCESS;
}

void
ParseArgs (EFI_LOADED_IMAGE *ImageInfo)
{
	BOOLEAN optFound;
	EFI_STATUS Status;
	EFI_FILE_HANDLE startFile;

	if (MetaiMatch (ImageInfo->LoadOptions,REGISTER1) ||
		MetaiMatch (ImageInfo->LoadOptions,REGISTER2)) {

		Status = OpenCreateFile (EFI_FILE_MODE_WRITE|EFI_FILE_MODE_CREATE,&startFile,STARTFILE);
		
		if (!(EFI_ERROR (Status))) {
	
			PopulateStartFile (startFile);
			BS->Exit (ExeHdl,EFI_SUCCESS,0,NULL);
		}
	}
}
void
Launch (CHAR16 *exePath)
{
	EFI_HANDLE exeHdl=NULL;
	UINTN i;
	EFI_DEVICE_PATH *ldrDevPath;
	EFI_STATUS 	Status;
    EFI_FILE_IO_INTERFACE   *Vol;
	EFI_FILE_HANDLE         RootFs;
	EFI_FILE_HANDLE         CurDir;
	EFI_FILE_HANDLE         FileHandle;
	CHAR16                  FileName[100],*DevicePathAsString;

	
    //
    // Open the volume for the device where the exe was loaded from.
    //
    Status = BS->HandleProtocol (ExeImage->DeviceHandle,
                                 &FileSystemProtocol,
                                 &Vol
                                 );

    if (EFI_ERROR(Status)) {
        Print(L"Can not get a FileSystem handle for ExeImage->DeviceHandle\n");
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }	
	Status = Vol->OpenVolume (Vol, &RootFs);
	
	if (EFI_ERROR(Status)) {
		Print(L"Can not open the volume for the file system\n");
		 BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	
	CurDir = RootFs;
	
	//
	// Open the file relative to the root.
	//
	
	DevicePathAsString = DevicePathToStr(ExeImage->FilePath);
	
	if (DevicePathAsString!=NULL) {
		StrCpy(FileName,DevicePathAsString);
		FreePool(DevicePathAsString);
	}

	FileName[0] = 0;
	StrCat(FileName,exePath);

//    size = StrLen(FileName);
//    Print(L"Length of filename is %d\n", size);
//    DumpHex(4, 0, 10, &FileName[size - 4]);

    //
    // Get rid of trailing spaces, new lines, whatever
    //
    TrimNonPrint(FileName);


	Status = CurDir->Open (CurDir,
						&FileHandle,
						FileName,
						EFI_FILE_MODE_READ,
						0
						);
	
	if (EFI_ERROR(Status)) {
		Print(L"Can not open the file ->%s<-, error was %X\n",FileName, Status);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	} else {
//		Print(L"Opened %s\n",FileName);
	}

	ldrDevPath  = FileDevicePath (ExeImage->DeviceHandle,FileName);

/*
	if (ldrDevPath) {
		Print (L"Type: %d\nSub-Type: %d\nLength[0][1]: [%d][%d]\n",ldrDevPath->Type,
			ldrDevPath->SubType,ldrDevPath->Length[0],ldrDevPath->Length[1]);
	}else {
		Print (L"bad dev path\n");
	}
*/
//	DumpHex (4,0,ldrDevPath->Length[0],ldrDevPath);

	Status = BS->LoadImage (FALSE,ExeHdl,ldrDevPath,NULL,0,&exeHdl);
	if (!(EFI_ERROR (Status))) {
//		Print (L"Image loaded!\n");
	
	}else {
		Print (L"Load Error: %X\n",Status);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	FreePool (ldrDevPath);

	BS->StartImage (exeHdl,&i,NULL);

	return;
}

EFI_STATUS
OpenCreateFile (UINT64 OCFlags,EFI_FILE_HANDLE *StartHdl,CHAR16 *Name)
{
    EFI_FILE_IO_INTERFACE   *Vol;
    EFI_FILE_HANDLE         RootFs;
    EFI_FILE_HANDLE         CurDir;
    EFI_FILE_HANDLE         FileHandle;
    CHAR16                  FileName[100],*DevicePathAsString;
    UINTN                   i;
	EFI_STATUS 				Status;

    //
    // Open the volume for the device where the EFI OS Loader was loaded from.
    //

    Status = BS->HandleProtocol (ExeImage->DeviceHandle,
                                 &FileSystemProtocol,
                                 &Vol
                                 );

    if (EFI_ERROR(Status)) {
        Print(L"Can not get a FileSystem handle for %s DeviceHandle\n",ExeImage->FilePath);
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }

    Status = Vol->OpenVolume (Vol, &RootFs);

    if (EFI_ERROR(Status)) {
        Print(L"Can not open the volume for the file system\n");
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }

    CurDir = RootFs;

    //
    // Open the startup options file in the same path as the launcher
    //

    DevicePathAsString = DevicePathToStr(ExeImage->FilePath);
    if (DevicePathAsString!=NULL) {
        StrCpy(FileName,DevicePathAsString);
        FreePool(DevicePathAsString);
    }
    for(i=StrLen(FileName);i>0 && FileName[i]!='\\';i--);
    FileName[i] = 0;
    StrCat(FileName,Name);

    Status = CurDir->Open (CurDir,
                           &FileHandle,
                           FileName,
                           OCFlags,
                           0
                           );

    if (EFI_ERROR(Status)) {
        Print(L"Can not open the file %s\n",FileName);
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }

	*StartHdl=FileHandle;

//    Print(L"Opened %s\n",FileName);


	return Status;
}


void ParseBootFile (EFI_FILE_HANDLE BootFile)
{
	EFI_STATUS Status;
	char *buffer,*t;
	CHAR16 *uniBuf,*optBegin,*optEnd,*optCopy;
	UINTN i,size;
	EFI_FILE_INFO *bootInfo;


	size= SIZE_OF_EFI_FILE_INFO+255*sizeof (CHAR16);
	
	bootInfo = AllocatePool (size);

	if (bootInfo == NULL) {
		Print (L"Failed to allocate memory for File Info buffer!\n");
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	
	Status = BootFile->GetInfo(BootFile,&GenericFileInfo,&size,bootInfo);

	size=(UINTN) bootInfo->FileSize;
	
	FreePool (bootInfo);

	buffer = AllocatePool ((size+1));

	if (buffer == NULL) {
		Print (L"Failed to allocate memory for File buffer!\n");
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}

	Status = BootFile->Read(BootFile,&size,buffer);
    	
    BootFile->Close (BootFile);
	
	if (EFI_ERROR (Status)) {
		Print (L"Failed to read bootfile!\n");
		FreePool (buffer);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}


	//
	// allocate FileSize's space worth of unicode chars.
	// (the file is in ASCII)
	//
	uniBuf = AllocateZeroPool ((size+1) * sizeof (CHAR16));

	if (uniBuf == NULL) {
		Print (L"Failed to allocate memory for Unicode buffer!\n");
		FreePool (buffer);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}

	t=(char *)uniBuf;

	//
	// Convert the buffer to a hacked unicode.
	//
	for (i=0;i<size;i++) {
		*(t+i*2)=*(buffer+i);
	}

	//
	//find the option we care about
	//
	optBegin = mystrstr (uniBuf,OSLOADOPT);

	//
	// find the end
	//

	optEnd = optBegin;
	while (*(optEnd++) != '\n');

	optCopy = AllocateZeroPool (((optEnd-optBegin)+2)*sizeof (CHAR16));


	if (optCopy == NULL) {
		Print (L"Failed to allocate memory for Unicode buffer!\n");
		FreePool (buffer);
		FreePool (uniBuf);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	
	CopyMem (optCopy,optBegin,(optEnd-optBegin)*sizeof (CHAR16));
	
//	Print (L"copied to unicode:%d bytes\n%lX\n%lX\n%s\n",(optEnd-optBegin)*sizeof(CHAR16),optEnd,optBegin,optCopy);

	FreePool (uniBuf);
	FreePool (buffer);

	//
	// re-using uniBuf;
	//
	uniBuf=optBegin=optCopy;

	uniBuf =ParseLine (optCopy);
#if 0
	do {
		uniBuf = mystrstr (uniBuf,PARTENT);
		if (uniBuf) {
			uniBuf+= StrLen (PARTENT);
			optBegin = uniBuf;
		}

	} while ( uniBuf );

	//
	// optBegin points to the last partition(n) value
	//
	while (*(optBegin++) != ')');

	optEnd = ++optBegin;

	while ((*optEnd != ';') && (*optEnd != '\n')) {
		optEnd++;
	}


	uniBuf = AllocateZeroPool (((optEnd-optBegin)+1)*sizeof (CHAR16));
	CopyMem (uniBuf,optBegin,(optEnd-optBegin)*sizeof (CHAR16));
#endif


    Print (L"Will launch... %s\n",uniBuf);
    Print (L"\nPress any key to abort autoload\n");
    Status = WaitForSingleEvent (ST->ConIn->WaitForKey,5*10000000);

    if (Status != EFI_TIMEOUT){
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }



	Launch (uniBuf);

	FreePool (optCopy);

}

//
// fill out startup.nsh with the name of this program
//
void PopulateStartFile (EFI_FILE_HANDLE StartFile)
{

	CHAR16 *NameBuf;
	EFI_STATUS Status;
	UINTN i,size;
	EFI_FILE_INFO *bootInfo;
	CHAR16 UnicodeMarker = UNICODE_BYTE_ORDER_MARK;
	
	size= SIZE_OF_EFI_FILE_INFO+255*sizeof (CHAR16);
	
	bootInfo = AllocatePool (size);
	
	if (bootInfo == NULL) {
		Print (L"Failed to allocate memory for File Info buffer!\n");
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	


    size = sizeof(UnicodeMarker);
	StartFile->Write(StartFile, &size, &UnicodeMarker);
	NameBuf=DevicePathToStr (ExeImage->FilePath);

	while (*(++NameBuf) != '\\');
	
	//
	// take off 4 for the '.efi' extension, which hangs the shell!!!!!
	//
	size= (StrLen (NameBuf)+2)*sizeof (CHAR16);
	
	StartFile->Write (StartFile,&size,NameBuf);

	size = sizeof (CHAR16);

	StartFile->Write (StartFile,&size,&L"\n");

	StartFile->Close (StartFile);

	FreePool (bootInfo);
	
}

CHAR16*
ParseLine (CHAR16 *optCopy)
{
	EFI_STATUS Status;
	UINTN i,len,count=0;
    CHAR16 *p;

//	Print (L"ParseLine: working on %s\n",optCopy);

	len=StrLen (optCopy);
	
	//
	// Figure out how many tokens there are in the option line
	// it will be: TOKENNAME=a;b;c
	// (watch for a;b;c;)
	//
	for (i=0;i<len-1;i++) {
		if (*(optCopy+i) == ';') {
			count++;
		}
	}
	while (*(++optCopy) != '=');

	//
    // strip the arc info
    //
    while (*(++optCopy) != '\\');

    p = ++optCopy;

	
    while (*optCopy != '\0' && *optCopy !=  ';') {
        optCopy++;
    }

    *optCopy='\0';

    return (p);

}


/***
*CHAR16 *mystrstr(string1, string2) - search for string2 in string1
*
*Purpose:
*	finds the first occurrence of string2 in string1
*
*Entry:
*	CHAR16 *string1 - string to search in
*	CHAR16 *string2 - string to search for
*
*Exit:
*	returns a pointer to the first occurrence of string2 in
*	string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

CHAR16 * __cdecl mystrstr (
	const CHAR16 * str1,
	const CHAR16 * str2
	)
{
	CHAR16 *cp = (CHAR16 *) str1;
	CHAR16 *s1, *s2;

	if ( !*str2 )
	    return((CHAR16 *)str1);

	while (*cp)
	{
		s1 = cp;
		s2 = (CHAR16 *) str2;

		while ( *s1 && *s2 && !(*s1-*s2) )
			s1++, s2++;

		if (!*s2)
			return(cp);

		cp++;
	}

	return(NULL);

}

void
TrimNonPrint(
	CHAR16 * str
)
{
	INTN i,size;


    if ((NULL == str) || (L'\0' == *str)) {
        return;
    }

    size = (INTN) StrLen(str);

//    Print(L"Size is %d\n", size);
//    DumpHex(4, 0, 2, &str[size]);

    for (i = size; i > 0; i--) {

        if (str[i] <= 0x20) {
            str[i] = L'\0';
        }
        else {
            // Leave when we hit a legit character
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\efildrimage\efildrimage.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efildrimage.c
    
Abstract:

    Creates and EFILDR image



Revision History

--*/


#include "windows.h"
#include "stdio.h"
#include "efi.h"

#define MAX_PE_IMAGES                  63
#define FILE_TYPE_FIXED_LOADER         0
#define FILE_TYPE_RELOCATABLE_PE_IMAGE 1

typedef struct {
    UINT32 CheckSum;
    UINT32 Offset;
    UINT32 Length;
    UINT8  FileName[52];
} EFILDR_IMAGE;

typedef struct {          
    UINT32       Signature;     
    UINT32       HeaderCheckSum;
    UINT32       FileLength;
    UINT32       NumberOfImages;
} EFILDR_HEADER;



VOID
Usage (
    VOID
    )
{
    printf ("Usage: EfiLdrImage OutImage LoaderImage PeImage1 PeImage2 ... PeImageN");
    exit (1);
}

ULONG
FCopyFile (
    FILE    *in,
    FILE    *out
    )
{
    ULONG           filesize, offset, length;
    UCHAR           Buffer[8*1024];

    fseek (in, 0, SEEK_END);
    filesize = ftell(in);

    fseek (in, 0, SEEK_SET);

    offset = 0;
    while (offset < filesize)  {
        length = sizeof(Buffer);
        if (filesize-offset < length) {
            length = filesize-offset;
        }

        fread (Buffer, length, 1, in);
        fwrite (Buffer, length, 1, out);
        offset += length;
    }

    return(filesize);
}


int
main (
    int argc,
    char *argv[]
    )
/*++

Routine Description:


Arguments:


Returns:


--*/
{
    ULONG         i;
    ULONG         filesize;
    FILE          *fpIn, *fpOut;
    EFILDR_HEADER EfiLdrHeader;
    EFILDR_IMAGE  EfiLdrImage[MAX_PE_IMAGES];

    if (argc < 4) {
        Usage();
    }

    memset(&EfiLdrHeader,0,sizeof(EfiLdrHeader));
    strcpy((UCHAR *)(&EfiLdrHeader.Signature),"EFIL");

    /* 
     *  open output file
     */

    fpOut = fopen(argv[1], "w+b");
    if (!fpOut) {
        printf ("efildrimage: Could not open output file %s\n", argv[1]);
    exit(1);
    }
    fseek (fpOut, 0, SEEK_SET);
    fwrite (&EfiLdrHeader, sizeof(EFILDR_HEADER)        , 1, fpOut);
    fwrite (&EfiLdrImage , sizeof(EFILDR_IMAGE)*(argc-2), 1, fpOut);


    EfiLdrHeader.FileLength = sizeof(EFILDR_HEADER) + sizeof(EFILDR_IMAGE)*(argc-2);

    /* 
     *  copy all the input files to the output file
     */

    for(i=2;i<(ULONG)argc;i++) {
        
        /* 
         *  open a PeImage file
         */

        fpIn = fopen (argv[i], "rb");
        if (!fpIn) {
            printf ("efildrimage: Could not open input file %s\n", argv[i-2]);
        exit(1);
        }

        /* 
         *  Copy the file
         */

        filesize = FCopyFile (fpIn, fpOut);

        EfiLdrImage[i-2].Offset = EfiLdrHeader.FileLength;
        EfiLdrImage[i-2].Length = filesize;
        strcpy(EfiLdrImage[i-2].FileName,argv[i]);
        EfiLdrHeader.FileLength += filesize;
        EfiLdrHeader.NumberOfImages++;

        /* 
         *  Close the PeImage file
         */

        fclose(fpIn);
    }

    /* 
     *  Write the image header to the output file
     */

    fseek (fpOut, 0, SEEK_SET);
    fwrite (&EfiLdrHeader, sizeof(EFILDR_HEADER)        , 1, fpOut);
    fwrite (&EfiLdrImage , sizeof(EFILDR_IMAGE)*(argc-2), 1, fpOut);

    /* 
     *  Close the OutImage file
     */

    fclose(fpOut);

    printf ("Created %s\n", argv[1]);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\col\col.c ===
#include <stdio.h>
#include <windows.h>


FILE                    *FpIn, *FpOut;
WIN32_FIND_DATA         FileData;
BOOLEAN                 UpdateFile = FALSE;
UCHAR                   DirName[1000];


VOID
ProcessDir (
    VOID
    );

VOID
ProcessFile (
    PCHAR       filename
    );


/* 
 * 
 */


int
main (
    int     argc,
    char    *argv[]
    )
{
    UpdateFile = TRUE;
    DirName[0] = 0;
    ProcessDir ();
    return 0;
}


VOID
ProcessDir ()
{
    HANDLE      h;
    int         len;
    int         dirnamelen;

    dirnamelen = strlen(DirName);

    /* 
     *  Enumerate files
     */

    h = FindFirstFile ("*", &FileData);
    if (h == INVALID_HANDLE_VALUE) {
         return ;
    }

    do {
        /*  must be a .c or .h file */
        len = strlen (FileData.cFileName);
        if (len > 3 && FileData.cFileName[len-2] == '.'  &&
            (FileData.cFileName[len-1] == 'c' || FileData.cFileName[len-1] == 'C' ||
            FileData.cFileName[len-1] == 'h' || FileData.cFileName[len-1] == 'H')) {

            /*  Check the file */
            ProcessFile (FileData.cFileName);
        }

    } while (FindNextFile (h, &FileData)) ;
    FindClose (h);


    /* 
     *  Process directories
     */
    h = FindFirstFile ("*", &FileData);
    do {
        /*  must be a directory */
        if (FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (strcmp (FileData.cFileName, ".") && strcmp (FileData.cFileName, "..")) {
                /*  put entry in the directory list */
                if (SetCurrentDirectory (FileData.cFileName)) {
                    sprintf (DirName+dirnamelen, "%s\\", FileData.cFileName);
                    ProcessDir ();
                    DirName[dirnamelen] = 0;
                    SetCurrentDirectory ("..");
                }
            }
        }
    } while (FindNextFile (h, &FileData)) ;
    FindClose (h);
}

VOID
ProcessFile (
    PCHAR       filename
    )
{    
    int         c, i, len, col, line;
    char        tmpname[512], oldname[512];
    BOOLEAN     error;


    printf ("Checking %s%-13s\t", DirName, filename);
    FpIn = fopen (filename, "r");
    if (!FpIn) {
        printf ("*open error*\n");
        return ;
    }

    while ( (c = fgetc (FpIn)) != EOF) {
        if (c == '\t') {
            printf ("TAB\t");
            break;
        }
    }

    if (!UpdateFile || c != '\t') {
        printf ("\n");
        return ;
    }

    /* 
     *  reset input file
     */

    fclose (FpIn);

    strcpy (tmpname, filename);
    strcpy (oldname, filename);
    len = strlen(tmpname);
    strcpy (tmpname+len-1, "ntb");
    strcpy (oldname+len-1, "old");

    FpIn = fopen (filename, "r");
    FpOut = fopen (tmpname, "w+");
    error = FALSE;
    line = 0;
    col = 0;
    while ( (c = fgetc (FpIn)) != EOF) {
        if (c < ' ') {
            switch (c) {
            case '\r':
                fputc (c, FpOut);
                col = 0;
                break;

            case '\n':
                fputc (c, FpOut);
                line = line + 1;
                col = 0;
                break;

            case '\t':
                for (i = 4 - (col % 4); i; i--) {
                    fputc(' ', FpOut);
                    col = col + 1;
                }
                break;

            default:
                printf ("unkown code %x\n", c);
                error = TRUE;
                goto Done;
            }
        } else {
            fputc (c, FpOut);
            col = col + 1;
        }
    }

Done:
    fclose (FpIn);
    fclose (FpOut);

    if (!error) {
        _unlink (oldname);
        rename (filename, oldname);
        rename (tmpname, filename);
        printf ("updated");
    }

    printf ("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\genmake\genmake.c ===
#include <stdio.h>
#include <stdlib.h>
#include <direct.h>
#include <windows.h>

#include "efi.h"

#define EFI_NT_EMUL
#include "efilib.h"

#define MAX_FILE_NAME   500

UCHAR   BuildDir[MAX_FILE_NAME];        /*  e.g. ..\build\ntdbg */
PUCHAR  EfiSource;                      /*  e.g. d:\source\efi (with or without drive letter) */
PUCHAR  BuildPath;                      /*  from EfiSource (e.g. build\ntdbg) */

typedef struct {
    LIST_ENTRY      Link;
    PUCHAR          ProcDir;
    UCHAR           Filename[1];        /*  without extension */
} A_FILE;

typedef struct {
    LIST_ENTRY      Link;
    UCHAR           Line[1];
} A_LINE;

typedef struct {
    LIST_ENTRY      C;                  /*  C files */
    LIST_ENTRY      S;                  /*  S files IA64 EM code */
    LIST_ENTRY      A;                  /*  Asm files */
    LIST_ENTRY      H;                  /*  H files */
    LIST_ENTRY      INC;                /*  INC files */
} FILE_LIST;

typedef struct {
    FILE_LIST       Comm;               /*  Common files */
    FILE_LIST       Ia32;               /*  Ia32 files */
    FILE_LIST       Ia64;               /*  Ia64 files */
    LIST_ENTRY      Includes;
    LIST_ENTRY      Libraries;
    LIST_ENTRY      NMake;
} MAKE_INFO;


/* 
 * 
 */

VOID
Init (
    VOID
    );

VOID
Done (
    VOID
    );

VOID
ProcessDir (
    IN ULONG    NameIndex,
    IN ULONG    DirLevel    
    );

VOID
ProcessMakeInfo (
    IN PCHAR    DirName,
    IN ULONG    DirLevel
    );


/* 
 * 
 */


int
main (
    int     argc,
    char    *argv[]
    )
{
    Init ();
    ProcessDir (0, 1);
    Done ();
    return 0;
}

VOID
Done (
    VOID
    )
{
    FILE    *fp;
    UCHAR   FileName[MAX_FILE_NAME];

    sprintf (FileName, "%s\\output\\makedone", BuildDir);
    fp = fopen (FileName, "w+");
    if (!fp) {
        printf ("Failed to create %s\n", FileName);
        _getcwd(BuildDir, sizeof(BuildDir));
        printf ("cwd %s\n", BuildDir);
        exit (1);
    }
    fclose (fp);

    sprintf (FileName, "%s\\bin", BuildDir);
    _mkdir (FileName);

    printf ("Make files generated\n");
}


VOID
Init (
    VOID
    )
{
    FILE        *Fp;
    BOOLEAN     f;
    char        *pDest;
    int         result;

    /*  Verify we are at a build point */
    Fp = fopen ("master.mak", "r");
    if (!Fp) {
        printf ("genmak not run from build point\n");
        exit (1);
    }
    fclose (Fp);

    /*  Get the current directory and EFI_SOURCE root */
    EfiSource = getenv("EFI_SOURCE");
    if (!EfiSource) {
        printf ("EFI_SOURCE enviroment variable not set\n");
        exit (1);
    }

    /*  _getcwd returns with drive letter */
    _getcwd(BuildDir, sizeof(BuildDir));

    /*  if EfiSource has drive letter, then we can index into
     *  builddir array with strlen of efisource
     *  if EfiSource doesn't have drive letter, then strip the
     *  drive letter from builddir as well, so that we can
     *  index to efisource properly to get buildpath */
    result = 0;
    pDest = strchr(EfiSource, ':');
    if(pDest == NULL) {
        /*  EfiSource does not have a drive letter */
        pDest = strchr(BuildDir,':');
        result = pDest - BuildDir + 1;
    }
    
    /*  Advance to the buildpath directory */
    BuildPath = BuildDir + strlen(EfiSource) + result;

    /*  Set the current dir to be the EFI_SOURCE root */
    f = SetCurrentDirectory (EfiSource);
    if (!f) {
        printf ("Could not find EFI_SOURCE\n");
    }
}


VOID
ProcessDir (
    IN ULONG                NameIndex,
    IN ULONG                DirLevel
    )
{
    HANDLE                  h;
    static WIN32_FIND_DATA  FileData;
    static UCHAR            NameBuffer[100];

    NameBuffer[NameIndex] = 0;

    /*  Don't process $(EFI_SOURCE)\build */
    if (strcmp (NameBuffer, "build") == 0) {
        return ;
    }

    /*  */
    ProcessMakeInfo(NameBuffer, DirLevel);

    /* 
     *  Process directories
     */

    h = FindFirstFile ("*", &FileData);
    do {
        /*  must be a directory */
        if (FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (strcmp (FileData.cFileName, ".") && strcmp (FileData.cFileName, "..")) {
                /*  put entry in the directory list */
                if (SetCurrentDirectory (FileData.cFileName)) {
                    _strlwr (FileData.cFileName);
                    if (NameIndex) {
                        sprintf (NameBuffer+NameIndex, "\\%s", FileData.cFileName);
                    } else {
                        sprintf (NameBuffer, "%s", FileData.cFileName);
                    }

                    ProcessDir (strlen (NameBuffer), DirLevel + 1);
                    NameBuffer[NameIndex] = 0;

                    SetCurrentDirectory ("..");
                }
            }
        }
    } while (FindNextFile (h, &FileData)) ;
    FindClose (h);
}



VOID
InitMakeInfo (
    IN OUT MAKE_INFO    *MakInfo
    )
{
    InitializeListHead (&MakInfo->Comm.C);
    InitializeListHead (&MakInfo->Comm.S);
    InitializeListHead (&MakInfo->Comm.A);
    InitializeListHead (&MakInfo->Comm.H);
    InitializeListHead (&MakInfo->Comm.INC);

    InitializeListHead (&MakInfo->Ia32.C);
    InitializeListHead (&MakInfo->Ia32.S);
    InitializeListHead (&MakInfo->Ia32.A);
    InitializeListHead (&MakInfo->Ia32.H);
    InitializeListHead (&MakInfo->Ia32.INC);

    InitializeListHead (&MakInfo->Ia64.C);
    InitializeListHead (&MakInfo->Ia64.S);
    InitializeListHead (&MakInfo->Ia64.A);
    InitializeListHead (&MakInfo->Ia64.H);
    InitializeListHead (&MakInfo->Ia64.INC);

    InitializeListHead (&MakInfo->Includes);
    InitializeListHead (&MakInfo->Libraries);
    InitializeListHead (&MakInfo->NMake);
}

VOID
FreeMakeInfoList (
    IN PLIST_ENTRY      Head
    )
{
    PLIST_ENTRY         Link, Last;

    Link=Head->Flink; 
    while (Link != Head->Flink) {
        Last = Link;
        Link = Link->Flink;
        RemoveEntryList(Last);
        free (Last);
    }
}


VOID
FreeMakeInfo (
    IN OUT MAKE_INFO    *MakInfo
    )
{
    FreeMakeInfoList (&MakInfo->Comm.C);
    FreeMakeInfoList (&MakInfo->Comm.S);
    FreeMakeInfoList (&MakInfo->Comm.A);
    FreeMakeInfoList (&MakInfo->Comm.H);
    FreeMakeInfoList (&MakInfo->Comm.INC);

    FreeMakeInfoList (&MakInfo->Ia32.C);
    FreeMakeInfoList (&MakInfo->Ia32.S);
    FreeMakeInfoList (&MakInfo->Ia32.A);
    FreeMakeInfoList (&MakInfo->Ia32.H);
    FreeMakeInfoList (&MakInfo->Ia32.INC);

    FreeMakeInfoList (&MakInfo->Ia64.C);
    FreeMakeInfoList (&MakInfo->Ia64.S);
    FreeMakeInfoList (&MakInfo->Ia64.A);
    FreeMakeInfoList (&MakInfo->Ia64.H);
    FreeMakeInfoList (&MakInfo->Ia64.INC);

    FreeMakeInfoList (&MakInfo->Includes);
    FreeMakeInfoList (&MakInfo->Libraries);
    FreeMakeInfoList (&MakInfo->NMake);
}

BOOLEAN
CopyFileData (
    IN FILE     *FpIn,
    IN FILE     *FpOut
    )
{
    UCHAR       s[1000];


    while (fgets (s, sizeof(s)-1, FpIn)) {
        fputs (s, FpOut);
    }

    return FALSE;
}


BOOLEAN
ParseInput (
    IN FILE             *FpIn,
    IN OUT MAKE_INFO    *MakInfo
    )
{
    PUCHAR              p, p1, p2;
    PUCHAR              ProcDir, DefProcDir;
    PLIST_ENTRY         FList, LineList;
    FILE_LIST           *DefFileList, *FileList;
    A_LINE              *LInfo;
    A_FILE              *FInfo;
    UCHAR               s[1000];

    DefFileList = NULL;
    LineList = NULL;
    while (fgets (s, sizeof(s)-1, FpIn)) {
        /*  strip white space */
        for (p=s; *p  && *p <= ' '; p++) ;

        p2 = p;
        for (p1=p; *p1; p1++) {
            if (*p1 > ' ') {
                p2 = p1;
            }
        }
        p2[1] = 0;

        if (p[0] == 0 || p[0] == '#') {
            continue;
        }

        if (p[0] == '[') {
            
            DefFileList = NULL;
            LineList = NULL;

            DefProcDir = "";
            if (_stricmp (p, "[sources]") == 0) {
                DefFileList = &MakInfo->Comm;

            } else if (_stricmp (p, "[ia32sources]") == 0) {
                DefFileList = &MakInfo->Ia32;
                DefProcDir = "Ia32\\";

            } else if (_stricmp (p, "[ia64sources]") == 0) {
                DefFileList = &MakInfo->Ia64;
                DefProcDir = "Ia64\\";

            } else if (_stricmp (p, "[includes]") == 0) {
                LineList = &MakInfo->Includes;

            } else if (_stricmp (p, "[libraries]") == 0) {
                LineList = &MakInfo->Libraries;

            } else if (_stricmp (p, "[nmake]") == 0) {
                LineList = &MakInfo->NMake;

            } else {
                printf ("FAILED: Unknown section in make.inf '%s'\n", p);
                return TRUE;

            }
            continue;
        }   

        /*  save data */
        if (DefFileList) {
            _strlwr (p);

            /*  check if filename is for a specific processor type
             *  and override to default  */
            
            FileList = DefFileList;
            ProcDir = DefProcDir;
            if (strstr (p, "\\ia32\\")) {
                FileList = &MakInfo->Ia32;
                ProcDir = "";
            } 
            if (strstr (p, "\\ia64\\")) {
                FileList = &MakInfo->Ia64;
                ProcDir = "";
            }

            /*  find extension for this file */
            p2 = ".";
            for (p1=p; *p1; p1++) {
                if (*p1 == '.') {
                    p2 = p1;
                }
            }

            /*  bin the file based on it's extension */
            if (_stricmp (p2, ".c") == 0) {
                FList = &FileList->C;
            } else if (_stricmp (p2, ".s") == 0) {
                FList = &FileList->S;
            } else if (_stricmp (p2, ".h") == 0) {
                FList = &FileList->H;
            } else if (_stricmp (p2, ".inc") == 0) {
                FList = &FileList->INC;
            } else if (_stricmp (p2, ".asm") == 0) {
                FList = &FileList->A;
            } else {
                printf ("  FAILED: Unknown source file extension type '%s'\n", p);
                return TRUE;
            }
            
            *p2 = 0;
            FInfo = malloc (sizeof(A_FILE) + strlen (p) + 1);
            if (!FInfo) {
                printf("FAILED: Out of memory\n");
                return TRUE;
            }
            FInfo->ProcDir = ProcDir;
            strcpy (FInfo->Filename, p);
            InsertTailList (FList, &FInfo->Link);
            continue;
        }
        
        if (LineList) {
            LInfo = malloc (sizeof(A_LINE) + strlen (p) + 1);
            if (!LInfo) {
                printf("FAILED: Out of memory\n");
                return TRUE;
            }
            strcpy (LInfo->Line, p);
            InsertTailList (LineList, &LInfo->Link);
            continue;
        }

        printf ("FAILED: Unknown data '%s'\n", p);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpFileInfo (
    IN FILE         *FpOut,
    IN FILE_LIST    *FileList
    )
{
    PLIST_ENTRY     Link;
    A_FILE          *FInfo;


    /*  Each C file depends on each OBJ file */
    for (Link=FileList->C.Flink; Link != &FileList->C; Link=Link->Flink) {
        FInfo = CONTAINING_RECORD (Link, A_FILE, Link);

        fprintf (FpOut, "$(BUILD_DIR)\\%s%s.obj : $(SOURCE_DIR)\\%s%s.c $(INC_DEPS)\n",
            FInfo->ProcDir, FInfo->Filename,
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "    $(CC) @<<\n$(C_FLAGS) $(MODULE_CFLAGS) /c $(SOURCE_DIR)\\%s%s.c /Fo$@ /FR$(@R).SBR\n<<NOKEEP",
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "\n");
    }

    fprintf (FpOut, "\n");

    /*  Append to build object list */
    if (!IsListEmpty (&FileList->C)) {
        fprintf (FpOut, "OBJECTS = $(OBJECTS) \\\n");
        for (Link=FileList->C.Flink; Link != &FileList->C; Link=Link->Flink) {
            FInfo = CONTAINING_RECORD (Link, A_FILE, Link);
            fprintf (FpOut, "    $(BUILD_DIR)\\%s%s.obj \\\n", FInfo->ProcDir, FInfo->Filename);
        }
    }

    fprintf (FpOut, "\n\n");

    /*  Each ASM file depends on each OBJ file */
    for (Link=FileList->A.Flink; Link != &FileList->A; Link=Link->Flink) {
        FInfo = CONTAINING_RECORD (Link, A_FILE, Link);

        fprintf (FpOut, "$(BUILD_DIR)\\%s%s.obj : $(SOURCE_DIR)\\%s%s.asm $(INC_DEPS)\n",
            FInfo->ProcDir, FInfo->Filename,
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "    $(MASM) $(MASM_FLAGS) $(MODULE_MASMFLAGS) /Fo$@ $(SOURCE_DIR)\\%s%s.asm\n",
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "\n");
    }

    fprintf (FpOut, "\n");

    /*  Append to build object list */
    if (!IsListEmpty (&FileList->A)) {
        fprintf (FpOut, "OBJECTS = $(OBJECTS) \\\n");
        for (Link=FileList->A.Flink; Link != &FileList->A; Link=Link->Flink) {
            FInfo = CONTAINING_RECORD (Link, A_FILE, Link);
            fprintf (FpOut, "    $(BUILD_DIR)\\%s%s.obj \\\n",             
                FInfo->ProcDir, FInfo->Filename
                );
        }
    }

    fprintf (FpOut, "\n\n");


    /*  Each S file depends on each OBJ file */
    for (Link=FileList->S.Flink; Link != &FileList->S; Link=Link->Flink) {
        FInfo = CONTAINING_RECORD (Link, A_FILE, Link);

        fprintf (FpOut, "$(BUILD_DIR)\\%s%s.obj : $(SOURCE_DIR)\\%s%s.s $(INC_DEPS)\n",
            FInfo->ProcDir, FInfo->Filename,
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "    $(CC) $(CFLAGS_P) $(SOURCE_DIR)\\%s%s.s > $(BUILD_DIR)\\%s%s.pro\n",
            FInfo->ProcDir, FInfo->Filename,
            FInfo->ProcDir, FInfo->Filename
            );        

        fprintf (FpOut, "    $(ASM) $(AFLAGS) $(MODULE_AFLAGS) $(BUILD_DIR)\\%s%s.pro\n",
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "    del $(BUILD_DIR)\\%s%s.pro\n",
            FInfo->ProcDir, FInfo->Filename
            );

        fprintf (FpOut, "\n");
    }

    fprintf (FpOut, "\n");

    /*  Append to build object list */
    if (!IsListEmpty (&FileList->S)) {
        fprintf (FpOut, "OBJECTS = $(OBJECTS) \\\n");
        for (Link=FileList->S.Flink; Link != &FileList->S; Link=Link->Flink) {
            FInfo = CONTAINING_RECORD (Link, A_FILE, Link);
            fprintf (FpOut, "    $(BUILD_DIR)\\%s%s.obj \\\n",             
                FInfo->ProcDir, FInfo->Filename
                );
        }
    }

    fprintf (FpOut, "\n\n");
}


VOID
DumpIncludeInfo (
    IN FILE         *FpOut,
    IN PUCHAR       DirName,
    IN FILE_LIST    *FileList
    )
{
    PLIST_ENTRY     Link;
    A_FILE          *FInfo;

    fprintf (FpOut, "INC_DEPS = $(INC_DEPS) \\\n");

    /*  Append to INC_DEPS list */
    if (!IsListEmpty (&FileList->H)) {
        for (Link=FileList->H.Flink; Link != &FileList->H; Link=Link->Flink) {
            FInfo = CONTAINING_RECORD (Link, A_FILE, Link);
            fprintf (FpOut, "    $(EFI_SOURCE)\\%s\\%s%s.h \\\n", DirName, FInfo->ProcDir, FInfo->Filename);
        }
    }

    /*  Append to INC_DEPS list */
    if (!IsListEmpty (&FileList->INC)) {
        for (Link=FileList->INC.Flink; Link != &FileList->INC; Link=Link->Flink) {
            FInfo = CONTAINING_RECORD (Link, A_FILE, Link);
            fprintf (FpOut, "    $(EFI_SOURCE)\\%s\\%s%s.inc \\\n", DirName, FInfo->ProcDir, FInfo->Filename);
        }
    }

    fprintf (FpOut, "\n\n");
}

VOID
DumpHeader (
    IN FILE     *Fp,
    IN PCHAR    Line
    )
{
    fprintf (Fp, "\n");
    fprintf (Fp, "#\n");
    if (Line) {
        fprintf (Fp, "# %s\n", Line);
    } else {
        fprintf (Fp, "# This is a machine generated file - DO NOT EDIT\n");
        fprintf (Fp, "#    Generated by genmake.exe\n");
        fprintf (Fp, "#    Generated from make.inf\n");
        fprintf (Fp, "#    Copyright (c) 1998  Intel Corporation\n");
    }
    fprintf (Fp, "#\n");
    fprintf (Fp, "\n");
}

PCHAR
LastName (
    IN PCHAR    FullName
    )
{
    PCHAR       p1, p2;

    p2 = FullName;
    for (p1=FullName; *p1; p1++) {
        if (*p1 == '\\' || *p1 == '/') {
            p2 = p1 + 1;
        }
    }

    return p2;
}


VOID
ProcessMakeInfo (
    IN PCHAR    DirName,
    IN ULONG    DirLevel
    )
{    
    FILE            *FpIn, *FpOut, *FpInc;
    BOOLEAN         Failed, f, RawMakefile;
    UCHAR           OutName[MAX_FILE_NAME];
    UCHAR           OutDir[MAX_FILE_NAME];
    UCHAR           IncName[MAX_FILE_NAME];
    PCHAR           LName;
    MAKE_INFO       MakInfo;
    A_LINE          *Line;
    PLIST_ENTRY     Link;

    Failed = TRUE;
    FpIn = NULL;
    FpOut = NULL;
    FpInc = NULL;
    OutName[0] = 0;
    IncName[0] = 0;
    RawMakefile = FALSE;

    /* 
     *  Create out directory
     */

    sprintf (OutDir, "%s\\output\\%s", BuildDir, DirName);
    _mkdir (OutDir);

    /* 
     *  Open input file
     */

    FpIn = fopen("make.inf", "r");
    if (!FpIn) {

        /* 
         *  Check for makefile
         */

        FpIn = fopen("makefile", "r");
        if (!FpIn) {
            return ;
        }

        RawMakefile = TRUE;
    }

    printf ("Processing %s  ", DirName);
    InitMakeInfo (&MakInfo);

    /* 
     *  Read input file
     */

    if (!RawMakefile) {
        f = ParseInput (FpIn, &MakInfo);
        if (f) {
            goto Done;
        }
    }

    /* 
     *  Create output name
     */

    sprintf (OutName, "%s\\makefile", OutDir);
    FpOut = fopen (OutName, "w+");
    if (!FpOut) {
        printf ("Could not create %s\n", OutName);
        goto Done;
    }
    DumpHeader (FpOut, NULL);

    /* 
     *  If the source is a raw makefile, just copy it
     */

    if (RawMakefile) {
        Failed = CopyFileData (FpIn, FpOut);
        goto Done;
    }

    sprintf (IncName, "%s\\makefile.hdr", OutDir);
    FpInc = fopen (IncName, "w+");
    if (!FpInc) {
        printf ("Could not create %s\n", IncName);
        goto Done;
    }
    DumpHeader (FpInc, NULL);

    /* 
     *  Write header to output file
     *   */

    DumpHeader (FpOut, "Globals");
    fprintf (FpOut, "SOURCE_DIR=$(EFI_SOURCE)\\%s\n", DirName);
    fprintf (FpOut, "BUILD_DIR=$(EFI_SOURCE)%s\\output\\%s\n", BuildPath, DirName);
    fprintf (FpOut, "\n");

    /* 
     *  Include master.env
     */

    DumpHeader (FpOut, "Include Master.env enviroment");
    fprintf (FpOut, "!include $(EFI_SOURCE)%s\\master.env\n", BuildPath);

    /* 
     *  Dump nmake section
     */

    if (!IsListEmpty (&MakInfo.NMake)) {
        DumpHeader (FpOut, "Gerneral make info");
        for (Link=MakInfo.NMake.Flink; Link != &MakInfo.NMake; Link = Link->Flink) {
            Line = CONTAINING_RECORD (Link, A_LINE, Link);
            fprintf (FpOut, "%s\n", Line->Line);
        }
    }

    /* 
     *  Include header file includes
     */

    DumpHeader (FpOut, "Include paths");
    for (Link=MakInfo.Includes.Flink; Link != &MakInfo.Includes; Link = Link->Flink) {
        Line = CONTAINING_RECORD (Link, A_LINE, Link);
        if (strncmp(Line->Line, "$(EFI_SOURCE)\\", 14) == 0) {
            fprintf (FpOut, "!include $(EFI_SOURCE)%s\\output\\%s\\makefile.hdr\n", BuildPath, Line->Line+14);
            fprintf (FpOut, "INC=-I %s -I %s\\$(PROCESSOR) $(INC)\n", Line->Line, Line->Line);
        } else {
            fprintf (FpOut, "!include $(BUILD_DIR)\\%s\\makefile.hdr\n", Line->Line);
            fprintf (FpOut, "INC=-I $(SOURCE_DIR)\\%s -I $(SOURCE_DIR)\\%s\\$(PROCESSOR) $(INC)\n", 
                                Line->Line,
                                Line->Line
                                );
        }
        fprintf (FpOut, "\n");
    }

    /* 
     *  Include libaries 
     */

    if (!IsListEmpty (&MakInfo.Libraries)) {
        DumpHeader (FpOut, "Libraries");
        for (Link=MakInfo.Libraries.Flink; Link != &MakInfo.Libraries; Link = Link->Flink) {
            Line = CONTAINING_RECORD (Link, A_LINE, Link);
            LName = LastName (Line->Line);
            if (strncmp(Line->Line, "$(EFI_SOURCE)\\", 14) == 0) {
                fprintf (FpOut, "LIBS = $(LIBS) $(EFI_SOURCE)%s\\output\\%s\\%s.lib\n", 
                                BuildPath, 
                                Line->Line+14,
                                LName
                                );
            } else {
                fprintf (FpOut, "LIBS = $(LIBS) $(SOURCE_DIR)\\%s\\%s.lib\n", 
                                Line->Line,
                                LName
                                );
            }
        }
    }

    /* 
     *  Dump source file info
     */

    DumpHeader (FpOut, "Source file dependencies");
    /*  Dump common files */
    DumpFileInfo (FpOut, &MakInfo.Comm);

    /*  Dump ia32 files     */
    fprintf (FpOut, "!IF \"$(PROCESSOR)\" == \"Ia32\"\n");
    DumpFileInfo (FpOut, &MakInfo.Ia32);
    fprintf (FpOut, "!ENDIF\n\n");

    /*  Dump ia64 files */
    fprintf (FpOut, "!IF \"$(PROCESSOR)\" == \"Ia64\"\n");
    DumpFileInfo (FpOut, &MakInfo.Ia64);
    fprintf (FpOut, "!ENDIF\n\n");

    /* 
     *  Dump include file info
     */

    DumpIncludeInfo (FpInc, DirName, &MakInfo.Comm);

    /*  Dump ia32 files     */
    fprintf (FpInc, "!IF \"$(PROCESSOR)\" == \"Ia32\"\n");
    DumpIncludeInfo(FpInc, DirName, &MakInfo.Ia32);
    fprintf (FpInc, "!ENDIF\n\n");

    /*  Dump ia64 files */
    fprintf (FpInc, "\n");
    fprintf (FpInc, "!IF \"$(PROCESSOR)\" == \"Ia64\"\n");
    DumpIncludeInfo (FpInc, DirName, &MakInfo.Ia64);
    fprintf (FpInc, "!ENDIF\n\n");

    /* 
     *  If there are any sources to build, define a lib target
     */

    LName = LastName (DirName);

    DumpHeader (FpOut, "Define the lib");
    fprintf (FpOut, "!IFDEF OBJECTS\n");
    fprintf (FpOut, "TARGET_LIB = $(BUILD_DIR)\\%s.lib\n", LName);
    fprintf (FpOut, "BIN_TARGETS = $(BIN_TARGETS) $(TARGET_LIB)\n");
    fprintf (FpOut, "$(TARGET_LIB) : $(OBJECTS) \n");
    fprintf (FpOut, "    $(LIB) @<<\n$(LIB_FLAGS) $** /OUT:$(TARGET_LIB)\n<<NOKEEP\n");
    fprintf (FpOut, "!ENDIF\n");

    /* 
     * 
     */

    DumpHeader (FpOut, "Define for apps");
    fprintf (FpOut, "!IFDEF TARGET_APP\n");
    fprintf (FpOut, "TARGET_APP = $(BIN_DIR)\\$(TARGET_APP).efi\n");
    fprintf (FpOut, "BIN_TARGETS = $(BIN_TARGETS) $(TARGET_APP)\n");
    fprintf (FpOut, "$(TARGET_APP) : $(TARGET_LIB) $(LIBS)\n");
    fprintf (FpOut, "    $(LINK) @<<\n$(L_FLAGS) $(MODULE_LFLAGS) $(LIBS) /ENTRY:$(IMAGE_ENTRY_POINT) $** /OUT:$(@R).dll\n<<NOKEEP\n");
    fprintf (FpOut, "    $(FWIMAGE) app $(@R).dll $(TARGET_APP)\n");
    fprintf (FpOut, "!ENDIF\n");
    
    /* 
     * 
     */

    DumpHeader (FpOut, "Define for boot service drivers");
    fprintf (FpOut, "!IFDEF TARGET_BS_DRIVER\n");
    fprintf (FpOut, "TARGET_DRIVER = $(BIN_DIR)\\$(TARGET_BS_DRIVER).efi\n");
    fprintf (FpOut, "BIN_TARGETS = $(BIN_TARGETS) $(TARGET_DRIVER)\n");
    fprintf (FpOut, "$(TARGET_DRIVER) : $(TARGET_LIB) $(LIBS)\n");
    fprintf (FpOut, "    $(LINK) @<<\n$(L_FLAGS) $(MODULE_LFLAGS) $(LIBS) /ENTRY:$(IMAGE_ENTRY_POINT) $** /OUT:$(@R).dll\n<<NOKEEP\n");
    fprintf (FpOut, "    $(FWIMAGE) bsdrv $(@R).dll $(TARGET_DRIVER)\n");
    fprintf (FpOut, "!ENDIF\n");

    /* 
     * 
     */

    DumpHeader (FpOut, "Define for runtime service drivers");
    fprintf (FpOut, "!IFDEF TARGET_RT_DRIVER\n");
    fprintf (FpOut, "TARGET_DRIVER = $(BIN_DIR)\\$(TARGET_RT_DRIVER).efi\n");
    fprintf (FpOut, "BIN_TARGETS = $(BIN_TARGETS) $(TARGET_DRIVER)\n");
    fprintf (FpOut, "$(TARGET_DRIVER) : $(TARGET_LIB) $(LIBS)\n");
    fprintf (FpOut, "    $(LINK) @<<\n$(L_FLAGS) $(MODULE_LFLAGS) $(LIBS) /ENTRY:$(IMAGE_ENTRY_POINT) $** /OUT:$(@R).dll\n<<NOKEEP\n");
    fprintf (FpOut, "    $(FWIMAGE) rtdrv $(@R).dll $(TARGET_DRIVER)\n");
    fprintf (FpOut, "!ENDIF\n");

    /* 
     *  Worked
     */

    DumpHeader (FpOut, "Handoff to Master.Mak");
    fprintf (FpOut, "!include $(EFI_SOURCE)%s\\master.mak\n", BuildPath);
    Failed = FALSE;
    printf ("\n");

Done:
    if (FpIn) {
        fclose (FpIn);
    }
    if (FpOut) {
        fclose (FpOut);
    }
    if (FpInc) {
        fclose (FpInc);
    }

    if (Failed) {
        if (OutName[0]) {
            _unlink (OutName);
        }

        if (IncName[0]) {
            _unlink (IncName);
        }
    }

    FreeMakeInfo (&MakInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\cribi\crefi.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    crefi.c
    
Abstract:

    Creates an EFI volume with the specified files in it



Revision History

--*/


#include "windows.h"
#include "stdio.h"
#include "efi.h"

#define EFI_NT_EMUL
#include "efilib.h"


/* 
 *  Globals
 */

EFI_GUID VendorMicrosoft = \
    { 0x4dd54b20, 0x79a1, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b };

BOOLEAN     ApplyVendorGuid = TRUE; /*  apply vendor guid to files */
BOOLEAN     SupplyLba0  = TRUE;     /*  write Lba0 to the image or not */
UINTN       BlockSize  = 512;       /*  default is 512 */


/* 
 *  Prototypes
 */

typedef struct {
    LIST_ENTRY  Link;
    HANDLE      h;
    PUCHAR      AsciiName;
    UINTN       FileSize;
    WCHAR       FileName[1];
} FILE_ENTRY, *PFILE_ENTRY;


VOID
Abort(
    VOID
    );

VOID
CreateFileEntry (
    IN UINTN    FileEntryLba,
    IN UINTN    DataLba,
    IN UINTN    ParentLba,
    IN PWCHAR   FileName,
    IN UINTN    FileSize
    );

PVOID
ZAlloc(
    IN UINTN    Size
    );


VOID
ParseArgs (
    IN UINTN    Argc,
    IN PUCHAR   *Argv
    );


VOID
WriteBlock (
    IN UINTN    Lba,
    IN VOID     *Buffer
    );

VOID
GetEfiTime (
    OUT EFI_TIME        *Time
    );

VOID
SetCrc (
    IN OUT EFI_TABLE_HEADER *Hdr
    );

VOID
SetCrcAltSize (
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

VOID
SetLbalCrc (
    IN EFI_LBAL     *Lbal
    );


/* 
 * 
 */

LIST_ENTRY  FileList;               /*  Input files */
PFILE_ENTRY OutFile;                /*  Output file */



int
main (
    int argc,
    char *argv[]
    )
/*++

Routine Description:


Arguments:


Returns:


--*/
{
    LIST_ENTRY              *Link;
    BOOLEAN                 Flag;
    PFILE_ENTRY             File;
    UINTN                   FileNumber, DataBlock;
    UINTN                   Len, BytesRead;
    VOID                    *DataBuffer;
    EFI_PARTITION_HEADER    *Partition;

    /* 
     *  Init globals
     */

    InitializeListHead (&FileList);

    /* 
     *  Crack the arguments
     */

    ParseArgs (argc, argv);

    /*  If no files to process, then abort */
    if (IsListEmpty(&FileList)) {
        Abort ();
    }

    /* 
     *  Last file is the out file
     */

    Link = FileList.Blink;
    OutFile = CONTAINING_RECORD (Link, FILE_ENTRY, Link);
    RemoveEntryList (&OutFile->Link);

    /*  If no files to process, then abort */
    if (IsListEmpty(&FileList)) {
        Abort ();
    }


    /* 
     *  Open the input files and accumlate their sizes
     */

    FileNumber = 0;
    for (Link = FileList.Flink; Link != &FileList; Link = Link->Flink) {
        File = CONTAINING_RECORD (Link, FILE_ENTRY, Link);

        File->h = CreateFile (
                        File->AsciiName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if (File->h == INVALID_HANDLE_VALUE) {
            printf ("Could not open %s, file skipped\n", File->AsciiName);
            RemoveEntryList (&File->Link);
            free (File);
        }

        File->FileSize = GetFileSize (File->h, NULL);
        FileNumber += 1;
    }


    /* 
     *  Open the output file
     */

    OutFile->h = CreateFile (
                    OutFile->AsciiName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL
                    );

    if (OutFile->h == INVALID_HANDLE_VALUE) {
        printf ( "Could not open output file %s\n", OutFile->AsciiName);
        exit (1);
    }

    /* 
     *  Write the EFI volume image
     * 
     *  Layout the image as follows:
     *       0   - not used
     *       1   - partition header
     *       2   - file header for root directory
     *       3   - contents of root dir
     *               3 - file header of file #0
     *               4 - file header of file #1
     *               ..
     *               n - file header of file #n
     *       n+1 - contents of file #0
     *       n+x - contents of file #1
     *       ...
     */

    Partition = ZAlloc(BlockSize);
    DataBuffer = ZAlloc(BlockSize);

    /*  write LBA 0 */
    WriteBlock (0, DataBuffer);

    /*  Create root directory in block 2 with data in block 3 */
    CreateFileEntry (2, 3, EFI_PARTITION_LBA, L"\\", FileNumber * BlockSize);

    /*  add all the files */

    DataBlock  = 3 + FileNumber;
    FileNumber = 0;

    for (Link = FileList.Flink; Link != &FileList; Link = Link->Flink) {
        File = CONTAINING_RECORD (Link, FILE_ENTRY, Link);

        /*  Create directory entry for the file */
        CreateFileEntry (3 + FileNumber, DataBlock, 2, File->FileName, File->FileSize);

        /*  write the file's data at DataBlock */
        while (File->FileSize) {
            Len = BlockSize;
            if (Len > File->FileSize) {
                Len = File->FileSize;
                memset (DataBuffer, 0, BlockSize);
            }

            Flag = ReadFile (File->h, DataBuffer, Len, &BytesRead, NULL);
            if (!Flag || BytesRead != Len) {
                printf ("Read error of file %s\n", File->FileName);
                exit (1);
            }

            WriteBlock (DataBlock, DataBuffer);
            DataBlock += 1;
            File->FileSize -= Len;
        }

        FileNumber += 1;
    }

    /* 
     *  Last step, write a valid EFI partition header
     */

    Partition->Hdr.Signature = EFI_PARTITION_SIGNATURE;
    Partition->Hdr.Revision = EFI_PARTITION_REVISION;
    Partition->Hdr.HeaderSize = sizeof(EFI_PARTITION_HEADER);
    Partition->FirstUsableLba = 2;
    Partition->LastUsableLba = DataBlock;
    Partition->DirectoryAllocationNumber = 1;
    Partition->BlockSize = BlockSize;
    Partition->RootFile = 2;                /*  Root dir in LBA 2 */

    SetCrc (&Partition->Hdr);
    WriteBlock (EFI_PARTITION_LBA, Partition);

    printf ("Done\n");
    return 0;
}


VOID
CreateFileEntry (
    IN UINTN    FileEntryLba,
    IN UINTN    DataLba,
    IN UINTN    ParentLba,
    IN PWCHAR   FileName,
    IN UINTN    FileSize
    )
{
    EFI_LBAL                *Lbal;
    EFI_RL                  *rl;
    EFI_FILE_HEADER         *File;
    UINTN                   Index;
    BOOLEAN                 ApplyGuid, Directory;


    Directory = FALSE;
    ApplyGuid = FALSE;
    if (ApplyVendorGuid && ParentLba != EFI_PARTITION_LBA) {
        ApplyGuid = TRUE;
    }
    
    if (ParentLba == EFI_PARTITION_LBA) {
        Directory = TRUE;
    }


    printf ("%4x Creating %s '%ls'%s, file size %d.\n",
                DataLba,
                Directory ? "directory" : "file",
                FileName,
                ApplyGuid ? " with Microsoft Vendor GUID" : "",
                FileSize
                );


    File = ZAlloc(BlockSize);

    File->Hdr.Signature = EFI_FILE_HEADER_SIGNATURE;

    File->Hdr.Revision = EFI_FILE_HEADER_REVISION;
    File->Hdr.HeaderSize = sizeof(EFI_FILE_HEADER);
    File->Class = EFI_FILE_CLASS_NORMAL;
    File->LBALOffset = File->Hdr.HeaderSize;
    File->Parent = ParentLba; 
    File->FileSize = FileSize;
    File->FileAttributes = Directory ? EFI_FILE_DIRECTORY : 0;
    GetEfiTime (&File->FileCreateTime);
    GetEfiTime (&File->FileModificationTime);
    for (Index=0; FileName[Index]; Index += 1) {
        File->FileString[Index] = FileName[Index];
    }
    if (ApplyGuid) {
        memcpy (&File->VendorGuid, &VendorMicrosoft, sizeof(EFI_GUID));
    }
    SetCrc (&File->Hdr);

    Lbal = EFI_FILE_LBAL(File);
    Lbal->Hdr.Signature = EFI_LBAL_SIGNATURE;
    Lbal->Hdr.Revision = EFI_LBAL_REVISION;
    Lbal->Hdr.HeaderSize = sizeof (EFI_LBAL);
    Lbal->Class = File->Class;
    Lbal->Parent = 0;
    Lbal->Next = 0;
    Lbal->ArraySize = EFI_LBAL_ARRAY_SIZE(Lbal, File->LBALOffset, BlockSize);
    Lbal->ArrayCount = 0;

    if (FileSize) {
        Lbal->ArrayCount = 1;
        rl = EFI_LBAL_RL(Lbal);
        rl->Start  = DataLba;
        rl->Length = FileSize / BlockSize;
        if (FileSize % BlockSize) {
            rl->Length += 1;
        }
    }
    SetLbalCrc (Lbal);
    WriteBlock (FileEntryLba, File);
    free (File);
}



VOID
WriteBlock (
    IN UINTN    Lba,
    IN VOID     *Buffer
    )
{
    BOOLEAN     Flag;
    UINTN       BytesWritten, pos;

    pos = SetFilePointer (OutFile->h, Lba * BlockSize, NULL, FILE_BEGIN);
    if (pos == 0xffffffff) {
        printf ("Seek error of file %s\n", OutFile->AsciiName);
    }

    Flag = WriteFile (OutFile->h, Buffer, BlockSize, &BytesWritten, NULL);
    if (!Flag || BytesWritten != BlockSize) {
        printf ("Write error of file %s\n", OutFile->AsciiName);
        exit (1);
    }
}



VOID
Abort(
    VOID
    )
{
    printf ("usage: cribi [-g] [-b blocksize] infile infile infile ... outfile\n");
    exit (1);
}



PVOID
ZAlloc(
    IN UINTN    Size
    )
{
    PVOID       p;

    p = malloc(Size);
    memset (p, 0, Size);
    return p;
}



UINTN   ParseArgc;
PUCHAR  *ParseArgv;


PUCHAR
NextArg (
    VOID
    )
{
    PUCHAR  Arg;

    Arg = NULL;
    if (ParseArgc) {
        Arg = *ParseArgv;
        ParseArgc -= 1;
        ParseArgv += 1;
    }
    return Arg;
}


VOID
ParseArgs (
    IN UINTN    Argc,
    IN PUCHAR   *Argv
    )
{
    PFILE_ENTRY     File;
    UINTN           Start, Index, Len;
    PUCHAR          Arg, p;

    ParseArgc = Argc - 1;
    ParseArgv = Argv + 1;

    while (Arg = NextArg()) {

        /* 
         *  If '-' then crack the flags
         */

        if (*Arg == '-') {
            for (Arg += 1; *Arg; Arg +=1) {
                switch (*Arg) {
                    case 'g':
                        ApplyVendorGuid = FALSE;
                        break;

                    case 'b':
                        p = NextArg();
                        if (!p) {
                            Abort();
                        }

                        BlockSize = atoi (p);
                        if (BlockSize < 512 || BlockSize % 512) {
                            printf ("Bad block size: %d\n", BlockSize);
                            exit (1);
                        }

                        printf ("Block size set to: %d\n", BlockSize);
                        break;

                    default:
                        printf ("Unkown flag ignored: %c\n", *Arg);
                }
            }

            continue;
        }

        /* 
         *  Add this name to the file list
         */


        Len  = strlen (Arg) + 1;
        File = ZAlloc (sizeof(FILE_ENTRY) + Len * sizeof(WCHAR));
        File->AsciiName = Arg;

        Start = 0;
        for (Index=0; Index < Len; Index += 1) {
            if (Arg[Index] == '\\') {
                Start = Index+1;
            }
        }
        Arg += Start;
        Len -= Start;
        if (Len > EFI_FILE_STRING_SIZE-1) {
            Len = EFI_FILE_STRING_SIZE-1;
            printf ("Warning: file name %s truncated\n", Arg);
        }

        for (Index=0; Index < Len; Index += 1) {
            File->FileName[Index] = Arg[Index];
        }

        File->FileName[Index] = 0;

        /*  add to the end of the list */
        InsertTailList (&FileList, &File->Link);
    }
}


VOID
GetEfiTime (
    OUT EFI_TIME        *Time
    )
{
    TIME_ZONE_INFORMATION   TimeZone;


    SYSTEMTIME              SystemTime;

    memset (Time, 0, sizeof(EFI_TIME));

    GetSystemTime (&SystemTime);
    GetTimeZoneInformation (&TimeZone);

    Time->Year   = (UINT16) SystemTime.wYear;
    Time->Month  = (UINT8)  SystemTime.wMonth;
    Time->Day    = (UINT8)  SystemTime.wDay;
    Time->Hour   = (UINT8)  SystemTime.wHour;
    Time->Minute = (UINT8)  SystemTime.wMinute;
    Time->Second = (UINT8)  SystemTime.wSecond;
    Time->Nanosecond = (UINT32) SystemTime.wMilliseconds * 1000000;
    Time->TimeZone = (INT16) TimeZone.Bias;

    if (TimeZone.StandardDate.wMonth) {
        Time->Daylight = EFI_TIME_ADJUST_DAYLIGHT;
    }    
}





/* 
 *  Copied from efi\libsrc\crc.c
 */


UINT32 CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D 
    };
    


VOID
SetCrc (
    IN OUT EFI_TABLE_HEADER *Hdr
    )
/*++

Routine Description:

    Updates the CRC32 value in the table header

Arguments:

    Hdr     - The table to update

Returns:

    None

--*/
{
    SetCrcAltSize (Hdr->HeaderSize, Hdr);
}

VOID
SetCrcAltSize (
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    )
/*++

Routine Description:

    Updates the CRC32 value in the table header

Arguments:

    Hdr     - The table to update

Returns:

    None

--*/
{
    UINT8       *pt;
    UINTN        Crc;
        
    /*  clear old crc from header */
    pt = (UINT8 *) Hdr;
    Hdr->CRC32 = 0;

    /*  compute crc */
    Crc =  0xffffffff;
    while (Size) {
        Crc = (Crc >> 8) ^ CRCTable[(UINT8) Crc ^ *pt];
        pt += 1;
        Size -= 1;
    }

    /*  set restults */
    Hdr->CRC32 = (UINT32) Crc ^ 0xffffffff;
}



VOID
SetLbalCrc (
    IN EFI_LBAL     *Lbal
    )
{
    UINTN            Size;

    Size = Lbal->Hdr.HeaderSize + Lbal->ArraySize * sizeof(EFI_RL);
    SetCrcAltSize (Size, &Lbal->Hdr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\adpatch\adpatch.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    adpatch.c
    
Abstract:

    Patches adpatec cd image file



Revision History

--*/


#include "windows.h"
#include "stdio.h"

typedef union {

    struct {
        UCHAR       Indicator;
        UCHAR       PlatformId;
        USHORT      Reserved;
        UCHAR       ManufacId[24];
        USHORT      Checksum;
        USHORT      Id55AA;
    } Catalog;

    struct {
        UCHAR       Indicator;
        UCHAR       MediaType:4;
        UCHAR       Reserved1:4;
        USHORT      LoadSegment;
        UCHAR       SystemType;
        UCHAR       Reserved2;
        USHORT      SectorCount;
        ULONG       Lba;
    } Boot;

    struct {
        UCHAR       Indicator;
        UCHAR       PlatformId;
        USHORT      SectionEntries;
        UCHAR       Id[28];
    } Section;

} ELT_CATALOG;




/* 
 *  Globals
 */

#define BLOCK_SIZE  2048

UCHAR   Buffer[BLOCK_SIZE];
FILE    *FpCd, *FpIn;
ULONG   CdSize, InSize;

UCHAR   Hex[] = "0123456789ABCDEF";

/* 
 * 
 */


VOID
DumpHex (
    IN ULONG        Indent,
    IN ULONG        Offset,
    IN ULONG        DataSize,
    IN VOID         *UserData
    )
{
    UCHAR           *Data, Val[50], Str[20], c;
    ULONG           Size, Index;

    Data = UserData;
    while (DataSize) {
        Size = 16;
        if (Size > DataSize) {
            Size = DataSize;
        }

        for (Index=0; Index < Size; Index += 1) {
            c = Data[Index];
            Val[Index*3+0] = Hex[c>>4];
            Val[Index*3+1] = Hex[c&0xF];
            Val[Index*3+2] = ' ';
            Str[Index] = (c < ' ' || c > 'z') ? '.' : c;
        }

        if (Size > 8) {
            Val[8*3+2] = '-';
        }

        Val[Index*3] = 0;
        Str[Index] = 0;
        printf ("%*s%04x: %-.48s *%s*\n", Indent, "", Offset, Val, Str);

        Data += Size;
        Offset += Size;
        DataSize -= Size;
    }
}


int
main (
    int argc,
    char *argv[]
    )
/*++

Routine Description:


Arguments:


Returns:


--*/
{
    ULONG           j;
    ULONG           Pos, Size, SectorCount;
    ULONG           FloppyImage, BootCatalog;
    ELT_CATALOG     *Elt;

    FloppyImage = 0;
    BootCatalog = 0;

    if (argc < 3) {
        printf ("usage: adpatch cd-image-file efifs-image-file\n");
        exit (1);
    }

    FpCd = fopen (argv[1], "r+b");
    if (!FpCd) {
        printf ("Could not open cd image file %s\n", argv[1]);
        exit (1);
    }
    fseek (FpCd, 0, SEEK_END);
    CdSize = ftell (FpCd);


    FpIn = fopen (argv[2], "rb");
    if (!FpIn) {
        printf ("Could not open efifs image file %s\n", argv[2]);
        exit (1);
    }
    fseek (FpIn, 0, SEEK_END);
    InSize = ftell (FpIn);
    SectorCount = (InSize / BLOCK_SIZE + ((InSize % BLOCK_SIZE) ? 1 : 0));
    printf ("SectorCount %d\n", SectorCount);

    /* 
     *  Go find the boot floppy image in the image file.  It is
     *  around 1.4 MB from the end
     */

    printf ("Searching for floppy image...  ");

    Pos = CdSize;
    while (Pos && !FloppyImage) {

        Pos -= BLOCK_SIZE;
        fseek (FpCd, Pos, SEEK_SET);
        fread (Buffer, BLOCK_SIZE, 1, FpCd);

        /*  search for MS-DOS */
        for (j=0; j < BLOCK_SIZE - 5; j++) {
            if (Buffer[j+0] == 'M'  &&
                Buffer[j+1] == 'S'  &&
                Buffer[j+2] == 'D'  &&
                Buffer[j+3] == 'O'  &&
                Buffer[j+4] == 'S') {

                /*  Found the floppy image */
                FloppyImage = Pos + j - 3;
                break;
            }
        }
    }

    if (!FloppyImage) {
        printf ("Not found\n");
        exit (1);
    }

    printf ("  found at %x\n", FloppyImage);

    /* 
     *  Find the El Torito boot catalog
     */

    printf ("Searching for El Torito boot catalog...  ");

    Pos = CdSize; /*  FloppyImage - BLOCK_SIZE; */
    while (Pos > BLOCK_SIZE) {
        Pos -= BLOCK_SIZE;
        fseek (FpCd, Pos, SEEK_SET);
        fread (Buffer, BLOCK_SIZE, 1, FpCd);

        for (j=0; j < BLOCK_SIZE - sizeof(ELT_CATALOG)*2; j++) {

            Elt = (ELT_CATALOG *) (Buffer + j);

            if (Elt[0].Catalog.Indicator == 0x01    &&
                Elt[0].Catalog.PlatformId == 0      &&
                Elt[0].Catalog.Checksum == 0x55AA   &&      /*  BUGBUG: depends on adapatec s/w */
                Elt[0].Catalog.Id55AA == 0xAA55     &&
                Elt[1].Boot.Indicator == 0x88       &&
                Elt[1].Boot.MediaType == 0x02       &&
                Elt[1].Boot.LoadSegment == 0x07C0   &&
                Elt[1].Boot.SystemType == 0         &&
                Elt[1].Boot.SectorCount == 1        &&
                Elt[1].Boot.Lba != 0) {

                BootCatalog = Pos + j;
                break;
            }
        }
    }


    if (!BootCatalog) {
        printf ("Not found\n");
        exit (1);
    }

    printf ("found at %x\n", BootCatalog);

    /*  Patch the floppy file */
    printf ("Patching floppy image\n");
    fseek (FpCd, FloppyImage, SEEK_SET);
    fseek (FpIn, 0, SEEK_SET);

    while (InSize) {
        Size = BLOCK_SIZE;
        if (Size > InSize) {
            Size = InSize;
        }
        fread (Buffer, BLOCK_SIZE, 1, FpIn);
        fwrite (Buffer, BLOCK_SIZE, 1, FpCd);

        InSize -= Size;
    }

    /*  Patch the boot catalog */
    printf ("Patching boot catalog\n");
    fseek (FpCd, BootCatalog, SEEK_SET);
    fread (Buffer, BLOCK_SIZE, 1, FpCd);

    Elt = (ELT_CATALOG *) Buffer;
    Elt[1].Boot.MediaType = 0;
    Elt[1].Boot.LoadSegment = 0;
    Elt[1].Boot.SectorCount = (USHORT) SectorCount;

    fseek (FpCd, BootCatalog, SEEK_SET);
    fwrite (Buffer, BLOCK_SIZE, 1, FpCd);

    printf ("Done\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\fwimage\fwimage.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    fwimage.c
    
Abstract:

    Converts a pe32+ image to an FW image type



Revision History

--*/


#include "windows.h"
#include "stdio.h"
#include "efi.h"

/*  #define EFI_NT_EMUL
 *  #include "efilib.h" */


VOID
Usage (
    VOID
    )
{
    printf ("Usage: fwimage [app|bsdrv|rtdrv] peimage [outimage]");
    exit (1);
}

VOID
FCopyFile (
    FILE    *in,
    FILE    *out
    )
{
    ULONG           filesize, offset, length;
    UCHAR           Buffer[8*1024];

    fseek (in, 0, SEEK_END);
    filesize = ftell(in);

    fseek (in, 0, SEEK_SET);
    fseek (out, 0, SEEK_SET);

    offset = 0;
    while (offset < filesize)  {
        length = sizeof(Buffer);
        if (filesize-offset < length) {
            length = filesize-offset;
        }

        fread (Buffer, length, 1, in);
        fwrite (Buffer, length, 1, out);
        offset += length;
    }

    if ((ULONG) ftell(out) != filesize) {
        printf ("fwimage: write error\n");
        exit (1);
    }
}


int
main (
    int argc,
    char *argv[]
    )
/*++

Routine Description:


Arguments:


Returns:


--*/
{
    ULONG                       Type;
    PUCHAR                      Ext, p, pe;
    PUCHAR                      OutImageName;
    UCHAR                       outname[500];
    FILE                        *fpIn, *fpOut;
    IMAGE_DOS_HEADER            DosHdr;
    IMAGE_NT_HEADERS            PeHdr;
    
    /* 
     *  Usage fwimage [app
     */

    if (argc < 3) {
        Usage();
    }

    if (argc == 4) {
        OutImageName = argv[3];
    }

    /* 
     *  Get new iamge type
     */

    p = argv[1];
    if (*p == '/' || *p == '\\') {
        p += 1;
    }

    if (_stricmp(p, "app") == 0) {
        Type = IMAGE_SUBSYSTEM_EFI_APPLICATION;
        Ext = ".efi";

    } else if (_stricmp(p, "bsdrv") == 0) {
        Type = IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER;
        Ext = ".efi";

    } else if (_stricmp(p, "rtdrv") == 0) {
        Type = IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER;
        Ext = ".efi";

    } else {
        Usage();
    }

    /* 
     *  open source file
     */

    fpIn = fopen (argv[2], "rb");
    if (!fpIn) {
        printf ("fwimage: Could not open input file %s\n", argv[2]);
    }

    /* 
     *  Read the dos & pe hdrs of the image
     */

    fseek (fpIn, 0, SEEK_SET);
    fread (&DosHdr, sizeof(DosHdr), 1, fpIn);
    if (DosHdr.e_magic != IMAGE_DOS_SIGNATURE) {
        printf ("fwimage: dos header not found on source image\n");
        exit (1);
    }

    fseek (fpIn, DosHdr.e_lfanew, SEEK_SET);
    fread (&PeHdr, sizeof(PeHdr), 1, fpIn);
    if (PeHdr.Signature != IMAGE_NT_SIGNATURE) {
        printf ("fwimage: pe header not found on source image\n");
        exit (1);
    }

    /* 
     *  open output file
     */

    strcpy (outname, argv[2]);
    pe = NULL;
    for (p=outname; *p; p++) {
        if (*p == '.') {
            pe = p;
        }
    }

    if (!pe) {
        pe = p;
    }
    strcpy (pe, Ext);

    if (!OutImageName) {
        OutImageName = outname;
    }

    fpOut = fopen(OutImageName, "w+b");
    if (!fpOut) {
        printf ("fwimage: Could not open output file %s\n", OutImageName);
    }

    /* 
     *  Copy the file
     */

    FCopyFile (fpIn, fpOut);

    /* 
     *  Path the PE header
     */

    PeHdr.OptionalHeader.Subsystem = (USHORT) Type;
    fseek (fpOut, DosHdr.e_lfanew, SEEK_SET);
    fwrite (&PeHdr, sizeof(PeHdr), 1, fpOut);

    /* 
     *  Done
     */

    printf ("Created %s\n", OutImageName);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\splitfile\stdafx.h ===
/*  stdafx.h : include file for standard system include files,
 *   or project specific include files that are used frequently, but
 *       are changed infrequently
 */

#if !defined(AFX_STDAFX_H__4FAC4647_A22C_4969_B400_8591E42D5993__INCLUDED_)
#define AFX_STDAFX_H__4FAC4647_A22C_4969_B400_8591E42D5993__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif /*  _MSC_VER > 1000 */

#define WIN32_LEAN_AND_MEAN     /*  Exclude rarely-used stuff from Windows headers */

#include <stdio.h>

/*  TODO: reference additional headers your program requires here */

/* {{AFX_INSERT_LOCATION}}
 *  Microsoft Visual C++ will insert additional declarations immediately before the previous line. */

#endif /*  !defined(AFX_STDAFX_H__4FAC4647_A22C_4969_B400_8591E42D5993__INCLUDED_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\build\tools\src\splitfile\splitfile.c ===
/*  splitfile.cpp : Defines the entry point for the console application.
 */

#include "stdafx.h"
#include "string.h"
#include "stdlib.h"

void helpmsg (void)
{
    printf(
        "SplitFile Filename Offset\n"
        "   Filename = Input file to split\n"
        "   Offset = offset at which to split file\n"
        "\n\n"
        "SplitFile will break a file in two pieces at the requested offset\n"
        "  outputting Filename1 and Filename2\n");
}

int main(int argc, char* argv[])
{
    FILE * In, * Out1, *Out2;
    char OutName1[512], OutName2[512];
    unsigned long i, splitpoint;
    char c;

    if (argc != 3)
    {
        helpmsg();
        return(-1);
    }
    
    In = fopen (argv[1], "rb");
    if (In == NULL)
    {
        printf ("Unable to open file \"%s\"\n", argv[1]);
        return(-1);
    }
    
    strncpy(OutName1, argv[1], 510);
    strncpy(OutName2, argv[1], 510);
    strcat(OutName1, "1");
    strcat(OutName2, "2");

    Out1 = fopen (OutName1, "wb");
    if (Out1 ==  NULL)
    {
        printf ("Unable to open file \"%s\"\n", OutName1);
        return(-1);
    }
    Out2 = fopen (OutName2, "wb");
    if (Out2 == NULL)
    {
        printf ("Unable to open file \"%s\"\n", OutName2);
        return(-1);
    }

    splitpoint = atoi(argv[2]);
    
    for (i = 0; i < splitpoint; i++)
    {
        c = fgetc(In);
        if (feof(In))
            break;
        fputc(c, Out1);
    }
    
    for(;;)
    {
        c = fgetc(In);
        if (feof(In))
            break;
        fputc(c, Out2);
    }
    
    fclose(In);
    fclose(Out1);
    fclose(Out2);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efi.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efi.h

Abstract:

    Public EFI header files



Revision History

--*/

/* 
 *  Build flags on input
 *   EFI32
 *   EFI_DEBUG               - Enable debugging code
 *   EFI_NT_EMULATOR         - Building for running under NT
 */


#ifndef _EFI_INCLUDE_
#define _EFI_INCLUDE_

#define EFI_FIRMWARE_VENDOR         L"INTEL"
#define EFI_FIRMWARE_MAJOR_REVISION 12
#define EFI_FIRMWARE_MINOR_REVISION 24
#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))

#include "efibind.h"
#include "efidef.h"
#include "efidevp.h"
#include "efiprot.h"
#include "eficon.h"
#include "efiser.h"
#include "efi_nii.h"
#include "efipxebc.h"
#include "efinet.h"
#include "efiapi.h"
#include "efifs.h"
#include "efierr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\eficon.h ===
#ifndef _EFI_CON_H
#define _EFI_CON_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    eficon.h

Abstract:

    EFI console protocols



Revision History

--*/

/* 
 *  Text output protocol
 */

#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
    { 0x387477c2, 0x69c7, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_RESET) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_TEST_STRING) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_QUERY_MODE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber,
    OUT UINTN                       *Columns,
    OUT UINTN                       *Rows
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_MODE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Attribute
    );

#define EFI_BLACK   0x00
#define EFI_BLUE    0x01
#define EFI_GREEN   0x02
#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
#define EFI_RED     0x04
#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
#define EFI_BROWN           (EFI_GREEN | EFI_RED)
#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
#define EFI_BRIGHT  0x08
#define EFI_DARKGRAY        (EFI_BRIGHT)
#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)

#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))

#define EFI_BACKGROUND_BLACK        0x00
#define EFI_BACKGROUND_BLUE         0x10
#define EFI_BACKGROUND_GREEN        0x20
#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
#define EFI_BACKGROUND_RED          0x40
#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)


typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Column,
    IN UINTN                        Row
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      Enable
    );

typedef struct {
    INT32                           MaxMode;
    /*  current settings */
    INT32                           Mode;
    INT32                           Attribute;
    INT32                           CursorColumn;
    INT32                           CursorRow;
    BOOLEAN                         CursorVisible;
} SIMPLE_TEXT_OUTPUT_MODE;

typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
    EFI_TEXT_RESET                  Reset;

    EFI_TEXT_OUTPUT_STRING          OutputString;
    EFI_TEXT_TEST_STRING            TestString;

    EFI_TEXT_QUERY_MODE             QueryMode;
    EFI_TEXT_SET_MODE               SetMode;
    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;

    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
    EFI_TEXT_ENABLE_CURSOR          EnableCursor;

    /*  Current mode */
    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
} SIMPLE_TEXT_OUTPUT_INTERFACE;

/* 
 *  Define's for required EFI Unicode Box Draw character
 */

#define BOXDRAW_HORIZONTAL                  0x2500
#define BOXDRAW_VERTICAL                    0x2502
#define BOXDRAW_DOWN_RIGHT                  0x250c
#define BOXDRAW_DOWN_LEFT                   0x2510
#define BOXDRAW_UP_RIGHT                    0x2514
#define BOXDRAW_UP_LEFT                     0x2518
#define BOXDRAW_VERTICAL_RIGHT              0x251c
#define BOXDRAW_VERTICAL_LEFT               0x2524
#define BOXDRAW_DOWN_HORIZONTAL             0x252c
#define BOXDRAW_UP_HORIZONTAL               0x2534
#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c

#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
#define BOXDRAW_DOUBLE_VERTICAL             0x2551
#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554

#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557

#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a

#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
#define BOXDRAW_DOUBLE_UP_LEFT              0x255d

#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560

#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563

#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566

#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569

#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c

/* 
 *  EFI Required Block Elements Code Chart
 */

#define BLOCKELEMENT_FULL_BLOCK             0x2588
#define BLOCKELEMENT_LIGHT_SHADE            0x2591
/* 
 *  EFI Required Geometric Shapes Code Chart
 */

#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4

/* 
 *  EFI Required Arrow shapes
 */

#define ARROW_UP                            0x2191
#define ARROW_DOWN                          0x2193

/* 
 *  Text input protocol
 */

#define SIMPLE_TEXT_INPUT_PROTOCOL  \
    { 0x387477c1, 0x69c7, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);

typedef struct {
    UINT16                              ScanCode;
    CHAR16                              UnicodeChar;
} EFI_INPUT_KEY;

/* 
 *  Baseline unicode control chars
 */

#define CHAR_NULL                       0x0000
#define CHAR_BACKSPACE                  0x0008
#define CHAR_TAB                        0x0009
#define CHAR_LINEFEED                   0x000A
#define CHAR_CARRIAGE_RETURN            0x000D

/* 
 *  Scan codes for base line keys
 */

#define SCAN_NULL                       0x0000
#define SCAN_UP                         0x0001
#define SCAN_DOWN                       0x0002
#define SCAN_RIGHT                      0x0003
#define SCAN_LEFT                       0x0004
#define SCAN_HOME                       0x0005
#define SCAN_END                        0x0006
#define SCAN_INSERT                     0x0007
#define SCAN_DELETE                     0x0008
#define SCAN_PAGE_UP                    0x0009
#define SCAN_PAGE_DOWN                  0x000A
#define SCAN_F1                         0x000B
#define SCAN_F2                         0x000C
#define SCAN_F3                         0x000D
#define SCAN_F4                         0x000E
#define SCAN_F5                         0x000F
#define SCAN_F6                         0x0010
#define SCAN_F7                         0x0011
#define SCAN_F8                         0x0012
#define SCAN_F9                         0x0013
#define SCAN_F10                        0x0014
#define SCAN_ESC                        0x0017

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_RESET) (
    IN struct _SIMPLE_INPUT_INTERFACE   *This,
    IN BOOLEAN                          ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_READ_KEY) (
    IN struct _SIMPLE_INPUT_INTERFACE   *This,
    OUT EFI_INPUT_KEY                   *Key
    );

typedef struct _SIMPLE_INPUT_INTERFACE {
    EFI_INPUT_RESET                     Reset;
    EFI_INPUT_READ_KEY                  ReadKeyStroke;
    EFI_EVENT                           WaitForKey;
} SIMPLE_INPUT_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efiapi.h ===
#ifndef _EFI_API_H
#define _EFI_API_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiapi.h

Abstract:

    Global EFI runtime & boot service interfaces




Revision History

--*/

/* 
 *  EFI Specification Revision
 */

#define EFI_SPECIFICATION_MAJOR_REVISION 0
#define EFI_SPECIFICATION_MINOR_REVISION 99

/* 
 *  Declare forward referenced data structures
 */

INTERFACE_DECL(_EFI_SYSTEM_TABLE);

/* 
 *  EFI Memory
 */

typedef
EFI_STATUS
(EFIAPI *EFI_ALLOCATE_PAGES) (
    IN EFI_ALLOCATE_TYPE            Type,
    IN EFI_MEMORY_TYPE              MemoryType,
    IN UINTN                        NoPages,
    OUT EFI_PHYSICAL_ADDRESS        *Memory
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FREE_PAGES) (
    IN EFI_PHYSICAL_ADDRESS         Memory,
    IN UINTN                        NoPages
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_MEMORY_MAP) (
    IN OUT UINTN                    *MemoryMapSize,
    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
    OUT UINTN                       *MapKey,
    OUT UINTN                       *DescriptorSize,
    OUT UINT32                      *DescriptorVersion
    );

#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))


typedef
EFI_STATUS
(EFIAPI *EFI_ALLOCATE_POOL) (
    IN EFI_MEMORY_TYPE              PoolType,
    IN UINTN                        Size,
    OUT VOID                        **Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FREE_POOL) (
    IN VOID                         *Buffer
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
    IN UINTN                        MemoryMapSize,
    IN UINTN                        DescriptorSize,
    IN UINT32                       DescriptorVersion,
    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
    );


#define EFI_OPTIONAL_PTR            0x00000001
#define EFI_INTERNAL_FNC            0x00000002      /*  Pointer to internal runtime fnc */
#define EFI_INTERNAL_PTR            0x00000004      /*  Pointer to internal runtime data */


typedef 
EFI_STATUS
(EFIAPI *EFI_CONVERT_POINTER) (
    IN UINTN                        DebugDisposition,
    IN OUT VOID                     **Address
    );


/* 
 *  EFI Events
 */



#define EVT_TIMER                           0x80000000
#define EVT_RUNTIME                         0x40000000
#define EVT_RUNTIME_CONTEXT                 0x20000000

#define EVT_NOTIFY_WAIT                     0x00000100
#define EVT_NOTIFY_SIGNAL                   0x00000200

#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202

#define EVT_EFI_SIGNAL_MASK                 0x000000FF
#define EVT_EFI_SIGNAL_MAX                  2

typedef
VOID
(EFIAPI *EFI_EVENT_NOTIFY) (
    IN EFI_EVENT                Event,
    IN VOID                     *Context
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CREATE_EVENT) (
    IN UINT32                       Type,
    IN EFI_TPL                      NotifyTpl,
    IN EFI_EVENT_NOTIFY             NotifyFunction,
    IN VOID                         *NotifyContext,
    OUT EFI_EVENT                   *Event
    );

typedef enum {
    TimerCancel,
    TimerPeriodic,
    TimerRelative,
    TimerTypeMax
} EFI_TIMER_DELAY;

typedef
EFI_STATUS
(EFIAPI *EFI_SET_TIMER) (
    IN EFI_EVENT                Event,
    IN EFI_TIMER_DELAY          Type,
    IN UINT64                   TriggerTime
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SIGNAL_EVENT) (
    IN EFI_EVENT                Event
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_WAIT_FOR_EVENT) (
    IN UINTN                    NumberOfEvents,
    IN EFI_EVENT                *Event,
    OUT UINTN                   *Index
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CLOSE_EVENT) (
    IN EFI_EVENT                Event
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CHECK_EVENT) (
    IN EFI_EVENT                Event
    );

/* 
 *  Task priority level
 */

#define TPL_APPLICATION    4
#define TPL_CALLBACK       8
#define TPL_NOTIFY        16 
#define TPL_HIGH_LEVEL    31 

typedef
EFI_TPL
(EFIAPI *EFI_RAISE_TPL) (
    IN EFI_TPL      NewTpl
    );

typedef
VOID
(EFIAPI *EFI_RESTORE_TPL) (
    IN EFI_TPL      OldTpl
    );


/* 
 *  EFI platform varibles
 */

#define EFI_GLOBAL_VARIABLE     \
    { 0x8BE4DF61, 0x93CA, 0x11d2, 0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C }

/*  Variable attributes */
#define EFI_VARIABLE_NON_VOLATILE           0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004


typedef
EFI_STATUS
(EFIAPI *EFI_GET_VARIABLE) (
    IN CHAR16                       *VariableName,
    IN EFI_GUID                     *VendorGuid,
    OUT UINT32                      *Attributes OPTIONAL,
    IN OUT UINTN                    *DataSize,
    OUT VOID                        *Data
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
    IN OUT UINTN                    *VariableNameSize,
    IN OUT CHAR16                   *VariableName,
    IN OUT EFI_GUID                 *VendorGuid
    );


typedef
EFI_STATUS
(EFIAPI *EFI_SET_VARIABLE) (
    IN CHAR16                       *VariableName,
    IN EFI_GUID                     *VendorGuid,
    IN UINT32                       Attributes,
    IN UINTN                        DataSize,
    IN VOID                         *Data
    );


/* 
 *  EFI Time
 */

typedef struct {
        UINT32                      Resolution;     /*  1e-6 parts per million */
        UINT32                      Accuracy;       /*  hertz */
        BOOLEAN                     SetsToZero;     /*  Set clears sub-second time */
} EFI_TIME_CAPABILITIES;


typedef
EFI_STATUS
(EFIAPI *EFI_GET_TIME) (
    OUT EFI_TIME                    *Time,
    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_TIME) (
    IN EFI_TIME                     *Time
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_WAKEUP_TIME) (
    OUT BOOLEAN                     *Enabled,
    OUT BOOLEAN                     *Pending,
    OUT EFI_TIME                    *Time
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_WAKEUP_TIME) (
    IN BOOLEAN                      Enable,
    IN EFI_TIME                     *Time OPTIONAL
    );


/* 
 *  Image functions
 */


/*  PE32+ Subsystem type for EFI images */

#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
#endif

/*  PE32+ Machine type for EFI images */

#if !defined(EFI_IMAGE_MACHINE_IA32)
#define EFI_IMAGE_MACHINE_IA32      0x014c
#endif

#if !defined(EFI_IMAGE_MACHINE_IA64)
#define EFI_IMAGE_MACHINE_IA64      0x0200
#endif

/*  Image Entry prototype */

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
    IN EFI_HANDLE                   ImageHandle,
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_LOAD) (
    IN BOOLEAN                      BootPolicy,
    IN EFI_HANDLE                   ParentImageHandle,
    IN EFI_DEVICE_PATH              *FilePath,
    IN VOID                         *SourceBuffer   OPTIONAL,
    IN UINTN                        SourceSize,
    OUT EFI_HANDLE                  *ImageHandle
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_START) (
    IN EFI_HANDLE                   ImageHandle,
    OUT UINTN                       *ExitDataSize,
    OUT CHAR16                      **ExitData  OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_EXIT) (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_STATUS                   ExitStatus,
    IN UINTN                        ExitDataSize,
    IN CHAR16                       *ExitData OPTIONAL
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_UNLOAD) (
    IN EFI_HANDLE                   ImageHandle
    );


/*  Image handle */
#define LOADED_IMAGE_PROTOCOL      \
    { 0x5B1B31A1, 0x9562, 0x11d2, 0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }

#define EFI_IMAGE_INFORMATION_REVISION      0x1000
typedef struct {
    UINT32                          Revision;
    EFI_HANDLE                      ParentHandle;
    struct _EFI_SYSTEM_TABLE        *SystemTable;

    /*  Source location of image */
    EFI_HANDLE                      DeviceHandle;
    EFI_DEVICE_PATH                 *FilePath;
    VOID                            *Reserved;

    /*  Images load options */
    UINT32                          LoadOptionsSize;
    VOID                            *LoadOptions;

    /*  Location of where image was loaded */
    VOID                            *ImageBase;
    UINT64                          ImageSize;
    EFI_MEMORY_TYPE                 ImageCodeType;
    EFI_MEMORY_TYPE                 ImageDataType;

    /*  If the driver image supports a dynamic unload request */
    EFI_IMAGE_UNLOAD                Unload;

} EFI_LOADED_IMAGE;


typedef
EFI_STATUS
(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
    IN EFI_HANDLE                   ImageHandle,
    IN UINTN                        MapKey
    );

/* 
 *  Misc
 */


typedef
EFI_STATUS
(EFIAPI *EFI_STALL) (
    IN UINTN                    Microseconds
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
    IN UINTN                    Timeout,
    IN UINT64                   WatchdogCode,
    IN UINTN                    DataSize,
    IN CHAR16                   *WatchdogData OPTIONAL
    );


typedef enum {
    EfiResetCold,
    EfiResetWarm
} EFI_RESET_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_RESET_SYSTEM) (
    IN EFI_RESET_TYPE           ResetType,
    IN EFI_STATUS               ResetStatus,
    IN UINTN                    DataSize,
    IN CHAR16                   *ResetData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
    OUT UINT64                  *Count
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
    OUT UINT32                  *HighCount
    );

/* 
 *  Protocol handler functions
 */

typedef enum {
    EFI_NATIVE_INTERFACE,
    EFI_PCODE_INTERFACE
} EFI_INTERFACE_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
    IN OUT EFI_HANDLE           *Handle,
    IN EFI_GUID                 *Protocol,
    IN EFI_INTERFACE_TYPE       InterfaceType,
    IN VOID                     *Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN VOID                     *OldInterface,
    IN VOID                     *NewInterface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN VOID                     *Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_HANDLE_PROTOCOL) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    OUT VOID                    **Interface
    );

typedef
EFI_STATUS 
(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
    IN EFI_GUID                 *Protocol,
    IN EFI_EVENT                Event,
    OUT VOID                    **Registration
    );

typedef enum {
    AllHandles,
    ByRegisterNotify,
    ByProtocol
} EFI_LOCATE_SEARCH_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_HANDLE) (
    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
    IN EFI_GUID                 *Protocol OPTIONAL,
    IN VOID                     *SearchKey OPTIONAL,
    IN OUT UINTN                *BufferSize,
    OUT EFI_HANDLE              *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
    IN EFI_GUID                 *Protocol,
    IN OUT EFI_DEVICE_PATH      **DevicePath,
    OUT EFI_HANDLE              *Device
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
    IN EFI_GUID                 *Guid,
    IN VOID                     *Table
    );

typedef
EFI_STATUS
(EFIAPI *EFI_RESERVED_SERVICE) (
    );

/* 
 *  Standard EFI table header
 */

typedef struct _EFI_TABLE_HEARDER {
    UINT64                      Signature;
    UINT32                      Revision;
    UINT32                      HeaderSize;
    UINT32                      CRC32;
    UINT32                      Reserved;
} EFI_TABLE_HEADER;


/* 
 *  EFI Runtime Serivces Table
 */

#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
#define EFI_RUNTIME_SERVICES_REVISION   (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct  {
    EFI_TABLE_HEADER                Hdr;

    /* 
     *  Time services
     */

    EFI_GET_TIME                    GetTime;
    EFI_SET_TIME                    SetTime;
    EFI_GET_WAKEUP_TIME             GetWakeupTime;
    EFI_SET_WAKEUP_TIME             SetWakeupTime;

    /* 
     *  Virtual memory services
     */

    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
    EFI_CONVERT_POINTER             ConvertPointer;

    /* 
     *  Variable serviers
     */

    EFI_GET_VARIABLE                GetVariable;
    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
    EFI_SET_VARIABLE                SetVariable;

    /* 
     *  Misc
     */

    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
    EFI_RESET_SYSTEM                ResetSystem;

} EFI_RUNTIME_SERVICES;


/* 
 *  EFI Boot Services Table
 */

#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct _EFI_BOOT_SERVICES {

    EFI_TABLE_HEADER                Hdr;

    /* 
     *  Task priority functions
     */

    EFI_RAISE_TPL                   RaiseTPL;
    EFI_RESTORE_TPL                 RestoreTPL;

    /* 
     *  Memory functions
     */

    EFI_ALLOCATE_PAGES              AllocatePages;
    EFI_FREE_PAGES                  FreePages;
    EFI_GET_MEMORY_MAP              GetMemoryMap;
    EFI_ALLOCATE_POOL               AllocatePool;
    EFI_FREE_POOL                   FreePool;

    /* 
     *  Event & timer functions
     */

    EFI_CREATE_EVENT                CreateEvent;
    EFI_SET_TIMER                   SetTimer;
    EFI_WAIT_FOR_EVENT              WaitForEvent;
    EFI_SIGNAL_EVENT                SignalEvent;
    EFI_CLOSE_EVENT                 CloseEvent;
    EFI_CHECK_EVENT                 CheckEvent;

    /* 
     *  Protocol handler functions
     */

    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
    EFI_HANDLE_PROTOCOL             HandleProtocol;
    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
    EFI_LOCATE_HANDLE               LocateHandle;
    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;

    /* 
     *  Image functions
     */

    EFI_IMAGE_LOAD                  LoadImage;
    EFI_IMAGE_START                 StartImage;
    EFI_EXIT                        Exit;
    EFI_IMAGE_UNLOAD                UnloadImage;
    EFI_EXIT_BOOT_SERVICES          ExitBootServices;

    /* 
     *  Misc functions
     */

    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
    EFI_STALL                       Stall;
    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;

} EFI_BOOT_SERVICES;


/* 
 *  EFI Configuration Table and GUID definitions
 */

#define MPS_TABLE_GUID    \
    { 0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define ACPI_TABLE_GUID    \
    { 0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define ACPI_20_TABLE_GUID  \
    { 0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }

#define SMBIOS_TABLE_GUID    \
    { 0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define SAL_SYSTEM_TABLE_GUID    \
    { 0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }


typedef struct _EFI_CONFIGURATION_TABLE {
    EFI_GUID                VendorGuid;
    VOID                    *VendorTable;
} EFI_CONFIGURATION_TABLE;


/* 
 *  EFI System Table
 */




#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct _EFI_SYSTEM_TABLE {
    EFI_TABLE_HEADER                Hdr;

    CHAR16                          *FirmwareVendor;
    UINT32                          FirmwareRevision;

    EFI_HANDLE                      ConsoleInHandle;
    SIMPLE_INPUT_INTERFACE          *ConIn;

    EFI_HANDLE                      ConsoleOutHandle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;

    EFI_HANDLE                      StandardErrorHandle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;

    EFI_RUNTIME_SERVICES            *RuntimeServices;
    EFI_BOOT_SERVICES               *BootServices;

    UINTN                           NumberOfTableEntries;
    EFI_CONFIGURATION_TABLE         *ConfigurationTable;

} EFI_SYSTEM_TABLE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efierr.h ===
#ifndef _EFI_ERR_H
#define _EFI_ERR_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efierr.h

Abstract:

    EFI error codes




Revision History

--*/


#define EFIWARN(a)                            (a)
#define EFI_ERROR(a)              (((INTN) a) < 0)


#define EFI_SUCCESS                             0
#define EFI_LOAD_ERROR                  EFIERR(1)
#define EFI_INVALID_PARAMETER           EFIERR(2)
#define EFI_UNSUPPORTED                 EFIERR(3)
#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
#define EFI_NOT_READY                   EFIERR(6)
#define EFI_DEVICE_ERROR                EFIERR(7)
#define EFI_WRITE_PROTECTED             EFIERR(8)
#define EFI_OUT_OF_RESOURCES            EFIERR(9)
#define EFI_VOLUME_CORRUPTED            EFIERR(10)
#define EFI_VOLUME_FULL                 EFIERR(11)
#define EFI_NO_MEDIA                    EFIERR(12)
#define EFI_MEDIA_CHANGED               EFIERR(13)
#define EFI_NOT_FOUND                   EFIERR(14)
#define EFI_ACCESS_DENIED               EFIERR(15)
#define EFI_NO_RESPONSE                 EFIERR(16)
#define EFI_NO_MAPPING                  EFIERR(17)
#define EFI_TIMEOUT                     EFIERR(18)
#define EFI_NOT_STARTED                 EFIERR(19)
#define EFI_ALREADY_STARTED             EFIERR(20)
#define EFI_ABORTED                     EFIERR(21)
#define EFI_ICMP_ERROR                  EFIERR(22)
#define EFI_TFTP_ERROR                  EFIERR(23)
#define EFI_PROTOCOL_ERROR              EFIERR(24)

#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efifs.h ===
#ifndef _EFI_FS_H
#define _EFI_FS_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efifs.h

Abstract:

    EFI File System structures



Revision History

--*/


/* 
 *  EFI Partition header (normaly starts in LBA 1)
 */

#define EFI_PARTITION_SIGNATURE         0x5053595320494249
#define EFI_PARTITION_REVISION          0x00010001
#define MIN_EFI_PARTITION_BLOCK_SIZE    512
#define EFI_PARTITION_LBA               1

typedef struct _EFI_PARTITION_HEADER {
    EFI_TABLE_HEADER    Hdr;
    UINT32              DirectoryAllocationNumber;
    UINT32              BlockSize;
    EFI_LBA             FirstUsableLba;
    EFI_LBA             LastUsableLba;
    EFI_LBA             UnusableSpace;
    EFI_LBA             FreeSpace;
    EFI_LBA             RootFile;
    EFI_LBA             SecutiryFile;
} EFI_PARTITION_HEADER;


/* 
 *  File header
 */

#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
#define EFI_FILE_HEADER_REVISION    0x00010000
#define EFI_FILE_STRING_SIZE        260

typedef struct _EFI_FILE_HEADER {
    EFI_TABLE_HEADER    Hdr;
    UINT32              Class;
    UINT32              LBALOffset;
    EFI_LBA             Parent;
    UINT64              FileSize;
    UINT64              FileAttributes;
    EFI_TIME            FileCreateTime;
    EFI_TIME            FileModificationTime;
    EFI_GUID            VendorGuid;
    CHAR16              FileString[EFI_FILE_STRING_SIZE];
} EFI_FILE_HEADER;


/* 
 *  Return the file's first LBAL which is in the same
 *  logical block as the file header
 */

#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))

#define EFI_FILE_CLASS_FREE_SPACE   1
#define EFI_FILE_CLASS_EMPTY        2
#define EFI_FILE_CLASS_NORMAL       3


/* 
 *  Logical Block Address List - the fundemental block
 *  description structure
 */

#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
#define EFI_LBAL_REVISION       0x00010000

typedef struct _EFI_LBAL {
    EFI_TABLE_HEADER    Hdr;
    UINT32              Class;
    EFI_LBA             Parent;
    EFI_LBA             Next;
    UINT32              ArraySize;
    UINT32              ArrayCount;
} EFI_LBAL;

/*  Array size  */
#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))

/* 
 *  Logical Block run-length
 */

typedef struct {
    EFI_LBA     Start;
    UINT64      Length;
} EFI_RL;

/* 
 *  Return the run-length structure from an LBAL header
 */

#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efidevp.h ===
#ifndef _DEVPATH_H
#define _DEVPATH_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    devpath.h

Abstract:

    Defines for parsing the EFI Device Path structures



Revision History

--*/

/* 
 *  Device Path structures - Section C
 */

typedef struct _EFI_DEVICE_PATH {
        UINT8                           Type;
        UINT8                           SubType;
        UINT8                           Length[2];
} EFI_DEVICE_PATH;

#define EFI_DP_TYPE_MASK                    0x7F
#define EFI_DP_TYPE_UNPACKED                0x80

/* #define END_DEVICE_PATH_TYPE                0xff */
#define END_DEVICE_PATH_TYPE                0x7f
/* #define END_DEVICE_PATH_TYPE_UNPACKED       0x7f */

#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH))


#define DP_IS_END_TYPE(a)
#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )

#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
#define DevicePathSubType(a)        ( (a)->SubType )
#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
/* #define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED ) */
#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )


#define SetDevicePathNodeLength(a,l) {                  \
            (a)->Length[0] = (UINT8) (l);               \
            (a)->Length[1] = (UINT8) ((l) >> 8);        \
            }

#define SetDevicePathEndNode(a)  {                      \
            (a)->Type = END_DEVICE_PATH_TYPE;           \
            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
            (a)->Length[0] = sizeof(EFI_DEVICE_PATH);   \
            (a)->Length[1] = 0;                         \
            }



/*
 *
 */
#define HARDWARE_DEVICE_PATH            0x01

#define HW_PCI_DP                       0x01
typedef struct _PCI_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           Function;
        UINT8                           Device;
} PCI_DEVICE_PATH;

#define HW_PCCARD_DP                    0x02
typedef struct _PCCARD_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           SocketNumber;
} PCCARD_DEVICE_PATH;

#define HW_MEMMAP_DP                    0x03
typedef struct _MEMMAP_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          MemoryType;
        EFI_PHYSICAL_ADDRESS            StartingAddress;
        EFI_PHYSICAL_ADDRESS            EndingAddress;
} MEMMAP_DEVICE_PATH;

#define HW_VENDOR_DP                    0x04
typedef struct _VENDOR_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_GUID                        Guid;
} VENDOR_DEVICE_PATH;

#define UNKNOWN_DEVICE_GUID \
    { 0xcf31fac5, 0xc24e, 0x11d2,  0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b  }

typedef struct _UKNOWN_DEVICE_VENDOR_DP {
    VENDOR_DEVICE_PATH      DevicePath;
    UINT8                   LegacyDriveLetter;
} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;

#define HW_CONTROLLER_DP            0x05
typedef struct _CONTROLLER_DEVICE_PATH {
        EFI_DEVICE_PATH     Header;
        UINT32              Controller;
} CONTROLLER_DEVICE_PATH;

/*
 *
 */
#define ACPI_DEVICE_PATH                 0x02

#define ACPI_DP                         0x01
typedef struct _ACPI_HID_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          HID;
        UINT32                          UID;
} ACPI_HID_DEVICE_PATH;

/* 
 *  EISA ID Macro
 *  EISA ID Definition 32-bits
 *   bits[15:0] - three character compressed ASCII EISA ID.
 *   bits[31:16] - binary number
 *    Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
 */
#define PNP_EISA_ID_CONST       0x41d0    
#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))

#define PNP_EISA_ID_MASK        0xffff
#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
/*
 *
 */
#define MESSAGING_DEVICE_PATH           0x03 

#define MSG_ATAPI_DP                    0x01
typedef struct _ATAPI_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           PrimarySecondary;
        UINT8                           SlaveMaster;
        UINT16                          Lun;
} ATAPI_DEVICE_PATH;

#define MSG_SCSI_DP                     0x02
typedef struct _SCSI_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT16                          Pun;
        UINT16                          Lun; 
} SCSI_DEVICE_PATH;

#define MSG_FIBRECHANNEL_DP             0x03
typedef struct _FIBRECHANNEL_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          Reserved;
        UINT64                          WWN;
} FIBRECHANNEL_DEVICE_PATH;

#define MSG_1394_DP                     0x04
typedef struct _F1394_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          Reserved;
        UINT64                          Guid;
} F1394_DEVICE_PATH;

#define MSG_USB_DP                      0x05
typedef struct _USB_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           Port;
        UINT8                           Reserved[3];
        UINT64                          Guid;
} USB_DEVICE_PATH;

#define MSG_I2O_DP                      0x06
typedef struct _I2O_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          Tid;
} I2O_DEVICE_PATH;

#define MSG_MAC_ADDR_DP                 0x0b
typedef struct _MAC_ADDR_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_MAC_ADDRESS                 MacAddress;
        UINT8                           IfType;
} MAC_ADDR_DEVICE_PATH;

#define MSG_IPv4_DP                     0x0c
typedef struct _IPv4_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_IPv4_ADDRESS                LocalIpAddress;
        EFI_IPv4_ADDRESS                RemoteIpAddress;
        UINT16                          LocalPort;
        UINT16                          RemotePort;
        UINT16                          Protocol;
        BOOLEAN                         StaticIpAddress;
} IPv4_DEVICE_PATH;

#define MSG_IPv6_DP                     0x0d
typedef struct _IPv6_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_IPv6_ADDRESS                LocalIpAddress;
        EFI_IPv6_ADDRESS                RemoteIpAddress;
        UINT16                          LocalPort;
        UINT16                          RemotePort;
        UINT16                          Protocol;
        BOOLEAN                         StaticIpAddress;
} IPv6_DEVICE_PATH;

#define MSG_INFINIBAND_DP               0x09
typedef struct _INFINIBAND_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
} INFINIBAND_DEVICE_PATH;

#define MSG_UART_DP                     0x0e
typedef struct _UART_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT64                          BaudRate;
        UINT8                           DataBits;
        UINT8                           Parity;
        UINT8                           StopBits;
} UART_DEVICE_PATH;

#define MSG_VENDOR_DP                   0x0A
/* Use VENDOR_DEVICE_PATH struct */

#define DEVICE_PATH_MESSAGING_PC_ANSI \
    { 0xe0c14753, 0xf9be, 0x11d2,  0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d  }

#define DEVICE_PATH_MESSAGING_VT_100 \
    { 0xdfa66065, 0xb419, 0x11d3,  0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d  }



#define MEDIA_DEVICE_PATH               0x04

#define MEDIA_HARDDRIVE_DP              0x01
typedef struct _HARDDRIVE_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          PartitionNumber;
        UINT64                          PartitionStart;
        UINT64                          PartitionSize;
        UINT8                           Signature[16];
        UINT8                           MBRType;
        UINT8                           SignatureType;
} HARDDRIVE_DEVICE_PATH;

#define MBR_TYPE_PCAT                       0x01
#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02

#define SIGNATURE_TYPE_MBR                  0x01
#define SIGNATURE_TYPE_GUID                 0x02

#define MEDIA_CDROM_DP                  0x02
typedef struct _CDROM_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          BootEntry;
        UINT64                          PartitionStart;
        UINT64                          PartitionSize;
} CDROM_DEVICE_PATH;

#define MEDIA_VENDOR_DP                 0x03
/* Use VENDOR_DEVICE_PATH struct */

#define MEDIA_FILEPATH_DP               0x04
typedef struct _FILEPATH_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        CHAR16                          PathName[1];
} FILEPATH_DEVICE_PATH;

#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)

#define MEDIA_PROTOCOL_DP               0x05
typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_GUID                        Protocol;
} MEDIA_PROTOCOL_DEVICE_PATH;


#define BBS_DEVICE_PATH                 0x05
#define BBS_BBS_DP                      0x01
typedef struct _BBS_BBS_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT16                          DeviceType;
        UINT16                          StatusFlag;
        CHAR8                           String[1];
} BBS_BBS_DEVICE_PATH;

/* DeviceType definitions - from BBS specification */
#define BBS_TYPE_FLOPPY                 0x01
#define BBS_TYPE_HARDDRIVE              0x02
#define BBS_TYPE_CDROM                  0x03
#define BBS_TYPE_PCMCIA                 0x04
#define BBS_TYPE_USB                    0x05
#define BBS_TYPE_EMBEDDED_NETWORK       0x06
#define BBS_TYPE_DEV                    0x80
#define BBS_TYPE_UNKNOWN                0xFF

typedef union {
    EFI_DEVICE_PATH                      DevPath;
    PCI_DEVICE_PATH                      Pci;
    PCCARD_DEVICE_PATH                   PcCard;
    MEMMAP_DEVICE_PATH                   MemMap;
    VENDOR_DEVICE_PATH                   Vendor;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;   
    CONTROLLER_DEVICE_PATH               Controller;
    ACPI_HID_DEVICE_PATH                 Acpi;

    ATAPI_DEVICE_PATH                    Atapi;
    SCSI_DEVICE_PATH                     Scsi;
    FIBRECHANNEL_DEVICE_PATH             FibreChannel;

    F1394_DEVICE_PATH                    F1394;
    USB_DEVICE_PATH                      Usb;
    I2O_DEVICE_PATH                      I2O;
    MAC_ADDR_DEVICE_PATH                 MacAddr;
    IPv4_DEVICE_PATH                     Ipv4;
    IPv6_DEVICE_PATH                     Ipv6;
    INFINIBAND_DEVICE_PATH               InfiniBand;
    UART_DEVICE_PATH                     Uart;

    HARDDRIVE_DEVICE_PATH                HardDrive;
    CDROM_DEVICE_PATH                    CD;

    FILEPATH_DEVICE_PATH                 FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;

    BBS_BBS_DEVICE_PATH                  Bbs;

} EFI_DEV_PATH;

typedef union {
    EFI_DEVICE_PATH                      *DevPath;
    PCI_DEVICE_PATH                      *Pci;
    PCCARD_DEVICE_PATH                   *PcCard;
    MEMMAP_DEVICE_PATH                   *MemMap;
    VENDOR_DEVICE_PATH                   *Vendor;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
    CONTROLLER_DEVICE_PATH               *Controller;
    ACPI_HID_DEVICE_PATH                 *Acpi;

    ATAPI_DEVICE_PATH                    *Atapi;
    SCSI_DEVICE_PATH                     *Scsi;
    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;

    F1394_DEVICE_PATH                    *F1394;
    USB_DEVICE_PATH                      *Usb;
    I2O_DEVICE_PATH                      *I2O;
    MAC_ADDR_DEVICE_PATH                 *MacAddr;
    IPv4_DEVICE_PATH                     *Ipv4;
    IPv6_DEVICE_PATH                     *Ipv6;
    INFINIBAND_DEVICE_PATH               *InfiniBand;
    UART_DEVICE_PATH                     *Uart;

    HARDDRIVE_DEVICE_PATH                *HardDrive;

    FILEPATH_DEVICE_PATH                 *FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;

    CDROM_DEVICE_PATH                    *CD;
    BBS_BBS_DEVICE_PATH                  *Bbs;

} EFI_DEV_PATH_PTR;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efidef.h ===
#ifndef _EFI_DEF_H
#define _EFI_DEF_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efidef.h

Abstract:

    EFI definitions




Revision History

--*/

typedef UINT16          CHAR16;
typedef UINT8           CHAR8;
typedef UINT8           BOOLEAN;

#ifndef TRUE
    #define TRUE    ((BOOLEAN) 1)
    #define FALSE   ((BOOLEAN) 0)
#endif

#ifndef NULL
    #define NULL    ((VOID *) 0)
#endif

typedef UINTN           EFI_STATUS;
typedef UINT64          EFI_LBA;
typedef UINTN           EFI_TPL;
typedef VOID            *EFI_HANDLE;
typedef VOID            *EFI_EVENT;


/* 
 *  Prototype argument decoration for EFI parameters to indicate
 *  their direction
 * 
 *  IN - argument is passed into the function
 *  OUT - argument (pointer) is returned from the function
 *  OPTIONAL - argument is optional
 */

#ifndef IN
    #define IN
    #define OUT
    #define OPTIONAL
#endif


/* 
 *  A GUID
 */

typedef struct {          
    UINT32  Data1;
    UINT16  Data2;
    UINT16  Data3;
    UINT8   Data4[8]; 
} EFI_GUID;


/* 
 *  Time
 */

typedef struct {          
    UINT16      Year;       /*  1998 - 20XX */
    UINT8       Month;      /*  1 - 12 */
    UINT8       Day;        /*  1 - 31 */
    UINT8       Hour;       /*  0 - 23 */
    UINT8       Minute;     /*  0 - 59 */
    UINT8       Second;     /*  0 - 59 */
    UINT8       Pad1;
    UINT32      Nanosecond; /*  0 - 999,999,999 */
    INT16       TimeZone;   /*  -1440 to 1440 or 2047 */
    UINT8       Daylight;
    UINT8       Pad2;
} EFI_TIME;

/*  Bit definitions for EFI_TIME.Daylight */
#define EFI_TIME_ADJUST_DAYLIGHT    0x01
#define EFI_TIME_IN_DAYLIGHT        0x02

/*  Value definition for EFI_TIME.TimeZone */
#define EFI_UNSPECIFIED_TIMEZONE    0x07FF



/* 
 *  Networking
 */

typedef struct {
    UINT8                   Addr[4];
} EFI_IPv4_ADDRESS;

typedef struct {
    UINT8                   Addr[16];
} EFI_IPv6_ADDRESS;

typedef struct {
    UINT8                   Addr[32];
} EFI_MAC_ADDRESS;

/* 
 *  Memory
 */

typedef UINT64          EFI_PHYSICAL_ADDRESS;
typedef UINT64          EFI_VIRTUAL_ADDRESS;

typedef enum {
    AllocateAnyPages,
    AllocateMaxAddress,
    AllocateAddress,
    MaxAllocateType
} EFI_ALLOCATE_TYPE;

/* Preseve the attr on any range supplied.
 * ConventialMemory must have WB,SR,SW when supplied.
 * When allocating from ConventialMemory always make it WB,SR,SW
 * When returning to ConventialMemory always make it WB,SR,SW
 * When getting the memory map, or on RT for runtime types */


typedef enum {
    EfiReservedMemoryType,
    EfiLoaderCode,
    EfiLoaderData,
    EfiBootServicesCode,
    EfiBootServicesData,
    EfiRuntimeServicesCode,
    EfiRuntimeServicesData,
    EfiConventionalMemory,
    EfiUnusableMemory,
    EfiACPIReclaimMemory,
    EfiACPIMemoryNVS,
    EfiMemoryMappedIO,
    EfiMemoryMappedIOPortSpace,
    EfiPalCode,
    EfiMaxMemoryType
} EFI_MEMORY_TYPE;

/*  possible caching types for the memory range */
#define EFI_MEMORY_UC           0x0000000000000001
#define EFI_MEMORY_WC           0x0000000000000002
#define EFI_MEMORY_WT           0x0000000000000004
#define EFI_MEMORY_WB           0x0000000000000008
#define EFI_MEMORY_UCE          0x0000000000000010  

/*  physical memory protection on range  */
#define EFI_MEMORY_WP           0x0000000000001000
#define EFI_MEMORY_RP           0x0000000000002000
#define EFI_MEMORY_XP           0x0000000000004000

/*  range requires a runtime mapping */
#define EFI_MEMORY_RUNTIME      0x8000000000000000

#define EFI_MEMORY_DESCRIPTOR_VERSION  1
typedef struct {
    UINT32                          Type;           /*  Field size is 32 bits followed by 32 bit pad */
    EFI_PHYSICAL_ADDRESS            PhysicalStart;  /*  Field size is 64 bits */
    EFI_VIRTUAL_ADDRESS             VirtualStart;   /*  Field size is 64 bits */
    UINT64                          NumberOfPages;  /*  Field size is 64 bits */
    UINT64                          Attribute;      /*  Field size is 64 bits */
} EFI_MEMORY_DESCRIPTOR;

/* 
 *  International Language
 */

typedef UINT8   ISO_639_2;
#define ISO_639_2_ENTRY_SIZE    3

/* 
 * 
 */

#define PAGE_SIZE   4096
#define PAGE_MASK   0xFFF
#define PAGE_SHIFT  12

#define SIZE_TO_PAGES(a)  \
    ( ((a) >> PAGE_SHIFT) + ((a) & PAGE_MASK ? 1 : 0) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efidebug.h ===
#ifndef _EFI_DEBUG_H
#define _EFI_DEBUG_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efidebug.h

Abstract:

    EFI library debug functions



Revision History

--*/

extern UINTN     EFIDebug;

#if EFI_DEBUG

    #define DBGASSERT(a)        DbgAssert(__FILE__, __LINE__, #a)
    #define DEBUG(a)            DbgPrint a
    
#else

    #define DBGASSERT(a)
    #define DEBUG(a)
    
#endif

#if EFI_DEBUG_CLEAR_MEMORY

    #define DBGSETMEM(a,l)      SetMem(a,l,(CHAR8)BAD_POINTER)

#else

    #define DBGSETMEM(a,l)

#endif

#define D_INIT        0x00000001          /*  Initialization style messages */
#define D_WARN        0x00000002          /*  Warnings */
#define D_LOAD        0x00000004          /*  Load events */
#define D_FS          0x00000008          /*  EFI File system */
#define D_POOL        0x00000010          /*  Alloc & Free's */
#define D_PAGE        0x00000020          /*  Alloc & Free's */
#define D_INFO        0x00000040          /*  Verbose */
#define D_VAR         0x00000100          /*  Variable */
#define D_PARSE       0x00000200          /*  Command parsing */
#define D_BM          0x00000400          /*  Boot manager */
#define D_BLKIO       0x00001000          /*  BlkIo Driver */
#define D_BLKIO_ULTRA 0x00002000          /*  BlkIo Driver */
#define D_NET         0x00004000          /*  SNI Driver */
#define D_NET_ULTRA   0x00008000          /*  SNI Driver */
#define D_TXTIN       0x00010000          /*  Simple Input Driver */
#define D_TXTOUT      0x00020000          /*  Simple Text Output Driver */
#define D_ERROR       0x80000000          /*  Error */

#define D_RESERVED    0x7fffC880          /*  Bits not reserved above */

/* 
 *  Current Debug level of the system, value of EFIDebug
 * 
 * #define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT) */
#define EFI_DBUG_MASK   (D_ERROR)

/* 
 * 
 */

#if EFI_DEBUG

    #define ASSERT(a)               if(!(a))       DBGASSERT(a)
    #define ASSERT_LOCKED(l)        if(!(l)->Lock) DBGASSERT(l not locked)
    #define ASSERT_STRUCT(p,t)      DBGASSERT(t not structure), p

#else

    #define ASSERT(a)               
    #define ASSERT_LOCKED(l)        
    #define ASSERT_STRUCT(p,t)      

#endif

/* 
 *  Prototypes
 */

INTN
DbgAssert (
    CHAR8   *file,
    INTN    lineno,
    CHAR8   *string
    );

INTN
DbgPrint (
    INTN    mask,
    CHAR8   *format,
    ...
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efilib.h ===
#ifndef _EFILIB_INCLUDE_
#define _EFILIB_INCLUDE_

/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    efilib.h

Abstract:

    EFI library functions



Revision History

--*/

#include "efidebug.h"
#include "efipart.h"
#include "efilibplat.h"
#include "link.h"
#include "EfiRtLib.h"
#include "pci22.h"

/* 
 *  Public read-only data in the EFI library
 */

extern EFI_SYSTEM_TABLE         *ST;
extern EFI_BOOT_SERVICES        *BS;
extern EFI_RUNTIME_SERVICES     *RT;

extern EFI_GUID DevicePathProtocol;
extern EFI_GUID LoadedImageProtocol;
extern EFI_GUID TextInProtocol;
extern EFI_GUID TextOutProtocol;
extern EFI_GUID BlockIoProtocol;
extern EFI_GUID DiskIoProtocol;
extern EFI_GUID FileSystemProtocol;
extern EFI_GUID LoadFileProtocol;
extern EFI_GUID DeviceIoProtocol;
extern EFI_GUID VariableStoreProtocol;
extern EFI_GUID LegacyBootProtocol;
extern EFI_GUID UnicodeCollationProtocol;
extern EFI_GUID SerialIoProtocol;
extern EFI_GUID VgaClassProtocol;
extern EFI_GUID TextOutSpliterProtocol;
extern EFI_GUID ErrorOutSpliterProtocol;
extern EFI_GUID TextInSpliterProtocol;
extern EFI_GUID SimpleNetworkProtocol;
extern EFI_GUID PxeBaseCodeProtocol;
extern EFI_GUID PxeCallbackProtocol;
extern EFI_GUID NetworkInterfaceIdentifierProtocol;
extern EFI_GUID InternalLoadProtocol;

extern EFI_GUID EfiGlobalVariable;
extern EFI_GUID GenericFileInfo;
extern EFI_GUID FileSystemInfo;
extern EFI_GUID FileSystemVolumeLabelInfo;
extern EFI_GUID PcAnsiProtocol;
extern EFI_GUID Vt100Protocol;
extern EFI_GUID NullGuid;
extern EFI_GUID UnknownDevice;

extern EFI_GUID MpsTableGuid;
extern EFI_GUID AcpiTableGuid;
extern EFI_GUID SMBIOSTableGuid;
extern EFI_GUID SalSystemTableGuid;

/* 
 *  EFI Variable strings
 */

#define VarLanguageCodes       L"LangCodes"
#define VarLanguage            L"Lang"
#define VarTimeout             L"Timeout"
#define VarConsoleInp          L"ConIn"
#define VarConsoleOut          L"ConOut"
#define VarErrorOut            L"ErrOut"
#define VarBootOption          L"Boot%04x"
#define VarBootOrder           L"BootOrder"
#define VarBootNext            L"BootNext"
#define VarBootCurrent         L"BootCurrent"
#define VarDriverOption        L"Driver%04x"
#define VarDriverOrder         L"DriverOrder"
#define VarSerialNumber        L"SerialNumber"
#define VarSystemGUID          L"SystemGUID"
#define VarConsoleInpDev       L"ConInDev"
#define VarConsoleOutDev       L"ConOutDev"
#define VarErrorOutDev         L"ErrOutDev"

#define LanguageCodeEnglish    "eng"

extern EFI_DEVICE_PATH RootDevicePath[];
extern EFI_DEVICE_PATH EndDevicePath[];
extern EFI_DEVICE_PATH EndInstanceDevicePath[];

/* 
 *  Other public data in the EFI library
 */

extern EFI_MEMORY_TYPE PoolAllocationType;

/* 
 *  STATIC - Name is internal to the module
 *  INTERNAL - Name is internal to the component (i.e., directory)
 *  BOOTSERVCE - Name of a boot service function
 */

#define STATIC
#define INTERNAL
#define BOOTSERVICE

/* 
 *  Prototypes
 */

VOID
InitializeLib (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
InitializeUnicodeSupport (
    CHAR8 *LangCode
    );

VOID
SetCrc (
    IN OUT EFI_TABLE_HEADER *Hdr
    );

VOID
SetCrcAltSize (
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

BOOLEAN
CheckCrc (
    IN UINTN                 MaxSize,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

BOOLEAN
CheckCrcAltSize (
    IN UINTN                 MaxSize,
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

UINT32
CalculateCrc (
    UINT8 *pt,
    UINTN Size
    );

VOID
ZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    );

VOID
SetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value    
    );

VOID
CopyMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    );

INTN
CompareMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    );

INTN
StrCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2
    );

INTN
StrnCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2,
    IN UINTN    len
    );

INTN
StriCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2
    );

VOID
StrLwr (
    IN CHAR16   *Str
    );

VOID
StrUpr (
    IN CHAR16   *Str
    );

VOID
StrCpy (
    IN CHAR16   *Dest,
    IN CHAR16    *Src
    );

VOID
StrCat (
    IN CHAR16   *Dest,
    IN CHAR16   *Src
    );

UINTN
StrLen (
    IN CHAR16   *s1
    );

UINTN
StrSize (
    IN CHAR16   *s1
    );

CHAR16 *
StrDuplicate (
    IN CHAR16   *Src
    );

UINTN
strlena (
    IN CHAR8    *s1
    );
    
UINTN
strcmpa (
    IN CHAR8    *s1,
    IN CHAR8    *s2
    );

UINTN
strncmpa (
    IN CHAR8    *s1,
    IN CHAR8    *s2,
    IN UINTN    len
    );

UINTN
xtoi (
    CHAR16      *str
    );

UINTN
Atoi (
    CHAR16  *str
    );

BOOLEAN 
MetaMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    );

BOOLEAN 
MetaiMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    );

UINT64
LShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    );

UINT64
RShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    );

UINT64
MultU64x32 (
    IN UINT64   Multiplicand,
    IN UINTN    Multiplier
    );

UINT64
DivU64x32 (
    IN UINT64   Dividend,
    IN UINTN    Divisor,
    OUT UINTN   *Remainder OPTIONAL
    );

VOID
InitializeLock (
    IN OUT FLOCK    *Lock,
    IN EFI_TPL  Priority
    );

VOID
AcquireLock (
    IN FLOCK    *Lock
    );

VOID
ReleaseLock (
    IN FLOCK    *Lock
    );


INTN
CompareGuid(
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    );

VOID *
AllocatePool (
    IN UINTN     Size
    );

VOID *
AllocateZeroPool (
    IN UINTN     Size
    );

VOID *
ReallocatePool (
    IN VOID                 *OldPool,
    IN UINTN                OldSize,
    IN UINTN                NewSize
    );

VOID
FreePool (
    IN VOID     *p
    );


VOID
Output (
    IN CHAR16   *Str
    );

VOID
Input (
    IN CHAR16   *Prompt OPTIONAL,
    OUT CHAR16  *InStr,
    IN UINTN    StrLen
    );

VOID
IInput (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
    IN SIMPLE_INPUT_INTERFACE           *ConIn,
    IN CHAR16                           *Prompt OPTIONAL,
    OUT CHAR16                          *InStr,
    IN UINTN                            StrLen
    );

UINTN
Print (
    IN CHAR16   *fmt,
    ...
    );

UINTN
SPrint (
    OUT CHAR16  *Str,
    IN UINTN    StrSize,
    IN CHAR16   *fmt,
    ...
    );

CHAR16 *
PoolPrint (
    IN CHAR16           *fmt,
    ...
    );

typedef struct {
    CHAR16      *str;
    UINTN       len;
    UINTN       maxlen;
} POOL_PRINT;

CHAR16 *
CatPrint (
    IN OUT POOL_PRINT   *Str,
    IN CHAR16           *fmt,
    ...
    );

UINTN
PrintAt (
    IN UINTN    Column,
    IN UINTN    Row,
    IN CHAR16   *fmt,
    ...
    );

UINTN
IPrint (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
    IN CHAR16                          *fmt,
    ...
    );

UINTN
IPrintAt (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
    IN UINTN                            Column,
    IN UINTN                            Row,
    IN CHAR16                           *fmt,
    ...
    );

UINTN
APrint (
    IN CHAR8    *fmt,
    ...
    );

VOID
ValueToHex (
    IN CHAR16   *Buffer,
    IN UINT64   v
    );

VOID
ValueToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN INT64    v
    );

VOID
TimeToString (
    OUT CHAR16      *Buffer,
    IN EFI_TIME     *Time
    );

VOID
GuidToString (
    OUT CHAR16      *Buffer,
    IN EFI_GUID     *Guid
    );

VOID
StatusToString (
    OUT CHAR16      *Buffer,
    EFI_STATUS      Status
    );

VOID
DumpHex (
    IN UINTN        Indent,
    IN UINTN        Offset,
    IN UINTN        DataSize,
    IN VOID         *UserData
    );

BOOLEAN
GrowBuffer(
    IN OUT EFI_STATUS   *Status,
    IN OUT VOID         **Buffer,
    IN UINTN            BufferSize
    );

EFI_MEMORY_DESCRIPTOR *
LibMemoryMap (
    OUT UINTN               *NoEntries,
    OUT UINTN               *MapKey,
    OUT UINTN               *DescriptorSize,
    OUT UINT32              *DescriptorVersion
    );

VOID *
LibGetVariable (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid
    );

VOID *
LibGetVariableAndSize (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid,
    OUT UINTN               *VarSize
    );

EFI_STATUS
LibLocateProtocol (
    IN  EFI_GUID    *ProtocolGuid,
    OUT VOID        **Interface
    );

EFI_STATUS
LibLocateHandle (
    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
    IN EFI_GUID                 *Protocol OPTIONAL,
    IN VOID                     *SearchKey OPTIONAL,
    IN OUT UINTN                *NoHandles,
    OUT EFI_HANDLE              **Buffer
    );

EFI_STATUS
LibLocateHandleByDiskSignature (
    IN UINT8                        MBRType,
    IN UINT8                        SignatureType,
    IN VOID                         *Signature,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    );

EFI_STATUS
LibInstallProtocolInterfaces (
    IN OUT EFI_HANDLE       *Handle,
    ...
    );

VOID
LibUninstallProtocolInterfaces (
    IN EFI_HANDLE           Handle,
    ...
    );

EFI_STATUS
LibReinstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    );

EFI_EVENT
LibCreateProtocolNotifyEvent (
    IN EFI_GUID             *ProtocolGuid,
    IN EFI_TPL              NotifyTpl,
    IN EFI_EVENT_NOTIFY     NotifyFunction,
    IN VOID                 *NotifyContext,
    OUT VOID                *Registration
    );

EFI_STATUS
WaitForSingleEvent (
    IN EFI_EVENT        Event,
    IN UINT64           Timeout OPTIONAL
    );

VOID
WaitForEventWithTimeout (
    IN  EFI_EVENT       Event,
    IN  UINTN           Timeout,
    IN  UINTN           Row,
    IN  UINTN           Column,
    IN  CHAR16          *String,
    IN  EFI_INPUT_KEY   TimeoutKey,
    OUT EFI_INPUT_KEY   *Key
    );

EFI_FILE_HANDLE
LibOpenRoot (
    IN EFI_HANDLE           DeviceHandle
    );

EFI_FILE_INFO *
LibFileInfo (
    IN EFI_FILE_HANDLE      FHand
    );

EFI_FILE_SYSTEM_INFO *
LibFileSystemInfo (
    IN EFI_FILE_HANDLE      FHand
    );

EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
LibFileSystemVolumeLabelInfo (
    IN EFI_FILE_HANDLE      FHand
    );

BOOLEAN
ValidMBR(
    IN  MASTER_BOOT_RECORD  *Mbr,
    IN  EFI_BLOCK_IO        *BlkIo
    );

BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    );

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    );

EFI_DEVICE_PATH *
DevicePathFromHandle (
    IN EFI_HANDLE           Handle
    );

EFI_DEVICE_PATH *
DevicePathInstance (
    IN OUT EFI_DEVICE_PATH  **DevicePath,
    OUT UINTN               *Size
    );

UINTN
DevicePathInstanceCount (
    IN EFI_DEVICE_PATH      *DevicePath
    );

EFI_DEVICE_PATH *
AppendDevicePath (
    IN EFI_DEVICE_PATH      *Src1,
    IN EFI_DEVICE_PATH      *Src2
    );

EFI_DEVICE_PATH *
AppendDevicePathNode (
    IN EFI_DEVICE_PATH      *Src1,
    IN EFI_DEVICE_PATH      *Src2
    );

EFI_DEVICE_PATH*
AppendDevicePathInstance (
    IN EFI_DEVICE_PATH  *Src,
    IN EFI_DEVICE_PATH  *Instance
    );

EFI_DEVICE_PATH *
FileDevicePath (
    IN EFI_HANDLE           Device  OPTIONAL,
    IN CHAR16               *FileName
    );

UINTN
DevicePathSize (
    IN EFI_DEVICE_PATH      *DevPath
    );

EFI_DEVICE_PATH *
DuplicateDevicePath (
    IN EFI_DEVICE_PATH      *DevPath
    );

EFI_DEVICE_PATH *
UnpackDevicePath (
    IN EFI_DEVICE_PATH      *DevPath
    );

EFI_STATUS
LibDevicePathToInterface (
    IN EFI_GUID             *Protocol,
    IN EFI_DEVICE_PATH      *FilePath,
    OUT VOID                **Interface
    );

CHAR16 *
DevicePathToStr (
    EFI_DEVICE_PATH         *DevPath
    );

/* 
 *  BugBug: I need my own include files
 */
typedef struct {
    UINT8   Register;
    UINT8   Function;
    UINT8   Device;
    UINT8   Bus;
    UINT32  Reserved;
} EFI_ADDRESS;

typedef union {
    UINT64          Address;
    EFI_ADDRESS     EfiAddress;
} EFI_PCI_ADDRESS_UNION;


EFI_STATUS
PciFindDeviceClass (
    IN  OUT EFI_PCI_ADDRESS_UNION   *Address,
    IN      UINT8                   BaseClass,
    IN      UINT8                   SubClass
    );

EFI_STATUS
PciFindDevice (
    IN  OUT EFI_PCI_ADDRESS_UNION   *DeviceAddress,
    IN      UINT16                  VendorId,
    IN      UINT16                  DeviceId,
    IN OUT  PCI_TYPE00              *Pci
    );

/* 
 *  SIMPLE_READ_FILE object used to access files
 */

typedef VOID        *SIMPLE_READ_FILE;

EFI_STATUS
OpenSimpleReadFile (
    IN BOOLEAN                  BootPolicy,
    IN VOID                     *SourceBuffer   OPTIONAL,
    IN UINTN                    SourceSize,
    IN OUT EFI_DEVICE_PATH      **FilePath,
    OUT EFI_HANDLE              *DeviceHandle,    
    OUT SIMPLE_READ_FILE        *SimpleReadHandle
    );

EFI_STATUS
ReadSimpleReadFile (
    IN SIMPLE_READ_FILE     SimpleReadHandle,
    IN UINTN                Offset,
    IN OUT UINTN            *ReadSize,
    OUT VOID                *Buffer
    );


VOID
CloseSimpleReadFile (
    IN SIMPLE_READ_FILE     SimpleReadHandle
    );

VOID
InitializeGuid (
    VOID
    );

UINT8
DecimaltoBCD(
    IN  UINT8 DecValue
    );

UINT8
BCDtoDecimal(
    IN  UINT8 BcdValue
    );

EFI_STATUS
LibGetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    );

BOOLEAN
LibIsValidTextGraphics (
    IN  CHAR16  Graphic,   
    OUT CHAR8   *PcAnsi,    OPTIONAL
    OUT CHAR8   *Ascii      OPTIONAL
    );

BOOLEAN
IsValidAscii (
    IN  CHAR16  Ascii
    );

BOOLEAN
IsValidEfiCntlChar (
    IN  CHAR16  c
    );


EFI_STATUS
InitializeGlobalIoDevice (
        IN  EFI_DEVICE_PATH             *DevicePath,
        IN  EFI_GUID                    *Protocol,
        IN  CHAR8                       *ErrorStr,
        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs 
        );

UINT32 
ReadPort (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port
        );

UINT32 
WritePort (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port,
        IN  UINTN                       Data
        );

UINT32 
ReadPciConfig (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port
        );

UINT32 
WritePciConfig (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port,
        IN  UINTN                       Data
        );

extern EFI_DEVICE_IO_INTERFACE  *GlobalIoFncs;

#define outp(_Port, _DataByte)  (UINT8)WritePort(GlobalIoFncs,  IO_UINT8,  (UINTN)_Port, (UINTN)_DataByte)
#define inp(_Port)              (UINT8)ReadPort(GlobalIoFncs,   IO_UINT8,  (UINTN)_Port)
#define outpw(_Port, _DataByte) (UINT16)WritePort(GlobalIoFncs, IO_UINT16, (UINTN)_Port, (UINTN)_DataByte)
#define inpw(_Port)             (UINT16)ReadPort(GlobalIoFncs,  IO_UINT16, (UINTN)_Port)
#define outpd(_Port, _DataByte) (UINT32)WritePort(GlobalIoFncs, IO_UINT32, (UINTN)_Port, (UINTN)_DataByte)
#define inpd(_Port)             (UINT32)ReadPort(GlobalIoFncs,  IO_UINT32, (UINTN)_Port)

#define writepci8(_Addr, _DataByte)  (UINT8)WritePciConfig(GlobalIoFncs,  IO_UINT8,  (UINTN)_Addr, (UINTN)_DataByte)
#define readpci8(_Addr)              (UINT8)ReadPciConfig(GlobalIoFncs,   IO_UINT8,  (UINTN)_Addr)
#define writepci16(_Addr, _DataByte) (UINT16)WritePciConfig(GlobalIoFncs, IO_UINT16, (UINTN)_Addr, (UINTN)_DataByte)
#define readpci16(_Addr)             (UINT16)ReadPciConfig(GlobalIoFncs,  IO_UINT16, (UINTN)_Addr)
#define writepci32(_Addr, _DataByte) (UINT32)WritePciConfig(GlobalIoFncs, IO_UINT32, (UINTN)_Addr, (UINTN)_DataByte)
#define readpci32(_Addr)             (UINT32)ReadPciConfig(GlobalIoFncs,  IO_UINT32, (UINTN)_Addr)

#define Pause()             WaitForSingleEvent (ST->ConIn->WaitForKey, 0)
#define Port80(_PostCode)   GlobalIoFncs->Io.Write (GlobalIoFncs, IO_UINT16, (UINT64)0x80, 1, &(_PostCode))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efipart.h ===
#ifndef _EFI_PART_H
#define _EFI_PART_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efipart.h
    
Abstract:   
    Info about disk partitions and Master Boot Records




Revision History

--*/

/* 
 * 
 */

#define EFI_PARTITION   0xef
#define FDISK_SIGNATURE L"EFI FDISK COMMAND"
#define MBR_SIZE        512

#pragma pack(1)

typedef struct {
    UINT8       BootIndicator;
    UINT8       StartHead;
    UINT8       StartSector;
    UINT8       StartTrack;
    UINT8       OSIndicator;
    UINT8       EndHead;
    UINT8       EndSector;
    UINT8       EndTrack;
    UINT8       StartingLBA[4];
    UINT8       SizeInLBA[4];
} MBR_PARTITION_RECORD;

#define EXTRACT_UINT32(D) (UINT32)(D[0] | (D[1] << 8) | (D[2] << 16) | (D[3] << 24))

#define MBR_SIGNATURE           0xaa55
#define MIN_MBR_DEVICE_SIZE     0x80000
#define MBR_ERRATA_PAD          0x40000 /*  128 MB */

#define MAX_MBR_PARTITIONS  4   
typedef struct {
    UINT8                   BootStrapCode[440];
    UINT8                   UniqueMbrSignature[4];
    UINT8                   Unknown[2];
    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
    UINT16                  Signature;
} MASTER_BOOT_RECORD;
#pragma pack()


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efiprot.h ===
#ifndef _EFI_PROT_H
#define _EFI_PROT_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiprot.h

Abstract:

    EFI Protocols



Revision History

--*/

/* 
 *  Device Path protocol
 */

#define DEVICE_PATH_PROTOCOL    \
    { 0x9576e91, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }


/* 
 *  Block IO protocol
 */

#define BLOCK_IO_PROTOCOL \
    { 0x964e5b21, 0x6459, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
#define EFI_BLOCK_IO_INTERFACE_REVISION   0x00010000

INTERFACE_DECL(_EFI_BLOCK_IO);

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_RESET) (
    IN struct _EFI_BLOCK_IO     *This,
    IN BOOLEAN                  ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_READ) (
    IN struct _EFI_BLOCK_IO     *This,
    IN UINT32                   MediaId,
    IN EFI_LBA                  LBA,
    IN UINTN                    BufferSize,
    OUT VOID                    *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_WRITE) (
    IN struct _EFI_BLOCK_IO     *This,
    IN UINT32                   MediaId,
    IN EFI_LBA                  LBA,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_FLUSH) (
    IN struct _EFI_BLOCK_IO     *This
    );



typedef struct {
    UINT32              MediaId;
    BOOLEAN             RemovableMedia;
    BOOLEAN             MediaPresent;

    BOOLEAN             LogicalPartition;
    BOOLEAN             ReadOnly;
    BOOLEAN             WriteCaching;

    UINT32              BlockSize;
    UINT32              IoAlign;

    EFI_LBA             LastBlock;
} EFI_BLOCK_IO_MEDIA;

typedef struct _EFI_BLOCK_IO {
    UINT64                  Revision;

    EFI_BLOCK_IO_MEDIA      *Media;

    EFI_BLOCK_RESET         Reset;
    EFI_BLOCK_READ          ReadBlocks;
    EFI_BLOCK_WRITE         WriteBlocks;
    EFI_BLOCK_FLUSH         FlushBlocks;

} EFI_BLOCK_IO;



/* 
 *  Disk Block IO protocol
 */

#define DISK_IO_PROTOCOL \
    { 0xce345171, 0xba0b, 0x11d2,  0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
#define EFI_DISK_IO_INTERFACE_REVISION   0x00010000

INTERFACE_DECL(_EFI_DISK_IO);

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_READ) (
    IN struct _EFI_DISK_IO      *This,
    IN UINT32                   MediaId,
    IN UINT64                   Offset,
    IN UINTN                    BufferSize,
    OUT VOID                    *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_DISK_WRITE) (
    IN struct _EFI_DISK_IO      *This,
    IN UINT32                   MediaId,
    IN UINT64                   Offset,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );


typedef struct _EFI_DISK_IO {
    UINT64              Revision;
    EFI_DISK_READ       ReadDisk;
    EFI_DISK_WRITE      WriteDisk;
} EFI_DISK_IO;


/* 
 *  Simple file system protocol
 */

#define SIMPLE_FILE_SYSTEM_PROTOCOL \
    { 0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_EFI_FILE_IO_INTERFACE);
INTERFACE_DECL(_EFI_FILE_HANDLE);

typedef
EFI_STATUS
(EFIAPI *EFI_VOLUME_OPEN) (
    IN struct _EFI_FILE_IO_INTERFACE    *This,
    OUT struct _EFI_FILE_HANDLE         **Root
    );

#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000

typedef struct _EFI_FILE_IO_INTERFACE {
    UINT64                  Revision;
    EFI_VOLUME_OPEN         OpenVolume;
} EFI_FILE_IO_INTERFACE;

/* 
 * 
 */

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_OPEN) (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT struct _EFI_FILE_HANDLE **NewHandle,
    IN CHAR16                   *FileName,
    IN UINT64                   OpenMode,
    IN UINT64                   Attributes
    );

/*  Open modes */
#define EFI_FILE_MODE_READ      0x0000000000000001
#define EFI_FILE_MODE_WRITE     0x0000000000000002
#define EFI_FILE_MODE_CREATE    0x8000000000000000

/*  File attributes */
#define EFI_FILE_READ_ONLY      0x0000000000000001
#define EFI_FILE_HIDDEN         0x0000000000000002
#define EFI_FILE_SYSTEM         0x0000000000000004
#define EFI_FILE_RESERVIED      0x0000000000000008
#define EFI_FILE_DIRECTORY      0x0000000000000010
#define EFI_FILE_ARCHIVE        0x0000000000000020
#define EFI_FILE_VALID_ATTR     0x0000000000000037

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_CLOSE) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_DELETE) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_READ) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_WRITE) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_SET_POSITION) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN UINT64                   Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_GET_POSITION) (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  *Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_GET_INFO) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_SET_INFO) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_FLUSH) (
    IN struct _EFI_FILE_HANDLE  *File
    );



#define EFI_FILE_HANDLE_REVISION         0x00010000
typedef struct _EFI_FILE_HANDLE {
    UINT64                  Revision;
    EFI_FILE_OPEN           Open;
    EFI_FILE_CLOSE          Close;
    EFI_FILE_DELETE         Delete;
    EFI_FILE_READ           Read;
    EFI_FILE_WRITE          Write;
    EFI_FILE_GET_POSITION   GetPosition;
    EFI_FILE_SET_POSITION   SetPosition;
    EFI_FILE_GET_INFO       GetInfo;
    EFI_FILE_SET_INFO       SetInfo;
    EFI_FILE_FLUSH          Flush;
} EFI_FILE, *EFI_FILE_HANDLE;


/* 
 *  File information types
 */

#define EFI_FILE_INFO_ID   \
    { 0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

typedef struct {
    UINT64                  Size;
    UINT64                  FileSize;
    UINT64                  PhysicalSize;
    EFI_TIME                CreateTime;
    EFI_TIME                LastAccessTime;
    EFI_TIME                ModificationTime;
    UINT64                  Attribute;
    CHAR16                  FileName[1];
} EFI_FILE_INFO;

/* 
 *  The FileName field of the EFI_FILE_INFO data structure is variable length.
 *  Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
 *  be the size of the data structure without the FileName field.  The following macro 
 *  computes this size correctly no matter how big the FileName array is declared.
 *  This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
 */

#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)

#define EFI_FILE_SYSTEM_INFO_ID    \
    { 0x9576e93, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

typedef struct {
    UINT64                  Size;
    BOOLEAN                 ReadOnly;
    UINT64                  VolumeSize;
    UINT64                  FreeSpace;
    UINT32                  BlockSize;
    CHAR16                  VolumeLabel[1];
} EFI_FILE_SYSTEM_INFO;

/* 
 *  The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
 *  Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
 *  to be the size of the data structure without the VolumeLable field.  The following macro 
 *  computes this size correctly no matter how big the VolumeLable array is declared.
 *  This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
 */

#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)

#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID    \
    { 0xDB47D7D3,0xFE81, 0x11d3, 0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D }

typedef struct {
    CHAR16                  VolumeLabel[1];
} EFI_FILE_SYSTEM_VOLUME_LABEL_INFO;

#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)

/* 
 *  Load file protocol
 */


#define LOAD_FILE_PROTOCOL \
    { 0x56EC3091, 0x954C, 0x11d2, 0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }

INTERFACE_DECL(_EFI_LOAD_FILE_INTERFACE);

typedef
EFI_STATUS
(EFIAPI *EFI_LOAD_FILE) (
    IN struct _EFI_LOAD_FILE_INTERFACE  *This,
    IN EFI_DEVICE_PATH                  *FilePath,
    IN BOOLEAN                          BootPolicy,
    IN OUT UINTN                        *BufferSize,
    IN VOID                             *Buffer OPTIONAL
    );

typedef struct _EFI_LOAD_FILE_INTERFACE {
    EFI_LOAD_FILE                       LoadFile;
} EFI_LOAD_FILE_INTERFACE;


/* 
 *  Device IO protocol
 */

#define DEVICE_IO_PROTOCOL \
    { 0xaf6ac311, 0x84c3, 0x11d2, 0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_EFI_DEVICE_IO_INTERFACE);

typedef enum {
    IO_UINT8,
    IO_UINT16,
    IO_UINT32,
    IO_UINT64,
/* 
 *  Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
 */
    MMIO_COPY_UINT8,
    MMIO_COPY_UINT16,
    MMIO_COPY_UINT32,
    MMIO_COPY_UINT64
} EFI_IO_WIDTH;

#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )


typedef
EFI_STATUS
(EFIAPI *EFI_DEVICE_IO) (
    IN struct _EFI_DEVICE_IO_INTERFACE *This,
    IN EFI_IO_WIDTH                 Width,
    IN UINT64                       Address,
    IN UINTN                        Count,
    IN OUT VOID                     *Buffer
    );

typedef struct {
    EFI_DEVICE_IO                   Read;
    EFI_DEVICE_IO                   Write;
} EFI_IO_ACCESS;

typedef 
EFI_STATUS
(EFIAPI *EFI_PCI_DEVICE_PATH) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN UINT64                           Address,
    IN OUT EFI_DEVICE_PATH              **PciDevicePath
    );

typedef enum {
    EfiBusMasterRead,
    EfiBusMasterWrite,
    EfiBusMasterCommonBuffer
} EFI_IO_OPERATION_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_IO_MAP) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN EFI_IO_OPERATION_TYPE            Operation,
    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
    IN OUT UINTN                        *NumberOfBytes,
    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
    OUT VOID                            **Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_UNMAP) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN VOID                             *Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN EFI_ALLOCATE_TYPE                Type,
    IN EFI_MEMORY_TYPE                  MemoryType,
    IN UINTN                            Pages,
    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_FLUSH) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_FREE_BUFFER) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN UINTN                            Pages,
    IN EFI_PHYSICAL_ADDRESS             HostAddress
    );

typedef struct _EFI_DEVICE_IO_INTERFACE {
    EFI_IO_ACCESS                       Mem;
    EFI_IO_ACCESS                       Io;
    EFI_IO_ACCESS                       Pci;
    EFI_IO_MAP                          Map;
    EFI_PCI_DEVICE_PATH                 PciDevicePath;
    EFI_IO_UNMAP                        Unmap;
    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
    EFI_IO_FLUSH                        Flush;
    EFI_IO_FREE_BUFFER                  FreeBuffer;
} EFI_DEVICE_IO_INTERFACE;


/* 
 *  Unicode Collation protocol
 */

#define UNICODE_COLLATION_PROTOCOL \
    { 0x1d85cd7f, 0xf43d, 0x11d2, 0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)

INTERFACE_DECL(_EFI_UNICODE_COLLATION_INTERFACE);

typedef
INTN
(EFIAPI *EFI_UNICODE_STRICOLL) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                         *s1,
    IN CHAR16                         *s2
    );

typedef
BOOLEAN
(EFIAPI *EFI_UNICODE_METAIMATCH) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                         *String,
    IN CHAR16                         *Pattern
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_STRLWR) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN OUT CHAR16                       *Str
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_STRUPR) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN OUT CHAR16                       *Str
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_FATTOSTR) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN UINTN                            FatSize,
    IN CHAR8                            *Fat,
    OUT CHAR16                          *String
    );

typedef
BOOLEAN
(EFIAPI *EFI_UNICODE_STRTOFAT) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *String,
    IN UINTN                            FatSize,
    OUT CHAR8                           *Fat
    );


typedef struct _EFI_UNICODE_COLLATION_INTERFACE {

    /*  general */
    EFI_UNICODE_STRICOLL                StriColl;
    EFI_UNICODE_METAIMATCH              MetaiMatch;
    EFI_UNICODE_STRLWR                  StrLwr;
    EFI_UNICODE_STRUPR                  StrUpr;

    /*  for supporting fat volumes */
    EFI_UNICODE_FATTOSTR                FatToStr;
    EFI_UNICODE_STRTOFAT                StrToFat;

    CHAR8                               *SupportedLanguages;
} EFI_UNICODE_COLLATION_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efinet.h ===
#ifndef _EFINET_H
#define _EFINET_H


/*++
Copyright (c) 1999  Intel Corporation

Module Name:
    efinet.h

Abstract:
    EFI Simple Network protocol

Revision History
--*/


/* /////////////////////////////////////////////////////////////////////////////
 * 
 *       Simple Network Protocol
 */

#define EFI_SIMPLE_NETWORK_PROTOCOL \
    { 0xA19832B9, 0xAC25, 0x11D3, 0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D }


INTERFACE_DECL(_EFI_SIMPLE_NETWORK);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef struct {
    /* 
     *  Total number of frames received.  Includes frames with errors and
     *  dropped frames.
     */
    UINT64  RxTotalFrames;

    /* 
     *  Number of valid frames received and copied into receive buffers.
     */
    UINT64  RxGoodFrames;

    /* 
     *  Number of frames below the minimum length for the media.
     *  This would be <64 for ethernet.
     */
    UINT64  RxUndersizeFrames;

    /* 
     *  Number of frames longer than the maxminum length for the
     *  media.  This would be >1500 for ethernet.
     */
    UINT64  RxOversizeFrames;

    /* 
     *  Valid frames that were dropped because receive buffers were full.
     */
    UINT64  RxDroppedFrames;

    /* 
     *  Number of valid unicast frames received and not dropped.
     */
    UINT64  RxUnicastFrames;

    /* 
     *  Number of valid broadcast frames received and not dropped.
     */
    UINT64  RxBroadcastFrames;

    /* 
     *  Number of valid mutlicast frames received and not dropped.
     */
    UINT64  RxMulticastFrames;

    /* 
     *  Number of frames w/ CRC or alignment errors.
     */
    UINT64  RxCrcErrorFrames;

    /* 
     *  Total number of bytes received.  Includes frames with errors
     *  and dropped frames.
     */
    UINT64  RxTotalBytes;

    /* 
     *  Transmit statistics.
     */
    UINT64  TxTotalFrames;
    UINT64  TxGoodFrames;
    UINT64  TxUndersizeFrames;
    UINT64  TxOversizeFrames;
    UINT64  TxDroppedFrames;
    UINT64  TxUnicastFrames;
    UINT64  TxBroadcastFrames;
    UINT64  TxMulticastFrames;
    UINT64  TxCrcErrorFrames;
    UINT64  TxTotalBytes;

    /* 
     *  Number of collisions detection on this subnet.
     */
    UINT64  Collisions;

    /* 
     *  Number of frames destined for unsupported protocol.
     */
    UINT64  UnsupportedProtocol;

} EFI_NETWORK_STATISTICS;

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef enum {
    EfiSimpleNetworkStopped,
    EfiSimpleNetworkStarted,
    EfiSimpleNetworkInitialized,
    EfiSimpleNetworkMaxState
} EFI_SIMPLE_NETWORK_STATE;

/* /////////////////////////////////////////////////////////////////////////////
 */

#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10

/* /////////////////////////////////////////////////////////////////////////////
 */

#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08

/* /////////////////////////////////////////////////////////////////////////////
 */
#define MAX_MCAST_FILTER_CNT    16
typedef struct {
    UINT32                      State;
    UINT32                      HwAddressSize;
    UINT32                      MediaHeaderSize;
    UINT32                      MaxPacketSize;
    UINT32                      NvRamSize;
    UINT32                      NvRamAccessSize;
    UINT32                      ReceiveFilterMask;
    UINT32                      ReceiveFilterSetting;
    UINT32                      MaxMCastFilterCount;
    UINT32                      MCastFilterCount;
    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
    EFI_MAC_ADDRESS             CurrentAddress;
    EFI_MAC_ADDRESS             BroadcastAddress;
    EFI_MAC_ADDRESS             PermanentAddress;
    UINT8                       IfType;
    BOOLEAN                     MacAddressChangeable;
    BOOLEAN                     MultipleTxSupported;
    BOOLEAN                     MediaPresentSupported;
    BOOLEAN                     MediaPresent;
} EFI_SIMPLE_NETWORK_MODE;

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_START) (
    IN struct _EFI_SIMPLE_NETWORK  *This
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
    IN struct _EFI_SIMPLE_NETWORK  *This
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
    IN struct _EFI_SIMPLE_NETWORK  *This,
    IN UINTN                       ExtraRxBufferSize  OPTIONAL,
    IN UINTN                       ExtraTxBufferSize  OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      ExtendedVerification
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
    IN struct _EFI_SIMPLE_NETWORK  *This
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN UINT32                       Enable,
    IN UINT32                       Disable,
    IN BOOLEAN                      ResetMCastFilter,
    IN UINTN                        MCastFilterCnt     OPTIONAL,
    IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      Reset,
    IN EFI_MAC_ADDRESS              *New      OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      Reset,
    IN OUT UINTN                    *StatisticsSize   OPTIONAL,
    OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      IPv6,
    IN EFI_IP_ADDRESS               *IP,
    OUT EFI_MAC_ADDRESS             *MAC
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
    IN struct _EFI_SIMPLE_NETWORK  *This,
    IN BOOLEAN                     ReadWrite,
    IN UINTN                       Offset,
    IN UINTN                       BufferSize,
    IN OUT VOID                    *Buffer
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
    IN struct _EFI_SIMPLE_NETWORK  *This,
    OUT UINT32                     *InterruptStatus  OPTIONAL,
    OUT VOID                       **TxBuf           OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN UINTN                        HeaderSize,
    IN UINTN                        BufferSize,
    IN VOID                         *Buffer,
    IN EFI_MAC_ADDRESS              *SrcAddr     OPTIONAL,
    IN EFI_MAC_ADDRESS              *DestAddr    OPTIONAL,
    IN UINT16                       *Protocol    OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    OUT UINTN                       *HeaderSize  OPTIONAL,
    IN OUT UINTN                    *BufferSize,
    OUT VOID                        *Buffer,
    OUT EFI_MAC_ADDRESS             *SrcAddr     OPTIONAL,
    OUT EFI_MAC_ADDRESS             *DestAddr    OPTIONAL,
    OUT UINT16                      *Protocol    OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000

typedef struct _EFI_SIMPLE_NETWORK {
    UINT64                              Revision;
    EFI_SIMPLE_NETWORK_START            Start;
    EFI_SIMPLE_NETWORK_STOP             Stop;
    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
    EFI_SIMPLE_NETWORK_RESET            Reset;
    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
    EFI_SIMPLE_NETWORK_NVDATA           NvData;
    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
    EFI_EVENT                           WaitForPacket;
    EFI_SIMPLE_NETWORK_MODE             *Mode;
} EFI_SIMPLE_NETWORK;

#endif /* _EFINET_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efi_nii.h ===
#ifndef _EFI_NII_H
#define _EFI_NII_H

/*++
Copyright (c) 2000  Intel Corporation

Module name:
    efi_nii.h

Abstract:

Revision history:
    2000-Feb-18 M(f)J   GUID updated.
                Structure order changed for machine word alignment.
                Added StringId[4] to structure.
                
    2000-Feb-14 M(f)J   Genesis.
--*/

#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
    { 0xE18541CD, 0xF755, 0x4f73, 0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29 }

#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000

typedef enum {
    EfiNetworkInterfaceUndi = 1
} EFI_NETWORK_INTERFACE_TYPE;

typedef struct {

    UINT64 Revision;
    /*  Revision of the network interface identifier protocol interface. */

    UINT64 ID;
    /*  Address of the first byte of the identifying structure for this
     *  network interface.  This is set to zero if there is no structure.
     * 
     *  For PXE/UNDI this is the first byte of the !PXE structure. */

    UINT64 ImageAddr;
    /*  Address of the UNrelocated driver/ROM image.  This is set
     *  to zero if there is no driver/ROM image.
     * 
     *  For 16-bit UNDI, this is the first byte of the option ROM in
     *  upper memory.
     * 
     *  For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
     *  image.
     * 
     *  For H/W UNDI, this is set to zero. */

    UINT32 ImageSize;
    /*  Size of the UNrelocated driver/ROM image of this network interface.
     *  This is set to zero if there is no driver/ROM image. */

    CHAR8 StringId[4];
    /*  4 char ASCII string to go in class identifier (option 60) in DHCP
     *  and Boot Server discover packets.
     *  For EfiNetworkInterfaceUndi this field is "UNDI".
     *  For EfiNetworkInterfaceSnp this field is "SNPN". */

    UINT8 Type;
    UINT8 MajorVer;
    UINT8 MinorVer;
    /*  Information to be placed into the PXE DHCP and Discover packets.
     *  This is the network interface type and version number that will
     *  be placed into DHCP option 94 (client network interface identifier). */
    BOOLEAN Ipv6Supported;
} EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;

extern EFI_GUID NetworkInterfaceIdentifierProtocol;

#endif /*  _EFI_NII_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efistdarg.h ===
#ifndef _EFISTDARG_H_
#define _EFISTDARG_H_

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    devpath.h

Abstract:

    Defines for parsing the EFI Device Path structures



Revision History

--*/

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(UINTN) - 1) & ~(sizeof(UINTN) - 1) )

typedef CHAR8 * va_list;

#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)  ( ap = (va_list)0 )


#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efipxebc.h ===
#ifndef _EFIPXEBC_H
#define _EFIPXEBC_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efipxebc.h

Abstract:

    EFI PXE Base Code Protocol



Revision History

--*/

/* 
 *  PXE Base Code protocol
 */

#define EFI_PXE_BASE_CODE_PROTOCOL \
    { 0x03c4e603, 0xac28, 0x11d3, 0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

INTERFACE_DECL(_EFI_PXE_BASE_CODE);

#define DEFAULT_TTL 4
#define DEFAULT_ToS 0
/* 
 *  Address definitions
 */

typedef union {
    UINT32      Addr[4];
    EFI_IPv4_ADDRESS    v4;
    EFI_IPv6_ADDRESS    v6;
} EFI_IP_ADDRESS;

typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;

/* 
 *  Packet definitions
 */

typedef struct {
    UINT8                           BootpOpcode;
    UINT8                           BootpHwType;
    UINT8                           BootpHwAddrLen;
    UINT8                           BootpGateHops;
    UINT32                          BootpIdent;
    UINT16                          BootpSeconds;
    UINT16                          BootpFlags;
    UINT8                           BootpCiAddr[4];
    UINT8                           BootpYiAddr[4];
    UINT8                           BootpSiAddr[4];
    UINT8                           BootpGiAddr[4];
    UINT8                           BootpHwAddr[16];
    UINT8                           BootpSrvName[64];
    UINT8                           BootpBootFile[128];
    UINT32                          DhcpMagik;
    UINT8                           DhcpOptions[56];
} EFI_PXE_BASE_CODE_DHCPV4_PACKET;

/*  TBD in EFI v1.1
 * typedef struct {
 *     UINT8                           reserved;
 * } EFI_PXE_BASE_CODE_DHCPV6_PACKET; */

typedef union {
    UINT8                               Raw[1472];
    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
/*     EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6; */
} EFI_PXE_BASE_CODE_PACKET;

typedef struct {
    UINT8                   Type;
    UINT8                   Code;
    UINT16                  Checksum;
    union {
        UINT32              reserved;
        UINT32              Mtu;
        UINT32              Pointer;
        struct {
            UINT16          Identifier;
            UINT16          Sequence;
        } Echo;
    } u;
    UINT8                   Data[494];
} EFI_PXE_BASE_CODE_ICMP_ERROR;

typedef struct {
    UINT8                   ErrorCode;
    CHAR8                   ErrorString[127];
} EFI_PXE_BASE_CODE_TFTP_ERROR;

/* 
 *  IP Receive Filter definitions
 */
#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
typedef struct {
    UINT8                       Filters;
    UINT8                       IpCnt;
    UINT16                      reserved;
    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
} EFI_PXE_BASE_CODE_IP_FILTER;

#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008

/* 
 *  ARP Cache definitions
 */

typedef struct {
    EFI_IP_ADDRESS       IpAddr;
    EFI_MAC_ADDRESS      MacAddr;
} EFI_PXE_BASE_CODE_ARP_ENTRY;

typedef struct {
    EFI_IP_ADDRESS       IpAddr;
    EFI_IP_ADDRESS       SubnetMask;
    EFI_IP_ADDRESS       GwAddr;
} EFI_PXE_BASE_CODE_ROUTE_ENTRY;

/* 
 *  UDP definitions
 */

#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020

/* 
 *  Discover() definitions
 */

#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
/* 
 *  17 through 32767 are reserved
 *  32768 through 65279 are for vendor use
 *  65280 through 65534 are reserved
 */
#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535

#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000


typedef struct {
    UINT16                      Type;
    BOOLEAN                     AcceptAnyResponse;
    UINT8                       Reserved;
    EFI_IP_ADDRESS              IpAddr;
} EFI_PXE_BASE_CODE_SRVLIST;

typedef struct {
    BOOLEAN                     UseMCast;
    BOOLEAN                     UseBCast;
    BOOLEAN                     UseUCast;
    BOOLEAN                     MustUseList;
    EFI_IP_ADDRESS              ServerMCastIp;
    UINT16                      IpCnt;
    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
} EFI_PXE_BASE_CODE_DISCOVER_INFO;

/* 
 *  Mtftp() definitions
 */

typedef enum {
    EFI_PXE_BASE_CODE_TFTP_FIRST,
    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
    EFI_PXE_BASE_CODE_MTFTP_LAST
} EFI_PXE_BASE_CODE_TFTP_OPCODE;

typedef struct {
    EFI_IP_ADDRESS   MCastIp;
    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
    UINT16                      ListenTimeout;
    UINT16                      TransmitTimeout;
} EFI_PXE_BASE_CODE_MTFTP_INFO;

/* 
 *  PXE Base Code Mode structure
 */

#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8

typedef struct {
    BOOLEAN                         Started;
    BOOLEAN                         Ipv6Available;
    BOOLEAN                         Ipv6Supported;
    BOOLEAN                         UsingIpv6;
    BOOLEAN                         BisSupported;
    BOOLEAN                         BisDetected;
    BOOLEAN                         AutoArp;
    BOOLEAN                         SendGUID;
    BOOLEAN                         DhcpDiscoverValid;
    BOOLEAN                         DhcpAckReceived;
    BOOLEAN                         ProxyOfferReceived;
    BOOLEAN                         PxeDiscoverValid;
    BOOLEAN                         PxeReplyReceived;
    BOOLEAN                         PxeBisReplyReceived;
    BOOLEAN                         IcmpErrorReceived;
    BOOLEAN                         TftpErrorReceived;
    BOOLEAN                         MakeCallbacks;
    UINT8                           TTL;
    UINT8                           ToS;
    EFI_IP_ADDRESS                  StationIp;
    EFI_IP_ADDRESS                  SubnetMask;
    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
    EFI_PXE_BASE_CODE_PACKET        PxeReply;
    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
    UINT32                          ArpCacheEntries;
    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
    UINT32                          RouteTableEntries;
    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
} EFI_PXE_BASE_CODE_MODE;

/* 
 *  PXE Base Code Interface Function definitions
 */

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_START) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN BOOLEAN                      UseIpv6
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
    IN struct _EFI_PXE_BASE_CODE    *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN BOOLEAN                      SortOffers
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
    IN struct _EFI_PXE_BASE_CODE            *This,
    IN UINT16                               Type,
    IN UINT16                               *Layer,
    IN BOOLEAN                              UseBis,
    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
    IN struct _EFI_PXE_BASE_CODE        *This,
    IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
    IN OUT VOID                         *BufferPtr  OPTIONAL,
    IN BOOLEAN                          Overwrite,
    IN OUT UINTN                        *BufferSize,
    IN UINTN                            *BlockSize  OPTIONAL,
    IN EFI_IP_ADDRESS                   *ServerIp,
    IN UINT8                            *Filename,
    IN EFI_PXE_BASE_CODE_MTFTP_INFO     *Info       OPTIONAL,
    IN BOOLEAN                          DontUseBuffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
    IN struct _EFI_PXE_BASE_CODE        *This,
    IN UINT16                           OpFlags,
    IN EFI_IP_ADDRESS                   *DestIp,
    IN EFI_PXE_BASE_CODE_UDP_PORT       *DestPort,
    IN EFI_IP_ADDRESS                   *GatewayIp,  OPTIONAL
    IN EFI_IP_ADDRESS                   *SrcIp,      OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,    OPTIONAL
    IN UINTN                            *HeaderSize, OPTIONAL
    IN VOID                             *HeaderPtr,  OPTIONAL
    IN UINTN                            *BufferSize,
    IN VOID                             *BufferPtr
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
    IN struct _EFI_PXE_BASE_CODE        *This,
    IN UINT16                           OpFlags,
    IN OUT EFI_IP_ADDRESS               *DestIp,      OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *DestPort,    OPTIONAL
    IN OUT EFI_IP_ADDRESS               *SrcIp,       OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,     OPTIONAL
    IN UINTN                            *HeaderSize,  OPTIONAL
    IN VOID                             *HeaderPtr,   OPTIONAL
    IN OUT UINTN                        *BufferSize,
    IN VOID                             *BufferPtr
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN EFI_PXE_BASE_CODE_IP_FILTER  *NewFilter
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN EFI_IP_ADDRESS               *IpAddr,      
    IN EFI_MAC_ADDRESS              *MacAddr      OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN BOOLEAN                      *NewAutoArp,    OPTIONAL
    IN BOOLEAN                      *NewSendGUID,   OPTIONAL
    IN UINT8                        *NewTTL,        OPTIONAL
    IN UINT8                        *NewToS,        OPTIONAL
    IN BOOLEAN                      *NewMakeCallback    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN EFI_IP_ADDRESS               *NewStationIp,  OPTIONAL
    IN EFI_IP_ADDRESS               *NewSubnetMask  OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    BOOLEAN                         *NewDhcpDiscoverValid,  OPTIONAL
    BOOLEAN                         *NewDhcpAckReceived,    OPTIONAL
    BOOLEAN                         *NewProxyOfferReceived, OPTIONAL
    BOOLEAN                         *NewPxeDiscoverValid,   OPTIONAL
    BOOLEAN                         *NewPxeReplyReceived,   OPTIONAL
    BOOLEAN                         *NewPxeBisReplyReceived,OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpDiscover, OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpAck,      OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewProxyOffer,   OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeDiscover,  OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeReply,     OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
    );

/* 
 *  PXE Base Code Protocol structure
 */

#define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000

typedef struct _EFI_PXE_BASE_CODE {
    UINT64                              Revision;
    EFI_PXE_BASE_CODE_START             Start;
    EFI_PXE_BASE_CODE_STOP              Stop;
    EFI_PXE_BASE_CODE_DHCP              Dhcp;
    EFI_PXE_BASE_CODE_DISCOVER          Discover;
    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
    EFI_PXE_BASE_CODE_ARP               Arp;
    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
    EFI_PXE_BASE_CODE_MODE              *Mode;
} EFI_PXE_BASE_CODE;

/* 
 *  Call Back Definitions
 */

#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
    { 0x245dca21, 0xfb7b, 0x11d3, 0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

/* 
 *  Revision Number
 */

#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000

INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK);

typedef enum {
    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
    EFI_PXE_BASE_CODE_FUNCTION_ARP,
    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
} EFI_PXE_BASE_CODE_FUNCTION;

typedef enum {
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
} EFI_PXE_BASE_CODE_CALLBACK_STATUS;

typedef
EFI_PXE_BASE_CODE_CALLBACK_STATUS 
(EFIAPI *EFI_PXE_CALLBACK) (
    IN struct _EFI_PXE_BASE_CODE_CALLBACK   *This,
    IN EFI_PXE_BASE_CODE_FUNCTION           Function,
    IN BOOLEAN                              Received,
    IN UINTN                                PacketLen,
    IN EFI_PXE_BASE_CODE_PACKET             *Packet     OPTIONAL
    );

typedef struct _EFI_PXE_BASE_CODE_CALLBACK {
    UINT64                      Revision;
    EFI_PXE_CALLBACK            Callback;
} EFI_PXE_BASE_CODE_CALLBACK;

#endif /* _EFIPXEBC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efiser.h ===
#ifndef _EFI_SER_H
#define _EFI_SER_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiser.h

Abstract:

    EFI serial protocol

Revision History

--*/

/* 
 *  Serial protocol
 */

#define SERIAL_IO_PROTOCOL \
    { 0xBB25CF6F, 0xF1D4, 0x11D2, 0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD }

INTERFACE_DECL(_SERIAL_IO_INTERFACE);

typedef enum {
    DefaultParity,      
    NoParity,           
    EvenParity,
    OddParity,
    MarkParity,
    SpaceParity
} EFI_PARITY_TYPE;

typedef enum {
    DefaultStopBits,        
    OneStopBit,         /*  1 stop bit */
    OneFiveStopBits,    /*  1.5 stop bits */
    TwoStopBits         /*  2 stop bits */
} EFI_STOP_BITS_TYPE;

#define EFI_SERIAL_CLEAR_TO_SEND        0x0010  /*  RO */
#define EFI_SERIAL_DATA_SET_READY       0x0020  /*  RO */
#define EFI_SERIAL_RING_INDICATE        0x0040  /*  RO */
#define EFI_SERIAL_CARRIER_DETECT       0x0080  /*  RO */
#define EFI_SERIAL_REQUEST_TO_SEND      0x0002  /*  WO */
#define EFI_SERIAL_DATA_TERMINAL_READY  0x0001  /*  WO */
#define EFI_SERIAL_INPUT_BUFFER_EMPTY   0x0100  /*  RO */

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_RESET) (
    IN struct _SERIAL_IO_INTERFACE  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN UINT64                       BaudRate,
    IN UINT32                       ReceiveFifoDepth,
    IN UINT32                       Timeout,
    IN EFI_PARITY_TYPE              Parity,
    IN UINT8                        DataBits,
    IN EFI_STOP_BITS_TYPE           StopBits
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN UINT32                       Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    OUT UINT32                      *Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_WRITE) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN OUT UINTN                    *BufferSize,
    IN VOID                         *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_READ) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN OUT UINTN                    *BufferSize,
    OUT VOID                        *Buffer
    );

typedef struct {
    UINT32                  ControlMask;

    /*  current Attributes */
    UINT32                  Timeout;
    UINT64                  BaudRate;
    UINT32                  ReceiveFifoDepth;
    UINT32                  DataBits;
    UINT32                  Parity;
    UINT32                  StopBits;
} SERIAL_IO_MODE;

#define SERIAL_IO_INTERFACE_REVISION    0x00010000

typedef struct _SERIAL_IO_INTERFACE {
    UINT32                       Revision;
    EFI_SERIAL_RESET             Reset;
    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
    EFI_SERIAL_WRITE             Write;
    EFI_SERIAL_READ              Read;

    SERIAL_IO_MODE               *Mode;
} SERIAL_IO_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efirtlib.h ===
#ifndef _EFI_RT_LIB_INCLUDE_
#define _EFI_RT_LIB_INCLUDE_
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilib.h

Abstract:

    EFI Runtime library functions



Revision History

--*/

#include "efidebug.h"
#include "efipart.h"
#include "efilibplat.h"


VOID
RUNTIMEFUNCTION
RtZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    );

VOID
RUNTIMEFUNCTION
RtSetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value    
    );

VOID
RUNTIMEFUNCTION
RtCopyMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    );

INTN
RUNTIMEFUNCTION
RtCompareMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    );

INTN
RUNTIMEFUNCTION
RtStrCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2
    );


VOID
RUNTIMEFUNCTION
RtStrCpy (
    IN CHAR16   *Dest,
    IN CHAR16    *Src
    );

VOID
RUNTIMEFUNCTION
RtStrCat (
    IN CHAR16   *Dest,
    IN CHAR16   *Src
    );

UINTN
RUNTIMEFUNCTION
RtStrLen (
    IN CHAR16   *s1
    );

UINTN
RUNTIMEFUNCTION
RtStrSize (
    IN CHAR16   *s1
    );

INTN
RUNTIMEFUNCTION
RtCompareGuid (
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    );

UINT8
RUNTIMEFUNCTION
RtDecimaltoBCD(
    IN  UINT8 BcdValue
    );

UINT8
RUNTIMEFUNCTION
RtBCDtoDecimal(
    IN  UINT8 BcdValue
    );

/* 
 *  Virtual mapping transition support.  (Only used during
 *  the virtual address change transisition)
 */

VOID
RUNTIMEFUNCTION
RtLibEnableVirtualMappings (
    VOID
    );

VOID
RUNTIMEFUNCTION
RtConvertList (
    IN UINTN            DebugDisposition,
    IN OUT LIST_ENTRY   *ListHead
    );

VOID
RUNTIMEFUNCTION
RtAcquireLock (
    IN FLOCK    *Lock
    );

VOID
RUNTIMEFUNCTION
RtReleaseLock (
    IN FLOCK    *Lock
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\efi_pxe.h ===
#ifndef _EFI_PXE_H
#define _EFI_PXE_H


/*++
Copyright (c) Intel  1999

Module name:
    efi_pxe.h

32/64-bit PXE specification:
    alpha-4, 99-Dec-17

Abstract:
    This header file contains all of the PXE type definitions,
    structure prototypes, global variables and constants that
    are needed for porting PXE to EFI.
--*/

#pragma pack(1)

#define PXE_INTEL_ORDER         1   /*  Intel order
 * #define PXE_NETWORK_ORDER         1   // network order */

#define PXE_UINT64_SUPPORT          1   /*  UINT64 supported
 * #define PXE_NO_UINT64_SUPPORT     1   // UINT64 not supported */

#define PXE_BUSTYPE(a,b,c,d)            \
((((PXE_UINT32)(d) & 0xFF) << 24) | \
(((PXE_UINT32)(c) & 0xFF) << 16) |  \
(((PXE_UINT32)(b) & 0xFF) << 8) |       \
((PXE_UINT32)(a) & 0xFF))

/* 
 *  UNDI ROM ID and devive ID signature
 */
#define PXE_BUSTYPE_PXE         PXE_BUSTYPE('!', 'P', 'X', 'E')

/* 
 *  BUS ROM ID signatures
 */
#define PXE_BUSTYPE_PCI         PXE_BUSTYPE('P', 'C', 'I', 'R')
#define PXE_BUSTYPE_PC_CARD     PXE_BUSTYPE('P', 'C', 'C', 'R')
#define PXE_BUSTYPE_USB         PXE_BUSTYPE('U', 'S', 'B', 'R')
#define PXE_BUSTYPE_1394        PXE_BUSTYPE('1', '3', '9', '4')

#define PXE_SWAP_UINT16(n)          \
((((PXE_UINT16)(n) & 0x00FF) << 8) |    \
(((PXE_UINT16)(n) & 0xFF00) >> 8))

#define PXE_SWAP_UINT32(n)              \
((((PXE_UINT32)(n) & 0x000000FF) << 24) |   \
(((PXE_UINT32)(n) & 0x0000FF00) << 8) |     \
(((PXE_UINT32)(n) & 0x00FF0000) >> 8) |     \
(((PXE_UINT32)(n) & 0xFF000000) >> 24))

#if PXE_UINT64_SUPPORT != 0
#define PXE_SWAP_UINT64(n)                  \
((((PXE_UINT64)(n) & 0x00000000000000FF) << 56) |   \
(((PXE_UINT64)(n) & 0x000000000000FF00) << 40) |    \
(((PXE_UINT64)(n) & 0x0000000000FF0000) << 24) |    \
(((PXE_UINT64)(n) & 0x00000000FF000000) << 8) | \
(((PXE_UINT64)(n) & 0x000000FF00000000) >> 8) | \
(((PXE_UINT64)(n) & 0x0000FF0000000000) >> 24) |    \
(((PXE_UINT64)(n) & 0x00FF000000000000) >> 40) |    \
(((PXE_UINT64)(n) & 0xFF00000000000000) >> 56))
#endif /*  PXE_UINT64_SUPPORT */

#if PXE_NO_UINT64_SUPPORT != 0
#define PXE_SWAP_UINT64(n)                      \
{                                       \
PXE_UINT32 tmp = (PXE_UINT64)(n)[1];                \
(PXE_UINT64)(n)[1] = PXE_SWAP_UINT32((PXE_UINT64)(n)[0]);   \
(PXE_UINT64)(n)[0] = tmp;                       \
}
#endif /*  PXE_NO_UINT64_SUPPORT */

#define PXE_CPBSIZE_NOT_USED            0   /*  zero */
#define PXE_DBSIZE_NOT_USED         0   /*  zero */
#define PXE_CPBADDR_NOT_USED        (PXE_UINT64)0       /*  zero */
#define PXE_DBADDR_NOT_USED     (PXE_UINT64)0       /*  zero */

#define PXE_CONST const

#define PXE_VOLATILE volatile

typedef void PXE_VOID;

typedef unsigned char PXE_UINT8;

typedef unsigned short PXE_UINT16;

typedef unsigned PXE_UINT32;

#if PXE_UINT64_SUPPORT != 0
/*  typedef unsigned long PXE_UINT64; */
typedef UINT64 PXE_UINT64;
#endif /*  PXE_UINT64_SUPPORT */

#if PXE_NO_UINT64_SUPPORT != 0
typedef PXE_UINT32 PXE_UINT64[2];
#endif /*  PXE_NO_UINT64_SUPPORT */

typedef unsigned PXE_UINTN;

typedef PXE_UINT8 PXE_BOOL;

#define PXE_FALSE               0   /*  zero */
#define PXE_TRUE                    (!PXE_FALSE)

typedef PXE_UINT16 PXE_OPCODE;

/* 
 *  Return UNDI operational state.
 */
#define PXE_OPCODE_GET_STATE                    0x0000

/* 
 *  Change UNDI operational state from Stopped to Started.
 */
#define PXE_OPCODE_START                    0x0001

/* 
 *  Change UNDI operational state from Started to Stopped.
 */
#define PXE_OPCODE_STOP                     0x0002

/* 
 *  Get UNDI initialization information.
 */
#define PXE_OPCODE_GET_INIT_INFO                0x0003

/* 
 *  Get NIC configuration information.
 */
#define PXE_OPCODE_GET_CONFIG_INFO              0x0004

/* 
 *  Changed UNDI operational state from Started to Initialized.
 */
#define PXE_OPCODE_INITIALIZE                   0x0005

/* 
 *  Re-initialize the NIC H/W.
 */
#define PXE_OPCODE_RESET                    0x0006

/* 
 *  Change the UNDI operational state from Initialized to Started.
 */
#define PXE_OPCODE_SHUTDOWN                 0x0007

/* 
 *  Read & change state of external interrupt enables.
 */
#define PXE_OPCODE_INTERRUPT_ENABLES                0x0008

/* 
 *  Read & change state of packet receive filters.
 */
#define PXE_OPCODE_RECEIVE_FILTERS              0x0009

/* 
 *  Read & change station MAC address.
 */
#define PXE_OPCODE_STATION_ADDRESS              0x000A

/* 
 *  Read traffic statistics.
 */
#define PXE_OPCODE_STATISTICS                   0x000B

/* 
 *  Convert multicast IP address to multicast MAC address.
 */
#define PXE_OPCODE_MCAST_IP_TO_MAC              0x000C

/* 
 *  Read or change non-volatile storage on the NIC.
 */
#define PXE_OPCODE_NVDATA                   0x000D

/* 
 *  Get & clear interrupt status.
 */
#define PXE_OPCODE_GET_STATUS                   0x000E

/* 
 *  Fill media header in packet for transmit.
 */
#define PXE_OPCODE_FILL_HEADER              0x000F

/* 
 *  Transmit packet(s).
 */
#define PXE_OPCODE_TRANSMIT                 0x0010

/* 
 *  Receive packet.
 */
#define PXE_OPCODE_RECEIVE                  0x0011

/*  last valid opcode: */
#define PXE_OPCODE_VALID_MAX                    0x0011

/* 
 *  Last valid PXE UNDI OpCode number.
 */
#define PXE_OPCODE_LAST_VALID                   0x0011

typedef PXE_UINT16 PXE_OPFLAGS;

#define PXE_OPFLAGS_NOT_USED                    0x0000

/* //////////////////////////////////////
 *  UNDI Get State
 */

/*  No OpFlags */

/* //////////////////////////////////////
 *  UNDI Start
 */

/*  No OpFlags */

/* //////////////////////////////////////
 *  UNDI Stop
 */

/*  No OpFlags */

/* //////////////////////////////////////
 *  UNDI Get Init Info
 */

/*  No Opflags */

/* //////////////////////////////////////
 *  UNDI Get Config Info
 */

/*  No Opflags */

/* //////////////////////////////////////
 *  UNDI Initialize
 */

#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001

/* //////////////////////////////////////
 *  UNDI Reset
 */

#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS        0x0001
#define PXE_OPFLAGS_RESET_DISABLE_FILTERS           0x0002

/* //////////////////////////////////////
 *  UNDI Shutdown
 */

/*  No OpFlags */

/* //////////////////////////////////////
 *  UNDI Interrupt Enables
 */

/* 
 *  Select whether to enable or disable external interrupt signals.
 *  Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
 */
#define PXE_OPFLAGS_INTERRUPT_OPMASK                0xC000
#define PXE_OPFLAGS_INTERRUPT_ENABLE                0x8000
#define PXE_OPFLAGS_INTERRUPT_DISABLE           0x4000
#define PXE_OPFLAGS_INTERRUPT_READ              0x0000

/* 
 *  Enable receive interrupts.  An external interrupt will be generated
 *  after a complete non-error packet has been received.
 */
#define PXE_OPFLAGS_INTERRUPT_RECEIVE           0x0001

/* 
 *  Enable transmit interrupts.  An external interrupt will be generated
 *  after a complete non-error packet has been transmitted.
 */
#define PXE_OPFLAGS_INTERRUPT_TRANSMIT          0x0002

/* 
 *  Enable command interrupts.  An external interrupt will be generated
 *  when command execution stops.
 */
#define PXE_OPFLAGS_INTERRUPT_COMMAND           0x0004

/* 
 *  Generate software interrupt.  Setting this bit generates an external
 *  interrupt, if it is supported by the hardware.
 */
#define PXE_OPFLAGS_INTERRUPT_SOFTWARE          0x0008

/* //////////////////////////////////////
 *  UNDI Receive Filters
 */

/* 
 *  Select whether to enable or disable receive filters.
 *  Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK           0xC000
#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE           0x8000
#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE          0x4000
#define PXE_OPFLAGS_RECEIVE_FILTER_READ         0x0000

/* 
 *  To reset the contents of the multicast MAC address filter list,
 *  set this OpFlag:
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000

/* 
 *  Enable unicast packet receiving.  Packets sent to the current station
 *  MAC address will be received.
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST          0x0001

/* 
 *  Enable broadcast packet receiving.  Packets sent to the broadcast 
 *  MAC address will be received.
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST        0x0002

/* 
 *  Enable filtered multicast packet receiving.  Packets sent to any
 *  of the multicast MAC addresses in the multicast MAC address filter
 *  list will be received.  If the filter list is empty, no multicast
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST   0x0004

/* 
 *  Enable promiscuous packet receiving.  All packets will be received.
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS      0x0008

/* 
 *  Enable promiscuous multicast packet receiving.  All multicast
 *  packets will be received.
 */
#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST        0x0010

/* //////////////////////////////////////
 *  UNDI Station Address
 */

#define PXE_OPFLAGS_STATION_ADDRESS_READ            0x0000
#define PXE_OPFLAGS_STATION_ADDRESS_RESET           0x0001

/* //////////////////////////////////////
 *  UNDI Statistics
 */

#define PXE_OPFLAGS_STATISTICS_READ             0x0000
#define PXE_OPFLAGS_STATISTICS_RESET                0x0001

/* //////////////////////////////////////
 *  UNDI MCast IP to MAC
 */

/* 
 *  Identify the type of IP address in the CPB.
 */
#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK          0x0003
#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC           0x0000
#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC           0x0001

/* //////////////////////////////////////
 *  UNDI NvData
 */

/* 
 *  Select the type of non-volatile data operation.
 */
#define PXE_OPFLAGS_NVDATA_OPMASK               0x0001
#define PXE_OPFLAGS_NVDATA_READ             0x0000
#define PXE_OPFLAGS_NVDATA_WRITE                0x0001

/* //////////////////////////////////////
 *  UNDI Get Status
 */

/* 
 *  Return current interrupt status.  This will also clear any interrupts
 *  that are currently set.  This can be used in a polling routine.  The
 *  interrupt flags are still set and cleared even when the interrupts
 *  are disabled.
 */
#define PXE_OPFLAGS_GET_INTERRUPT_STATUS            0x0001

/* 
 *  Return list of transmitted buffers for recycling.  Transmit buffers
 *  must not be changed or unallocated until they have recycled.  After
 *  issuing a transmit command, wait for a transmit complete interrupt.
 *  When a transmit complete interrupt is received, read the transmitted
 *  buffers.  Do not plan on getting one buffer per interrupt.  Some
 *  NICs and UNDIs may transmit multiple buffers per interrupt.
 */
#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS         0x0002

/* //////////////////////////////////////
 *  UNDI Fill Header
 */

#define PXE_OPFLAGS_FILL_HEADER_OPMASK          0x0001
#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED          0x0001
#define PXE_OPFLAGS_FILL_HEADER_WHOLE           0x0000

/* //////////////////////////////////////
 *  UNDI Transmit
 */

/* 
 *  S/W UNDI only.  Return after the packet has been transmitted.  A
 *  transmit complete interrupt will still be generated and the transmit
 *  buffer will have to be recycled.
 */
#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK          0x0001
#define PXE_OPFLAGS_TRANSMIT_BLOCK              0x0001
#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK         0x0000

/* 
 * 
 */
#define PXE_OPFLAGS_TRANSMIT_OPMASK             0x0002
#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED         0x0002
#define PXE_OPFLAGS_TRANSMIT_WHOLE              0x0000

/* //////////////////////////////////////
 *  UNDI Receive
 */

/*  No OpFlags */

typedef PXE_UINT16 PXE_STATFLAGS;

#define PXE_STATFLAGS_INITIALIZE                0x0000

/* //////////////////////////////////////
 *  Common StatFlags that can be returned by all commands.
 */

/* 
 *  The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
 *  implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
 *  that support command queuing.
 */
#define PXE_STATFLAGS_STATUS_MASK               0xC000
#define PXE_STATFLAGS_COMMAND_COMPLETE          0xC000
#define PXE_STATFLAGS_COMMAND_FAILED                0x8000
#define PXE_STATFLAGS_COMMAND_QUEUED                0x4000
/* #define PXE_STATFLAGS_INITIALIZE              0x0000 */

#define PXE_STATFLAGS_DB_WRITE_TRUNCATED            0x2000

/* //////////////////////////////////////
 *  UNDI Get State
 */

#define PXE_STATFLAGS_GET_STATE_MASK                0x0003
#define PXE_STATFLAGS_GET_STATE_INITIALIZED         0x0002
#define PXE_STATFLAGS_GET_STATE_STARTED         0x0001
#define PXE_STATFLAGS_GET_STATE_STOPPED         0x0000

/* //////////////////////////////////////
 *  UNDI Start
 */

/*  No additional StatFlags */

/* //////////////////////////////////////
 *  UNDI Get Init Info
 */

#define PXE_STATFLAGS_CABLE_DETECT_MASK          0x0001
#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED 0x0000
#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED     0x0001


/* //////////////////////////////////////
 *  UNDI Initialize
 */

#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA          0x0001

/* //////////////////////////////////////
 *  UNDI Reset
 */

#define PXE_STATFLAGS_RESET_NO_MEDIA                0x0001

/* //////////////////////////////////////
 *  UNDI Shutdown
 */

/*  No additional StatFlags */

/* //////////////////////////////////////
 *  UNDI Interrupt Enables
 */

/* 
 *  If set, receive interrupts are enabled.
 */
#define PXE_STATFLAGS_INTERRUPT_RECEIVE         0x0001

/* 
 *  If set, transmit interrupts are enabled.
 */
#define PXE_STATFLAGS_INTERRUPT_TRANSMIT            0x0002

/* 
 *  If set, command interrupts are enabled.
 */
#define PXE_STATFLAGS_INTERRUPT_COMMAND         0x0004


/* //////////////////////////////////////
 *  UNDI Receive Filters
 */

/* 
 *  If set, unicast packets will be received.
 */
#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST        0x0001

/* 
 *  If set, broadcast packets will be received.
 */
#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST      0x0002

/* 
 *  If set, multicast packets that match up with the multicast address
 *  filter list will be received.
 */
#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004

/* 
 *  If set, all packets will be received.
 */
#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS        0x0008

/* 
 *  If set, all multicast packets will be received.
 */
#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010

/* //////////////////////////////////////
 *  UNDI Station Address
 */

/*  No additional StatFlags */

/* //////////////////////////////////////
 *  UNDI Statistics
 */

/*  No additional StatFlags */

/* //////////////////////////////////////
 *  UNDI MCast IP to MAC
 */

/*  No additional StatFlags */

/* //////////////////////////////////////
 *  UNDI NvData
 */

/*  No additional StatFlags */


/* //////////////////////////////////////
 *  UNDI Get Status
 */

/* 
 *  Use to determine if an interrupt has occurred.
 */
#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK     0x000F
#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS      0x0000

/* 
 *  If set, at least one receive interrupt occurred.
 */
#define PXE_STATFLAGS_GET_STATUS_RECEIVE            0x0001

/* 
 *  If set, at least one transmit interrupt occurred.
 */
#define PXE_STATFLAGS_GET_STATUS_TRANSMIT           0x0002

/* 
 *  If set, at least one command interrupt occurred.
 */
#define PXE_STATFLAGS_GET_STATUS_COMMAND            0x0004

/* 
 *  If set, at least one software interrupt occurred.
 */
#define PXE_STATFLAGS_GET_STATUS_SOFTWARE           0x0008

/* 
 *  This flag is set if the transmitted buffer queue is empty.  This flag
 *  will be set if all transmitted buffer addresses get written into the DB.
 */
#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010

/* 
 *  This flag is set if no transmitted buffer addresses were written
 *  into the DB.  (This could be because DBsize was too small.)
 */
#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020

/* //////////////////////////////////////
 *  UNDI Fill Header
 */

/*  No additional StatFlags */

/* //////////////////////////////////////
 *  UNDI Transmit
 */

/*  No additional StatFlags. */

/* //////////////////////////////////////
 *  UNDI Receive
 */

/*  No additional StatFlags. */

typedef PXE_UINT16 PXE_STATCODE;

#define PXE_STATCODE_INITIALIZE             0x0000

/* //////////////////////////////////////
 *  Common StatCodes returned by all UNDI commands, UNDI protocol functions
 *  and BC protocol functions.
 */

#define PXE_STATCODE_SUCCESS                    0x0000

#define PXE_STATCODE_INVALID_CDB                0x0001
#define PXE_STATCODE_INVALID_CPB                0x0002
#define PXE_STATCODE_BUSY                   0x0003
#define PXE_STATCODE_QUEUE_FULL             0x0004
#define PXE_STATCODE_ALREADY_STARTED                0x0005
#define PXE_STATCODE_NOT_STARTED                0x0006
#define PXE_STATCODE_NOT_SHUTDOWN               0x0007
#define PXE_STATCODE_ALREADY_INITIALIZED            0x0008
#define PXE_STATCODE_NOT_INITIALIZED                0x0009
#define PXE_STATCODE_DEVICE_FAILURE             0x000A
#define PXE_STATCODE_NVDATA_FAILURE             0x000B
#define PXE_STATCODE_UNSUPPORTED                0x000C
#define PXE_STATCODE_BUFFER_FULL                0x000D
#define PXE_STATCODE_NO_DATA                0x000E

typedef PXE_UINT16 PXE_IFNUM;

/* 
 *  This interface number must be passed to the S/W UNDI Start command.
 */
#define PXE_IFNUM_START                     0x0000

/* 
 *  This interface number is returned by the S/W UNDI Get State and
 *  Start commands if information in the CDB, CPB or DB is invalid.
 */
#define PXE_IFNUM_INVALID                   0x0000

typedef PXE_UINT16 PXE_CONTROL;

/* 
 *  Setting this flag directs the UNDI to queue this command for later
 *  execution if the UNDI is busy and it supports command queuing.
 *  If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
 *  is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL 
 *  error is returned.
 */
#define PXE_CONTROL_QUEUE_IF_BUSY               0x0002

/* 
 *  These two bit values are used to determine if there are more UNDI
 *  CDB structures following this one.  If the link bit is set, there
 *  must be a CDB structure following this one.  Execution will start
 *  on the next CDB structure as soon as this one completes successfully.
 *  If an error is generated by this command, execution will stop.
 */
#define PXE_CONTROL_LINK                    0x0001
#define PXE_CONTROL_LAST_CDB_IN_LIST                0x0000

typedef PXE_UINT8 PXE_FRAME_TYPE;

#define PXE_FRAME_TYPE_NONE                 0x00
#define PXE_FRAME_TYPE_UNICAST              0x01
#define PXE_FRAME_TYPE_BROADCAST                0x02
#define PXE_FRAME_TYPE_MULTICAST            0x03
#define PXE_FRAME_TYPE_PROMISCUOUS              0x04

typedef PXE_UINT32 PXE_IPV4;

typedef PXE_UINT32 PXE_IPV6[4];
#define PXE_MAC_LENGTH 32

typedef PXE_UINT8 PXE_MAC_ADDR[PXE_MAC_LENGTH];

typedef PXE_UINT8 PXE_IFTYPE;
typedef PXE_UINT16 PXE_MEDIA_PROTOCOL;

/* 
 *  This information is from the ARP section of RFC 1700.
 * 
 *      1 Ethernet (10Mb)                                    [JBP]
 *      2 Experimental Ethernet (3Mb)                        [JBP]
 *      3 Amateur Radio AX.25                                [PXK]
 *      4 Proteon ProNET Token Ring                          [JBP]
 *      5 Chaos                                              [GXP]
 *      6 IEEE 802 Networks                                  [JBP]
 *      7 ARCNET                                             [JBP]
 *      8 Hyperchannel                                       [JBP]
 *      9 Lanstar                                             [TU]
 *     10 Autonet Short Address                             [MXB1]
 *     11 LocalTalk                                         [JKR1]
 *     12 LocalNet (IBM PCNet or SYTEK LocalNET)             [JXM]
 *     13 Ultra link                                        [RXD2]
 *     14 SMDS                                              [GXC1]
 *     15 Frame Relay                                        [AGM]
 *     16 Asynchronous Transmission Mode (ATM)              [JXB2]
 *     17 HDLC                                               [JBP]
 *     18 Fibre Channel                            [Yakov Rekhter]
 *     19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
 *     20 Serial Line                                        [JBP]
 *     21 Asynchronous Transmission Mode (ATM)              [MXB1]
 */

#define PXE_IFTYPE_ETHERNET                 0x01
#define PXE_IFTYPE_TOKENRING                    0x04
#define PXE_IFTYPE_FIBRE_CHANNEL                0x12

typedef struct s_pxe_hw_undi {
PXE_UINT32 Signature;       /*  PXE_ROMID_SIGNATURE */
PXE_UINT8 Len;          /*  sizeof(PXE_HW_UNDI) */
PXE_UINT8 Fudge;            /*  makes 8-bit cksum equal zero */
PXE_UINT8 Rev;          /*  PXE_ROMID_REV */
PXE_UINT8 IFcnt;            /*  physical connector count */
PXE_UINT8 MajorVer;         /*  PXE_ROMID_MAJORVER */
PXE_UINT8 MinorVer;         /*  PXE_ROMID_MINORVER */
PXE_UINT16 reserved;        /*  zero, not used */
PXE_UINT32 Implementation;      /*  implementation flags
 *  reserved             // vendor use
 *  PXE_UINT32 Status;       // status port
 *  PXE_UINT32 Command;      // command port
 *  PXE_UINT64 CDBaddr;      // CDB address port */
} PXE_HW_UNDI;

/* 
 *  Status port bit definitions
 */

/* 
 *  UNDI operation state
 */
#define PXE_HWSTAT_STATE_MASK                   0xC0000000
#define PXE_HWSTAT_BUSY                     0xC0000000
#define PXE_HWSTAT_INITIALIZED              0x80000000
#define PXE_HWSTAT_STARTED                  0x40000000
#define PXE_HWSTAT_STOPPED                  0x00000000

/* 
 *  If set, last command failed
 */
#define PXE_HWSTAT_COMMAND_FAILED               0x20000000

/* 
 *  If set, identifies enabled receive filters
 */
#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
#define PXE_HWSTAT_BROADCAST_RX_ENABLED         0x00000400
#define PXE_HWSTAT_MULTICAST_RX_ENABLED         0x00000200
#define PXE_HWSTAT_UNICAST_RX_ENABLED           0x00000100

/* 
 *  If set, identifies enabled external interrupts
 */
#define PXE_HWSTAT_SOFTWARE_INT_ENABLED         0x00000080
#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED          0x00000040
#define PXE_HWSTAT_PACKET_RX_INT_ENABLED            0x00000020
#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED         0x00000010

/* 
 *  If set, identifies pending interrupts
 */
#define PXE_HWSTAT_SOFTWARE_INT_PENDING         0x00000008
#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING          0x00000004
#define PXE_HWSTAT_PACKET_RX_INT_PENDING            0x00000002
#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING         0x00000001

/* 
 *  Command port definitions
 */

/* 
 *  If set, CDB identified in CDBaddr port is given to UNDI.
 *  If not set, other bits in this word will be processed.
 */
#define PXE_HWCMD_ISSUE_COMMAND             0x80000000
#define PXE_HWCMD_INTS_AND_FILTS                0x00000000

/* 
 *  Use these to enable/disable receive filters.
 */
#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE       0x00001000
#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE         0x00000800
#define PXE_HWCMD_BROADCAST_RX_ENABLE           0x00000400
#define PXE_HWCMD_MULTICAST_RX_ENABLE           0x00000200
#define PXE_HWCMD_UNICAST_RX_ENABLE             0x00000100

/* 
 *  Use these to enable/disable external interrupts
 */
#define PXE_HWCMD_SOFTWARE_INT_ENABLE           0x00000080
#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE            0x00000040
#define PXE_HWCMD_PACKET_RX_INT_ENABLE          0x00000020
#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE           0x00000010

/* 
 *  Use these to clear pending external interrupts
 */
#define PXE_HWCMD_CLEAR_SOFTWARE_INT                0x00000008
#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT         0x00000004
#define PXE_HWCMD_CLEAR_PACKET_RX_INT           0x00000002
#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT            0x00000001

typedef struct s_pxe_sw_undi {
PXE_UINT32 Signature;       /*  PXE_ROMID_SIGNATURE */
PXE_UINT8 Len;          /*  sizeof(PXE_SW_UNDI) */
PXE_UINT8 Fudge;            /*  makes 8-bit cksum zero */
PXE_UINT8 Rev;          /*  PXE_ROMID_REV */
PXE_UINT8 IFcnt;            /*  physical connector count */
PXE_UINT8 MajorVer;         /*  PXE_ROMID_MAJORVER */
PXE_UINT8 MinorVer;         /*  PXE_ROMID_MINORVER */
PXE_UINT16 reserved1;       /*  zero, not used */
PXE_UINT32 Implementation;      /*  Implementation flags */
PXE_UINT64 EntryPoint;      /*  API entry point */
PXE_UINT8 reserved2[3];     /*  zero, not used */
PXE_UINT8 BusCnt;           /*  number of bustypes supported */
PXE_UINT32 BusType[1];      /*  list of supported bustypes */
} PXE_SW_UNDI;

typedef union u_pxe_undi {
PXE_HW_UNDI hw;
PXE_SW_UNDI sw;
} PXE_UNDI;

/* 
 *  Signature of !PXE structure
 */
#define PXE_ROMID_SIGNATURE     PXE_BUSTYPE('!', 'P', 'X', 'E')

/* 
 *  !PXE structure format revision
 */
#define PXE_ROMID_REV                       0x02

/* 
 *  UNDI command interface revision.  These are the values that get sent
 *  in option 94 (Client Network Interface Identifier) in the DHCP Discover
 *  and PXE Boot Server Request packets.
 */
#define PXE_ROMID_MAJORVER                  0x03
#define PXE_ROMID_MINORVER                  0x00

/* 
 *  Implementation flags
 */
#define PXE_ROMID_IMP_HW_UNDI                   0x80000000
#define PXE_ROMID_IMP_SW_VIRT_ADDR              0x40000000
#define PXE_ROMID_IMP_64BIT_DEVICE              0x00010000
#define PXE_ROMID_IMP_FRAG_SUPPORTED                0x00008000
#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED            0x00004000
#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED           0x00002000
#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED         0x00001000
#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK           0x00000C00
#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE          0x00000C00
#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE        0x00000800
#define PXE_ROMID_IMP_NVDATA_READ_ONLY          0x00000400
#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE          0x00000000
#define PXE_ROMID_IMP_STATISTICS_SUPPORTED          0x00000200
#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE         0x00000100
#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED    0x00000080
#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED      0x00000040
#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED        0x00000020
#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED   0x00000010
#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED        0x00000008
#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED     0x00000004
#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED       0x00000002
#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED        0x00000001

 
typedef struct s_pxe_cdb {
PXE_OPCODE OpCode;
PXE_OPFLAGS OpFlags;
PXE_UINT16 CPBsize;
PXE_UINT16 DBsize;
UINT64 CPBaddr;
UINT64 DBaddr;
PXE_STATCODE StatCode;
PXE_STATFLAGS StatFlags;
PXE_UINT16 IFnum;
PXE_CONTROL Control;
} PXE_CDB;


typedef union u_pxe_ip_addr {
PXE_IPV6 IPv6;
PXE_IPV4 IPv4;
} PXE_IP_ADDR;

typedef union pxe_device {
/* 
 *  PCI and PC Card NICs are both identified using bus, device
 *  and function numbers.  For PC Card, this may require PC
 *  Card services to be loaded in the BIOS or preboot
 *  environment.
 */
struct {
/* 
 *  See S/W UNDI ROMID structure definition for PCI and
 *  PCC BusType definitions.
 */
PXE_UINT32 BusType;

/* 
 *  Bus, device & function numbers that locate this device.
 */
PXE_UINT16 Bus;
PXE_UINT8 Device;
PXE_UINT8 Function;
} PCI, PCC;

/* 
 *  %%TBD - More information is needed about enumerating
 *  USB and 1394 devices.
 */
struct {
PXE_UINT32 BusType;
PXE_UINT32 tdb;
} USB, _1394;
} PXE_DEVICE;

/*  cpb and db definitions */

#define MAX_PCI_CONFIG_LEN 64   /*  # of dwords */
#define MAX_EEPROM_LEN 32       /*  #of dwords */
#define MAX_XMIT_BUFFERS    32  /*  recycling Q length for xmit_done */
#define MAX_MCAST_ADDRESS_CNT 8

typedef struct s_pxe_cpb_start {
    /* 
     *  PXE_VOID Delay(PXE_UINT64 microseconds);
     * 
     *  UNDI will never request a delay smaller than 10 microseconds
     *  and will always request delays in increments of 10 microseconds.
     *  The Delay() CallBack routine must delay between n and n + 10 
     *  microseconds before returning control to the UNDI.
     * 
     *  This field cannot be set to zero.
     */
    PXE_UINT64 Delay;

    /* 
     *  PXE_VOID Block(PXE_UINT32 enable);
     * 
     *  UNDI may need to block multi-threaded/multi-processor access to
     *  critical code sections when programming or accessing the network
     *  device.  To this end, a blocking service is needed by the UNDI.
     *  When UNDI needs a block, it will call Block() passing a non-zero
     *  value.  When UNDI no longer needs a block, it will call Block()
     *  with a zero value.  When called, if the Block() is already enabled,
     *  do not return control to the UNDI until the previous Block() is
     *  disabled.
     * 
     *  This field cannot be set to zero.
     */
    PXE_UINT64 Block;

    /* 
     *  PXE_VOID Virt2Phys(PXE_UINT64 virtual, PXE_UINT64 physical_ptr);
     * 
     *  UNDI will pass the virtual address of a buffer and the virtual
     *  address of a 64-bit physical buffer.  Convert the virtual address
     *  to a physical address and write the result to the physical address
     *  buffer.  If virtual and physical addresses are the same, just
     *  copy the virtual address to the physical address buffer.
     * 
     *  This field can be set to zero if virtual and physical addresses 
     *  are equal.
     */
    PXE_UINT64 Virt2Phys;
    /* 
     *  PXE_VOID Mem_IO(PXE_UINT8 read_write, PXE_UINT8 len, PXE_UINT64 port, 
     *               PXE_UINT64 buf_addr);
     * 
     *  UNDI will read or write the device io space using this call back 
     *  function. It passes the number of bytes as the len parameter and it 
     *  will be either 1,2,4 or 8.
     * 
     *  This field can not be set to zero.
     */
    PXE_UINT64 Mem_IO;
} PXE_CPB_START;

#define PXE_DELAY_MILLISECOND                   1000
#define PXE_DELAY_SECOND                    1000000
#define PXE_IO_READ                     0
#define PXE_IO_WRITE                        1
#define PXE_MEM_READ                        2
#define PXE_MEM_WRITE                       4


typedef struct s_pxe_db_get_init_info {
    /* 
     *  Minimum length of locked memory buffer that must be given to
     *  the Initialize command. Giving UNDI more memory will generally
     *  give better performance.
     * 
     *  If MemoryRequired is zero, the UNDI does not need and will not
     *  use system memory to receive and transmit packets.
     */
    PXE_UINT32 MemoryRequired;

    /* 
     *  Maximum frame data length for Tx/Rx excluding the media header.
     */
    PXE_UINT32 FrameDataLen;

    /* 
     *  Supported link speeds are in units of mega bits.  Common ethernet
     *  values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
     *  filled.
     */
    PXE_UINT32 LinkSpeeds[4];

    /* 
     *  Number of non-volatile storage items.
     */
    PXE_UINT32 NvCount;

    /* 
     *  Width of non-volatile storage item in bytes.  0, 1, 2 or 4
     */
    PXE_UINT16 NvWidth;

    /* 
     *  Media header length.  This is the typical media header length for
     *  this UNDI.  This information is needed when allocating receive
     *  and transmit buffers.
     */
    PXE_UINT16 MediaHeaderLen;

    /* 
     *  Number of bytes in the NIC hardware (MAC) address.
     */
    PXE_UINT16 HWaddrLen;

    /* 
     *  Maximum number of multicast MAC addresses in the multicast
     *  MAC address filter list.
     */
    PXE_UINT16 MCastFilterCnt;

    /* 
     *  Default number and size of transmit and receive buffers that will 
     *  be allocated by the UNDI.  If MemoryRequired is non-zero, this 
     *  allocation will come out of the memory buffer given to the Initialize 
     *  command.  If MemoryRequired is zero, this allocation will come out of 
     *  memory on the NIC.
     */
    PXE_UINT16 TxBufCnt;
    PXE_UINT16 TxBufSize;
    PXE_UINT16 RxBufCnt;
    PXE_UINT16 RxBufSize;

    /* 
     *  Hardware interface types defined in the Assigned Numbers RFC
     *  and used in DHCP and ARP packets.
     *  See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
     */
    PXE_UINT8 IFtype;

    /* 
     *  Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
     */
    PXE_UINT8 Duplex;

    /* 
     *  Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
     */
    PXE_UINT8 LoopBack;
} PXE_DB_GET_INIT_INFO;

#define PXE_MAX_TXRX_UNIT_ETHER             1500

#define PXE_HWADDR_LEN_ETHER                    0x0006
#define PXE_MAC_HEADER_LEN_ETHER                0x000E

#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED            1
#define PXE_DUPLEX_FORCE_FULL_SUPPORTED         2

#define PXE_LOOPBACK_INTERNAL_SUPPORTED         1
#define PXE_LOOPBACK_EXTERNAL_SUPPORTED         2


typedef struct s_pxe_pci_config_info {
    /* 
     *  This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
     *  For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
     */
    PXE_UINT32 BusType;

    /* 
     *  This identifies the PCI network device that this UNDI interface
     *  is bound to.
     */
    PXE_UINT16 Bus;
    PXE_UINT8 Device;
    PXE_UINT8 Function;

    /* 
     *  This is a copy of the PCI configuration space for this 
     *  network device.
     */
    union {
        PXE_UINT8 Byte[256];
        PXE_UINT16 Word[128];
        PXE_UINT32 Dword[64];
    } Config;
} PXE_PCI_CONFIG_INFO;


typedef struct s_pxe_pcc_config_info {
    /* 
     *  This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
     *  For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
     */
    PXE_UINT32 BusType;
    
    /* 
     *  This identifies the PCC network device that this UNDI interface
     *  is bound to.
     */
    PXE_UINT16 Bus;
    PXE_UINT8 Device;
    PXE_UINT8 Function;

    /* 
     *  This is a copy of the PCC configuration space for this 
     *  network device.
     */
    union {
        PXE_UINT8 Byte[256];
        PXE_UINT16 Word[128];
        PXE_UINT32 Dword[64];
    } Config;
} PXE_PCC_CONFIG_INFO;


typedef struct s_pxe_usb_config_info {
    PXE_UINT32 BusType;
    /*  %%TBD What should we return here... */
} PXE_USB_CONFIG_INFO;


typedef struct s_pxe_1394_config_info {
    PXE_UINT32 BusType;
    /*  %%TBD What should we return here... */
} PXE_1394_CONFIG_INFO;


typedef union u_pxe_db_get_config_info {
    PXE_PCI_CONFIG_INFO pci;
    PXE_PCC_CONFIG_INFO pcc;
    PXE_USB_CONFIG_INFO usb;
    PXE_1394_CONFIG_INFO _1394;
} PXE_DB_GET_CONFIG_INFO;


typedef struct s_pxe_cpb_initialize {
    /* 
     *  Address of first (lowest) byte of the memory buffer.  This buffer must
     *  be in contiguous physical memory and cannot be swapped out.  The UNDI
     *  will be using this for transmit and receive buffering.
     */
    PXE_UINT64 MemoryAddr;

    /* 
     *  MemoryLength must be greater than or equal to MemoryRequired
     *  returned by the Get Init Info command.
     */
    PXE_UINT32 MemoryLength;

    /* 
     *  Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
     *  and 1000.  Setting a value of zero will auto-detect and/or use the
     *  default link speed (operation depends on UNDI/NIC functionality).
     */
    PXE_UINT32 LinkSpeed;

    /* 
     *  Suggested number and size of receive and transmit buffers to
     *  allocate.  If MemoryAddr and MemoryLength are non-zero, this
     *  allocation comes out of the supplied memory buffer.  If MemoryAddr 
     *  and MemoryLength are zero, this allocation comes out of memory
     *  on the NIC.
     * 
     *  If these fields are set to zero, the UNDI will allocate buffer
     *  counts and sizes as it sees fit.
     */
    PXE_UINT16 TxBufCnt;
    PXE_UINT16 TxBufSize;
    PXE_UINT16 RxBufCnt;
    PXE_UINT16 RxBufSize;

    /* 
     *  The following configuration parameters are optional and must be zero 
     *  to use the default values.
     */
    PXE_UINT8 Duplex; 

    PXE_UINT8 LoopBack;
} PXE_CPB_INITIALIZE;


#define PXE_DUPLEX_DEFAULT                  0x00
#define PXE_FORCE_FULL_DUPLEX                   0x01
#define PXE_ENABLE_FULL_DUPLEX              0x02

#define LOOPBACK_NORMAL 0
#define LOOPBACK_INTERNAL 1
#define LOOPBACK_EXTERNAL 2


typedef struct s_pxe_db_initialize {
    /* 
     *  Actual amount of memory used from the supplied memory buffer.  This
     *  may be less that the amount of memory suppllied and may be zero if
     *  the UNDI and network device do not use external memory buffers.
     * 
     *  Memory used by the UNDI and network device is allocated from the 
     *  lowest memory buffer address.
     */
    PXE_UINT32 MemoryUsed;

    /* 
     *  Actual number and size of receive and transmit buffers that were
     *  allocated.
     */
    PXE_UINT16 TxBufCnt;
    PXE_UINT16 TxBufSize;
    PXE_UINT16 RxBufCnt;
    PXE_UINT16 RxBufSize;
} PXE_DB_INITIALIZE;


typedef struct s_pxe_cpb_receive_filters {
    /* 
     *  List of multicast MAC addresses.  This list, if present, will
     *  replace the existing multicast MAC address filter list.
     */
    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
} PXE_CPB_RECEIVE_FILTERS;


typedef struct s_pxe_db_receive_filters {
    /* 
     *  Filtered multicast MAC address list.
     */
    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
} PXE_DB_RECEIVE_FILTERS;


typedef struct s_pxe_cpb_station_address {
    /* 
     *  If supplied and supported, the current station MAC address
     *  will be changed.
     */
    PXE_MAC_ADDR StationAddr;
} PXE_CPB_STATION_ADDRESS;


typedef struct s_pxe_dpb_station_address {
    /* 
     *  Current station MAC address.
     */
    PXE_MAC_ADDR StationAddr;

    /* 
     *  Station broadcast MAC address.
     */
    PXE_MAC_ADDR BroadcastAddr;

    /* 
     *  Permanent station MAC address.
     */
    PXE_MAC_ADDR PermanentAddr;
} PXE_DB_STATION_ADDRESS;


typedef struct s_pxe_db_statistics {
    /* 
     *  Bit field identifying what statistic data is collected by the 
     *  UNDI/NIC.
     *  If bit 0x00 is set, Data[0x00] is collected.
     *  If bit 0x01 is set, Data[0x01] is collected.
     *  If bit 0x20 is set, Data[0x20] is collected.
     *  If bit 0x21 is set, Data[0x21] is collected.
     *  Etc.
     */
    PXE_UINT64 Supported;

    /* 
     *  Statistic data.
     */
    PXE_UINT64 Data[64];
} PXE_DB_STATISTICS;

/* 
 *  Total number of frames received.  Includes frames with errors and
 *  dropped frames.
 */
#define PXE_STATISTICS_RX_TOTAL_FRAMES          0x00

/* 
 *  Number of valid frames received and copied into receive buffers.
 */
#define PXE_STATISTICS_RX_GOOD_FRAMES           0x01

/* 
 *  Number of frames below the minimum length for the media.
 *  This would be <64 for ethernet.
 */
#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES          0x02

/* 
 *  Number of frames longer than the maxminum length for the
 *  media.  This would be >1500 for ethernet.
 */
#define PXE_STATISTICS_RX_OVERSIZE_FRAMES           0x03

/* 
 *  Valid frames that were dropped because receive buffers were full.
 */
#define PXE_STATISTICS_RX_DROPPED_FRAMES            0x04

/* 
 *  Number of valid unicast frames received and not dropped.
 */
#define PXE_STATISTICS_RX_UNICAST_FRAMES            0x05

/* 
 *  Number of valid broadcast frames received and not dropped.
 */
#define PXE_STATISTICS_RX_BROADCAST_FRAMES          0x06

/* 
 *  Number of valid mutlicast frames received and not dropped.
 */
#define PXE_STATISTICS_RX_MULTICAST_FRAMES          0x07

/* 
 *  Number of frames w/ CRC or alignment errors.
 */
#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES          0x08

/* 
 *  Total number of bytes received.  Includes frames with errors
 *  and dropped frames.
 */
#define PXE_STATISTICS_RX_TOTAL_BYTES           0x09

/* 
 *  Transmit statistics.
 */
#define PXE_STATISTICS_TX_TOTAL_FRAMES          0x0A
#define PXE_STATISTICS_TX_GOOD_FRAMES           0x0B
#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES          0x0C
#define PXE_STATISTICS_TX_OVERSIZE_FRAMES           0x0D
#define PXE_STATISTICS_TX_DROPPED_FRAMES            0x0E
#define PXE_STATISTICS_TX_UNICAST_FRAMES            0x0F
#define PXE_STATISTICS_TX_BROADCAST_FRAMES          0x10
#define PXE_STATISTICS_TX_MULTICAST_FRAMES          0x11
#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES          0x12
#define PXE_STATISTICS_TX_TOTAL_BYTES           0x13

/* 
 *  Number of collisions detection on this subnet.
 */
#define PXE_STATISTICS_COLLISIONS               0x14

/* 
 *  Number of frames destined for unsupported protocol.
 */
#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL         0x15


typedef struct s_pxe_cpb_mcast_ip_to_mac {
    /* 
     *  Multicast IP address to be converted to multicast MAC address.
     */
    PXE_IP_ADDR IP;
} PXE_CPB_MCAST_IP_TO_MAC;


typedef struct s_pxe_db_mcast_ip_to_mac {
    /* 
     *  Multicast MAC address.
     */
    PXE_MAC_ADDR MAC;
} PXE_DB_MCAST_IP_TO_MAC;


typedef struct s_pxe_cpb_nvdata_sparse {
    /* 
     *  NvData item list.  Only items in this list will be updated.
     */
    struct {
        /*   Non-volatile storage address to be changed. */
        PXE_UINT32 Addr;

        /*  Data item to write into above storage address. */
    
        union {
            PXE_UINT8 Byte;
            PXE_UINT16 Word;
            PXE_UINT32 Dword;
        } Data;
    } Item[MAX_EEPROM_LEN];
} PXE_CPB_NVDATA_SPARSE;


/* 
 *  When using bulk update, the size of the CPB structure must be
 *  the same size as the non-volatile NIC storage.
 */
typedef union u_pxe_cpb_nvdata_bulk {
    /* 
     *  Array of byte-wide data items.
     */
    PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];

    /* 
     *  Array of word-wide data items.
     */
    PXE_UINT16 Word[MAX_EEPROM_LEN << 1];

    /* 
     *  Array of dword-wide data items.
     */
    PXE_UINT32 Dword[MAX_EEPROM_LEN];
} PXE_CPB_NVDATA_BULK;

typedef struct s_pxe_db_nvdata {

    /*  Arrays of data items from non-volatile storage. */

    union {
        /* 
         *  Array of byte-wide data items.
         */
        PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];

        /* 
         *  Array of word-wide data items.
         */
        PXE_UINT16 Word[MAX_EEPROM_LEN << 1];

        /*  Array of dword-wide data items. */

        PXE_UINT32 Dword[MAX_EEPROM_LEN];
    } Data;
} PXE_DB_NVDATA;


typedef struct s_pxe_db_get_status {
    /* 
     *  Length of next receive frame (header + data).  If this is zero,
     *  there is no next receive frame available.
     */
    PXE_UINT32 RxFrameLen;

    /* 
     *  Reserved, set to zero.
     */
    PXE_UINT32 reserved;

    /* 
     *   Addresses of transmitted buffers that need to be recycled.
     */
    PXE_UINT64 TxBuffer[MAX_XMIT_BUFFERS];
} PXE_DB_GET_STATUS;



typedef struct s_pxe_cpb_fill_header {
    /* 
     *  Source and destination MAC addresses.  These will be copied into
     *  the media header without doing byte swapping.
     */
    PXE_MAC_ADDR SrcAddr;
    PXE_MAC_ADDR DestAddr;

    /* 
     *  Address of first byte of media header.  The first byte of packet data
     *  follows the last byte of the media header.
     */
    PXE_UINT64 MediaHeader;

    /* 
     *  Length of packet data in bytes (not including the media header).
     */
    PXE_UINT32 PacketLen;

    /* 
     *  Protocol type.  This will be copied into the media header without
     *  doing byte swapping.  Protocol type numbers can be obtained from
     *  the Assigned Numbers RFC 1700.
     */
    PXE_UINT16 Protocol;

    /* 
     *  Length of the media header in bytes.
     */
    PXE_UINT16 MediaHeaderLen;
} PXE_CPB_FILL_HEADER;


#define PXE_PROTOCOL_ETHERNET_IP                0x0800
#define PXE_PROTOCOL_ETHERNET_ARP               0x0806
#define MAX_XMIT_FRAGMENTS 16

typedef struct s_pxe_cpb_fill_header_fragmented {
    /* 
     *  Source and destination MAC addresses.  These will be copied into
     *  the media header without doing byte swapping.
     */
    PXE_MAC_ADDR SrcAddr;
    PXE_MAC_ADDR DestAddr;

    /* 
     *  Length of packet data in bytes (not including the media header).
     */
    PXE_UINT32 PacketLen;

    /* 
     *  Protocol type.  This will be copied into the media header without
     *  doing byte swapping.  Protocol type numbers can be obtained from
     *  the Assigned Numbers RFC 1700.
     */
    PXE_MEDIA_PROTOCOL Protocol;

    /* 
     *  Length of the media header in bytes.
     */
    PXE_UINT16 MediaHeaderLen;

    /* 
     *  Number of packet fragment descriptors.
     */
    PXE_UINT16 FragCnt;

    /* 
     *  Reserved, must be set to zero.
     */
    PXE_UINT16 reserved;

    /* 
     *  Array of packet fragment descriptors.  The first byte of the media
     *  header is the first byte of the first fragment.
     */
    struct {
        /* 
         *  Address of this packet fragment.
         */
        PXE_UINT64 FragAddr;

        /* 
         *  Length of this packet fragment.
         */
        PXE_UINT32 FragLen;

        /* 
         *  Reserved, must be set to zero.
         */
        PXE_UINT32 reserved;
    } FragDesc[MAX_XMIT_FRAGMENTS];
} PXE_CPB_FILL_HEADER_FRAGMENTED;



typedef struct s_pxe_cpb_transmit {
    /* 
     *  Address of first byte of frame buffer.  This is also the first byte
     *  of the media header.
     */
    PXE_UINT64 FrameAddr;

    /* 
     *  Length of the data portion of the frame buffer in bytes.  Do not
     *  include the length of the media header.
     */
    PXE_UINT32 DataLen;

    /* 
     *  Length of the media header in bytes.
     */
    PXE_UINT16 MediaheaderLen;

    /* 
     *  Reserved, must be zero.
     */
    PXE_UINT16 reserved;
} PXE_CPB_TRANSMIT;



typedef struct s_pxe_cpb_transmit_fragments {
    /* 
     *  Length of packet data in bytes (not including the media header).
     */
    PXE_UINT32 FrameLen;

    /* 
     *  Length of the media header in bytes.
     */
    PXE_UINT16 MediaheaderLen;

    /* 
     *  Number of packet fragment descriptors.
     */
    PXE_UINT16 FragCnt;

    /* 
     *  Array of frame fragment descriptors.  The first byte of the first
     *  fragment is also the first byte of the media header.
     */
    struct {
        /* 
         *  Address of this frame fragment.
         */
        PXE_UINT64 FragAddr;

        /* 
         *  Length of this frame fragment.
         */
        PXE_UINT32 FragLen;

        /* 
         *  Reserved, must be set to zero.
         */
        PXE_UINT32 reserved;
    } FragDesc[MAX_XMIT_FRAGMENTS];
} PXE_CPB_TRANSMIT_FRAGMENTS;


typedef struct s_pxe_cpb_receive {
    /* 
     *  Address of first byte of receive buffer.  This is also the first byte
     *  of the frame header.
     */
    PXE_UINT64 BufferAddr;

    /* 
     *  Length of receive buffer.  This must be large enough to hold the
     *  received frame (media header + data).  If the length of smaller than
     *  the received frame, data will be lost.
     */
    PXE_UINT32 BufferLen;

    /* 
     *  Reserved, must be set to zero.
     */
    PXE_UINT32 reserved;
} PXE_CPB_RECEIVE;


typedef struct s_pxe_db_receive {
    /* 
     *  Source and destination MAC addresses from media header.
     */
    PXE_MAC_ADDR SrcAddr;
    PXE_MAC_ADDR DestAddr;

    /* 
     *  Length of received frame.  May be larger than receive buffer size.
     *  The receive buffer will not be overwritten.  This is how to tell
     *  if data was lost because the receive buffer was too small.
     */
    PXE_UINT32 FrameLen;

    /* 
     *  Protocol type from media header.
     */
    PXE_MEDIA_PROTOCOL Protocol;

    /* 
     *  Length of media header in received frame.
     */
    PXE_UINT16 MediaHeaderLen;

    /* 
     *  Type of receive frame.
     */
    PXE_FRAME_TYPE Type;

    /* 
     *  Reserved, must be zero.
     */
    PXE_UINT8 reserved[7];

} PXE_DB_RECEIVE;

#pragma pack()

/* EOF - efi_pxe.h */
#endif /* _EFI_PXE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\pci22.h ===
#ifndef _PCI22_H
#define _PCI22_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    pci22.h
    
Abstract:      
    Support for PCI 2.2 standard.




Revision History

--*/

#ifdef SOFT_SDV
#define PCI_MAX_BUS     1
#else
#define PCI_MAX_BUS     255
#endif

#define PCI_MAX_DEVICE  31
#define PCI_MAX_FUNC    7

/* 
 *  Command
 */
#define PCI_VGA_PALETTE_SNOOP_DISABLED   0x20

#pragma pack(1)
typedef struct {
    UINT16      VendorId;
    UINT16      DeviceId;
    UINT16      Command;
    UINT16      Status;
    UINT8       RevisionID;
    UINT8       ClassCode[3];
    UINT8       CacheLineSize;
    UINT8       LaytencyTimer;
    UINT8       HeaderType;
    UINT8       BIST;
} PCI_DEVICE_INDEPENDENT_REGION;

typedef struct {
    UINT32      Bar[6];
    UINT32      CISPtr;
    UINT16      SubsystemVendorID;
    UINT16      SubsystemID;
    UINT32      ExpansionRomBar;
    UINT32      Reserved[2];
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT8       MinGnt;
    UINT8       MaxLat;     
} PCI_DEVICE_HEADER_TYPE_REGION;

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_DEVICE_HEADER_TYPE_REGION   Device;
} PCI_TYPE00;

typedef struct {              
    UINT32      Bar[2];
    UINT8       PrimaryBus;
    UINT8       SecondaryBus;
    UINT8       SubordinateBus;
    UINT8       SecondaryLatencyTimer;
    UINT8       IoBase;
    UINT8       IoLimit;
    UINT16      SecondaryStatus;
    UINT16      MemoryBase;
    UINT16      MemoryLimit;
    UINT16      PrefetchableMemoryBase;
    UINT16      PrefetchableMemoryLimit;
    UINT32      PrefetchableBaseUpper32;
    UINT32      PrefetchableLimitUpper32;
    UINT16      IoBaseUpper16;
    UINT16      IoLimitUpper16;
    UINT32      Reserved;
    UINT32      ExpansionRomBAR;
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT16      BridgeControl;
} PCI_BRIDGE_CONTROL_REGISTER;

#define PCI_CLASS_DISPLAY_CTRL          0x03
#define PCI_CLASS_VGA                   0x00

#define PCI_CLASS_BRIDGE                0x06
#define PCI_CLASS_ISA                   0x01
#define PCI_CLASS_ISA_POSITIVE_DECODE   0x80

#define PCI_CLASS_NETWORK               0x02 
#define PCI_CLASS_ETHERNET              0x00
        
#define HEADER_TYPE_DEVICE              0x00
#define HEADER_TYPE_PCI_TO_PCI_BRIDGE   0x01
#define HEADER_TYPE_MULTI_FUNCTION      0x80
#define HEADER_LAYOUT_CODE              0x7f

#define IS_PCI_BRIDGE(_p) ((((_p)->Hdr.HeaderType) & HEADER_LAYOUT_CODE) == HEADER_TYPE_PCI_TO_PCI_BRIDGE)        
#define IS_PCI_MULTI_FUNC(_p)   (((_p)->Hdr.HeaderType) & HEADER_TYPE_MULTI_FUNCTION)         

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
} PCI_TYPE01;

typedef struct {
    UINT8   Register;
    UINT8   Function;
    UINT8   Device;
    UINT8   Bus;
    UINT8   Reserved[4];
} DEFIO_PCI_ADDR;

typedef struct {
    UINT32  Reg     : 8;
    UINT32  Func    : 3;
    UINT32  Dev     : 5;
    UINT32  Bus     : 8;
    UINT32  Reserved: 7;
    UINT32  Enable  : 1;
} PCI_CONFIG_ACCESS_CF8;

#pragma pack()

#define EFI_ROOT_BRIDGE_LIST    'eprb'
typedef struct {
    UINTN           Signature;

    UINT16          BridgeNumber;
    UINT16          PrimaryBus;
    UINT16          SubordinateBus;

    EFI_DEVICE_PATH *DevicePath;

    LIST_ENTRY      Link;
} PCI_ROOT_BRIDGE_ENTRY;


#define PCI_EXPANSION_ROM_HEADER_SIGNATURE        0xaa55
#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE 0x0EF1
#define PCI_DATA_STRUCTURE_SIGNATURE              EFI_SIGNATURE_32('P','C','I','R')

#pragma pack(1)
typedef struct {
    UINT16          Signature;              /*  0xaa55 */
    UINT8           Reserved[0x16];
    UINT16          PcirOffset;
} PCI_EXPANSION_ROM_HEADER;


typedef struct {
    UINT16          Signature;              /*  0xaa55 */
    UINT16          InitializationSize;
    UINT16          EfiSignature;           /*  0x0EF1 */
    UINT16          EfiSubsystem;
    UINT16          EfiMachineType;
    UINT8           Reserved[0x0A];
    UINT16          EfiImageHeaderOffset;
    UINT16          PcirOffset;
} EFI_PCI_EXPANSION_ROM_HEADER;

typedef struct {
    UINT32          Signature;              /*  "PCIR"  */
    UINT16          VendorId;
    UINT16          DeviceId;
    UINT16          Reserved0;
    UINT16          Length;
    UINT8           Revision;
    UINT8           ClassCode[3];
    UINT16          ImageLength;
    UINT16          CodeRevision;
    UINT8           CodeType;
    UINT8           Indicator;
    UINT16          Reserved1;
} PCI_DATA_STRUCTURE;
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\link.h ===
#ifndef _LINK_H
#define _LINK_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    link.h

Abstract:

    EFI link list macro's



Revision History

--*/

#ifndef EFI_NT_EMUL

/* 
 *  List entry - doubly linked list
 */

typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY  *Flink;
    struct _LIST_ENTRY  *Blink;
} LIST_ENTRY;

#endif 


/* 
 *   VOID
 *   InitializeListHead(
 *       LIST_ENTRY *ListHead
 *       );
 */

#define InitializeListHead(ListHead) \
    (ListHead)->Flink = ListHead;    \
    (ListHead)->Blink = ListHead;

/* 
 *   BOOLEAN
 *   IsListEmpty(
 *       PLIST_ENTRY ListHead
 *       );
 */

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

/* 
 *   VOID
 *   RemoveEntryList(
 *       PLIST_ENTRY Entry
 *       );
 */

#define _RemoveEntryList(Entry) {       \
        LIST_ENTRY *_Blink, *_Flink;    \
        _Flink = (Entry)->Flink;        \
        _Blink = (Entry)->Blink;        \
        _Blink->Flink = _Flink;         \
        _Flink->Blink = _Blink;         \
        }

#if EFI_DEBUG
    #define RemoveEntryList(Entry)                      \
        _RemoveEntryList(Entry);                        \
        (Entry)->Flink = (LIST_ENTRY *) BAD_POINTER;    \
        (Entry)->Blink = (LIST_ENTRY *) BAD_POINTER; 
#else
    #define RemoveEntryList(Entry)      \
        _RemoveEntryList(Entry);
#endif

/* 
 *   VOID
 *   InsertTailList(
 *       PLIST_ENTRY ListHead,
 *       PLIST_ENTRY Entry
 *       );
 */

#define InsertTailList(ListHead,Entry) {\
    LIST_ENTRY *_ListHead, *_Blink;     \
    _ListHead = (ListHead);             \
    _Blink = _ListHead->Blink;          \
    (Entry)->Flink = _ListHead;         \
    (Entry)->Blink = _Blink;            \
    _Blink->Flink = (Entry);            \
    _ListHead->Blink = (Entry);         \
    }

/* 
 *   VOID
 *   InsertHeadList(
 *       PLIST_ENTRY ListHead,
 *       PLIST_ENTRY Entry
 *       );
 */

#define InsertHeadList(ListHead,Entry) {\
    LIST_ENTRY *_ListHead, *_Flink;     \
    _ListHead = (ListHead);             \
    _Flink = _ListHead->Flink;          \
    (Entry)->Flink = _Flink;            \
    (Entry)->Blink = _ListHead;         \
    _Flink->Blink = (Entry);            \
    _ListHead->Flink = (Entry);         \
    }

/* 
 *   EFI_FIELD_OFFSET - returns the byte offset to a field within a structure
 */

#define EFI_FIELD_OFFSET(TYPE,Field) ((UINTN)(&(((TYPE *) 0)->Field)))

/* 
 *   CONTAINING_RECORD - returns a pointer to the structure
 *       from one of it's elements.
 */

#define _CR(Record, TYPE, Field)  \
    ((TYPE *) ( (CHAR8 *)(Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))

#if EFI_DEBUG
    #define CR(Record, TYPE, Field, Sig)     \
        _CR(Record, TYPE, Field)->Signature != Sig ?        \
            (TYPE *) ASSERT_STRUCT(_CR(Record, TYPE, Field), Record) : \
            _CR(Record, TYPE, Field)
#else
    #define CR(Record, TYPE, Field, Signature)   \
        _CR(Record, TYPE, Field)                           
#endif


/* 
 *  A lock structure
 */

typedef struct _FLOCK {
    EFI_TPL     Tpl;
    EFI_TPL     OwnerTpl;
    UINTN       Lock;
} FLOCK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia64\efilibplat.h ===
#ifndef _EFI_LIB_PLAT_H
#define _EFI_LIB_PLAT_H
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings



Revision History

--*/

#include "SalProc.h"


VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
LibInitSalAndPalProc(
    OUT PLABEL  *SalPlabel,
    OUT UINT64  *PalEntry
    );

EFI_STATUS
LibGetSalIoPortMapping (
    OUT UINT64  *IoPortMapping
    );

EFI_STATUS
LibGetSalIpiBlock (
    OUT UINT64  *IpiBlock
    );

EFI_STATUS
LibGetSalWakeupVector (
    OUT UINT64  *WakeVector
    );

VOID *
LibSearchSalSystemTable (
    IN  UINT8   EntryType  
    );


VOID
LibSalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );

VOID
LibPalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    OUT rArg      *Results  OPTIONAL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia32\efilibplat.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings




Revision History

--*/

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia64\efibind.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/

#pragma pack()


/* 
 *  Basic int types of various widths
 */

#if (__STDC_VERSION__ < 199901L )

    /*  No ANSI C 1999/2000 stdint.h integer width declarations  */

    #if _MSC_EXTENSIONS

        /*  Use Microsoft C compiler integer width declarations  */

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned __int16    uint16_t;
        typedef __int16             int16_t;
        typedef unsigned __int8     uint8_t;
        typedef __int8              int8_t;
    #else             
        #ifdef UNIX_LP64

            /*  Use LP64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long       uint64_t;
            typedef long                int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #else

            /*  Assume P64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long long  uint64_t;
            typedef long long           int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #endif
    #endif
#endif

/* 
 *  Basic EFI types of various widths
 */


typedef uint64_t   UINT64;
typedef int64_t    INT64;
typedef uint32_t   UINT32;
typedef int32_t    INT32;
typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;


#undef VOID
#define VOID    void


typedef int64_t    INTN;
typedef uint64_t   UINTN;

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *  BugBug: Code to debug
 */
#define BIT63   0x8000000000000000

#define PLATFORM_IOBASE_ADDRESS   (0xffffc000000 | BIT63)                                               
#define PORT_TO_MEMD(_Port) (PLATFORM_IOBASE_ADDRESS | ( ( ( (_Port) & 0xfffc) << 10 ) | ( (_Port) & 0x0fff) ) )
                                                                           
/*                                                                   
 *  Macro's with casts make this much easier to use and read.
 */
#define PORT_TO_MEM8D(_Port)  (*(UINT8  *)(PORT_TO_MEMD(_Port)))
#define POST_CODE(_Data)  (PORT_TO_MEM8D(0x80) = (_Data))
/* 
 *  BugBug: End Debug Code!!!
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

#define EFIERR(a)           (0x8000000000000000 | a)
#define EFI_ERROR_MASK      0x8000000000000000
#define EFIERR_OEM(a)       (0xc000000000000000 | a)      

#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF

#define BREAKPOINT()        while (TRUE)

/* 
 *  Pointers must be aligned to these address to function
 *   you will get an alignment fault if this value is less than 8
 */
#define MIN_ALIGNMENT_SIZE  8

#define ALIGN_VARIABLE(Value , Adjustment) \
            (UINTN) Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment

/* 
 *  Define macros to create data structure signatures.
 */

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | (EFI_SIGNATURE_32(E,F,G,H) << 32))

/* 
 *  To export & import functions in the EFI emulator environment
 */

    #define EXPORTAPI

/* 
 *  EFIAPI - prototype calling convention for EFI function pointers
 *  BOOTSERVICE - prototype for implementation of a boot service interface
 *  RUNTIMESERVICE - prototype for implementation of a runtime service interface
 *  RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
 *  RUNTIME_CODE - pragma macro for declaring runtime code    
 */

#ifndef EFIAPI                  /*  Forces EFI calling conventions reguardless of compiler options  */
    #if _MSC_EXTENSIONS
        #define EFIAPI __cdecl  /*  Force C calling convention for Microsoft C compiler  */
    #else
        #define EFIAPI          /*  Substitute expresion to force C calling convention  */
    #endif
#endif

#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION

#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

/* 
 *  BugBug: Need to find out if this is portable accross compliers.
 */
void __mf (void);                       
#pragma intrinsic (__mf)  
#define MEMORY_FENCE()    __mf()

/* 
 *  When build similiar to FW, then link everything together as
 *  one big module.
 */

#define EFI_DRIVER_ENTRY_POINT(InitFunction)

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
        (_if)->LoadInternal(type, name, entry)

/* 
 *  Some compilers don't support the forward reference construct:
 *   typedef struct XXXXX
 * 
 *  The following macro provide a workaround for such cases.
 */
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia32\efibind.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/

#pragma pack()


/* 
 *  Basic int types of various widths
 */

#if (__STDC_VERSION__ < 199901L )

    /*  No ANSI C 1999/2000 stdint.h integer width declarations  */

    #if _MSC_EXTENSIONS

        /*  Use Microsoft C compiler integer width declarations  */

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef char                int8_t;
    #else             
        #ifdef UNIX_LP64

            /*  Use LP64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long       uint64_t;
            typedef long                int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #else

            /*  Assume P64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long long  uint64_t;
            typedef long long           int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #endif
    #endif
#endif

/* 
 *  Basic EFI types of various widths
 */

typedef uint64_t   UINT64;
typedef int64_t    INT64;

#ifndef _BASETSD_H_
    typedef uint32_t   UINT32;
    typedef int32_t    INT32;
#endif

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;


#undef VOID
#define VOID    void


typedef int32_t    INTN;
typedef uint32_t   UINTN;

#ifdef EFI_NT_EMULATOR
    #define POST_CODE(_Data)
#else    
    #ifdef EFI_DEBUG
#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
    #else
        #define POST_CODE(_Data)
    #endif  
#endif

#define EFIERR(a)           (0x80000000 | a)
#define EFI_ERROR_MASK      0x80000000
#define EFIERR_OEM(a)       (0xc0000000 | a)      


#define BAD_POINTER         0xFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFF

#ifdef EFI_NT_EMULATOR
    #define BREAKPOINT()        __asm { int 3 }
#else
    #define BREAKPOINT()        while (TRUE);    /*  Make it hang on Bios[Dbg]32 */
#endif

/* 
 *  Pointers must be aligned to these address to function
 */

#define MIN_ALIGNMENT_SIZE  4

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


/* 
 *  Define macros to build data structure signatures from characters.
 */

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | (EFI_SIGNATURE_32(E,F,G,H) << 32))

/* 
 *  To export & import functions in the EFI emulator environment
 */

#if EFI_NT_EMULATOR
    #define EXPORTAPI           __declspec( dllexport )
#else
    #define EXPORTAPI
#endif


/* 
 *  EFIAPI - prototype calling convention for EFI function pointers
 *  BOOTSERVICE - prototype for implementation of a boot service interface
 *  RUNTIMESERVICE - prototype for implementation of a runtime service interface
 *  RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
 *  RUNTIME_CODE - pragma macro for declaring runtime code    
 */

#ifndef EFIAPI                  /*  Forces EFI calling conventions reguardless of compiler options  */
    #if _MSC_EXTENSIONS
        #define EFIAPI __cdecl  /*  Force C calling convention for Microsoft C compiler  */
    #else
        #define EFIAPI          /*  Substitute expresion to force C calling convention  */
    #endif
#endif

#define BOOTSERVICE
/* #define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
 * #define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a */
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

#define MEMORY_FENCE()    

#ifdef EFI_NT_EMULATOR

/* 
 *  To help ensure proper coding of integrated drivers, they are
 *  compiled as DLLs.  In NT they require a dll init entry pointer.
 *  The macro puts a stub entry point into the DLL so it will load.
 */

#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    __stdcall                                   \
    _DllMainCRTStartup (                        \
        UINTN    Inst,                          \
        UINTN    reason_for_call,               \
        VOID    *rserved                        \
        )                                       \
    {                                           \
        return 1;                               \
    }                                           \
                                                \
    int                                         \
    EXPORTAPI                                   \
    __cdecl                                     \
    InitializeDriver (                          \
        void *ImageHandle,                      \
        void *SystemTable                       \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle, SystemTable);       \
    }


    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
        (_if)->LoadInternal(type, name, NULL)             

#else /*  EFI_NT_EMULATOR  */

/* 
 *  When build similiar to FW, then link everything together as
 *  one big module.
 */

    #define EFI_DRIVER_ENTRY_POINT(InitFunction)

    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
            (_if)->LoadInternal(type, name, entry)

#endif /*  EFI_FW_NT  */

/* 
 *  Some compilers don't support the forward reference construct:
 *   typedef struct XXXXX
 * 
 *  The following macro provide a workaround for such cases.
 */
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\protocol\eficonsplit.h ===
#ifndef _EFI_CONFORK_H
#define _EFI_CONFORK_H
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

Abstract:



Revision History

--*/



/* 
 *  ConOut Forker Protocol
 */

#define TEXT_OUT_SPLITER_PROTOCOL    \
    { 0x56d830a0, 0x7e7a, 0x11d3, 0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define ERROR_OUT_SPLITER_PROTOCOL    \
    { 0xf0ba9039, 0x68f1, 0x425e, 0xaa, 0x7f, 0xd9, 0xaa, 0xf9, 0x1b, 0x82, 0xa1}

#define TEXT_IN_SPLITER_PROTOCOL    \
    { 0xf9a3c550, 0x7fb5, 0x11d3, 0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia32\pe.h ===
/* 
    PE32+ header file
 */
#ifndef _PE_H
#define _PE_H

#define IMAGE_DOS_SIGNATURE                 0x5A4D      /*  MZ */
#define IMAGE_OS2_SIGNATURE                 0x454E      /*  NE */
#define IMAGE_OS2_SIGNATURE_LE              0x454C      /*  LE */
#define IMAGE_NT_SIGNATURE                  0x00004550  /*  PE00   */
#define IMAGE_EDOS_SIGNATURE                0x44454550  /*  PEED */


typedef struct _IMAGE_DOS_HEADER {      /*  DOS .EXE header */
    UINT16   e_magic;                     /*  Magic number */
    UINT16   e_cblp;                      /*  Bytes on last page of file */
    UINT16   e_cp;                        /*  Pages in file */
    UINT16   e_crlc;                      /*  Relocations */
    UINT16   e_cparhdr;                   /*  Size of header in paragraphs */
    UINT16   e_minalloc;                  /*  Minimum extra paragraphs needed */
    UINT16   e_maxalloc;                  /*  Maximum extra paragraphs needed */
    UINT16   e_ss;                        /*  Initial (relative) SS value */
    UINT16   e_sp;                        /*  Initial SP value */
    UINT16   e_csum;                      /*  Checksum */
    UINT16   e_ip;                        /*  Initial IP value */
    UINT16   e_cs;                        /*  Initial (relative) CS value */
    UINT16   e_lfarlc;                    /*  File address of relocation table */
    UINT16   e_ovno;                      /*  Overlay number */
    UINT16   e_res[4];                    /*  Reserved words */
    UINT16   e_oemid;                     /*  OEM identifier (for e_oeminfo) */
    UINT16   e_oeminfo;                   /*  OEM information; e_oemid specific */
    UINT16   e_res2[10];                  /*  Reserved words */
    UINT32   e_lfanew;                    /*  File address of new exe header */
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      /*  OS/2 .EXE header */
    UINT16   ne_magic;                    /*  Magic number */
    UINT8    ne_ver;                      /*  Version number */
    UINT8    ne_rev;                      /*  Revision number */
    UINT16   ne_enttab;                   /*  Offset of Entry Table */
    UINT16   ne_cbenttab;                 /*  Number of bytes in Entry Table */
    UINT32   ne_crc;                      /*  Checksum of whole file */
    UINT16   ne_flags;                    /*  Flag UINT16 */
    UINT16   ne_autodata;                 /*  Automatic data segment number */
    UINT16   ne_heap;                     /*  Initial heap allocation */
    UINT16   ne_stack;                    /*  Initial stack allocation */
    UINT32   ne_csip;                     /*  Initial CS:IP setting */
    UINT32   ne_sssp;                     /*  Initial SS:SP setting */
    UINT16   ne_cseg;                     /*  Count of file segments */
    UINT16   ne_cmod;                     /*  Entries in Module Reference Table */
    UINT16   ne_cbnrestab;                /*  Size of non-resident name table */
    UINT16   ne_segtab;                   /*  Offset of Segment Table */
    UINT16   ne_rsrctab;                  /*  Offset of Resource Table */
    UINT16   ne_restab;                   /*  Offset of resident name table */
    UINT16   ne_modtab;                   /*  Offset of Module Reference Table */
    UINT16   ne_imptab;                   /*  Offset of Imported Names Table */
    UINT32   ne_nrestab;                  /*  Offset of Non-resident Names Table */
    UINT16   ne_cmovent;                  /*  Count of movable entries */
    UINT16   ne_align;                    /*  Segment alignment shift count */
    UINT16   ne_cres;                     /*  Count of resource segments */
    UINT8    ne_exetyp;                   /*  Target Operating system */
    UINT8    ne_flagsothers;              /*  Other .EXE flags */
    UINT16   ne_pretthunks;               /*  offset to return thunks */
    UINT16   ne_psegrefbytes;             /*  offset to segment ref. bytes */
    UINT16   ne_swaparea;                 /*  Minimum code swap area size */
    UINT16   ne_expver;                   /*  Expected Windows version number */
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

/* 
 *  File header format.
 */

typedef struct _IMAGE_FILE_HEADER {
    UINT16   Machine;
    UINT16   NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16   SizeOfOptionalHeader;
    UINT16   Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  /*  Relocation info stripped from file. */
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  /*  File is executable  (i.e. no unresolved externel references). */
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  /*  Line nunbers stripped from file. */
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  /*  Local symbols stripped from file. */
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  /*  Bytes of machine word are reversed. */
#define IMAGE_FILE_32BIT_MACHINE             0x0100  /*  32 bit word machine. */
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  /*  Debugging info stripped from file in .DBG file */
#define IMAGE_FILE_SYSTEM                    0x1000  /*  System File. */
#define IMAGE_FILE_DLL                       0x2000  /*  File is a DLL. */
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  /*  Bytes of machine word are reversed. */

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   /*  Intel 386. */
#define IMAGE_FILE_MACHINE_R3000             0x162   /*  MIPS little-endian, 0540 big-endian */
#define IMAGE_FILE_MACHINE_R4000             0x166   /*  MIPS little-endian */
#define IMAGE_FILE_MACHINE_ALPHA             0x184   /*  Alpha_AXP */
#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   /*  IBM PowerPC Little-Endian */
#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   /*  Intel EM machine
 * 
 *  Directory format.
 */

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32   VirtualAddress;
    UINT32   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

/* 
 *  Optional header format.
 */

typedef struct _IMAGE_OPTIONAL_HEADER {
    /* 
     *  Standard fields.
     */

    UINT16    Magic;
    UINT8     MajorLinkerVersion;
    UINT8     MinorLinkerVersion;
    UINT32    SizeOfCode;
    UINT32    SizeOfInitializedData;
    UINT32    SizeOfUninitializedData;
    UINT32    AddressOfEntryPoint;
    UINT32    BaseOfCode;
    UINT32    BaseOfData;
                
    /* 
     *  NT additional fields.
     */

    UINT32   ImageBase;
    UINT32   SectionAlignment;
    UINT32   FileAlignment;
    UINT16   MajorOperatingSystemVersion;
    UINT16   MinorOperatingSystemVersion;
    UINT16   MajorImageVersion;
    UINT16   MinorImageVersion;
    UINT16   MajorSubsystemVersion;
    UINT16   MinorSubsystemVersion;
    UINT32   Reserved1;
    UINT32   SizeOfImage;
    UINT32   SizeOfHeaders;
    UINT32   CheckSum;
    UINT16   Subsystem;
    UINT16   DllCharacteristics;
    UINT32   SizeOfStackReserve;
    UINT32   SizeOfStackCommit;
    UINT32   SizeOfHeapReserve;
    UINT32   SizeOfHeapCommit;
    UINT32   LoaderFlags;
    UINT32   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    UINT16  Magic;
    UINT8   MajorLinkerVersion;
    UINT8   MinorLinkerVersion;
    UINT32  SizeOfCode;
    UINT32  SizeOfInitializedData;
    UINT32  SizeOfUninitializedData;
    UINT32  AddressOfEntryPoint;
    UINT32  BaseOfCode;
    UINT32  BaseOfData;
    UINT32  BaseOfBss;
    UINT32  GprMask;
    UINT32  CprMask[4];
    UINT32  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((UINT32)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


/*  Subsystem Values */

#define IMAGE_SUBSYSTEM_UNKNOWN              0   /*  Unknown subsystem. */
#define IMAGE_SUBSYSTEM_NATIVE               1   /*  Image doesn't require a subsystem. */
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   /*  Image runs in the Windows GUI subsystem. */
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   /*  Image runs in the Windows character subsystem. */
#define IMAGE_SUBSYSTEM_OS2_CUI              5   /*  image runs in the OS/2 character subsystem. */
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   /*  image run  in the Posix character subsystem. */


/*  Directory Entries */

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   /*  Export Directory */
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   /*  Import Directory */
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   /*  Resource Directory */
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   /*  Exception Directory */
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   /*  Security Directory */
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   /*  Base Relocation Table */
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   /*  Debug Directory */
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   /*  Description String */
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   /*  Machine Value (MIPS GP) */
#define IMAGE_DIRECTORY_ENTRY_TLS            9   /*  TLS Directory */
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   /*  Load Configuration Directory */

/* 
 *  Section header format.
 */

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            UINT32   PhysicalAddress;
            UINT32   VirtualSize;
    } Misc;
    UINT32   VirtualAddress;
    UINT32   SizeOfRawData;
    UINT32   PointerToRawData;
    UINT32   PointerToRelocations;
    UINT32   PointerToLinenumbers;
    UINT16   NumberOfRelocations;
    UINT16   NumberOfLinenumbers;
    UINT32   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  /*  Reserved. */

#define IMAGE_SCN_CNT_CODE                   0x00000020  /*  Section contains code. */
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  /*  Section contains initialized data. */
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  /*  Section contains uninitialized data. */

#define IMAGE_SCN_LNK_OTHER                  0x00000100  /*  Reserved. */
#define IMAGE_SCN_LNK_INFO                   0x00000200  /*  Section contains comments or some other type of information. */
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  /*  Section contents will not become part of image. */
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  /*  Section contents comdat. */

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  /*  */
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  /*  */
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  /*  */
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  /*  */
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  /*  Default alignment if no others are specified. */
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  /*  */
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  /*  */

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  /*  Section can be discarded. */
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  /*  Section is not cachable. */
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  /*  Section is not pageable. */
#define IMAGE_SCN_MEM_SHARED                 0x10000000  /*  Section is shareable. */
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  /*  Section is executable. */
#define IMAGE_SCN_MEM_READ                   0x40000000  /*  Section is readable. */
#define IMAGE_SCN_MEM_WRITE                  0x80000000  /*  Section is writeable. */

/* 
 *  Symbol format.
 */


#define IMAGE_SIZEOF_SYMBOL                  18

/* 
 *  Section values.
 * 
 *  Symbols have a section number of the section in which they are
 *  defined. Otherwise, section numbers have the following meanings:
 */

#define IMAGE_SYM_UNDEFINED           (UINT16)0           /*  Symbol is undefined or is common. */
#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          /*  Symbol is an absolute value. */
#define IMAGE_SYM_DEBUG               (UINT16)-2          /*  Symbol is a special debug item. */

/* 
 *  Type (fundamental) values.
 */

#define IMAGE_SYM_TYPE_NULL                  0           /*  no type. */
#define IMAGE_SYM_TYPE_VOID                  1           /*  */
#define IMAGE_SYM_TYPE_CHAR                  2           /*  type character. */
#define IMAGE_SYM_TYPE_SHORT                 3           /*  type short integer. */
#define IMAGE_SYM_TYPE_INT                   4           /*  */
#define IMAGE_SYM_TYPE_LONG                  5           /*  */
#define IMAGE_SYM_TYPE_FLOAT                 6           /*  */
#define IMAGE_SYM_TYPE_DOUBLE                7           /*  */
#define IMAGE_SYM_TYPE_STRUCT                8           /*  */
#define IMAGE_SYM_TYPE_UNION                 9           /*  */
#define IMAGE_SYM_TYPE_ENUM                  10          /*  enumeration. */
#define IMAGE_SYM_TYPE_MOE                   11          /*  member of enumeration. */
#define IMAGE_SYM_TYPE_BYTE                  12          /*  */
#define IMAGE_SYM_TYPE_WORD                  13          /*  */
#define IMAGE_SYM_TYPE_UINT                  14          /*  */
#define IMAGE_SYM_TYPE_DWORD                 15          /*  */

/* 
 *  Type (derived) values.
 */

#define IMAGE_SYM_DTYPE_NULL                 0           /*  no derived type. */
#define IMAGE_SYM_DTYPE_POINTER              1           /*  pointer. */
#define IMAGE_SYM_DTYPE_FUNCTION             2           /*  function. */
#define IMAGE_SYM_DTYPE_ARRAY                3           /*  array. */

/* 
 *  Storage classes.
 */

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
/*  new */
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

/*  type packing constants */

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

/*  MACROS */

/* 
 *  Communal selection types.
 */

#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3


/* 
 *  Relocation format.
 */

typedef struct _IMAGE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SymbolTableIndex;
    UINT16    Type;
} IMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

/* 
 *  I386 relocation types.
 */

#define IMAGE_REL_I386_ABSOLUTE              0           /*  Reference is absolute, no relocation is necessary */
#define IMAGE_REL_I386_DIR16                 01          /*  Direct 16-bit reference to the symbols virtual address */
#define IMAGE_REL_I386_REL16                 02          /*  PC-relative 16-bit reference to the symbols virtual address */
#define IMAGE_REL_I386_DIR32                 06          /*  Direct 32-bit reference to the symbols virtual address */
#define IMAGE_REL_I386_DIR32NB               07          /*  Direct 32-bit reference to the symbols virtual address, base not included */
#define IMAGE_REL_I386_SEG12                 011         /*  Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address */
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         /*  PC-relative 32-bit reference to the symbols virtual address */

/* 
 *  MIPS relocation types.
 */

#define IMAGE_REL_MIPS_ABSOLUTE              0           /*  Reference is absolute, no relocation is necessary */
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

/* 
 *  Alpha Relocation types.
 */

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

/* 
 *  IBM PowerPC relocation types.
 */

#define IMAGE_REL_PPC_ABSOLUTE 0x0000  /*  NOP */
#define IMAGE_REL_PPC_ADDR64   0x0001  /*  64-bit address */
#define IMAGE_REL_PPC_ADDR32   0x0002  /*  32-bit address */
#define IMAGE_REL_PPC_ADDR24   0x0003  /*  26-bit address, shifted left 2 (branch absolute) */
#define IMAGE_REL_PPC_ADDR16   0x0004  /*  16-bit address */
#define IMAGE_REL_PPC_ADDR14   0x0005  /*  16-bit address, shifted left 2 (load doubleword) */
#define IMAGE_REL_PPC_REL24    0x0006  /*  26-bit PC-relative offset, shifted left 2 (branch relative) */
#define IMAGE_REL_PPC_REL14    0x0007  /*  16-bit PC-relative offset, shifted left 2 (br cond relative) */
#define IMAGE_REL_PPC_TOCREL16 0x0008  /*  16-bit offset from TOC base */
#define IMAGE_REL_PPC_TOCREL14 0x0009  /*  16-bit offset from TOC base, shifted left 2 (load doubleword) */

#define IMAGE_REL_PPC_ADDR32NB 0x000A  /*  32-bit addr w/o image base */
#define IMAGE_REL_PPC_SECREL   0x000B  /*  va of containing section (as in an image sectionhdr) */
#define IMAGE_REL_PPC_SECTION  0x000C  /*  sectionheader number */
#define IMAGE_REL_PPC_IFGLUE   0x000D  /*  substitute TOC restore instruction iff symbol is glue code */
#define IMAGE_REL_PPC_IMGLUE   0x000E  /*  symbol is glue code; virtual address is TOC restore instruction */

#define IMAGE_REL_PPC_TYPEMASK 0x00FF  /*  mask to isolate above values in IMAGE_RELOCATION.Type */

/*  Flag bits in IMAGE_RELOCATION.TYPE */

#define IMAGE_REL_PPC_NEG      0x0100  /*  subtract reloc value rather than adding it */
#define IMAGE_REL_PPC_BRTAKEN  0x0200  /*  fix branch prediction bit to predict branch taken */
#define IMAGE_REL_PPC_BRNTAKEN 0x0400  /*  fix branch prediction bit to predict branch not taken */
#define IMAGE_REL_PPC_TOCDEFN  0x0800  /*  toc slot defined in file (or, data in toc) */

/* 
 *  Based relocation format.
 */

typedef struct _IMAGE_BASE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SizeOfBlock;
/*   UINT16    TypeOffset[1]; */
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

/* 
 *  Based relocation types.
 */

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10

/* 
 *  Line number format.
 */

typedef struct _IMAGE_LINENUMBER {
    union {
        UINT32   SymbolTableIndex;               /*  Symbol table index of function name if Linenumber is 0. */
        UINT32   VirtualAddress;                 /*  Virtual address of line number. */
    } Type;
    UINT16    Linenumber;                         /*  Line number. */
} IMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

/* 
 *  Archive format.
 */

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UINT8     Name[16];                          /*  File member name - `/' terminated. */
    UINT8     Date[12];                          /*  File member date - decimal. */
    UINT8     UserID[6];                         /*  File member user id - decimal. */
    UINT8     GroupID[6];                        /*  File member group id - decimal. */
    UINT8     Mode[8];                           /*  File member mode - octal. */
    UINT8     Size[10];                          /*  File member size - decimal. */
    UINT8     EndHeader[2];                      /*  String to end header. */
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

/* 
 *  DLL support.
 */

/* 
 *  Export Format
 */

typedef struct _IMAGE_EXPORT_DIRECTORY {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT16   MajorVersion;
    UINT16   MinorVersion;
    UINT32   Name;
    UINT32   Base;
    UINT32   NumberOfFunctions;
    UINT32   NumberOfNames;
    UINT32   *AddressOfFunctions;
    UINT32   *AddressOfNames;
    UINT32   *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

/* 
 *  Import Format
 */

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    UINT8     Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        UINT32 Function;
        UINT32 Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT32   ForwarderChain;
    UINT32   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia64\pe.h ===
/* 
    PE32+ header file
 */
#ifndef _PE_H
#define _PE_H

#define IMAGE_DOS_SIGNATURE                 0x5A4D      /*  MZ */
#define IMAGE_OS2_SIGNATURE                 0x454E      /*  NE */
#define IMAGE_OS2_SIGNATURE_LE              0x454C      /*  LE */
#define IMAGE_NT_SIGNATURE                  0x00004550  /*  PE00   */
#define IMAGE_EDOS_SIGNATURE                0x44454550  /*  PEED */

/*****************************************************************************
 * The following stuff comes from winnt.h from the ia64sdk, plus the Plabel for
 * loading EM executables.
 *****************************************************************************/
/* 
 *  Intel IA64 specific
 */

#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_IA64_DIR64            10

struct Plabel { 
    UINT64  EntryPoint;
    UINT64  NewGP;
};

typedef struct _IMAGE_DOS_HEADER {      /*  DOS .EXE header */
    UINT16   e_magic;                     /*  Magic number */
    UINT16   e_cblp;                      /*  Bytes on last page of file */
    UINT16   e_cp;                        /*  Pages in file */
    UINT16   e_crlc;                      /*  Relocations */
    UINT16   e_cparhdr;                   /*  Size of header in paragraphs */
    UINT16   e_minalloc;                  /*  Minimum extra paragraphs needed */
    UINT16   e_maxalloc;                  /*  Maximum extra paragraphs needed */
    UINT16   e_ss;                        /*  Initial (relative) SS value */
    UINT16   e_sp;                        /*  Initial SP value */
    UINT16   e_csum;                      /*  Checksum */
    UINT16   e_ip;                        /*  Initial IP value */
    UINT16   e_cs;                        /*  Initial (relative) CS value */
    UINT16   e_lfarlc;                    /*  File address of relocation table */
    UINT16   e_ovno;                      /*  Overlay number */
    UINT16   e_res[4];                    /*  Reserved words */
    UINT16   e_oemid;                     /*  OEM identifier (for e_oeminfo) */
    UINT16   e_oeminfo;                   /*  OEM information; e_oemid specific */
    UINT16   e_res2[10];                  /*  Reserved words */
    UINT32   e_lfanew;                    /*  File address of new exe header */
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      /*  OS/2 .EXE header */
    UINT16   ne_magic;                    /*  Magic number */
    UINT8    ne_ver;                      /*  Version number */
    UINT8    ne_rev;                      /*  Revision number */
    UINT16   ne_enttab;                   /*  Offset of Entry Table */
    UINT16   ne_cbenttab;                 /*  Number of bytes in Entry Table */
    UINT32   ne_crc;                      /*  Checksum of whole file */
    UINT16   ne_flags;                    /*  Flag UINT16 */
    UINT16   ne_autodata;                 /*  Automatic data segment number */
    UINT16   ne_heap;                     /*  Initial heap allocation */
    UINT16   ne_stack;                    /*  Initial stack allocation */
    UINT32   ne_csip;                     /*  Initial CS:IP setting */
    UINT32   ne_sssp;                     /*  Initial SS:SP setting */
    UINT16   ne_cseg;                     /*  Count of file segments */
    UINT16   ne_cmod;                     /*  Entries in Module Reference Table */
    UINT16   ne_cbnrestab;                /*  Size of non-resident name table */
    UINT16   ne_segtab;                   /*  Offset of Segment Table */
    UINT16   ne_rsrctab;                  /*  Offset of Resource Table */
    UINT16   ne_restab;                   /*  Offset of resident name table */
    UINT16   ne_modtab;                   /*  Offset of Module Reference Table */
    UINT16   ne_imptab;                   /*  Offset of Imported Names Table */
    UINT32   ne_nrestab;                  /*  Offset of Non-resident Names Table */
    UINT16   ne_cmovent;                  /*  Count of movable entries */
    UINT16   ne_align;                    /*  Segment alignment shift count */
    UINT16   ne_cres;                     /*  Count of resource segments */
    UINT8    ne_exetyp;                   /*  Target Operating system */
    UINT8    ne_flagsothers;              /*  Other .EXE flags */
    UINT16   ne_pretthunks;               /*  offset to return thunks */
    UINT16   ne_psegrefbytes;             /*  offset to segment ref. bytes */
    UINT16   ne_swaparea;                 /*  Minimum code swap area size */
    UINT16   ne_expver;                   /*  Expected Windows version number */
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

/* 
 *  File header format.
 */

typedef struct _IMAGE_FILE_HEADER {
    UINT16   Machine;
    UINT16   NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16   SizeOfOptionalHeader;
    UINT16   Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  /*  Relocation info stripped from file. */
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  /*  File is executable  (i.e. no unresolved externel references). */
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  /*  Line nunbers stripped from file. */
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  /*  Local symbols stripped from file. */
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  /*  Bytes of machine word are reversed. */
#define IMAGE_FILE_32BIT_MACHINE             0x0100  /*  32 bit word machine. */
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  /*  Debugging info stripped from file in .DBG file */
#define IMAGE_FILE_SYSTEM                    0x1000  /*  System File. */
#define IMAGE_FILE_DLL                       0x2000  /*  File is a DLL. */
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  /*  Bytes of machine word are reversed. */

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   /*  Intel 386. */
#define IMAGE_FILE_MACHINE_R3000             0x162   /*  MIPS little-endian, 0540 big-endian */
#define IMAGE_FILE_MACHINE_R4000             0x166   /*  MIPS little-endian */
#define IMAGE_FILE_MACHINE_ALPHA             0x184   /*  Alpha_AXP */
#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   /*  IBM PowerPC Little-Endian */
#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   /*  Intel EM machine
 * 
 *  Directory format.
 */

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32   VirtualAddress;
    UINT32   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16


typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    UINT16  Magic;
    UINT8   MajorLinkerVersion;
    UINT8   MinorLinkerVersion;
    UINT32  SizeOfCode;
    UINT32  SizeOfInitializedData;
    UINT32  SizeOfUninitializedData;
    UINT32  AddressOfEntryPoint;
    UINT32  BaseOfCode;
    UINT32  BaseOfData;
    UINT32  BaseOfBss;
    UINT32  GprMask;
    UINT32  CprMask[4];
    UINT32  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER {
    UINT16      Magic;
    UINT8       MajorLinkerVersion;
    UINT8       MinorLinkerVersion;
    UINT32      SizeOfCode;
    UINT32      SizeOfInitializedData;
    UINT32      SizeOfUninitializedData;
    UINT32      AddressOfEntryPoint;
    UINT32      BaseOfCode;
    /*  UINT32       BaseOfData; */
    UINT64      ImageBase;
    UINT32      SectionAlignment;
    UINT32      FileAlignment;
    UINT16      MajorOperatingSystemVersion;
    UINT16      MinorOperatingSystemVersion;
    UINT16      MajorImageVersion;
    UINT16      MinorImageVersion;
    UINT16      MajorSubsystemVersion;
    UINT16      MinorSubsystemVersion;
    UINT32      Win32VersionValue;
    UINT32      SizeOfImage;
    UINT32      SizeOfHeaders;
    UINT32      CheckSum;
    UINT16      Subsystem;
    UINT16      DllCharacteristics;
    UINT64      SizeOfStackReserve;
    UINT64      SizeOfStackCommit;
    UINT64      SizeOfHeapReserve;
    UINT64      SizeOfHeapCommit;
    UINT32      LoaderFlags;
    UINT32      NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;


#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER    244

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((UINT32)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


/*  Subsystem Values */

#define IMAGE_SUBSYSTEM_UNKNOWN              0   /*  Unknown subsystem. */
#define IMAGE_SUBSYSTEM_NATIVE               1   /*  Image doesn't require a subsystem. */
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   /*  Image runs in the Windows GUI subsystem. */
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   /*  Image runs in the Windows character subsystem. */
#define IMAGE_SUBSYSTEM_OS2_CUI              5   /*  image runs in the OS/2 character subsystem. */
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   /*  image run  in the Posix character subsystem. */


/*  Directory Entries */

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   /*  Export Directory */
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   /*  Import Directory */
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   /*  Resource Directory */
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   /*  Exception Directory */
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   /*  Security Directory */
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   /*  Base Relocation Table */
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   /*  Debug Directory */
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   /*  Description String */
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   /*  Machine Value (MIPS GP) */
#define IMAGE_DIRECTORY_ENTRY_TLS            9   /*  TLS Directory */
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   /*  Load Configuration Directory */

/* 
 *  Section header format.
 */

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            UINT32   PhysicalAddress;
            UINT32   VirtualSize;
    } Misc;
    UINT32   VirtualAddress;
    UINT32   SizeOfRawData;
    UINT32   PointerToRawData;
    UINT32   PointerToRelocations;
    UINT32   PointerToLinenumbers;
    UINT16   NumberOfRelocations;
    UINT16   NumberOfLinenumbers;
    UINT32   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  /*  Reserved. */

#define IMAGE_SCN_CNT_CODE                   0x00000020  /*  Section contains code. */
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  /*  Section contains initialized data. */
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  /*  Section contains uninitialized data. */

#define IMAGE_SCN_LNK_OTHER                  0x00000100  /*  Reserved. */
#define IMAGE_SCN_LNK_INFO                   0x00000200  /*  Section contains comments or some other type of information. */
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  /*  Section contents will not become part of image. */
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  /*  Section contents comdat. */

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  /*  */
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  /*  */
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  /*  */
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  /*  */
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  /*  Default alignment if no others are specified. */
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  /*  */
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  /*  */

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  /*  Section can be discarded. */
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  /*  Section is not cachable. */
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  /*  Section is not pageable. */
#define IMAGE_SCN_MEM_SHARED                 0x10000000  /*  Section is shareable. */
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  /*  Section is executable. */
#define IMAGE_SCN_MEM_READ                   0x40000000  /*  Section is readable. */
#define IMAGE_SCN_MEM_WRITE                  0x80000000  /*  Section is writeable. */

/* 
 *  Symbol format.
 */


#define IMAGE_SIZEOF_SYMBOL                  18

/* 
 *  Section values.
 * 
 *  Symbols have a section number of the section in which they are
 *  defined. Otherwise, section numbers have the following meanings:
 */

#define IMAGE_SYM_UNDEFINED           (UINT16)0           /*  Symbol is undefined or is common. */
#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          /*  Symbol is an absolute value. */
#define IMAGE_SYM_DEBUG               (UINT16)-2          /*  Symbol is a special debug item. */

/* 
 *  Type (fundamental) values.
 */

#define IMAGE_SYM_TYPE_NULL                  0           /*  no type. */
#define IMAGE_SYM_TYPE_VOID                  1           /*  */
#define IMAGE_SYM_TYPE_CHAR                  2           /*  type character. */
#define IMAGE_SYM_TYPE_SHORT                 3           /*  type short integer. */
#define IMAGE_SYM_TYPE_INT                   4           /*  */
#define IMAGE_SYM_TYPE_LONG                  5           /*  */
#define IMAGE_SYM_TYPE_FLOAT                 6           /*  */
#define IMAGE_SYM_TYPE_DOUBLE                7           /*  */
#define IMAGE_SYM_TYPE_STRUCT                8           /*  */
#define IMAGE_SYM_TYPE_UNION                 9           /*  */
#define IMAGE_SYM_TYPE_ENUM                  10          /*  enumeration. */
#define IMAGE_SYM_TYPE_MOE                   11          /*  member of enumeration. */
#define IMAGE_SYM_TYPE_BYTE                  12          /*  */
#define IMAGE_SYM_TYPE_WORD                  13          /*  */
#define IMAGE_SYM_TYPE_UINT                  14          /*  */
#define IMAGE_SYM_TYPE_DWORD                 15          /*  */

/* 
 *  Type (derived) values.
 */

#define IMAGE_SYM_DTYPE_NULL                 0           /*  no derived type. */
#define IMAGE_SYM_DTYPE_POINTER              1           /*  pointer. */
#define IMAGE_SYM_DTYPE_FUNCTION             2           /*  function. */
#define IMAGE_SYM_DTYPE_ARRAY                3           /*  array. */

/* 
 *  Storage classes.
 */

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
/*  new */
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

/*  type packing constants */

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

/*  MACROS */

/* 
 *  Communal selection types.
 */

#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3


/* 
 *  Relocation format.
 */

typedef struct _IMAGE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SymbolTableIndex;
    UINT16   Type;
} IMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

/* 
 *  I386 relocation types.
 */

#define IMAGE_REL_I386_ABSOLUTE              0           /*  Reference is absolute, no relocation is necessary */
#define IMAGE_REL_I386_DIR16                 01          /*  Direct 16-bit reference to the symbols virtual address */
#define IMAGE_REL_I386_REL16                 02          /*  PC-relative 16-bit reference to the symbols virtual address */
#define IMAGE_REL_I386_DIR32                 06          /*  Direct 32-bit reference to the symbols virtual address */
#define IMAGE_REL_I386_DIR32NB               07          /*  Direct 32-bit reference to the symbols virtual address, base not included */
#define IMAGE_REL_I386_SEG12                 011         /*  Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address */
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         /*  PC-relative 32-bit reference to the symbols virtual address */

/* 
 *  MIPS relocation types.
 */

#define IMAGE_REL_MIPS_ABSOLUTE              0           /*  Reference is absolute, no relocation is necessary */
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

/* 
 *  Alpha Relocation types.
 */

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

/* 
 *  IBM PowerPC relocation types.
 */

#define IMAGE_REL_PPC_ABSOLUTE 0x0000  /*  NOP */
#define IMAGE_REL_PPC_ADDR64   0x0001  /*  64-bit address */
#define IMAGE_REL_PPC_ADDR32   0x0002  /*  32-bit address */
#define IMAGE_REL_PPC_ADDR24   0x0003  /*  26-bit address, shifted left 2 (branch absolute) */
#define IMAGE_REL_PPC_ADDR16   0x0004  /*  16-bit address */
#define IMAGE_REL_PPC_ADDR14   0x0005  /*  16-bit address, shifted left 2 (load doubleword) */
#define IMAGE_REL_PPC_REL24    0x0006  /*  26-bit PC-relative offset, shifted left 2 (branch relative) */
#define IMAGE_REL_PPC_REL14    0x0007  /*  16-bit PC-relative offset, shifted left 2 (br cond relative) */
#define IMAGE_REL_PPC_TOCREL16 0x0008  /*  16-bit offset from TOC base */
#define IMAGE_REL_PPC_TOCREL14 0x0009  /*  16-bit offset from TOC base, shifted left 2 (load doubleword) */

#define IMAGE_REL_PPC_ADDR32NB 0x000A  /*  32-bit addr w/o image base */
#define IMAGE_REL_PPC_SECREL   0x000B  /*  va of containing section (as in an image sectionhdr) */
#define IMAGE_REL_PPC_SECTION  0x000C  /*  sectionheader number */
#define IMAGE_REL_PPC_IFGLUE   0x000D  /*  substitute TOC restore instruction iff symbol is glue code */
#define IMAGE_REL_PPC_IMGLUE   0x000E  /*  symbol is glue code; virtual address is TOC restore instruction */

#define IMAGE_REL_PPC_TYPEMASK 0x00FF  /*  mask to isolate above values in IMAGE_RELOCATION.Type */

/*  Flag bits in IMAGE_RELOCATION.TYPE */

#define IMAGE_REL_PPC_NEG      0x0100  /*  subtract reloc value rather than adding it */
#define IMAGE_REL_PPC_BRTAKEN  0x0200  /*  fix branch prediction bit to predict branch taken */
#define IMAGE_REL_PPC_BRNTAKEN 0x0400  /*  fix branch prediction bit to predict branch not taken */
#define IMAGE_REL_PPC_TOCDEFN  0x0800  /*  toc slot defined in file (or, data in toc) */

/* 
 *  Based relocation format.
 */

typedef struct _IMAGE_BASE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SizeOfBlock;
/*   UINT16    TypeOffset[1]; */
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

/* 
 *  Based relocation types.
 */

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10

/* 
 *  Line number format.
 */

typedef struct _IMAGE_LINENUMBER {
    union {
        UINT32   SymbolTableIndex;               /*  Symbol table index of function name if Linenumber is 0. */
        UINT32   VirtualAddress;                 /*  Virtual address of line number. */
    } Type;
    UINT16    Linenumber;                         /*  Line number. */
} IMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

/* 
 *  Archive format.
 */

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UINT8     Name[16];                          /*  File member name - `/' terminated. */
    UINT8     Date[12];                          /*  File member date - decimal. */
    UINT8     UserID[6];                         /*  File member user id - decimal. */
    UINT8     GroupID[6];                        /*  File member group id - decimal. */
    UINT8     Mode[8];                           /*  File member mode - octal. */
    UINT8     Size[10];                          /*  File member size - decimal. */
    UINT8     EndHeader[2];                      /*  String to end header. */
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

/* 
 *  DLL support.
 */

/* 
 *  Export Format
 */

typedef struct _IMAGE_EXPORT_DIRECTORY {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT16   MajorVersion;
    UINT16   MinorVersion;
    UINT32   Name;
    UINT32   Base;
    UINT32   NumberOfFunctions;
    UINT32   NumberOfNames;
    UINT32   AddressOfFunctions;
    UINT32   AddressOfNames;
    UINT32   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

/* 
 *  Import Format
 */

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    UINT8     Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        UINT32 Function;
        UINT32 Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT32   ForwarderChain;
    UINT32   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\ia64\salproc.h ===
#ifndef _SAL_PROC_H
#define _SAL_PROC_H
/* 
 * 
 * Copyright (c) 1999  Intel Corporation
 * 
 * Module Name:
 * 
 *     SalProc.h
 * 
 * Abstract:
 * 
 *     Main SAL interface routins for IA-64 calls. 
 * 
 * 
 * Revision History
 * 
 */

/*   return value that mimicks r8,r9,r10 & r11 registers  */
typedef struct {
    UINT64     p0;
    UINT64     p1;
    UINT64     p2;
    UINT64     p3;
} rArg;

#define  SAL_PCI_CONFIG_READ                    0x01000010
#define  SAL_PCI_CONFIG_WRITE                   0x01000011

typedef VOID (*PFN)();
typedef rArg (*PFN_SAL_PROC)(UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64);
typedef rArg (*PFN_SAL_CALLBACK)(UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64);

typedef struct _PLABEL {
   UINT64 ProcEntryPoint;
   UINT64 GP;
} PLABEL;

typedef struct tagIA32_BIOS_REGISTER_STATE {

    /*  general registers */
    UINT32 eax;
    UINT32 ecx;
    UINT32 edx;
    UINT32 ebx;

    /*  stack registers */
    UINT32 esp;
    UINT32 ebp;
    UINT32 esi;
    UINT32 edi;

    /*  eflags */
    UINT32 eflags;

    /*  instruction pointer */
    UINT32 eip;

    UINT16 cs;
    UINT16 ds;
    UINT16 es;
    UINT16 fs;
    UINT16 gs;
    UINT16 ss;

    /*  Reserved */
    UINT32 Reserved1;
    UINT64 Reserved2;
} IA32_BIOS_REGISTER_STATE;

VOID EFIInitMsg(VOID);

EFI_STATUS
PlRegisterAndStartTimer(
    IN UINTN Period
    );

EFI_STATUS
PlDeRegisterAndCancelTimer(VOID);

VOID
SalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );

VOID
SalCallBack (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );

VOID
RUNTIMEFUNCTION
RtSalCallBack (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );


extern PLABEL   RtGlobalSalProcEntry;
extern PLABEL   RtGlobalSALCallBack;

#pragma pack(1)
/* 
 *  SAL System Table
 */
typedef struct {
    UINT32 Signature;
    UINT32 Length;
    UINT16 Revision;
    UINT16 EntryCount;
    UINT8  CheckSum;
    UINT8  Reserved[7];
    UINT16 SALA_Ver;
    UINT16 SALB_Ver;
    UINT8  OemId[32];
    UINT8  ProductID[32];
    UINT8  Reserved2[8];
} SAL_SYSTEM_TABLE_HDR;

#define SAL_ST_ENTRY_POINT          0
#define SAL_ST_MEMORY_DESCRIPTOR    1
#define SAL_ST_PLATFORM_FEATURES    2
#define SAL_ST_TR_USAGE             3
#define SAL_ST_PTC                  4
#define SAL_ST_AP_WAKEUP            5

typedef struct {
    UINT8   Type;   /*   Type == 0  */
    UINT8   Reserved[7];
    UINT64  PalProcEntry;
    UINT64  SalProcEntry;
    UINT64  GlobalDataPointer;
    UINT64  Reserved2[2];
} SAL_ST_ENTRY_POINT_DESCRIPTOR;

typedef struct {
    UINT8   Type;   /*   Type == 1 */
    UINT8   NeedVirtualRegistration;
    UINT8   MemoryAttributes;
    UINT8   PageAccessRights;
    UINT8   SupportedAttributes;
    UINT8   Reserved;
    UINT16  MemoryType;
    UINT64  PhysicalMemoryAddress;
    UINT32  Length;
    UINT32  Reserved1;
    UINT64  OemReserved;
} SAL_ST_MEMORY_DESCRIPTOR_ENTRY;

/* 
 *  MemoryType info
 */
#define SAL_SAPIC_IPI_BLOCK 0x0002
#define SAL_IO_PORT_MAPPING 0x0003

typedef struct {
    UINT8   Type;   /*  Type == 2 */
    UINT8   PlatformFeatures;
    UINT8   Reserved[14];
} SAL_ST_MEMORY_DECRIPTOR;

typedef struct {
    UINT8   Type;   /*  Type == 3 */
    UINT8   TRType;
    UINT8   TRNumber;
    UINT8   Reserved[5];
    UINT64  VirtualAddress;
    UINT64  EncodedPageSize;
    UINT64  Reserved1;
} SAL_ST_TR_DECRIPTOR;

typedef struct {
    UINT64  NumberOfProcessors;
    UINT64  LocalIDRegister;
} SAL_COHERENCE_DOMAIN_INFO;

typedef struct {
    UINT8                       Type;   /*  Type == 4 */
    UINT8                       Reserved[3];
    UINT32                      NumberOfDomains;
    SAL_COHERENCE_DOMAIN_INFO  *DomainInformation;
} SAL_ST_CACHE_COHERENCE_DECRIPTOR;

typedef struct {
    UINT8   Type;   /*  Type == 5 */
    UINT8   WakeUpType;
    UINT8   Reserved[6];
    UINT64  ExternalInterruptVector;
} SAL_ST_AP_WAKEUP_DECRIPTOR;

typedef struct {
    SAL_SYSTEM_TABLE_HDR            Header;
    SAL_ST_ENTRY_POINT_DESCRIPTOR   Entry0;
} SAL_SYSTEM_TABLE_ASCENDING_ORDER;

#define     FIT_ENTRY_PTR       (0x100000000 - 32)  /*  4GB - 24 */
#define     FIT_PALA_ENTRY      (0x100000000 - 48)  /*  4GB - 32 */
#define     FIT_PALB_TYPE       01

typedef struct {
    UINT64  Address;
    UINT8   Size[3];
    UINT8   Reserved;
    UINT16  Revision;
    UINT8   Type:7;
    UINT8   CheckSumValid:1;
    UINT8   CheckSum;
} FIT_ENTRY;

#pragma pack()

typedef
 rArg 
(*CALL_SAL_PROC)(
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8
    );

typedef
 rArg 
(*CALL_PAL_PROC)(
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4
    );

extern CALL_SAL_PROC   GlobalSalProc;
extern CALL_PAL_PROC   GlobalPalProc;
extern PLABEL   SalProcPlabel;
extern PLABEL   PalProcPlabel;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\protocol\intload.h ===
/*++

Copyright (c) 1999 Intel Corporation

Module Name:

    intload

Abstract:

    EFI support for loading internally linked in apps



Revision History

--*/

#ifndef _INTERNAL_LOAD_INCLUDE_
#define _INTERNAL_LOAD_INCLUDE_

/*  {D65A6B8C-71E5-4df0-A909-F0D2992B5AA9} */
#define INTERNAL_LOAD_PROTOCOL \
    { 0xd65a6b8c, 0x71e5, 0x4df0, { 0xa9, 0x09, 0xf0, 0xd2, 0x99, 0x2b, 0x5a, 0xa9} }


typedef
EFI_STATUS
(EFIAPI *INTERNAL_LOAD_SHELL) (
    VOID
    );

typedef struct _INTERNAL_LOAD_INTERFACE {
    INTERNAL_LOAD_SHELL    LoadShell;

} INTERNAL_LOAD_INTERFACE;

EFI_STATUS
PlInitializeInternalLoad (
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\protocol\piflash64.h ===
#ifndef _PIFLASH64_H
#define _PIFLASH64_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    PIflash64.h
    
Abstract:

    Iflash64.efi protocol to abstract iflash from
    the system.

Revision History

--*/

/* 
 *  Guid that identifies the IFLASH protocol
 */
#define IFLASH64_PROTOCOL_PROTOCOL \
    { 0x65cba110, 0x74ab, 0x11d3, 0xbb, 0x89, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 };

/* 
 *  Unlock FLASH from StartAddress to EndAddress and return a LockKey
 */
typedef
EFI_STATUS
(EFIAPI *UNLOCK_FLASH_API)(
    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
    );

/* 
 *  Lock the flash represented by the LockKey
 */
typedef
EFI_STATUS
(EFIAPI *LOCK_FLASH_API)(
    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
    );

/* 
 *  Status callback for a utility like IFLASH64
 * 
 *   Token would map to a list like Ted proposed. The utility has no idea what 
 *       happens on the other side.
 *   ErrorStatus - Level of Error or success. Independent of Token. If you 
 *       don't know the token you will at least know pass or fail.
 *   String - Optional extra information about the error. Could be used for 
 *       debug or future expansion
 * 
 *   Attributes - Options screen attributes for String. Could allow the string to be different colors.
 */
typedef
EFI_STATUS
(EFIAPI *UTILITY_PROGRESS_API)(
    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This,
    IN  UINTN                               Token,
    IN  EFI_STATUS                          ErrorStatus, 
    IN  CHAR16                              *String,    OPTIONAL
    IN  UINTN                               *Attributes OPTIONAL
    );

/* 
 *  Token Values
 * 
 *  IFlash64 Token Codes */
#define IFLASH_TOKEN_IFLASHSTART    0xB0                /*  IFlash64 has started */
#define IFLASH_TOKEN_READINGFILE    0xB1                /*  Reading File */
#define IFLASH_TOKEN_INITVPP        0xB2                /*  Initializing Vpp */
#define IFLASH_TOKEN_DISABLEVPP     0x10                /*  Disable Vpp */
#define IFLASH_TOKEN_FLASHUNLOCK    0xB3                /*  Unlocking FLASH Devices */
#define IFLASH_TOKEN_FLASHERASE     0xB4                /*  Erasing FLASH Devices */
#define IFLASH_TOKEN_FLASHPROGRAM   0xB5                /*  Programming FLASH */
#define IFLASH_TOKEN_FLASHVERIFY    0xB6                /*  Verifying FLASH */
#define IFLASH_TOKEN_UPDATESUCCES   0xB7                /*  FLASH Updage Success! */

#define IFLASH_TOKEN_PROGRESS_READINGFILE   0x11        /*  % Reading File */
#define IFLASH_TOKEN_PROGRESS_FLASHUNLOCK   0x13        /*  % Unlocking FLASH Devices */
#define IFLASH_TOKEN_PROGRESS_FLASHERASE    0x14        /*  % Erasing FLASH Devices */
#define IFLASH_TOKEN_PROGRESS_FLASHPROGRAM  0x15        /*  % Programming FLASH */
#define IFLASH_TOKEN_PROGRESS_FLASHVERIFY   0x16        /*  % Verifying FLASH */

#define IFLASH_TOKEN_READINGFILE_ER 0xB8                /*  File Read Error */
#define IFLASH_TOKEN_INITVPP_ER     0xB9                /*  Initialization of IFB Error */
#define IFLASH_TOKEN_FLASHUNLOCK_ER 0xBA                /*  FLASH Unlock Error */
#define IFLASH_TOKEN_FLASHERASE_ER  0xBB                /*  FLASH Erase Error */
#define IFLASH_TOKEN_FLASHVERIFY_ER 0xBC                /*  FLASH Verify Error */
#define IFLASH_TOKEN_FLASHPROG_ER   0xBD                /*  FLASH Program Error */

#define IFLASH_TABLE_END            0x00

/* 
 *  If this number changes one of the existing API's has changes
 */
#define IFLASH_PI_MAJOR_VERSION 0x01

/* 
 *  This number changes when new APIs or data variables get added to the end
 *   of the data structure
 */
#define IFLASH_PI_MINOR_VERSION 0x01

typedef struct _IFLASH64_PROTOCOL_INTERFACE {
    UINT32                  MajorVersion;       
    UINT32                  MinorVersion;   
    UNLOCK_FLASH_API        UnlockFlash;
    LOCK_FLASH_API          LockFlash;
    UTILITY_PROGRESS_API    Progress;
    
    /* 
     *  Future expansion goes here
     */

} IFLASH64_PROTOCOL_INTERFACE;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\protocol\efivar.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

Abstract:



Revision History

--*/



/* 
 *  The variable store protocol interface is specific to the reference
 *  implementation.  The initialization code adds variable store devices
 *  to the system, and the FW connects to the devices to provide the
 *  variable store interfaces through these devices.
 */

/* 
 *  Variable Store Device protocol
 */

#define VARIABLE_STORE_PROTOCOL    \
    { 0xf088cd91, 0xa046, 0x11d2, 0x8e, 0x42, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_EFI_VARIABLE_STORE);

typedef
EFI_STATUS
(EFIAPI *EFI_STORE_CLEAR) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN OUT VOID                     *Scratch
    );


typedef
EFI_STATUS
(EFIAPI *EFI_STORE_READ) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN UINTN                        Offset,
    IN UINTN                        BufferSize,
    OUT VOID                        *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_STORE_UPDATE) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN UINTN                        Offset,
    IN UINTN                        BufferSize,
    IN VOID                         *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_STORE_SIZE) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        NoBanks
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TRANSACTION_UPDATE) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN VOID                         *NewContents
    );

typedef struct _EFI_VARIABLE_STORE {

    /* 
     *  Number of banks and bank size
     */

    UINT32                      Attributes;
    UINT32                      BankSize;
    UINT32                      NoBanks;

    /* 
     *  Functions to access the storage banks
     */

    EFI_STORE_CLEAR             ClearStore;
    EFI_STORE_READ              ReadStore;
    EFI_STORE_UPDATE            UpdateStore;
    EFI_STORE_SIZE              SizeStore OPTIONAL;
    EFI_TRANSACTION_UPDATE      TransactionUpdate OPTIONAL;

} EFI_VARIABLE_STORE;


/* 
 * 
 *  ClearStore()     - A function to clear the requested storage bank.  A cleared
 *       bank contains all "on" bits.
 * 
 *  ReadStore()      - Read data from the requested store.
 * 
 *  UpdateStore()    - Updates data on the requested store. The FW will only
 *       ever issue updates to clear bits in the store. Updates must be
 *       performed in LSb to MSb order of the update buffer.
 * 
 *  SizeStore()      - An optional function for non-runtime stores that can be
 *       dynamically sized.  The FW will only ever increase or decrease the store
 *       by 1 banksize at a time, and it is always adding or removing a bank from 
 *       the end of the store.
 * 
 *  By default the FW will update variables and storage banks in an
 *  "atomic" manner by keeping 1 old copy of the data during an update,
 *  and recovering appropiately if the power is lost during the middle
 *  of an operation.  To do this the FW needs to have multiple banks
 *  of storage dedicated to its use. If that's not possible, the driver 
 *  can implement an atomic bank update function and the FW will allow 
 *  1 bank in this case.  (It will allow any number of banks,
 *  but it won't require an "extra" bank to provide its bank transaction 
 *  function).
 * 
 *  TransactionUpdate()  - An optional function that can clear & update an 
 *       entire bank in an "atomic" fashion.  If the operation fails in the 
 *       middle the driver is responsible for having either the previous copy 
 *       of the bank's data or the new copy.  A copy that's partially written
 *       is not valid as internal data settings may get lost.  Supply this
 *       function only when needed.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\protocol\vgaclass.h ===
#ifndef _VGA_CLASS_H
#define _VGA_CLASS_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    VgaClass.h
    
Abstract:

    Vga Mini port binding to Vga Class protocol



Revision History

--*/

/* 
 *  VGA Device Structure
 */

/*  {0E3D6310-6FE4-11d3-BB81-0080C73C8881} */
#define VGA_CLASS_DRIVER_PROTOCOL \
    { 0xe3d6310, 0x6fe4, 0x11d3, 0xbb, 0x81, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }

typedef 
EFI_STATUS 
(* INIT_VGA_CARD) (
    IN  UINTN   VgaMode,
    IN  VOID    *Context
    );

typedef struct {
    UINTN   MaxColumns;
    UINTN   MaxRows;
} MAX_CONSOLE_GEOMETRY;

#define VGA_CON_OUT_DEV_SIGNATURE   EFI_SIGNATURE_32('c','v','g','a')
typedef struct {
    UINTN                           Signature;

    EFI_HANDLE                      Handle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    ConOut;
    SIMPLE_TEXT_OUTPUT_MODE         ConOutMode;
    EFI_DEVICE_PATH                 *DevicePath;

    UINT8                           *Buffer;
    EFI_DEVICE_IO_INTERFACE         *DeviceIo;

    /* 
     *  Video Card Context
     */
    INIT_VGA_CARD                   InitVgaCard;
    VOID                            *VgaCardContext;
    MAX_CONSOLE_GEOMETRY            *Geometry;
    /* 
     *  Video buffer normally 0xb8000
     */
    UINT64                          VideoBuffer;

    /* 
     *  Clear Screen & Default Attribute
     */
    UINT32                          Attribute;

    /* 
     *  -1 means search for active VGA device
     */
    EFI_PCI_ADDRESS_UNION           Pci;
} VGA_CON_OUT_DEV;

#define VGA_CON_OUT_DEV_FROM_THIS(a) CR(a, VGA_CON_OUT_DEV, ConOut, VGA_CON_OUT_DEV_SIGNATURE)

/* 
 *  Vga Class Driver Protocol. 
 *  GUID defined in EFI Lib
 */

typedef 
EFI_STATUS
(EFIAPI *INSTALL_VGA_DRIVER) (
    IN  VGA_CON_OUT_DEV    *ConOutDev 
    );

typedef struct {
    UINT32               Version;
    INSTALL_VGA_DRIVER   InstallGenericVgaDriver;
} INSTALL_VGA_DRIVER_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\boxdraw.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    BoxDraw.c

Abstract:
    Lib functions to support Box Draw Unicode code pages.



Revision History

--*/

#include "lib.h"

typedef struct {
    CHAR16  Unicode;
    CHAR8   PcAnsi;
    CHAR8   Ascii;
} UNICODE_TO_CHAR;


/* 
 *  This list is used to define the valid extend chars.
 *  It also provides a mapping from Unicode to PCANSI or
 *  ASCII. The ASCII mapping we just made up.
 * 
 */

STATIC UNICODE_TO_CHAR UnicodeToPcAnsiOrAscii[] = {
    BOXDRAW_HORIZONTAL,                 0xc4, L'-', 
    BOXDRAW_VERTICAL,                   0xb3, L'|',
    BOXDRAW_DOWN_RIGHT,                 0xda, L'/',
    BOXDRAW_DOWN_LEFT,                  0xbf, L'\\',
    BOXDRAW_UP_RIGHT,                   0xc0, L'\\',
    BOXDRAW_UP_LEFT,                    0xd9, L'/',
    BOXDRAW_VERTICAL_RIGHT,             0xc3, L'|',
    BOXDRAW_VERTICAL_LEFT,              0xb4, L'|',
    BOXDRAW_DOWN_HORIZONTAL,            0xc2, L'+',
    BOXDRAW_UP_HORIZONTAL,              0xc1, L'+',
    BOXDRAW_VERTICAL_HORIZONTAL,        0xc5, L'+',
    BOXDRAW_DOUBLE_HORIZONTAL,          0xcd, L'-',
    BOXDRAW_DOUBLE_VERTICAL,            0xba, L'|',
    BOXDRAW_DOWN_RIGHT_DOUBLE,          0xd5, L'/',
    BOXDRAW_DOWN_DOUBLE_RIGHT,          0xd6, L'/',
    BOXDRAW_DOUBLE_DOWN_RIGHT,          0xc9, L'/',
    BOXDRAW_DOWN_LEFT_DOUBLE,           0xb8, L'\\',
    BOXDRAW_DOWN_DOUBLE_LEFT,           0xb7, L'\\',
    BOXDRAW_DOUBLE_DOWN_LEFT,           0xbb, L'\\',
    BOXDRAW_UP_RIGHT_DOUBLE,            0xd4, L'\\',
    BOXDRAW_UP_DOUBLE_RIGHT,            0xd3, L'\\',
    BOXDRAW_DOUBLE_UP_RIGHT,            0xc8, L'\\',
    BOXDRAW_UP_LEFT_DOUBLE,             0xbe, L'/',
    BOXDRAW_UP_DOUBLE_LEFT,             0xbd, L'/',
    BOXDRAW_DOUBLE_UP_LEFT,             0xbc, L'/',
    BOXDRAW_VERTICAL_RIGHT_DOUBLE,      0xc6, L'|',
    BOXDRAW_VERTICAL_DOUBLE_RIGHT,      0xc7, L'|',
    BOXDRAW_DOUBLE_VERTICAL_RIGHT,      0xcc, L'|',
    BOXDRAW_VERTICAL_LEFT_DOUBLE,       0xb5, L'|',
    BOXDRAW_VERTICAL_DOUBLE_LEFT,       0xb6, L'|',
    BOXDRAW_DOUBLE_VERTICAL_LEFT,       0xb9, L'|',
    BOXDRAW_DOWN_HORIZONTAL_DOUBLE,     0xd1, L'+',
    BOXDRAW_DOWN_DOUBLE_HORIZONTAL,     0xd2, L'+',
    BOXDRAW_DOUBLE_DOWN_HORIZONTAL,     0xcb, L'+',
    BOXDRAW_UP_HORIZONTAL_DOUBLE,       0xcf, L'+',
    BOXDRAW_UP_DOUBLE_HORIZONTAL,       0xd0, L'+',
    BOXDRAW_DOUBLE_UP_HORIZONTAL,       0xca, L'+',
    BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE, 0xd8, L'+',
    BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL, 0xd7, L'+',
    BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL, 0xce, L'+',

    BLOCKELEMENT_FULL_BLOCK,            0xdb, L'*',
    BLOCKELEMENT_LIGHT_SHADE,           0xb0, L'+',

    GEOMETRICSHAPE_UP_TRIANGLE,         0x1e, L'^',
    GEOMETRICSHAPE_RIGHT_TRIANGLE,      0x10, L'>',
    GEOMETRICSHAPE_DOWN_TRIANGLE,       0x1f, L'v',
    GEOMETRICSHAPE_LEFT_TRIANGLE,       0x11, L'<',

    /* BugBug: Left Arrow is an ESC. We can not make it print
                on a PCANSI terminal. If we can make left arrow 
                come out on PC ANSI we can add it back.

    ARROW_LEFT,                         0x1b, L'<',
    */

    ARROW_UP,                           0x18, L'^',
    
    /* BugBut: Took out left arrow so right has to go too.
    ARROW_RIGHT,                        0x1a, L'>',
    */      
    ARROW_DOWN,                         0x19, L'v',
    
    0x0000, 0x00
};


BOOLEAN
LibIsValidTextGraphics (
    IN  CHAR16  Graphic,
    OUT CHAR8   *PcAnsi,    OPTIONAL
    OUT CHAR8   *Ascii      OPTIONAL
    )
/*++

Routine Description:

    Detects if a Unicode char is for Box Drawing text graphics.

Arguments:

    Grphic  - Unicode char to test.

    PcAnsi  - Optional pointer to return PCANSI equivalent of Graphic.

    Asci    - Optional pointer to return Ascii equivalent of Graphic.

Returns:

    TRUE if Gpaphic is a supported Unicode Box Drawing character.

--*/{
    UNICODE_TO_CHAR     *Table;

    if ((((Graphic & 0xff00) != 0x2500) && ((Graphic & 0xff00) != 0x2100))) {
     
        /* 
         *  Unicode drawing code charts are all in the 0x25xx range, 
         *   arrows are 0x21xx
         */
        return FALSE;
    }

    for (Table = UnicodeToPcAnsiOrAscii; Table->Unicode != 0x0000; Table++) {
        if (Graphic == Table->Unicode) {
            if (PcAnsi) {
                *PcAnsi = Table->PcAnsi; 
            }
            if (Ascii) {
                *Ascii = Table->Ascii;
            }
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
IsValidAscii (
    IN  CHAR16  Ascii
    )
{
    if ((Ascii >= 0x20) && (Ascii <= 0x7f)) {
        return TRUE;
    }              
    return FALSE;
}

BOOLEAN
IsValidEfiCntlChar (
    IN  CHAR16  c
    )
{
    if (c == CHAR_NULL || c == CHAR_BACKSPACE || c == CHAR_LINEFEED || c == CHAR_CARRIAGE_RETURN) {
        return TRUE;
    }              
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\console.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    console.c

Abstract:




Revision History

--*/

#include "lib.h"



VOID
Output (
    IN CHAR16   *Str
    )
/*  Write a string to the console at the current cursor location */
{
    ST->ConOut->OutputString (ST->ConOut, Str);
}


VOID
Input (
    IN CHAR16    *Prompt OPTIONAL,
    OUT CHAR16   *InStr,
    IN UINTN     StrLen
    )
/*  Input a string at the current cursor location, for StrLen */
{
    IInput (
        ST->ConOut,
        ST->ConIn,
        Prompt,
        InStr,
        StrLen
        );
}

VOID
IInput (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
    IN SIMPLE_INPUT_INTERFACE           *ConIn,
    IN CHAR16                           *Prompt OPTIONAL,
    OUT CHAR16                          *InStr,
    IN UINTN                            StrLen
    )
/*  Input a string at the current cursor location, for StrLen */
{
    EFI_INPUT_KEY                   Key;
    EFI_STATUS                      Status;
    UINTN                           Len;

    if (Prompt) {
        ConOut->OutputString (ConOut, Prompt);
    }

    Len = 0;
    for (; ;) {
        WaitForSingleEvent (ConIn->WaitForKey, 0);

        Status = ConIn->ReadKeyStroke(ConIn, &Key);
        if (EFI_ERROR(Status)) {
            DEBUG((D_ERROR, "Input: error return from ReadKey %x\n", Status));
            break;
        }

        if (Key.UnicodeChar == '\n' ||
            Key.UnicodeChar == '\r') {
            break;
        }
        
        if (Key.UnicodeChar == '\b') {
            if (Len) {
                ConOut->OutputString(ConOut, L"\b \b");
                Len -= 1;
            }
            continue;
        }

        if (Key.UnicodeChar >= ' ') {
            if (Len < StrLen-1) {
                InStr[Len] = Key.UnicodeChar;

                InStr[Len+1] = 0;
                ConOut->OutputString(ConOut, &InStr[Len]);

                Len += 1;
            }
            continue;
        }
    }

    InStr[Len] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\inc\protocol\legacyboot.h ===
/*++

Copyright (c) 1999 Intel Corporation

Module Name:

    legacyboot

Abstract:

    EFI support for legacy boot



Revision History

--*/

#ifndef _LEGACY_BOOT_INCLUDE_
#define _LEGACY_BOOT_INCLUDE_

#define LEGACY_BOOT_PROTOCOL \
    { 0x376e5eb2, 0x30e4, 0x11d3, { 0xba, 0xe5, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }

#pragma pack(1)

/* 
 *  BBS 1.01 (See Appendix A) IPL and BCV Table Entry Data structure.
 *   Seg:Off pointers have been converted to EFI pointers in this data structure
 *   This is the structure that also maps to the EFI device path for the boot selection
 */
typedef struct {
    UINT16  DeviceType;
    UINT16  StatusFlag;
    UINT32  Reserved;
    VOID    *BootHandler;   /*  Not an EFI entry point */
    CHAR8   *DescString;
} BBS_TABLE_ENTRY;
#pragma pack()

typedef
EFI_STATUS
(EFIAPI *LEGACY_BOOT_CALL) (
    IN EFI_DEVICE_PATH      *DevicePath
    );


/* 
 *  BBS support functions
 *   PnP Call numbers and BiosSelector hidden in implementation
 */

typedef enum {
    IplRelative,
    BcvRelative
} BBS_TYPE;


/* 
 *  == PnP Function 0x60 then BbsVersion == 0x0101 if this call fails then BbsVersion == 0x0000
 */

/* 
 *  == PnP Function 0x61
 */
typedef
EFI_STATUS
(EFIAPI *GET_DEVICE_COUNT) (
    IN  struct _LEGACY_BOOT_INTERFACE   *This,
    IN  BBS_TYPE        *TableType,
    OUT UINTN           *DeviceCount,
    OUT UINTN           *MaxCount
    );

/* 
 *  == PnP Function 0x62
 */
typedef
EFI_STATUS
(EFIAPI *GET_PRIORITY_AND_TABLE) (
    IN  struct _LEGACY_BOOT_INTERFACE   *This,
    IN  BBS_TYPE        *TableType,
    IN OUT  UINTN       *PrioritySize, /*  MaxCount * sizeof(UINT8) */
    OUT     UINTN       *Priority,
    IN OUT  UINTN       *TableSize,    /*  MaxCount * sizeof(BBS_TABLE_ENTRY) */
    OUT BBS_TABLE_ENTRY *TableEntrySize
    );

/* 
 *  == PnP Function 0x63
 */
typedef
EFI_STATUS
(EFIAPI *SET_PRIORITY) (
    IN  struct _LEGACY_BOOT_INTERFACE   *This,
    IN  BBS_TYPE        *TableType,
    IN OUT  UINTN       *PrioritySize,
    OUT     UINTN       *Priority
    );

typedef struct _LEGACY_BOOT_INTERFACE {
    LEGACY_BOOT_CALL    BootIt;

    /* 
     *  New functions to allow BBS booting to be configured from EFI
     */
    UINTN                   BbsVersion;     /*  Currently 0x0101 */
    GET_DEVICE_COUNT        GetDeviceCount;
    GET_PRIORITY_AND_TABLE  GetPriorityAndTable;
    SET_PRIORITY            SetPriority;   
} LEGACY_BOOT_INTERFACE;

EFI_STATUS
PlInitializeLegacyBoot (
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\crc.c ===
/*++

Copyright (c) 1998  Intel Corporation
    
Module Name:

    crc.c

Abstract:

    CRC32 functions



Revision History

--*/

#include "lib.h"


UINT32 CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D 
    };
    


VOID
SetCrc (
    IN OUT EFI_TABLE_HEADER *Hdr
    )
/*++

Routine Description:

    Updates the CRC32 value in the table header

Arguments:

    Hdr     - The table to update

Returns:

    None

--*/
{
    SetCrcAltSize (Hdr->HeaderSize, Hdr);
}

VOID
SetCrcAltSize (
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    )
/*++

Routine Description:

    Updates the CRC32 value in the table header

Arguments:

    Hdr     - The table to update

Returns:

    None

--*/
{
    Hdr->CRC32 = 0;
    Hdr->CRC32 = CalculateCrc((UINT8 *)Hdr, Size);
}


BOOLEAN
CheckCrc (
    IN UINTN                 MaxSize,
    IN OUT EFI_TABLE_HEADER *Hdr
    )
/*++

Routine Description:

    Checks the CRC32 value in the table header

Arguments:

    Hdr     - The table to check

Returns:

    TRUE if the CRC is OK in the table

--*/
{
    return CheckCrcAltSize (MaxSize, Hdr->HeaderSize, Hdr);
}




BOOLEAN
CheckCrcAltSize (
    IN UINTN                 MaxSize,
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    )
/*++

Routine Description:

    Checks the CRC32 value in the table header

Arguments:

    Hdr     - The table to check

Returns:

    TRUE if the CRC is OK in the table

--*/
{
    UINT32      Crc;
    UINT32      OrgCrc;
    BOOLEAN     f;

    if (Size == 0) {
        /* 
         *  If header size is 0 CRC will pass so return FALSE here
         */
        return FALSE;
    }
    if (MaxSize && Size > MaxSize) {
        DEBUG((D_ERROR, "CheckCrc32: Size > MaxSize\n"));
        return FALSE;
    }

    /*  clear old crc from header */
    OrgCrc = Hdr->CRC32;
    Hdr->CRC32 = 0;
    Crc = CalculateCrc((UINT8 *)Hdr, Size);

    /*  set restults */
    Hdr->CRC32 = OrgCrc;

    /*  return status */
    f = OrgCrc == (UINT32) Crc;
    if (!f) {
        DEBUG((D_ERROR, "CheckCrc32: Crc check failed\n"));
    }

    return f;
}


UINT32
CalculateCrc (
    UINT8 *pt,
    UINTN Size
    )
{
    UINTN Crc;

    /*  compute crc */
    Crc = 0xffffffff;
    while (Size) {
        Crc = (Crc >> 8) ^ CRCTable[(UINT8) Crc ^ *pt];
        pt += 1;
        Size -= 1;
    }
    Crc = Crc ^ 0xffffffff;
    return (UINT32)Crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\data.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    data.c

Abstract:

    EFI library global data



Revision History

--*/

#include "lib.h"

/* 
 *  LibInitialized - TRUE once InitializeLib() is called for the first time
 */

BOOLEAN  LibInitialized = FALSE;

/* 
 *  ST - pointer to the EFI system table
 */

EFI_SYSTEM_TABLE        *ST;

/* 
 *  BS - pointer to the boot services table
 */

EFI_BOOT_SERVICES       *BS;


/* 
 *  Default pool allocation type
 */

EFI_MEMORY_TYPE PoolAllocationType = EfiBootServicesData;

/* 
 *  Unicode collation functions that are in use
 */

EFI_UNICODE_COLLATION_INTERFACE   LibStubUnicodeInterface = {
    LibStubStriCmp,
    LibStubMetaiMatch,
    LibStubStrLwrUpr,
    LibStubStrLwrUpr,
    NULL,   /*  FatToStr */
    NULL,   /*  StrToFat */
    NULL    /*  SupportedLanguages */
}; 

EFI_UNICODE_COLLATION_INTERFACE   *UnicodeInterface = &LibStubUnicodeInterface;

/* 
 *  Root device path
 */

EFI_DEVICE_PATH RootDevicePath[] = {
    END_DEVICE_PATH_TYPE, END_ENTIRE_DEVICE_PATH_SUBTYPE, END_DEVICE_PATH_LENGTH, 0
};

EFI_DEVICE_PATH EndDevicePath[] = {
    END_DEVICE_PATH_TYPE, END_ENTIRE_DEVICE_PATH_SUBTYPE, END_DEVICE_PATH_LENGTH, 0
};

EFI_DEVICE_PATH EndInstanceDevicePath[] = {
    END_DEVICE_PATH_TYPE, END_INSTANCE_DEVICE_PATH_SUBTYPE, END_DEVICE_PATH_LENGTH, 0
};


/* 
 *  EFI IDs
 */

EFI_GUID EfiGlobalVariable  = EFI_GLOBAL_VARIABLE;
EFI_GUID NullGuid = { 0,0,0,0,0,0,0,0,0,0,0 };

/* 
 *  Protocol IDs
 */

EFI_GUID DevicePathProtocol       = DEVICE_PATH_PROTOCOL;
EFI_GUID LoadedImageProtocol      = LOADED_IMAGE_PROTOCOL;
EFI_GUID TextInProtocol           = SIMPLE_TEXT_INPUT_PROTOCOL;
EFI_GUID TextOutProtocol          = SIMPLE_TEXT_OUTPUT_PROTOCOL;
EFI_GUID BlockIoProtocol          = BLOCK_IO_PROTOCOL;
EFI_GUID DiskIoProtocol           = DISK_IO_PROTOCOL;
EFI_GUID FileSystemProtocol       = SIMPLE_FILE_SYSTEM_PROTOCOL;
EFI_GUID LoadFileProtocol         = LOAD_FILE_PROTOCOL;
EFI_GUID DeviceIoProtocol         = DEVICE_IO_PROTOCOL;
EFI_GUID UnicodeCollationProtocol = UNICODE_COLLATION_PROTOCOL;
EFI_GUID SerialIoProtocol         = SERIAL_IO_PROTOCOL;
EFI_GUID SimpleNetworkProtocol    = EFI_SIMPLE_NETWORK_PROTOCOL;
EFI_GUID PxeBaseCodeProtocol      = EFI_PXE_BASE_CODE_PROTOCOL;
EFI_GUID PxeCallbackProtocol      = EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL;
EFI_GUID NetworkInterfaceIdentifierProtocol = EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL;

/* 
 *  File system information IDs
 */

EFI_GUID GenericFileInfo           = EFI_FILE_INFO_ID;
EFI_GUID FileSystemInfo            = EFI_FILE_SYSTEM_INFO_ID;
EFI_GUID FileSystemVolumeLabelInfo = EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID;

/* 
 *  Reference implementation public protocol IDs
 */

EFI_GUID VariableStoreProtocol = VARIABLE_STORE_PROTOCOL;
EFI_GUID LegacyBootProtocol = LEGACY_BOOT_PROTOCOL;
EFI_GUID VgaClassProtocol = VGA_CLASS_DRIVER_PROTOCOL;
EFI_GUID InternalLoadProtocol = INTERNAL_LOAD_PROTOCOL;

EFI_GUID TextOutSpliterProtocol = TEXT_OUT_SPLITER_PROTOCOL;
EFI_GUID ErrorOutSpliterProtocol = ERROR_OUT_SPLITER_PROTOCOL;
EFI_GUID TextInSpliterProtocol = TEXT_IN_SPLITER_PROTOCOL;


/* 
 *  Device path media protocol IDs
 */
EFI_GUID PcAnsiProtocol = DEVICE_PATH_MESSAGING_PC_ANSI;
EFI_GUID Vt100Protocol  = DEVICE_PATH_MESSAGING_VT_100;

/* 
 *  Reference implementation Vendor Device Path Guids
 */
EFI_GUID UnknownDevice      = UNKNOWN_DEVICE_GUID;

/* 
 *  Configuration Table GUIDs
 */

EFI_GUID MpsTableGuid             = MPS_TABLE_GUID;
EFI_GUID AcpiTableGuid            = ACPI_TABLE_GUID;
EFI_GUID SMBIOSTableGuid          = SMBIOS_TABLE_GUID;
EFI_GUID SalSystemTableGuid       = SAL_SYSTEM_TABLE_GUID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\debug.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    debug.c

Abstract:

    Debug library functions



Revision History

--*/

#include "lib.h"



/*
 *  Declare runtime functions
 */

/*
 *
 */
//
// Disable the warning about no exit for the implementation of BREAKPOINT that is
// a while(TRUE) (some of them)
//
#pragma warning( disable : 4715 )

INTN
DbgAssert (
    IN CHAR8    *FileName,
    IN INTN     LineNo,
    IN CHAR8    *Description
    )
{
    DbgPrint (D_ERROR, "%EASSERT FAILED: %a(%d): %a%N\n", FileName, LineNo, Description);
    BREAKPOINT();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\guid.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    misc.c

Abstract:

    Misc EFI support functions



Revision History

--*/

#include "lib.h"


/* 
 *  Additional Known guids
 */

#define SHELL_INTERFACE_PROTOCOL \
    { 0x47c7b223, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define ENVIRONMENT_VARIABLE_ID  \
    { 0x47c7b224, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define DEVICE_PATH_MAPPING_ID  \
    { 0x47c7b225, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define PROTOCOL_ID_ID  \
    { 0x47c7b226, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define ALIAS_ID  \
    { 0x47c7b227, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

static EFI_GUID ShellInterfaceProtocol = SHELL_INTERFACE_PROTOCOL;
static EFI_GUID SEnvId                 = ENVIRONMENT_VARIABLE_ID;
static EFI_GUID SMapId                 = DEVICE_PATH_MAPPING_ID;
static EFI_GUID SProtId                = PROTOCOL_ID_ID;
static EFI_GUID SAliasId               = ALIAS_ID;

struct {
    EFI_GUID        *Guid;
    CHAR16          *GuidName;
} KnownGuids[] = {
    &NullGuid,                  L"G0",
    &EfiGlobalVariable,         L"Efi",

    &VariableStoreProtocol,     L"varstore",
    &DevicePathProtocol,        L"dpath",
    &LoadedImageProtocol,       L"image",
    &TextInProtocol,            L"txtin",
    &TextOutProtocol,           L"txtout",
    &BlockIoProtocol,           L"blkio",
    &DiskIoProtocol,            L"diskio",
    &FileSystemProtocol,        L"fs",
    &LoadFileProtocol,          L"load",
    &DeviceIoProtocol,          L"DevIo",

    &GenericFileInfo,           L"GenFileInfo",
    &FileSystemInfo,            L"FileSysInfo",

    &UnicodeCollationProtocol,  L"unicode",
    &LegacyBootProtocol,        L"LegacyBoot",
    &SerialIoProtocol,          L"serialio",
    &VgaClassProtocol,          L"vgaclass",
    &SimpleNetworkProtocol,     L"net",
    &NetworkInterfaceIdentifierProtocol,    L"nii",
    &PxeBaseCodeProtocol,       L"pxebc",
    &PxeCallbackProtocol,       L"pxecb",

    &VariableStoreProtocol,     L"varstore",
    &LegacyBootProtocol,        L"LegacyBoot",
    &VgaClassProtocol,          L"VgaClass",
    &TextOutSpliterProtocol,    L"TxtOutSplit",
    &ErrorOutSpliterProtocol,   L"ErrOutSplit",
    &TextInSpliterProtocol,     L"TxtInSplit",
    &PcAnsiProtocol,            L"PcAnsi",
    &Vt100Protocol,             L"Vt100",
    &InternalLoadProtocol,      L"InternalLoad",
    &UnknownDevice,             L"Unknown Device",

    &ShellInterfaceProtocol,    L"ShellInt",
    &SEnvId,                    L"SEnv",
    &SProtId,                   L"ShellProtId",
    &SMapId,                    L"ShellDevPathMap",
    &SAliasId,                  L"ShellAlias",

    NULL
};

/* 
 * 
 */

LIST_ENTRY          GuidList;


VOID
InitializeGuid (
    VOID
    )
{
}

INTN
CompareGuid(
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    )
/*++

Routine Description:

    Compares to GUIDs

Arguments:

    Guid1       - guid to compare
    Guid2       - guid to compare

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    return RtCompareGuid (Guid1, Guid2);
}


VOID
GuidToString (
    OUT CHAR16      *Buffer,
    IN EFI_GUID     *Guid
    )
{

    UINTN           Index;

    /* 
     *  Else, (for now) use additional internal function for mapping guids
     */

    for (Index=0; KnownGuids[Index].Guid; Index++) {
        if (CompareGuid(Guid, KnownGuids[Index].Guid) == 0) {
            SPrint (Buffer, 0, KnownGuids[Index].GuidName);
            return ;
        }
    }

    /* 
     *  Else dump it
     */

    SPrint (Buffer, 0, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        Guid->Data1,                    
        Guid->Data2,
        Guid->Data3,
        Guid->Data4[0],
        Guid->Data4[1],
        Guid->Data4[2],
        Guid->Data4[3],
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\event.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    event.c

Abstract:




Revision History

--*/

#include "lib.h"


EFI_EVENT
LibCreateProtocolNotifyEvent (
    IN EFI_GUID             *ProtocolGuid,
    IN EFI_TPL              NotifyTpl,
    IN EFI_EVENT_NOTIFY     NotifyFunction,
    IN VOID                 *NotifyContext,
    OUT VOID                *Registration
    )
{
    EFI_STATUS              Status;
    EFI_EVENT               Event;

    /* 
     *  Create the event
     */

    Status = BS->CreateEvent (
                    EVT_NOTIFY_SIGNAL,
                    NotifyTpl,
                    NotifyFunction,
                    NotifyContext,
                    &Event
                    );
    ASSERT (!EFI_ERROR(Status));

    /* 
     *  Register for protocol notifactions on this event
     */

    Status = BS->RegisterProtocolNotify (
                    ProtocolGuid, 
                    Event, 
                    Registration
                    );

    ASSERT (!EFI_ERROR(Status));

    /* 
     *  Kick the event so we will perform an initial pass of
     *  current installed drivers
     */

    BS->SignalEvent (Event);
    return Event;
}


EFI_STATUS
WaitForSingleEvent (
    IN EFI_EVENT        Event,
    IN UINT64           Timeout OPTIONAL
    )
{
    EFI_STATUS          Status;
    UINTN               Index;
    EFI_EVENT           TimerEvent;
    EFI_EVENT           WaitList[2];

    if (Timeout) {
        /* 
         *  Create a timer event
         */

        Status = BS->CreateEvent (EVT_TIMER, 0, NULL, NULL, &TimerEvent);
        if (!EFI_ERROR(Status)) {

            /* 
             *  Set the timer event
             */

            BS->SetTimer (TimerEvent, TimerRelative, Timeout);
            
            /* 
             *  Wait for the original event or the timer
             */

            WaitList[0] = Event;
            WaitList[1] = TimerEvent;
            Status = BS->WaitForEvent (2, WaitList, &Index);
            BS->CloseEvent (TimerEvent);

            /* 
             *  If the timer expired, change the return to timed out
             */

            if (!EFI_ERROR(Status)  &&  Index == 1) {
                Status = EFI_TIMEOUT;
            }
        }

    } else {

        /* 
         *  No timeout... just wait on the event
         */

        Status = BS->WaitForEvent (1, &Event, &Index);
        ASSERT (!EFI_ERROR(Status));
        ASSERT (Index == 0);
    }

    return Status;
}

VOID
WaitForEventWithTimeout (
    IN  EFI_EVENT       Event,
    IN  UINTN           Timeout,
    IN  UINTN           Row,
    IN  UINTN           Column,
    IN  CHAR16          *String,
    IN  EFI_INPUT_KEY   TimeoutKey,
    OUT EFI_INPUT_KEY   *Key
    )
{
    EFI_STATUS      Status;

    do {
        PrintAt (Column, Row, String, Timeout);
        Status = WaitForSingleEvent (Event, 10000000);
        if (Status == EFI_SUCCESS) {
            if (!EFI_ERROR(ST->ConIn->ReadKeyStroke (ST->ConIn, Key))) {
                return;
            }
        }
    } while (Timeout > 0);
    *Key = TimeoutKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\error.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    error.c

Abstract:




Revision History

--*/

#include "lib.h"


struct {
    EFI_STATUS      Code;
    CHAR16          *Desc;
} ErrorCodeTable[] = {
    EFI_SUCCESS,                L"Success",
    EFI_LOAD_ERROR,             L"Load Error",
    EFI_INVALID_PARAMETER,      L"Invalid Parameter",
    EFI_UNSUPPORTED,            L"Unsupported",
    EFI_BAD_BUFFER_SIZE,        L"Bad Buffer Size",
    EFI_BUFFER_TOO_SMALL,       L"Buffer Too Small",
    EFI_NOT_READY,              L"Not Ready",
    EFI_DEVICE_ERROR,           L"Device Error",
    EFI_WRITE_PROTECTED,        L"Write Protected",
    EFI_OUT_OF_RESOURCES,       L"Out of Resources",
    EFI_VOLUME_CORRUPTED,       L"Volume Corrupt",
    EFI_VOLUME_FULL,            L"Volume Full",
    EFI_NO_MEDIA,               L"No Media",
    EFI_MEDIA_CHANGED,          L"Media changed",
    EFI_NOT_FOUND,              L"Not Found",
    EFI_ACCESS_DENIED,          L"Access Denied",
    EFI_NO_RESPONSE,            L"No Response",
    EFI_NO_MAPPING,             L"No mapping",
    EFI_TIMEOUT,                L"Time out",
    EFI_NOT_STARTED,            L"Not started",
    EFI_ALREADY_STARTED,        L"Already started",
    EFI_ABORTED,                L"Aborted",
    EFI_ICMP_ERROR,             L"ICMP Error",
    EFI_TFTP_ERROR,             L"TFTP Error",
    EFI_PROTOCOL_ERROR,         L"Protocol Error",

    /*  warnings */
    EFI_WARN_UNKOWN_GLYPH,      L"Warning Unknown Glyph",
    EFI_WARN_DELETE_FAILURE,    L"Warning Delete Failure",
    EFI_WARN_WRITE_FAILURE,     L"Warning Write Failure",
    EFI_WARN_BUFFER_TOO_SMALL,  L"Warning Buffer Too Small",
    0, NULL
} ;


VOID
StatusToString (
    OUT CHAR16          *Buffer,
    IN EFI_STATUS       Status
    )
{
    UINTN           Index;

    for (Index = 0; ErrorCodeTable[Index].Desc; Index +=1) {
        if (ErrorCodeTable[Index].Code == Status) {
            StrCpy (Buffer, ErrorCodeTable[Index].Desc);
            return;
        }
    }

    SPrint (Buffer, 0, L"%X", Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\hand.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    hand.c

Abstract:




Revision History

--*/

#include "lib.h"
#include "efistdarg.h"                        /*  !!! */


EFI_STATUS
LibLocateProtocol (
    IN  EFI_GUID    *ProtocolGuid,
    OUT VOID        **Interface
    )
/* 
 *  Find the first instance of this Protocol in the system and return it's interface
 */
{
    EFI_STATUS      Status;
    UINTN           NumberHandles, Index;
    EFI_HANDLE      *Handles;

    
    *Interface = NULL;
    Status = LibLocateHandle (ByProtocol, ProtocolGuid, NULL, &NumberHandles, &Handles);
    if (EFI_ERROR(Status)) {
        DEBUG((D_INFO, "LibLocateProtocol: Handle not found\n"));
        return Status;
    }

    for (Index=0; Index < NumberHandles; Index++) {
        Status = BS->HandleProtocol (Handles[Index], ProtocolGuid, Interface);
        if (!EFI_ERROR(Status)) {
            break;
        }
    }

    if (Handles) {
        FreePool (Handles);
    }

    return Status;
}

EFI_STATUS
LibLocateHandle (
    IN EFI_LOCATE_SEARCH_TYPE       SearchType,
    IN EFI_GUID                     *Protocol OPTIONAL,
    IN VOID                         *SearchKey OPTIONAL,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    )

{
    EFI_STATUS          Status;
    UINTN               BufferSize;

    /* 
     *  Initialize for GrowBuffer loop
     */

    *Buffer = NULL;
    BufferSize = 50 * sizeof(EFI_HANDLE);

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {

        Status = BS->LocateHandle (
                        SearchType,
                        Protocol,
                        SearchKey,
                        &BufferSize,
                        *Buffer
                        );

    }

    *NoHandles = BufferSize / sizeof (EFI_HANDLE);
    if (EFI_ERROR(Status)) {
        *NoHandles = 0;
    }

    return Status;
}

EFI_STATUS
LibLocateHandleByDiskSignature (
    IN UINT8                        MBRType,
    IN UINT8                        SignatureType,
    IN VOID                         *Signature,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    )

{
    EFI_STATUS            Status;
    UINTN                 BufferSize;
    UINTN                 NoBlockIoHandles;
    EFI_HANDLE            *BlockIoBuffer;
    EFI_DEVICE_PATH       *DevicePath;
    UINTN                 Index;
    EFI_DEVICE_PATH       *Start, *Next, *DevPath;
    HARDDRIVE_DEVICE_PATH *HardDriveDevicePath;
    BOOLEAN               Match;
    BOOLEAN               PreviousNodeIsHardDriveDevicePath;

    /* 
     *  Initialize for GrowBuffer loop
     */

    BlockIoBuffer = NULL;
    BufferSize = 50 * sizeof(EFI_HANDLE);

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {

        /* 
         *  Get list of device handles that support the BLOCK_IO Protocol.
         */

        Status = BS->LocateHandle (
                        ByProtocol,
                        &BlockIoProtocol,
                        NULL,
                        &BufferSize,
                        BlockIoBuffer
                        );

    }

    NoBlockIoHandles = BufferSize / sizeof (EFI_HANDLE);
    if (EFI_ERROR(Status)) {
        NoBlockIoHandles = 0;
    }

    /* 
     *  If there was an error or there are no device handles that support 
     *  the BLOCK_IO Protocol, then return.
     */

    if (NoBlockIoHandles == 0) {
        FreePool(BlockIoBuffer);
        *NoHandles = 0;
        *Buffer = NULL;
        return Status;
    }

    /* 
     *  Loop through all the device handles that support the BLOCK_IO Protocol
     */

    *NoHandles = 0;

    for(Index=0;Index<NoBlockIoHandles;Index++) {

        Status = BS->HandleProtocol (BlockIoBuffer[Index], 
                                     &DevicePathProtocol, 
                                     (VOID*)&DevicePath
                                     );

        /* 
         *  Search DevicePath for a Hard Drive Media Device Path node.
         *  If one is found, then see if it matches the signature that was
         *  passed in.  If it does match, and the next node is the End of the
         *  device path, and the previous node is not a Hard Drive Media Device
         *  Path, then we have found a match.
         */

        Match = FALSE;

        if (DevicePath != NULL) {

            PreviousNodeIsHardDriveDevicePath = FALSE;

            DevPath = DevicePath;
            Start = DevPath;

            /* 
             *  Check for end of device path type
             *      */

            for (; ;) {

                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
                    (DevicePathSubType(DevPath) == MEDIA_HARDDRIVE_DP)) {

                    HardDriveDevicePath = (HARDDRIVE_DEVICE_PATH *)(DevPath);

                    if (PreviousNodeIsHardDriveDevicePath == FALSE) {

                        Next = NextDevicePathNode(DevPath);
                        if (IsDevicePathEndType(Next)) {
                            if ((HardDriveDevicePath->MBRType == MBRType) &&
                                (HardDriveDevicePath->SignatureType == SignatureType)) {
                                    switch(SignatureType) {
                                        case SIGNATURE_TYPE_MBR:
                                            if (*((UINT32 *)(Signature)) == *(UINT32 *)(&(HardDriveDevicePath->Signature[0]))) {
                                                Match = TRUE;
                                            }
                                            break;
                                        case SIGNATURE_TYPE_GUID:
                                            if (CompareGuid((EFI_GUID *)Signature,(EFI_GUID *)(&(HardDriveDevicePath->Signature[0]))) == 0) {
                                                Match = TRUE;
                                            }
                                            break;
                                    }
                            }
                        }
                    }
                    PreviousNodeIsHardDriveDevicePath = TRUE;
                } else {
                    PreviousNodeIsHardDriveDevicePath = FALSE;
                }

                if (IsDevicePathEnd(DevPath)) {
                    break;
                }

                DevPath = NextDevicePathNode(DevPath);
            }

        }

        if (Match == FALSE) {
            BlockIoBuffer[Index] = NULL;
        } else {
            *NoHandles = *NoHandles + 1;
        }
    }

    /* 
     *  If there are no matches, then return
     */

    if (*NoHandles == 0) {
        FreePool(BlockIoBuffer);
        *NoHandles = 0;
        *Buffer = NULL;
        return EFI_SUCCESS;
    }

    /* 
     *  Allocate space for the return buffer of device handles.
     */

    *Buffer = AllocatePool(*NoHandles * sizeof(EFI_HANDLE));

    if (*Buffer == NULL) {
        FreePool(BlockIoBuffer);
        *NoHandles = 0;
        *Buffer = NULL;
        return EFI_OUT_OF_RESOURCES;
    }

    /* 
     *  Build list of matching device handles.
     */

    *NoHandles = 0;
    for(Index=0;Index<NoBlockIoHandles;Index++) {
        if (BlockIoBuffer[Index] != NULL) {
            (*Buffer)[*NoHandles] = BlockIoBuffer[Index];
            *NoHandles = *NoHandles + 1;
        }
    }

    FreePool(BlockIoBuffer);

    return EFI_SUCCESS;
}

EFI_FILE_HANDLE
LibOpenRoot (
    IN EFI_HANDLE               DeviceHandle
    )
{
    EFI_STATUS                  Status;
    EFI_FILE_IO_INTERFACE       *Volume;
    EFI_FILE_HANDLE             File;


    /* 
     *  File the file system interface to the device
     */

    Status = BS->HandleProtocol (DeviceHandle, &FileSystemProtocol, (VOID*)&Volume);

    /* 
     *  Open the root directory of the volume 
     */

    if (!EFI_ERROR(Status)) {
        Status = Volume->OpenVolume(Volume, &File);
    }

    /* 
     *  Done
     */

    return EFI_ERROR(Status) ? NULL : File;
}

EFI_FILE_INFO *
LibFileInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    EFI_STATUS              Status;
    EFI_FILE_INFO           *Buffer;
    UINTN                   BufferSize;

    /* 
     *  Initialize for GrowBuffer loop
     */

    Buffer = NULL;
    BufferSize = SIZE_OF_EFI_FILE_INFO + 200;

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
        Status = FHand->GetInfo (
                    FHand,
                    &GenericFileInfo,
                    &BufferSize,
                    Buffer
                    );
    }

    return Buffer;
}

    
EFI_FILE_SYSTEM_INFO *
LibFileSystemInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    EFI_STATUS              Status;
    EFI_FILE_SYSTEM_INFO    *Buffer;
    UINTN                   BufferSize;

    /* 
     *  Initialize for GrowBuffer loop
     */

    Buffer = NULL;
    BufferSize = SIZE_OF_EFI_FILE_SYSTEM_INFO + 200;

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
        Status = FHand->GetInfo (
                    FHand,
                    &FileSystemInfo,
                    &BufferSize,
                    Buffer
                    );
    }

    return Buffer;
}

EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
LibFileSystemVolumeLabelInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    EFI_STATUS                        Status;
    EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *Buffer;
    UINTN                             BufferSize;

    /* 
     *  Initialize for GrowBuffer loop
     */

    Buffer = NULL;
    BufferSize = SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO + 200;

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
        Status = FHand->GetInfo (
                    FHand,
                    &FileSystemVolumeLabelInfo,
                    &BufferSize,
                    Buffer
                    );
    }

    return Buffer;
}

    

EFI_STATUS
LibInstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    )
{
    va_list         args;
    EFI_STATUS      Status;
    EFI_GUID        *Protocol;
    VOID            *Interface;
    EFI_TPL         OldTpl;
    UINTN           Index;
    EFI_HANDLE      OldHandle;

    /* 
     *  Syncronize with notifcations
     *   */

    OldTpl = BS->RaiseTPL(TPL_NOTIFY);
    OldHandle = *Handle;

    /* 
     *  Install the protocol interfaces
     */

    Index = 0;
    Status = EFI_SUCCESS;
    va_start (args, Handle);

    while (!EFI_ERROR(Status)) {

        /* 
         *  If protocol is NULL, then it's the end of the list
         */

        Protocol = va_arg(args, EFI_GUID *);
        if (!Protocol) {
            break;
        }

        Interface = va_arg(args, VOID *);

        /* 
         *  Install it
         */

        DEBUG((D_INFO, "LibInstallProtocolInterface: %d %x\n", Protocol, Interface));
        Status = BS->InstallProtocolInterface (Handle, Protocol, EFI_NATIVE_INTERFACE, Interface);
        if (EFI_ERROR(Status)) {
            break;
        }

        Index += 1;
    }

    /* 
     *  If there was an error, remove all the interfaces that were
     *  installed without any errors
     */

    if (EFI_ERROR(Status)) {
        va_start (args, Handle);
        while (Index) {

            Protocol = va_arg(args, EFI_GUID *);
            Interface = va_arg(args, VOID *);
            BS->UninstallProtocolInterface (*Handle, Protocol, Interface);

            Index -= 1;
        }        

        *Handle = OldHandle;
    }

    /* 
     *  Done
     */

    BS->RestoreTPL(OldTpl);
    return Status;
}


VOID
LibUninstallProtocolInterfaces (
    IN EFI_HANDLE           Handle,
    ...
    )
{
    va_list         args;
    EFI_STATUS      Status;
    EFI_GUID        *Protocol;
    VOID            *Interface;

    
    va_start (args, Handle);
    for (; ;) {

        /* 
         *  If protocol is NULL, then it's the end of the list
         */

        Protocol = va_arg(args, EFI_GUID *);
        if (!Protocol) {
            break;
        }

        Interface = va_arg(args, VOID *);

        /* 
         *  Uninstall it
         */

        Status = BS->UninstallProtocolInterface (Handle, Protocol, Interface);
        if (EFI_ERROR(Status)) {
            DEBUG((D_ERROR, "LibUninstallProtocolInterfaces: failed %g, %r\n", Protocol, Handle));
        }
    }
}    


EFI_STATUS
LibReinstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    )
{
    va_list         args;
    EFI_STATUS      Status;
    EFI_GUID        *Protocol;
    VOID            *OldInterface, *NewInterface;
    EFI_TPL         OldTpl;
    UINTN           Index;

    /* 
     *  Syncronize with notifcations
     *   */

    OldTpl = BS->RaiseTPL(TPL_NOTIFY);

    /* 
     *  Install the protocol interfaces
     */

    Index = 0;
    Status = EFI_SUCCESS;
    va_start (args, Handle);

    while (!EFI_ERROR(Status)) {

        /* 
         *  If protocol is NULL, then it's the end of the list
         */

        Protocol = va_arg(args, EFI_GUID *);
        if (!Protocol) {
            break;
        }

        OldInterface = va_arg(args, VOID *);
        NewInterface = va_arg(args, VOID *);

        /* 
         *  Reinstall it
         */

        Status = BS->ReinstallProtocolInterface (Handle, Protocol, OldInterface, NewInterface);
        if (EFI_ERROR(Status)) {
            break;
        }

        Index += 1;
    }

    /* 
     *  If there was an error, undo all the interfaces that were
     *  reinstalled without any errors
     */

    if (EFI_ERROR(Status)) {
        va_start (args, Handle);
        while (Index) {

            Protocol = va_arg(args, EFI_GUID *);
            OldInterface = va_arg(args, VOID *);
            NewInterface = va_arg(args, VOID *);

            BS->ReinstallProtocolInterface (Handle, Protocol, NewInterface, OldInterface);

            Index -= 1;
        }        
    }

    /* 
     *  Done
     */

    BS->RestoreTPL(OldTpl);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\dpath.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    dpath.c

Abstract:
    MBR & Device Path functions



Revision History

--*/

#include "lib.h"

#define ALIGN_SIZE(a)   ((a % MIN_ALIGNMENT_SIZE) ? MIN_ALIGNMENT_SIZE - (a % MIN_ALIGNMENT_SIZE) : 0)



EFI_DEVICE_PATH *
DevicePathFromHandle (
    IN EFI_HANDLE       Handle
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;

    Status = BS->HandleProtocol (Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    if (EFI_ERROR(Status)) {
        DevicePath = NULL;
    }

    return DevicePath;
}


EFI_DEVICE_PATH *
DevicePathInstance (
    IN OUT EFI_DEVICE_PATH  **DevicePath,
    OUT UINTN               *Size
    )
{
    EFI_DEVICE_PATH         *Start, *Next, *DevPath;
    UINTN                   Count;

    DevPath = *DevicePath;
    Start = DevPath;

    if (!DevPath) {
        return NULL;
    }

    /* 
     *  Check for end of device path type
     *      */

    for (Count = 0; ; Count++) {
        Next = NextDevicePathNode(DevPath);

        if (IsDevicePathEndType(DevPath)) {
            break;
        }

        if (Count > 01000) {
            /* 
             *  BugBug: Debug code to catch bogus device paths
             */
            DEBUG((D_ERROR, "DevicePathInstance: DevicePath %x Size %d", *DevicePath, ((UINT8 *) DevPath) - ((UINT8 *) Start) ));
            DumpHex (0, 0, ((UINT8 *) DevPath) - ((UINT8 *) Start), Start);
            break;
        }

        DevPath = Next;
    }

    ASSERT (DevicePathSubType(DevPath) == END_ENTIRE_DEVICE_PATH_SUBTYPE ||
            DevicePathSubType(DevPath) == END_INSTANCE_DEVICE_PATH_SUBTYPE);

    /* 
     *  Set next position
     */

    if (DevicePathSubType(DevPath) == END_ENTIRE_DEVICE_PATH_SUBTYPE) {
        Next = NULL;
    }

    *DevicePath = Next;

    /* 
     *  Return size and start of device path instance
     */

    *Size = ((UINT8 *) DevPath) - ((UINT8 *) Start);
    return Start;
}

UINTN
DevicePathInstanceCount (
    IN EFI_DEVICE_PATH      *DevicePath
    )
{
    UINTN       Count, Size;

    Count = 0;
    while (DevicePathInstance(&DevicePath, &Size)) {
        Count += 1;
    }

    return Count;
}


EFI_DEVICE_PATH *
AppendDevicePath (
    IN EFI_DEVICE_PATH  *Src1,
    IN EFI_DEVICE_PATH  *Src2
    )
/*  Src1 may have multiple "instances" and each instance is appended
 *  Src2 is appended to each instance is Src1.  (E.g., it's possible
 *  to append a new instance to the complete device path by passing 
 *  it in Src2) */
{
    UINTN               Src1Size, Src1Inst, Src2Size, Size;
    EFI_DEVICE_PATH     *Dst, *Inst;
    UINT8               *DstPos;

    /* 
     *  If there's only 1 path, just duplicate it
     */

    if (!Src1) {
        ASSERT (!IsDevicePathUnpacked (Src2));
        return DuplicateDevicePath (Src2);
    }

    if (!Src2) {
        ASSERT (!IsDevicePathUnpacked (Src1));
        return DuplicateDevicePath (Src1);
    }

    /* 
     *  Verify we're not working with unpacked paths
     */

/*     ASSERT (!IsDevicePathUnpacked (Src1));
 *     ASSERT (!IsDevicePathUnpacked (Src2)); */

    /* 
     *  Append Src2 to every instance in Src1
     */

    Src1Size = DevicePathSize(Src1);
    Src1Inst = DevicePathInstanceCount(Src1);
    Src2Size = DevicePathSize(Src2);
    Size = Src1Size * Src1Inst + Src2Size;
    
    Dst = AllocatePool (Size);
    if (Dst) {
        DstPos = (UINT8 *) Dst;

        /* 
         *  Copy all device path instances
         */

        while (Inst = DevicePathInstance (&Src1, &Size)) {

            CopyMem(DstPos, Inst, Size);
            DstPos += Size;

            CopyMem(DstPos, Src2, Src2Size);
            DstPos += Src2Size;

            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
            DstPos += sizeof(EFI_DEVICE_PATH);
        }

        /*  Change last end marker */
        DstPos -= sizeof(EFI_DEVICE_PATH);
        CopyMem(DstPos, EndDevicePath, sizeof(EFI_DEVICE_PATH));
    }

    return Dst;
}


EFI_DEVICE_PATH *
AppendDevicePathNode (
    IN EFI_DEVICE_PATH  *Src1,
    IN EFI_DEVICE_PATH  *Src2
    )
/*  Src1 may have multiple "instances" and each instance is appended
 *  Src2 is a signal device path node (without a terminator) that is
 *  appended to each instance is Src1. */
{
    EFI_DEVICE_PATH     *Temp, *Eop;
    UINTN               Length;

    /* 
     *  Build a Src2 that has a terminator on it
     */

    Length = DevicePathNodeLength(Src2);
    Temp = AllocatePool (Length + sizeof(EFI_DEVICE_PATH));
    if (!Temp) {
        return NULL;
    }

    CopyMem (Temp, Src2, Length);
    Eop = NextDevicePathNode(Temp); 
    SetDevicePathEndNode(Eop);

    /* 
     *  Append device paths
     */

    Src1 = AppendDevicePath (Src1, Temp);
    FreePool (Temp);
    return Src1;
}


EFI_DEVICE_PATH *
FileDevicePath (
    IN EFI_HANDLE       Device  OPTIONAL,
    IN CHAR16           *FileName
    )
/*++

    N.B. Results are allocated from pool.  The caller must FreePool
    the resulting device path structure

--*/
{
    UINTN                   Size;
    FILEPATH_DEVICE_PATH    *FilePath;
    EFI_DEVICE_PATH         *Eop, *DevicePath;    

    Size = StrSize(FileName);
    FilePath = AllocateZeroPool (Size + SIZE_OF_FILEPATH_DEVICE_PATH + sizeof(EFI_DEVICE_PATH));
    DevicePath = NULL;

    if (FilePath) {

        /* 
         *  Build a file path
         */

        FilePath->Header.Type = MEDIA_DEVICE_PATH;
        FilePath->Header.SubType = MEDIA_FILEPATH_DP;
        SetDevicePathNodeLength (&FilePath->Header, Size + SIZE_OF_FILEPATH_DEVICE_PATH);
        CopyMem (FilePath->PathName, FileName, Size);
        Eop = NextDevicePathNode(&FilePath->Header);
        SetDevicePathEndNode(Eop);

        /* 
         *  Append file path to device's device path
         */

        DevicePath = (EFI_DEVICE_PATH *) FilePath;
        if (Device) {
            DevicePath = AppendDevicePath (
                            DevicePathFromHandle(Device),
                            DevicePath
                            );

            FreePool(FilePath);
        }
    }

    return DevicePath;
}



UINTN
DevicePathSize (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    EFI_DEVICE_PATH     *Start;

    /* 
     *  Search for the end of the device path structure
     *      */

    Start = DevPath;
    while (!IsDevicePathEnd(DevPath)) {
        DevPath = NextDevicePathNode(DevPath);
    }

    /* 
     *  Compute the size
     */

    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
}

EFI_DEVICE_PATH *
DuplicateDevicePath (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    EFI_DEVICE_PATH     *NewDevPath;
    UINTN               Size;    


    /* 
     *  Compute the size
     */

    Size = DevicePathSize (DevPath);

    /* 
     *  Make a copy
     */

    NewDevPath = AllocatePool (Size);
    if (NewDevPath) {
        CopyMem (NewDevPath, DevPath, Size);
    }

    return NewDevPath;
}

EFI_DEVICE_PATH *
UnpackDevicePath (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    EFI_DEVICE_PATH     *Src, *Dest, *NewPath;
    UINTN               Size;
    
    /* 
     *  Walk device path and round sizes to valid boundries
     *      */

    Src = DevPath;
    Size = 0;
    for (; ;) {
        Size += DevicePathNodeLength(Src);
        Size += ALIGN_SIZE(Size);

        if (IsDevicePathEnd(Src)) {
            break;
        }

        Src = NextDevicePathNode(Src);
    }


    /* 
     *  Allocate space for the unpacked path
     */

    NewPath = AllocateZeroPool (Size);
    if (NewPath) {

        ASSERT (((UINTN)NewPath) % MIN_ALIGNMENT_SIZE == 0);

        /* 
         *  Copy each node
         */

        Src = DevPath;
        Dest = NewPath;
        for (; ;) {
            Size = DevicePathNodeLength(Src);
            CopyMem (Dest, Src, Size);
            Size += ALIGN_SIZE(Size);
            SetDevicePathNodeLength (Dest, Size);
            Dest->Type |= EFI_DP_TYPE_UNPACKED;
            Dest = (EFI_DEVICE_PATH *) (((UINT8 *) Dest) + Size);

            if (IsDevicePathEnd(Src)) {
                break;
            }

            Src = NextDevicePathNode(Src);
        }
    }

    return NewPath;
}


EFI_DEVICE_PATH*
AppendDevicePathInstance (
    IN EFI_DEVICE_PATH  *Src,
    IN EFI_DEVICE_PATH  *Instance
    )
{
    UINT8           *Ptr;
    EFI_DEVICE_PATH *DevPath;
    UINTN           SrcSize;
    UINTN           InstanceSize;

    if (Src == NULL) {
        return DuplicateDevicePath (Instance);
    }
    SrcSize = DevicePathSize(Src);
    InstanceSize = DevicePathSize(Instance);
    Ptr = AllocatePool (SrcSize + InstanceSize);
    DevPath = (EFI_DEVICE_PATH *)Ptr;
    ASSERT(DevPath);

    CopyMem (Ptr, Src, SrcSize);
/*     FreePool (Src); */
    
    while (!IsDevicePathEnd(DevPath)) {
        DevPath = NextDevicePathNode(DevPath);
    }
    /* 
     *  Convert the End to an End Instance, since we are
     *   appending another instacne after this one its a good
     *   idea.
     */
    DevPath->SubType = END_INSTANCE_DEVICE_PATH_SUBTYPE;
    
    DevPath = NextDevicePathNode(DevPath);
    CopyMem (DevPath, Instance, InstanceSize);
    return (EFI_DEVICE_PATH *)Ptr;
}

EFI_STATUS
LibDevicePathToInterface (
    IN EFI_GUID             *Protocol,
    IN EFI_DEVICE_PATH      *FilePath,
    OUT VOID                **Interface
    )
{
    EFI_STATUS              Status;
    EFI_HANDLE              Device;

    Status = BS->LocateDevicePath (Protocol, &FilePath, &Device);

    if (!EFI_ERROR(Status)) {

        /*  If we didn't get a direct match return not found */
        Status = EFI_NOT_FOUND;

        if (IsDevicePathEnd(FilePath)) {

            /* 
             *  It was a direct match, lookup the protocol interface
             */

            Status = BS->HandleProtocol (Device, Protocol, Interface);
        }
    }

    /* 
     *  If there was an error, do not return an interface
     */

    if (EFI_ERROR(Status)) {
        *Interface = NULL;
    }

    return Status;
}

VOID
_DevPathPci (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    PCI_DEVICE_PATH         *Pci;

    Pci = DevPath;
    CatPrint(Str, L"Pci(%x|%x)", Pci->Device, Pci->Function);
}

VOID
_DevPathPccard (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    PCCARD_DEVICE_PATH      *Pccard;

    Pccard = DevPath;   
    CatPrint(Str, L"Pccard(Socket%x)", Pccard->SocketNumber);
}

VOID
_DevPathMemMap (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    MEMMAP_DEVICE_PATH      *MemMap;

    MemMap = DevPath;   
    CatPrint(Str, L"MemMap(%d:%x-%x)",
        MemMap->MemoryType,
        MemMap->StartingAddress,
        MemMap->EndingAddress
        );
}

VOID
_DevPathController (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    CONTROLLER_DEVICE_PATH  *Controller;

    Controller = DevPath;
    CatPrint(Str, L"Ctrl(%d)",
        Controller->Controller
        );
}

VOID
_DevPathVendor (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    VENDOR_DEVICE_PATH                  *Vendor;
    CHAR16                              *Type;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH   *UnknownDevPath;

    Vendor = DevPath;
    switch (DevicePathType(&Vendor->Header)) {
    case HARDWARE_DEVICE_PATH:  Type = L"Hw";        break;
    case MESSAGING_DEVICE_PATH: Type = L"Msg";       break;
    case MEDIA_DEVICE_PATH:     Type = L"Media";     break;
    default:                    Type = L"?";         break;
    }                            

    CatPrint(Str, L"Ven%s(%g", Type, &Vendor->Guid);
    if (CompareGuid (&Vendor->Guid, &UnknownDevice) == 0) {
        /* 
         *  GUID used by EFI to enumerate an EDD 1.1 device
         */
        UnknownDevPath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *)Vendor;
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    } else {
        CatPrint(Str, L")");
    }
}


VOID
_DevPathAcpi (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    ACPI_HID_DEVICE_PATH        *Acpi;

    Acpi = DevPath;
    if ((Acpi->HID & PNP_EISA_ID_MASK) == PNP_EISA_ID_CONST) {
        CatPrint(Str, L"Acpi(PNP%04x,%x)", EISA_ID_TO_NUM (Acpi->HID), Acpi->UID);
    } else {
        CatPrint(Str, L"Acpi(%08x,%x)", Acpi->HID, Acpi->UID);
    }
}


VOID
_DevPathAtapi (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    ATAPI_DEVICE_PATH       *Atapi;

    Atapi = DevPath;
    CatPrint(Str, L"Ata(%s,%s)", 
        Atapi->PrimarySecondary ? L"Secondary" : L"Primary",
        Atapi->SlaveMaster ? L"Slave" : L"Master"
        );
}

VOID
_DevPathScsi (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    SCSI_DEVICE_PATH        *Scsi;

    Scsi = DevPath;
    CatPrint(Str, L"Scsi(Pun%x,Lun%x)", Scsi->Pun, Scsi->Lun);
}


VOID
_DevPathFibre (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    FIBRECHANNEL_DEVICE_PATH    *Fibre;

    Fibre = DevPath;
    CatPrint(Str, L"Fibre(%lx)", Fibre->WWN);
}

VOID
_DevPath1394 (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    F1394_DEVICE_PATH       *F1394;

    F1394 = DevPath;
    CatPrint(Str, L"1394(%g)", &F1394->Guid);
}



VOID
_DevPathUsb (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    USB_DEVICE_PATH         *Usb;

    Usb = DevPath;
    CatPrint(Str, L"Usb(%x)", Usb->Port);
}


VOID
_DevPathI2O (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    I2O_DEVICE_PATH         *I2O;

    I2O = DevPath;
    CatPrint(Str, L"I2O(%x)", I2O->Tid);
}

VOID
_DevPathMacAddr (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    MAC_ADDR_DEVICE_PATH    *MAC;
    UINTN                   HwAddressSize;
    UINTN                   Index;

    MAC = DevPath;

    HwAddressSize = sizeof(EFI_MAC_ADDRESS);
    if (MAC->IfType == 0x01 || MAC->IfType == 0x00) {
        HwAddressSize = 6;
    }
    
    CatPrint(Str, L"Mac(");

    for(Index = 0; Index < HwAddressSize; Index++) {
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    }
    CatPrint(Str, L")");
}

VOID
_DevPathIPv4 (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    IPv4_DEVICE_PATH     *IP;

    IP = DevPath;
    CatPrint(Str, L"IPv4(not-done)");
}

VOID
_DevPathIPv6 (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    IPv6_DEVICE_PATH     *IP;

    IP = DevPath;
    CatPrint(Str, L"IP-v6(not-done)");
}

VOID
_DevPathInfiniBand (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    INFINIBAND_DEVICE_PATH  *InfiniBand;

    InfiniBand = DevPath;
    CatPrint(Str, L"InfiniBand(not-done)");
}

VOID
_DevPathUart (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    UART_DEVICE_PATH  *Uart;
    CHAR8             Parity;

    Uart = DevPath;
    switch (Uart->Parity) {
        case 0  : Parity = 'D'; break;
        case 1  : Parity = 'N'; break;
        case 2  : Parity = 'E'; break;
        case 3  : Parity = 'O'; break;
        case 4  : Parity = 'M'; break;
        case 5  : Parity = 'S'; break;
        default : Parity = 'x'; break;
    }

    if (Uart->BaudRate == 0) {
        CatPrint(Str, L"Uart(DEFAULT %c",Uart->BaudRate,Parity);
    } else {
        CatPrint(Str, L"Uart(%d %c",Uart->BaudRate,Parity);
    }

    if (Uart->DataBits == 0) {
        CatPrint(Str, L"D");
    } else {
        CatPrint(Str, L"%d",Uart->DataBits);
    }

    switch (Uart->StopBits) {
        case 0  : CatPrint(Str, L"D)");   break;
        case 1  : CatPrint(Str, L"1)");   break;
        case 2  : CatPrint(Str, L"1.5)"); break;
        case 3  : CatPrint(Str, L"2)");   break;
        default : CatPrint(Str, L"x)");   break;
    }
}


VOID
_DevPathHardDrive (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    HARDDRIVE_DEVICE_PATH   *Hd;

    Hd = DevPath;
    switch (Hd->SignatureType) {
        case SIGNATURE_TYPE_MBR:
            CatPrint(Str, L"HD(Part%d,Sig%08X)", 
                Hd->PartitionNumber,
                *((UINT32 *)(&(Hd->Signature[0])))
                );
            break;
        case SIGNATURE_TYPE_GUID:
            CatPrint(Str, L"HD(Part%d,Sig%g)", 
                Hd->PartitionNumber,
                (EFI_GUID *) &(Hd->Signature[0])     
                );
            break;
        default:
            CatPrint(Str, L"HD(Part%d,MBRType=%02x,SigType=%02x)", 
                Hd->PartitionNumber,
                Hd->MBRType,
                Hd->SignatureType
                );
            break;
    }
}

VOID
_DevPathCDROM (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    CDROM_DEVICE_PATH       *Cd;

    Cd = DevPath;
    CatPrint(Str, L"CDROM(Entry%x)", Cd->BootEntry);
}

VOID
_DevPathFilePath (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    FILEPATH_DEVICE_PATH    *Fp;   

    Fp = DevPath;
    CatPrint(Str, L"%s", Fp->PathName);
}

VOID
_DevPathMediaProtocol (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    MEDIA_PROTOCOL_DEVICE_PATH  *MediaProt;

    MediaProt = DevPath;
    CatPrint(Str, L"%g", &MediaProt->Protocol);
}

VOID
_DevPathBssBss (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    BBS_BBS_DEVICE_PATH     *Bss;
    CHAR16                  *Type;

    Bss = DevPath;
    switch (Bss->DeviceType) {
    case BBS_TYPE_FLOPPY:               Type = L"Floppy";       break;
    case BBS_TYPE_HARDDRIVE:            Type = L"Harddrive";    break;
    case BBS_TYPE_CDROM:                Type = L"CDROM";        break;
    case BBS_TYPE_PCMCIA:               Type = L"PCMCIA";       break;
    case BBS_TYPE_USB:                  Type = L"Usb";          break;
    case BBS_TYPE_EMBEDDED_NETWORK:     Type = L"Net";          break;
    default:                            Type = L"?";            break;
    }

    CatPrint(Str, L"Bss-%s(%a)", Type, Bss->String);
}


VOID
_DevPathEndInstance (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    CatPrint(Str, L",");
}

VOID
_DevPathNodeUnknown (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    CatPrint(Str, L"?");
}


struct {
    UINT8   Type;
    UINT8   SubType;
    VOID    (*Function)(POOL_PRINT *, VOID *);    
} DevPathTable[] = {
    HARDWARE_DEVICE_PATH,   HW_PCI_DP,                        _DevPathPci,
    HARDWARE_DEVICE_PATH,   HW_PCCARD_DP,                     _DevPathPccard,
    HARDWARE_DEVICE_PATH,   HW_MEMMAP_DP,                     _DevPathMemMap,
    HARDWARE_DEVICE_PATH,   HW_VENDOR_DP,                     _DevPathVendor,
    HARDWARE_DEVICE_PATH,   HW_CONTROLLER_DP,                 _DevPathController,
    ACPI_DEVICE_PATH,       ACPI_DP,                          _DevPathAcpi,
    MESSAGING_DEVICE_PATH,  MSG_ATAPI_DP,                     _DevPathAtapi,
    MESSAGING_DEVICE_PATH,  MSG_SCSI_DP,                      _DevPathScsi,
    MESSAGING_DEVICE_PATH,  MSG_FIBRECHANNEL_DP,              _DevPathFibre,
    MESSAGING_DEVICE_PATH,  MSG_1394_DP,                      _DevPath1394,
    MESSAGING_DEVICE_PATH,  MSG_USB_DP,                       _DevPathUsb,
    MESSAGING_DEVICE_PATH,  MSG_I2O_DP,                       _DevPathI2O,
    MESSAGING_DEVICE_PATH,  MSG_MAC_ADDR_DP,                  _DevPathMacAddr,
    MESSAGING_DEVICE_PATH,  MSG_IPv4_DP,                      _DevPathIPv4,
    MESSAGING_DEVICE_PATH,  MSG_IPv6_DP,                      _DevPathIPv6,
    MESSAGING_DEVICE_PATH,  MSG_INFINIBAND_DP,                _DevPathInfiniBand,
    MESSAGING_DEVICE_PATH,  MSG_UART_DP,                      _DevPathUart,
    MESSAGING_DEVICE_PATH,  MSG_VENDOR_DP,                    _DevPathVendor,
    MEDIA_DEVICE_PATH,      MEDIA_HARDDRIVE_DP,               _DevPathHardDrive,
    MEDIA_DEVICE_PATH,      MEDIA_CDROM_DP,                   _DevPathCDROM,
    MEDIA_DEVICE_PATH,      MEDIA_VENDOR_DP,                  _DevPathVendor,
    MEDIA_DEVICE_PATH,      MEDIA_FILEPATH_DP,                _DevPathFilePath,
    MEDIA_DEVICE_PATH,      MEDIA_PROTOCOL_DP,                _DevPathMediaProtocol,
    BBS_DEVICE_PATH,        BBS_BBS_DP,                       _DevPathBssBss,
    END_DEVICE_PATH_TYPE,   END_INSTANCE_DEVICE_PATH_SUBTYPE, _DevPathEndInstance,
    0,                      0,                          NULL
};


CHAR16 *
DevicePathToStr (
    EFI_DEVICE_PATH     *DevPath
    )
/*++

    Turns the Device Path into a printable string.  Allcoates
    the string from pool.  The caller must FreePool the returned
    string.

--*/
{
    POOL_PRINT          Str;
    EFI_DEVICE_PATH     *DevPathNode;
    VOID                (*DumpNode)(POOL_PRINT *, VOID *);    
    UINTN               Index, NewSize;

    ZeroMem(&Str, sizeof(Str));

    /* 
     *  Unpacked the device path
     */

    DevPath = UnpackDevicePath(DevPath);
    ASSERT (DevPath);


    /* 
     *  Process each device path node
     *      */

    DevPathNode = DevPath;
    while (!IsDevicePathEnd(DevPathNode)) {

        /* 
         *  Find the handler to dump this device path node
         */

        DumpNode = NULL;
        for (Index = 0; DevPathTable[Index].Function; Index += 1) {

            if (DevicePathType(DevPathNode) == DevPathTable[Index].Type &&
                DevicePathSubType(DevPathNode) == DevPathTable[Index].SubType) {
                DumpNode = DevPathTable[Index].Function;
                break;
            }
        }

        /* 
         *  If not found, use a generic function
         */

        if (!DumpNode) {
            DumpNode = _DevPathNodeUnknown;
        }

        /* 
         *   Put a path seperator in if needed
         */

        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
            CatPrint (&Str, L"/");
        }

        /* 
         *  Print this node of the device path
         */

        DumpNode (&Str, DevPathNode);

        /* 
         *  Next device path node
         */

        DevPathNode = NextDevicePathNode(DevPathNode);
    }

    /* 
     *  Shrink pool used for string allocation
     */

    FreePool (DevPath);
    NewSize = (Str.len + 1) * sizeof(CHAR16);
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    Str.str[Str.len] = 0;
    return Str.str;
}

BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    )
{
    EFI_DEVICE_PATH     *DevicePath, *DevicePathInst;
    UINTN               Size;

    if (!Multi || !Single) {
        return FALSE;
    }

    DevicePath = Multi;
    while (DevicePathInst = DevicePathInstance (&DevicePath, &Size)) {
        if (CompareMem (Single, DevicePathInst, Size) == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    EFI_DEVICE_PATH     *NewDevPath,*DevicePathInst,*Temp;
    UINTN               Size;    

    /* 
     *  get the size of an instance from the input
     */

    Temp = DevPath;
    DevicePathInst = DevicePathInstance (&Temp, &Size);
    
    /* 
     *  Make a copy and set proper end type
     */
    NewDevPath = NULL;
    if (Size) { 
        NewDevPath = AllocatePool (Size + sizeof(EFI_DEVICE_PATH));
    }

    if (NewDevPath) {
        CopyMem (NewDevPath, DevicePathInst, Size);
        Temp = NextDevicePathNode(NewDevPath); 
        SetDevicePathEndNode(Temp);
    }

    return NewDevPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\init.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:


Abstract:




Revision History

--*/

#include "lib.h"

VOID
InitializeLib (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
/*++

Routine Description:

    Initializes EFI library for use
    
Arguments:

    Firmware's EFI system table
    
Returns:

    None

--*/ 
{
    EFI_LOADED_IMAGE        *LoadedImage;
    EFI_STATUS              Status;
    CHAR8                   *LangCode;

    if (!LibInitialized) {
        LibInitialized = TRUE;
        LibFwInstance = FALSE;

        /* 
         *  Set up global pointer to the system table, boot services table,
         *  and runtime services table
         */

        ST = SystemTable;
        BS = SystemTable->BootServices;
        RT = SystemTable->RuntimeServices;
/*         ASSERT (CheckCrc(0, &ST->Hdr));
 *         ASSERT (CheckCrc(0, &BS->Hdr));
 *         ASSERT (CheckCrc(0, &RT->Hdr)); */


        /* 
         *  Initialize pool allocation type
         */

        if (ImageHandle) {
            Status = BS->HandleProtocol (
                            ImageHandle, 
                            &LoadedImageProtocol,
                            (VOID*)&LoadedImage
                            );

            if (!EFI_ERROR(Status)) {
                PoolAllocationType = LoadedImage->ImageDataType;
            }
        }

        /* 
         *  Initialize Guid table
         */

        InitializeGuid();

        InitializeLibPlatform(ImageHandle,SystemTable);
    }

    /* 
     *  
     */

    if (ImageHandle && UnicodeInterface == &LibStubUnicodeInterface) {
        LangCode = LibGetVariable (VarLanguage, &EfiGlobalVariable);
        InitializeUnicodeSupport (LangCode);
        if (LangCode) {
            FreePool (LangCode);
        }
    }
}

VOID
InitializeUnicodeSupport (
    CHAR8 *LangCode
    )
{
    EFI_UNICODE_COLLATION_INTERFACE *Ui;
    EFI_STATUS                      Status;
    CHAR8                           *Languages;
    UINTN                           Index, Position, Length;
    UINTN                           NoHandles;
    EFI_HANDLE                      *Handles;

    /* 
     *  If we don't know it, lookup the current language code
     */

    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    if (!LangCode || !NoHandles) {
        goto Done;
    }

    /* 
     *  Check all driver's for a matching language code
     */

    for (Index=0; Index < NoHandles; Index++) {
        Status = BS->HandleProtocol (Handles[Index], &UnicodeCollationProtocol, (VOID*)&Ui);
        if (EFI_ERROR(Status)) {
            continue;
        }

        /* 
         *  Check for a matching language code
         */

        Languages = Ui->SupportedLanguages;
        Length = strlena(Languages);
        for (Position=0; Position < Length; Position += ISO_639_2_ENTRY_SIZE) {

            /* 
             *  If this code matches, use this driver
             */

            if (CompareMem (Languages+Position, LangCode, ISO_639_2_ENTRY_SIZE) == 0) {
                UnicodeInterface = Ui;
                goto Done;
            }
        }
    }

Done:
    /* 
     *  Cleanup
     */

    if (Handles) {
        FreePool (Handles);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\hw.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    hw.c

Abstract:

    Debug library functions for Hardware IO access



Revision History

--*/

#include "lib.h"


EFI_STATUS
InitializeGlobalIoDevice (
        IN  EFI_DEVICE_PATH             *DevicePath,
        IN  EFI_GUID                    *Protocol,
        IN  CHAR8                       *ErrorStr,
        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs 
        )
/*++

Routine Description:

    Check to see if DevicePath exists for a given Protocol. Return Error if it 
    exists. Return GlobalIoFuncs set match the DevicePath

  Arguments:

    DevicePath      - to operate on
    Protocol        - to check the DevicePath against
    ErrorStr        - ASCII string to display on error
    GlobalIoFncs    - Returned with DeviceIoProtocol for the DevicePath

Returns:

    Pass or Fail based on  wether GlobalIoFncs where found

--*/
{
    EFI_STATUS      Status;
    EFI_HANDLE      Handle;

    /* 
     *  Check to see if this device path already has Protocol on it.
     *   if so we are loading recursivly and should exit with an error
     */
    Status = BS->LocateDevicePath (Protocol, &DevicePath, &Handle);
    if (!EFI_ERROR(Status)) {
        DEBUG ((D_INIT, "Device Already Loaded for %a device\n", ErrorStr));
        return EFI_LOAD_ERROR;
    }

    Status = BS->LocateDevicePath (&DeviceIoProtocol, &DevicePath, &Handle);
    if (!EFI_ERROR(Status)) {
        Status = BS->HandleProtocol (Handle, &DeviceIoProtocol, (VOID*)GlobalIoFncs);
    }

    ASSERT (!EFI_ERROR(Status));
    return Status;
}

UINT32 
ReadPort (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port
        )
{
    UINT32       Data;
    EFI_STATUS  Status;

    Status = GlobalIoFncs->Io.Read (GlobalIoFncs, Width, (UINT64)Port, 1, &Data);
    ASSERT(!EFI_ERROR(Status));
    return Data;
}

UINT32 
WritePort (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port,
        IN  UINTN                       Data
        )
{
    EFI_STATUS  Status;

    Status = GlobalIoFncs->Io.Write (GlobalIoFncs, Width, (UINT64)Port, 1, &Data);
    ASSERT(!EFI_ERROR(Status));
    return (UINT32)Data;
}

UINT32 
ReadPciConfig (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Address
        )
{
    UINT32       Data;
    EFI_STATUS  Status;

    Status = GlobalIoFncs->Pci.Read (GlobalIoFncs, Width, (UINT64)Address, 1, &Data);
    ASSERT(!EFI_ERROR(Status));
    return Data;
}

UINT32 
WritePciConfig (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs, 
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Address,
        IN  UINTN                       Data
        )
{
    EFI_STATUS  Status;

    Status = GlobalIoFncs->Pci.Write (GlobalIoFncs, Width, (UINT64)Address, 1, &Data);
    ASSERT(!EFI_ERROR(Status));
    return (UINT32)Data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\misc.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    misc.c

Abstract:




Revision History

--*/

#include "lib.h"


/* 
 * 
 */

VOID *
AllocatePool (
    IN UINTN                Size
    )
{
    EFI_STATUS              Status;
    VOID                    *p;

    Status = BS->AllocatePool (PoolAllocationType, Size, &p);
    if (EFI_ERROR(Status)) {
        DEBUG((D_ERROR, "AllocatePool: out of pool  %x\n", Status));
        p = NULL;
    }
    return p;
}

VOID *
AllocateZeroPool (
    IN UINTN                Size
    )
{
    VOID                    *p;

    p = AllocatePool (Size);
    if (p) {
        ZeroMem (p, Size);
    }

    return p;
}

VOID *
ReallocatePool (
    IN VOID                 *OldPool,
    IN UINTN                OldSize,
    IN UINTN                NewSize
    )
{
    VOID                    *NewPool;

    NewPool = NULL;
    if (NewSize) {
        NewPool = AllocatePool (NewSize);
    }

    if (OldPool) {
        if (NewPool) {
            CopyMem (NewPool, OldPool, OldSize < NewSize ? OldSize : NewSize);
        }
    
        FreePool (OldPool);
    }
    
    return NewPool;
}


VOID
FreePool (
    IN VOID                 *Buffer
    )
{
    BS->FreePool (Buffer);
}



VOID
ZeroMem (
    IN VOID     *Buffer,
    IN UINTN    Size
    )
{
    RtZeroMem (Buffer, Size);
}

VOID
SetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value    
    )
{
    RtSetMem (Buffer, Size, Value);
}

VOID
CopyMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    )
{
    RtCopyMem (Dest, Src, len);
}

INTN
CompareMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    )
{
    return RtCompareMem (Dest, Src, len);
}

BOOLEAN
GrowBuffer(
    IN OUT EFI_STATUS   *Status,
    IN OUT VOID         **Buffer,
    IN UINTN            BufferSize
    )
/*++

Routine Description:

    Helper function called as part of the code needed
    to allocate the proper sized buffer for various 
    EFI interfaces.

Arguments:

    Status      - Current status

    Buffer      - Current allocated buffer, or NULL

    BufferSize  - Current buffer size needed
    
Returns:
    
    TRUE - if the buffer was reallocated and the caller 
    should try the API again.

--*/
{
    BOOLEAN         TryAgain;

    /* 
     *  If this is an initial request, buffer will be null with a new buffer size
     */

    if (!*Buffer && BufferSize) {
        *Status = EFI_BUFFER_TOO_SMALL;
    }

    /* 
     *  If the status code is "buffer too small", resize the buffer
     */
        
    TryAgain = FALSE;
    if (*Status == EFI_BUFFER_TOO_SMALL) {

        if (*Buffer) {
            FreePool (*Buffer);
        }

        *Buffer = AllocatePool (BufferSize);

        if (*Buffer) {
            TryAgain = TRUE;
        } else {    
            *Status = EFI_OUT_OF_RESOURCES;
        } 
    }

    /* 
     *  If there's an error, free the buffer
     */

    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
        FreePool (*Buffer);
        *Buffer = NULL;
    }

    return TryAgain;
}


EFI_MEMORY_DESCRIPTOR *
LibMemoryMap (
    OUT UINTN               *NoEntries,
    OUT UINTN               *MapKey,
    OUT UINTN               *DescriptorSize,
    OUT UINT32              *DescriptorVersion
    )
{
    EFI_STATUS              Status;
    EFI_MEMORY_DESCRIPTOR   *Buffer;
    UINTN                   BufferSize;

    /* 
     *  Initialize for GrowBuffer loop
     */

    Buffer = NULL;
    BufferSize = sizeof(EFI_MEMORY_DESCRIPTOR);

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
        Status = BS->GetMemoryMap (&BufferSize, Buffer, MapKey, DescriptorSize, DescriptorVersion);
    }

    /* 
     *  Convert buffer size to NoEntries
     */

    if (!EFI_ERROR(Status)) {
        *NoEntries = BufferSize / *DescriptorSize;
    }

    return Buffer;
}

VOID *
LibGetVariableAndSize (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid,
    OUT UINTN               *VarSize
    )
{
    EFI_STATUS              Status;
    VOID                    *Buffer;
    UINTN                   BufferSize;

    /* 
     *  Initialize for GrowBuffer loop
     */

    Buffer = NULL;
    BufferSize = 100;

    /* 
     *  Call the real function
     */

    while (GrowBuffer (&Status, &Buffer, BufferSize)) {
        Status = RT->GetVariable (
                    Name,
                    VendorGuid,
                    NULL,
                    &BufferSize,
                    Buffer
                    );
    }
    if (Buffer) {
        *VarSize = BufferSize;
    } else {
        *VarSize = 0;
    }
    return Buffer;
}
    
VOID *
LibGetVariable (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid
    )
{
    UINTN   VarSize;

    return LibGetVariableAndSize (Name, VendorGuid, &VarSize);
}


BOOLEAN
ValidMBR(
    IN  MASTER_BOOT_RECORD  *Mbr,
    IN  EFI_BLOCK_IO        *BlkIo
    )
{
    UINT32      StartingLBA, EndingLBA;
    UINT32      NewEndingLBA;
    INTN        i, j;
    BOOLEAN     ValidMbr;

    if (Mbr->Signature != MBR_SIGNATURE) {
        /* 
         *  The BPB also has this signature, so it can not be used alone.
         */
        return FALSE;
    } 

    ValidMbr = FALSE;
    for (i=0; i<MAX_MBR_PARTITIONS; i++) {
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
            continue;
        }
        ValidMbr = TRUE;
        StartingLBA = EXTRACT_UINT32(Mbr->Partition[i].StartingLBA);
        EndingLBA = StartingLBA + EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) - 1;
        if (EndingLBA > BlkIo->Media->LastBlock) {
            /* 
             *  Compatability Errata:
             *   Some systems try to hide drive space with thier INT 13h driver
             *   This does not hide space from the OS driver. This means the MBR
             *   that gets created from DOS is smaller than the MBR created from 
             *   a real OS (NT & Win98). This leads to BlkIo->LastBlock being 
             *   wrong on some systems FDISKed by the OS.
             * 
             */
        if (BlkIo->Media->LastBlock < MIN_MBR_DEVICE_SIZE) {
                /* 
                 *  If this is a very small device then trust the BlkIo->LastBlock
                 */
                return FALSE;
            }

            if (EndingLBA > (BlkIo->Media->LastBlock + MBR_ERRATA_PAD)) {
                return FALSE;
            }

        }
        for (j=i+1; j<MAX_MBR_PARTITIONS; j++) {
            if (Mbr->Partition[j].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[j].SizeInLBA) == 0) {
                continue;
            }
            if (   EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) >= StartingLBA && 
                   EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) <= EndingLBA       ) {
                /* 
                 *  The Start of this region overlaps with the i'th region
                 */
                return FALSE;
            } 
            NewEndingLBA = EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) + EXTRACT_UINT32(Mbr->Partition[j].SizeInLBA) - 1;
            if ( NewEndingLBA >= StartingLBA && NewEndingLBA <= EndingLBA ) {
                /* 
                 *  The End of this region overlaps with the i'th region
                 */
                return FALSE;
            }
        }
    }
    /* 
     *  Non of the regions overlapped so MBR is O.K.
     */
    return ValidMbr;
} 
   

UINT8
DecimaltoBCD(
    IN  UINT8 DecValue
    )
{
    return RtDecimaltoBCD (DecValue);
}


UINT8
BCDtoDecimal(
    IN  UINT8 BcdValue
    )
{
    return RtBCDtoDecimal (BcdValue);
}

EFI_STATUS
LibGetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    )

{
    UINTN Index;

    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
        if (CompareGuid(TableGuid,&(ST->ConfigurationTable[Index].VendorGuid))==0) {
            *Table = ST->ConfigurationTable[Index].VendorTable;
            return EFI_SUCCESS;
        }
    }
    return EFI_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\lock.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    lock.c

Abstract:

    Implements FLOCK



Revision History

--*/


#include "lib.h"


VOID
InitializeLock (
    IN OUT FLOCK    *Lock,
    IN EFI_TPL      Priority
    )
/*++

Routine Description:

    Initialize a basic mutual exclusion lock.   Each lock
    provides mutual exclusion access at it's task priority
    level.  Since there is no-premption (at any TPL) or
    multiprocessor support, acquiring the lock only consists
    of raising to the locks TPL.

    Note on a debug build the lock is acquired and released
    to help ensure proper usage.
    
Arguments:

    Lock        - The FLOCK structure to initialize

    Priority    - The task priority level of the lock

    
Returns:

    An initialized F Lock structure.

--*/
{
    Lock->Tpl = Priority;
    Lock->OwnerTpl = 0;
    Lock->Lock = 0;
}


VOID
AcquireLock (
    IN FLOCK    *Lock
    )
/*++

Routine Description:

    Raising to the task priority level of the mutual exclusion
    lock, and then acquires ownership of the lock.
    
Arguments:

    Lock        - The lock to acquire
    
Returns:

    Lock owned

--*/
{
    RtAcquireLock (Lock);
}


VOID
ReleaseLock (
    IN FLOCK    *Lock
    )
/*++

Routine Description:

    Releases ownership of the mutual exclusion lock, and
    restores the previous task priority level.
    
Arguments:

    Lock        - The lock to release
    
Returns:

    Lock unowned

--*/
{
    RtReleaseLock (Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\print.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    print.c

Abstract:




Revision History

--*/

#include "lib.h"
#include "efistdarg.h"                        /*  !!! */

/* 
 *  Declare runtime functions
 */

#ifdef RUNTIME_CODE
#pragma RUNTIME_CODE(DbgPrint)

/*  For debugging.. */

/*
#pragma RUNTIME_CODE(_Print)
#pragma RUNTIME_CODE(PFLUSH)
#pragma RUNTIME_CODE(PSETATTR)
#pragma RUNTIME_CODE(PPUTC)
#pragma RUNTIME_CODE(PGETC)
#pragma RUNTIME_CODE(PITEM)
#pragma RUNTIME_CODE(ValueToHex)
#pragma RUNTIME_CODE(ValueToString)
#pragma RUNTIME_CODE(TimeToString)
*/

#endif

/* 
 * 
 */


#define PRINT_STRING_LEN            200
#define PRINT_ITEM_BUFFER_LEN       100

typedef struct {
    BOOLEAN             Ascii;
    UINTN               Index;
    union {
        CHAR16          *pw;
        CHAR8           *pc;
    } ;
} POINTER;


typedef struct _pitem {

    POINTER     Item;
    CHAR16      Scratch[PRINT_ITEM_BUFFER_LEN];
    UINTN       Width;
    UINTN       FieldWidth;
    UINTN       *WidthParse;
    CHAR16      Pad;
    BOOLEAN     PadBefore;
    BOOLEAN     Comma;
    BOOLEAN     Long;
} PRINT_ITEM;


typedef struct _pstate {
    /*  Input */
    POINTER     fmt;
    va_list     args;

    /*  Output */
    CHAR16      *Buffer;
    CHAR16      *End;
    CHAR16      *Pos;
    UINTN       Len;

    UINTN       Attr;    
    UINTN       RestoreAttr;

    UINTN       AttrNorm;
    UINTN       AttrHighlight;
    UINTN       AttrError;

    INTN        (*Output)(VOID *context, CHAR16 *str);
    INTN        (*SetAttr)(VOID *context, UINTN attr);
    VOID        *Context;    

    /*  Current item being formatted */
    struct _pitem  *Item;
} PRINT_STATE;

/* 
 *  Internal fucntions
 */

STATIC
UINTN
_Print (
    IN PRINT_STATE     *ps
    );

STATIC
UINTN
_IPrint (
    IN UINTN                            Column,
    IN UINTN                            Row,
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
    IN CHAR16                           *fmt,
    IN CHAR8                            *fmta,
    IN va_list                          args
    );

STATIC
INTN
_DbgOut (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    );

STATIC
VOID
PFLUSH (
    IN OUT PRINT_STATE     *ps
    );

STATIC
VOID
PPUTC (
    IN OUT PRINT_STATE     *ps,
    IN CHAR16              c
    );

STATIC
VOID
PITEM (
    IN OUT PRINT_STATE  *ps
    );

STATIC
CHAR16
PGETC (
    IN POINTER      *p
    );

STATIC
VOID
PSETATTR (
    IN OUT PRINT_STATE  *ps,
    IN UINTN             Attr
    );

VOID
ValueToLowerHex (
    IN CHAR16   *Buffer,
    IN UINT64   v
    );

/* 
 * 
 */

INTN
DbgPrint (
    IN INTN      mask,
    IN CHAR8     *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to the default StandardError console

Arguments:

    mask        - Bit mask of debug string.  If a bit is set in the
                  mask that is also set in EFIDebug the string is 
                  printed; otherwise, the string is not printed

    fmt         - Format string

Returns:

    Length of string printed to the StandardError console

--*/
{
    SIMPLE_TEXT_OUTPUT_INTERFACE    *DbgOut;
    PRINT_STATE     ps;
    va_list         args;
    UINTN           back;
    UINTN           attr;
    UINTN           SavedAttribute;


    if (!(EFIDebug & mask)) {
        return 0;
    }

    va_start (args, fmt);
    ZeroMem (&ps, sizeof(ps));

    ps.Output = _DbgOut; 
    ps.fmt.Ascii = TRUE;
    ps.fmt.pc = fmt;
    ps.args = args;
    ps.Attr = EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_RED); 

    DbgOut = LibRuntimeDebugOut;

    if (!DbgOut) {
        DbgOut = ST->StdErr;
    }

    if (DbgOut) {
        ps.Attr = DbgOut->Mode->Attribute;
        ps.Context = DbgOut;
        ps.SetAttr = (INTN (*)(VOID *, UINTN))  DbgOut->SetAttribute;
    }

    SavedAttribute = ps.Attr;

    back = (ps.Attr >> 4) & 0xf;
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);

    attr = ps.AttrNorm;

    if (mask & D_WARN) {
        attr = ps.AttrHighlight;
    }

    if (mask & D_ERROR) {
        attr = ps.AttrError;
    }

    if (ps.SetAttr) {
        ps.Attr = attr;
        ps.SetAttr (ps.Context, attr);
    }

    _Print (&ps);

    /* 
     *  Restore original attributes
     */

    if (ps.SetAttr) {
        ps.SetAttr (ps.Context, SavedAttribute);
    }
    
    return 0;
}



STATIC
INTN
_DbgOut (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
/*  Append string worker for DbgPrint */
{
    SIMPLE_TEXT_OUTPUT_INTERFACE    *DbgOut;

    DbgOut = Context;
/*     if (!DbgOut && ST && ST->ConOut) {
 *         DbgOut = ST->ConOut;
 *     } */

    if (DbgOut) {
        DbgOut->OutputString (DbgOut, Buffer);
    }

    return 0;
}

INTN
_SPrint (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
/*  Append string worker for SPrint, PoolPrint and CatPrint */
{
    UINTN           len;
    POOL_PRINT      *spc;

    spc = Context;
    len = StrLen(Buffer);

    /* 
     *  Is the string is over the max truncate it
     */

    if (spc->len + len > spc->maxlen) {
        len = spc->maxlen - spc->len;
    }

    /* 
     *  Append the new text
     */

    CopyMem (spc->str + spc->len, Buffer, len * sizeof(CHAR16));
    spc->len += len;

    /* 
     *  Null terminate it
     */

    if (spc->len < spc->maxlen) {
        spc->str[spc->len] = 0;
    } else if (spc->maxlen) {
        spc->str[spc->maxlen-1] = 0;
    }

    return 0;
}


INTN
_PoolPrint (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
/*  Append string worker for PoolPrint and CatPrint */
{
    UINTN           newlen;
    POOL_PRINT      *spc;

    spc = Context;
    newlen = spc->len + StrLen(Buffer) + 1;

    /* 
     *  Is the string is over the max, grow the buffer
     */

    if (newlen > spc->maxlen) {

        /* 
         *  Grow the pool buffer
         */

        newlen += PRINT_STRING_LEN;
        spc->maxlen = newlen;
        spc->str = ReallocatePool (
                        spc->str, 
                        spc->len * sizeof(CHAR16), 
                        spc->maxlen * sizeof(CHAR16)
                        );

        if (!spc->str) {
            spc->len = 0;
            spc->maxlen = 0;
        }
    }

    /* 
     *  Append the new text
     */

    return _SPrint (Context, Buffer);
}



VOID
_PoolCatPrint (
    IN CHAR16           *fmt,
    IN va_list          args,
    IN OUT POOL_PRINT   *spc,
    IN INTN             (*Output)(VOID *context, CHAR16 *str)
    )
/*  Dispath function for SPrint, PoolPrint, and CatPrint */
{
    PRINT_STATE         ps;

    ZeroMem (&ps, sizeof(ps));
    ps.Output  = Output;
    ps.Context = spc;
    ps.fmt.pw = fmt;
    ps.args = args;
    _Print (&ps);
}



UINTN
SPrint (
    OUT CHAR16  *Str,
    IN UINTN    StrSize,
    IN CHAR16   *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to a buffer

Arguments:

    Str         - Output buffer to print the formatted string into

    StrSize     - Size of Str.  String is truncated to this size.
                  A size of 0 means there is no limit

    fmt         - The format string

Returns:

    String length returned in buffer

--*/
{
    POOL_PRINT          spc;
    va_list             args;


    va_start (args, fmt);
    spc.str    = Str;
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    spc.len    = 0;

    _PoolCatPrint (fmt, args, &spc, _SPrint);
    return spc.len;
}


CHAR16 *
PoolPrint (
    IN CHAR16           *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to allocated pool.  The caller
    must free the resulting buffer.

Arguments:

    fmt         - The format string

Returns:

    Allocated buffer with the formatted string printed in it.  
    The caller must free the allocated buffer.   The buffer
    allocation is not packed.

--*/
{
    POOL_PRINT          spc;
    va_list             args;

    ZeroMem (&spc, sizeof(spc));
    va_start (args, fmt);
    _PoolCatPrint (fmt, args, &spc, _PoolPrint);
    return spc.str;
}



CHAR16 *
CatPrint (
    IN OUT POOL_PRINT   *Str,
    IN CHAR16           *fmt,
    ...
    )
/*++

Routine Description:

    Concatenates a formatted unicode string to allocated pool.  
    The caller must free the resulting buffer.

Arguments:

    Str         - Tracks the allocated pool, size in use, and 
                  amount of pool allocated.

    fmt         - The format string

Returns:

    Allocated buffer with the formatted string printed in it.  
    The caller must free the allocated buffer.   The buffer
    allocation is not packed.

--*/
{
    va_list             args;

    va_start (args, fmt);
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    return Str->str;
}



UINTN
Print (
    IN CHAR16   *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to the default console

Arguments:

    fmt         - Format string

Returns:

    Length of string printed to the console

--*/
{
    va_list     args;

    va_start (args, fmt);
    return _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
}

UINTN
PrintAt (
    IN UINTN     Column,
    IN UINTN     Row,
    IN CHAR16    *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to the default console, at 
    the supplied cursor position

Arguments:

    Column, Row - The cursor position to print the string at

    fmt         - Format string

Returns:

    Length of string printed to the console

--*/
{
    va_list     args;

    va_start (args, fmt);
    return _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
}


UINTN
IPrint (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
    IN CHAR16                          *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to the specified console

Arguments:

    Out         - The console to print the string too

    fmt         - Format string

Returns:

    Length of string printed to the console

--*/
{
    va_list     args;

    va_start (args, fmt);
    return _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
}


UINTN
IPrintAt (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
    IN UINTN                            Column,
    IN UINTN                            Row,
    IN CHAR16                           *fmt,
    ...
    )
/*++

Routine Description:

    Prints a formatted unicode string to the specified console, at
    the supplied cursor position

Arguments:

    Out         - The console to print the string too

    Column, Row - The cursor position to print the string at

    fmt         - Format string

Returns:

    Length of string printed to the console

--*/
{
    va_list     args;

    va_start (args, fmt);
    return _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
}


UINTN
_IPrint (
    IN UINTN                            Column,
    IN UINTN                            Row,
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
    IN CHAR16                           *fmt,
    IN CHAR8                            *fmta,
    IN va_list                          args
    )
/*  Display string worker for: Print, PrintAt, IPrint, IPrintAt */
{
    PRINT_STATE     ps;
    UINTN            back;

    ZeroMem (&ps, sizeof(ps));
    ps.Context = Out;
    ps.Output  = (INTN (*)(VOID *, CHAR16 *)) Out->OutputString;
    ps.SetAttr = (INTN (*)(VOID *, UINTN))  Out->SetAttribute;
    ps.Attr = Out->Mode->Attribute;
   
    back = (ps.Attr >> 4) & 0xF;
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);

    if (fmt) {
        ps.fmt.pw = fmt;
    } else {
        ps.fmt.Ascii = TRUE;
        ps.fmt.pc = fmta;
    }

    ps.args = args;

    if (Column != (UINTN) -1) {
        Out->SetCursorPosition(Out, Column, Row);
    }

    return _Print (&ps);
}


UINTN
APrint (
    IN CHAR8    *fmt,
    ...
    )
/*++

Routine Description:

    For those whom really can't deal with unicode, a print
    function that takes an ascii format string

Arguments:

    fmt         - ascii format string

Returns:

    Length of string printed to the console

--*/

{
    va_list     args;

    va_start (args, fmt);
    return _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
}


STATIC
VOID
PFLUSH (
    IN OUT PRINT_STATE     *ps
    )
{
    *ps->Pos = 0;
    ps->Output(ps->Context, ps->Buffer);
    ps->Pos = ps->Buffer;
}

STATIC
VOID
PSETATTR (
    IN OUT PRINT_STATE  *ps,
    IN UINTN             Attr
    )
{
   PFLUSH (ps);

   ps->RestoreAttr = ps->Attr;
   if (ps->SetAttr) {
        ps->SetAttr (ps->Context, Attr);
   }

   ps->Attr = Attr;
}   

STATIC
VOID
PPUTC (
    IN OUT PRINT_STATE     *ps,
    IN CHAR16              c
    )
{
    /*  if this is a newline, add a carraige return */
    if (c == '\n') {
        PPUTC (ps, '\r');
    }

    *ps->Pos = c;
    ps->Pos += 1;
    ps->Len += 1;

    /*  if at the end of the buffer, flush it */
    if (ps->Pos >= ps->End) {
        PFLUSH(ps);
    }
}


STATIC
CHAR16
PGETC (
    IN POINTER      *p
    )
{
    CHAR16      c;

    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    p->Index += 1;

    return  c;
}


STATIC
VOID
PITEM (
    IN OUT PRINT_STATE  *ps
    )
{
    UINTN               Len, i;
    PRINT_ITEM          *Item;
    CHAR16              c;

    /*  Get the length of the item */
    Item = ps->Item;
    Item->Item.Index = 0;
    while (Item->Item.Index < Item->FieldWidth) {
        c = PGETC(&Item->Item);
        if (!c) {
            Item->Item.Index -= 1;
            break;
        }
    }
    Len = Item->Item.Index;

    /*  if there is no item field width, use the items width */
    if (Item->FieldWidth == (UINTN) -1) {
        Item->FieldWidth = Len;
    }

    /*  if item is larger then width, update width */
    if (Len > Item->Width) {
        Item->Width = Len;
    }


    /*  if pad field before, add pad char */
    if (Item->PadBefore) {
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
            PPUTC (ps, ' ');
        }
    }

    /*  pad item */
    for (i=Len; i < Item->Width; i++) {
        PPUTC (ps, Item->Pad);
    }

    /*  add the item */
    Item->Item.Index=0; 
    while (Item->Item.Index < Len) {
        PPUTC (ps, PGETC(&Item->Item));
    }

    /*  If pad at the end, add pad char */
    if (!Item->PadBefore) {
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
            PPUTC (ps, ' ');
        }
    }
}


STATIC
UINTN
_Print (
    IN PRINT_STATE     *ps
    )
/*++

Routine Description:

    %w.lF   -   w = width
                l = field width
                F = format of arg

  Args F:
    0       -   pad with zeros
    -       -   justify on left (default is on right)
    ,       -   add comma's to field    
    *       -   width provided on stack
    n       -   Set output attribute to normal (for this field only)
    h       -   Set output attribute to highlight (for this field only)
    e       -   Set output attribute to error (for this field only)
    l       -   Value is 64 bits

    a       -   ascii string
    s       -   unicode string
    X       -   fixed 8 byte value in hex
    x       -   hex value
    d       -   value as decimal    
    c       -   Unicode char
    t       -   EFI time structure
    g       -   Pointer to GUID
    r       -   EFI status code (result code)

    N       -   Set output attribute to normal
    H       -   Set output attribute to highlight
    E       -   Set output attribute to error
    %       -   Print a %
    
Arguments:

    SystemTable     - The system table

Returns:

    Number of charactors written   

--*/
{
    CHAR16          c;
    UINTN           Attr;
    PRINT_ITEM      Item;
    CHAR16          Buffer[PRINT_STRING_LEN];

    ps->Len = 0;
    ps->Buffer = Buffer;
    ps->Pos = Buffer;
    ps->End = Buffer + PRINT_STRING_LEN - 1;
    ps->Item = &Item;

    ps->fmt.Index = 0;
    while (c = PGETC(&ps->fmt)) {

        if (c != '%') {
            PPUTC ( ps, c );
            continue;   
        }

        /*  setup for new item */
        Item.FieldWidth = (UINTN) -1;
        Item.Width = 0;
        Item.WidthParse = &Item.Width;
        Item.Pad = ' ';
        Item.PadBefore = TRUE;
        Item.Comma = FALSE;
        Item.Long = FALSE;
        Item.Item.Ascii = FALSE;
        Item.Item.pw = NULL;
        ps->RestoreAttr = 0;
        Attr = 0;

        while (c = PGETC(&ps->fmt)) {

            switch (c) {
            
            case '%':
                /* 
                 *  %% -> %
                 */
                Item.Item.pw = Item.Scratch;
                Item.Item.pw[0] = '%';  
                Item.Item.pw[1] = 0;
                break;

            case '0':
                Item.Pad = '0';
                break;

            case '-':
                Item.PadBefore = FALSE;
                break;

            case ',':
                Item.Comma = TRUE;
                break;

            case '.':
                Item.WidthParse = &Item.FieldWidth;
                break;

            case '*':
                *Item.WidthParse = va_arg(ps->args, UINTN);
                break;
            
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                *Item.WidthParse = 0;
                do {
                    *Item.WidthParse = *Item.WidthParse * 10 + c - '0';
                    c = PGETC(&ps->fmt);
                } while (c >= '0'  &&  c <= '9') ;
                ps->fmt.Index -= 1;
                break;

            case 'a':
                Item.Item.pc = va_arg(ps->args, CHAR8 *);
                Item.Item.Ascii = TRUE;
                if (!Item.Item.pc) {
                    Item.Item.pc = "(null)";
                }
                break;

            case 's':
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
                if (!Item.Item.pw) {
                    Item.Item.pw = L"(null)";
                }
                break;

            case 'c':
                Item.Item.pw = Item.Scratch;
                Item.Item.pw[0] = (CHAR16) va_arg(ps->args, UINTN);  
                Item.Item.pw[1] = 0;
                break;

            case 'l':
                Item.Long = TRUE;
                break;

            case 'X':
                Item.Item.pw = Item.Scratch;
                ValueToHex (
                    Item.Item.pw, 
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINTN)
                    );
                break;
            case 'x':
                Item.Item.pw = Item.Scratch;
                ValueToLowerHex (
                    Item.Item.pw, 
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINTN)
                    );

                break;
        

            case 'g':
                Item.Item.pw = Item.Scratch;
                GuidToString (Item.Item.pw, va_arg(ps->args, EFI_GUID *));
                break;

            case 'd':
                Item.Item.pw = Item.Scratch;
                ValueToString (
                    Item.Item.pw, 
                    Item.Comma, 
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINTN)
                    );
                break
                    ;
            case 't':
                Item.Item.pw = Item.Scratch;
                TimeToString (Item.Item.pw, va_arg(ps->args, EFI_TIME *));
                break;

            case 'r':
                Item.Item.pw = Item.Scratch;
                StatusToString (Item.Item.pw, va_arg(ps->args, EFI_STATUS));
                break;

            case 'n':
                PSETATTR(ps, ps->AttrNorm);
                break;

            case 'h':
                PSETATTR(ps, ps->AttrHighlight);
                break;

            case 'e':
                PSETATTR(ps, ps->AttrError);
                break;

            case 'N':
                Attr = ps->AttrNorm;
                break;

            case 'H':
                Attr = ps->AttrHighlight;
                break;

            case 'E':
                Attr = ps->AttrError;
                break;

            default:
                Item.Item.pw = Item.Scratch;
                Item.Item.pw[0] = '?';
                Item.Item.pw[1] = 0;
                break;
            }

            /*  if we have an Item */
            if (Item.Item.pw) {
                PITEM (ps);
                break;
            }

            /*  if we have an Attr set */
            if (Attr) {
                PSETATTR(ps, Attr);
                ps->RestoreAttr = 0;
                break;
            }
        }

        if (ps->RestoreAttr) {
            PSETATTR(ps, ps->RestoreAttr);
        }
    }

    /*  Flush buffer */
    PFLUSH (ps);
    return ps->Len;
}

STATIC CHAR8 UpperHex[] = {'0','1','2','3','4','5','6','7',
                           '8','9','A','B','C','D','E','F'};

STATIC CHAR8 LowerHex[] = {'0','1','2','3','4','5','6','7',
                           '8','9','a','b','c','d','e','f'};
 
CHAR8 *Hex = UpperHex;

//
// default will be Upper Case
//
VOID
ValueToHex (
    IN CHAR16   *Buffer,
    IN UINT64   v
    )
{
    CHAR8           str[30], *p1;
    CHAR16          *p2;

    if (!v) {
        Buffer[0] = '0';
        Buffer[1] = 0;
        return ;
    }

    p1 = str;
    p2 = Buffer;

    while (v) {
        *(p1++) = Hex[v & 0xf];
        v = RShiftU64 (v, 4);
    }

    while (p1 != str) {
        *(p2++) = *(--p1);
    }
    *p2 = 0;
}

VOID
ValueToLowerHex (
    IN CHAR16   *Buffer,
    IN UINT64   v
    )
{
    Hex = LowerHex;
    ValueToHex(Buffer, v);
    Hex = UpperHex;
}


VOID
ValueToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN INT64    v
    )
{
    STATIC CHAR8 ca[] = {  3, 1, 2 };
    CHAR8        str[40], *p1;
    CHAR16       *p2;
    UINTN        c, r;

    if (!v) {
        Buffer[0] = '0';
        Buffer[1] = 0;
        return ;
    }

    p1 = str;
    p2 = Buffer;

    if (v < 0) {
        *(p2++) = '-';
        v = -v;
    }

    while (v) {
        v = (INT64)DivU64x32 ((UINT64)v, 10, &r);
        *(p1++) = (CHAR8)r + '0';
    }

    c = (Comma ? ca[(p1 - str) % 3] : 999) + 1;
    while (p1 != str) {

        c -= 1;
        if (!c) {
            *(p2++) = ',';
            c = 3;
        }

        *(p2++) = *(--p1);
    }
    *p2 = 0;
}

VOID
TimeToString (
    OUT CHAR16      *Buffer,
    IN EFI_TIME     *Time
    )
{
    UINTN       Hour, Year;
    CHAR16      AmPm;

    AmPm = 'a';
    Hour = Time->Hour;
    if (Time->Hour == 0) {
        Hour = 12;
    } else if (Time->Hour >= 12) {
        AmPm = 'p';
        if (Time->Hour >= 13) {
            Hour -= 12;
        }
    }

    Year = Time->Year % 100;
    
    /*  bugbug: for now just print it any old way */
    SPrint (Buffer, 0, L"%02d/%02d/%02d  %02d:%02d%c",
        Time->Month,
        Time->Day,
        Year,
        Hour,
        Time->Minute,
        AmPm
        );
} 




VOID
DumpHex (
    IN UINTN        Indent,
    IN UINTN        Offset,
    IN UINTN        DataSize,
    IN VOID         *UserData
    )
{
    CHAR8           *Data, Val[50], Str[20], c;
    UINTN           Size, Index;
    
    UINTN           ScreenCount;
    UINTN           TempColumn;
    UINTN           ScreenSize;
    CHAR16          ReturnStr[1];


    ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    ScreenCount = 0;
    ScreenSize -= 2;

    Data = UserData;
    while (DataSize) {
        Size = 16;
        if (Size > DataSize) {
            Size = DataSize;
        }

        for (Index=0; Index < Size; Index += 1) {
            c = Data[Index];
            Val[Index*3+0] = Hex[c>>4];
            Val[Index*3+1] = Hex[c&0xF];
            Val[Index*3+2] = (Index == 7)?'-':' ';
            Str[Index] = (c < ' ' || c > 'z') ? '.' : c;
        }

        Val[Index*3] = 0;
        Str[Index] = 0;
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);

        Data += Size;
        Offset += Size;
        DataSize -= Size;

        ScreenCount++;
        if (ScreenCount >= ScreenSize && ScreenSize != 0) {
            /* 
             *  If ScreenSize == 0 we have the console redirected so don't
             *   block updates
             */
            ScreenCount = 0;
            Print (L"Press Return to contiue :");
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
            Print (L"\n");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\lib.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    lib.h

Abstract:

    EFI library header files



Revision History

--*/


#include "efi.h"
#include "efilib.h"
#include "EfiRtLib.h"

/* 
 *  Include non architectural protocols
 */

#include "efivar.h"
#include "legacyBoot.h"
#include "intload.h"
#include "VgaClass.h"
#include "EfiConSplit.h"
/* 
 *  Prototypes
 */

VOID
InitializeGuid (
    VOID
    );

INTN
LibStubStriCmp (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *S1,
    IN CHAR16                           *S2
    );

BOOLEAN
LibStubMetaiMatch (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *String,
    IN CHAR16                           *Pattern
    );

VOID
LibStubStrLwrUpr (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *Str
    );

BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    );

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    );


/* 
 *  Globals
 */
extern BOOLEAN                          LibInitialized;
extern BOOLEAN                          LibFwInstance;
extern SIMPLE_TEXT_OUTPUT_INTERFACE     *LibRuntimeDebugOut;
extern EFI_UNICODE_COLLATION_INTERFACE  *UnicodeInterface;
extern EFI_UNICODE_COLLATION_INTERFACE  LibStubUnicodeInterface;
extern EFI_RAISE_TPL                    LibRuntimeRaiseTPL;
extern EFI_RESTORE_TPL                  LibRuntimeRestoreTPL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\sread.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:
    
    sread.c

Abstract:

    Simple read file access



Revision History

--*/

#include "lib.h"

#define SIMPLE_READ_SIGNATURE       EFI_SIGNATURE_32('s','r','d','r')
typedef struct _SIMPLE_READ_FILE {
    UINTN               Signature;
    BOOLEAN             FreeBuffer;
    VOID                *Source;
    UINTN               SourceSize;
    EFI_FILE_HANDLE     FileHandle;
} SIMPLE_READ_HANDLE;

       

EFI_STATUS
OpenSimpleReadFile (
    IN BOOLEAN                  BootPolicy,
    IN VOID                     *SourceBuffer   OPTIONAL,
    IN UINTN                    SourceSize,
    IN OUT EFI_DEVICE_PATH      **FilePath,
    OUT EFI_HANDLE              *DeviceHandle,
    OUT SIMPLE_READ_FILE        *SimpleReadHandle
    )
/*++

Routine Description:

    Opens a file for (simple) reading.  The simple read abstraction
    will access the file either from a memory copy, from a file
    system interface, or from the load file interface. 

Arguments:

Returns:

    A handle to access the file

--*/
{
    SIMPLE_READ_HANDLE          *FHand;
    EFI_DEVICE_PATH             *UserFilePath;
    FILEPATH_DEVICE_PATH        *FilePathNode;
    EFI_FILE_HANDLE             FileHandle, LastHandle;
    EFI_STATUS                  Status;
    EFI_LOAD_FILE_INTERFACE     *LoadFile;
  
    FHand = NULL;
    UserFilePath = *FilePath;

    /* 
     *  Allocate a new simple read handle structure
     */

    FHand = AllocateZeroPool (sizeof(SIMPLE_READ_HANDLE));
    if (!FHand) {
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    *SimpleReadHandle = (SIMPLE_READ_FILE) FHand;
    FHand->Signature = SIMPLE_READ_SIGNATURE;

    /* 
     *  If the caller passed a copy of the file, then just use it
     */

    if (SourceBuffer) {
        FHand->Source = SourceBuffer;
        FHand->SourceSize = SourceSize;
        *DeviceHandle = NULL;
        Status = EFI_SUCCESS;
        goto Done;
    } 

    /* 
     *  Attempt to access the file via a file system interface
     */

    FileHandle = NULL;
    Status = BS->LocateDevicePath (&FileSystemProtocol, FilePath, DeviceHandle);
    if (!EFI_ERROR(Status)) {
        FileHandle = LibOpenRoot (*DeviceHandle);
    }

    Status = FileHandle ? EFI_SUCCESS : EFI_UNSUPPORTED;

    /* 
     *  To access as a filesystem, the filepath should only
     *  contain filepath components.  Follow the filepath nodes
     *  and find the target file
     */

    FilePathNode = (FILEPATH_DEVICE_PATH *) *FilePath;
    while (!IsDevicePathEnd(&FilePathNode->Header)) {

        /* 
         *  For filesystem access each node should be a filepath component
         */

        if (DevicePathType(&FilePathNode->Header) != MEDIA_DEVICE_PATH ||
            DevicePathSubType(&FilePathNode->Header) != MEDIA_FILEPATH_DP) {
            Status = EFI_UNSUPPORTED;
        }

        /* 
         *  If there's been an error, stop
         */

        if (EFI_ERROR(Status)) {
            break;
        }
        
        /* 
         *  Open this file path node
         */

        LastHandle = FileHandle;
        FileHandle = NULL;

        Status = LastHandle->Open (
                        LastHandle,
                        &FileHandle,
                        FilePathNode->PathName,
                        EFI_FILE_MODE_READ,
                        0
                        );
        
        /* 
         *  Close the last node
         */
        
        LastHandle->Close (LastHandle);

        /* 
         *  Get the next node
         */

        FilePathNode = (FILEPATH_DEVICE_PATH *) NextDevicePathNode(&FilePathNode->Header);
    }

    /* 
     *  If success, return the FHand
     */

    if (!EFI_ERROR(Status)) {
        ASSERT(FileHandle);
        FHand->FileHandle = FileHandle;
        goto Done;
    }

    /* 
     *  Cleanup from filesystem access
     */

    if (FileHandle) {
        FileHandle->Close (FileHandle);
        FileHandle = NULL;
        *FilePath = UserFilePath;
    }

    /* 
     *  If the error is something other then unsupported, return it
     */

    if (Status != EFI_UNSUPPORTED) {
        goto Done;
    }

    /* 
     *  Attempt to access the file via the load file protocol
     */

    Status = LibDevicePathToInterface (&LoadFileProtocol, *FilePath, (VOID*)&LoadFile);
    if (!EFI_ERROR(Status)) {

        /* 
         *  Determine the size of buffer needed to hold the file
         */

        SourceSize = 0;
        Status = LoadFile->LoadFile (
                    LoadFile,
                    *FilePath,
                    BootPolicy,
                    &SourceSize,
                    NULL
                    );

        /* 
         *  We expect a buffer too small error to inform us 
         *  of the buffer size needed
         */

        if (Status == EFI_BUFFER_TOO_SMALL) {
            SourceBuffer = AllocatePool (SourceSize);
            
            if (SourceBuffer) {
                FHand->FreeBuffer = TRUE;
                FHand->Source = SourceBuffer;
                FHand->SourceSize = SourceSize;

                Status = LoadFile->LoadFile (
                            LoadFile,
                            *FilePath,
                            BootPolicy,
                            &SourceSize,
                            SourceBuffer
                            );  
            }
        }

        /* 
         *  If success, return FHand
         */

        if (!EFI_ERROR(Status)) {
            goto Done;
        }
    }

    /* 
     *  Nothing else to try
     */

    DEBUG ((D_LOAD|D_WARN, "OpenSimpleReadFile: Device did not support a known load protocol\n"));
    Status = EFI_UNSUPPORTED;

Done:

    /* 
     *  If the file was not accessed, clean up
     */

    if (EFI_ERROR(Status)) {
        if (FHand) {
            if (FHand->FreeBuffer) {
                FreePool (FHand->Source);
            }

            FreePool (FHand);
        }
    }

    return Status;
}

EFI_STATUS
ReadSimpleReadFile (
    IN SIMPLE_READ_FILE     UserHandle,
    IN UINTN                Offset,
    IN OUT UINTN            *ReadSize,
    OUT VOID                *Buffer
    )
{
    UINTN                   EndPos;
    SIMPLE_READ_HANDLE      *FHand;
    EFI_STATUS              Status;

    FHand = UserHandle;
    ASSERT (FHand->Signature == SIMPLE_READ_SIGNATURE);
    if (FHand->Source) {

        /* 
         *  Move data from our local copy of the file
         */

        EndPos = Offset + *ReadSize;
        if (EndPos > FHand->SourceSize) {
            *ReadSize = FHand->SourceSize - Offset;
            if (Offset >= FHand->SourceSize) {
                *ReadSize = 0;
            }
        }

        CopyMem (Buffer, (CHAR8 *) FHand->Source + Offset, *ReadSize);
        Status = EFI_SUCCESS;

    } else {

        /* 
         *  Read data from the file
         */

        Status = FHand->FileHandle->SetPosition (FHand->FileHandle, Offset);

        if (!EFI_ERROR(Status)) {
            Status = FHand->FileHandle->Read (FHand->FileHandle, ReadSize, Buffer);
        }
    }

    return Status;
}


VOID
CloseSimpleReadFile (
    IN SIMPLE_READ_FILE     UserHandle
    )
{
    SIMPLE_READ_HANDLE      *FHand;

    FHand = UserHandle;
    ASSERT (FHand->Signature == SIMPLE_READ_SIGNATURE);

    /* 
     *  Free any file handle we opened
     */

    if (FHand->FileHandle) {
        FHand->FileHandle->Close (FHand->FileHandle);
    }

    /* 
     *  If we allocated the Source buffer, free it
     */

    if (FHand->FreeBuffer) {
        FreePool (FHand->Source);
    }

    /* 
     *  Done with this simple read file handle
     */

    FreePool (FHand);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\str.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    str.c

Abstract:




Revision History

--*/

#include "lib.h"


INTN
StrCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2
    )
/*  compare strings */
{
    return RtStrCmp(s1, s2);
}

INTN
StrnCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2,
    IN UINTN    len
    )
/*  compare strings */
{
    while (*s1  &&  len) {
        if (*s1 != *s2) {
            break;
        }

        s1  += 1;
        s2  += 1;
        len -= 1;
    }

    return len ? *s1 - *s2 : 0;
}


INTN
LibStubStriCmp (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *s1,
    IN CHAR16                           *s2
    )
{
    return StrCmp (s1, s2);
}

VOID
LibStubStrLwrUpr (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *Str
    )
{
}

INTN
StriCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2
    )
/*  compare strings */
{
    return UnicodeInterface->StriColl(UnicodeInterface, s1, s2);
}

VOID
StrLwr (
    IN CHAR16   *Str
    )
/*  lwoer case string */
{
    UnicodeInterface->StrLwr(UnicodeInterface, Str);
}

VOID
StrUpr (
    IN CHAR16   *Str
    )
/*  upper case string */
{
    UnicodeInterface->StrUpr(UnicodeInterface, Str);
}

VOID
StrCpy (
    IN CHAR16   *Dest,
    IN CHAR16   *Src
    )
/*  copy strings */
{
    RtStrCpy (Dest, Src);
}

VOID
StrCat (
    IN CHAR16   *Dest,
    IN CHAR16   *Src
    )
{   
    RtStrCat(Dest, Src);
}

UINTN
StrLen (
    IN CHAR16   *s1
    )
/*  string length */
{
    return RtStrLen(s1);
}

UINTN
StrSize (
    IN CHAR16   *s1
    )
/*  string size */
{
    return RtStrSize(s1);
}

CHAR16 *
StrDuplicate (
    IN CHAR16   *Src
    )
/*  duplicate a string */
{
    CHAR16      *Dest;
    UINTN       Size;

    Size = StrSize(Src);
    Dest = AllocatePool (Size);
    if (Dest) {
        CopyMem (Dest, Src, Size);
    }
    return Dest;
}

UINTN
strlena (
    IN CHAR8    *s1
    )
/*  string length */
{
    UINTN        len;
    
    for (len=0; *s1; s1+=1, len+=1) ;
    return len;
}

UINTN
strcmpa (
    IN CHAR8    *s1,
    IN CHAR8    *s2
    )
/*  compare strings */
{
    while (*s1) {
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
        s2 += 1;
    }

    return *s1 - *s2;
}

UINTN
strncmpa (
    IN CHAR8    *s1,
    IN CHAR8    *s2,
    IN UINTN    len
    )
/*  compare strings */
{
    while (*s1  &&  len) {
        if (*s1 != *s2) {
            break;
        }

        s1  += 1;
        s2  += 1;
        len -= 1;
    }

    return len ? *s1 - *s2 : 0;
}



UINTN
xtoi (
    CHAR16  *str
    )
/*  convert hex string to uint */
{
    UINTN       u;
    CHAR16      c;

    /*  skip preceeding white space */
    while (*str && *str == ' ') {
        str += 1;
    }

    /*  convert hex digits */
    u = 0;
    while (c = *(str++)) {
        if (c >= 'a'  &&  c <= 'f') {
            c -= 'a' - 'A';
        }

        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F')) {
            u = u << 4  |  c - (c >= 'A' ? 'A'-10 : '0');
        } else {
            break;
        }
    }

    return u;
}

UINTN
Atoi (
    CHAR16  *str
    )
/*  convert hex string to uint */
{
    UINTN       u;
    CHAR16      c;

    /*  skip preceeding white space */
    while (*str && *str == ' ') {
        str += 1;
    }

    /*  convert digits */
    u = 0;
    while (c = *(str++)) {
        if (c >= '0' && c <= '9') {
            u = (u * 10) + c - '0';
        } else {
            break;
        }
    }

    return u;
}

BOOLEAN 
MetaMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    )
{
    CHAR16  c, p, l;

    for (; ;) {
        p = *Pattern;
        Pattern += 1;

        switch (p) {
        case 0:    
            /*  End of pattern.  If end of string, TRUE match */
            return *String ? FALSE : TRUE;     

        case '*':                               
            /*  Match zero or more chars */
            while (*String) {
                if (MetaMatch (String, Pattern)) {
                    return TRUE;
                }
                String += 1;
            }
            return MetaMatch (String, Pattern);

        case '?':                               
            /*  Match any one char */
            if (!*String) {
                return FALSE;
            }
            String += 1;
            break;

        case '[':                               
            /*  Match char set */
            c = *String;
            if (!c) {
                return FALSE;                       /*  syntax problem */
            }

            l = 0;
            while ( p = *Pattern++ ) {
                if (p == ']') {
                    return FALSE;
                }

                if (p == '-') {                     /*  if range of chars, */
                    p = *Pattern;                   /*  get high range */
                    if (p == 0 || p == ']') {
                        return FALSE;               /*  syntax problem */
                    }

                    if (c >= l && c <= p) {         /*  if in range,  */
                        break;                      /*  it's a match */
                    }
                }
                
                l = p;
                if (c == p) {                       /*  if char matches */
                    break;                          /*  move on */
                }
            }
            
            /*  skip to end of match char set */
            while (p && p != ']') {
                p = *Pattern;
                Pattern += 1;
            }

            String += 1;
            break;

        default:
            c = *String;
            if (c != p) {
                return FALSE;
            }

            String += 1;
            break;
        }
    }
}


BOOLEAN
LibStubMetaiMatch (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *String,
    IN CHAR16                           *Pattern
    )
{
    return MetaMatch (String, Pattern);
}


BOOLEAN 
MetaiMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    )
{
    return UnicodeInterface->MetaiMatch(UnicodeInterface, String, Pattern);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia32\initplat.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    initplat.c

Abstract:




Revision History

--*/

#include "lib.h"

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia64\math.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    math.c

Abstract:




Revision History

--*/

#include "lib.h"


/* 
 *  Declare runtime functions
 */

#ifdef RUNTIME_CODE
#pragma RUNTIME_CODE(LShiftU64)
#pragma RUNTIME_CODE(RShiftU64)
#pragma RUNTIME_CODE(MultU64x32)
#pragma RUNTIME_CODE(DivU64x32)
#endif

/* 
 * 
 */




UINT64
LShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
/*  Left shift 64bit by 32bit and get a 64bit result */
{
    return Operand << Count;
}

UINT64
RShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
/*  Right shift 64bit by 32bit and get a 64bit result */
{
    return Operand >> Count;
}


UINT64
MultU64x32 (
    IN UINT64   Multiplicand,
    IN UINTN    Multiplier
    )
/*  Multiple 64bit by 32bit and get a 64bit result */
{
    return Multiplicand * Multiplier;
}

UINT64
DivU64x32 (
    IN UINT64   Dividend,
    IN UINTN    Divisor,
    OUT UINTN   *Remainder OPTIONAL
    )
/*  divide 64bit by 32bit and get a 64bit result
 *  N.B. only works for 31bit divisors!! */
{
    ASSERT (Divisor != 0);

    if (Remainder) {
        *Remainder = Dividend % Divisor;
    }

    return Dividend / Divisor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia64\palproc.s ===
//++
//      Copyright (c) 1996-99 Intel Corp.            
//        All Rights Reserved   
//
//      INTEL CORPORATION PROPRIETARY INFORMATION
//
//      This software is supplied under the terms of a license
//      agreement or nondisclosure agreement with Intel Corpo-
//      ration and may not be copied or disclosed except in
//      accordance with the terms of that agreement.
//
//
//
// Module Name:
//
//  palproc.s
//
// Abstract:
//
//  Contains an implementation for making PAL PROC calls on
//  IA-64 architecture.
//
//
//
// Revision History:
//
//--

	.file	"palproc.s"

#include <palproc.h>


//-----------------------------------------------------------------------------
//++
// MakeStaticPALCall
//
// This routine is called whenever an architected static calling convention
// based PAL call is to be made. This call does use RSE actually, but our policy
// in making static PAL calls before memory is available is to make sure that 
// we do not nest too deep and allocate beyond 96 banked registers. In other
// words we carefully code calls and control flow before memory is available.
//
// Arguments : All parameters set up to do static PAL call.
//
// On Entry :
//
// Return Value: 
// 
// As per static calling conventions. 
// 
//--
//---------------------------------------------------------------------------
PROCEDURE_ENTRY(MakeStaticPALCall)

        NESTED_SETUP (5,8,0,0)
        mov         loc3 = b5
        mov         loc4 = r2
        mov         loc7 = r1;;
        
        movl        loc6 = PAL_MC_CLEAR_LOG
        mov         r2 = psr;;
        mov         loc5 = r2

        cmp.eq      p6,p7 = r28,loc6;;
    (p7)movl        loc6 = PAL_MC_DYNAMIC_STATE;;
    (p7)cmp.eq      p6,p7 = r28,loc6;;        
        
    (p7)movl        loc6 = PAL_MC_ERROR_INFO;;
    (p7)cmp.eq      p6,p7 = r28,loc6;;        
         
    (p7)movl        loc6 = PAL_MC_RESUME;;
    (p7)cmp.eq      p6,p7 = r28,loc6        

        mov         loc6 = 0x1;;
    (p7)dep         r2 = loc6,r2,13,1;;         // psr.ic = 1

// p6 will be true, if it is one of the MCHK calls. There has been lots of debate
// on psr.ic for these values. For now, do not do any thing to psr.ic

//    (p6)dep         r2 = r0,r2,13,1;;         // psr.ic = 0
        dep         r2 = r0,r2,14,1;;           // psr.i = 0

        mov         psr.l = r2
        srlz.d;;                                // Needs data serailization.
        srlz.i;;                                // Needs instruction serailization.

StaticGetPALLocalIP:
        mov         loc2 = ip;;
        add         loc2 = StaticComeBackFromPALCall - StaticGetPALLocalIP,loc2;;
        mov         b0 = loc2                   // return address after Pal call
        mov         r28 = in1                   // get the input parameters to PAL call
        mov         r29 = in2
        mov         r30 = in3;;
        mov         r31 = in4
        mov         b5 =  in0;;                 // get the PalProcEntrypt from input
        br.sptk     b5                          // Take the plunge.

StaticComeBackFromPALCall::

        mov         psr.l = loc5;;
        srlz.d;;                                // Needs data serailization.
        srlz.i;;                                // Needs instruction serailization.

        mov         b5 = loc3
        mov         r2 = loc4
        mov         r1 = loc7
        
        NESTED_RETURN

PROCEDURE_EXIT(MakeStaticPALCall)


//-----------------------------------------------------------------------------
//++
// MakeStackedPALCall
//
// This routine is called whenever an architected stacked calling convention
// based PAL call is to be made. This call is made after memory is available.
// Although stacked calls could be made directly from 'C', there is a PAL 
// requirement which forces the index to be in GR28 and hence this stub is
// needed
//
// Arguments : All parameters set up to do stacted PAL call.
//
// On Entry :
//          in0:  PAL_PROC entrypoint 
//          in1-in4 : PAL_PROC arguments
//
// Return Value: 
// 
// As per stacked calling conventions. 
// 
//--
//---------------------------------------------------------------------------
PROCEDURE_ENTRY(MakeStackedPALCall)

        NESTED_SETUP (5,8,4,0)
        mov         loc3 = b5
        mov         loc4 = r2
        mov         loc7 = r1    
        mov         r2 = psr;;
        mov         loc5 = r2;;
        dep         r2 = r0,r2,14,1;;           // psr.i = 0
        mov         psr.l = r2
        srlz.d;;                                // Needs data serailization.
        srlz.i;;                                // Needs instruction serailization.

StackedGetPALLocalIP:
        mov         r28 = in1                   // get the input parameters to PAL call
        mov         out0 = in1
        mov         out1 = in2;;
        mov         out2 = in3
        mov         out3 = in4
        mov         b5 =  in0;;                 // get the PalProcEntrypt from input
        br.call.dpnt b0=b5;;                    // Take the plunge.

StackedComeBackFromPALCall::

        mov         psr.l = loc5;;
        srlz.d;;                                // Needs data serailization.
        srlz.i;;                                // Needs instruction serailization.
        mov         b5 = loc3
        mov         r2 = loc4
        mov         r1 = loc7
        
        NESTED_RETURN

PROCEDURE_EXIT(MakeStackedPALCall)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia32\math.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    math.c

Abstract:




Revision History

--*/

#include "lib.h"


/* 
 *  Declare runtime functions
 */

#ifdef RUNTIME_CODE
#pragma RUNTIME_CODE(LShiftU64)
#pragma RUNTIME_CODE(RShiftU64)
#pragma RUNTIME_CODE(MultU64x32)
#pragma RUNTIME_CODE(DivU64x32)
#endif

/* 
 * 
 */

UINT64
LShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
/*  Left shift 64bit by 32bit and get a 64bit result */
{
    UINT64      Result;

    _asm {
        mov     eax, dword ptr Operand[0]
        mov     edx, dword ptr Operand[4]
        mov     ecx, Count
        and     ecx, 63

        shld    edx, eax, cl
        shl     eax, cl

        cmp     ecx, 32
        jc      short ls10

        mov     edx, eax
        xor     eax, eax

ls10:
        mov     dword ptr Result[0], eax
        mov     dword ptr Result[4], edx
    }

    return Result;
}

UINT64
RShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
/*  Right shift 64bit by 32bit and get a 64bit result */
{
    UINT64      Result;

    _asm {
        mov     eax, dword ptr Operand[0]
        mov     edx, dword ptr Operand[4]
        mov     ecx, Count
        and     ecx, 63

        shrd    eax, edx, cl
        shr     edx, cl

        cmp     ecx, 32
        jc      short rs10

        mov     eax, edx
        xor     edx, edx

rs10:
        mov     dword ptr Result[0], eax
        mov     dword ptr Result[4], edx
    }

    return Result;
}


UINT64
MultU64x32 (
    IN UINT64   Multiplicand,
    IN UINTN    Multiplier
    )
/*  Multiple 64bit by 32bit and get a 64bit result */
{
    UINT64      Result;

    _asm {
        mov     eax, dword ptr Multiplicand[0]
        mul     Multiplier
        mov     dword ptr Result[0], eax
        mov     dword ptr Result[4], edx
        mov     eax, dword ptr Multiplicand[4]
        mul     Multiplier
        add     dword ptr Result[4], eax
    }

    return Result;
}

UINT64
DivU64x32 (
    IN UINT64   Dividend,
    IN UINTN    Divisor,
    OUT UINTN   *Remainder OPTIONAL
    )
/*  divide 64bit by 32bit and get a 64bit result
 *  N.B. only works for 31bit divisors!! */
{
    UINT32      Rem;
    UINT32      bit;        

    ASSERT (Divisor != 0);
    ASSERT ((Divisor >> 31) == 0);

    /* 
     *  For each bit in the dividend
     */

    Rem = 0;
    for (bit=0; bit < 64; bit++) {
        _asm {
            shl     dword ptr Dividend[0], 1    ; shift rem:dividend left one
            rcl     dword ptr Dividend[4], 1    
            rcl     dword ptr Rem, 1            

            mov     eax, Rem
            cmp     eax, Divisor                ; Is Rem >= Divisor?
            cmc                                 ; No - do nothing
            sbb     eax, eax                    ; Else, 
            sub     dword ptr Dividend[0], eax  ;   set low bit in dividen
            and     eax, Divisor                ; and
            sub     Rem, eax                    ;   subtract divisor 
        }
    }

    if (Remainder) {
        *Remainder = Rem;
    }

    return Dividend;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia64\initplat.c ===
/*++

Copyright (c) 1999  Intel Corporation
    
Module Name:

    initplat.c

Abstract:

    Functions to make SAL and PAL proc calls

Revision History

--*/
#include "lib.h"

/* #include "palproc.h" */

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )

{
    PLABEL  SalPlabel;
    UINT64  PalEntry;

    LibInitSalAndPalProc (&SalPlabel, &PalEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia64\salpal.c ===
/*++

Copyright (c) 1999  Intel Corporation
    
Module Name:

    salpal.c

Abstract:

    Functions to make SAL and PAL proc calls

Revision History

--*/
#include "lib.h"
#include "palproc.h"
#include "SalProc.h"

rArg
MakeStaticPALCall (
    IN UINT64   PALPROCPtr,
    IN UINT64   Arg1,
    IN UINT64   Arg2,
    IN UINT64   Arg3,
    IN UINT64   Arg4
    );

rArg
MakeStackedPALCall (
    IN UINT64   PALPROCPtr,
    IN UINT64   Arg1,
    IN UINT64   Arg2,
    IN UINT64   Arg3,
    IN UINT64   Arg4
    );


PLABEL   SalProcPlabel;
PLABEL   PalProcPlabel;
CALL_SAL_PROC   GlobalSalProc;
CALL_PAL_PROC   GlobalPalProc;

VOID
LibInitSalAndPalProc (
    OUT PLABEL  *SalPlabel,
    OUT UINT64  *PalEntry
    )
{
    SAL_SYSTEM_TABLE_ASCENDING_ORDER    *SalSystemTable;
    EFI_STATUS                          Status;

    GlobalSalProc = NULL;
    GlobalPalProc = NULL;

    Status = LibGetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        return; 
    }

    /* 
     *  BugBug: Add code to test checksum on the Sal System Table
     */
    if (SalSystemTable->Entry0.Type != 0) {
        return;
    }

    SalProcPlabel.ProcEntryPoint = SalSystemTable->Entry0.SalProcEntry; 
    SalProcPlabel.GP             = SalSystemTable->Entry0.GlobalDataPointer;
    GlobalSalProc                = (CALL_SAL_PROC)&SalProcPlabel.ProcEntryPoint;

    /* 
     *  Need to check the PAL spec to make sure I'm not responsible for
     *   storing more state.
     *  We are passing in a Plabel that should be ignorred by the PAL. Call
     *   this way will cause use to retore our gp after the PAL returns.
     */
    PalProcPlabel.ProcEntryPoint = SalSystemTable->Entry0.PalProcEntry; 
    PalProcPlabel.GP             = SalSystemTable->Entry0.GlobalDataPointer;
    GlobalPalProc                = (CALL_PAL_PROC)PalProcPlabel.ProcEntryPoint;

    *PalEntry = PalProcPlabel.ProcEntryPoint;
    *SalPlabel = SalProcPlabel;
}

EFI_STATUS
LibGetSalIoPortMapping (
    OUT UINT64  *IoPortMapping
    )
/*++

  Get the IO Port Map from the SAL System Table.
  DO NOT USE THIS TO DO YOU OWN IO's!!!!!!!!!!!!
  Only use this for getting info, or initing the built in EFI IO abstraction.
  Always use the EFI Device IO protoocl to access IO space.
  
--*/
{
    SAL_SYSTEM_TABLE_ASCENDING_ORDER    *SalSystemTable;
    SAL_ST_MEMORY_DESCRIPTOR_ENTRY      *SalMemDesc;
    EFI_STATUS                          Status;

    Status = LibGetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        return EFI_UNSUPPORTED; 
    }

    /* 
     *  BugBug: Add code to test checksum on the Sal System Table
     */
    if (SalSystemTable->Entry0.Type != 0) {
        return EFI_UNSUPPORTED;
    }

    /* 
     *  The SalSystemTable pointer includes the Type 0 entry.
     *   The SalMemDesc is Type 1 so it comes next.
     */
    SalMemDesc = (SAL_ST_MEMORY_DESCRIPTOR_ENTRY *)(SalSystemTable + 1);
    while (SalMemDesc->Type == SAL_ST_MEMORY_DESCRIPTOR) {
        if (SalMemDesc->MemoryType == SAL_IO_PORT_MAPPING) {
            *IoPortMapping = SalMemDesc->PhysicalMemoryAddress;
            return EFI_SUCCESS;
        }
        SalMemDesc++;
    }
    return EFI_UNSUPPORTED;
}

EFI_STATUS
LibGetSalIpiBlock (
    OUT UINT64  *IpiBlock
    )
/*++

  Get the IPI block from the SAL system table
  
--*/
{
    SAL_SYSTEM_TABLE_ASCENDING_ORDER    *SalSystemTable;
    SAL_ST_MEMORY_DESCRIPTOR_ENTRY      *SalMemDesc;
    EFI_STATUS                          Status;

    Status = LibGetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        return EFI_UNSUPPORTED; 
    }

    /* 
     *  BugBug: Add code to test checksum on the Sal System Table
     */
    if (SalSystemTable->Entry0.Type != 0) {
        return EFI_UNSUPPORTED;
    }

    /* 
     *  The SalSystemTable pointer includes the Type 0 entry.
     *   The SalMemDesc is Type 1 so it comes next.
     */
    SalMemDesc = (SAL_ST_MEMORY_DESCRIPTOR_ENTRY *)(SalSystemTable + 1);
    while (SalMemDesc->Type == SAL_ST_MEMORY_DESCRIPTOR) {
        if (SalMemDesc->MemoryType == SAL_SAPIC_IPI_BLOCK ) {
            *IpiBlock = SalMemDesc->PhysicalMemoryAddress;
            return EFI_SUCCESS;
        }
        SalMemDesc++;
    }
    return EFI_UNSUPPORTED;
}

EFI_STATUS
LibGetSalWakeupVector (
    OUT UINT64  *WakeVector
    )
/*++

Get the wakeup vector from the SAL system table
  
--*/
{
    SAL_ST_AP_WAKEUP_DECRIPTOR      *ApWakeUp;

    ApWakeUp = LibSearchSalSystemTable (SAL_ST_AP_WAKEUP);
    if (!ApWakeUp) {
        *WakeVector = -1;
        return EFI_UNSUPPORTED;
    }
    *WakeVector = ApWakeUp->ExternalInterruptVector;
    return EFI_SUCCESS;
}

VOID *
LibSearchSalSystemTable (
    IN  UINT8   EntryType  
    )
{
    EFI_STATUS                          Status;
    UINT8                               *SalTableHack;
    SAL_SYSTEM_TABLE_ASCENDING_ORDER    *SalSystemTable;
    UINT16                              EntryCount;
    UINT16                              Count;

    Status = LibGetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        return NULL; 
    }

    EntryCount = SalSystemTable->Header.EntryCount;
    if (EntryCount == 0) {
        return NULL;
    }
    /* 
     *  BugBug: Add code to test checksum on the Sal System Table
     */

    SalTableHack = (UINT8 *)&SalSystemTable->Entry0;
    for (Count = 0; Count < EntryCount ;Count++) {
        if (*SalTableHack == EntryType) {
            return (VOID *)SalTableHack;
        }
        switch (*SalTableHack) {
        case SAL_ST_ENTRY_POINT:
            SalTableHack += 48;
            break;
        case SAL_ST_MEMORY_DESCRIPTOR:
            SalTableHack += 32;
            break;
        case SAL_ST_PLATFORM_FEATURES:
            SalTableHack += 16;
            break;
        case SAL_ST_TR_USAGE:
            SalTableHack += 32;
            break;
        case SAL_ST_PTC:
            SalTableHack += 16;
            break;
        case SAL_ST_AP_WAKEUP:
            SalTableHack += 16;
            break;
        default:
            ASSERT(FALSE);
            break;
        }
    }
    return NULL;
}


VOID
LibSalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    )
{
    rArg    ReturnValue;

    ReturnValue.p0 = -3;    /*  SAL status return completed with error  */
    if (GlobalSalProc) {
        ReturnValue = GlobalSalProc(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
    }

    if (Results) {
        CopyMem (Results, &ReturnValue, sizeof(rArg));
    }
}

VOID
LibPalProc (
    IN  UINT64    Arg1, /*  Pal Proc index */
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    OUT rArg      *Results  OPTIONAL
    )
{
    
    rArg    ReturnValue;

    ReturnValue.p0 = -3;    /*  PAL status return completed with error  */

    /* 
     *  check for valid PalProc entry point
     */
    
    if (!GlobalPalProc) {
        if (Results) 
            CopyMem (Results, &ReturnValue, sizeof(rArg));
        return;
    }
        
    /* 
     *  check if index falls within stacked or static register calling conventions
     *  and call appropriate Pal stub call
     */

    if (((Arg1 >=255) && (Arg1 <=511)) ||
        ((Arg1 >=768) && (Arg1 <=1023))) {    
            ReturnValue = MakeStackedPALCall((UINT64)GlobalPalProc,Arg1,Arg2,Arg3,Arg4);
    }
    else {
        ReturnValue = MakeStaticPALCall((UINT64)GlobalPalProc,Arg1,Arg2,Arg3,Arg4);
    }
          
    if (Results) 
        CopyMem (Results, &ReturnValue, sizeof(rArg));
        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\ia64\palproc.h ===
// 
// 
//       Copyright (c) 1996-99 Intel Corp.            
//         All Rights Reserved   
// 
//       INTEL CORPORATION PROPRIETARY INFORMATION
// 
//       This software is supplied under the terms of a license
//       agreement or nondisclosure agreement with Intel Corpo-
//       ration and may not be copied or disclosed except in
//       accordance with the terms of that agreement.
// 
// 
// 
//Module Name:
// 
//   palproc.h
// 
//Abstract:
// 
//   This module contains generic macros for an IA64 assembly writer.
// 
// 
//Revision History
// 
 
#ifndef _PALPROC_H
#define _PALPROC_H

#define PROCEDURE_ENTRY(name)   .##text;            \
                .##type name, @function;    \
                .##proc name;           \
name::

#define PROCEDURE_EXIT(name)    .##endp name

// Note: use of NESTED_SETUP requires number of locals (l) >= 3

#define NESTED_SETUP(i,l,o,r) \
         alloc loc1=ar##.##pfs,i,l,o,r ;\
         mov loc0=b0

#define NESTED_RETURN \
         mov b0=loc0 ;\
         mov ar##.##pfs=loc1 ;;\
         br##.##ret##.##dpnt  b0;;


// defines needed in palproc.s

#define PAL_MC_CLEAR_LOG                                0x0015
#define PAL_MC_DRAIN                                    0x0016
#define PAL_MC_EXPECTED                                 0x0017
#define PAL_MC_DYNAMIC_STATE                            0x0018
#define PAL_MC_ERROR_INFO                               0x0019
#define PAL_MC_RESUME                                   0x001a
#define PAL_MC_REGISTER_MEM                             0x001b

#endif  // _PALPROC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\runtime\lock.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    lock.c

Abstract:

    Implements FLOCK



Revision History

--*/


#include "lib.h"



#pragma RUNTIME_CODE(RtAcquireLock)
VOID
RtAcquireLock (
    IN FLOCK    *Lock
    )
/*++

Routine Description:

    Raising to the task priority level of the mutual exclusion
    lock, and then acquires ownership of the lock.
    
Arguments:

    Lock        - The lock to acquire
    
Returns:

    Lock owned

--*/
{
    if (BS) {
        if (BS->RaiseTPL != NULL) {
            Lock->OwnerTpl = BS->RaiseTPL(Lock->Tpl);
        } 
    }
    else {
        if (LibRuntimeRaiseTPL != NULL) {
            Lock->OwnerTpl = LibRuntimeRaiseTPL(Lock->Tpl);
        }
    }
    Lock->Lock += 1;
    ASSERT (Lock->Lock == 1);
}


#pragma RUNTIME_CODE(RtAcquireLock)
VOID
RtReleaseLock (
    IN FLOCK    *Lock
    )
/*++

Routine Description:

    Releases ownership of the mutual exclusion lock, and
    restores the previous task priority level.
    
Arguments:

    Lock        - The lock to release
    
Returns:

    Lock unowned

--*/
{
    EFI_TPL     Tpl;

    Tpl = Lock->OwnerTpl;
    ASSERT(Lock->Lock == 1);
    Lock->Lock -= 1;
    if (BS) {
        if (BS->RestoreTPL != NULL) {
            BS->RestoreTPL (Tpl);
        } 
    }
    else {
        if (LibRuntimeRestoreTPL != NULL) {
            LibRuntimeRestoreTPL(Tpl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\runtime\rtdata.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    data.c

Abstract:

    EFI library global data



Revision History

--*/

#include "lib.h"


/* 
 *  These globals are runtime globals
 * 
 *  N.B. The Microsoft C compiler will only put the data in the
 *  right data section if it is explicitly initialized..
 */

#pragma BEGIN_RUNTIME_DATA()

/* 
 *  RT - pointer to the runtime table
 */

EFI_RUNTIME_SERVICES    *RT;

/* 
 *  LibStandalone - TRUE if lib is linked in as part of the firmware.
 *  N.B. The EFI fw sets this value directly
 */

BOOLEAN  LibFwInstance;

/* 
 *  EFIDebug - Debug mask
 */

UINTN    EFIDebug    = EFI_DBUG_MASK;

/* 
 *  LibRuntimeDebugOut - Runtime Debug Output device
 */

SIMPLE_TEXT_OUTPUT_INTERFACE    *LibRuntimeDebugOut;

/* 
 *  LibRuntimeRaiseTPL, LibRuntimeRestoreTPL - pointers to Runtime functions from the 
 *                                             Boot Services Table
 */

EFI_RAISE_TPL   LibRuntimeRaiseTPL   = NULL;
EFI_RESTORE_TPL LibRuntimeRestoreTPL = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\runtime\efirtlib.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    EfiRtLib.h

Abstract:

    EFI Runtime library functions



Revision History

--*/

#include "efi.h"
#include "efilib.h"
#include "EfiRtLib.h"

#pragma RUNTIME_CODE(RtZeroMem)
VOID
RUNTIMEFUNCTION
RtZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    )
{
    INT8        *pt;

    pt = Buffer;
    while (Size--) {
        *(pt++) = 0;
    }
}

#pragma RUNTIME_CODE(RtSetMem)
VOID
RUNTIMEFUNCTION
RtSetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value    
    )
{
    INT8        *pt;

    pt = Buffer;
    while (Size--) {
        *(pt++) = Value;
    }
}

#pragma RUNTIME_CODE(RtCopyMem)
VOID
RUNTIMEFUNCTION
RtCopyMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    )
{
    CHAR8    *d, *s;

    d = Dest;
    s = Src;
    while (len--) {
        *(d++) = *(s++);
    }
}

#pragma RUNTIME_CODE(RtCompareMem)
INTN
RUNTIMEFUNCTION
RtCompareMem (
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    )
{
    CHAR8    *d, *s;

    d = Dest;
    s = Src;
    while (len--) {
        if (*d != *s) {
            return *d - *s;
        }

        d += 1;
        s += 1;
    }

    return 0;
}

#pragma RUNTIME_CODE(RtCompareGuid)
INTN
RUNTIMEFUNCTION
RtCompareGuid (
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    )
/*++

Routine Description:

    Compares to GUIDs

Arguments:

    Guid1       - guid to compare
    Guid2       - guid to compare

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    INT32       *g1, *g2, r;

    /* 
     *  Compare 32 bits at a time
     */

    g1 = (INT32 *) Guid1;
    g2 = (INT32 *) Guid2;

    r  = g1[0] - g2[0];
    r |= g1[1] - g2[1];
    r |= g1[2] - g2[2];
    r |= g1[3] - g2[3];

    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\runtime\vm.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    vm.c

Abstract:

    Very hard to remap runtime address into the new virual address space 
    that was registered by the OS for RT calls.

    So the code image needs to be relocated. All pointers need to be 
    manually fixed up since the address map changes. 

    GOOD LUCK NOT HAVING BUGS IN YOUR CODE! PLEASE TEST A LOT. MAKE SURE
    EXIT BOOTSERVICES OVER WRITES ALL BOOTSERVICE MEMORY & DATA SPACES WHEN 
    YOU TEST.

Revision History

--*/

#include "lib.h"

#pragma RUNTIME_CODE(RtLibEnableVirtualMappings)
VOID
RUNTIMEFUNCTION
RtLibEnableVirtualMappings (
    VOID
    )
{
    EFI_CONVERT_POINTER     ConvertPointer;

    /* 
     *  If this copy of the lib is linked into the firmware, then
     *  do not update the pointers yet.
     */

    if (!LibFwInstance) {

        /* 
         *  Different components are updating to the new virtual
         *  mappings at differnt times.  The only function that
         *  is safe to call at this notification is ConvertAddress
         */

        ConvertPointer = RT->ConvertPointer;

        /* 
         *  Fix any pointers that the lib created, that may be needed
         *  during runtime.
         */

        ConvertPointer (EFI_INTERNAL_PTR, (VOID **)&RT);
        ConvertPointer (EFI_OPTIONAL_PTR, (VOID **)&LibRuntimeDebugOut);

        ConvertPointer (EFI_INTERNAL_PTR, (VOID **)&LibRuntimeRaiseTPL);
        ConvertPointer (EFI_INTERNAL_PTR, (VOID **)&LibRuntimeRestoreTPL);

        /*  that was it :^) */
    }
}


#pragma RUNTIME_CODE(RtConvertList)
VOID
RUNTIMEFUNCTION
RtConvertList (
    IN UINTN                DebugDisposition,
    IN OUT LIST_ENTRY       *ListHead
    )
{
    LIST_ENTRY              *Link;
    LIST_ENTRY              *NextLink;
    EFI_CONVERT_POINTER     ConvertPointer;

    ConvertPointer = RT->ConvertPointer;

    /* 
     *  Convert all the Flink & Blink pointers in the list
     */

    Link = ListHead;
    do {
        NextLink = Link->Flink;

        ConvertPointer (
            Link->Flink == ListHead ? DebugDisposition : 0, 
            (VOID **)&Link->Flink
            );

        ConvertPointer (
            Link->Blink == ListHead ? DebugDisposition : 0, 
            (VOID **)&Link->Blink
            );

        Link = NextLink;
    } while (Link != ListHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\lib\runtime\str.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    str.c

Abstract:

    String runtime functions


Revision History

--*/

#include "lib.h"

#pragma RUNTIME_CODE(RtAcquireLock)
INTN
RUNTIMEFUNCTION
RtStrCmp (
    IN CHAR16   *s1,
    IN CHAR16   *s2
    )
/*  compare strings */
{
    while (*s1) {
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
        s2 += 1;
    }

    return *s1 - *s2;
}

#pragma RUNTIME_CODE(RtStrCpy)
VOID
RUNTIMEFUNCTION
RtStrCpy (
    IN CHAR16   *Dest,
    IN CHAR16   *Src
    )
/*  copy strings */
{
    while (*Src) {
        *(Dest++) = *(Src++);
    }
    *Dest = 0;
}

#pragma RUNTIME_CODE(RtStrCat)
VOID
RUNTIMEFUNCTION
RtStrCat (
    IN CHAR16   *Dest,
    IN CHAR16   *Src
    )
{   
    RtStrCpy(Dest+StrLen(Dest), Src);
}

#pragma RUNTIME_CODE(RtStrLen)
UINTN
RUNTIMEFUNCTION
RtStrLen (
    IN CHAR16   *s1
    )
/*  string length */
{
    UINTN        len;
    
    for (len=0; *s1; s1+=1, len+=1) ;
    return len;
}

#pragma RUNTIME_CODE(RtStrSize)
UINTN
RUNTIMEFUNCTION
RtStrSize (
    IN CHAR16   *s1
    )
/*  string size */
{
    UINTN        len;
    
    for (len=0; *s1; s1+=1, len+=1) ;
    return (len + 1) * sizeof(CHAR16);
}

#pragma RUNTIME_CODE(RtBCDtoDecimal)
UINT8
RUNTIMEFUNCTION
RtBCDtoDecimal(
    IN  UINT8 BcdValue
    )
{
    UINTN   High, Low;

    High    = BcdValue >> 4;
    Low     = BcdValue - (High << 4);

    return ((UINT8)(Low + (High * 10)));
}


#pragma RUNTIME_CODE(RtDecimaltoBCD)
UINT8
RUNTIMEFUNCTION
RtDecimaltoBCD (
    IN  UINT8 DecValue
    )
{
    UINTN   High, Low;

    High    = DecValue / 10;
    Low     = DecValue - (High * 10);

    return ((UINT8)(Low + (High << 4)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\notes\samples\apps\hello\hello.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    hello.c
    
Abstract:


Author:

Revision History

--*/

#include "efi.h"

EFI_STATUS
InitializeHelloApplication (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    UINTN Index;

    /* 
     *  Send a message to the ConsoleOut device.
     */

    SystemTable->ConOut->OutputString(SystemTable->ConOut,
                                      L"Hello application started\n\r");

    /* 
     *  Wait for the user to press a key.
     */

    SystemTable->ConOut->OutputString(SystemTable->ConOut,
                                      L"\n\r\n\r\n\rHit any key to exit this image\n\r");

    SystemTable->BootServices->WaitForEvent (1, &(SystemTable->ConIn->WaitForKey), &Index);

    SystemTable->ConOut->OutputString(SystemTable->ConOut,L"\n\r\n\r");

    /* 
     *  Exit the application.
     */

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\attrib\attrib.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    attrib.c
    
Abstract:

    Shell app "attrib"

Revision History

--*/

#include "shell.h"

/* 
 * 
 */

EFI_STATUS
InitializeAttrib (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_STATUS
AttribSet (
    IN CHAR16       *Str,
    IN OUT UINT64   *Attr
    );

VOID
AttribFile (
    IN SHELL_FILE_ARG       *Arg,
    IN UINT64               Remove,
    IN UINT64               Add

    );

BOOLEAN PageBreaks;
UINTN   TempColumn;
UINTN   ScreenCount;
UINTN   ScreenSize;

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeAttrib)

EFI_STATUS
InitializeAttrib (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;
    UINT64                  Remove, Add;
    EFI_STATUS              Status;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeAttrib,
        L"attrib",                      /*  command */
        L"attrib [-b] [+/- rhs] [file]", /*  command syntax */
        L"View/sets file attributes",   /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;
    InitializeListHead (&FileList);
    Remove = 0;
    Add = 0;

    /* 
     *  Expand each arg
     */

    for (Index = 1; Index < Argc; Index += 1) {
        if (Argv[Index][0] == '-') {
            /*  remove these attributes */
            Status = AttribSet (Argv[Index]+1, &Remove);
        } else if (Argv[Index][0] == '+') {
            /*  add these attributes */
            Status = AttribSet (Argv[Index]+1, &Add);
        } else {
            ShellFileMetaArg (Argv[Index], &FileList);
        }

        if (EFI_ERROR(Status)) {
            goto Done;
        }
    }

    /*  if no file specified, get the whole directory */
    if (IsListEmpty(&FileList)) {
        ShellFileMetaArg (L"*", &FileList);
    }

    /* 
     *  Attrib each file
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        AttribFile (Arg, Remove, Add);
    }

Done:
    ShellFreeFileList (&FileList);
    return EFI_SUCCESS;
}

EFI_STATUS
AttribSet (
    IN CHAR16       *Str,
    IN OUT UINT64   *Attr
    )
{
    while (*Str) {
        switch (*Str) {
        case 'b' :
        case 'B' :
            PageBreaks = TRUE;
            ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
            ScreenCount = 0;
            break;
        case 'a':
        case 'A':
            *Attr |= EFI_FILE_ARCHIVE;
            break;
        case 's':
        case 'S':
            *Attr |= EFI_FILE_SYSTEM;
            break;
        case 'h':
        case 'H':
            *Attr |= EFI_FILE_HIDDEN;
            break;
        case 'r':
        case 'R':
            *Attr |= EFI_FILE_READ_ONLY;
            break;
        default:
            Print (L"attr: unknown file attribute %hc\n", *Attr);
            return EFI_INVALID_PARAMETER;
        }
        Str += 1;
    }

    return EFI_SUCCESS;
}


VOID
AttribFile (
    IN SHELL_FILE_ARG           *Arg,
    IN UINT64                   Remove,
    IN UINT64                   Add
    )
{
    UINT64                      Attr;
    EFI_STATUS                  Status;
    EFI_FILE_INFO               *Info;
    CHAR16                      ReturnStr[1];

    Status = Arg->Status;
    if (EFI_ERROR(Status)) {
        goto Done;
    }

    Info = Arg->Info;

    if (Add || Remove) {
        Info->Attribute = Info->Attribute & (~Remove) | Add;
        Status = Arg->Handle->SetInfo(  
                    Arg->Handle,
                    &GenericFileInfo,
                    (UINTN) Info->Size,
                    Info
                    );
    }

Done:
    if (EFI_ERROR(Status)) {
        Print (L"       %s : %hr\n", Arg->FullName, Status);
    } else {
        Attr = Info->Attribute;
        Print (L"%c%c %c%c%c %s\n",
            Attr & EFI_FILE_DIRECTORY ? 'D' : ' ',
            Attr & EFI_FILE_ARCHIVE   ? 'A' : ' ',
            Attr & EFI_FILE_SYSTEM    ? 'S' : ' ',
            Attr & EFI_FILE_HIDDEN    ? 'H' : ' ',
            Attr & EFI_FILE_READ_ONLY ? 'R' : ' ',
            Arg->FullName
           );
    }    

    if (PageBreaks) {
        ScreenCount++;
        if (ScreenCount > ScreenSize - 4) {
            ScreenCount = 0;
            Print (L"\nPress Return to contiue :");
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
            Print (L"\n\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\notes\samples\shell\itestcmd\itestcmd.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    itestcmd.c

Abstract:

    Shell app "itestcmd"

Author:

Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeInternalTestCommand (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeInternalTestCommand)

EFI_STATUS
InitializeInternalTestCommand (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16 **Argv;
    UINTN  Argc;
    UINTN  i;

    /* 
     *  Check to see if the app is to be installed as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeInternalTestCommand,
        L"itestcmd",                    /*  command */
        L"itestcmd",                    /*  command syntax */
        L"Displays argc/argv list",     /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are not being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     *  Get Argc and Argv.
     */

    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *  Display list of argumnents.
     */

    for(i=0;i<Argc;i++) {
        Print(L"Argv[%d] = %s\n",i,Argv[i]);
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\bcfg\bcfg.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    bcfg.c
    
Abstract:

    Shell app "bcfg"

    Boot time driver config

Revision History

--*/

#include "shell.h"

#define MAX_ENV_SIZE    1024


#define BCFG_NONE       0
#define BCFG_DUMP       1
#define BCFG_MOVE       2
#define BCFG_REMOVE     3
#define BCFG_ADD        4    
#define BCFG_USAGE      5


typedef struct {
    UINT32              Attributes;
    CHAR16              *Description;
    EFI_DEVICE_PATH     *FilePath;
    VOID                *LoadOptions;
    UINTN               LoadOptionsSize;
    CHAR16              *FilePathStr;
} BCFG_LOAD_OPTION;

/* 
 * 
 */

EFI_STATUS
InitializeBCfg (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


VOID
DumpFileInfo (
    IN SHELL_FILE_ARG          *Arg
    );


VOID
BCfgDumpBootList (
    IN CHAR16       *BootOrder,
    IN CHAR16       *BootOption
    );

BCFG_LOAD_OPTION *
BCfgParseLoadOption (
    UINT8               *Data,
    UINTN               DataSize
    );

VOID
BCfgFreeLoadOption (
    BCFG_LOAD_OPTION    *Option
    );

VOID
BCfgSetOperation (
    UINTN               *OldOper,
    UINTN               NewOper
    );

VOID
BCfgUsage (
    VOID
    );

VOID
BCfgRemove (
    IN UINTN            Position
    );

VOID
BCfgMove (
    IN UINTN            Src,
    IN UINTN            Dest
    );

VOID
BCfgAdd (
    IN UINTN            Position,
    IN CHAR16           *File,
    IN CHAR16           *Desc
    );



/* 
 * 
 */

BOOLEAN     BCfgVerbose = FALSE;

/* 
 *  Selected list
 */

CHAR16      *BCfgSelOrder;
CHAR16      *BCfgSelOption;
CHAR16      *BCfgSelName;
UINT32      BCfgAttributes;

/* 
 *  Scratch memory
 */

UINTN       BCfgOrderCount;
UINT16      *BCfgOrder;
UINT8       *BCfgData;

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeBCfg)

EFI_STATUS
InitializeBCfg (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    EFI_STATUS              Status;
    UINTN                   Index, BufferSize;
    UINTN                   No1, No2;
    CHAR16                  *p, *File, *Desc;
    UINTN                   Oper;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeBCfg,
        L"bcfg",                                            /*  command */
        L"bcfg -?",                                         /*  command syntax */
        L"Configures boot driver & load options",           /*  1 line descriptor */
        NULL                                                /*  command help page */
        );

    /* 
     *  We are not being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    BCfgVerbose = FALSE;
    BCfgSelName = NULL;
    BCfgSelOrder = NULL;
    BCfgOrderCount = 0;

    No1 = 0;
    No2 = 0;
    File = NULL;
    Desc = NULL;

    BCfgOrder = AllocatePool(MAX_ENV_SIZE + 32);
    BCfgData  = AllocatePool(MAX_ENV_SIZE + 32);
        
    /* 
     *  Scan args for flags
     */

    Oper = BCFG_NONE;
    for (Index = 1; Index < Argc; Index += 1) {
        p = Argv[Index];
        if (StrCmp(p, L"?") == 0) {
            BCfgSetOperation (&Oper, BCFG_USAGE);
        } else if (StrCmp(p, L"driver") == 0) {
            BCfgSelOrder = VarDriverOrder;
            BCfgSelOption = VarDriverOption;
            BCfgSelName = L"boot driver";
        } else if (StrCmp(p, L"boot") == 0) {
            BCfgSelOrder = VarBootOrder;
            BCfgSelOption = VarBootOption;
            BCfgSelName = L"boot option";
        } else if (StrCmp(p, L"dump") == 0) {
            BCfgSetOperation (&Oper, BCFG_DUMP);
        } else if (StrCmp(p, L"v") == 0) {
            BCfgVerbose = TRUE;
        } else if (StrCmp(p, L"rm") == 0) {
            Index += 1;
            if (Index < Argc) {
                No1 = Atoi(Argv[Index]);
            }

            BCfgSetOperation (&Oper, BCFG_REMOVE);

        } else if (StrCmp(p, L"mv") == 0) {
            Index += 1;
            if (Index < Argc) {
                No1 = Atoi(Argv[Index]);
            }

            Index += 1;
            if (Index < Argc) {
                No2 = Atoi(Argv[Index]);
            }

            BCfgSetOperation (&Oper, BCFG_MOVE);

        } else if (StrCmp(p, L"add") == 0) {
            Index += 1;
            if (Index < Argc) {
                No1 = Atoi(Argv[Index]);
            }
            Index += 1;
            if (Index < Argc) {
                File = Argv[Index];
            }
            Index += 1;
            if (Index < Argc) {
                Desc = Argv[Index];
            }

            BCfgSetOperation (&Oper, BCFG_ADD);

        } else {
            Print (L"bfg: unknown flag '%h'\n", p);
            Oper = BCFG_USAGE;
            break;
        }
    }


    if (BCfgSelOrder) {
        /* 
         *  Read the boot order var
         */

        BufferSize = MAX_ENV_SIZE;
        Status = RT->GetVariable (
                    BCfgSelOrder, 
                    &EfiGlobalVariable,
                    &BCfgAttributes,
                    &BufferSize,
                    BCfgOrder
                    );

        if (EFI_ERROR(Status)) {
            BufferSize = 0;
            BCfgAttributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS;
            if (BCfgSelOrder == VarBootOrder) {
                BCfgAttributes = BCfgAttributes | EFI_VARIABLE_RUNTIME_ACCESS;
            }
        }

        BCfgOrderCount = BufferSize / sizeof(UINT16);
    }

    if (Oper == BCFG_NONE) {
        Oper = BCFG_USAGE;
    }
    
    if (Oper != BCFG_USAGE && !BCfgSelName) {
        Print (L"bcfg: must supply 'driver' or 'boot'\n");
        Oper = BCFG_NONE;
    }

    switch (Oper) {
    case BCFG_NONE:
        break;

    case BCFG_USAGE:
        BCfgUsage();
        break;

    case BCFG_DUMP:
        Print (L"The %s list is:\n", BCfgSelName);
        BCfgDumpBootList (BCfgSelOrder, BCfgSelOption);
        break;

    case BCFG_ADD:
        BCfgAdd (No1, File, Desc);
        break;

    case BCFG_MOVE:
        BCfgMove (No1, No2);
        break;

    case BCFG_REMOVE:
        BCfgRemove (No1);
        break;
    }

    /* 
     *  Done
     */

    if (BCfgOrder) {
        FreePool (BCfgOrder);
    }

    if (BCfgData) {
        FreePool (BCfgData);
    }

    return EFI_SUCCESS;
}

VOID
BCfgSetOperation (
    UINTN           *OldOper,
    UINTN           NewOper
    )
{
    if (*OldOper != BCFG_NONE && *OldOper != BCFG_USAGE) {
        Print (L"bcfg: only one operation may be specified at a time\n");
        *OldOper = BCFG_USAGE;
    }

    *OldOper = NewOper;
}


VOID
BCfgUsage (
    VOID
    )
{

    Print (L"bcfg driver|boot [dump [-v]] [add # file \"desc\"] [rm #] [mv # #]\n");
    Print (L"  driver  selects boot driver list\n");
    Print (L"  boot    selects boot option list\n");
    Print (L"  dump    dumps selected list\n");
    Print (L"   v      dumps verbose (includes load options)\n");
    Print (L"  add     add 'file' with 'desc' at position #\n");
    Print (L"  rm      remove #\n");
    Print (L"  mv      move # to #\n");
}


VOID
BCfgAdd (
    IN UINTN            Position,
    IN CHAR16           *File,
    IN CHAR16           *Desc
    )
{
    EFI_STATUS              Status;
    EFI_DEVICE_PATH         *DevicePath, *FilePath, *FileNode;
    CHAR16                  *Str, *p;
    UINT8                   *p8;
    SHELL_FILE_ARG          *Arg;
    LIST_ENTRY              FileList;
    CHAR16                  OptionStr[40];
    UINTN                   DescSize, FilePathSize;
    BOOLEAN                 Found;
    UINTN                   Target, Index;

    
    Str = NULL;
    FilePath = NULL;
    FileNode = NULL;
    InitializeListHead (&FileList);

    if (Position < 1) {
        Position = 1;
    }

    Position = Position - 1;

    if (Position > BCfgOrderCount) {
        Position = BCfgOrderCount;
    }

    if (!File || !Desc) {
        Print (L"bcfg: missing parameter for 'add' operation\n");
        Print (L"cfg: driver|boot add # file \"desc\"\n");
        goto Done;
    }

    /* 
     *  Get file info
     */

    ShellFileMetaArg (File, &FileList);

    /* 
     *  If filename expadned to multiple names, fail
     */

    if (FileList.Flink->Flink != &FileList) {
        Print (L"bcfg: too many source files\n");
        goto Done;
    }

    Arg = CR(FileList.Flink, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
    Status = Arg->Status;
    if (EFI_ERROR(Status)) {
        Print (L"bcfg: file %hs - %r\n", Arg->FileName, Status);
        goto Done;
    }

    /* 
     *  Build FilePath to the filename
     */

    /*  split full name at device string */
    for(p=Arg->FullName; *p && *p != ':'; p++) ;

    if (!*p) {
        Print (L"bcfg: unsupported file name '%hs'\n", Arg->FullName);
        Status = EFI_UNSUPPORTED;
        goto Done;
    }


    /*  get the device path  */
    *p = 0;
    DevicePath = (EFI_DEVICE_PATH *) ShellGetMap(Arg->FullName);
    if (!DevicePath) {
        Print (L"bcfg: no device path for %s\n", Arg->FullName);
        Status = EFI_UNSUPPORTED;
        goto Done;
    }

    /*  append the file  */
    FileNode = FileDevicePath(NULL, p+1);
    FilePath = AppendDevicePath(DevicePath, FileNode);

    /* 
     *  Find a free target # (bugbug: brute force implementation)
     */

    Found = FALSE;
    for (Target=1; Target < 0xFFFF; Target += 1) {
        Found = TRUE;
        for (Index=0; Index < BCfgOrderCount; Index += 1) {
            if (BCfgOrder[Index] == Target) {
                Found = FALSE;
                break;
            }
        }

        if (Found) {
            break;
        }
    }

    if (Target == 0xFFFF) {
        Print (L"bcfg: Failed to find available variable name\n");
        goto Done;
    }

    Print (L"Target = %d\n", Target);

    /* 
     *  Add the option
     */


    DescSize = StrSize(Desc);
    FilePathSize = DevicePathSize(FilePath);

    p8 = BCfgData;
    *((UINT32 *) p8) = 0;                       /*  Attributes */
    p8 += sizeof (UINT32);
    CopyMem (p8, Desc, DescSize);
    p8 += DescSize;
    CopyMem (p8, FilePath, FilePathSize);

    SPrint (OptionStr, sizeof(OptionStr), BCfgSelOption, Target);
    Status = RT->SetVariable (
                OptionStr,
                &EfiGlobalVariable,
                BCfgAttributes,
                sizeof(UINT32) + DescSize + FilePathSize,
                BCfgData
                );

    if (EFI_ERROR(Status)) {
        Print (L"bcfg: failed to add %hs - %hr\n", OptionStr, Status);
        goto Done;
    }


    /* 
     *  Insert target into order list
     */

    BCfgOrderCount += 1;
    for (Index=BCfgOrderCount-1; Index > Position; Index -= 1) {
        BCfgOrder[Index] = BCfgOrder[Index-1];
    }

    BCfgOrder[Position] = (UINT16) Target;
    Status = RT->SetVariable (
                    BCfgSelOrder, 
                    &EfiGlobalVariable, 
                    BCfgAttributes,
                    BCfgOrderCount * sizeof(UINT16),
                    BCfgOrder
                    );

    if (EFI_ERROR(Status)) {
        Print (L"bcfg: failed to update %hs - %hr\n", BCfgSelOrder, Status);
        goto Done;
    }

    /* 
     *  Done
     */

    Print (L"bcfg: %s added as %d\n", BCfgSelName, Position+1);

Done:
    if (FileNode) {
        FreePool (FileNode);
    }

    if (FilePath) {
        FreePool (FilePath);
    }

    if (Str) {
        FreePool(Str);
    }

    ShellFreeFileList (&FileList);
}


VOID
BCfgRemove (
    IN UINTN            Position
    )
{
    CHAR16              OptionStr[40];
    EFI_STATUS          Status;
    UINTN               Index;
    UINT16              Target;


    if (Position < 1 || Position > BCfgOrderCount) {
        Print (L"bcfg: %hd not removed.  Value is out of range\n", Position);
        return ;
    }

    Target = BCfgOrder[Position-1];

    /* 
     *  remove from order list
     */

    BCfgOrderCount = BCfgOrderCount - 1;
    for (Index=Position-1; Index < BCfgOrderCount; Index += 1) {
        BCfgOrder[Index] = BCfgOrder[Index+1];
    }

    Status = RT->SetVariable (
                    BCfgSelOrder, 
                    &EfiGlobalVariable, 
                    BCfgAttributes,
                    BCfgOrderCount * sizeof(UINT16),
                    BCfgOrder
                    );


    /* 
     *  Remove the option
     */

    SPrint (OptionStr, sizeof(OptionStr), BCfgSelOption, Target);
    RT->SetVariable (OptionStr, &EfiGlobalVariable, BCfgAttributes, 0, NULL);

    /* 
     *  Done
     */

    if (EFI_ERROR(Status)) {
        Print (L"bcfg: failed to remove - %hr\n", Status);
    } else {
        Print (L"bcfg: %s %d removed\n", BCfgSelName, Position);
    }
}

VOID
BCfgMove (
    IN UINTN            Src,
    IN UINTN            Dest
    )
{
    UINT16              Target;
    UINTN               Index;
    EFI_STATUS          Status;

    if (Src < 1 || Src > BCfgOrderCount) {
        Print (L"bcfg: %hd not moved.  Value is out of range\n", Src);
        return ;
    }

    if (Dest < 1) {
        Dest = 1;
    }

    if (Dest > BCfgOrderCount) {
        Dest = BCfgOrderCount;
    }

    /* 
     * 
     */

    Src = Src - 1;
    Dest = Dest - 1;
    Target = BCfgOrder[Src];

    /* 
     *  Remove the item
     */

    for (Index=Src; Index < BCfgOrderCount-1; Index += 1) {
        BCfgOrder[Index] = BCfgOrder[Index+1];
    }

    /* 
     *  Insert it
     */

    for (Index=BCfgOrderCount-1; Index > Dest; Index -= 1) {
        BCfgOrder[Index] = BCfgOrder[Index-1];
    }

    BCfgOrder[Dest] = Target;

    /* 
     *  Update the order
     */

    Status = RT->SetVariable (
                    BCfgSelOrder, 
                    &EfiGlobalVariable, 
                    BCfgAttributes,
                    BCfgOrderCount * sizeof(UINT16),
                    BCfgOrder
                    );

    /* 
     *  Done
     */

    if (EFI_ERROR(Status)) {
        Print (L"bcfg: failed to move option - %hr\n", Status);
    } else {
        Print (L"bcfg: %s %d moved to %d\n", BCfgSelName, Src+1, Dest+1);
    }
}




VOID
BCfgDumpBootList (
    IN CHAR16           *BootOrder,
    IN CHAR16           *BootOption
    )
{
    EFI_STATUS          Status;
    UINTN               DataSize;
    UINT32              Attributes;
    CHAR16              OptionStr[40];
    BCFG_LOAD_OPTION    *Option;
    UINTN               Index;

    for (Index=0; Index < BCfgOrderCount; Index++) {
        SPrint (OptionStr, sizeof(OptionStr), BootOption, BCfgOrder[Index]);
        DataSize = MAX_ENV_SIZE;
        Status = RT->GetVariable (
                    OptionStr,
                    &EfiGlobalVariable,
                    &Attributes,
                    &DataSize,
                    BCfgData
                    );

        Print (L"%02x. ", Index+1);
        if (!EFI_ERROR(Status)) {

            Option = BCfgParseLoadOption ((UINT8 *) BCfgData, DataSize);
            if (!Option) {
                Print (L"%Hcould not parse option%N\n");
                continue;
            }

            Print (L"%s %H\"%ns\"%s%N\n", 
                        Option->FilePathStr, 
                        Option->Description, 
                        Option->LoadOptionsSize ? L" OPT" : L""
                        );

            BCfgFreeLoadOption (Option);

        } else {
            Print (L"%hr\n", Status);
        }
    }
}


BCFG_LOAD_OPTION *
BCfgParseLoadOption (
    UINT8               *Data,
    UINTN               DataSize
    )
{
    BCFG_LOAD_OPTION    *Option;
    BOOLEAN             Valid;
    UINT8               *End;
    EFI_DEVICE_PATH     *DevicePathNode;

    Valid = FALSE;
    Option = AllocateZeroPool(sizeof(BCFG_LOAD_OPTION));

    /* 
     *  Parse the load option into the Option structure
     */

    if (DataSize < 10) {
        goto Done;
    }

    /* 
     *  First 32 bits are the load option attributes
     */

    CopyMem (&Option->Attributes, Data, sizeof(UINT32));
    Data += sizeof(UINT32);
    DataSize -= sizeof(UINT32);

    /* 
     *  Next is a null terminated string
     */

    Option->Description = AllocatePool(DataSize);
    CopyMem (Option->Description, Data, DataSize);

    /*  find the string terminator */
    Data = (UINT8 *) Option->Description;
    End = Data + DataSize;
    while (*((CHAR16 *) Data)) {
        if (Data > End - sizeof(CHAR16) - 1) {
            goto Done;
        }
        Data += sizeof(UINT16);
    }
    Data += sizeof(UINT16);
    DataSize = End - Data;

    /* 
     *  Next is the file path
     */

    Option->FilePath = AllocatePool (DataSize);
    CopyMem (Option->FilePath, Data, DataSize);

    /*  find the end of path terminator */
    DevicePathNode = (EFI_DEVICE_PATH *) Data;
    while (!IsDevicePathEnd (DevicePathNode)) {
        DevicePathNode = NextDevicePathNode (DevicePathNode);
        if ((UINT8 *) DevicePathNode > End - sizeof(EFI_DEVICE_PATH)) {
            goto Done;
        }
    }

    Data = ((UINT8 *) DevicePathNode) + sizeof(EFI_DEVICE_PATH);
    DataSize = End - Data;

    /* 
     *  Next is the load options
     */

    if (DataSize) {
        Option->LoadOptions = Data;
        Option->LoadOptionsSize = DataSize;
    }

    /* 
     *  Expand the FilePath to a string
     */

    Option->FilePathStr = DevicePathToStr(Option->FilePath);

    Valid = TRUE;
Done:
    if (!Valid && Option) {
        BCfgFreeLoadOption (Option);
        Option = NULL;
    }

    return Option;
}


VOID
BCfgFreeLoadOption (
    BCFG_LOAD_OPTION    *Option
    )
{
    if (Option->Description) {
        FreePool (Option->Description);
    }

    if (Option->FilePath) {
        FreePool (Option->FilePath);
    }

    if (Option->FilePathStr) {
        FreePool (Option->FilePathStr);
    }

    FreePool (Option);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\notes\samples\shell\etestcmd\etestcmd.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    etestcmd.c

Abstract:

    Shell app "etestcmd"

Author:

Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeExternalTestCommand (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeExternalTestCommand)

EFI_STATUS
InitializeExternalTestCommand (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16 **Argv;
    UINTN  Argc;
    UINTN  i;

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     *  Get Argc and Argv.
     */

    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *  Display list of argumnents.
     */

    for(i=0;i<Argc;i++) {
        Print(L"Argv[%d] = %s\n",i,Argv[i]);
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\cp\cp.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    cp.c
    
Abstract:

    Shell app "cp"



Revision History

--*/

#include "shell.h"


#define     COPY_SIZE   (64*1024)
VOID        *CpBuffer;

/* 
 * 
 */

EFI_STATUS
InitializeCP (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );



VOID
CopyCP (
    IN SHELL_FILE_ARG       *Src,
    IN SHELL_FILE_ARG       *Dst,
    IN BOOLEAN              CreateSubDir
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeCP)

EFI_STATUS
InitializeCP (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    CHAR16                  *Dest;
    LIST_ENTRY              SrcList;
    LIST_ENTRY              DstList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *SrcArg, *DstArg;
    UINTN                   Len1, Len2;
    BOOLEAN                 CreateSubDir;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeCP,
        L"cp",                          /*  command */
        L"cp file [file] ... [dest]",   /*  command syntax */
        L"Copy files/dirs",             /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    InitializeListHead (&SrcList);
    InitializeListHead (&DstList);
    CpBuffer = NULL;
    CreateSubDir = FALSE;

    Argv = SI->Argv;
    Argc = SI->Argc;

    if (Argc < 2) {
        Print (L"cp: no files specified\n");
        goto Done;
    }

    /* 
     *  If there's only 1 argument, then assume the destionation is
     *  the current directory
     */

    if (Argc == 2) {
        Dest = L".";
    } else {
        Argc -= 1;
        Dest = Argv[Argc];
    }

    /* 
     *  Expand the source file list
     */

    for (Index = 1; Index < Argc; Index += 1) {
        ShellFileMetaArg (Argv[Index], &SrcList);
    }

    /* 
     *  Expand the desctionation (had better be only one entry)
     */

    ShellFileMetaArg (Dest, &DstList);
    if (IsListEmpty(&DstList)) {
        Print (L"cp: no destionation\n");
        goto Done;
    }

    DstArg = CR(DstList.Flink, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
    if (DstArg->Link.Flink != &DstList) {
        Print (L"cp: destionation must be 1 location\n");
        goto Done;
    }

    /* 
     *  Verify no unexpected error on the destionation file
     */

    if (EFI_ERROR(DstArg->Status) && DstArg->Status != EFI_NOT_FOUND) {
        Print (L"cp: could not open/create destionation %hs - %r\n", DstArg->FullName, DstArg->Status);
        goto Done;
    }

    /* 
     *  Is there's more then one source file?
     */

    if (SrcList.Flink->Flink != &SrcList) {
        CreateSubDir = TRUE;
        if (DstArg->Info && !(DstArg->Info->Attribute & EFI_FILE_DIRECTORY)) {
            Print(L"cp: can not copy > 1 source file into single destionation file\n");
            goto Done;
        }
    }

    CpBuffer = AllocatePool (COPY_SIZE);
    if (!CpBuffer) {
        Print(L"cp: out of memory\n");
        goto Done;
    }

    /* 
     *  Copy each file in the SrcList
     */

    for (Link=SrcList.Flink; Link!=&SrcList; Link=Link->Flink) {
        SrcArg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);

        if (StriCmp(SrcArg->FileName, DstArg->FileName) == 0) {

            Len1 = DevicePathSize(SrcArg->ParentDevicePath);
            Len2 = DevicePathSize(DstArg->ParentDevicePath);
            if (Len1 == Len2 &&
                CompareMem(SrcArg->ParentDevicePath, DstArg->ParentDevicePath, Len1) == 0) {

                Print(L"cp: can not copy. src = dest (%hs)\n", SrcArg->FullName);
                continue;
            }
        }

        if (EFI_ERROR(SrcArg->Status)) {
            Print(L"cp: can not open %hs - %r\n", SrcArg->FullName, SrcArg->Status);
            continue;
        }

        CopyCP (SrcArg, DstArg, CreateSubDir);
    }

Done:
    if (CpBuffer) {
        FreePool (CpBuffer);
        CpBuffer = NULL;
    }

    ShellFreeFileList (&SrcList);
    ShellFreeFileList (&DstList);
    return EFI_SUCCESS;
}

SHELL_FILE_ARG *
CpCreateChild (
    IN SHELL_FILE_ARG       *Parent,
    IN CHAR16               *FileName,
    IN OUT LIST_ENTRY       *ListHead
    )
{
    SHELL_FILE_ARG          *Arg;
    UINTN                   Len;

    Arg = AllocateZeroPool (sizeof(SHELL_FILE_ARG));
    if (!Arg) {
        return NULL;
    }

    Arg->Signature = SHELL_FILE_ARG_SIGNATURE;
    Parent->Parent->Open (Parent->Handle, &Arg->Parent, L".", EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    Arg->ParentName = StrDuplicate(Parent->FullName);
    Arg->FileName = StrDuplicate(FileName);

    /*  append filename to parent's name to get the file's full name */
    Len = StrLen(Arg->ParentName);
    if (Len && Arg->ParentName[Len-1] == '\\') {
        Len -= 1;
    }

    Arg->FullName = PoolPrint(L"%.*s\\%s", Len, Arg->ParentName, FileName);

    InsertTailList (ListHead, &Arg->Link);
    return Arg;
}

VOID
CopyCP (
    IN SHELL_FILE_ARG       *Src,
    IN SHELL_FILE_ARG       *Dst,
    IN BOOLEAN              CreateSubDir
    )
{
    EFI_FILE_INFO           *Info;
    EFI_STATUS              Status;
    UINTN                   Size, WriteSize;
    LIST_ENTRY              Cleanup;
    UINT64                  SrcAttr, DstAttr;
    SHELL_FILE_ARG          *NewSrc;
    SHELL_FILE_ARG          *NewDst;
    
    if (!Src || !Dst) {
        Print(L"cp: out of memory\n");
        return ;
    }

    /* 
     *  N.B. we alloc our own shell_file_arg's to recurs, but we only
     *  fill in some of the fields
     */

    Info = (EFI_FILE_INFO *) CpBuffer;
    InitializeListHead (&Cleanup);

    /* 
     *  If the src file is not open, open it
     */

    if (!Src->Handle) {
        Status = Src->Parent->Open (
                    Src->Parent,
                    &Src->Handle,
                    Src->FileName,
                    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
                    0
                    );

        if (EFI_ERROR(Status)) {
            Print(L"cp: could not open/create %hs\n", Src->FullName);
            goto Done;
        }
    }

    Size = COPY_SIZE;
    Status = Src->Handle->GetInfo(Src->Handle, &GenericFileInfo, &Size, Info);
    if (EFI_ERROR(Status)) {
        Print(L"cp: can not get info of %hs\n", Src->FullName);
        goto Done;
    }
    SrcAttr = Info->Attribute;


    /* 
     *  If the dest file is not open, open/create it
     */

    if (!Dst->Handle) {
        if (SrcAttr & EFI_FILE_DIRECTORY) {
            CreateSubDir = TRUE;
        }

        Status = Dst->Parent->Open (
                    Dst->Parent,
                    &Dst->Handle,
                    Dst->FileName,
                    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE,
                    CreateSubDir ? EFI_FILE_DIRECTORY : 0
                    );

        if (EFI_ERROR(Status)) {
            Print(L"cp: could not open/create %hs: %r\n", Dst->FullName, Status);
            goto Done;
        }

        if (CreateSubDir) {
            Print(L"mkdir %s\n", Dst->FullName);
        }
    }

    Size = COPY_SIZE;
    Status = Dst->Handle->GetInfo(Dst->Handle, &GenericFileInfo, &Size, Info);
    if (EFI_ERROR(Status)) {
        Print(L"cp: can not get info of %hs\n", Dst->FullName);
        goto Done;
    }
    DstAttr = Info->Attribute;
    
    /* 
     *  If the source is a file, but the dest is a directory we need to create a sub-file
     */

    if (!(SrcAttr & EFI_FILE_DIRECTORY) && (DstAttr & EFI_FILE_DIRECTORY)) {
        Dst = CpCreateChild (Dst, Src->FileName, &Cleanup);
        CopyCP (Src, Dst, FALSE);
        goto Done;
    }

    /* 
     *  Copy the source
     */

    if (!(SrcAttr & EFI_FILE_DIRECTORY)) {

        /* 
         *  Copy the file's contents
         */

        Print(L"%s -> %s ", Src->FullName, Dst->FullName);
        Src->Handle->SetPosition (Src->Handle, 0);
        Dst->Handle->SetPosition (Dst->Handle, 0);

        /* 
         *  Set the size of the destination file to 0.
         */

        Status = Dst->Handle->GetInfo(Dst->Handle, &GenericFileInfo, &Size, Info);
        if (!EFI_ERROR(Status)) {
            Info->FileSize = 0;
            Status = Dst->Handle->SetInfo(  
                        Dst->Handle,
                        &GenericFileInfo,
                        (UINTN) Info->Size,
                        Info
                        );
        }

        for (; ;) {
            Size = COPY_SIZE;
            Status = Src->Handle->Read (Src->Handle, &Size, CpBuffer);
            if (!Size) {
                break;
            }

            if (EFI_ERROR(Status)) {
                Print(L"- read error: %r\n", Status);
                break;
            }

            WriteSize = Size;
            Status = Dst->Handle->Write (Dst->Handle, &WriteSize, CpBuffer);
            if (EFI_ERROR(Status)) {
                Print(L"- write error: %r\n", Status);
                break;
            }

            if (WriteSize != Size) {
                Print(L"- short write\n");
                break;
            }
        }

        if (Size) {
            Dst->Handle->Delete (Dst->Handle);
            Dst->Handle = NULL;
            goto Done;
        }

        Print(L"[ok]\n");

    } else {

        /* 
         *  Copy all the sub-entries
         */

        Src->Handle->SetPosition (Src->Handle, 0);

        for (; ;) {
            Size = COPY_SIZE;
            Status = Src->Handle->Read (Src->Handle, &Size, CpBuffer);
            if (EFI_ERROR(Status) || Size == 0) {
                break;
            }

            /* 
             *  Skip "." and ".."
             */

            if (StriCmp(Info->FileName, L".") == 0 ||
                StriCmp(Info->FileName, L"..") == 0) {
                continue;
            }

            /* 
             *  Copy the sub file
             */

            NewSrc = CpCreateChild (Src, Info->FileName, &Cleanup);
            NewDst = CpCreateChild (Dst, Info->FileName, &Cleanup);
            CopyCP (NewSrc, NewDst, FALSE);

            /* 
             *  Close the handles
             */

            ShellFreeFileList (&Cleanup);

            /*  next... */
        }
    }

Done:
    ShellFreeFileList (&Cleanup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\comp\comp.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    comp.c
    
Abstract:

    Shell app "comp" - compare two files



Revision History

--*/

#include "shell.h"


#define     COPY_SIZE   (64*1024)
VOID        *CpBuffer;

/* 
 * 
 */

EFI_STATUS
InitializeComp (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );



VOID
CopyCP (
    IN SHELL_FILE_ARG       *Src,
    IN SHELL_FILE_ARG       *Dst,
    IN BOOLEAN              CreateSubDir
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeComp)

EFI_STATUS
InitializeComp (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    LIST_ENTRY              File1List;
    LIST_ENTRY              File2List;
    SHELL_FILE_ARG          *File1Arg, *File2Arg;
    UINTN                   Size, ReadSize;
    UINT8                   *File1Buffer;
    UINT8                   *File2Buffer;
    UINTN                   NotTheSameCount;
    EFI_STATUS              Status;
    UINTN                   Index, Count;
    UINTN                   Address;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */
    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeComp,
        L"comp",                        /*  command */
        L"comp file1 file2",            /*  command syntax */
        L"Compare two files",           /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are not being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    InitializeListHead (&File1List);
    InitializeListHead (&File2List);
    File1Buffer = File2Buffer = NULL;

    Argv = SI->Argv;
    Argc = SI->Argc;

    if (Argc < 3) {
        Print (L"cp: no files specified\n");
        goto Done;
    }

    /* 
     *  Expand the source file list
     */

    ShellFileMetaArg (Argv[1], &File1List);
    File1Arg = CR(File1List.Flink, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
    if ((EFI_ERROR(File1Arg->Status) && File1Arg->Status != EFI_NOT_FOUND) ||
         !File1Arg->Handle ) {
        Print (L"comp: could not open file1 %hs - %r\n", File1Arg->FullName, File1Arg->Status);
        goto Done;
    }
    if (File1Arg->Info && (File1Arg->Info->Attribute & EFI_FILE_DIRECTORY)) {
        Print(L"comp: file1 can not be a directory\n");
        goto Done;
    }

    ShellFileMetaArg (Argv[2], &File2List);
    File2Arg = CR(File2List.Flink, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
    if ((EFI_ERROR(File2Arg->Status) && File2Arg->Status != EFI_NOT_FOUND) || 
        !File2Arg->Handle ) {
        Print (L"comp: could not open file2 %hs - %r\n", File2Arg->FullName, File2Arg->Status);
        goto Done;
    }
    if (File2Arg->Info && (File2Arg->Info->Attribute & EFI_FILE_DIRECTORY)) {
        Print(L"comp: file2 can not be a directory\n");
        goto Done;
    }

    File1Buffer = AllocatePool (COPY_SIZE);
    File2Buffer = AllocatePool (COPY_SIZE);
    if (!File1Buffer || !File2Buffer) {
        Print(L"comp: out of memory\n");
        goto Done;
    }

    /* 
     *   Compare files
     */
    Print(L"Compare %s to %s\n", File1Arg->FullName, File2Arg->FullName);
    File1Arg->Handle->SetPosition (File1Arg->Handle, 0);
    File2Arg->Handle->SetPosition (File2Arg->Handle, 0);

    Size = COPY_SIZE;
    for (NotTheSameCount = 0, Address = 0; Size > 0 && NotTheSameCount < 10;) {
        Size = COPY_SIZE;
        Status = File1Arg->Handle->Read (File1Arg->Handle, &Size, File1Buffer);
        if (EFI_ERROR(Status)) {
            Print(L"- read error file1: %r\n", Status);
            NotTheSameCount++;
            break;
        }

        ReadSize = COPY_SIZE;
        Status = File2Arg->Handle->Read (File2Arg->Handle, &ReadSize, File2Buffer);
        if (EFI_ERROR(Status)) {
            Print(L"- read error file2: %r\n", Status);
            NotTheSameCount++;
            break;
        }

        if (ReadSize != Size) {
            Print(L"- File size miss match\n");
            NotTheSameCount++;
            break;
        }

        /* 
         *  Diff the buffer
         */
        for (Index = 0; (Index < Size) && (NotTheSameCount < 10); Index++) {
            if (File1Buffer[Index] != File2Buffer[Index] ) {
                for (Count = 1; Count < 0x20; Count++) {
                    if (File1Buffer[Index + Count] == File2Buffer[Index + Count]) {
                        break;
                    }
                }
                Print (L"Miscompare #%d File1: %s\n", NotTheSameCount + 1, File1Arg->FullName);
                DumpHex (1, Address + Index, Count, &File1Buffer[Index]);
                Print (L"File2: %s\n", File2Arg->FullName);
                DumpHex (1, Address + Index, Count, &File2Buffer[Index]);
                Print (L"\n");
                NotTheSameCount++;
                Index += Count;
            }
        }
        Address += Size;
    }

    if (!NotTheSameCount) {
        Print(L"[ok]\n");
        Status = EFI_SUCCESS;
    } else {
        Status = EFI_NOT_FOUND;
    }

Done:
    if (File1Buffer) {
        FreePool (File1Buffer);
    }
    if (File2Buffer) {
        FreePool (File2Buffer);
    }

    ShellFreeFileList (&File1List);
    ShellFreeFileList (&File2List);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\date\date.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    date.c
    
Abstract:   


Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeDate (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeDate)

EFI_STATUS
InitializeDate (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

    date [mm/dd/yyyy] 

 --*/
{
    EFI_STATUS  Status;
    EFI_TIME    Time;
    CHAR16      *DateString;
    UINT32      i;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeDate, 
        L"date",                            /*  command */
        L"date [mm/dd/yyyy]",               /*  command syntax */
        L"Get or set date",                 /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    InitializeShellApplication (ImageHandle, SystemTable);
    
    if (SI->Argc > 2) {
        Print(L"date [mm/dd/yyyy]\n");
        return EFI_SUCCESS;
    }

    if (SI->Argc == 1) {
        Status = RT->GetTime(&Time,NULL);

        if (!EFI_ERROR(Status)) {
            Print(L"%02d/%02d/%04d\n",Time.Month,Time.Day,Time.Year);
        }
        return EFI_SUCCESS;
    }

    if (StrCmp(SI->Argv[1],L"/?") == 0) {
        Print(L"date [mm/dd/yyyy]\n");
        return EFI_SUCCESS;
    }
    if (StrCmp(SI->Argv[1],L"/h") == 0) {
        Print(L"date [mm/dd/yyyy]\n");
        return EFI_SUCCESS;
    }

    Status = RT->GetTime(&Time,NULL);
    if (EFI_ERROR(Status)) {
        Print(L"error : Clock not functional\n");
        return Status;
    }

    DateString = SI->Argv[1];
    Time.Month = (UINT8)Atoi(DateString);
    if (Time.Month<1 || Time.Month>12) {
        Print(L"error : invalid month\n");
        return EFI_INVALID_PARAMETER;
    }
    
    for(i=0;i<StrLen(DateString) && DateString[i]!='/';i++);

    if (DateString[i]=='/') {
        i++;
        Time.Day = (UINT8)Atoi(&(DateString[i]));
        if (Time.Day<1 || Time.Day>31) {
            Print(L"error : invalid day\n");
            return EFI_INVALID_PARAMETER;
        }
        for(;i<StrLen(DateString) && DateString[i]!='/';i++);
        if (DateString[i]=='/') {
            i++;
            Time.Year = (UINT16)Atoi(&(DateString[i]));
            if (Time.Year<100) {
                Time.Year = Time.Year + 1900;
                if (Time.Year < 1998) {
                    Time.Year = Time.Year + 100;
                }
            }
            if (Time.Year < 1998) {
                Print(L"error : invalid year\n");
                return EFI_INVALID_PARAMETER;
            }
            Status = RT->SetTime(&Time);
            if (EFI_ERROR(Status)) {
                Print(L"error : Clock not functional\n");
                return Status;
            }
            return EFI_SUCCESS;
         }
    }    
    Print(L"error : invalid date format\n");
    return EFI_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\notes\samples\apps\hellolib\hellolib.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name: hellolib.c

Abstract: This is an example EFI program

Author: 

Revision History: 1.0

--*/

#include "efi.h"
#include "efilib.h"

EFI_STATUS
InitializeHelloLibApplication (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    /* 
     *  Initialize the Library. Set BS, RT, &ST globals
     *   BS = Boot Services 
     *   RT = RunTime Services
     *   ST = System Table
     */

    InitializeLib (ImageHandle, SystemTable);

    /* 
     *  Print a message to the console device using a library function.
     */

    Print(L"HelloLib application started\n");

    /* 
     *  Wait for a key to be pressed on the console device.
     */

    Print(L"\n\n\nHit any key to exit this image\n");
    WaitForSingleEvent (ST->ConIn->WaitForKey, 0);

    /* 
     *  Print a message to the console device using a protocol interface.
     */

    ST->ConOut->OutputString (ST->ConOut, L"\n\n");

    /* 
     *  Return control to the Shell.
     */

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\cls\cls.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    cls.c
    
Abstract:



Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeCls (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeCls)

EFI_STATUS
InitializeCls (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    UINTN Background;
    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeCls,
        L"cls",                      /*  command */
        L"cls [background color]",   /*  command syntax */
        L"Clear screen",             /*  1 line descriptor */
        NULL                         /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     * 
     */

    if ( SI->Argc > 1 ) {
        Background = xtoi(SI->Argv[1]);
        if (Background > EFI_LIGHTGRAY) {
            Background = EFI_BLACK;
        }
        ST->ConOut->SetAttribute(ST->ConOut,(ST->ConOut->Mode->Attribute & 0x0f) | (Background << 4));
    }     

    ST->ConOut->ClearScreen(ST->ConOut);

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\debug\dblk.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    dblk.c
    
Abstract:
    Dump Data from block IO devices   




Revision History

--*/

#include "shelle.h"

EFI_STATUS
DumpBlockDev (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(DumpBlockDev)

EFI_STATUS
DumpBlockDev (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*
    dblk BlockDeviceName [LBA] [# Blocks]
        if no Address default address is LBA 0
        if no # Blocks then # Blocks is 1
 */
{
    UINT64              BlockAddress; 
    UINT32              NumBlocks;
    UINTN               ByteSize;
    EFI_DEVICE_PATH     *DevicePath;          
    EFI_STATUS          Status;
    EFI_BLOCK_IO        *BlkIo;
    VOID                *Buffer;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   DumpBlockDev, 
        L"dblk",                            /*  command */
        L"dblk device [Lba] [Blocks]",      /*  command syntax */
        L"Hex dump of BlkIo Devices",       /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    InitializeShellApplication (ImageHandle, SystemTable);

    if ( SI->Argc < 2 ) {
        Print (L"Usage - %Hdblk%N BlockDeviceName [LBA] [# Blocks]\n");
        return EFI_SUCCESS;
    }

    if (SI->Argc >= 3) {
        BlockAddress = xtoi(SI->Argv[2]);
    } else {
        BlockAddress = 0;
    }

    if (SI->Argc >= 4) {
        NumBlocks = (UINT32) xtoi(SI->Argv[3]);
    } else {
        NumBlocks = 1;
    }
 
    /* 
     *  Check for the device mapping
     */

    DevicePath = (EFI_DEVICE_PATH *)ShellGetMap (SI->Argv[1]);
    if (DevicePath == NULL) {
        return EFI_INVALID_PARAMETER;
    }
    Status = LibDevicePathToInterface (&BlockIoProtocol, DevicePath, (VOID **)&BlkIo);
    if (EFI_ERROR(Status)) {
        Print (L"%E - Device Not a BlockIo Device %r%N", Status);
        return Status;
    }

    if (NumBlocks > 0x10) {
        NumBlocks = 0x10;
    }

    if (BlockAddress > BlkIo->Media->LastBlock) {
        BlockAddress = 0;
    }
    
    ByteSize = BlkIo->Media->BlockSize*NumBlocks;
    Buffer = AllocatePool (ByteSize);
    if (Buffer) {
        Print (L"\n LBA 0x%016lx Size 0x%08x bytes BlkIo 0x%08x\n", BlockAddress, ByteSize, BlkIo);
        Status = BlkIo->ReadBlocks(BlkIo, BlkIo->Media->MediaId, BlockAddress, ByteSize, Buffer);
        if (Status == EFI_SUCCESS) {
            DumpHex (2, 0, ByteSize, Buffer);
            EFIStructsPrint (Buffer, BlkIo->Media->BlockSize, BlockAddress, BlkIo);
        } else {
            Print (L"  ERROR in Read %er\n", Status);
        }
        FreePool (Buffer);
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\echo\echo.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    echo.c
    
Abstract:

    Shell app "echo"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeEcho (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        InitializeEcho

    Description:
        Shell command "echo".
*/
EFI_DRIVER_ENTRY_POINT(InitializeEcho)

EFI_STATUS
InitializeEcho (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeEcho,
        L"echo",                                        /*  command */
        L"echo [[-on | -off] | [text]",                 /*  command syntax */
        L"Echo text to stdout or toggle script echo",   /*  1 line descriptor */
        NULL                                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *   No args: print status
     *   One arg, either -on or -off: set console echo flag
     *   Otherwise: echo all the args.  Shell parser will expand any args or vars.
     */

    if ( Argc == 1 ) {
        Print( L"Echo with no args not supported yet\n" );

    } else if ( Argc == 2 && StriCmp( Argv[1], L"-on" ) == 0 ) {
        Print( L"echo -on not supported yet\n" );

    } else if ( Argc == 2 && StriCmp( Argv[1], L"-off" ) == 0 ) {
        Print( L"echo -off not supported yet\n" );

    } else {
        for (Index = 1; Index < Argc; Index += 1) {
            Print( L"%s ", Argv[Index] );
        }
        Print( L"\n" );
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\debug\efidump.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    EfiDump.c
    
Abstract:   

    Dump out info about EFI structs



Revision History

--*/

#include "shelle.h"
#include "fat.h"

typedef union {
    FAT_BOOT_SECTOR     Fat;
    FAT_BOOT_SECTOR_EX  Fat32;
} EFI_FAT_BOOT_SECTOR;

FAT_VOLUME_TYPE
ValidBPB (
    IN  EFI_FAT_BOOT_SECTOR *Bpb,
    IN  UINTN               BlockSize
    );

VOID
DumpBpb (
    IN  FAT_VOLUME_TYPE     FatType,
    IN  EFI_FAT_BOOT_SECTOR *Bpb,
    IN  UINTN               BlockSize
    );

typedef union {
    VOID                    *RawData;
    UINT8                   *PtrMath;
    EFI_TABLE_HEADER        *Hdr;
    EFI_PARTITION_HEADER    *Partition;
    EFI_SYSTEM_TABLE        *Sys;
    EFI_RUNTIME_SERVICES    *RT;
    EFI_BOOT_SERVICES       *BS;
} EFI_TABLE_HEADER_PTR;

VOID
EFIFileAttributePrint (
    IN UINT64   Attrib
    );

CHAR16 *
EFIClassString (
    IN  UINT32  Class
    );

BOOLEAN
IsValidEfiHeader (
    IN  UINTN                   BlockSize,
    IN  EFI_TABLE_HEADER_PTR    Hdr
    );

VOID
EFITableHeaderPrint (
    IN  VOID        *Buffer,
    IN  UINTN       ByteSize,
    IN  UINT64      BlockAddress,
    IN  BOOLEAN     IsBlkDevice
    );

VOID
DumpGenericHeader (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    );

VOID
DumpPartition (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    );    

VOID
DumpFileHeader (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    );    

VOID
DumpSystemTable (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    );

UINT8 FatNumber[] = { 12, 16, 32, 0 }; 
                            
VOID
EFIStructsPrint (
    IN  VOID            *Buffer,
    IN  UINTN           BlockSize,
    IN  UINT64          BlockAddress,
    IN  EFI_BLOCK_IO    *BlkIo
    )
{
    MASTER_BOOT_RECORD  *Mbr;
    INTN                i;
    BOOLEAN             IsBlkDevice;
    FAT_VOLUME_TYPE     FatType;

    Print (L"\n");
    Mbr = NULL;
    if (BlockAddress == 0 && BlkIo != NULL) {
        Mbr = (MASTER_BOOT_RECORD *)Buffer;
        if (ValidMBR (Mbr, BlkIo)) {
           Print (L"  Valid MBR\n  ---------\n");
           for (i=0; i<MAX_MBR_PARTITIONS; i++) {
                Print (L"  Partition %d OS %02x Start 0x%08x Size 0x%08x\n", 
                        i, 
                        Mbr->Partition[i].OSIndicator, 
                        EXTRACT_UINT32(Mbr->Partition[i].StartingLBA), 
                        EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA)
                        );
            }
        } else if ((FatType = ValidBPB ((EFI_FAT_BOOT_SECTOR*) Buffer, BlockSize)) != FatUndefined) {
            DumpBpb (FatType, (EFI_FAT_BOOT_SECTOR*) Buffer, BlockSize); 
        }
    }

    if (!Mbr) {
        IsBlkDevice = (BlkIo != NULL);
        EFITableHeaderPrint (Buffer, BlockSize, BlockAddress, IsBlkDevice);
    }
}


typedef
VOID
(*EFI_DUMP_HEADER) (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    );

typedef struct {
    UINT64          Signature;
    CHAR16          *String;
    EFI_DUMP_HEADER Func;
} TABLE_HEADER_INFO;

TABLE_HEADER_INFO TableHeader[] = {
    EFI_PARTITION_SIGNATURE,        L"Partition",       DumpPartition,
    EFI_SYSTEM_TABLE_SIGNATURE,     L"System",          DumpSystemTable,
    EFI_BOOT_SERVICES_SIGNATURE,    L"Boot Services",   DumpGenericHeader,
    EFI_RUNTIME_SERVICES_SIGNATURE, L"Runtime Services",   DumpGenericHeader,
    0x00,                           L"",                DumpGenericHeader
};

VOID
EFITableHeaderPrint (
    IN  VOID        *Buffer,
    IN  UINTN       ByteSize,
    IN  UINT64      BlockAddress,
    IN  BOOLEAN     IsBlkDevice
    )
{
    EFI_TABLE_HEADER_PTR    Hdr;
    INTN                    i;
    
    Hdr.RawData = Buffer;
    if (IsValidEfiHeader (ByteSize, Hdr)) {
        for (i=0; TableHeader[i].Signature != 0x00; i++) {
            if (TableHeader[i].Signature == Hdr.Hdr->Signature) {
                Print (L"  Valid EFI Header at %a %016lx\n  ----------------------------------------%a\n", 
                        (IsBlkDevice ? "LBA":"Address"), 
                        BlockAddress, 
                        (IsBlkDevice ? "":"----")                 
                        );                 
                Print (L"  %H%s: Table Structure%N size %08x revision %08x\n", TableHeader[i].String, Hdr.Hdr->HeaderSize, Hdr.Hdr->Revision);
                TableHeader[i].Func (Hdr);
                return;
            }
        }
        /* 
         *  Dump the Generic Header, since we don't know the type
         */
        TableHeader[i].Func (Hdr);
    }
}

BOOLEAN
IsValidEfiHeader (
    IN  UINTN                   BlockSize,
    IN  EFI_TABLE_HEADER_PTR    Hdr
    )
{

    if (Hdr.Hdr->HeaderSize == 0x00) {
        return FALSE;
    }
    if (Hdr.Hdr->HeaderSize > BlockSize) {
        return FALSE;
    }
    return TRUE;
}

VOID
DumpGenericHeader (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    )
{
    Print (L"   Header 0x%016lx Revision 0x%08x Size 0x%08x CRC 0x%08x\n",
        Tbl.Hdr->Signature,
        Tbl.Hdr->Revision,
        Tbl.Hdr->HeaderSize,
        Tbl.Hdr->CRC32
        );
}

VOID
DumpPartition (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    )
{
    Print (L"   LBA's 0x%016lx - 0x%016lx Unusable (0x%016lx)\n", 
                Tbl.Partition->FirstUsableLba,
                Tbl.Partition->LastUsableLba,
                Tbl.Partition->UnusableSpace
                );
    Print (L"   Free Space LBA 0x%016lx Root LBA 0x%016lx\n",
                Tbl.Partition->FreeSpace, 
                Tbl.Partition->RootFile
                );
    Print (L"   Block Size 0x%08x Dir Allocation Units 0x%08x\n",
                Tbl.Partition->BlockSize,
                Tbl.Partition->DirectoryAllocationNumber
                );
}


CHAR16 *
EFIClassString (
    IN  UINT32  Class
    )
{
    switch (Class) {
    case EFI_FILE_CLASS_FREE_SPACE:
        return L"Free Space";
    case EFI_FILE_CLASS_EMPTY:
        return L"Empty";
    case EFI_FILE_CLASS_NORMAL:
        return L"Nornal";
    default:
        return L"Invalid";
    }
}

VOID
DumpSystemTable (
    IN  EFI_TABLE_HEADER_PTR    Tbl
    )
{
    EFI_STATUS      Status;
    EFI_DEVICE_PATH *DevicePath;
    VOID            *AcpiTable              = NULL;
    VOID            *SMBIOSTable            = NULL;
    VOID            *SalSystemTable         = NULL;
    VOID            *MpsTable               = NULL;

    Print (L"  ConIn (0x%08x) ConOut (0x%08x) StdErr (0x%08x)\n",
        Tbl.Sys->ConsoleInHandle,
        Tbl.Sys->ConsoleOutHandle,
        Tbl.Sys->StandardErrorHandle
        );
    
    Status = BS->HandleProtocol (Tbl.Sys->ConsoleInHandle, &DevicePathProtocol, (VOID*)&DevicePath);
    if (Status == EFI_SUCCESS && DevicePath) {
        Print (L"   Console In on  %s\n", DevicePathToStr (DevicePath));
    }
    Status = BS->HandleProtocol (Tbl.Sys->ConsoleOutHandle, &DevicePathProtocol, (VOID*)&DevicePath);
    if (Status == EFI_SUCCESS && DevicePath) {
        Print (L"   Console Out on %s\n", DevicePathToStr (DevicePath));
    }

    Status = BS->HandleProtocol (Tbl.Sys->StandardErrorHandle, &DevicePathProtocol, (VOID*)&DevicePath);
    if (Status == EFI_SUCCESS && DevicePath) {
        Print (L"   Std Error on   %s\n", DevicePathToStr (DevicePath));
    }

    Print (L"  Runtime Services 0x%016lx\n", (UINT64)Tbl.Sys->RuntimeServices); 
    Print (L"  Boot Services    0x%016lx\n", (UINT64)Tbl.Sys->BootServices);

    Status = LibGetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (!EFI_ERROR(Status)) {
        Print (L"  SAL System Table 0x%016lx\n", (UINT64)SalSystemTable);
    }

    Status = LibGetSystemConfigurationTable(&AcpiTableGuid,      &AcpiTable);
    if (!EFI_ERROR(Status)) {
        Print (L"  ACPI Table       0x%016lx\n", (UINT64)AcpiTable);
    }

    Status = LibGetSystemConfigurationTable(&MpsTableGuid,       &MpsTable);
    if (!EFI_ERROR(Status)) {
        Print (L"  MPS Table        0x%016lx\n", (UINT64)MpsTable);
    }

    Status = LibGetSystemConfigurationTable(&SMBIOSTableGuid,    &SMBIOSTable);
    if (!EFI_ERROR(Status)) {
        Print (L"  SMBIOS Table     0x%016lx\n", (UINT64)SMBIOSTable);
    }
}

FAT_VOLUME_TYPE
ValidBPB (
    IN  EFI_FAT_BOOT_SECTOR *Bpb,
    IN  UINTN               BlockSize
    )
{
    UINT32              BlockSize32;
    BOOLEAN             IsFat;
    UINT32              RootSize;
    UINT32              RootLba;
    UINT32              FirstClusterLba;
    UINT32              MaxCluster;
    UINT32              Sectors;
    FAT_VOLUME_TYPE     FatType;

    BlockSize32 = (UINT32)BlockSize;

    if (Bpb->Fat.SectorsPerFat == 0) {
        FatType = FAT32;
    } else {
        FatType = FatUndefined;
    }

    IsFat = TRUE;
    if (Bpb->Fat.Ia32Jump[0] != 0xe9  &&
        Bpb->Fat.Ia32Jump[0] != 0xeb  &&
        Bpb->Fat.Ia32Jump[0] != 0x49) {
            IsFat = FALSE;
    }

    Sectors = (Bpb->Fat.Sectors == 0) ? Bpb->Fat.LargeSectors : Bpb->Fat.Sectors;
    
    if (Bpb->Fat.SectorSize != BlockSize32          ||
        Bpb->Fat.ReservedSectors == 0               ||
        Bpb->Fat.NoFats == 0                        ||
        Sectors == 0 ) {
            IsFat = FALSE;
    }

    if (Bpb->Fat.SectorsPerCluster != 1   &&
        Bpb->Fat.SectorsPerCluster != 2   &&
        Bpb->Fat.SectorsPerCluster != 4   &&
        Bpb->Fat.SectorsPerCluster != 8   &&
        Bpb->Fat.SectorsPerCluster != 16  &&
        Bpb->Fat.SectorsPerCluster != 32  &&
        Bpb->Fat.SectorsPerCluster != 64  &&
        Bpb->Fat.SectorsPerCluster != 128) {
            IsFat = FALSE;
    }

    if (FatType == FAT32  && (Bpb->Fat32.LargeSectorsPerFat == 0 || Bpb->Fat32.FsVersion != 0)) {
        IsFat = FALSE;
    }

    if (Bpb->Fat.Media != 0xf0    &&
        Bpb->Fat.Media != 0xf8    &&
        Bpb->Fat.Media != 0xf9    &&
        Bpb->Fat.Media != 0xfb    &&
        Bpb->Fat.Media != 0xfc    &&
        Bpb->Fat.Media != 0xfd    &&
        Bpb->Fat.Media != 0xfe    &&
        Bpb->Fat.Media != 0xff    &&
        /*  FujitsuFMR */
        Bpb->Fat.Media != 0x00    &&
        Bpb->Fat.Media != 0x01    &&
        Bpb->Fat.Media != 0xfa) {
            IsFat = FALSE;
    }

    if (FatType != FAT32 && Bpb->Fat.RootEntries == 0) {
        IsFat = FALSE;
    }

    /*  If this is fat32, refuse to mount mirror-disabled volumes */
    if (FatType == FAT32 && (Bpb->Fat32.ExtendedFlags & 0x80)) {
        IsFat = FALSE;
    }

    if (FatType != FAT32) {
        RootSize = Bpb->Fat.RootEntries * sizeof(FAT_DIRECTORY_ENTRY);
        RootLba = Bpb->Fat.NoFats * Bpb->Fat.SectorsPerFat + Bpb->Fat.ReservedSectors;
        FirstClusterLba = RootLba + (RootSize / Bpb->Fat.SectorSize);
        MaxCluster = (Bpb->Fat.Sectors - FirstClusterLba) / Bpb->Fat.SectorsPerCluster;
        FatType = (MaxCluster + 1) < 4087 ? FAT12 : FAT16;
    }
    return (IsFat ? FatType : FatUndefined);
}

VOID
DumpBpb (
    IN  FAT_VOLUME_TYPE     FatType,
    IN  EFI_FAT_BOOT_SECTOR *Bpb,
    IN  UINTN               BlockSize
    )
{
    UINT32      Sectors;

    Sectors = (Bpb->Fat.Sectors == 0) ? Bpb->Fat.LargeSectors : Bpb->Fat.Sectors;

    Print (L"%HFat %d%N BPB  ", FatNumber[FatType]);
    if (FatType == FAT32) {
        Print (L"FatLabel: '%.*a' SystemId: '%.*a' OemId: '%.*a'\n", 
               sizeof(Bpb->Fat32.FatLabel), Bpb->Fat32.FatLabel, 
               sizeof(Bpb->Fat32.SystemId), Bpb->Fat32.SystemId,
               sizeof(Bpb->Fat32.OemId), Bpb->Fat32.OemId
               );
    } else {
        Print (L"FatLabel: '%.*a'  SystemId: '%.*a' OemId: '%.*a'\n", 
               sizeof(Bpb->Fat.FatLabel), Bpb->Fat.FatLabel, 
               sizeof(Bpb->Fat.SystemId), Bpb->Fat.SystemId,
               sizeof(Bpb->Fat.OemId), Bpb->Fat.OemId
               );
    }     

    Print (L" SectorSize 0x%x  SectorsPerCluster %d", Bpb->Fat.SectorSize, Bpb->Fat.SectorsPerCluster);
    Print (L" ReservedSectors %d  # Fats %d\n Root Entries 0x%x  Media 0x%x", Bpb->Fat.ReservedSectors, Bpb->Fat.NoFats, Bpb->Fat.RootEntries,  Bpb->Fat.Media);
    if (FatType == FAT32) {
        Print (L"  Sectors 0x%x  SectorsPerFat 0x%x\n", Sectors, Bpb->Fat32.LargeSectorsPerFat);
    } else {
        Print (L"  Sectors 0x%x  SectorsPerFat 0x%x\n", Sectors, Bpb->Fat.SectorsPerFat);
    }
    Print (L" SectorsPerTrack 0x%x Heads %d\n", Bpb->Fat.SectorsPerTrack, Bpb->Fat.Heads);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libeditor.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libEditor.c

  Abstract:
    Defines the Main Editor data type - 
     - Global variables 
     - Instances of the other objects of the editor
     - Main Interfaces

--*/

#ifndef _LIB_EDITOR
#define _LIB_EDITOR

#include "editor.h"

STATIC  EFI_EDITOR_COLOR_ATTRIBUTES OriginalColors;
STATIC  INTN                        OriginalMode;

extern  EFI_EDITOR_FILE_BUFFER      FileBuffer;
extern  EFI_EDITOR_FILE_IMAGE       FileImage;
extern  EFI_EDITOR_TITLE_BAR        MainTitleBar;
extern  EFI_EDITOR_STATUS_BAR       MainStatusBar;
extern  EFI_EDITOR_INPUT_BAR        MainInputBar;
extern  EFI_EDITOR_MENU_BAR         MainMenuBar;

STATIC  EFI_STATUS  MainEditorInit (VOID);
STATIC  EFI_STATUS  MainEditorCleanup (VOID);
STATIC  EFI_STATUS  MainEditorKeyInput (VOID);
STATIC  EFI_STATUS  MainEditorHandleInput (EFI_INPUT_KEY*);
STATIC  EFI_STATUS  MainEditorRefresh (VOID);

EFI_EDITOR_GLOBAL_EDITOR MainEditor = {
    &MainTitleBar,
    &MainMenuBar,
    &MainStatusBar,
    &MainInputBar,
    &FileBuffer,
    {0,0},
    NULL,
    &FileImage,
    FALSE,
    MainEditorInit,
    MainEditorCleanup,
    MainEditorKeyInput,
    MainEditorHandleInput,
    MainEditorRefresh
};

EFI_EDITOR_GLOBAL_EDITOR MainEditorConst = {
    &MainTitleBar,
    &MainMenuBar,
    &MainStatusBar,
    &MainInputBar,
    &FileBuffer,
    {0,0},
    NULL,
    &FileImage,
    FALSE,
    MainEditorInit,
    MainEditorCleanup,
    MainEditorKeyInput,
    MainEditorHandleInput,
    MainEditorRefresh
};


STATIC
EFI_STATUS
MainEditorInit (VOID)
{
    EFI_STATUS  Status;

    CopyMem (&MainEditor, &MainEditorConst, sizeof(MainEditor));

    Status = In->Reset(In,FALSE);
    if (EFI_ERROR(Status)) {
        Print (L"%ECould not obtain input device!%N\n");
        return EFI_LOAD_ERROR;
    }

    MainEditor.ColorAttributes.Colors.Foreground = Out->Mode->Attribute & 0x000000ff;
    MainEditor.ColorAttributes.Colors.Background = (UINT8)(Out->Mode->Attribute >> 4);
    OriginalColors = MainEditor.ColorAttributes.Colors;

    OriginalMode = Out->Mode->Mode;

    MainEditor.ScreenSize = AllocatePool (sizeof(EFI_EDITOR_POSITION));
    if (MainEditor.ScreenSize == NULL ) {
        Print (L"%ECould Not Allocate Memory for Screen Size\n%N");
        return EFI_OUT_OF_RESOURCES;
    }
    Out->QueryMode(Out,Out->Mode->Mode,&(MainEditor.ScreenSize->Column),&(MainEditor.ScreenSize->Row));

    Status = MainEditor.TitleBar->Init ();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on TitleBar init\n%N");
        return EFI_LOAD_ERROR;
    }
    Status = MainEditor.StatusBar->Init ();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on StatusBar init\n%N");
        return EFI_LOAD_ERROR;
    }
    Status = MainEditor.FileBuffer->Init();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on FileBuffer init\n%N");
        return EFI_LOAD_ERROR;
    }
    Status = MainEditor.MenuBar->Init();
    if ( EFI_ERROR(Status)) {
        Print (L"%EMainEditor init failed on MainMenu init\n%N");
        return EFI_LOAD_ERROR;
    } 
    Status = MainEditor.InputBar->Init ();
    if ( EFI_ERROR(Status)) {
        Print (L"%EMainEditor init failed on InputBar init\n%N");
        return EFI_LOAD_ERROR;
    }

    Out->ClearScreen(Out);
    Out->EnableCursor(Out,TRUE);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainEditorCleanup (
    VOID
    )
{
    EFI_STATUS      Status;

    Status = MainEditor.TitleBar->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"TitleBar cleanup failed\n");
    }

    Status = MainEditor.MenuBar->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"MenuBar cleanup failed\n");
    }

    Status = MainEditor.InputBar->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"InputBar cleanup failed\n");
    }

    Status = MainEditor.FileImage->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"FileImage cleanup failed\n");
    }

    Status = MainEditor.FileBuffer->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"FileBuffer cleanup failed\n");
    }

    Status = MainEditor.StatusBar->Cleanup();
    if (EFI_ERROR (Status))  {
        Print (L"StatusBar cleanup failed\n");
    }

    if (OriginalMode != Out->Mode->Mode) {
        Out->SetMode(Out,OriginalMode);
    }
    Out->SetAttribute(Out,EFI_TEXT_ATTR(OriginalColors.Foreground,OriginalColors.Background));
    Out->ClearScreen (Out);


    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
MainEditorKeyInput (
    VOID
    )
{
    EFI_INPUT_KEY   Key;
    EFI_STATUS      Status;
    UINTN           i =0;

    do {
        WaitForSingleEvent(In->WaitForKey,0);
        Status = In->ReadKeyStroke(In,&Key);
        if ( EFI_ERROR(Status)) {
            continue;
        }

        if (IS_VALID_CHAR(Key.ScanCode)) {
            Status = MainEditor.FileBuffer->HandleInput(&Key);
        } else if (IS_DIRECTION_KEY(Key.ScanCode)) {
            Status = MainEditor.FileBuffer->HandleInput(&Key);
        } else if (IS_FUNCTION_KEY(Key.ScanCode)) {
            Status = MainEditor.MenuBar->HandleInput(&Key);
        } else {
            MainEditor.StatusBar->SetStatusString(L"Unknown Command");
        }
    }
    while (!EFI_ERROR(Status));


    return  EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainEditorHandleInput (
    IN  EFI_INPUT_KEY*  Key
) 
{
    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
MainEditorRefresh (
    VOID
    )
{
    MainEditor.TitleBar->Refresh();
    MainEditor.MenuBar->Refresh();
    MainEditor.StatusBar->Refresh();
    MainEditor.FileBuffer->Refresh();
    return EFI_SUCCESS;
}


#endif  /* ._LIB_EDITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\debug\fat.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    fat.h

Abstract:

    On disk fat structures



Revision History

--*/

typedef enum {
    FAT12,
    FAT16,
    FAT32,
    FatUndefined
} FAT_VOLUME_TYPE;

#pragma pack(1)

/* 
 *  Used for fat12 & fat16
 */

typedef struct {
    UINT8           Ia32Jump[3];
    CHAR8           OemId[8];

    UINT16          SectorSize;
    UINT8           SectorsPerCluster;
    UINT16          ReservedSectors;
    UINT8           NoFats;
    UINT16          RootEntries;            /*  < FAT32, root dir is fixed size */
    UINT16          Sectors;
    UINT8           Media;                  /*  (ignored) */
    UINT16          SectorsPerFat;          /*  < FAT32 */
    UINT16          SectorsPerTrack;        /*  (ignored) */
    UINT16          Heads;                  /*  (ignored) */
    UINT32          HiddenSectors;          /*  (ignored) */
    UINT32          LargeSectors;           /*  => FAT32 */
    
    UINT8           PhysicalDriveNumber;    /*  (ignored) */
    UINT8           CurrentHead;            /*  holds boot_sector_dirty bit */
    UINT8           Signature;              /*  (ignored) */

    CHAR8           Id[4];
    CHAR8           FatLabel[11];
    CHAR8           SystemId[8];

} FAT_BOOT_SECTOR;

typedef struct {
    UINT8           Ia32Jump[3];
    CHAR8           OemId[8];

    UINT16          SectorSize;
    UINT8           SectorsPerCluster;
    UINT16          ReservedSectors;
    UINT8           NoFats;
    UINT16          RootEntries;            /*  < FAT32, root dir is fixed size */
    UINT16          Sectors;
    UINT8           Media;                  /*  (ignored) */
    UINT16          SectorsPerFat;          /*  < FAT32 */
    UINT16          SectorsPerTrack;        /*  (ignored) */
    UINT16          Heads;                  /*  (ignored) */
    UINT32          HiddenSectors;          /*  (ignored) */
    UINT32          LargeSectors;           /*  Used if Sectors==0 */

    UINT32          LargeSectorsPerFat;     /*  FAT32 */
    UINT16          ExtendedFlags;          /*  FAT32 (ignored) */
    UINT16          FsVersion;              /*  FAT32 (ignored) */
    UINT32          RootDirFirstCluster;    /*  FAT32 */
    UINT16          FsInfoSector;           /*  FAT32 */
    UINT16          BackupBootSector;       /*  FAT32 */
    UINT8           Reserved[12];           /*  FAT32 (ignored) */

    UINT8           PhysicalDriveNumber;    /*  (ignored) */
    UINT8           CurrentHead;            /*  holds boot_sector_dirty bit */
    UINT8           Signature;              /*  (ignored) */

    CHAR8           Id[4];
    CHAR8           FatLabel[11];
    CHAR8           SystemId[8];
} FAT_BOOT_SECTOR_EX;

/* 
 *  ignored - means not used in the EFI driver
 * 
 *  For <Fat32 RootEntries indicates the number of entries in the root directory,
 *  and SectorsPerFat is used to size the fact table
 */

typedef struct {
    UINT16          Day:5;
    UINT16          Month:4;
    UINT16          Year:7;                 /*  From 1980 */
} FAT_DATE;

typedef struct {
    UINT16          DoubleSecond:5;
    UINT16          Minute:6;
    UINT16          Hour:5;
} FAT_TIME;

typedef struct {
    FAT_TIME        Time;
    FAT_DATE        Date;
} FAT_DATE_TIME;


typedef struct {
    CHAR8           FileName[11];           /*  8.3 filename */
    UINT8           Attributes;
    UINT8           CaseFlag;
    UINT8           CreateMillisecond;      /*  (creation milliseconds - ignored) */
    FAT_DATE_TIME   FileCreateTime;
    FAT_DATE        FileLastAccess;
    UINT16          FileClusterHigh;        /*  >= FAT32 */
    FAT_DATE_TIME   FileModificationTime;
    UINT16          FileCluster;        
    UINT32          FileSize;
} FAT_DIRECTORY_ENTRY;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libfilebuffer.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libFileBuffer.c

  Abstract:
    Defines FileBuffer - the view of the file that is visible at any point, 
    as well as the event handlers for editing the file
--*/


#ifndef _LIB_FILE_BUFFER
#define _LIB_FILE_BUFFER

#include "libMisc.h"

extern  EFI_EDITOR_LINE*    FileImageCreateNode  (VOID);


#define ABSOLUTE_MAX_COLUMNS    132
STATIC  CHAR16  BlankLine[ABSOLUTE_MAX_COLUMNS];

STATIC  EFI_STATUS  FileBufferScrollUp (VOID);
STATIC  EFI_STATUS  FileBufferScrollDown (VOID);
STATIC  EFI_STATUS  FileBufferScrollLeft (VOID);
STATIC  EFI_STATUS  FileBufferScrollRight (VOID);
STATIC  EFI_STATUS  FileBufferPageUp (VOID);
STATIC  EFI_STATUS  FileBufferPageDown (VOID);
STATIC  EFI_STATUS  FileBufferHome  (VOID);
STATIC  EFI_STATUS  FileBufferEnd   (VOID);
STATIC  EFI_STATUS  FileBufferChangeMode    (VOID);

STATIC  EFI_STATUS  FileBufferDoDelete (VOID);
STATIC  EFI_STATUS  FileBufferDoBackspace (VOID);
STATIC  EFI_STATUS  FileBufferDoCharInput (CHAR16);
STATIC  EFI_STATUS  FileBufferDoReturn (VOID);


STATIC  EFI_STATUS  FileBufferRefreshCurrentLine(VOID);
STATIC  EFI_STATUS  FileBufferRefreshDown(VOID);

STATIC  EFI_STATUS  FileBufferInit (VOID);
STATIC  EFI_STATUS  FileBufferCleanup (VOID);
STATIC  EFI_STATUS  FileBufferRefresh (VOID);
STATIC  EFI_STATUS  FileBufferHide (VOID);
STATIC  EFI_STATUS  FileBufferHandleInput (EFI_INPUT_KEY*);

STATIC  EFI_STATUS  FileBufferClearLine (UINTN);
STATIC  EFI_STATUS  FileBufferSetPosition (UINTN,UINTN);
STATIC  EFI_STATUS  FileBufferRestorePosition (VOID);

EFI_EDITOR_FILE_BUFFER  FileBuffer = {
    {0,0},
    {0,0},
    {0,0},
    {0,0},
    0,
    0,
    TRUE,
    NULL,
    FileBufferInit,
    FileBufferCleanup,
    FileBufferRefresh,
    FileBufferHide,
    FileBufferHandleInput,
    FileBufferClearLine,
    FileBufferSetPosition,
    FileBufferRestorePosition,
    FileBufferRefreshCurrentLine
};

EFI_EDITOR_FILE_BUFFER  FileBufferConst = {
    {0,0},
    {0,0},
    {0,0},
    {0,0},
    0,
    0,
    TRUE,
    NULL,
    FileBufferInit,
    FileBufferCleanup,
    FileBufferRefresh,
    FileBufferHide,
    FileBufferHandleInput,
    FileBufferClearLine,
    FileBufferSetPosition,
    FileBufferRestorePosition,
    FileBufferRefreshCurrentLine
};


STATIC
EFI_STATUS
FileBufferInit (
    VOID
    )
{ 
    UINTN   i;

    CopyMem (&FileBuffer, &FileBufferConst, sizeof(FileBuffer));

    FileBuffer.DisplayPosition.Row = TEXT_START_ROW;
    FileBuffer.DisplayPosition.Column = TEXT_START_COLUMN;
    FileBuffer.LowVisibleRange.Row = TEXT_START_ROW;
    FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
    FileBuffer.MaxVisibleRows = MAX_TEXT_ROWS;
    FileBuffer.MaxVisibleColumns = MAX_TEXT_COLUMNS;
    FileBuffer.HighVisibleRange.Row = MAX_TEXT_ROWS;
    FileBuffer.HighVisibleRange.Column = MAX_TEXT_COLUMNS;

    for (i = 0; i < MAX_TEXT_COLUMNS; i++) {
        BlankLine[i] = ' ';
    }
    BlankLine[i-1] = 0;

    FileBuffer.LowVisibleRange.Row = TEXT_START_ROW;
    FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;

    FileBuffer.MaxVisibleRows = MAX_TEXT_ROWS;
    FileBuffer.MaxVisibleColumns = MAX_TEXT_COLUMNS;

    FileBuffer.FilePosition.Row = 1;
    FileBuffer.FilePosition.Column = 1;

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferCleanup   (
    VOID
    )
{
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferRefresh (
    VOID
    )
{
    LIST_ENTRY          *Item;
    UINTN               Row;

    Row = FileBuffer.DisplayPosition.Row;
    FileBuffer.DisplayPosition.Row = TEXT_START_ROW;

    Item = FileBuffer.CurrentLine;

    LineRetreat(FileBuffer.FilePosition.Row - FileBuffer.LowVisibleRange.Row);

    FileBufferRefreshDown();

    FileBuffer.CurrentLine = Item;

    FileBuffer.DisplayPosition.Row = Row;
    FileBufferRestorePosition();

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferRefreshCurrentLine (
    VOID
    )
{
    EFI_EDITOR_LINE *Line;
    UINTN           Where;
    CHAR16          *StrLine;
    UINTN           StartColumn;

    Where = FileBuffer.DisplayPosition.Row;
    StartColumn = FileBuffer.LowVisibleRange.Column;

    FileBufferClearLine(Where);

    Line = LineCurrent();

    if (Line->Link.Blink == MainEditor.FileImage->ListHead && 
        FileBuffer.DisplayPosition.Row > TEXT_START_ROW) {
        return EFI_SUCCESS;
    }

    if (Line->Size < StartColumn) {
        FileBufferRestorePosition();
        return EFI_SUCCESS;
    }

    StrLine = PoolPrint(L"%s",Line->Buffer + StartColumn);
    if ((Line->Size - StartColumn)> FileBuffer.MaxVisibleColumns) {
        StrLine[FileBuffer.MaxVisibleColumns-2] = 0;
    } else {
        StrLine[(Line->Size - StartColumn)] = 0;
    }

/*   PrintAt(0,Where,StrLine); */
    Out->SetCursorPosition(Out,0,Where);
    Out->OutputString(Out,StrLine);

    FreePool(StrLine);

    FileBufferRestorePosition();
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferRefreshDown (
    VOID
    )
{
    LIST_ENTRY  *Item;
    LIST_ENTRY  *Link;
    UINTN       Row;

    Row = FileBuffer.DisplayPosition.Row;

    Item = FileBuffer.CurrentLine;
    Link = FileBuffer.CurrentLine;

    while (FileBuffer.DisplayPosition.Row <= MAX_TEXT_ROWS) {
        if (Link->Flink != MainEditor.FileImage->ListHead) {
            FileBufferRefreshCurrentLine();
            LineNext();
            Link = FileBuffer.CurrentLine;
        } else {
            FileBufferClearLine(FileBuffer.DisplayPosition.Row);
        }
        FileBuffer.DisplayPosition.Row++;
    }

    FileBuffer.CurrentLine = Item;

    FileBuffer.DisplayPosition.Row = Row;
    FileBufferRestorePosition();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferHandleInput (
    IN  EFI_INPUT_KEY*  Key
    )
{ 

    switch (Key->ScanCode) {
    case    SCAN_CODE_NULL:
        FileBufferDoCharInput (Key->UnicodeChar);
        break;
    case    SCAN_CODE_UP:
        FileBufferScrollUp();
        break;
    case    SCAN_CODE_DOWN:
        FileBufferScrollDown();
        break;
    case    SCAN_CODE_RIGHT:
        FileBufferScrollRight();
        break;
    case    SCAN_CODE_LEFT:
        FileBufferScrollLeft();
        break;
    case    SCAN_CODE_PGUP:
        FileBufferPageUp();
        break;
    case    SCAN_CODE_PGDN:
        FileBufferPageDown();
        break;
    case    SCAN_CODE_DEL:
        FileBufferDoDelete();
        break;
    case    SCAN_CODE_HOME:
        FileBufferHome();
        break;
    case    SCAN_CODE_END:
        FileBufferEnd();
        break;
    case    SCAN_CODE_INS:
        FileBufferChangeMode();
        break;
    default:
        break;
    }

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferHide (
    VOID
    )
{ 
    UINTN   i;

    for (i = TEXT_START_ROW; i < FileBuffer.MaxVisibleRows; i++ ) {
        FileBufferClearLine(i);
    }

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferClearLine (
    UINTN Line
    ) 
{
    PrintAt(0,Line,BlankLine);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferSetPosition (
    IN  UINTN   Row,
    IN  UINTN   Column
    )
{
    FileBuffer.DisplayPosition.Row = Row;
    FileBuffer.DisplayPosition.Column = Column;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferRestorePosition (
    VOID
    )
{
    Out->SetCursorPosition (Out,FileBuffer.DisplayPosition.Column,FileBuffer.DisplayPosition.Row);

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileBufferScrollDown (
    VOID
)
{
    UINTN               CurrentRow;
    UINTN               CurrentCol;
    UINTN               MaxRows;
    UINTN               HighRow;
    EFI_EDITOR_LINE     *Line;
    BOOLEAN             Refresh = FALSE;
    
    Line = LineCurrent();
    if (Line->Link.Flink == MainEditor.FileImage->ListHead) {
        return EFI_SUCCESS;
    }

    CurrentRow = FileBuffer.DisplayPosition.Row;
    CurrentCol = FileBuffer.DisplayPosition.Column;
    MaxRows = FileBuffer.MaxVisibleRows;
    HighRow = FileBuffer.HighVisibleRange.Row;
    
        /*  Current row is the bottom row, shift only one line, not scroll the whole screen. */
    if (CurrentRow == MaxRows) {
        FileBuffer.LowVisibleRange.Row += 1;
        FileBuffer.HighVisibleRange.Row += 1;
        CurrentRow = MaxRows;
        Refresh = TRUE;
    } else if (CurrentRow == HighRow) {
        return EFI_SUCCESS;
    } else {
        ++CurrentRow;
    }

    Line = LineNext();

    if (FileBuffer.FilePosition.Column > (Line->Size-1)) {
        FileBuffer.FilePosition.Column = Line->Size;
        if (Line->Size < FileBuffer.LowVisibleRange.Column) {
            if (FileBuffer.LowVisibleRange.Column < FileBuffer.MaxVisibleColumns) {
                FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
            } else {
                FileBuffer.LowVisibleRange.Column = Line->Size - FileBuffer.MaxVisibleColumns + 2;
            }
            FileBuffer.HighVisibleRange.Column = FileBuffer.LowVisibleRange.Column + FileBuffer.MaxVisibleColumns - 1;
            Refresh = TRUE;
        }
        CurrentCol = FileBuffer.FilePosition.Column - FileBuffer.LowVisibleRange.Column - 1;
    }

    if (Refresh) {
        FileBufferRefresh();
    }
    FileBuffer.SetPosition(CurrentRow,CurrentCol);

    ++FileBuffer.FilePosition.Row;

    MainEditor.StatusBar->SetPosition(FileBuffer.FilePosition.Row,FileBuffer.FilePosition.Column);

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferScrollUp (
    VOID
    )
{ 
    UINTN           CurrentRow;
    UINTN           CurrentCol;
    UINTN           MaxRows;
    UINTN           LowRow;
    EFI_EDITOR_LINE *Line;

    if ( FileBuffer.FilePosition.Row <= TEXT_START_ROW ) {
        return EFI_SUCCESS;
    }

    MaxRows = FileBuffer.MaxVisibleRows;
    LowRow = FileBuffer.LowVisibleRange.Row;

    CurrentRow = FileBuffer.DisplayPosition.Row;
    CurrentCol = FileBuffer.DisplayPosition.Column;

        /*  Current row is the top row, shift only one line, not scroll the whole screen. */
    if (CurrentRow == TEXT_START_ROW) {
        
        FileBuffer.HighVisibleRange.Row -= 1;
        FileBuffer.LowVisibleRange.Row -= 1;
        CurrentRow = TEXT_START_ROW;                
        FileBuffer.Refresh();
    } else {
        CurrentRow--;
    }
        
    Line = LinePrevious ();

    if (FileBuffer.FilePosition.Column > (Line->Size-1)) {

        FileBuffer.FilePosition.Column = Line->Size;

        if (Line->Size < FileBuffer.LowVisibleRange.Column) {
            if ( FileBuffer.LowVisibleRange.Column < FileBuffer.MaxVisibleColumns ) {
                FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
            } else {
                FileBuffer.LowVisibleRange.Column = Line->Size - FileBuffer.MaxVisibleColumns + 2;
            }
            FileBuffer.HighVisibleRange.Column = FileBuffer.LowVisibleRange.Column + FileBuffer.MaxVisibleColumns - 1;
            FileBuffer.Refresh();
        }
        CurrentCol = FileBuffer.FilePosition.Column - FileBuffer.LowVisibleRange.Column - 1;
    }

    FileBuffer.SetPosition(CurrentRow,CurrentCol);

    --FileBuffer.FilePosition.Row;
    MainEditor.StatusBar->SetPosition(FileBuffer.FilePosition.Row,FileBuffer.FilePosition.Column);

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferPageUp (
    VOID
    )
{
    UINTN           MaxRows;
    UINTN           LowRow;
    UINTN           FilePos;
    EFI_EDITOR_LINE *Line;

    if ( FileBuffer.FilePosition.Row <= TEXT_START_ROW ) {
        return EFI_SUCCESS;
    }

    MaxRows = FileBuffer.MaxVisibleRows;
    LowRow = FileBuffer.LowVisibleRange.Row;
    FilePos = FileBuffer.FilePosition.Row;

    if (LowRow < MaxRows) {
        FileBuffer.HighVisibleRange.Row = MaxRows;
        FileBuffer.LowVisibleRange.Row = 1;
        if (LowRow > TEXT_START_ROW) {
            if (FilePos > MaxRows){
                FileBuffer.DisplayPosition.Row = FilePos - MaxRows;
            } else {
                FileBuffer.DisplayPosition.Row = 1;
            }
        } else {
            FileBuffer.DisplayPosition.Row = 1;
            FileBuffer.DisplayPosition.Column = TEXT_START_COLUMN;          
        }
        FileBuffer.FilePosition.Row = FileBuffer.DisplayPosition.Row;
    } else {
        FileBuffer.HighVisibleRange.Row = LowRow;
        FileBuffer.LowVisibleRange.Row -= (MaxRows - 1);
        FileBuffer.FilePosition.Row -= (MaxRows - 1);
    }

    LineRetreat(FilePos - FileBuffer.FilePosition.Row);
    Line = LineCurrent ();

    if (FileBuffer.FilePosition.Column > (Line->Size-1)) {

        FileBuffer.FilePosition.Column = Line->Size;

        if (Line->Size < FileBuffer.LowVisibleRange.Column ) {
            if ( FileBuffer.LowVisibleRange.Column < FileBuffer.MaxVisibleColumns ) {
                FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
            } else {
                FileBuffer.LowVisibleRange.Column = Line->Size - FileBuffer.MaxVisibleColumns + 2;
            }
            FileBuffer.HighVisibleRange.Column = FileBuffer.LowVisibleRange.Column + FileBuffer.MaxVisibleColumns - 1;
        }
        FileBuffer.DisplayPosition.Column = FileBuffer.FilePosition.Column - FileBuffer.LowVisibleRange.Column - 1;
        FileBuffer.Refresh();
    }

    FileBuffer.Refresh();

    MainEditor.StatusBar->SetPosition(FileBuffer.FilePosition.Row,FileBuffer.FilePosition.Column);

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileBufferPageDown (
    VOID
    )
{ 
    UINTN           MaxRows;
    UINTN           HighRow;
    UINTN           FilePos;
    EFI_EDITOR_LINE *Line;
    BOOLEAN         Refresh = FALSE;

    if (FileBuffer.FilePosition.Row == MainEditor.FileImage->NumLines) {
        return EFI_SUCCESS;
    }

    MaxRows = FileBuffer.MaxVisibleRows;
    HighRow = FileBuffer.HighVisibleRange.Row;
    FilePos = FileBuffer.FilePosition.Row;

    FileBuffer.FilePosition.Row = min((FileBuffer.FilePosition.Row+MaxRows-1),MainEditor.FileImage->NumLines);
    if (HighRow < MainEditor.FileImage->NumLines) {
        FileBuffer.LowVisibleRange.Row = HighRow;
        FileBuffer.HighVisibleRange.Row = HighRow + (MaxRows-1);
        Refresh = TRUE;
    }

    FileBuffer.DisplayPosition.Row = TEXT_START_ROW + FileBuffer.FilePosition.Row - FileBuffer.LowVisibleRange.Row;
    
    Line = LineAdvance(FileBuffer.FilePosition.Row - FilePos);

    if (FileBuffer.FilePosition.Column > (Line->Size-1) || !Refresh) {
        FileBuffer.FilePosition.Column = Line->Size;
        if (Line->Size < FileBuffer.LowVisibleRange.Column ) {
            if (FileBuffer.LowVisibleRange.Column < FileBuffer.MaxVisibleColumns) {
                FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
            } else {
                FileBuffer.LowVisibleRange.Column = Line->Size - FileBuffer.MaxVisibleColumns + 2;
            }
            FileBuffer.HighVisibleRange.Column = FileBuffer.LowVisibleRange.Column + FileBuffer.MaxVisibleColumns - 1;
            Refresh = TRUE;
        }
        FileBuffer.DisplayPosition.Column = FileBuffer.FilePosition.Column - FileBuffer.LowVisibleRange.Column - 1;
    }

    if (Refresh) {
        FileBuffer.Refresh();
    }

    MainEditor.StatusBar->SetPosition(FileBuffer.FilePosition.Row,FileBuffer.FilePosition.Column);

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferScrollLeft (
    VOID
    )
{
    UINTN   CurrentCol;
    UINTN   CurrentRow;
    UINTN   MaxCols;
    UINTN   HighCol;
    UINTN   LowCol;
    EFI_EDITOR_POSITION FilePos;    
    EFI_EDITOR_LINE *Line;

    CurrentCol = FileBuffer.DisplayPosition.Column;
    CurrentRow = FileBuffer.DisplayPosition.Row;
    MaxCols = FileBuffer.MaxVisibleColumns;
    HighCol = FileBuffer.HighVisibleRange.Column;
    LowCol = FileBuffer.LowVisibleRange.Column;
    FilePos = FileBuffer.FilePosition;
    Line = LineCurrent ();

    if ( FilePos.Row == 1 && FilePos.Column == 1) {
        return EFI_SUCCESS;
    }

    if ( Line->Size == 0 || FilePos.Column == TEXT_START_COLUMN + 1 ) {
        FileBufferScrollUp ();
        Line = LineCurrent (); 
        CurrentCol = Line->Size - 1;

        if ( CurrentCol > HighCol ) {
            if ( CurrentCol  < MaxCols ) {
                FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
                FileBuffer.HighVisibleRange.Column = MaxCols;
            } else {
                FileBuffer.HighVisibleRange.Column = CurrentCol;
                FileBuffer.LowVisibleRange.Column = CurrentCol - MaxCols + 1;
            }
            FileBuffer.Refresh();
        }
        FileBuffer.FilePosition.Column = CurrentCol + 1;
        FileBuffer.DisplayPosition.Column = CurrentCol - FileBuffer.LowVisibleRange.Column;
    } else if ( FilePos.Column <= LowCol+1 ) {
        if ( LowCol <= MaxCols ) {
            LowCol = TEXT_START_COLUMN;
        } else {
            LowCol -= (MaxCols-1);
        }
        FileBuffer.LowVisibleRange.Column = LowCol;
        FileBuffer.HighVisibleRange.Column = LowCol + MaxCols - 1;
        FileBuffer.DisplayPosition.Column = FilePos.Column - LowCol - 2;
        --FileBuffer.FilePosition.Column;

        FileBuffer.Refresh();
    } else {
        --FileBuffer.DisplayPosition.Column;
        --FileBuffer.FilePosition.Column;
    }
    MainEditor.StatusBar->SetPosition(FileBuffer.FilePosition.Row,FileBuffer.FilePosition.Column);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferScrollRight (
    VOID
    )
{ 
    EFI_EDITOR_POSITION FilePos;
    EFI_EDITOR_POSITION CurrentPos;
    EFI_EDITOR_LINE     *Line;
    UINTN               LineSize;
    UINTN               MaxCols;
    UINTN               LowCol;
    UINTN               HighCol;

    CurrentPos = FileBuffer.DisplayPosition;
    FilePos = FileBuffer.FilePosition;
    Line = LineCurrent ();
    LineSize = Line->Size;
    MaxCols = FileBuffer.MaxVisibleColumns;
    LowCol = FileBuffer.LowVisibleRange.Column;
    HighCol = FileBuffer.HighVisibleRange.Column;

    if (FilePos.Column >= (Line->Size-1) && FilePos.Row >= MainEditor.FileImage->NumLines) {
        return EFI_SUCCESS;
    }

    if (LineSize == 0 || FilePos.Column >= LineSize) {
        FileBufferScrollDown();

        CurrentPos.Column = TEXT_START_COLUMN;

        if (LowCol > TEXT_START_COLUMN) {
            FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;

            FileBuffer.HighVisibleRange.Column = MaxCols;
            FileBuffer.Refresh ();
        }
        FileBuffer.FilePosition.Column = 1;
        FileBuffer.DisplayPosition.Column = TEXT_START_COLUMN;
    } else if (CurrentPos.Column >= (MaxCols - 1)) {
        FileBuffer.LowVisibleRange.Column = HighCol - 2;
        FileBuffer.HighVisibleRange.Column = HighCol + MaxCols - 2;

        ++FileBuffer.FilePosition.Column;

        FileBuffer.DisplayPosition.Column = TEXT_START_COLUMN + 2;

        FileBuffer.Refresh();
    } else {
        ++FileBuffer.FilePosition.Column;
        ++FileBuffer.DisplayPosition.Column;
    }

    MainEditor.StatusBar->SetPosition(FileBuffer.FilePosition.Row,FileBuffer.FilePosition.Column);
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferHome  (
    VOID
    )
{
    FileBuffer.DisplayPosition.Column = TEXT_START_COLUMN;
    FileBuffer.FilePosition.Column = TEXT_START_COLUMN + 1;

    if (FileBuffer.LowVisibleRange.Column != TEXT_START_COLUMN) {
        FileBuffer.LowVisibleRange.Column = TEXT_START_COLUMN;
        FileBuffer.HighVisibleRange.Column = FileBuffer.MaxVisibleColumns;
        FileBuffer.Refresh ();
    }

    MainEditor.StatusBar->SetPosition (FileBuffer.FilePosition.Row,TEXT_START_COLUMN+1);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferEnd   (
    VOID
    )
{
    EFI_EDITOR_LINE *Line;

    Line = LineCurrent ();

    FileBuffer.FilePosition.Column = Line->Size;

    if (FileBuffer.HighVisibleRange.Column < (Line->Size - 1)) {
        FileBuffer.HighVisibleRange.Column = Line->Size - 1;
        FileBuffer.LowVisibleRange.Column = Line->Size - FileBuffer.MaxVisibleColumns;
        FileBuffer.Refresh();
    }
    FileBuffer.DisplayPosition.Column = Line->Size - FileBuffer.LowVisibleRange.Column - 1;

    MainEditor.StatusBar->SetPosition (FileBuffer.FilePosition.Row,Line->Size);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferDoCharInput (
    IN  CHAR16  Char
    )
{
    switch (Char) {
    case 0:
        break;
    case 0x08:
        FileBufferDoBackspace();
        break;
    case 0x0a:
    case 0x0d:
        FileBufferDoReturn();
        break;
    default:
        {
            EFI_EDITOR_LINE *Line;
            UINTN           FilePos;
            Line = LineCurrent ();
            if (Line->Link.Flink != MainEditor.FileImage->ListHead) {
                FilePos = FileBuffer.FilePosition.Column - 1;
                if (FileBuffer.ModeInsert || FilePos >= Line->Size-1) {
                    StrInsert (&Line->Buffer,Char,FilePos,Line->Size+1);
                    Line->Size++;
                } else {
                    Line->Buffer[FilePos] = Char;
                }
            } else {
                Line->Buffer[0] = Char;
                Line->Size++;
                FileImageCreateNode();
            }
            FileBufferRefreshCurrentLine();
            FileBufferScrollRight();
        }
        if (!MainEditor.FileModified) {
            MainEditor.FileModified = TRUE;
            MainEditor.TitleBar->Refresh();
        }
        break;
    }
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferDoBackspace (
    VOID
    )
{
    EFI_EDITOR_LINE *Line;
    EFI_EDITOR_LINE *End;
    LIST_ENTRY      *Link;
    UINTN           FileColumn;

    FileColumn = FileBuffer.FilePosition.Column - 1;

    if (FileColumn == TEXT_START_COLUMN) {
        if (FileBuffer.FilePosition.Row == 1) {
            return EFI_SUCCESS;
        }
        FileBufferScrollLeft();
        Line = LineCurrent ();

        Link = Line->Link.Flink;
        End = CR(Link,EFI_EDITOR_LINE,Link,EFI_EDITOR_LINE_LIST);
        LineCat(Line,End);

        RemoveEntryList(&End->Link);
        FreePool(End);

        --MainEditor.FileImage->NumLines;
        FileBufferRefresh();

    } else {
        Line = LineCurrent ();
        LineDeleteAt(Line,FileColumn-1);
        FileBufferRefreshCurrentLine();
        FileBufferScrollLeft();
    }
    if (!MainEditor.FileModified) {
        MainEditor.FileModified = TRUE;
        MainEditor.TitleBar->Refresh();
    }

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS  
FileBufferDoDelete (
    VOID
    )
{
    EFI_EDITOR_LINE *Line;
    EFI_EDITOR_LINE *Next;
    LIST_ENTRY      *Link;
    UINTN           FileColumn;

    Line = LineCurrent ();
    FileColumn = FileBuffer.FilePosition.Column - 1;

    if (Line->Link.Flink == MainEditor.FileImage->ListHead) {
        return EFI_SUCCESS;
    }

    if (FileColumn >= Line->Size - 1) {
        Link = Line->Link.Flink;
        if (Link->Flink == MainEditor.FileImage->ListHead) {
            return EFI_SUCCESS;
        }
        Next = CR(Link,EFI_EDITOR_LINE,Link,EFI_EDITOR_LINE_LIST);
        LineCat(Line,Next);

        RemoveEntryList(&Next->Link);
        FreePool(Next);
        --MainEditor.FileImage->NumLines;
        FileBufferRefresh();
    } else {
        LineDeleteAt (Line,FileColumn);
        FileBufferRefreshCurrentLine();
    }

    if (!MainEditor.FileModified) {
        MainEditor.FileModified = TRUE;
        MainEditor.TitleBar->Refresh();
    }

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferDoReturn (
    VOID
    )
{
    EFI_EDITOR_LINE *Line;
    EFI_EDITOR_LINE *NewLine;
    UINTN           FileColumn;

    Line = LineCurrent ();
    FileColumn = FileBuffer.FilePosition.Column - 1;

    NewLine = AllocatePool(sizeof(EFI_EDITOR_LINE));
    NewLine->Signature = EFI_EDITOR_LINE_LIST;
    NewLine->Size = Line->Size - FileColumn;
    if (NewLine->Size > 1) {
        NewLine->Buffer = PoolPrint(L"%s\0",Line->Buffer+FileColumn);
    } else {
        NewLine->Buffer = PoolPrint(L" \0");
    }

    Line->Buffer[FileColumn] = ' ';
    Line->Buffer[FileColumn+1] = 0;
    Line->Size = FileColumn + 1;

    NewLine->Link.Blink = &(Line->Link);
    NewLine->Link.Flink = Line->Link.Flink;
    Line->Link.Flink->Blink = &(NewLine->Link);
    Line->Link.Flink = &(NewLine->Link);

    ++MainEditor.FileImage->NumLines;

    BS->Stall(50);
    FileBufferRefreshDown();
    FileBufferScrollRight();
    if (!MainEditor.FileModified) {
        MainEditor.FileModified = TRUE;
        MainEditor.TitleBar->Refresh();
    }

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileBufferChangeMode    (
    VOID
    )
{

    FileBuffer.ModeInsert = !FileBuffer.ModeInsert;
    MainEditor.StatusBar->SetMode(FileBuffer.ModeInsert);
    MainEditor.StatusBar->Refresh();
    return EFI_SUCCESS;
}


#endif  /*  _LIB_FILE_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\dmpstore\dmpstore.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    dmpstore.c
    
Abstract:

    Shell app "dmpstore"



Revision History

--*/

#include "shell.h"



#define DEBUG_NAME_SIZE 1050

static CHAR16   *AttrType[] = {
    L"invalid",         /*  000 */
    L"invalid",         /*  001 */
    L"BS",              /*  010 */
    L"NV+BS",           /*  011 */
    L"RT+BS",           /*  100 */
    L"NV+RT+BS",        /*  101 */
    L"RT+BS",           /*  110 */
    L"NV+RT+BS",        /*  111 */
};

/* 
 * 
 */

EFI_STATUS
InitializeDumpStore (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
DumpVariableStore (
    VOID
    );

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeDumpStore)

EFI_STATUS
InitializeDumpStore (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeDumpStore,
        L"dmpstore",                    /*  command */
        L"dmpstore",                    /*  command syntax */
        L"Dumps variable store",        /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     * 
     */

    DumpVariableStore ();

    /* 
     *  Done
     */

    return EFI_SUCCESS;
}


VOID
DumpVariableStore (
    VOID
    )
{
    EFI_STATUS      Status;
    EFI_GUID        Guid;
    UINT32          Attributes;
    CHAR16          Name[DEBUG_NAME_SIZE/2];
    UINTN           NameSize;
    CHAR16          Data[DEBUG_NAME_SIZE/2];
    UINTN           DataSize;

    UINTN           ScreenCount;
    UINTN           TempColumn;
    UINTN           ScreenSize;
    UINTN           ItemScreenSize;
    CHAR16          ReturnStr[80];

    ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    ST->ConOut->ClearScreen (ST->ConOut);
    ScreenCount = 1;
    ScreenSize -= 2;

    Print(L"Dump NVRAM\n");
    Name[0] = 0x0000;
    do {
        NameSize = DEBUG_NAME_SIZE;
        Status = RT->GetNextVariableName(&NameSize, Name, &Guid);
        if ( Status == EFI_SUCCESS) {
            DataSize = DEBUG_NAME_SIZE;
            Status = RT->GetVariable(Name, &Guid, &Attributes, &DataSize, Data);
            if ( Status == EFI_SUCCESS) {
                /* 
                 *  Account for Print() and DumpHex() 
                 */
                ItemScreenSize = 1 + DataSize/0x10 + (((DataSize % 0x10) == 0) ? 0 : 1);
                ScreenCount += ItemScreenSize;
                if ((ScreenCount >= ScreenSize) && ScreenSize != 0) {
                    /* 
                     *  If ScreenSize == 0 we have the console redirected so don't
                     *   block updates
                     */
                    Print (L"Press Return to contiue :");
                    Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                    TempColumn = ST->ConOut->Mode->CursorColumn;
                    if (TempColumn) {
                        Print (L"\r%*a\r", TempColumn, "");
                    }
                    ScreenCount = ItemScreenSize;
                }

                /*  dump for... */
                Print (L"Variable %hs '%hg:%hs' DataSize = %x\n",
                            AttrType[Attributes & 7],
                            &Guid,
                            Name,
                            DataSize
                            );

                DumpHex (2, 0, DataSize, Data);

            }
        }
    } while (Status == EFI_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\editor.h ===
#ifndef _EDITOR_H
#define _EDITOR_H
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    Editor.h

  Abstract:
    Main include file for text editor

--*/

#include "efi.h"
#include "efilib.h"
#include "shell.h"

#define EDITOR_NAME     L"EFI Text Editor\0"
#define EDITOR_VERSION  L"0.92\0"

typedef 
EFI_STATUS
(*EFI_EDITOR_INIT) (VOID);

typedef 
EFI_STATUS
(*EFI_EDITOR_CLEANUP) (VOID);

typedef
EFI_STATUS
(*EFI_EDITOR_REFRESH) (VOID);

typedef
EFI_STATUS
(*EFI_EDITOR_HIDE) (VOID);

typedef
EFI_STATUS
(*EFI_EDITOR_INPUT) (
    VOID
    );

typedef
EFI_STATUS
(*EFI_EDITOR_HANDLE_INPUT) (
    IN  OUT     EFI_INPUT_KEY   *Key
    );

typedef struct  {
    UINTN   Row;
    UINTN   Column;
} EFI_EDITOR_POSITION;


typedef 
EFI_STATUS
(*EFI_MENU_ITEM_FUNCTION) (VOID);

typedef struct  {
    CHAR16  Name[50];
    CHAR16  Key[3];
    EFI_MENU_ITEM_FUNCTION  Function;
} MENU_ITEMS;

#define EFI_EDITOR_LINE_LIST    'eell'

typedef struct  _EFI_EDITOR_LINE {
    UINTN               Signature;
    CHAR16              *Buffer;
    UINTN               Size;
    LIST_ENTRY          Link;
} EFI_EDITOR_LINE;

typedef struct  _EFI_EDITOR_MENU_ITEM   {
    CHAR16                      *Name;
    CHAR16                      *FunctionKey;
    EFI_MENU_ITEM_FUNCTION      Function;
} EFI_EDITOR_MENU_ITEM;

typedef struct  {
    EFI_EDITOR_MENU_ITEM        *MenuItems;
    EFI_EDITOR_INIT             Init;
    EFI_EDITOR_CLEANUP          Cleanup;
    EFI_EDITOR_REFRESH          Refresh;
    EFI_EDITOR_HIDE             Hide;
    EFI_EDITOR_HANDLE_INPUT     HandleInput;
} EFI_EDITOR_MENU_BAR;

typedef struct  {
    CHAR16                  *Filename;
    EFI_EDITOR_INIT         Init;
    EFI_EDITOR_CLEANUP      Cleanup;
    EFI_EDITOR_REFRESH      Refresh;
    EFI_EDITOR_HIDE         Hide;
    EFI_STATUS  (*SetTitleString) (CHAR16*);
} EFI_EDITOR_TITLE_BAR;

#define INSERT_MODE_STR L"INS"
#define OVERWR_MODE_STR L"OVR"

typedef struct  {
    CHAR16                  *StatusString;
    CHAR16                  *ModeString;
    EFI_EDITOR_POSITION     Pos;
    EFI_EDITOR_INIT         Init;
    EFI_EDITOR_CLEANUP      Cleanup;
    EFI_EDITOR_REFRESH      Refresh;
    EFI_EDITOR_HIDE         Hide;
    EFI_STATUS  (*SetStatusString) (CHAR16*);
    EFI_STATUS  (*SetPosition) (UINTN,UINTN);
    EFI_STATUS  (*SetMode) (BOOLEAN);
} EFI_EDITOR_STATUS_BAR;


typedef struct  {
    CHAR16                  *Prompt;
    CHAR16                  *ReturnString;
    UINTN                   StringSize;
    EFI_EDITOR_INIT         Init;
    EFI_EDITOR_CLEANUP      Cleanup;
    EFI_EDITOR_REFRESH      Refresh;
    EFI_EDITOR_HIDE         Hide;
    EFI_STATUS  (*SetPrompt) (CHAR16*);
    EFI_STATUS  (*SetStringSize) (UINTN);
} EFI_EDITOR_INPUT_BAR;

typedef struct  {
    EFI_EDITOR_POSITION     DisplayPosition;
    EFI_EDITOR_POSITION     FilePosition;
    EFI_EDITOR_POSITION     LowVisibleRange;
    EFI_EDITOR_POSITION     HighVisibleRange;
    UINTN                   MaxVisibleColumns;
    UINTN                   MaxVisibleRows;
    BOOLEAN                 ModeInsert;
    LIST_ENTRY              *CurrentLine;
    EFI_EDITOR_INIT         Init;
    EFI_EDITOR_CLEANUP      Cleanup;
    EFI_EDITOR_REFRESH      Refresh;
    EFI_EDITOR_HIDE         Hide;
    EFI_EDITOR_HANDLE_INPUT HandleInput;
    EFI_STATUS  (*ClearLine) (UINTN);
    EFI_STATUS  (*SetPosition) (UINTN,UINTN);
    EFI_STATUS  (*RestorePosition) (VOID);
    EFI_STATUS  (*RefreshCurrentLine) (VOID);
} EFI_EDITOR_FILE_BUFFER;

typedef struct  {
    UINT32  Foreground:4;
    UINT32  Background:4;
} EFI_EDITOR_COLOR_ATTRIBUTES;

typedef union {
    EFI_EDITOR_COLOR_ATTRIBUTES Colors;
    UINT8                       Data;
} EFI_EDITOR_COLOR_UNION;

typedef struct  {
    UINTN   Columns;
    UINTN   Rows;
} EFI_EDITOR_TEXT_MODE;

typedef enum    {
    ASCII_FILE,
    UNICODE_FILE 
} EFI_EDITOR_FILE_TYPE;

typedef enum    {
    USE_LF,
    USE_CRLF
}   EE_NEWLINE_TYPE;


typedef struct  {
    CHAR16                  *FileName;
    LIST_ENTRY              *ListHead;
    EFI_EDITOR_LINE         *Lines;
    UINTN                   NumLines;
    EFI_EDITOR_FILE_TYPE    FileType;
    EE_NEWLINE_TYPE         NewLineType;
    EFI_LOADED_IMAGE        *LoadedImage;
    EFI_DEVICE_PATH         *DevicePath;
    EFI_FILE_HANDLE         FileHandle;
    EFI_FILE_IO_INTERFACE   *Vol;
    EFI_FILE_HANDLE         CurrentDir;
    EFI_EDITOR_CLEANUP      Cleanup;
    EFI_STATUS  (*Init) (EFI_HANDLE);
    EFI_STATUS  (*OpenFile) (VOID);
    EFI_STATUS  (*ReadFile) (VOID);
    EFI_STATUS  (*CloseFile) (VOID);
    EFI_STATUS  (*WriteFile) (VOID);
    EFI_STATUS  (*SetFilename) (CHAR16*);
    BOOLEAN                 FileIsOpen;
} EFI_EDITOR_FILE_IMAGE;



typedef struct  {
    EFI_EDITOR_TITLE_BAR    *TitleBar;
    EFI_EDITOR_MENU_BAR     *MenuBar;
    EFI_EDITOR_STATUS_BAR   *StatusBar;
    EFI_EDITOR_INPUT_BAR    *InputBar;
    EFI_EDITOR_FILE_BUFFER  *FileBuffer;
    EFI_EDITOR_COLOR_UNION  ColorAttributes;
    EFI_EDITOR_POSITION     *ScreenSize;
    EFI_EDITOR_FILE_IMAGE   *FileImage;
    BOOLEAN                 FileModified;
    EFI_EDITOR_INIT         Init;
    EFI_EDITOR_CLEANUP      Cleanup;
    EFI_EDITOR_INPUT        KeyInput;
    EFI_EDITOR_HANDLE_INPUT HandleInput;
    EFI_EDITOR_REFRESH      Refresh;
} EFI_EDITOR_GLOBAL_EDITOR;


#define TITLE_BAR_LOCATION  0
#define STATUS_BAR_LOCATION MainEditor.ScreenSize->Row - 4
#define INPUT_BAR_LOCATION  STATUS_BAR_LOCATION
#define MENU_BAR_LOCATION   MainEditor.ScreenSize->Row - 3
#define LAST_LINE_LOCATION  MainEditor.ScreenSize->Row - 1
#define TEXT_START_ROW      TITLE_BAR_LOCATION + 1
#define TEXT_START_COLUMN   0
#define TEXT_END_ROW        MainEditor.ScreenSize->Row - 4
#define MAX_TEXT_COLUMNS    MainEditor.ScreenSize->Column
#define MAX_TEXT_ROWS       TEXT_END_ROW - 1


#define MIN_POOL_SIZE       125
#define MAX_STRING_LENGTH   127
#define min(a,b) \
    (( a > b) ? b : a)
#define max(a,b) \
    (( a > b) ? a : b)

/* Global variables for input and output */
#define Out     ST->ConOut
#define In      ST->ConIn

extern  EFI_EDITOR_GLOBAL_EDITOR    MainEditor;

#define SCAN_CODE_NULL  0x00
#define SCAN_CODE_UP    0x01
#define SCAN_CODE_DOWN  0x02
#define SCAN_CODE_RIGHT 0x03
#define SCAN_CODE_LEFT  0x04
#define SCAN_CODE_HOME  0x05
#define SCAN_CODE_END   0x06
#define SCAN_CODE_INS   0x07
#define SCAN_CODE_DEL   0x08
#define SCAN_CODE_PGUP  0x09
#define SCAN_CODE_PGDN  0x0A
#define SCAN_CODE_F1    0x0B
#define SCAN_CODE_F2    0x0C
#define SCAN_CODE_F3    0x0D
#define SCAN_CODE_F4    0x0E
#define SCAN_CODE_F5    0x0F
#define SCAN_CODE_F6    0x10
#define SCAN_CODE_F7    0x11
#define SCAN_CODE_F8    0x12
#define SCAN_CODE_F9    0x13
#define SCAN_CODE_F10   0x14
#define SCAN_CODE_F11   0x15
#define SCAN_CODE_F12   0x16
#define SCAN_CODE_ESC   0x17
#define CHAR_BS         0x08
#define CHAR_LF         0x0a
#define CHAR_CR         0x0d

#define IS_VALID_CHAR(x) \
    (x == SCAN_CODE_NULL)
#define IS_DIRECTION_KEY(x) \
    ((x >= SCAN_CODE_UP) && (x <= SCAN_CODE_PGDN))
#define IS_FUNCTION_KEY(x) \
    ((x >= SCAN_CODE_F1) && x <= (SCAN_CODE_F12))
#define IS_ESCAPE(x) \
    (x == SCAN_CODE_ESC) 



#endif  /*  _EDITOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libfileimage.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libFileImage.c

  Abstract:
    Definition of the File Image - the complete image of the file that 
    resides in memory

--*/

#ifndef _LIB_FILE_IMAGE
#define _LIB_FILE_IMAGE

#include "libMisc.h"


STATIC  EFI_EDITOR_LINE*    FileImageCreateNode     (VOID);
STATIC  VOID                FileImageDeleteLines    (VOID);

#define FILE_ATTRIBUTES     EFI_FILE_MODE_READ  | \
                            EFI_FILE_MODE_WRITE | \
                            EFI_FILE_MODE_CREATE
#define FILE_READ_WRITE     EFI_FILE_MODE_READ  | \
                            EFI_FILE_MODE_WRITE
#define FILE_CREATE         EFI_FILE_MODE_READ  | \
                            EFI_FILE_MODE_WRITE | \
                            EFI_FILE_MODE_CREATE

STATIC  EFI_STATUS  FileImageInit   (EFI_HANDLE);
STATIC  EFI_STATUS  FileImageCleanup    (VOID);
STATIC  EFI_STATUS  FileImageOpen   (VOID);
STATIC  EFI_STATUS  FileImageRead   (VOID);
STATIC  EFI_STATUS  FileImageClose  (VOID);
STATIC  EFI_STATUS  FileImageWrite  (VOID);
STATIC  EFI_STATUS  FileImageSetFilename (CHAR16*);

EFI_EDITOR_FILE_IMAGE   FileImage = {
    NULL,
    NULL,
    NULL,
    0,
    UNICODE_FILE,
    USE_LF,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    FileImageCleanup,
    FileImageInit,
    FileImageOpen,
    FileImageRead,
    FileImageClose,
    FileImageWrite,
    FileImageSetFilename,
    FALSE
};

EFI_EDITOR_FILE_IMAGE   FileImageConst = {
    NULL,
    NULL,
    NULL,
    0,
    UNICODE_FILE,
    USE_LF,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    FileImageCleanup,
    FileImageInit,
    FileImageOpen,
    FileImageRead,
    FileImageClose,
    FileImageWrite,
    FileImageSetFilename,
    FALSE
};


STATIC
EFI_STATUS
FileImageInit   (
    IN  EFI_HANDLE ImageHandle
    )
{
    EFI_STATUS      Status;
    EFI_EDITOR_LINE *Line;
    CHAR16          *CurDir;
    UINTN           i;
    EFI_DEVICE_PATH *DevicePath;

    CopyMem (&FileImage, &FileImageConst, sizeof(FileImage));

    Status = BS->HandleProtocol (ImageHandle,&LoadedImageProtocol,&FileImage.LoadedImage);
    if (EFI_ERROR(Status)) {
        Print (L"Could not obtain Loaded Image Protocol\n");
        return EFI_LOAD_ERROR;
    }
    if (FileImage.LoadedImage->DeviceHandle != NULL) {
        Status = BS->HandleProtocol (FileImage.LoadedImage->DeviceHandle,&DevicePathProtocol,&FileImage.DevicePath);
        if (EFI_ERROR(Status)) {
            Print (L"Could not obtain Device Path Protocol\n");
            return EFI_LOAD_ERROR;
        }

        Status = BS->HandleProtocol (FileImage.LoadedImage->DeviceHandle,&FileSystemProtocol,&FileImage.Vol);
        if (EFI_ERROR(Status)) {
            Print (L"Could not obtain File System Protocol\n");
            return EFI_LOAD_ERROR;
        }

    } else {
        CurDir = ShellCurDir(NULL);
        if (CurDir == NULL) {
            Print (L"Could not get current working directory\n");
            return EFI_LOAD_ERROR;
        }
        for (i=0; i < StrLen(CurDir) && CurDir[i] != ':'; i++);
        CurDir[i] = 0;
        DevicePath = (EFI_DEVICE_PATH *)ShellGetMap (CurDir);

        if (DevicePath == NULL) {
            Print (L"Could not open volume for the filesystem\n");
            return EFI_LOAD_ERROR;
        }

        Status = LibDevicePathToInterface (&FileSystemProtocol, DevicePath, &FileImage.Vol);

        if (EFI_ERROR(Status)) {
            Print (L"Could not obtain File System Protocol\n");
            return EFI_LOAD_ERROR;
        }
    }

    Status = FileImage.Vol->OpenVolume(FileImage.Vol,&FileImage.CurrentDir);
    if (EFI_ERROR(Status)) {
        Print (L"Could not open volume for the filesystem\n");
        return EFI_LOAD_ERROR;
    }

    FileImage.FileName = PoolPrint(L"NewFile.txt");

    FileImage.ListHead = AllocatePool(sizeof(LIST_ENTRY));
    InitializeListHead(FileImage.ListHead);

    Line = FileImageCreateNode();
    MainEditor.FileBuffer->CurrentLine = FileImage.ListHead->Flink;

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileImageOpen (
    VOID
    ) 
{
    EFI_STATUS  Status;

    Status = FileImage.CurrentDir->Open (FileImage.CurrentDir,&FileImage.FileHandle,FileImage.FileName,FILE_ATTRIBUTES,0);

    if (EFI_ERROR(Status)) {
        MainEditor.StatusBar->SetStatusString(L"File Could Not be Opened");
        return EFI_NOT_FOUND;
    }
    FileImage.FileIsOpen = TRUE;

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileImageCleanup    (
    VOID
    )
{
    EFI_EDITOR_LINE *Blank;

    FreePool (FileImage.FileName);
    FileImageDeleteLines ();

    Blank = LineCurrent();
    RemoveEntryList(&Blank->Link);
    FreePool(Blank->Buffer);
    FreePool(Blank);
    FreePool(FileImage.ListHead);

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileImageRead ( 
    VOID
    )
{
    EFI_EDITOR_LINE     *Line = NULL;
    UINTN               i = 0;
    UINTN               LineSize;
    VOID                *FileBuffer;
    CHAR16              *UnicodeBuffer;
    CHAR8               *AsciiBuffer;
    LIST_ENTRY          *Blank;
    UINTN               FileSize = 0x100000;

    FileBuffer = AllocatePool(FileSize);

    if ( FileBuffer == NULL ) {
        EditorError(EFI_OUT_OF_RESOURCES,L"Could not allocate File Buffer");
        return EFI_SUCCESS;
    }

    FileImage.FileHandle->Read(FileImage.FileHandle,&FileSize,FileBuffer);

    if (FileSize == 0) {
        FreePool (FileBuffer);
        return EFI_SUCCESS;
    }

    AsciiBuffer = FileBuffer;
    if (AsciiBuffer[0] == 0xff && AsciiBuffer[1] == 0xfe) {
        FileImage.FileType = UNICODE_FILE;
        FileSize /= 2;
        UnicodeBuffer = FileBuffer;
        ++UnicodeBuffer;
        FileSize--;
    } else {
        FileImage.FileType = ASCII_FILE;
    }

    FileImageDeleteLines ();
    Blank = FileImage.ListHead->Flink;
    RemoveEntryList (Blank);

    for (i = 0; i < FileSize; i++) {
        for (LineSize = i; LineSize < FileSize; LineSize++) {
            if (FileImage.FileType == ASCII_FILE) {
                if (AsciiBuffer[LineSize] == CHAR_CR)   {
                    FileImage.NewLineType = USE_CRLF;
                    break;
                } else if (AsciiBuffer[LineSize] == CHAR_LF)    {
                    break;
                }
            } else {
                if (UnicodeBuffer[LineSize] == CHAR_CR) {
                    FileImage.NewLineType = USE_CRLF;
                    break;
                } else if (UnicodeBuffer[LineSize] == CHAR_LF)  {
                    break;
                }
            }
        }

        LineSize -= i;
        
        Line = FileImageCreateNode ();

        if (Line == NULL) {
            EditorError(EFI_OUT_OF_RESOURCES,L"FileImageRead: Could Not Allocate another Line");
            break;
        }

        Line->Buffer = AllocateZeroPool(LineSize*2+2);
        if (Line->Buffer == NULL) {
            EditorError(EFI_OUT_OF_RESOURCES,L"FileImageRead: Could not allocate buffer");
            RemoveEntryList(&Line->Link);
            break;
        }
        
        for (Line->Size = 0; Line->Size < LineSize; Line->Size++) {
            if (FileImage.FileType == ASCII_FILE) {
                Line->Buffer[Line->Size] = (CHAR16)AsciiBuffer[i];
            } else {
                Line->Buffer[Line->Size] = UnicodeBuffer[i];
            }
            i++;
            
        }
            
        Line->Size++;
        if (FileImage.NewLineType == USE_CRLF) {
            ++i;
        }
                
        Line->Buffer[LineSize] = 0;

    }

    FreePool (FileBuffer);

    InsertTailList(FileImage.ListHead,Blank);

    MainEditor.FileBuffer->FilePosition.Row = 1;
    MainEditor.FileBuffer->FilePosition.Column = 1;

    MainEditor.FileBuffer->CurrentLine = FileImage.ListHead->Flink;

    MainEditor.StatusBar->SetPosition(1,1);

    UnicodeBuffer = PoolPrint(L"%d Lines Read",FileImage.NumLines);
    MainEditor.StatusBar->SetStatusString(UnicodeBuffer);
    FreePool (UnicodeBuffer);

    FileImage.FileHandle->Close(FileImage.FileHandle);
    FileImage.FileIsOpen = FALSE;


    return EFI_SUCCESS;
}


STATIC
VOID
GetNewLine  (
    CHAR8   *Buffer,
    UINT8   *Size
    )
{
    UINT8           size = 0;

    if (FileImage.NewLineType == USE_CRLF) {
        Buffer[size] = 0x0d;
        size++;
        if (FileImage.FileType == UNICODE_FILE) {
            Buffer[size] = 0x00;
            size++;
        }
    }
    Buffer[size] = 0x0a;
    size++;
    if (FileImage.FileType == UNICODE_FILE) {
        Buffer[size] = 0x00;
        size++;
    }
    *Size = size;
}

STATIC
EFI_STATUS  
FileImageWrite (
    VOID
    )
{
    LIST_ENTRY      *Link;
    EFI_EDITOR_LINE *Line;
    CHAR16          *Str;
    VOID            *Buffer;

    EFI_STATUS      Status;
    UINTN           Length = 0;
    UINTN           NumLines = 1;
    CHAR8           NewLineBuffer[4];
    UINT8           NewLineSize;

    Status = FileImage.CurrentDir->Open (FileImage.CurrentDir,&FileImage.FileHandle,FileImage.FileName,FILE_READ_WRITE,0);
    if (!EFI_ERROR(Status)) {
        Status = FileImage.FileHandle->Delete (FileImage.FileHandle);
        if (EFI_ERROR(Status)) {
            EditorError(Status,L"Error Deleting File");
/*           return EFI_SUCCESS; */
        }
    }

    Status = FileImage.CurrentDir->Open(FileImage.CurrentDir,&FileImage.FileHandle,FileImage.FileName,FILE_CREATE,0);
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"Error Accessing File");
        return EFI_SUCCESS;
    }

    GetNewLine(NewLineBuffer,&NewLineSize);

    if (FileImage.FileType == UNICODE_FILE) {
        UINT8   Marker1 = 0xff,Marker2 = 0xfe;
        Length = 1;
        FileImage.FileHandle->Write(FileImage.FileHandle,&Length,&Marker1);
        Length = 1;
        FileImage.FileHandle->Write(FileImage.FileHandle,&Length,&Marker2);
    }

    for (Link = FileImage.ListHead->Flink;
            Link != FileImage.ListHead->Blink; Link = Link->Flink) {
        Line = CR(Link,EFI_EDITOR_LINE,Link,EFI_EDITOR_LINE_LIST);

        Line->Buffer[Line->Size-1] = 0;
        if (FileImage.FileType == ASCII_FILE) {
            (CHAR8*)Buffer = AllocatePool(Line->Size);
            UnicodeToAscii(Line->Buffer,Line->Size,(CHAR8*)Buffer);
            Length = Line->Size - 1;
        } else {
            Length = (Line->Size*2) - 2;
            (CHAR16*)Buffer = PoolPrint(L"%s",Line->Buffer);
        }

        Status = FileImage.FileHandle->Write(FileImage.FileHandle,&Length,Buffer);
        FreePool(Buffer);
        if (EFI_ERROR(Status)) {
            EditorError(Status,L"Error Writing File");
            return EFI_SUCCESS;
        }
        Length = NewLineSize;
        Status = FileImage.FileHandle->Write(FileImage.FileHandle,&Length,NewLineBuffer);
        if (EFI_ERROR(Status)) {
            EditorError(Status,L"Error Writing Newline");
            return EFI_SUCCESS;
        }

        NumLines++;
    }

    MainEditor.FileModified = FALSE;
    MainEditor.TitleBar->Refresh();

    Str = PoolPrint(L"Wrote %d Lines",NumLines);
    MainEditor.StatusBar->SetStatusString(Str);
    FreePool(Str);

    Status = FileImage.FileHandle->Close(FileImage.FileHandle);
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Error Closing File");
        return EFI_SUCCESS;
    }

    return  EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileImageClose ( 
    VOID 
    )
{
    FileImageDeleteLines ();

    MainEditor.FileBuffer->FilePosition.Row = 1;
    MainEditor.FileBuffer->FilePosition.Column = 1;
    MainEditor.StatusBar->SetPosition(1,1);
    MainEditor.FileBuffer->SetPosition(TEXT_START_ROW,TEXT_START_COLUMN);

    MainEditor.FileModified = FALSE;
    MainEditor.TitleBar->Refresh();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileImageSetFilename    (
    IN  CHAR16* Filename
    )
{
    if (Filename == NULL) {
        return EFI_LOAD_ERROR;
    }
    if (FileImage.FileName != NULL) {
        FreePool(FileImage.FileName);
    }

    FileImage.FileName = PoolPrint(L"%s",Filename);
    return EFI_SUCCESS;
}

STATIC
VOID
FileImageDeleteLines (
    VOID
    )
{
    EFI_EDITOR_LINE *Line;
    LIST_ENTRY      *Blank;
    LIST_ENTRY      *Item;

    Blank = FileImage.ListHead->Blink;
    RemoveEntryList(Blank);

    while (!IsListEmpty(FileImage.ListHead)) {
        Item = FileImage.ListHead->Flink;

        RemoveEntryList(Item);

        Line = CR(Item,EFI_EDITOR_LINE,Link,EFI_EDITOR_LINE_LIST);

        if (Line->Buffer != NULL && Line->Buffer != (CHAR16*)BAD_POINTER) {
            FreePool(Line->Buffer);
        }

        FreePool (Line);
        FileImage.NumLines--;
    }
    InsertTailList(FileImage.ListHead,Blank);
    MainEditor.FileBuffer->CurrentLine = Blank;
    FileImage.NumLines = 1;
}

STATIC
EFI_EDITOR_LINE*
FileImageCreateNode  (
    VOID
    )
{
    EFI_EDITOR_LINE     *Line;

    Line = AllocatePool (sizeof(EFI_EDITOR_LINE));

    if ( Line == NULL ) {
        EditorError(EFI_OUT_OF_RESOURCES,L"FileImageCreateNode: Could not allocate Node");
        return NULL;
    }
    
    Line->Signature = EFI_EDITOR_LINE_LIST;
    Line->Size = 1;
    Line->Buffer = PoolPrint(L" \0");
    FileImage.NumLines++;

    InsertTailList(FileImage.ListHead,&Line->Link);

    return Line;
}


#endif  /*  _LIB_FILE_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libmisc.h ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libMisc.h

  Abstract:
    Definitions for various line and string routines

--*/

#include "editor.h"


extern  UINTN   StrInsert (CHAR16**,CHAR16,UINTN,UINTN);
extern  UINTN   StrnCpy (CHAR16*,CHAR16*,UINTN,UINTN);
extern  VOID    LineCat (EFI_EDITOR_LINE*,EFI_EDITOR_LINE*);
extern  VOID    LineDeleteAt (EFI_EDITOR_LINE*,UINTN);

extern  VOID    LineSplit   (EFI_EDITOR_LINE*,UINTN,EFI_EDITOR_LINE*);
extern  VOID    LineMerge   (EFI_EDITOR_LINE*,UINTN,EFI_EDITOR_LINE*,UINTN);
extern  EFI_EDITOR_LINE*    LineDup (EFI_EDITOR_LINE*);
extern  EFI_EDITOR_LINE*    LineNext (VOID);
extern  EFI_EDITOR_LINE*    LinePrevious (VOID);
extern  EFI_EDITOR_LINE*    LineAdvance (UINTN Count);
extern  EFI_EDITOR_LINE*    LineRetreat (UINTN Count);
extern  EFI_EDITOR_LINE*    LineFirst (VOID);
extern  EFI_EDITOR_LINE*    LineLast (VOID);
extern  EFI_EDITOR_LINE*    LineCurrent (VOID);

extern  INTN    StrStr (CHAR16*,CHAR16*);
extern  UINTN   UnicodeToAscii(CHAR16*,UINTN,CHAR8*);

extern  VOID    EditorError (EFI_STATUS,CHAR16*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libmenubar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libMenuBar.c

  Abstract:
    Definition of the Menu Bar for the text editor

--*/


#ifndef _LIB_MENU_BAR
#define _LIB_MENU_BAR

#include "libMisc.h"

STATIC  EFI_STATUS  MenuInit (VOID);
STATIC  EFI_STATUS  MenuCleanup (VOID);
STATIC  EFI_STATUS  MenuRefresh (VOID);
STATIC  EFI_STATUS  MenuHandleInput (EFI_INPUT_KEY*);
STATIC  EFI_STATUS  MenuHide(VOID);
STATIC  EFI_STATUS  NewFile (VOID);
STATIC  EFI_STATUS  OpenFile(VOID);
STATIC  EFI_STATUS  CloseFile(VOID);
STATIC  EFI_STATUS  SaveFile(VOID);
STATIC  EFI_STATUS  SaveFileAs(VOID);
STATIC  EFI_STATUS  ExitEditor(VOID);

STATIC  EFI_STATUS  CutLine(VOID);
STATIC  EFI_STATUS  PasteLine(VOID);

STATIC  EFI_STATUS  SearchFind(VOID);
STATIC  EFI_STATUS  SearchReplace(VOID);
STATIC  EFI_STATUS  GotoLine(VOID);

STATIC  EFI_STATUS  SetupColors(VOID);
STATIC  EFI_STATUS  SetupScreen(VOID);
STATIC  EFI_STATUS  FileType(VOID);

EFI_EDITOR_MENU_ITEM    MainMenuItems[] = {
    {   L"Open File",       L"F1",  OpenFile        },
    {   L"Save File",       L"F2",  SaveFile        },
    {   L"Exit",            L"F3",  ExitEditor      },

    {   L"Cut Line",        L"F4",  CutLine         },
    {   L"Paste Line",      L"F5",  PasteLine       },
    {   L"Go To Line",      L"F6",  GotoLine        },

    {   L"Search",          L"F7",  SearchFind      },
    {   L"Search/Replace",  L"F8",  SearchReplace   },
    {   L"File Type",       L"F9",  FileType        },

    {   L"",                L"",    NULL            }
};

EFI_EDITOR_MENU_BAR     MainMenuBar = {
    MainMenuItems,
    MenuInit,
    MenuCleanup,
    MenuRefresh,
    MenuHide,
    MenuHandleInput 
};

extern EFI_STATUS   FileBufferRefreshDown(VOID);
extern  EFI_STATUS  FileBufferHome  (VOID);

#define FileIsModified() \
    MainEditor.FileModified

STATIC  BOOLEAN EditorIsExiting;
#define IS_EDITOR_EXITING (EditorIsExiting == TRUE)

STATIC  EFI_EDITOR_LINE *MenuCutLine;

STATIC
EFI_STATUS
MenuInit    (
    VOID
    ) 
{
    EditorIsExiting = FALSE;
    MenuCutLine     = NULL;
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS  
MenuCleanup (
    VOID
    )
{
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MenuRefresh (
    VOID
    )
{
    EFI_EDITOR_MENU_ITEM    *Item;
    UINTN                   Col = 0;
    UINTN                   Row = MENU_BAR_LOCATION;
    UINTN                   Width;

    MenuHide();

    for (Item = MainMenuBar.MenuItems;Item->Function;Item++) {

        Width = max((StrLen(Item->Name)+6),20);
        if (((Col + Width) >= MAX_TEXT_COLUMNS)) {
            Row++;
            Col = 0;
        }
        PrintAt(Col,Row,L"%E%s%N  %H%s%N  ",Item->FunctionKey,Item->Name);
        Col += Width;
    }

    MainEditor.FileBuffer->RestorePosition();

    return  EFI_SUCCESS;
}


STATIC
EFI_STATUS
MenuHandleInput (
    EFI_INPUT_KEY   *Key
    )
{
    EFI_EDITOR_MENU_ITEM    *Item;
    EFI_STATUS              Status;
    UINTN   i = 0;
    UINTN   NumItems = 0;


    NumItems = sizeof(MainMenuItems)/sizeof(EFI_EDITOR_MENU_ITEM) - 1;

    Item = MainMenuBar.MenuItems;

    i = Key->ScanCode - SCAN_CODE_F1;

    if (i > (NumItems - 1)) {
        return EFI_SUCCESS;
    }

    Item = &MainMenuBar.MenuItems[i];

    Status = Item->Function();
    MenuRefresh();
    return  (IS_EDITOR_EXITING) ? EFI_LOAD_ERROR : EFI_SUCCESS;
}

STATIC
EFI_STATUS
OpenFile    (
    VOID
    )
{
    EFI_STATUS  Status = EFI_SUCCESS;
    CHAR16      *Filename;

    MainEditor.InputBar->SetPrompt(L"File Name to Open: ");
    MainEditor.InputBar->SetStringSize (125);
    Status = MainEditor.InputBar->Refresh ();
    if ( EFI_ERROR(Status) ) {
        return EFI_SUCCESS;
    }
    Filename = MainEditor.InputBar->ReturnString;

    if ( Filename == NULL ) {
        MainEditor.StatusBar->SetStatusString(L"Filename was NULL");
        return EFI_SUCCESS;

    }
    Status = MainEditor.FileImage->SetFilename (Filename);
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Set Filename");
        return EFI_NOT_FOUND;
    }

    Status = MainEditor.FileImage->OpenFile ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Open File");
        return EFI_NOT_FOUND;
    }

    
    Status = MainEditor.FileImage->ReadFile ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Read File");
        return EFI_NOT_FOUND;
    }
    
    Status = MainEditor.FileBuffer->Refresh();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Refresh");
        return EFI_NOT_FOUND;
    }

    MainEditor.FileBuffer->SetPosition(TEXT_START_ROW,TEXT_START_COLUMN);

    MainEditor.TitleBar->SetTitleString(Filename);
    
    MainEditor.Refresh();

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
CloseFile   (
    VOID
    )
{
    EFI_INPUT_KEY   Key;
    EFI_STATUS      Status;
    BOOLEAN         Done = FALSE;


    if (FileIsModified()) {
        MenuHide();
        PrintAt(0,MENU_BAR_LOCATION,L"%EY%H  Yes%N  %EN%N  %HNo%N   %EQ%N  %HCancel%N");
        MainEditor.StatusBar->SetStatusString(L"File Modified.  Save? ");

        while (!Done) {
            WaitForSingleEvent(In->WaitForKey,0);
            Status = In->ReadKeyStroke(In,&Key);
            if ( EFI_ERROR(Status) || Key.ScanCode != 0 ) {
                continue;
            }
            switch (Key.UnicodeChar) {
            case 'q':
            case 'Q':
                Status = EFI_NOT_READY;
                Done = TRUE;
                break;
            case 'n':
            case 'N':
                Status = EFI_SUCCESS;
                Done = TRUE;
                break;
            case 'y':
            case 'Y':
                Status = SaveFile();
                Done = TRUE;
                break;
            default:
                break;
            }

        }
        MenuRefresh();
    }
    if (!EFI_ERROR(Status)) {
        MainEditor.FileImage->CloseFile();
        MainEditor.FileBuffer->Refresh ();
        MainEditor.TitleBar->SetTitleString(L"");
    } else {
        EditorIsExiting = FALSE;
    }

    MainEditor.StatusBar->Refresh();
    MenuRefresh();

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
SaveFile    (
    VOID
    )
{
    CHAR16      *Output;
    EFI_STATUS  Status;

    if (!MainEditor.FileModified) {
        return EFI_SUCCESS; 
    }

    Output = PoolPrint (L"File To Save: [%s]",MainEditor.FileImage->FileName);

    MainEditor.InputBar->SetPrompt(Output);
    MainEditor.InputBar->SetStringSize(100);

    Status = MainEditor.InputBar->Refresh();
    FreePool(Output);

    if (!EFI_ERROR(Status)) {
        if (MainEditor.InputBar->StringSize > 0) {
            MainEditor.FileImage->SetFilename(MainEditor.InputBar->ReturnString);
            FreePool(MainEditor.InputBar->ReturnString);
        }
        Status = MainEditor.FileImage->WriteFile();
    }

    return Status; 
}


STATIC
EFI_STATUS 
ExitEditor (
    VOID
    ) 
{ 
    EditorIsExiting = TRUE;
    CloseFile();
    return EFI_SUCCESS;
}

    
STATIC
EFI_STATUS 
MenuHide    (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine (MENU_BAR_LOCATION);
    MainEditor.FileBuffer->ClearLine (MENU_BAR_LOCATION+1);
    MainEditor.FileBuffer->ClearLine (MENU_BAR_LOCATION+2);
    return  EFI_SUCCESS;
}


STATIC
EFI_STATUS
CutLine (
    VOID
    )
{
    LIST_ENTRY  *Link;
    LIST_ENTRY  *Next;
    LIST_ENTRY  *Prev;
    EFI_EDITOR_LINE *Line;


    Link = MainEditor.FileBuffer->CurrentLine;

    if (Link == MainEditor.FileImage->ListHead->Blink) {
        return EFI_SUCCESS;
    }

    if (MenuCutLine) {
        FreePool(MenuCutLine);
    }
    Line = CR(Link,EFI_EDITOR_LINE,Link,EFI_EDITOR_LINE_LIST);

    MenuCutLine = LineDup(Line);

    Next = Link->Flink;
    Prev = Link->Blink;
    Prev->Flink = Next;
    Next->Blink = Prev;

    Link->Flink = Link;
    Link->Blink = Link;

    MainEditor.FileImage->NumLines--;
    MainEditor.FileBuffer->CurrentLine = Next;
    FileBufferHome();

    FileBufferRefreshDown();

    FreePool(Line);

    if (!FileIsModified()) {
        MainEditor.FileModified = TRUE;
        MainEditor.TitleBar->Refresh();
    }
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS  
PasteLine   (
    VOID
    )
{
    LIST_ENTRY  *Link;
    EFI_EDITOR_LINE *Line;

    if (!MenuCutLine) {
        return EFI_SUCCESS;
    }

    Line = LineDup(MenuCutLine);

    Link = MainEditor.FileBuffer->CurrentLine;
    Line->Link.Blink = Link->Blink;
    Line->Link.Flink = Link;

    Link->Blink->Flink = &Line->Link;
    Link->Blink = &Line->Link;

    MainEditor.FileImage->NumLines++;
    MainEditor.FileBuffer->CurrentLine = &Line->Link;
    FileBufferHome();
    FileBufferRefreshDown();
    return EFI_SUCCESS;
}



STATIC
EFI_STATUS
GotoLine    (
    VOID
    )
{
    CHAR16      *Str;
    UINTN       Row;
    UINTN       Current;
    UINTN       RowRange;
    BOOLEAN     Refresh = FALSE;

    MenuHide ();
    Str = PoolPrint(L"Go To Line: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(5);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize > 0 ) {
        Row = Atoi(MainEditor.InputBar->ReturnString);
    }
    if ( Row > MainEditor.FileImage->NumLines ) {
        return EFI_SUCCESS;
    }

    Current = MainEditor.FileBuffer->FilePosition.Row;
    RowRange = MainEditor.FileBuffer->MaxVisibleRows;

    if (Row == Current ) {
        return EFI_SUCCESS;
    }

    if (Row < Current) {
        LineRetreat(Current-Row);
        if ( Row < MainEditor.FileBuffer->LowVisibleRange.Row ) {
            MainEditor.FileBuffer->LowVisibleRange.Row = Row-1;
            MainEditor.FileBuffer->HighVisibleRange.Row = min(Row+RowRange-1,MainEditor.FileImage->NumLines);
            Refresh = TRUE;
        }
    } else {
        LineAdvance(Row - Current);
        if ( Row > MainEditor.FileBuffer->HighVisibleRange.Row ) {
            MainEditor.FileBuffer->LowVisibleRange.Row = Row - 1;
            MainEditor.FileBuffer->HighVisibleRange.Row = min(Row+RowRange-1,MainEditor.FileImage->NumLines);
            Refresh = TRUE;
        }
    }
    if (MainEditor.FileBuffer->LowVisibleRange.Column > TEXT_START_COLUMN ) {
        MainEditor.FileBuffer->LowVisibleRange.Column = TEXT_START_COLUMN;
        MainEditor.FileBuffer->HighVisibleRange.Column = MAX_TEXT_COLUMNS;
        Refresh = TRUE;
    }

    Current = MainEditor.FileBuffer->LowVisibleRange.Row;

    MainEditor.FileBuffer->FilePosition.Row = Row;

    MainEditor.FileBuffer->SetPosition(Row-Current+TEXT_START_ROW,TEXT_START_COLUMN);
    MainEditor.StatusBar->SetPosition(Row,TEXT_START_COLUMN+1);

    if ( Refresh = TRUE ) {
        MainEditor.FileBuffer->Refresh();
    }

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
SearchFind  (
    VOID
    )
{
    CHAR16          *Str;
    UINTN           Pos;
    EFI_EDITOR_LINE *Line;
    UINTN           LineNumber;
    UINTN           MaxRows;
    UINTN           NumLines;
    BOOLEAN         Refresh = FALSE;
    BOOLEAN         Found = FALSE;

    Str = PoolPrint(L"Enter Search String: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(50);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize == 0) {
        return EFI_SUCCESS;
    }
    Str = PoolPrint(L"%s\0",MainEditor.InputBar->ReturnString);

    Line = LineCurrent();

    MaxRows = MainEditor.FileBuffer->MaxVisibleRows;
    NumLines = MainEditor.FileImage->NumLines;
    LineNumber = MainEditor.FileBuffer->FilePosition.Row;

    while (TRUE) {
        Pos = 0;
        if (StrLen(Line->Buffer) != 0) {
            Pos = StrStr (Line->Buffer,Str);
        }

        if (Pos == 0) {
            if (LineNumber == MainEditor.FileImage->NumLines) {
                break;
            } else {
                LineNumber++;
            }
            Line = LineNext();
            continue;
        }
        MainEditor.FileBuffer->FilePosition.Row = LineNumber;
        MainEditor.FileBuffer->FilePosition.Column = Pos;
        MainEditor.StatusBar->SetPosition(LineNumber,Pos);
        LineAdvance(LineNumber-MainEditor.FileBuffer->FilePosition.Row);

        if (LineNumber > MainEditor.FileBuffer->HighVisibleRange.Row ||
            LineNumber < MainEditor.FileBuffer->LowVisibleRange.Row) {
            MainEditor.FileBuffer->LowVisibleRange.Row = LineNumber - 1;
            MainEditor.FileBuffer->HighVisibleRange.Row = min(LineNumber+MaxRows-2,NumLines);
            Refresh = TRUE;
        }
        if (Pos > MainEditor.FileBuffer->HighVisibleRange.Column || 
            Pos < MainEditor.FileBuffer->LowVisibleRange.Column) {
            MainEditor.FileBuffer->LowVisibleRange.Column = Pos - 1;
            MainEditor.FileBuffer->HighVisibleRange.Column = Pos + MAX_TEXT_COLUMNS - 1;
            Refresh = TRUE;
        }
        Pos = Pos - MainEditor.FileBuffer->LowVisibleRange.Column - 1;
        LineNumber = LineNumber - MainEditor.FileBuffer->LowVisibleRange.Row;
        MainEditor.FileBuffer->SetPosition(LineNumber+TEXT_START_ROW,Pos+TEXT_START_COLUMN);

        if (Refresh) {
            MainEditor.FileBuffer->Refresh();
        }

        Found = TRUE;
        break;
    }

    if (!Found) {
        MainEditor.StatusBar->SetStatusString(L"Search String Not Found");
    }
    FreePool(Str);
    return EFI_SUCCESS; 
}

STATIC
BOOLEAN
CheckReplace    (
    VOID
    )
{
    EFI_INPUT_KEY   Key;
    EFI_STATUS      Status = EFI_SUCCESS;
    BOOLEAN         Done = FALSE;

    MenuHide();
    PrintAt(0,MENU_BAR_LOCATION,L"%EY%N%H  Yes%N  %EN%N  %HNo%N   %EQ%N  %HCancel%N");
    MainEditor.StatusBar->SetStatusString(L"Replace? ");

    while (!Done) {
        WaitForSingleEvent(In->WaitForKey,0);
        Status = In->ReadKeyStroke(In,&Key);
        if (EFI_ERROR(Status) || Key.ScanCode != 0) {
            continue;
        }
        switch (Key.UnicodeChar) {
        case 'y':
        case 'Y':
            Status = EFI_SUCCESS;
            Done = TRUE;
            break;
        case 'q':
        case 'Q':
            Status = EFI_NOT_READY;
            Done = TRUE;
            break;
        case 'n':
        case 'N':
            Status = EFI_NOT_READY;
            Done = TRUE;
            break;
        default:
            break;
        }

    }
    MenuRefresh();

    MainEditor.StatusBar->SetStatusString(L" ");

    return (Status == EFI_SUCCESS);
}

STATIC
BOOLEAN
GetInputStrings (
    OUT CHAR16  **Search,
    OUT CHAR16  **Replace
    )
{
    CHAR16  *Str;

    Str = PoolPrint(L"Enter Search String: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(50);
    MainEditor.InputBar->Refresh();

    if ( MainEditor.InputBar->StringSize == 0 ) {
        return FALSE;
    }
    *Search = PoolPrint(L"%s",MainEditor.InputBar->ReturnString);


    Str = PoolPrint(L"Replace With: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(50);
    MainEditor.InputBar->Refresh();

    *Replace = PoolPrint(L"%s",MainEditor.InputBar->ReturnString);

    return TRUE;
}

STATIC
EFI_STATUS
SearchReplace   (
    VOID
    )
{
    CHAR16          *Search;
    CHAR16          *Replacement;
    UINTN           SearchLength;
    UINTN           ReplaceLength;
    UINTN           LinePos;
    UINTN           Pos;
    EFI_EDITOR_LINE *Line;
    UINTN           LineNumber;
    UINTN           MaxRows;
    BOOLEAN         Refresh = FALSE;
    BOOLEAN         Found = FALSE;

    if (!GetInputStrings(&Search,&Replacement)) {
        return EFI_SUCCESS;
    }

    Line = LineCurrent();

    MaxRows = MainEditor.FileBuffer->MaxVisibleRows;

    SearchLength = StrLen(Search);
    ReplaceLength = StrLen(Replacement);

    Pos = MainEditor.FileBuffer->FilePosition.Column - 1;

    LineNumber = MainEditor.FileBuffer->FilePosition.Row - 1;
    while (TRUE) {
        LinePos = StrStr (Line->Buffer+Pos,Search);
        if (LinePos == 0) {
            if (LineNumber == MainEditor.FileImage->NumLines) {
                break;
            } else {
                LineNumber++;
            }
            Line = LineNext();
            Pos = 0;
            continue;
        }
        Pos += LinePos;

        LinePos = Pos + SearchLength - 1;
        MainEditor.FileBuffer->FilePosition.Row = LineNumber;
        MainEditor.FileBuffer->FilePosition.Column = Pos;

        if (LineNumber > MainEditor.FileBuffer->HighVisibleRange.Row ||
            LineNumber < MainEditor.FileBuffer->LowVisibleRange.Row) {
            MainEditor.FileBuffer->LowVisibleRange.Row = LineNumber - 1;
            MainEditor.FileBuffer->HighVisibleRange.Row = min(LineNumber+MaxRows-2,MainEditor.FileImage->NumLines+1);
            Refresh = TRUE;
        }
        if (Pos > MainEditor.FileBuffer->HighVisibleRange.Column || 
            Pos < MainEditor.FileBuffer->LowVisibleRange.Column) {
            MainEditor.FileBuffer->LowVisibleRange.Column = Pos - 1;
            MainEditor.FileBuffer->HighVisibleRange.Column = Pos + MAX_TEXT_COLUMNS - 1;
            Refresh = TRUE;
        }
        Pos = Pos - MainEditor.FileBuffer->LowVisibleRange.Column - 1;
        MainEditor.FileBuffer->SetPosition(LineNumber-MainEditor.FileBuffer->LowVisibleRange.Row+TEXT_START_ROW,Pos+TEXT_START_COLUMN);

        if (Refresh) {
            MainEditor.FileBuffer->Refresh();
        }

        Found = TRUE;
        if (!CheckReplace()) {
            break;
        }
        {
            CHAR16  *Tail;
            UINTN   Size = Line->Size*2;
            INTN    Diff = ReplaceLength - SearchLength;

            if (Diff > 0) {
                Line->Buffer = ReallocatePool(Line->Buffer,Size,Size+2*Diff);
            }

            Tail = PoolPrint(L"%s%s",Replacement,Line->Buffer+LinePos);

            Size = LinePos - SearchLength;
            StrCpy(Line->Buffer+Size,Tail);

            FreePool(Tail);
            Line->Size += Diff;
            Pos = LinePos + Diff;
        }
        if (!MainEditor.FileModified) {
            MainEditor.FileModified = TRUE;
            MainEditor.TitleBar->Refresh();
        }
        MainEditor.FileBuffer->RefreshCurrentLine();
    }

    if (!Found) {
        MainEditor.StatusBar->SetStatusString(L"Search String Not Found");
    }
    return EFI_SUCCESS; 
}

STATIC  
EFI_STATUS  
FileType    (
    VOID
    )
{
    CHAR16  *FT;
    CHAR16  *NewType;
    CHAR16  *A = L"ASCII";
    CHAR16  *U = L"UNICODE";
    EFI_INPUT_KEY   Key;
    EFI_STATUS      Status = EFI_SUCCESS;
    BOOLEAN         Done = FALSE;
    BOOLEAN         Choice;

    Choice = MainEditor.FileImage->FileType;

    if (Choice == ASCII_FILE) {
        NewType = A;
    } else {
        NewType = U;
    }
    FT = PoolPrint(L"File is %s",NewType);
    MainEditor.StatusBar->SetStatusString(FT);
    FreePool(FT);

    MenuHide();
    PrintAt(0,MENU_BAR_LOCATION,L"%E U %N%H  Set as UNICODE File  %N  %E A %N  %HSet As ASCII File%N   %EQ%N  %HCancel%N");

    while (!Done) {
        WaitForSingleEvent(In->WaitForKey,0);
        Status = In->ReadKeyStroke(In,&Key);
        if (EFI_ERROR(Status) || Key.ScanCode != 0) {
            continue;
        }
        switch (Key.UnicodeChar) {
        case 'u':
        case 'U':
            Choice = UNICODE_FILE;
            Done = TRUE;
            break;
        case 'a':
        case 'A':
            Choice = ASCII_FILE;
            Done = TRUE;
            break;
        case 'q':
        case 'Q':
            Done = TRUE;
            break;
        default:
            break;
        }

    }
    MenuRefresh();

    if (Choice != MainEditor.FileImage->FileType) {
        MainEditor.FileImage->FileType = Choice;
        NewType = (Choice == ASCII_FILE) ? A : U;
        FT = PoolPrint(L"File Type Changed to %s",NewType);
        MainEditor.StatusBar->SetStatusString(FT);
        FreePool(FT);
    }

    return EFI_SUCCESS;
}

#endif  /* _LIB_MENU_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libmisc.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libMisc.c

  Abstract:
    Implementation of various string and line routines

--*/

#include "libMisc.h"

#ifndef _LIB_MISC
#define _LIB_MISC

UINTN   StrInsert (CHAR16**,CHAR16,UINTN,UINTN);
UINTN   StrnCpy (CHAR16*,CHAR16*,UINTN,UINTN);
INTN    StrStr (CHAR16*,CHAR16*);

VOID    LineCat (EFI_EDITOR_LINE*,EFI_EDITOR_LINE*);
VOID    LineDeleteAt (EFI_EDITOR_LINE*,UINTN);
VOID    LineSplit   (EFI_EDITOR_LINE*,UINTN,EFI_EDITOR_LINE*);
VOID    LineMerge   (EFI_EDITOR_LINE*,UINTN,EFI_EDITOR_LINE*,UINTN);
EFI_EDITOR_LINE*    LineDup (EFI_EDITOR_LINE*);

EFI_EDITOR_LINE*    LineNext (VOID);
EFI_EDITOR_LINE*    LinePrevious (VOID);
EFI_EDITOR_LINE*    LineAdvance (UINTN Count);
EFI_EDITOR_LINE*    LineRetreat (UINTN Count);
EFI_EDITOR_LINE*    LineCurrent (VOID);

EFI_EDITOR_LINE*    LineFirst (VOID);
EFI_EDITOR_LINE*    LineLast (VOID);

VOID
EditorError (
    IN  EFI_STATUS  Status,
    IN  CHAR16      *Msg
    )
{
    CHAR16  *Str;
    CHAR16  *Error;

    Error = AllocatePool(255);
    StatusToString(Error,Status);
    Str = PoolPrint(L"%s: %s",Msg,Error);
    MainEditor.StatusBar->SetStatusString(Str);

    FreePool(Str);
    FreePool(Error);
}

UINTN
StrInsert (
    IN  OUT CHAR16  **Str,
    IN      CHAR16  Char,
    IN      UINTN   Pos,
    IN      UINTN   StrSize
    )
{
    UINTN   i;
    CHAR16  *s;

    i = (StrSize)*2;

    *Str = ReallocatePool(*Str,i,i+2);

    s = *Str;
    for (i = StrSize-1; i > Pos; i--) {
        s[i] = s[i-1];
    }
    s[i] = Char;
    return (StrSize+1);
}

UINTN
StrnCpy (
        OUT CHAR16  *Dest,
    IN      CHAR16  *Src,
    IN      UINTN   Offset,
    IN      UINTN   Num
    )
{
    UINTN   i,j;
    j = 0;

    for ( i = Offset; (i < Num) && (Src[j] != 0); i++ ) {
        Dest[i] = Src[j];
        ++j;
    }

    return j;
}

INTN
StrStr  (
    IN  CHAR16  *Str,
    IN  CHAR16  *Pat
    )
{
    INTN    *Failure;
    INTN    i,j;
    INTN    Lenp;
    INTN    Lens;

    Lenp = StrLen(Pat);
    Lens = StrLen(Str);

    Failure = AllocatePool(Lenp*sizeof(INTN));
    Failure[0] = -1;
    for (j=1; j< Lenp; j++ ) {
        i = Failure[j-1];
        while ( (Pat[j] != Pat[i+1]) && (i >= 0)) {
            i = Failure[i];
        }
        if ( Pat[i] == Pat[i+1]) {
            Failure[j] = i+1;
        } else {
            Failure[j] = -1;
        }
    }

    i = 0;
    j = 0;
    while (i < Lens && j < Lenp) {
        if (Str[i] == Pat[j]) {
            i++;
            j++;
        } else if (j == 0) {
            i++;
        } else {
            j = Failure[j-1] + 1;
        }
    }

    FreePool(Failure);

    return ((j == Lenp) ? (i - Lenp) : -1)+1;

}

VOID
LineCat (
    IN  OUT EFI_EDITOR_LINE* Dest,
    IN      EFI_EDITOR_LINE* Src
    )
{
    CHAR16  *Str;
    UINTN   Size;
    Size = Dest->Size - 1;

    Dest->Buffer[Size] = 0;

    Str = PoolPrint (L"%s%s",Dest->Buffer,Src->Buffer);

    Dest->Size = Size + Src->Size;

    FreePool (Dest->Buffer);
    FreePool (Src->Buffer);
    Dest->Buffer = Str;
}

VOID
LineDeleteAt (
    IN  OUT EFI_EDITOR_LINE*    Line,
    IN      UINTN               Pos
    )
{
    UINTN   i;

    for ( i = Pos; i < Line->Size; i++) {
        Line->Buffer[i] = Line->Buffer[i+1];
    }
    --Line->Size;
}


EFI_EDITOR_LINE*
LineDup ( 
    IN  EFI_EDITOR_LINE *Src
    )
{
    EFI_EDITOR_LINE *Dest;
    Dest = AllocatePool(sizeof(EFI_EDITOR_LINE));
    Dest->Signature = EFI_EDITOR_LINE_LIST;
    Dest->Size = Src->Size;
    Dest->Buffer = PoolPrint(L"%s\0",Src->Buffer);

    Dest->Link = Src->Link;

    return Dest;
}

VOID
LineSplit (
    IN  EFI_EDITOR_LINE     *Src,
    IN  UINTN               Pos,
    OUT EFI_EDITOR_LINE     *Dest
    )
{
    Dest->Size = Src->Size - Pos;
    Dest->Buffer = PoolPrint(L"%s\0",Src->Buffer+Pos);
}

VOID
LineMerge (
    IN  OUT EFI_EDITOR_LINE*    Line1,
    IN      UINTN               Line1Pos,
    IN      EFI_EDITOR_LINE*    Line2,
    IN      UINTN               Line2Pos
    )
{
    UINTN   Size;
    CHAR16  *Buffer;

    Size = Line1Pos + Line2->Size - Line2Pos;
    Line1->Size = Size;

    Buffer = PoolPrint(L"%s%s\0",Line1->Buffer,Line2->Buffer+Line2Pos);

    FreePool(Line1->Buffer);

    Line1->Buffer = Buffer;

}

EFI_EDITOR_LINE*
LineFirst (
    VOID
    )
{
    MainEditor.FileBuffer->CurrentLine = MainEditor.FileImage->ListHead->Flink;
    return LineCurrent();
}

EFI_EDITOR_LINE*
LineLast (
    VOID
    )
{
    MainEditor.FileBuffer->CurrentLine = MainEditor.FileImage->ListHead->Blink;
    return LineCurrent();
}

EFI_EDITOR_LINE*
LineNext (
    VOID
    )
{
    LIST_ENTRY  *Link;
    Link = MainEditor.FileBuffer->CurrentLine->Flink;
    if (Link == MainEditor.FileImage->ListHead) {
        Link = Link->Flink;
    }
    MainEditor.FileBuffer->CurrentLine = Link;
    return LineCurrent();
}

EFI_EDITOR_LINE*
LinePrevious (
    VOID
    )
{ 
    LIST_ENTRY  *Link;
    Link = MainEditor.FileBuffer->CurrentLine->Blink;
    if (Link == MainEditor.FileImage->ListHead) {
        Link = Link->Blink;
    }
    MainEditor.FileBuffer->CurrentLine = Link;
    return LineCurrent();
}

EFI_EDITOR_LINE*
LineAdvance (
    IN  UINTN Count
    )
{
    UINTN   i;

    for (i = 0; i < Count && (MainEditor.FileBuffer->CurrentLine->Flink != MainEditor.FileImage->ListHead); i++ ) {
        MainEditor.FileBuffer->CurrentLine = MainEditor.FileBuffer->CurrentLine->Flink;
    }
    return LineCurrent();
}

EFI_EDITOR_LINE*
LineRetreat (
    IN  UINTN Count
    )
{ 
    UINTN   i;

    for (i = 0; i < Count && (MainEditor.FileBuffer->CurrentLine->Blink != MainEditor.FileImage->ListHead); i++ ) {
        MainEditor.FileBuffer->CurrentLine = MainEditor.FileBuffer->CurrentLine->Blink;
    }
    return LineCurrent();
}


EFI_EDITOR_LINE*
LineCurrent (
    VOID
    )
{
    return CR(MainEditor.FileBuffer->CurrentLine,EFI_EDITOR_LINE,Link,EFI_EDITOR_LINE_LIST);
}

UINTN
UnicodeToAscii  (
    IN  CHAR16  *UStr,
    IN  UINTN   Length,
    OUT CHAR8   *AStr
    )
{
    UINTN   i;

    for (i = 0; i < Length; i++) {
        *AStr++ = (CHAR8)*UStr++;
    }

    return i;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libtitlebar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libTitle.c

--*/

#ifndef _LIB_TITLE_BAR
#define _LIB_TITLE_BAR

#include "editor.h"

STATIC  EFI_STATUS  MainTitleBarInit (VOID);
STATIC  EFI_STATUS  MainTitleBarCleanup (VOID);
STATIC  EFI_STATUS  MainTitleBarRefresh (VOID);
STATIC  EFI_STATUS  MainTitleBarHide (VOID);
STATIC  EFI_STATUS  MainTitleBarSetTitle (CHAR16*);

EFI_EDITOR_TITLE_BAR    MainTitleBar = {
    NULL,
    MainTitleBarInit,
    MainTitleBarCleanup,
    MainTitleBarRefresh,
    MainTitleBarHide,
    MainTitleBarSetTitle
};

EFI_EDITOR_TITLE_BAR    MainTitleBarConst = {
    NULL,
    MainTitleBarInit,
    MainTitleBarCleanup,
    MainTitleBarRefresh,
    MainTitleBarHide,
    MainTitleBarSetTitle
};

STATIC
EFI_STATUS
MainTitleBarInit    (
    VOID
    )
{
    CopyMem (&MainTitleBar, &MainTitleBarConst, sizeof(MainTitleBar));

    MainTitleBar.SetTitleString(L"New File");

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainTitleBarCleanup (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine (TITLE_BAR_LOCATION);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainTitleBarRefresh (
    VOID
    )
{
    EFI_EDITOR_COLOR_UNION  Orig,New;

    Orig = MainEditor.ColorAttributes;
    New.Colors.Foreground = Orig.Colors.Background;
    New.Colors.Background = Orig.Colors.Foreground;

    Out->SetAttribute (Out,New.Data);

    MainEditor.FileBuffer->ClearLine (TITLE_BAR_LOCATION);
    PrintAt (0,TITLE_BAR_LOCATION,L"  %s  %s     %s   ",EDITOR_NAME,EDITOR_VERSION,MainTitleBar.Filename);
    
    if (MainEditor.FileImage->FileType == ASCII_FILE) {
        Print(L"[ASCII]");
    } else {
        Print(L"[UNICODE]");
    }
    if (MainEditor.FileModified) {
        Print(L"     Modified");
    }

    Out->SetAttribute (Out,Orig.Data);

    MainEditor.FileBuffer->RestorePosition();
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainTitleBarHide    (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine (TITLE_BAR_LOCATION);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainTitleBarSetTitle    (
    IN  CHAR16  *Filename
    )
{
    if (MainTitleBar.Filename != NULL ) {
        FreePool (MainTitleBar.Filename);
    }
    MainTitleBar.Filename = StrDuplicate (Filename);
    MainTitleBar.Refresh();
    return EFI_SUCCESS;
}

#endif  /* _LIB_TITLE_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libinputbar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libInputBar.c

  Abstract:
    Definition of the user input bar (multi-plexes with the Status Bar)

--*/

#ifndef _LIB_INPUT_BAR
#define _LIB_INPUT_BAR

#include "editor.h"

STATIC  EFI_STATUS  MainInputBarInit (VOID);
STATIC  EFI_STATUS  MainInputBarCleanup (VOID);
STATIC  EFI_STATUS  MainInputBarRefresh (VOID);
STATIC  EFI_STATUS  MainInputBarHide (VOID);
STATIC  EFI_STATUS  MainInputBarSetPrompt (CHAR16*);
STATIC  EFI_STATUS  MainInputBarSetStringSize (UINTN);

EFI_EDITOR_INPUT_BAR MainInputBar = {
    NULL,
    NULL,
    0,
    MainInputBarInit,
    MainInputBarCleanup,
    MainInputBarRefresh,
    MainInputBarHide,
    MainInputBarSetPrompt,
    MainInputBarSetStringSize
};

EFI_EDITOR_INPUT_BAR MainInputBarConst = {
    NULL,
    NULL,
    0,
    MainInputBarInit,
    MainInputBarCleanup,
    MainInputBarRefresh,
    MainInputBarHide,
    MainInputBarSetPrompt,
    MainInputBarSetStringSize
};

STATIC
EFI_STATUS
MainInputBarInit (
    VOID
    )
{
    CopyMem (&MainInputBar, &MainInputBarConst, sizeof(MainInputBar));

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarCleanup (
    VOID
    )
{
    MainInputBar.Hide ();
    if (MainInputBar.Prompt != NULL ) {
        FreePool ((VOID*)MainInputBar.Prompt);
    }
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarRefresh (
    VOID
    )
{
    EFI_EDITOR_COLOR_UNION  Orig,New;
    EFI_INPUT_KEY           Key;
    UINTN                   Column;
    UINTN                   Size = 0;
    EFI_STATUS              Status = EFI_SUCCESS;

    Orig = MainEditor.ColorAttributes;
    New.Colors.Foreground = Orig.Colors.Background;
    New.Colors.Background = Orig.Colors.Foreground;

    Out->SetAttribute (Out,New.Data);

    MainInputBar.Hide();
    Out->SetCursorPosition(Out,0,INPUT_BAR_LOCATION);
    Print(L"%s ",MainInputBar.Prompt);

    for ( ;; ) {
        WaitForSingleEvent(In->WaitForKey,0);
        Status = In->ReadKeyStroke(In,&Key);
        if ( EFI_ERROR(Status) ) {
            continue;
        }
        if ( Key.ScanCode == SCAN_CODE_ESC ) {
            Size = 0;
            FreePool(MainInputBar.ReturnString);
            Status = EFI_NOT_READY;
            break;
        } 
        if ( Key.UnicodeChar == CHAR_LF || Key.UnicodeChar == CHAR_CR ) {
            break;
        } else if (Key.UnicodeChar == CHAR_BS) {
            if (Size > 0) {
                Size--;
                Column = Out->Mode->CursorColumn - 1;
                PrintAt(Column,INPUT_BAR_LOCATION,L" ");
                Out->SetCursorPosition(Out,Column,INPUT_BAR_LOCATION);
            }
        } else if (Key.UnicodeChar != 0) {
            if ( Size < MainInputBar.StringSize) {
                MainInputBar.ReturnString[Size] = Key.UnicodeChar;
                Size++;
                Print(L"%c",Key.UnicodeChar);
            }
        }
    }
    MainInputBar.StringSize = Size;
    if ( Size > 0 ) {
        MainInputBar.ReturnString[Size] = 0;
    }

    Out->SetAttribute (Out,Orig.Data);
    MainEditor.StatusBar->Refresh();

    return Status;
}

STATIC
EFI_STATUS
MainInputBarHide (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine(INPUT_BAR_LOCATION);
    return  EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarSetPrompt (
    IN  CHAR16* Str
    )
{

    if ( MainInputBar.Prompt != NULL && MainInputBar.Prompt != (CHAR16*)BAD_POINTER) {
        FreePool (MainInputBar.Prompt);
    }
    MainInputBar.Prompt = PoolPrint (L"%s",Str);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarSetStringSize   (
    UINTN   Size
    )
{
/*   if ( MainInputBar.ReturnString != NULL && MainInputBar.ReturnString != (CHAR16*)BAD_POINTER) {
 *       FreePool ( MainInputBar.ReturnString );
 *   } */
    MainInputBar.StringSize = Size;

    MainInputBar.ReturnString = AllocatePool (Size+6);

    return EFI_SUCCESS;
}


#endif  /* _LIB_INPUT_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\main.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    main.c

  Abstract:
    

--*/

#include "libMisc.h"

EFI_STATUS
InitializeEFIEditor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeEFIEditor)





EFI_STATUS
InitializeEFIEditor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_STATUS      Status;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeEFIEditor,
        L"edit",                      /*  command */
        L"edit [file name]",          /*  command syntax */
        L"Edit a file",               /*  1 line descriptor */
        NULL                          /*  command help page */
        );

    InitializeShellApplication (ImageHandle, SystemTable);

    Status = MainEditor.Init();
    if (EFI_ERROR(Status)) {
        Out->ClearScreen(Out);
        Out->EnableCursor(Out,TRUE);
        Print(L"EDIT : Initialization Failed\n");
        return EFI_SUCCESS;
    }
    Status = MainEditor.FileImage->Init (ImageHandle);
    if (EFI_ERROR(Status)) {
        Out->ClearScreen(Out);
        Out->EnableCursor(Out,TRUE);
        Print(L"EDIT : File Handle Initialization Failed\n");
        return EFI_SUCCESS;
    }

    if (SI->Argc > 1) {
        MainEditor.FileImage->SetFilename(SI->Argv[1]);
        Status = MainEditor.FileImage->OpenFile ();
        if (EFI_ERROR(Status)) {
            Out->ClearScreen(Out);
            Out->EnableCursor(Out,TRUE);
            Print(L"EDIT : Could Not Open File\n");
            return EFI_SUCCESS;
        }
        MainEditor.TitleBar->SetTitleString (SI->Argv[1]);
        MainEditor.FileImage->ReadFile();
    }

    MainEditor.Refresh ();

    MainEditor.KeyInput ();

    MainEditor.Cleanup();

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\edit\libstatusbar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libStatus.c

  Abstract:
    Definition for the Status Bar - the updatable display for the status of the editor

--*/

#ifndef _LIB_STATUS_BAR
#define _LIB_STATUS_BAR

#include "editor.h"

STATIC  EFI_STATUS  MainStatusBarInit (VOID);
STATIC  EFI_STATUS  MainStatusBarCleanup (VOID);
STATIC  EFI_STATUS  MainStatusBarRefresh (VOID);
STATIC  EFI_STATUS  MainStatusBarHide (VOID);
STATIC  EFI_STATUS  MainStatusBarSetStatusString (CHAR16*);
STATIC  EFI_STATUS  MainStatusBarSetPosition (UINTN,UINTN);
STATIC  EFI_STATUS  MainStatusBarSetMode (BOOLEAN);

BOOLEAN InsertFlag=TRUE;

EFI_EDITOR_STATUS_BAR MainStatusBar = {
    NULL,
    INSERT_MODE_STR,
    {1,1},
    MainStatusBarInit,
    MainStatusBarCleanup,
    MainStatusBarRefresh,
    MainStatusBarHide,
    MainStatusBarSetStatusString,
    MainStatusBarSetPosition,
    MainStatusBarSetMode
};

EFI_EDITOR_STATUS_BAR MainStatusBarConst = {
    NULL,
    INSERT_MODE_STR,
    {1,1},
    MainStatusBarInit,
    MainStatusBarCleanup,
    MainStatusBarRefresh,
    MainStatusBarHide,
    MainStatusBarSetStatusString,
    MainStatusBarSetPosition,
    MainStatusBarSetMode
};
 
STATIC
EFI_STATUS
MainStatusBarInit   (
    VOID
    )
{     

    CopyMem (&MainStatusBar, &MainStatusBarConst, sizeof(MainStatusBar));
    
    MainStatusBar.SetStatusString(L"");
    
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarCleanup    (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine(STATUS_BAR_LOCATION);
    if ( MainStatusBar.StatusString != NULL ) {
        FreePool ((VOID*)MainStatusBar.StatusString);
    }
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarRefresh    (
    VOID
    )
{
    EFI_EDITOR_COLOR_UNION  Orig,New;
    Orig = MainEditor.ColorAttributes;
    New.Colors.Foreground = Orig.Colors.Background;
    New.Colors.Background = Orig.Colors.Foreground;

    Out->SetAttribute (Out,New.Data);

    MainEditor.FileBuffer->ClearLine(STATUS_BAR_LOCATION);
    PrintAt (0,STATUS_BAR_LOCATION,L"  Row: %d  Col: %d       %s",
        MainStatusBar.Pos.Row,MainStatusBar.Pos.Column,MainStatusBar.StatusString);
    if ( InsertFlag ) {
        PrintAt (MAX_TEXT_COLUMNS-10,STATUS_BAR_LOCATION,L"|%s|",L"INS");
    } else {
        PrintAt (MAX_TEXT_COLUMNS-10,STATUS_BAR_LOCATION,L"|%s|",L"OVR");
    }
    
    Out->SetAttribute (Out,Orig.Data);

    MainEditor.FileBuffer->RestorePosition();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarHide   (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine(STATUS_BAR_LOCATION);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarSetStatusString (
    IN CHAR16* Str
    )
{
    
    if ( MainStatusBar.StatusString != NULL ) {
        FreePool (MainStatusBar.StatusString);
    }
    
    MainStatusBar.StatusString = StrDuplicate (Str);
    
    MainStatusBarRefresh();
    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
MainStatusBarSetPosition (
    IN  UINTN   Row,
    IN  UINTN   Column
    )
{
    MainStatusBar.Pos.Row = Row;
    MainStatusBar.Pos.Column = Column;

    MainStatusBar.Refresh();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarSetMode    (
    BOOLEAN IsInsertMode
    )
{   
    InsertFlag = IsInsertMode;
    /*  
    if (IsInsertMode) {
        StrCpy(MainStatusBar.ModeString,INSERT_MODE_STR);
    } else {
        StrCpy(MainStatusBar.ModeString,OVERWR_MODE_STR);
    }
        */      
    return EFI_SUCCESS;
}


#endif  /* _LIB_STATUS_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libbufferimage.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  ModuleName:
    libBufferImage.c

  Abstract:
    Defines the routines to handle the image of the buffer in memory and 
    provides access to handle whatever type it is - a file, disk, or memory
    image

--*/

#ifndef _LIB_BUFFER_IMAGE
#define _LIB_BUFFER_IMAGE

#include "libMisc.h"

extern  EE_FILE_IMAGE   FileImage;
extern  EE_DISK_IMAGE   DiskImage;
extern  EE_MEM_IMAGE    MemImage;

STATIC  EFI_STATUS  BufferImageInit (VOID);
STATIC  EFI_STATUS  BufferImageCleanup (VOID);


EE_BUFFER_IMAGE BufferImage = {
    NULL,
    NO_BUFFER,
    0,
    BufferImageInit,
    BufferImageCleanup,
    Nothing,
    Nothing,
    Nothing,
    Nothing,
    Nothing,
    &FileImage,
    &DiskImage,
    &MemImage
};


STATIC
EFI_STATUS
BufferImageInit (
    VOID
    )
{
    BufferImage.ListHead = AllocatePool(sizeof(LIST_ENTRY));
    InitializeListHead(BufferImage.ListHead);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
BufferImageCleanup (
    VOID
    )
{
    EE_LINE *Blank;

    BufferImage.Close();
    BufferImage.ImageCleanup();
    BufferImage.BufferType = NO_BUFFER;

    Blank = LineCurrent();
    RemoveEntryList(&Blank->Link);
    FreePool(Blank);
    FreePool(BufferImage.ListHead);

    return EFI_SUCCESS;
}

#endif  /* _LIB_BUFFER_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\hexedit.h ===
#ifndef _EDITOR_H
#define _EDITOR_H
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    Editor.h

  Abstract:
    Main include file for hex editor

--*/

#include "efi.h"
#include "efilib.h"
#include "shelle.h"

#define EDITOR_NAME     L"EFI Hex Editor\0"
#define EDITOR_VERSION  L"0.92\0"

#define EE  EFI_EDITOR

typedef 
EFI_STATUS
(*EE_INIT)  (
    VOID
    );

typedef 
EFI_STATUS
(*EE_CLEANUP)   (
    VOID
    );

typedef
EFI_STATUS
(*EE_REFRESH)   (
    VOID
    );

typedef
EFI_STATUS
(*EE_HIDE)  (
    VOID
    );

typedef
EFI_STATUS
(*EE_INPUT) (
    VOID
    );

typedef
EFI_STATUS
(*EE_HANDLE_INPUT) (
    IN  OUT     EFI_INPUT_KEY   *Key
    );

typedef
EFI_STATUS
(*EE_IMAGE_OPEN)    (
    VOID
    );
typedef
EFI_STATUS
(*EE_IMAGE_CLOSE)   (
    VOID
    );
typedef
EFI_STATUS
(*EE_IMAGE_READ)    (
    VOID
    );
typedef
EFI_STATUS
(*EE_IMAGE_WRITE)   (
    VOID
    );
typedef
EFI_STATUS
(*EE_IMAGE_CLEAN)   (
    VOID
    );


typedef struct  {
    UINTN   Row;
    UINTN   Column;
} EE_POSITION;


typedef 
EFI_STATUS
(*EFI_MENU_ITEM_FUNCTION) (VOID);

typedef struct  {
    CHAR16  Name[50];
    CHAR16  Key[3];
    EFI_MENU_ITEM_FUNCTION  Function;
} SubItems;

#define EE_LINE_LIST    'eell'

typedef struct  _EE_LINE {
    UINTN               Signature;
    UINT8               Buffer[0x10];
    UINTN               Size;
    LIST_ENTRY          Link;
} EE_LINE;

typedef struct  {
    CHAR16                  *Name;
    CHAR16                  *FunctionKey;
    EFI_MENU_ITEM_FUNCTION  Function;
} EE_MENU_ITEM;

typedef struct  {
    EE_MENU_ITEM        *MenuItems;
    EE_INIT             Init;
    EE_CLEANUP          Cleanup;
    EE_REFRESH          Refresh;
    EE_HIDE             Hide;
    EE_HANDLE_INPUT     HandleInput;
} EE_MENU_BAR;

typedef struct  {
    CHAR16          *Filename;
    EE_INIT         Init;
    EE_CLEANUP      Cleanup;
    EE_REFRESH      Refresh;
    EE_HIDE         Hide;
    EFI_STATUS  (*SetTitleString) (CHAR16*);
} EE_TITLE_BAR;

typedef struct  {
    CHAR16*                 StatusString;
    UINTN                   Offset;
    EE_INIT         Init;
    EE_CLEANUP      Cleanup;
    EE_REFRESH      Refresh;
    EE_HIDE         Hide;
    EFI_STATUS  (*SetStatusString) (CHAR16*);
    EFI_STATUS  (*SetOffset) (UINTN);
} EE_STATUS_BAR;


typedef struct  {
    CHAR16                  *Prompt;
    CHAR16                  *ReturnString;
    UINTN                   StringSize;
    EE_INIT         Init;
    EE_CLEANUP      Cleanup;
    EE_REFRESH      Refresh;
    EE_HIDE         Hide;
    EFI_STATUS  (*SetPrompt) (CHAR16*);
    EFI_STATUS  (*SetStringSize) (UINTN);
} EE_INPUT_BAR;

typedef struct  {
    EE_POSITION     DisplayPosition;
    UINTN           Offset;
    UINTN           LowVisibleOffset;
    UINTN           HighVisibleOffset;
    UINTN           MaxVisibleBytes;
    LIST_ENTRY      *CurrentLine;
    EE_INIT         Init;
    EE_CLEANUP      Cleanup;
    EE_REFRESH      Refresh;
    EE_HIDE         Hide;
    EE_HANDLE_INPUT HandleInput;
    EFI_STATUS      (*ClearLine) (UINTN);
    EFI_STATUS      (*SetPosition) (UINTN,UINTN);
    EFI_STATUS      (*RestorePosition) (VOID);
} EE_FILE_BUFFER;

typedef struct  {
    LIST_ENTRY  *ListHead;
    EE_LINE     *Lines;
    UINTN       NumLines;
    EE_INIT     Init;
    EE_CLEANUP  Cleanup;
    EFI_STATUS  (*Clear)    (VOID);
    EFI_STATUS  (*Cut)  (UINTN,UINTN);
    EFI_STATUS  (*Copy) (UINTN,UINTN);
    EFI_STATUS  (*Paste)(VOID);
} EE_CLIPBOARD;

typedef struct  {
    UINT32  Foreground:4;
    UINT32  Background:4;
} EE_COLOR_ATTRIBUTES;

typedef union {
    EE_COLOR_ATTRIBUTES Colors;
    UINT8                       Data;
} EE_COLOR_UNION;

typedef struct  {
    UINTN   Columns;
    UINTN   Rows;
} EE_TEXT_MODE;

typedef struct  {
    EFI_BLOCK_IO    *BlkIo;
    EFI_DEVICE_PATH *DevicePath;
    UINTN           Size;
    UINT64          Offset;
    EE_INIT         Init;
    EFI_STATUS      (*SetDevice) (CHAR16*);
    EFI_STATUS      (*SetOffset) (UINT64);
    EFI_STATUS      (*SetSize) (UINTN);
} EE_DISK_IMAGE;

typedef struct  {
    EFI_DEVICE_IO_INTERFACE *IoFncs;
    UINTN           Offset;
    UINTN           Size;
    EE_INIT         Init;
    EFI_STATUS      (*SetOffset)(UINTN);
    EFI_STATUS      (*SetSize)  (UINTN);
} EE_MEM_IMAGE;

typedef struct  {
    CHAR16          *FileName;
    EFI_FILE_HANDLE FileHandle;
    EFI_FILE_HANDLE CurrentDir;
    EE_INIT         Init;
    EFI_STATUS      (*SetFilename)  (CHAR16*);
} EE_FILE_IMAGE;

typedef enum    {
    NO_BUFFER,
    DISK_BUFFER,
    MEM_BUFFER,
    FILE_BUFFER
}   EE_ACTIVE_BUFFER_TYPE;

typedef struct  {
    LIST_ENTRY      *ListHead;
    EE_ACTIVE_BUFFER_TYPE   BufferType;
    UINTN           NumBytes;
    EE_INIT         Init;
    EE_CLEANUP      Cleanup;
    EE_IMAGE_OPEN   Open;
    EE_IMAGE_CLOSE  Close;
    EE_IMAGE_READ   Read;
    EE_IMAGE_WRITE  Write;
    EE_IMAGE_CLEAN  ImageCleanup;
    EE_FILE_IMAGE   *FileImage;
    EE_DISK_IMAGE   *DiskImage;
    EE_MEM_IMAGE    *MemImage;
} EE_BUFFER_IMAGE;



typedef struct  {
    EFI_HANDLE      *ImageHandle;
    EE_TITLE_BAR    *TitleBar;
    EE_MENU_BAR     *MenuBar;
    EE_STATUS_BAR   *StatusBar;
    EE_INPUT_BAR    *InputBar;
    EE_FILE_BUFFER  *FileBuffer;
    EE_CLIPBOARD    *Clipboard;
    EE_COLOR_UNION  ColorAttributes;
    EE_POSITION     *ScreenSize;
    EE_BUFFER_IMAGE *BufferImage;
    BOOLEAN         FileModified;
    EFI_STATUS      (*Init) (EFI_HANDLE*);
    EE_CLEANUP      Cleanup;
    EE_INPUT        KeyInput;
    EE_HANDLE_INPUT HandleInput;
    EE_REFRESH      Refresh;
} EE_EDITOR;

extern  EE_EDITOR   MainEditor;


#define TITLE_BAR_LOCATION  0
#define STATUS_BAR_LOCATION (MainEditor.ScreenSize->Row - 4)
#define INPUT_BAR_LOCATION  STATUS_BAR_LOCATION
#define MENU_BAR_LOCATION   (MainEditor.ScreenSize->Row - 3)
#define LAST_LINE_LOCATION  (MainEditor.ScreenSize->Row - 1)
#define TEXT_START_ROW      1
#define TEXT_START_COLUMN   0
#define TEXT_END_ROW        (MainEditor.ScreenSize->Row - 4)
#define MAX_TEXT_COLUMNS    MainEditor.ScreenSize->Column
#define MAX_TEXT_ROWS       (TEXT_END_ROW - 1)
#define DISP_START_ROW      1
#define DISP_START_COLUMN   0
#define DISP_END_ROW        (MainEditor.ScreenSize->Row - 4)
#define DISP_MAX_ROWS       (DISP_END_ROW - 1)
#define HEX_POSITION        10
#define ASCII_POSITION      (0x10*3)+2+HEX_POSITION


#define MIN_POOL_SIZE       125
#define MAX_STRING_LENGTH   127
#define min(a,b) \
    (( a > b) ? b : a)
#define max(a,b) \
    (( a > b) ? a : b)

/* Global variables for input and output */
#define Out     ST->ConOut
#define In      ST->ConIn


#define SCAN_CODE_NULL  0x00
#define SCAN_CODE_UP    0x01
#define SCAN_CODE_DOWN  0x02
#define SCAN_CODE_RIGHT 0x03
#define SCAN_CODE_LEFT  0x04
#define SCAN_CODE_HOME  0x05
#define SCAN_CODE_END   0x06
#define SCAN_CODE_INS   0x07
#define SCAN_CODE_DEL   0x08
#define SCAN_CODE_PGUP  0x09
#define SCAN_CODE_PGDN  0x0A
#define SCAN_CODE_F1    0x0B
#define SCAN_CODE_F2    0x0C
#define SCAN_CODE_F3    0x0D
#define SCAN_CODE_F4    0x0E
#define SCAN_CODE_F5    0x0F
#define SCAN_CODE_F6    0x10
#define SCAN_CODE_F7    0x11
#define SCAN_CODE_F8    0x12
#define SCAN_CODE_F9    0x13
#define SCAN_CODE_F10   0x14
#define SCAN_CODE_F11   0x15
#define SCAN_CODE_F12   0x16
#define SCAN_CODE_ESC   0x17
#define CHAR_BS         0x08
#define CHAR_LF         0x0a
#define CHAR_CR         0x0d

#define IS_VALID_CHAR(x) \
    (x == SCAN_CODE_NULL)
#define IS_DIRECTION_KEY(x) \
    ((x >= SCAN_CODE_UP) && (x <= SCAN_CODE_PGDN))
#define IS_FUNCTION_KEY(x) \
    ((x >= SCAN_CODE_F1) && x <= (SCAN_CODE_F12))
#define IS_ESCAPE(x) \
    (x == SCAN_CODE_ESC) 

extern  VOID    EditorError (EFI_STATUS,CHAR16*);


#endif  /*  _EDITOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\err\err.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    err.c
    
Abstract:

    Shell app "err"



Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeError (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeError)

EFI_STATUS
InitializeError (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeError,
        L"err",                      /*  command */
        L"err [level]",                      /*  command syntax */
        L"Set or display error level",    /*  1 line descriptor */
        NULL                         /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);


    /* 
     * 
     */


    if ( SI->Argc > 1 ) {
        EFIDebug = xtoi(SI->Argv[1]);
    } 
    
    Print (L"\n%HEFI ERROR%N %016x\n", EFIDebug);
    Print (L"    %08x  D_INIT\n",        D_INIT);
    Print (L"    %08x  D_WARN\n",        D_WARN);
    Print (L"    %08x  D_LOAD\n",        D_LOAD);
    Print (L"    %08x  D_FS\n",          D_FS);
    Print (L"    %08x  D_POOL\n",        D_POOL);
    Print (L"    %08x  D_PAGE\n",        D_PAGE);
    Print (L"    %08x  D_INFO\n",        D_INFO);
    Print (L"    %08x  D_VAR\n",         D_VAR);
    Print (L"    %08x  D_PARSE\n",       D_PARSE);
    Print (L"    %08x  D_BM\n",          D_BM);
    Print (L"    %08x  D_BLKIO\n",       D_BLKIO);
    Print (L"    %08x  D_BLKIO_ULTRA\n", D_BLKIO_ULTRA);
    Print (L"    %08x  D_NET\n",         D_NET);
    Print (L"    %08x  D_NET_ULTRA\n",   D_NET_ULTRA);
    Print (L"    %08x  D_ERROR\n",       D_ERROR);

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\getmtc\getmtc.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    getmtc
    
Abstract:

    Get next monotonic count

Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeGetMTC (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeGetMTC)

EFI_STATUS
InitializeGetMTC (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    UINT64                  mtc;
    EFI_STATUS              Status;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeGetMTC,
        L"getmtc",                      /*  command */
        L"getmtc",                      /*  command syntax */
        L"Get next monotonic count",    /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  Initialize app
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    Status = BS->GetNextMonotonicCount(&mtc);
    if (EFI_ERROR(Status)) {
        Print (L"Failed to get Monotonic count - %r\n", Status);
    } else {
        Print (L"Monotonic count = %hlx\n", mtc);
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libclipboard.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libClipboard.c

  Abstract:
    Implementation of the "clipboard"


--*/

#ifndef _LIB_CLIPBOARD
#define _LIB_CLIPBOARD

#include "libMisc.h"


STATIC  EFI_STATUS  ClipboardInit   (VOID);
STATIC  EFI_STATUS  ClipboardCleanup(VOID);
STATIC  EFI_STATUS  ClipboardClear  (VOID);
STATIC  EFI_STATUS  ClipboardCut    (UINTN,UINTN);
STATIC  EFI_STATUS  ClipboardCopy   (UINTN,UINTN);
STATIC  EFI_STATUS  ClipboardPaste  (VOID);

EE_CLIPBOARD    Clipboard = {
    NULL,
    NULL,
    0,
    ClipboardInit,
    ClipboardCleanup,
    ClipboardClear,
    ClipboardCut,
    ClipboardCopy,
    ClipboardPaste
};

STATIC
EFI_STATUS
ClipboardInit (
    VOID
    ) 
{
    Clipboard.ListHead = AllocatePool(sizeof(LIST_ENTRY));
    InitializeListHead(Clipboard.ListHead);


    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
ClipboardCleanup (
    VOID
    )
{

    ClipboardClear();

    FreePool(Clipboard.ListHead);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
ClipboardClear (
    VOID
    )
{
    EE_LINE *Line;
    LIST_ENTRY      *Link;
    LIST_ENTRY      *Head;

    Head = Clipboard.ListHead;

    for ( Link = Head->Blink; Link != Head; Link = Head->Blink) {
        RemoveEntryList(Link);
        Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);
        FreePool(Line);
    }

    Clipboard.NumLines = 0;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
ClipboardFill (
    IN  UINTN   Start,
    IN  UINTN   End
    )
{
    EE_LINE *Current;
    EE_LINE *NewLine;
    UINTN           i;
    LIST_ENTRY      *Link;
    UINTN           StartRow = Start / 0x10;
    UINTN           EndRow = End / 0x10;

    NewLine = AllocatePool (sizeof(EE_LINE));
    NewLine->Signature = EE_LINE_LIST;

    Link = MainEditor.BufferImage->ListHead->Flink;
    for (i = 0; i < StartRow; i++) {
        Link = Link->Flink;
    }
    Current = CR(Link,EE_LINE,Link,EE_LINE_LIST);

    InsertTailList(Clipboard.ListHead,&NewLine->Link);

    LineSplit(Current,(Start%0x10),NewLine);

    Clipboard.NumLines = 1;

    if ( StartRow == EndRow ) {
        NewLine->Size = End - Start + 1;
    } else {
        for ( i = StartRow; i < EndRow; i++ ) {

            Link = Current->Link.Flink;
            Current = CR(Link,EE_LINE,Link,EE_LINE_LIST);

            NewLine = LineDup(Current);
            InsertTailList(Clipboard.ListHead,&NewLine->Link);
        }
        NewLine->Size = 1 + (End % 0x10);
        ++Clipboard.NumLines;
    }

    return  EFI_SUCCESS;
}

STATIC
EFI_STATUS
ClipboardCut (
    IN  UINTN   Start,
    IN  UINTN   End
    )
{
    LIST_ENTRY      *Link;
    UINTN           i;
    UINTN           StartRow = Start / 0x10;

    ClipboardClear ();
    ClipboardFill(Start,End);

    Link = MainEditor.BufferImage->ListHead->Flink;
    for ( i = 0; i < StartRow; i++ ) {
        Link = Link->Flink;
    }

    LineDeleteAt(Link,(Start%0x10),End-Start+1);

    if (Start < MainEditor.FileBuffer->LowVisibleOffset) {
        MainEditor.FileBuffer->LowVisibleOffset = (Start & 0xfffffff0);
        MainEditor.FileBuffer->HighVisibleOffset = (Start & 0xfffffff0) + MainEditor.FileBuffer->MaxVisibleBytes;
    } else if (Start > MainEditor.FileBuffer->HighVisibleOffset) {
        MainEditor.FileBuffer->LowVisibleOffset = (Start & 0xfffffff0);
        MainEditor.FileBuffer->HighVisibleOffset = (Start & 0xfffffff0) + MainEditor.FileBuffer->MaxVisibleBytes;
    }

    MainEditor.FileBuffer->DisplayPosition.Row = (Start - MainEditor.FileBuffer->LowVisibleOffset) % 0x10 + DISP_START_ROW;
    MainEditor.FileBuffer->DisplayPosition.Column = HEX_POSITION + (Start%0x10)*3;
    if (Start%0x10 > 0x07) {
        ++MainEditor.FileBuffer->DisplayPosition.Column;
    }
    MainEditor.StatusBar->SetOffset(Start);
    MainEditor.FileBuffer->Offset = Start;

    MainEditor.FileBuffer->Refresh();

    FileModification();

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
ClipboardCopy (
    IN  UINTN   Start,
    IN  UINTN   End
    )
{
    ClipboardClear();
    ClipboardFill(Start,End);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
ClipboardPaste()
{
    EE_LINE *StartLine;
    EE_LINE *BottomHalf;
    EE_LINE *Current;
    LIST_ENTRY      *Link;
    LIST_ENTRY      *Head;
    UINTN           NumBytes = 0;
    UINTN           LinePos;
    UINTN           ClipPos = 0;

    if (Clipboard.NumLines == 0) { 
        return EFI_SUCCESS;
    }

    LinePos = MainEditor.FileBuffer->Offset % 0x10;

    StartLine = LineCurrent();
    BottomHalf = AllocatePool(sizeof(EE_LINE));
    BottomHalf->Signature = EE_LINE_LIST;
    LineSplit(StartLine,LinePos,BottomHalf);

    Head = MainEditor.BufferImage->ListHead;

    BottomHalf->Link.Blink = Head->Blink;
    BottomHalf->Link.Blink->Flink = &BottomHalf->Link;
    BottomHalf->Link.Flink = StartLine->Link.Flink;
    BottomHalf->Link.Flink->Blink = &BottomHalf->Link;

    Head->Blink = &StartLine->Link;
    Head->Blink->Flink = Head;

    StartLine->Size = LinePos + 1;

    Head = Clipboard.ListHead;
    Link = Head->Flink;

    while (Link != Head) {
        Current = CR(Link,EE_LINE,Link,EE_LINE_LIST);
        if (LinePos == 0x10) {
            StartLine->Size = 0x10;
            StartLine = LineCreateNode(MainEditor.BufferImage->ListHead);
            LinePos = 0;
        } else if (ClipPos >= Current->Size) {
            Link = Link->Flink;
            ClipPos = 0;
        } else {
            StartLine->Buffer[LinePos] = Current->Buffer[ClipPos];
            ++LinePos;
            ++ClipPos;
            ++NumBytes;
        }
    }
    StartLine->Size = LinePos;

    MainEditor.FileBuffer->DisplayPosition.Column = LinePos*3 + HEX_POSITION;
    if (LinePos > 0x07) {
        ++MainEditor.FileBuffer->DisplayPosition.Column;
    }

    MainEditor.BufferImage->NumBytes += NumBytes;

    ClipPos = 0;
    Current = BottomHalf;
    Link = Head = &Current->Link;

    while (Link != Head->Blink && ClipPos <= Current->Size) {
        if (LinePos == 0x10) {
            StartLine->Size = 0x10;
            StartLine = LineCreateNode(MainEditor.BufferImage->ListHead);
            LinePos = 0;
        } else if (ClipPos >= Current->Size) {
            Link = Link->Flink;
            Current = CR(Link,EE_LINE,Link,EE_LINE_LIST);
            ClipPos = 0;
        } else {
            StartLine->Buffer[LinePos] = Current->Buffer[ClipPos];
            ++LinePos;
            ++ClipPos;
        }
    }
    StartLine->Size = LinePos;

    Link = Head->Blink;
    RemoveEntryList(Link);
    InsertTailList(MainEditor.BufferImage->ListHead,Link);

    do {
        Link = Head->Flink;
        RemoveEntryList(Link);
        Current = CR(Link,EE_LINE,Link,EE_LINE_LIST);
        FreePool(Current);
    } while (Link != Head);


    LineAdvance(NumBytes/0x10);
    NumBytes += MainEditor.FileBuffer->Offset;
    MainEditor.FileBuffer->Offset = NumBytes;

    if (NumBytes > MainEditor.FileBuffer->HighVisibleOffset) {
        MainEditor.FileBuffer->LowVisibleOffset = NumBytes & 0xfffffff0;
        MainEditor.FileBuffer->HighVisibleOffset = NumBytes + MainEditor.FileBuffer->MaxVisibleBytes;
    }

    LinePos = (NumBytes - MainEditor.FileBuffer->LowVisibleOffset);
    LinePos /= 0x10;
    LinePos += DISP_START_ROW; 
    MainEditor.FileBuffer->DisplayPosition.Row = LinePos;
    MainEditor.StatusBar->SetOffset(NumBytes);

    MainEditor.FileBuffer->Refresh();

    FileModification();

    return EFI_SUCCESS;
}

#endif  /*   _LIB_CLIPBOARD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libeditor.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libEditor.c

--*/

#ifndef _LIB_EDITOR
#define _LIB_EDITOR

#include "hexedit.h"

extern  EE_FILE_BUFFER      FileBuffer;
extern  EE_BUFFER_IMAGE     BufferImage;
extern  EE_TITLE_BAR        TitleBar;
extern  EE_STATUS_BAR       MainStatusBar;
extern  EE_INPUT_BAR        MainInputBar;
extern  EE_MENU_BAR         MainMenuBar;
extern  EE_CLIPBOARD        Clipboard;

STATIC  EE_COLOR_ATTRIBUTES OriginalColors;
STATIC  INTN                OriginalMode;

STATIC  EFI_STATUS  MainEditorInit (EFI_HANDLE*);
STATIC  EFI_STATUS  MainEditorCleanup (VOID);
STATIC  EFI_STATUS  MainEditorKeyInput (VOID);
STATIC  EFI_STATUS  MainEditorHandleInput (EFI_INPUT_KEY*);
STATIC  EFI_STATUS  MainEditorRefresh (VOID);

EE_EDITOR MainEditor = {
    NULL,
    &TitleBar,
    &MainMenuBar,
    &MainStatusBar,
    &MainInputBar,
    &FileBuffer,
    &Clipboard,
    {0,0},
    NULL,
    &BufferImage,
    FALSE,
    MainEditorInit,
    MainEditorCleanup,
    MainEditorKeyInput,
    MainEditorHandleInput,
    MainEditorRefresh
};

STATIC
EFI_STATUS
MainEditorInit (
    IN  EFI_HANDLE  *ImageHandle
    )
{
    EFI_STATUS  Status;

    MainEditor.ImageHandle = ImageHandle;

    Status = In->Reset(In,FALSE);
    if (EFI_ERROR(Status)) {
        Print (L"%ECould not obtain input device!%N\n");
        return EFI_LOAD_ERROR;
    }
    Status = Out->Reset(Out,FALSE);
    if (EFI_ERROR(Status)) {
        Print (L"%ECould not obtain output device!%N\n");
        return EFI_LOAD_ERROR;
    }

    MainEditor.ColorAttributes.Colors.Foreground = Out->Mode->Attribute & 0x000000ff;
    MainEditor.ColorAttributes.Colors.Background = (UINT8)(Out->Mode->Attribute >> 4);
    OriginalColors = MainEditor.ColorAttributes.Colors;

    OriginalMode = Out->Mode->Mode;

    MainEditor.ScreenSize = AllocatePool (sizeof(EE_POSITION));
    if (MainEditor.ScreenSize == NULL ) {
        Print (L"%ECould Not Allocate Memory for Screen Size\n%N");
        return EFI_OUT_OF_RESOURCES;
    }
    Out->QueryMode(Out,Out->Mode->Mode,&(MainEditor.ScreenSize->Column),&(MainEditor.ScreenSize->Row));

    Status = MainEditor.BufferImage->Init ();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on BufferImage init\n%N");
        return EFI_LOAD_ERROR;
    }

    Status = MainEditor.TitleBar->Init ();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on TitleBar init\n%N");
        return EFI_LOAD_ERROR;
    }

    Status = MainEditor.StatusBar->Init ();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on StatusBar init\n%N");
        return EFI_LOAD_ERROR;
    }

    Status = MainEditor.FileBuffer->Init();
    if ( EFI_ERROR(Status) ) {
        Print (L"%EMainEditor init failed on FileBuffer init\n%N");
        return EFI_LOAD_ERROR;
    }

    Status = MainEditor.MenuBar->Init();
    if ( EFI_ERROR(Status)) {
        Print (L"%EMainEditor init failed on MainMenu init\n%N");
        return EFI_LOAD_ERROR;
    } 

    Status = MainEditor.InputBar->Init ();
    if ( EFI_ERROR(Status)) {
        Print (L"%EMainEditor init failed on InputBar init\n%N");
        return EFI_LOAD_ERROR;
    }

    Status = MainEditor.Clipboard->Init();
    if ( EFI_ERROR(Status)) {
        Print (L"%EMainEditor init failed on Clipboard init\n%N");
        return EFI_LOAD_ERROR;
    }

    Out->ClearScreen(Out);
    Out->EnableCursor(Out,TRUE);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainEditorCleanup (
    VOID
    )
{
    EFI_STATUS      Status;

    Status = MainEditor.BufferImage->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"BufferImage cleanup failed\n");
    }

    Print(L"BufferImage Cleanup OK");

    Status = MainEditor.TitleBar->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"TitleBar cleanup failed\n");
    }
    Print(L"Title Bar Cleanup OK");

    Status = MainEditor.MenuBar->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"MenuBar cleanup failed\n");
    }

    Status = MainEditor.InputBar->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"InputBar cleanup failed\n");
    }

    Status = MainEditor.FileBuffer->Cleanup();
    if (EFI_ERROR (Status)) {
        Print (L"FileBuffer cleanup failed\n");
    }
    Print(L"FileBuffer Cleanup OK");

    Status = MainEditor.StatusBar->Cleanup();
    if (EFI_ERROR (Status))  {
        Print (L"StatusBar cleanup failed\n");
    }

    if ( OriginalMode != Out->Mode->Mode) {
        Out->SetMode(Out,OriginalMode);
    }
    Out->SetAttribute(Out,EFI_TEXT_ATTR(OriginalColors.Foreground,OriginalColors.Background));
    Out->ClearScreen (Out);


    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
MainEditorKeyInput (
    VOID
    )
{
    EFI_INPUT_KEY   Key;
    EFI_STATUS      Status;
    UINTN           i =0;

    do {
        /* Get Key Input */
        WaitForSingleEvent(In->WaitForKey,0);
        Status = In->ReadKeyStroke(In,&Key);
        if ( EFI_ERROR(Status)) {
            continue;
        }

        if (IS_VALID_CHAR(Key.ScanCode)) {
            Status = MainEditor.FileBuffer->HandleInput(&Key);
        } else if (IS_DIRECTION_KEY(Key.ScanCode)) {
            Status = MainEditor.FileBuffer->HandleInput(&Key);
        } else if (IS_FUNCTION_KEY(Key.ScanCode)) {
            Status = MainEditor.MenuBar->HandleInput(&Key);
        } else {
            MainEditor.StatusBar->SetStatusString(L"Unknown Command");
        }
    }
    while (!EFI_ERROR(Status));

    return  EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainEditorHandleInput (
    IN  EFI_INPUT_KEY*  Key
) 
{
    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
MainEditorRefresh (
    VOID
    )
{
    MainEditor.TitleBar->Refresh();
    MainEditor.MenuBar->Refresh();
    MainEditor.FileBuffer->Refresh();
    MainEditor.StatusBar->Refresh();
    return EFI_SUCCESS;
}



#endif  /* _LIB_EDITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libdiskimage.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libDiskImage.c

  Abstract:
    Describes the routines for handling and editing a disk buffer in memory

--*/

#ifndef _LIB_DISK_IMAGE
#define _LIB_DISK_IMAGE

#include "libMisc.h"

extern  EE_BUFFER_IMAGE BufferImage;

STATIC  EFI_STATUS  DiskImageInit (VOID);
STATIC  EFI_STATUS  DiskImageCleanup (VOID);
STATIC  EFI_STATUS  DiskImageOpen (VOID);
STATIC  EFI_STATUS  DiskImageClose (VOID);
STATIC  EFI_STATUS  DiskImageRead (VOID);
STATIC  EFI_STATUS  DiskImageWrite (VOID);
STATIC  EFI_STATUS  DiskImageSetSize    (UINTN);
STATIC  EFI_STATUS  DiskImageSetOffset  (UINT64);

STATIC  EFI_STATUS  DiskImageSetDevice (CHAR16*);

EE_DISK_IMAGE   DiskImage = {
    NULL,
    NULL,
    0,
    0,
    DiskImageInit,
    DiskImageSetDevice,
    DiskImageSetOffset,
    DiskImageSetSize
};


STATIC
EFI_STATUS
DiskImageInit   (
    VOID
    )
{
    EFI_HANDLE      *HandleBuffer = NULL;

    BufferImage.ImageCleanup();

    BufferImage.ImageCleanup    = DiskImageCleanup;
    BufferImage.Open    = DiskImageOpen;
    BufferImage.Close   = DiskImageClose;
    BufferImage.Read    = DiskImageRead;
    BufferImage.Write   = DiskImageWrite;
    BufferImage.BufferType = DISK_BUFFER;

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
DiskImageSetDevice  (
    IN  CHAR16* Device
    )
{
    DiskImage.DevicePath = (EFI_DEVICE_PATH *)ShellGetMap (Device);
    if (DiskImage.DevicePath == NULL) {
        return EFI_INVALID_PARAMETER;
    }

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
DiskImageSetOffset  (
    IN  UINT64 Offset
    )
{
    DiskImage.Offset = Offset;
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
DiskImageSetSize    (
    IN  UINTN Size
    )
{
    DiskImage.Size = Size;
    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
DiskImageCleanup    (
    VOID
    )
{
    DiskImage.Offset = 0;
    DiskImage.Size = 0;
    DiskImage.DevicePath = NULL;

    BufferImage.ImageCleanup = Nothing;
    BufferImage.Open = Nothing;
    BufferImage.Close = Nothing;
    BufferImage.Read = Nothing;
    BufferImage.Write = Nothing;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
DiskImageOpen   (
    VOID
    )
{
    EFI_STATUS  Status;

    if (DiskImage.DevicePath == NULL) {
        return EFI_INVALID_PARAMETER;
    }

    Status = LibDevicePathToInterface (&BlockIoProtocol, DiskImage.DevicePath, &DiskImage.BlkIo);
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"Device Not a BlockIo Device");
        return Status;
    }

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
DiskImageRead   (
    VOID
    )
{
    VOID            *Buffer;
    CHAR16          *Str;
    EFI_BLOCK_IO    *BlockIo = DiskImage.BlkIo;
    UINTN           Bytes;
    EFI_STATUS      Status;


    if (DiskImage.Offset > MultU64x32 (BlockIo->Media->LastBlock, BlockIo->Media->BlockSize)) {
        DiskImage.Offset = 0;
    }

    Bytes = BlockIo->Media->BlockSize*DiskImage.Size;
    Buffer = AllocatePool (Bytes);

    if (Buffer == NULL) {
        EditorError(EFI_OUT_OF_RESOURCES,L"DiskImageRead: Could not allocate memory for buffer");
        return EFI_OUT_OF_RESOURCES;
    }

    Status = BlockIo->ReadBlocks    (
        BlockIo, 
        BlockIo->Media->MediaId, 
        DiskImage.Offset, 
        Bytes,
        Buffer
        );

    if (EFI_ERROR(Status)) {
        EditorError(Status,L"DiskImageRead: Error in reading");
    } else {
        BufferToList(BufferImage.ListHead,Bytes,Buffer);
    }

    FreePool(Buffer);
    
    Str = PoolPrint(L"%d Bytes Read",Bytes);
    MainEditor.StatusBar->SetStatusString(Str);
    FreePool (Str);

    return Status;
}

STATIC
EFI_STATUS
DiskImageClose  (
    VOID
    )
{
    LineDeleteAll(BufferImage.ListHead);
    BufferImage.NumBytes = 0;

    MainEditor.FileBuffer->Offset = 0x00;
    MainEditor.StatusBar->SetOffset(0x00);
    MainEditor.FileBuffer->LowVisibleOffset = 0x00;

    MainEditor.FileBuffer->SetPosition(DISP_START_ROW,HEX_POSITION);

    MainEditor.FileModified = FALSE;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
DiskImageWrite  (
    VOID
    )
{
    EFI_STATUS  Status;
    VOID        *Buffer;
    UINTN       Bytes;


    DiskImage.Size = MainEditor.BufferImage->NumBytes;

    Bytes = DiskImage.BlkIo->Media->BlockSize*DiskImage.Size;
    Buffer = AllocatePool (Bytes);

    if (Buffer == NULL) {
        EditorError(EFI_OUT_OF_RESOURCES,L"DiskImageWrite: Could not allocate memory for buffer");
        return EFI_OUT_OF_RESOURCES;
    }

    /* 
     * Convert from list to buffer
     */

    Status = DiskImage.BlkIo->WriteBlocks(DiskImage.BlkIo, DiskImage.BlkIo->Media->MediaId, DiskImage.Offset, Bytes, Buffer);

    if (EFI_ERROR(Status)) {
        EditorError(Status,L"DiskImageWrite: Error in writing");
    }

    FreePool(Buffer);
    return Status;
}



#endif  /* _LIB_DISK_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libfileimage.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libFileImage.c

  Abstract:
    Defines the properties and the operation of the FileImage data type, which
    is the image of the entire file that resides in memory.

--*/

#ifndef _LIB_FILE_IMAGE
#define _LIB_FILE_IMAGE

#include "libMisc.h"

#define FILE_ATTRIBUTES     EFI_FILE_MODE_READ  | \
                            EFI_FILE_MODE_WRITE | \
                            EFI_FILE_MODE_CREATE
#define FILE_READ_WRITE     EFI_FILE_MODE_READ  | \
                            EFI_FILE_MODE_WRITE
#define FILE_CREATE         EFI_FILE_MODE_READ  | \
                            EFI_FILE_MODE_WRITE | \
                            EFI_FILE_MODE_CREATE

STATIC  EFI_STATUS  FileImageInit   (VOID);
STATIC  EFI_STATUS  FileImageCleanup(VOID);
STATIC  EFI_STATUS  FileImageOpen   (VOID);
STATIC  EFI_STATUS  FileImageRead   (VOID);
STATIC  EFI_STATUS  FileImageClose  (VOID);
STATIC  EFI_STATUS  FileImageWrite  (VOID);
STATIC  EFI_STATUS  FileImageSetFilename(CHAR16*);

extern  EE_BUFFER_IMAGE BufferImage;

EE_FILE_IMAGE   FileImage = {
    NULL,
    NULL,
    NULL,
    FileImageInit,
    FileImageSetFilename
};

STATIC
EFI_STATUS
FileImageInit   (
    VOID
    )
{
    EFI_STATUS          Status;
    EFI_LOADED_IMAGE    *LoadedImage;
    EFI_DEVICE_PATH     *DevicePath;
    EFI_FILE_IO_INTERFACE   *Vol;

    BufferImage.Close();
    BufferImage.ImageCleanup();

    Status = BS->HandleProtocol (*MainEditor.ImageHandle,&LoadedImageProtocol,&LoadedImage);
    if (EFI_ERROR(Status)) {
        Print (L"Could not obtain Loaded Image Protocol\n");
        return EFI_LOAD_ERROR;
    }
    Status = BS->HandleProtocol (LoadedImage->DeviceHandle,&DevicePathProtocol,&DevicePath);
    if (EFI_ERROR(Status) || DevicePath == NULL) {
        Print (L"Could not obtain Device Path Protocol\n");
        return EFI_LOAD_ERROR;
    }

    Status = BS->HandleProtocol (LoadedImage->DeviceHandle,&FileSystemProtocol,&Vol);
    if (EFI_ERROR(Status)) {
        Print (L"Could not obtain File System Protocol\n");
        return EFI_LOAD_ERROR;
    }

    Status = Vol->OpenVolume(Vol,&FileImage.CurrentDir);
    if ( EFI_ERROR(Status) ) {
        Print (L"Could not open volume for the filesystem\n");
        return EFI_LOAD_ERROR;
    }

    FileImage.FileName = PoolPrint(L"NewFile.bin");

    MainEditor.BufferImage->Open    = FileImageOpen;
    MainEditor.BufferImage->Close   = FileImageClose;
    MainEditor.BufferImage->Read    = FileImageRead;
    MainEditor.BufferImage->Write   = FileImageWrite;
    MainEditor.BufferImage->ImageCleanup    = FileImageCleanup;
    MainEditor.BufferImage->BufferType = FILE_BUFFER;

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileImageOpen (
    VOID
    ) 
{
    EFI_STATUS  Status;

    Status = FileImage.CurrentDir->Open (FileImage.CurrentDir,&FileImage.FileHandle,FileImage.FileName,FILE_ATTRIBUTES,0);

    if (EFI_ERROR(Status)) {
        MainEditor.StatusBar->SetStatusString(L"File Could Not be Opened");
        return EFI_NOT_FOUND;
    }

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileImageCleanup    (
    VOID
    )
{
    FreePool(FileImage.FileName);

    BufferImage.ImageCleanup = Nothing;
    BufferImage.Open = Nothing;
    BufferImage.Close = Nothing;
    BufferImage.Read = Nothing;
    BufferImage.Write = Nothing;

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileImageRead ( 
    VOID
    )
{
    UINTN       FileSize;
    VOID        *FileBuffer;
    CHAR16      *Status;

    FileSize = 0x100000;
    FileBuffer = AllocatePool(FileSize);

    if ( FileBuffer == NULL ) {
        Print(L"%ECould not allocate File Buffer\n%N");
        return EFI_OUT_OF_RESOURCES;
    }

    FileImage.FileHandle->Read(FileImage.FileHandle,&FileSize,FileBuffer);

    BufferToList (BufferImage.ListHead,FileSize,FileBuffer);

    FreePool (FileBuffer);
    
    FileImage.FileHandle->Close(FileImage.FileHandle);

    Status = PoolPrint(L"0x%x Bytes Read",FileSize);
    MainEditor.StatusBar->SetStatusString(Status);
    FreePool (Status);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS  
FileImageWrite (
    VOID
    )
{
    EFI_STATUS      Status;
    UINTN           Length = 0;
    CHAR16          *Str;
    VOID            *Buffer;

    Status = FileImage.CurrentDir->Open (FileImage.CurrentDir,&FileImage.FileHandle,FileImage.FileName,FILE_READ_WRITE,0);
    if (!EFI_ERROR(Status)) {
            Status = FileImage.FileHandle->Delete (FileImage.FileHandle);
        if (EFI_ERROR(Status)) {
            EditorError(Status,L"Error Deleting File");
            return EFI_SUCCESS;
        }
    } 

    Status = FileImage.CurrentDir->Open (FileImage.CurrentDir,&FileImage.FileHandle,FileImage.FileName,FILE_CREATE,0);
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"Error Accessing File");
        return EFI_SUCCESS;
    }

    Status = ListToBuffer(BufferImage.ListHead,&Length,&Buffer);

    if (EFI_ERROR(Status)) {
        EditorError(Status,L"FileImageWrite: Could not allocate buffer");
        return Status;
    }

    Status = FileImage.FileHandle->Write(FileImage.FileHandle,&Length,Buffer);
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Error Writing File");
        return Status;
    }

    FreePool(Buffer);

    Str = PoolPrint(L"0x%x Bytes Written",Length);
    MainEditor.StatusBar->SetStatusString(Str);
    FreePool(Str);

    Status = FileImage.CurrentDir->Close(FileImage.FileHandle);
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Error Closing File");
        return Status;
    }

    return  EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileImageClose ( 
    VOID 
    )
{
    LineDeleteAll(BufferImage.ListHead);
    BufferImage.NumBytes = 0;

    MainEditor.FileBuffer->Offset = 0x00;
    MainEditor.StatusBar->SetOffset(0x00);
    MainEditor.FileBuffer->LowVisibleOffset = 0x00;

    MainEditor.FileBuffer->SetPosition(DISP_START_ROW,HEX_POSITION);

    MainEditor.FileModified = FALSE;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileImageSetFilename    (
    IN  CHAR16* Filename
    )
{
    if (Filename == NULL) {
        return EFI_LOAD_ERROR;
    }
    if (FileImage.FileName != NULL) {
        FreePool(FileImage.FileName);
    }
    FileImage.FileName = PoolPrint(Filename);
    return EFI_SUCCESS;
}



#endif  /* _LIB_FILE_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libmemimage.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libMemImage.c

  Abstract:
    Defines the routines for handling a memory buffer

--*/

#ifndef _LIB_MEM_IMAGE
#define _LIB_MEM_IMAGE

#include "libMisc.h"

STATIC  EFI_STATUS  MemImageInit (VOID);
STATIC  EFI_STATUS  MemImageOpen (VOID);
STATIC  EFI_STATUS  MemImageClose (VOID);
STATIC  EFI_STATUS  MemImageCleanup (VOID);
STATIC  EFI_STATUS  MemImageRead (VOID);
STATIC  EFI_STATUS  MemImageWrite (VOID);
STATIC  EFI_STATUS  MemImageSetOffset (UINTN);
STATIC  EFI_STATUS  MemImageSetSize (UINTN);

extern  EE_BUFFER_IMAGE BufferImage;

EE_MEM_IMAGE    MemImage = {
    NULL,
    0,
    0,
    MemImageInit,
    MemImageSetOffset,
    MemImageSetSize,
};

STATIC
EFI_STATUS
MemImageInit    (
    VOID
    )
{
    BufferImage.ImageCleanup();

    MemImage.IoFncs = AllocatePool(sizeof(EFI_DEVICE_IO_INTERFACE));

    BufferImage.ImageCleanup = MemImageCleanup;
    BufferImage.Open = MemImageOpen;
    BufferImage.Close = MemImageClose;
    BufferImage.Read = MemImageRead;
    BufferImage.Write = MemImageWrite;
    BufferImage.BufferType = MEM_BUFFER;

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
MemImageOpen    (
    VOID
    )
{
    EFI_STATUS  Status;
    EFI_HANDLE  Handle;
    EFI_DEVICE_PATH *DevicePath;
    EFI_DEV_PATH    Node;

    ZeroMem(&Node,sizeof(Node));
    Node.DevPath.Type = HARDWARE_DEVICE_PATH;
    Node.DevPath.SubType = HW_MEMMAP_DP;
    SetDevicePathNodeLength(&Node.DevPath,sizeof(MEMMAP_DEVICE_PATH));

    Node.MemMap.StartingAddress = MemImage.Offset;
    Node.MemMap.EndingAddress = MemImage.Offset + MemImage.Size;

    DevicePath = AppendDevicePathNode (EndDevicePath, &Node.DevPath);

    Status = BS->LocateDevicePath(&DevicePathProtocol,
                                &DevicePath,
                                &Handle
                                );
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"MemImageOpen: Could not get DevicePath");
        return Status;
    }

    Status = BS->HandleProtocol (Handle,
                            &DeviceIoProtocol,
                            &MemImage.IoFncs
                            );
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"MemImageOpen: Could not get DeviceIo Protocol");
        return Status;
    }

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MemImageClose   (
    VOID
    )
{
    LineDeleteAll(BufferImage.ListHead);
    BufferImage.NumBytes = 0;

    MainEditor.FileBuffer->Offset = 0x00;
    MainEditor.StatusBar->SetOffset(0x00);
    MainEditor.FileBuffer->LowVisibleOffset = 0x00;

    MainEditor.FileBuffer->SetPosition(DISP_START_ROW,HEX_POSITION);

    MainEditor.FileModified = FALSE;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MemImageCleanup (
    VOID
    )
{
    if (MemImage.IoFncs != NULL) {
        FreePool(MemImage.IoFncs);
    }

    MemImage.Offset = 0;
    MemImage.Size = 0;

    BufferImage.ImageCleanup = Nothing;
    BufferImage.Open = Nothing;
    BufferImage.Close = Nothing;
    BufferImage.Read = Nothing;
    BufferImage.Write = Nothing;

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
MemImageRead    (
    VOID
    )
{
    EFI_STATUS  Status;
    VOID        *Buffer;

    Buffer = AllocatePool(MemImage.Size);

    Status = MemImage.IoFncs->Mem.Read (
                        MemImage.IoFncs,
                        IO_UINT8,
                        MemImage.Offset,
                        MemImage.Size,
                        Buffer
                        );

    if (EFI_ERROR(Status)) {
        EditorError(Status,L"MemImageRead: Trouble Reading Memory");
        return Status;
    }

    BufferToList(BufferImage.ListHead,MemImage.Size,Buffer);

    FreePool(Buffer);

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
MemImageWrite   (
    VOID
    )
{
    EFI_STATUS  Status;
    VOID        *Buffer;

    MemImage.Size = MainEditor.BufferImage->NumBytes;
    Buffer = AllocatePool(MemImage.Size);

    /* 
     *  Construct the buffer from the list of lines
     */

    Status = MemImage.IoFncs->Mem.Write (
                            MemImage.IoFncs,
                            IO_UINT8,
                            MemImage.Offset,
                            MemImage.Size,
                            Buffer
                            );

    if (EFI_ERROR(Status)) {
        EditorError(Status,L"Trouble Writing Memory");
    }

    FreePool(Buffer);

    return Status; 
}

STATIC
EFI_STATUS
MemImageSetOffset   (
    IN  UINTN   Offset
    )
{
    MemImage.Offset = Offset;
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
MemImageSetSize (
    IN  UINTN   Size
    )
{
    MemImage.Size = Size;
    return EFI_SUCCESS; 
}



#endif  _LIB_MEM_IMAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libfilebuffer.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libFileBuffer.c

--*/

#ifndef _LIB_FILE_BUFFER
#define _LIB_FILE_BUFFER

#include "libMisc.h"


#define ABSOLUTE_MAX_COLUMNS    132
STATIC  CHAR16  BlankLine[ABSOLUTE_MAX_COLUMNS];

STATIC  EFI_STATUS  FileBufferScrollUp (VOID);
STATIC  EFI_STATUS  FileBufferScrollDown (VOID);
STATIC  EFI_STATUS  FileBufferScrollLeft (VOID);
STATIC  EFI_STATUS  FileBufferScrollRight (VOID);
STATIC  EFI_STATUS  FileBufferPageUp (VOID);
STATIC  EFI_STATUS  FileBufferPageDown (VOID);
STATIC  EFI_STATUS  FileBufferHome  (VOID);
STATIC  EFI_STATUS  FileBufferEnd   (VOID);

STATIC  EFI_STATUS  FileBufferDoDelete (VOID);
STATIC  EFI_STATUS  FileBufferDoBackspace (VOID);
STATIC  EFI_STATUS  FileBufferDoHexInput (CHAR16);

STATIC  EFI_STATUS  FileBufferRefreshCurrentLine(VOID);
STATIC  EFI_STATUS  FileBufferRefreshDown (VOID);

STATIC  EFI_STATUS  FileBufferInit (VOID);
STATIC  EFI_STATUS  FileBufferCleanup (VOID);
STATIC  EFI_STATUS  FileBufferRefresh (VOID);
STATIC  EFI_STATUS  FileBufferHide (VOID);
STATIC  EFI_STATUS  FileBufferHandleInput (EFI_INPUT_KEY*);

STATIC  EFI_STATUS  FileBufferClearLine (UINTN);
STATIC  EFI_STATUS  FileBufferSetPosition (UINTN,UINTN);
STATIC  EFI_STATUS  FileBufferRestorePosition (VOID);
STATIC  UINTN       DisplayPosition();


EE_FILE_BUFFER  FileBuffer = {
    {0,0},
    0x00,
    0x00,
    0x00,
    0x00,
    NULL,
    FileBufferInit,
    FileBufferCleanup,
    FileBufferRefresh,
    FileBufferHide,
    FileBufferHandleInput,
    FileBufferClearLine,
    FileBufferSetPosition,
    FileBufferRestorePosition,
};


STATIC
EFI_STATUS
FileBufferInit (
    VOID
    )
{ 
    UINTN   i;

    FileBuffer.DisplayPosition.Row = TEXT_START_ROW;
    FileBuffer.DisplayPosition.Column = HEX_POSITION;

    FileBuffer.MaxVisibleBytes = MAX_TEXT_ROWS * 0x10;

    for (i = 0; i < ABSOLUTE_MAX_COLUMNS; i++) {
        BlankLine[i] = ' ';
    }

    LineCreateNode(MainEditor.BufferImage->ListHead);
    FileBuffer.CurrentLine = MainEditor.BufferImage->ListHead->Flink;

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferCleanup   (
    VOID
    )
{
    return EFI_SUCCESS; 
}

STATIC
VOID
RefreshOffset   (
    VOID
    )
{
    PrintAt(0,FileBuffer.DisplayPosition.Row,L"%X",FileBuffer.Offset&0xfffffff0);
    FileBufferRestorePosition();
}

STATIC
EFI_STATUS
FileBufferRefresh (
    VOID
    )
{
    UINTN               i;
    UINTN               Limit;
    LIST_ENTRY          *Item;
    UINTN               Offset = 0x00;
    UINTN               Row;

    Item = MainEditor.BufferImage->ListHead->Flink;
    FileBuffer.HighVisibleOffset = FileBuffer.MaxVisibleBytes;
    Row = FileBuffer.LowVisibleOffset / 0x10;

    for (i = 0; i < Row && Item != MainEditor.BufferImage->ListHead; i++) {
        Item = Item->Flink;
        FileBuffer.HighVisibleOffset += 0x10;
        Offset += 0x10;
    }

    Limit = FileBuffer.MaxVisibleBytes / 0x10;

    i = TEXT_START_ROW;

    for (i = TEXT_START_ROW; i <= Limit; i++) {
        if (Item->Flink != MainEditor.BufferImage->ListHead) {
            LinePrint (Item,Offset,i);
            Offset += 0x10;
            Item = Item->Flink;
        } else {
            FileBufferClearLine(i);
        }
    }

    RefreshOffset();

    FileBufferRestorePosition();
    return EFI_SUCCESS; 
}

STATIC  
EFI_STATUS
FileBufferRefreshDown (
    VOID
    )
{
    UINTN           Limit;
    LIST_ENTRY      *Link;
    UINTN           i;
    UINTN           Offset;

    Limit = FileBuffer.MaxVisibleBytes / 0x10;
    Offset = FileBuffer.Offset & 0xfffffff0;

    Link = FileBuffer.CurrentLine;

/*   while (Link != MainEditor.BufferImage->ListHead) { */
    for (i = FileBuffer.DisplayPosition.Row; i < TEXT_END_ROW; i++) {
        if (Link->Flink != MainEditor.BufferImage->ListHead) {
            LinePrint (Link,Offset,i);  
            Link = Link->Flink;
            Offset += 0x10;
        } else {
            FileBufferClearLine(i);
        }
    }

    FileBufferRestorePosition();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferHandleInput (
    IN  EFI_INPUT_KEY*  Key
    )
{ 

    switch (Key->ScanCode) {
    case    SCAN_CODE_NULL:
        FileBufferDoHexInput (Key->UnicodeChar);
        break;
    case    SCAN_CODE_UP:
        FileBufferScrollUp();
        break;
    case    SCAN_CODE_DOWN:
        FileBufferScrollDown();
        break;
    case    SCAN_CODE_RIGHT:
        FileBufferScrollRight();
        break;
    case    SCAN_CODE_LEFT:
        FileBufferScrollLeft();
        break;
    case    SCAN_CODE_PGUP:
        FileBufferPageUp();
        break;
    case    SCAN_CODE_PGDN:
        FileBufferPageDown();
        break;
    case    SCAN_CODE_DEL:
        FileBufferDoDelete();
        break;
    case    SCAN_CODE_HOME:
        FileBufferHome();
        break;
    case    SCAN_CODE_END:
        FileBufferEnd();
        break;
    default:
        break;
    }

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferHide (
    VOID
    )
{ 
    UINTN   i;
    UINTN   NumLines;

    NumLines = FileBuffer.MaxVisibleBytes / 0x10;

    for (i = TEXT_START_ROW; i <= NumLines; i++) {
        FileBufferClearLine(i);
    }

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferRefreshCurrentLine (
    VOID
    )
{
    UINTN   Where;

    Where = FileBuffer.DisplayPosition.Row;

    LinePrint(FileBuffer.CurrentLine,(FileBuffer.Offset & 0xfffffff0),Where);
    FileBufferRestorePosition();
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferRefreshCurrentDigit (
    VOID
    )
{
    UINTN   Row;
    UINTN   Pos;

    Row = FileBuffer.DisplayPosition.Row;
    Pos = FileBuffer.Offset % 0x10;

    DigitPrint(FileBuffer.CurrentLine,Pos,Row);
    FileBufferRestorePosition();
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferClearLine (
    UINTN Line
    ) 
{
    BlankLine[MAX_TEXT_COLUMNS-1] = 0;
    PrintAt(0,Line,BlankLine);
    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileBufferSetPosition (
    IN  UINTN   Row,
    IN  UINTN   Column
    )
{
    FileBuffer.DisplayPosition.Row = Row;
    FileBuffer.DisplayPosition.Column = Column;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferRestorePosition (
    VOID
    )
{
    Out->SetCursorPosition (Out,FileBuffer.DisplayPosition.Column,FileBuffer.DisplayPosition.Row);

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
FileBufferScrollDown (
    VOID
)
{
    UINTN   MaxBytes;
    UINTN   HighOffset;
    UINTN   CurrentRow;
    UINTN   CurrentOffset;
    UINTN   MaxRows;
    UINTN   HighRow;
    UINTN   NumBytes;
    UINTN   NumLines;
    UINTN   DisplayOffset;
    EE_LINE *Line;

    CurrentRow = FileBuffer.DisplayPosition.Row;
    Line = LineCurrent();

    MaxBytes = FileBuffer.MaxVisibleBytes;
    HighOffset = FileBuffer.HighVisibleOffset;

    MaxRows = TEXT_END_ROW;
    HighRow = HighOffset/0x10;

    NumBytes = MainEditor.BufferImage->NumBytes;
    NumLines = NumBytes / 0x10;

    if (Line->Link.Flink == MainEditor.BufferImage->ListHead->Blink) {
        return EFI_SUCCESS;
    }

    CurrentOffset = FileBuffer.Offset + 0x10;
    FileBuffer.Offset = CurrentOffset;
    
    if (CurrentRow == (MaxRows - 1)) {      
        FileBuffer.LowVisibleOffset += 0x10;
        FileBuffer.HighVisibleOffset += 0x10;
        CurrentRow = MaxRows - 1;
    
        FileBuffer.Refresh();
    } else if (CurrentRow == HighRow) {
        return EFI_SUCCESS;
    } else {
        ++CurrentRow;
    }

    Line = LineNext ();

    if ((CurrentOffset % 0x10) < Line->Size) {
        DisplayOffset = FileBuffer.DisplayPosition.Column;
    } else {
        CurrentOffset = NumBytes;
        DisplayOffset = (Line->Size*3) + HEX_POSITION;
        if (Line->Size > 0x07) {
            ++DisplayOffset;
        }
    }


    FileBuffer.SetPosition(CurrentRow,DisplayOffset);

    MainEditor.StatusBar->SetOffset(CurrentOffset);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferScrollUp (
    VOID
    )
{
    UINTN           CurrentRow;
    UINTN           MaxRows;
    UINTN           LowRow;
    UINTN           MaxBytes;
    UINTN           LowOffset;
    UINTN           CurrentOffset;

    CurrentOffset = FileBuffer.Offset;

    if ( CurrentOffset < 0x10 ) {
        return EFI_SUCCESS;
    }

    MaxBytes = FileBuffer.MaxVisibleBytes;
    MaxRows = MaxBytes / 0x10;
    LowOffset = FileBuffer.LowVisibleOffset;
    LowRow = LowOffset / 0x10;

    CurrentRow = FileBuffer.DisplayPosition.Row;

    CurrentOffset -= 0x10;
    FileBuffer.Offset -= 0x10;
    
    if (CurrentRow == 1) {
        FileBuffer.HighVisibleOffset -= 0x10;
        FileBuffer.LowVisibleOffset -= 0x10;
        CurrentRow = 1;
        FileBuffer.Refresh();
    } else {
        CurrentRow--;
    }

    LinePrevious ();

    FileBuffer.SetPosition(CurrentRow,FileBuffer.DisplayPosition.Column);
    
    MainEditor.StatusBar->SetOffset(CurrentOffset);

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS
FileBufferPageUp (
    VOID
    )
{
    UINTN   MaxBytes;
    UINTN   LowOffset;
    UINTN   CurrentOffset;
    BOOLEAN Refresh = FALSE;

    CurrentOffset = FileBuffer.Offset;
    MaxBytes = FileBuffer.MaxVisibleBytes;
    LowOffset = FileBuffer.LowVisibleOffset;

    if (LowOffset <= MaxBytes) {
        FileBuffer.HighVisibleOffset = MaxBytes - 0x10;
        FileBuffer.LowVisibleOffset = 0x00;

                if (LowOffset > 0x00) { 
            if (CurrentOffset < MaxBytes) {
                FileBuffer.Offset = 0x00;
            } else {
                FileBuffer.Offset -= (MaxBytes - 0x10);
            }
        } else {
            FileBuffer.Offset = 0x00;
        }
        
        Refresh = TRUE;
        
        FileBuffer.DisplayPosition.Row = FileBuffer.Offset/0x10 + TEXT_START_ROW;
    } else {
        FileBuffer.HighVisibleOffset = LowOffset - 0x10;
        FileBuffer.LowVisibleOffset -= (MaxBytes - 0x10);
        FileBuffer.Offset -= (MaxBytes - 0x10);
        Refresh = TRUE;
    }

    CurrentOffset -= FileBuffer.Offset;
    CurrentOffset /= 0x10;
    LineRetreat(CurrentOffset);

    if (Refresh) {
        FileBufferRefresh();
    }
    FileBuffer.DisplayPosition.Column = DisplayPosition();

    MainEditor.StatusBar->SetOffset(FileBuffer.Offset);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferPageDown (
    VOID
    )
{ 
    UINTN   NumBytes;
    UINTN   MaxBytes;
    UINTN   HighOffset;
    UINTN   CurrentOffset;

    NumBytes = MainEditor.BufferImage->NumBytes;
    MaxBytes = FileBuffer.MaxVisibleBytes;
    HighOffset = FileBuffer.HighVisibleOffset;
    CurrentOffset = FileBuffer.Offset;

    FileBuffer.Offset = min(NumBytes,CurrentOffset+MaxBytes-0x10);
    if (HighOffset < NumBytes) {
        FileBuffer.LowVisibleOffset = HighOffset-0x10;
        FileBuffer.HighVisibleOffset += (MaxBytes - 0x10);
        FileBuffer.Refresh();
        LineAdvance((FileBuffer.Offset-CurrentOffset)/0x10);
    } else if (FileBuffer.Offset >= NumBytes-1) {
        FileBuffer.Offset &= 0xfffffff0;
        FileBuffer.Offset |= ((NumBytes-1) & 0x00000001f);
        FileBuffer.CurrentLine = LineLast()->Link.Blink;
    }

    FileBuffer.DisplayPosition.Column = DisplayPosition();
    FileBuffer.DisplayPosition.Row = (FileBuffer.Offset-FileBuffer.LowVisibleOffset)/0x10 + TEXT_START_ROW;

    MainEditor.StatusBar->SetOffset (FileBuffer.Offset);

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferScrollLeft (
    VOID
    )
{
    UINTN   LineOffset;

    LineOffset = FileBuffer.Offset % 0x10;

    if (FileBuffer.Offset == 0x00) {
        return EFI_SUCCESS;
    }

    if (LineOffset == 0x00) {
        FileBufferScrollUp ();
        FileBuffer.Offset += 0x10;
        LineOffset = 0x0f;
    } else {
        --LineOffset;
    }
    FileBuffer.DisplayPosition.Column = HEX_POSITION + (LineOffset*3);
    if (LineOffset > 0x07) {
        ++FileBuffer.DisplayPosition.Column;
    }
    --FileBuffer.Offset;

    MainEditor.StatusBar->SetOffset(FileBuffer.Offset);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferScrollRight (
    VOID
    )
{ 
    UINTN   CurrentOffset;
    UINTN   LineOffset;
    EE_LINE *Line;

    Line = LineCurrent();
    CurrentOffset = FileBuffer.Offset;
    LineOffset = CurrentOffset % 0x10;

    if (CurrentOffset >= MainEditor.BufferImage->NumBytes){
        return EFI_SUCCESS;
    } 
    if (LineOffset > Line->Size) {
        return EFI_SUCCESS;
    }

    if (LineOffset == 0x0f) {
        FileBufferScrollDown();
        FileBuffer.Offset &= 0xfffffff0;
        FileBuffer.DisplayPosition.Column = HEX_POSITION;
        RefreshOffset();
    } else {
        ++LineOffset;
        FileBuffer.DisplayPosition.Column = HEX_POSITION + (LineOffset*3);
        if (LineOffset > 0x07) {
            ++FileBuffer.DisplayPosition.Column;
        }
        ++FileBuffer.Offset;
    }

    MainEditor.StatusBar->SetOffset(FileBuffer.Offset);
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferHome  (
    VOID
    )
{
    FileBuffer.DisplayPosition.Column = HEX_POSITION;
    FileBuffer.Offset &= 0xfffffff0;

    MainEditor.StatusBar->SetOffset(FileBuffer.Offset);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferEnd   (
    VOID
    )
{
    EE_LINE *Line;

    Line = LineCurrent();
    FileBuffer.Offset &= 0xfffffff0;
    if (Line->Size > 0) {
        FileBuffer.Offset |= ((Line->Size-1) & 0x0000000f);
    }
    FileBuffer.DisplayPosition.Column = DisplayPosition();
    MainEditor.StatusBar->SetOffset(FileBuffer.Offset);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileBufferDoHexInput (
    IN  CHAR16  Char
    )
{
    EE_LINE *Line;
    UINTN   LineOffset;
    UINTN   Pos;
    UINTN   Num;

    if (Char == CHAR_BS) {
        FileBufferDoBackspace();
        return EFI_SUCCESS;
    }

    if (Char >= 'A' && Char <= 'F') {
        Num = Char - 'A' + 0xa;
    } else if (Char >= 'a' && Char <= 'f') {
        Num = Char - 'a' + 0xa;
    } else if (Char >= '0' && Char <= '9') {
        Num = Char - '0';
    } else {
        return EFI_SUCCESS;
    }

    LineOffset = FileBuffer.Offset % 0x10;
    Pos = FileBuffer.DisplayPosition.Column - HEX_POSITION;
    if (LineOffset > 0x07) {
        Pos -= (0x07*3)+1;
    }

    if (FileBuffer.CurrentLine == MainEditor.BufferImage->ListHead->Blink) {
        Line = LineCreateNode(MainEditor.BufferImage->ListHead);
        FileBuffer.CurrentLine = Line->Link.Blink;
    }

    Line = LineCurrent();

    Line->Buffer[LineOffset] <<= 4;
    Line->Buffer[LineOffset] |= Num;


    if (FileBuffer.Offset == MainEditor.BufferImage->NumBytes) {
        ++Line->Size;
        ++MainEditor.BufferImage->NumBytes;
    } else if (FileBuffer.Offset == (MainEditor.BufferImage->NumBytes - 1)) {
        if ((Pos%3) != 0 && Line->Size == 0x10) {
            Line = LineCreateNode(MainEditor.BufferImage->ListHead);
        }
    }

    FileBufferRefreshCurrentDigit();

    if ((Pos % 3) != 0) {
        FileBufferScrollRight();
    } else {
        ++FileBuffer.DisplayPosition.Column;
    }

    FileBufferRestorePosition();

    FileModification();

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
FileBufferDoBackspace (
    VOID
    )
{
    UINTN   LinePos;

    if (FileBuffer.Offset == 0x00) {
        return EFI_SUCCESS;
    }

    FileBufferScrollLeft();
    LinePos = FileBuffer.Offset % 0x10;

    LineDeleteAt(FileBuffer.CurrentLine,LinePos,1);

    FileBufferRefreshDown();
    FileModification();
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS  
FileBufferDoDelete (
    VOID
    )
{
    LIST_ENTRY      *Link;
    UINTN           LinePos;

    if (FileBuffer.Offset == MainEditor.BufferImage->NumBytes) {
        return EFI_SUCCESS;
    }

    LinePos = FileBuffer.Offset % 0x10;
    Link = FileBuffer.CurrentLine;

    LineDeleteAt(Link,LinePos,1);

    if (FileBuffer.Offset == MainEditor.BufferImage->NumBytes) {
        FileBufferScrollLeft();
    }

    FileBufferRefreshDown();
    FileModification();
    return EFI_SUCCESS; 
}

STATIC
UINTN
DisplayPosition (
    VOID
    )
{
    EE_LINE *Line;
    UINTN   Pos = 0;

    Line = LineCurrent();
    Pos = FileBuffer.Offset & 0x0000000f;
    Pos = Pos * 3 + HEX_POSITION;

    if (Line->Size > 0x07) {
        Pos++;
    }

    return Pos;
}

#endif  /* _LIB_FILE_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libmisc.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libMisc.c

  Abstract:
    Defines various routines for Line handling

--*/


#ifndef _LIB_MISC
#define _LIB_MISC

#include "libMisc.h"

VOID
EditorError (
    IN  EFI_STATUS  Status,
    IN  CHAR16      *Msg
    )
{
    CHAR16  *Str;
    CHAR16  *Error;

    Error = AllocatePool(255);
    StatusToString(Error,Status);
    Str = PoolPrint(L"%s: %s",Msg,Error);
    MainEditor.StatusBar->SetStatusString(Str);

    FreePool(Str);
    FreePool(Error);
}


EE_LINE*
LineDup ( 
    IN  EE_LINE *Src
    )
{
    EE_LINE *Dest;
    UINTN           i;
    Dest = AllocatePool(sizeof(EE_LINE));
    Dest->Signature = EE_LINE_LIST;
    Dest->Size = Src->Size;
    for (i = 0; i < 0x10; i++) {
        Dest->Buffer[i] = Src->Buffer[i];
    }

    Dest->Link = Src->Link;

    return Dest;
}

VOID
LineSplit (
    IN  EE_LINE     *Src,
    IN  UINTN               Pos,
    OUT EE_LINE     *Dest
    )
{
    UINTN   i;
    Dest->Size = Src->Size - Pos;
    for (i = 0; (i+Pos) < Src->Size; i++) {
        Dest->Buffer[i] = Src->Buffer[Pos+i];
    }
}

VOID
LineMerge (
    IN  OUT EE_LINE*    Line1,
    IN      UINTN               Line1Pos,
    IN      EE_LINE*    Line2,
    IN      UINTN               Line2Pos
    )
{
    UINTN   Size;
    UINTN   i;

    Size = Line1Pos + Line2->Size - Line2Pos;
    Line1->Size = Size;

    for (i = 0; i + Line2Pos < 0x10; i++) {
        Line1->Buffer[Line1Pos+i] = Line2->Buffer[Line2Pos+i];
    }

}


EE_LINE*
LineFirst (
    VOID
    )
{
    MainEditor.FileBuffer->CurrentLine = MainEditor.BufferImage->ListHead->Flink;
    return LineCurrent();
}

EE_LINE*
LineLast (
    VOID
    )
{
    MainEditor.FileBuffer->CurrentLine = MainEditor.BufferImage->ListHead->Blink;
    return LineCurrent();
}

EE_LINE*
LineNext (
    VOID
    )
{
    MainEditor.FileBuffer->CurrentLine = MainEditor.FileBuffer->CurrentLine->Flink;
    return LineCurrent();
}

EE_LINE*
LinePrevious (
    VOID
    )
{ 
    MainEditor.FileBuffer->CurrentLine = MainEditor.FileBuffer->CurrentLine->Blink;
    return LineCurrent();
}

EE_LINE*
LineAdvance (
    IN  UINTN Count
    )
{
    UINTN   i;

    for (i = 0; i < Count && (MainEditor.FileBuffer->CurrentLine->Flink != MainEditor.BufferImage->ListHead); i++ ) {
        MainEditor.FileBuffer->CurrentLine = MainEditor.FileBuffer->CurrentLine->Flink;
    }
    return LineCurrent();
}

EE_LINE*
LineRetreat (
    IN  UINTN Count
    )
{ 
    UINTN   i;

    for (i = 0; i < Count && (MainEditor.FileBuffer->CurrentLine->Blink != MainEditor.BufferImage->ListHead); i++ ) {
        MainEditor.FileBuffer->CurrentLine = MainEditor.FileBuffer->CurrentLine->Blink;
    }
    return LineCurrent();
}

EE_LINE*
LineCurrent (VOID)
{
    return CR(MainEditor.FileBuffer->CurrentLine,EE_LINE,Link,EE_LINE_LIST);
}

VOID
LineDeleteAt    (
    LIST_ENTRY* Link,
    UINTN       Pos,
    UINTN       Num
    )
{
    EE_LINE     *Line;
    EE_LINE     *Next;
    UINTN       LinePos;
    UINTN       NextPos;
    LIST_ENTRY  *NextLink;
    LIST_ENTRY  *Blank;

    NextLink = Link;

    MainEditor.BufferImage->NumBytes -= Num;
    Num += Pos;
    while (Num > 0x10) {
        NextLink = NextLink->Flink;
        Num -= 0x10;
    }

    Blank = MainEditor.BufferImage->ListHead->Blink;

    Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);
    Next = CR(NextLink,EE_LINE,Link,EE_LINE_LIST);
    NextPos = Num;
    LinePos = Pos;

    while (NextLink != Blank) {
        while (LinePos < Line->Size && NextPos < Next->Size) {
            Line->Buffer[LinePos] = Next->Buffer[NextPos];
            ++LinePos;
            ++NextPos;
        }
        if (NextPos == Next->Size) {
            NextLink = NextLink->Flink;
            Next = CR(NextLink,EE_LINE,Link,EE_LINE_LIST);
            NextPos = 0;
        }
        if (LinePos == Line->Size) {
            Link = Link->Flink;
            Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);
            LinePos = 0;
        }
    }
    Line->Size = LinePos;
    Link = Link->Flink;

    while (Link != Blank) {
        Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);
        NextLink = Link->Flink;
        RemoveEntryList(Link);
        FreePool(Line);
        Link = NextLink;
    }
}

VOID
LinePrint   (
    LIST_ENTRY* Link,
    UINTN       Offset,
    UINTN       Row
    )
{
    EE_LINE *Line;
    UINTN   j;
    UINTN   Pos;

    if (Row > DISP_MAX_ROWS) {
        return;
    }
    MainEditor.FileBuffer->ClearLine (Row);

    Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);

    PrintAt(0,Row,L"%X",Offset);
    if (Line->Size == 0) {
        return;
    }

    for (j = 0; j < 0x08 && j < Line->Size; j++) {
        Pos = HEX_POSITION + (j*3);
        if (Line->Buffer[j] < 0x10) {
            PrintAt(Pos,Row,L"0");
            ++Pos;
        }
        PrintAt(Pos,Row,L"%x ",Line->Buffer[j]);
    }
    while (j < 0x10 && j < Line->Size) {
        Pos = HEX_POSITION + (j*3) + 1;
        if (Line->Buffer[j] < 0x10) {
            PrintAt(Pos,Row,L"0");
            ++Pos;
        }
        PrintAt(Pos,Row,L"%x ",Line->Buffer[j]);
        ++j;
    }
    for (j = 0; j < 0x10 && j < Line->Size; j++) {
        Pos = ASCII_POSITION+j;
        if (IsValidChar(Line->Buffer[j])) {
            PrintAt(Pos,Row,L"%c",(CHAR16)Line->Buffer[j]);
        } else {
            PrintAt(Pos,Row,L"%c",'.');
        }
    }

}

VOID
DigitPrint  (
    IN  LIST_ENTRY  *Link,
    IN  UINTN       Digit,
    IN  UINTN       Row
    )
{
    EE_LINE *Line;
    UINTN   Pos;

    Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);

    Pos = HEX_POSITION + (Digit*3);
    if (Digit > 0x07) {
        Pos++;
    }
    if (Line->Buffer[Digit] < 0x10) {
        PrintAt(Pos,Row,L"0");
        ++Pos;
    }
    PrintAt(Pos,Row,L"%x ",Line->Buffer[Digit]);

    Pos = ASCII_POSITION+Digit;
    if (IsValidChar(Line->Buffer[Digit])) {
        PrintAt(Pos,Row,L"%c",(CHAR16)Line->Buffer[Digit]);
    } else {
        PrintAt(Pos,Row,L"%c",'.');
    }
}

UINTN
StrStr  (
    IN  CHAR16  *Str,
    IN  CHAR16  *Pat
    )
{
    INTN    *Failure;
    INTN    i,j;
    INTN    Lenp;
    INTN    Lens;

    Lenp = StrLen(Pat);
    Lens = StrLen(Str);

    Failure = AllocatePool(Lenp*sizeof(INTN));
    Failure[0] = -1;
    for (j=1; j< Lenp; j++ ) {
        i = Failure[j-1];
        while ( (Pat[j] != Pat[i+1]) && (i >= 0)) {
            i = Failure[i];
        }
        if ( Pat[i] == Pat[i+1]) {
            Failure[j] = i+1;
        } else {
            Failure[j] = -1;
        }
    }

    i = 0;
    j = 0;
    while (i < Lens && j < Lenp) {
        if (Str[i] == Pat[j]) {
            i++;
            j++;
        } else if (j == 0) {
            i++;
        } else {
            j = Failure[j-1] + 1;
        }
    }

    FreePool(Failure);

    return ((j == Lenp) ? (i - Lenp) : -1)+1;

}

VOID
FileModification (
    VOID
    )
{
    if ( !MainEditor.FileModified ) {
        MainEditor.StatusBar->SetStatusString(L"File Modified");
        MainEditor.FileModified = TRUE;
    }

}

EFI_STATUS
Nothing (
    VOID
    )
{
    return EFI_SUCCESS;
}


STATIC
VOID
LineDeleteAll (
    IN  LIST_ENTRY* Head
    )
{
    EE_LINE     *Line;
    LIST_ENTRY  *Item;

    Item = Head->Flink;

    while (Item != Head->Blink) {

        RemoveEntryList(Item);

        Line = CR(Item,EE_LINE,Link,EE_LINE_LIST);

        FreePool (Line);
        Item = Head->Flink;
    }
    MainEditor.FileBuffer->CurrentLine = Head->Flink;
}

EE_LINE*
LineCreateNode  (
    IN  LIST_ENTRY* Head
    )
{
    EE_LINE *Line;
    UINTN   i;

    Line = AllocatePool (sizeof(EE_LINE));

    if ( Line == NULL ) {
        MainEditor.StatusBar->SetStatusString(L"LineCreateNode: Could not allocate Node");
        return NULL;
    }
    
    Line->Signature = EE_LINE_LIST;
    Line->Size = 0;

    for (i = 0; i < 0x10; i++) {
        Line->Buffer[i] = 0x00;
    }

    InsertTailList(Head,&Line->Link);

    return Line;
}

VOID
BufferToList    (
    OUT LIST_ENTRY  *Head,
    IN  UINTN       Size,
    IN  VOID        *Buffer
    )
{
    EE_LINE     *Line = NULL;
    UINTN       i = 0;
    UINTN       LineSize;
    UINT8       *UintBuffer;
    LIST_ENTRY  *Blank;

    LineDeleteAll(Head);
    Blank = Head->Flink;
    RemoveEntryList (Blank);

    UintBuffer = Buffer;

    while (i < Size) {

        Line = LineCreateNode (Head);


        if (Line == NULL || Line == (EE_LINE*)BAD_POINTER) {
            EditorError(EFI_OUT_OF_RESOURCES,L"BufferToList: Could not allocate another line");
            break;
        }
        for (LineSize = 0; LineSize < 0x10 && i < Size; LineSize++) {
            Line->Buffer[LineSize] = UintBuffer[i];
            i++;
        }
        Line->Size = LineSize;
    }

    InsertTailList(Head,Blank);

    MainEditor.BufferImage->NumBytes = Size;

    MainEditor.FileBuffer->Offset = 0x00;
    MainEditor.StatusBar->SetOffset(0x00);

    MainEditor.FileBuffer->CurrentLine = MainEditor.BufferImage->ListHead->Flink;
}

EFI_STATUS
ListToBuffer    (
    IN      LIST_ENTRY  *Head,
    IN  OUT UINTN       *Size,
        OUT VOID        **Buffer
    )
{
    EE_LINE     *Line;
    UINTN       i;
    UINTN       LineSize;
    UINT8       *UintBuffer;
    LIST_ENTRY  *Link;
    LIST_ENTRY  *Blank;

    i = 0;

    Blank = Head->Blink;
    RemoveEntryList(Blank);

    *Size = MainEditor.BufferImage->NumBytes;
    *Buffer = AllocatePool(*Size);

    if (*Buffer == NULL) {
        return EFI_OUT_OF_RESOURCES;
    }

    UintBuffer = *Buffer;

    for(Link = Head->Flink; Link != Head; Link = Link->Flink) {

        Line = CR(Link,EE_LINE,Link,EE_LINE_LIST);
        for (LineSize = 0; LineSize < Line->Size; LineSize++) {
            UintBuffer[i] = Line->Buffer[LineSize];
            ++i;
        }

    }
    *Size = i;
    InsertTailList(Head,Blank);

    return EFI_SUCCESS;

}


#endif  /* _LIB_MISC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libmisc.h ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libEtc.h

  Abstract:
    Some Functions for the Misc. Data Structures

--*/

#include "hexedit.h"

VOID    LineSplit   (EE_LINE*,UINTN,EE_LINE*);
VOID    LineMerge   (EE_LINE*,UINTN,EE_LINE*,UINTN);
EE_LINE*    LineDup (EE_LINE*);

EE_LINE*    LineNext (VOID);
EE_LINE*    LineFirst (VOID);
EE_LINE*    LineLast (VOID);
EE_LINE*    LinePrevious (VOID);
EE_LINE*    LineAdvance (UINTN Count);
EE_LINE*    LineRetreat (UINTN Count);
EE_LINE*    LineCurrent (VOID);

VOID        LineDeleteAt(LIST_ENTRY*,UINTN,UINTN);
VOID        LinePrint   (LIST_ENTRY*,UINTN,UINTN);
EE_LINE*    LineCreateNode  (LIST_ENTRY*);
VOID        LineDeleteAll   (LIST_ENTRY*);
VOID        BufferToList (LIST_ENTRY*,UINTN,VOID*);
EFI_STATUS  ListToBuffer (LIST_ENTRY*,UINTN*,VOID**);

VOID    DigitPrint(LIST_ENTRY*,UINTN,UINTN);

UINTN   StrStr  (CHAR16*,CHAR16*);

VOID    FileModification (VOID);

EFI_STATUS  Nothing (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libinputbar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libInputBar.c

  Abstract:
    Defines the Input Bar data type - the interactive query that multiplexes 
    with the Status Bar.

--*/

#ifndef _LIB_INPUT_BAR
#define _LIB_INPUT_BAR

#include "libMisc.h"


STATIC  EFI_STATUS  MainInputBarInit (VOID);
STATIC  EFI_STATUS  MainInputBarCleanup (VOID);
STATIC  EFI_STATUS  MainInputBarRefresh (VOID);
STATIC  EFI_STATUS  MainInputBarHide (VOID);
STATIC  EFI_STATUS  MainInputBarSetPrompt (CHAR16*);
STATIC  EFI_STATUS  MainInputBarSetStringSize (UINTN);

EE_INPUT_BAR MainInputBar = {
    NULL,
    NULL,
    0,
    MainInputBarInit,
    MainInputBarCleanup,
    MainInputBarRefresh,
    MainInputBarHide,
    MainInputBarSetPrompt,
    MainInputBarSetStringSize
};


STATIC
EFI_STATUS
MainInputBarInit (
    VOID
    )
{
    /* Nothing to do... */
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarCleanup (
    VOID
    )
{
    MainInputBar.Hide ();
    if (MainInputBar.Prompt != NULL ) {
        FreePool ((VOID*)MainInputBar.Prompt);
    }
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarRefresh (
    VOID
    )
{
    EE_COLOR_UNION  Orig,New;
    EFI_INPUT_KEY           Key;
    UINTN                   Column;
    UINTN                   Size = 0;
    EFI_STATUS              Status = EFI_SUCCESS;

    Orig = MainEditor.ColorAttributes;
    New.Colors.Foreground = Orig.Colors.Background;
    New.Colors.Background = Orig.Colors.Foreground;

    Out->SetAttribute (Out,New.Data);

    MainInputBar.Hide();
    Out->SetCursorPosition(Out,0,INPUT_BAR_LOCATION);
    Print(L"%s ",MainInputBar.Prompt);

    for ( ;; ) {
        WaitForSingleEvent(In->WaitForKey,0);
        Status = In->ReadKeyStroke(In,&Key);
        if ( EFI_ERROR(Status) ) {
            continue;
        }
        if ( Key.ScanCode == SCAN_CODE_ESC ) {
            Size = 0;
            FreePool(MainInputBar.ReturnString);
            Status = EFI_NOT_READY;
            break;
        } 
        if ( Key.UnicodeChar == CHAR_LF || Key.UnicodeChar == CHAR_CR ) {
            break;
        } else if (Key.UnicodeChar == CHAR_BS) {
            if (Size > 0) {
                Size--;
                Column = Out->Mode->CursorColumn - 1;
                PrintAt(Column,INPUT_BAR_LOCATION,L" ");
                Out->SetCursorPosition(Out,Column,INPUT_BAR_LOCATION);
            }
        } else {
            if ( Size < MainInputBar.StringSize) {
                MainInputBar.ReturnString[Size] = Key.UnicodeChar;
                Size++;
                Print(L"%c",Key.UnicodeChar);
            }
        }
    }
    MainInputBar.StringSize = Size;
    if ( Size > 0 ) {
        MainInputBar.ReturnString[Size] = 0;
    }

    Out->SetAttribute (Out,Orig.Data);
    MainEditor.StatusBar->Refresh();

    return Status;
}

STATIC
EFI_STATUS
MainInputBarHide (
    VOID
    )
{
    MainEditor.FileBuffer->ClearLine(INPUT_BAR_LOCATION);
    return  EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarSetPrompt (
    IN  CHAR16* Str
    )
{

    if ( MainInputBar.Prompt != NULL && MainInputBar.Prompt != (CHAR16*)BAD_POINTER) {
        FreePool (MainInputBar.Prompt);
    }
    MainInputBar.Prompt = PoolPrint (Str);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainInputBarSetStringSize   (
    UINTN   Size
    )
{
/*   if ( MainInputBar.ReturnString != NULL && MainInputBar.ReturnString != (CHAR16*)BAD_POINTER) {
 *       FreePool ( MainInputBar.ReturnString );
 *   } */
    MainInputBar.StringSize = Size;

    MainInputBar.ReturnString = AllocatePool (Size+6);

    return EFI_SUCCESS;
}

#endif  /* _LIB_INPUT_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libmenubar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libMenuBar.c

  Abstract:
    Defines the MenuBar data type and the operations to be performed on it.

--*/

#ifndef _LIB_MENU_BAR
#define _LIB_MENU_BAR

#include "libMisc.h"


STATIC  UINTN   HexSelStart;
STATIC  UINTN   HexSelEnd;

STATIC  BOOLEAN EditorIsExiting = FALSE;
#define IS_EDITOR_EXITING (EditorIsExiting == TRUE)

STATIC  EFI_STATUS  MainMenuInit (VOID);
STATIC  EFI_STATUS  MainMenuCleanup (VOID);
STATIC  EFI_STATUS  MainMenuRefresh (VOID);
STATIC  EFI_STATUS  MainMenuHandleInput (EFI_INPUT_KEY*);
STATIC  EFI_STATUS  MenuHide(VOID);
STATIC  EFI_STATUS  OpenFile(VOID);
STATIC  EFI_STATUS  BufferClose(VOID);
STATIC  EFI_STATUS  BufferSave(VOID);
STATIC  EFI_STATUS  Exit(VOID);

STATIC  EFI_STATUS  DiskOpen(VOID);

STATIC  EFI_STATUS  MemOpen(VOID);


STATIC  EFI_STATUS  SelectStart(VOID);
STATIC  EFI_STATUS  SelectEnd(VOID);
STATIC  EFI_STATUS  CopyHex(VOID);
STATIC  EFI_STATUS  CutHex(VOID);
STATIC  EFI_STATUS  PasteHex(VOID);
STATIC  EFI_STATUS  GotoOffset(VOID);

EE_MENU_ITEM    MenuItems[] =   {
    {   L"Open File",       L"F1",  OpenFile    },
    {   L"Open Disk",       L"F2",  DiskOpen    },
    {   L"Open Memory",     L"F3",  MemOpen     },
    {   L"Save Buffer",     L"F4",  BufferSave  },

    {   L"Select Start",    L"F5",  SelectStart },
    {   L"Select End",      L"F6",  SelectEnd   },
    {   L"Cut",             L"F7",  CutHex      },
    {   L"Paste",           L"F8",  PasteHex    },

    {   L"Go To Offset",    L"F9",  GotoOffset  },
    {   L"Exit",            L"F10", Exit        },
    {   L"",                L"",    NULL        }
};

EE_MENU_BAR     MainMenuBar = {
    MenuItems,
    MainMenuInit,
    MainMenuCleanup,
    MainMenuRefresh,
    MenuHide,
    MainMenuHandleInput 
};





STATIC
EFI_STATUS  
MainMenuInit (VOID) 
{
    HexSelStart = 0;
    HexSelEnd = 0;

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS  
MainMenuCleanup (VOID)
{
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainMenuRefresh (VOID)
{
    EE_MENU_ITEM    *Item;
    UINTN           Col = 0;
    UINTN           Row = MENU_BAR_LOCATION;
    UINTN           Width;

    MenuHide ();

    for (Item = MainMenuBar.MenuItems; Item->Function;Item++) {

        Width = max((StrLen(Item->Name)+6),18);
        if ((Col + Width) >= MAX_TEXT_COLUMNS ) {
            Row++;
            Col = 0;
        }
        PrintAt(Col,Row,L"%E%s%N  %H%s%N  ",Item->FunctionKey,Item->Name);
        Col += Width;
    }
    
    MainEditor.FileBuffer->RestorePosition();

    return  EFI_SUCCESS;
}


STATIC
EFI_STATUS
MainMenuHandleInput (EFI_INPUT_KEY  *Key)
{
    EE_MENU_ITEM    *Item;
    EFI_STATUS      Status;
    UINTN           ItemIndex = 0;
    UINTN           NumItems;

    NumItems = sizeof(MainMenuBar.MenuItems)/sizeof(EE_MENU_ITEM) - 1;

    Item = MainMenuBar.MenuItems;

    ItemIndex = Key->ScanCode - SCAN_CODE_F1;

    if (ItemIndex > (NumItems - 1)) {
        return EFI_SUCCESS;
    }

    Item = &MainMenuBar.MenuItems[ItemIndex];

    Status = Item->Function();

    MainMenuRefresh();

    return  (IS_EDITOR_EXITING) ? EFI_LOAD_ERROR : Status;
}


STATIC
EFI_STATUS
OpenFile (VOID)
{
    EFI_STATUS  Status = EFI_SUCCESS;
    CHAR16      *Filename;

    MainEditor.BufferImage->FileImage->Init();

    MainEditor.InputBar->SetPrompt(L"File Name to Open: ");
    MainEditor.InputBar->SetStringSize (125);
    Status = MainEditor.InputBar->Refresh ();
    if ( EFI_ERROR(Status) ) {
        return EFI_SUCCESS;
    }
    Filename = MainEditor.InputBar->ReturnString;

    if ( Filename == NULL ) {
        MainEditor.StatusBar->SetStatusString(L"Filename was NULL");
        return EFI_SUCCESS;

    }

    Status = MainEditor.BufferImage->FileImage->SetFilename (Filename);
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Set Filename");
        return EFI_NOT_FOUND;
    }

    Status = MainEditor.BufferImage->Open ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Open File");
        return EFI_NOT_FOUND;
    }

    
    Status = MainEditor.BufferImage->Read ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Read File");
        return EFI_NOT_FOUND;
    }
    
    Status = MainEditor.FileBuffer->Refresh();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Refresh");
        return EFI_NOT_FOUND;
    }

    MainEditor.TitleBar->SetTitleString(Filename);
    
    MainEditor.Refresh();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
BufferClose (VOID)
{

    EFI_INPUT_KEY   Key;
    EFI_STATUS      Status = EFI_SUCCESS;
    BOOLEAN         Done = FALSE;


    if (MainEditor.FileModified) {
        MenuHide();
        PrintAt(0,MENU_BAR_LOCATION,L"%E%Y%H  Yes%N  %EN%N  %HNo%N   %EQ%N  %HCancel%N");
        MainEditor.StatusBar->SetStatusString(L"Buffer Modified.  Save? ");

        while (!Done) {
            WaitForSingleEvent(In->WaitForKey,0);
            Status = In->ReadKeyStroke(In,&Key);
            if ( EFI_ERROR(Status) || Key.ScanCode != 0 ) {
                continue;
            }
            switch (Key.UnicodeChar) {
            case 'q':
            case 'Q':
                Status = EFI_NOT_READY;
                Done = TRUE;
                break;
            case 'n':
            case 'N':
                Status = EFI_SUCCESS;
                Done = TRUE;
                break;
            case 'y':
            case 'Y':
                Status = BufferSave();
                Done = TRUE;
                break;
            default:
                break;
            }

        }
        MainMenuRefresh();
    }
    if (!EFI_ERROR(Status)) {
        MainEditor.BufferImage->Close();
        MainEditor.FileBuffer->Refresh ();
        MainEditor.TitleBar->SetTitleString(L"");
    } else {
        EditorIsExiting = FALSE;
    }
    MainEditor.StatusBar->Refresh();
    MainMenuRefresh();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
FileGetName (
    VOID
    )
{
    CHAR16      *Output;
    EFI_STATUS  Status;

    Output = PoolPrint (L"File To Save: [%s]",MainEditor.BufferImage->FileImage->FileName);
    MainEditor.InputBar->SetPrompt(Output);
    MainEditor.InputBar->SetStringSize(255);

    Status = MainEditor.InputBar->Refresh();
    FreePool(Output);

    if (!EFI_ERROR(Status) && MainEditor.InputBar->StringSize > 0) {
        MainEditor.BufferImage->FileImage->SetFilename(MainEditor.InputBar->ReturnString);
    }

    return Status; 
}

STATIC
EFI_STATUS
BufferSave  (VOID)
{
    EFI_STATUS  Status;

    if (!MainEditor.FileModified) {
        return EFI_SUCCESS;
    }

    if (MainEditor.BufferImage->BufferType == FILE_BUFFER) {
        FileGetName();
    }

    Status = MainEditor.BufferImage->Write();

    if (EFI_ERROR(Status)) {
        EditorError(Status,L"BufferSave: Problems Writing");
    }
    MainEditor.FileModified = FALSE;
    return Status;
}


STATIC
EFI_STATUS 
Exit (
    VOID
    ) 
{ 
    EditorIsExiting = TRUE;
    BufferClose();
    return EFI_SUCCESS;
}



STATIC
EFI_STATUS 
MenuHide (VOID)
{
    MainEditor.FileBuffer->ClearLine (MENU_BAR_LOCATION);
    MainEditor.FileBuffer->ClearLine (MENU_BAR_LOCATION+1);
    MainEditor.FileBuffer->ClearLine (MENU_BAR_LOCATION+2);
    return  EFI_SUCCESS;
}


STATIC
EFI_STATUS
SelectStart (
    VOID
    )
{
    HexSelStart = MainEditor.FileBuffer->Offset;
    HexSelEnd = HexSelStart;
    
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
SelectEnd   (
    VOID
    )
{
    UINTN   Offset;

    Offset = MainEditor.FileBuffer->Offset;

    if (Offset > HexSelStart) {
        HexSelEnd = Offset;
    }

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
CopyHex (
    VOID
    )
{
    MainEditor.Clipboard->Copy(HexSelStart,HexSelEnd);
    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS
CutHex  (
    VOID
    )
{
    MainEditor.StatusBar->SetStatusString (L"EditMenuCut: Entered Function");

    MainEditor.Clipboard->Cut (HexSelStart,HexSelEnd);

    return EFI_SUCCESS; 
}

STATIC
EFI_STATUS  
PasteHex    (
    VOID
    )
{
    EFI_STATUS  Status;

    Status = MainEditor.Clipboard->Paste();
    return Status;
}



STATIC
EFI_STATUS
GotoOffset  (
    VOID
    )
{
    CHAR16      *Str;
    UINTN       Offset;
    UINTN       Current;
    UINTN       MaxBytes;
    UINTN       RowDiff;
    UINTN       LineOffset;
    BOOLEAN     Refresh = FALSE;

    MenuHide ();
    Str = PoolPrint(L"Go To Offset: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    /*  Inputing the offset as the style "0000XXXX" displayed on the editor screen will cause 
     *  an assert error related to pool, the gived string size may be short.   */
    MainEditor.InputBar->SetStringSize(20);
    MainEditor.InputBar->Refresh();
        
    if (MainEditor.InputBar->StringSize > 0) {
        Offset = xtoi(MainEditor.InputBar->ReturnString);
    } else {
        return EFI_SUCCESS;
    }
    FreePool(MainEditor.InputBar->ReturnString);

    if (Offset > MainEditor.BufferImage->NumBytes) {
        return EFI_SUCCESS;
    }

    Current = MainEditor.FileBuffer->Offset;
    MaxBytes = MainEditor.FileBuffer->MaxVisibleBytes;

    if (Offset == Current ) {
        return EFI_SUCCESS;
    }

    if (Offset < Current) {
        RowDiff = (Current - Offset) / 0x10;
        LineRetreat(RowDiff);
        if (Offset < MainEditor.FileBuffer->LowVisibleOffset ) {
            MainEditor.FileBuffer->LowVisibleOffset = Offset & 0xfffffff0;
            MainEditor.FileBuffer->HighVisibleOffset = (Offset + MaxBytes) & 0xfffffff0; 
            Refresh = TRUE;
        }
    } else {
        RowDiff = (Offset - Current) / 0x10;
        LineAdvance(RowDiff);
        if (Offset > MainEditor.FileBuffer->HighVisibleOffset) {
            MainEditor.FileBuffer->LowVisibleOffset = Offset & 0xfffffff0;
            MainEditor.FileBuffer->HighVisibleOffset = (Offset + MaxBytes) & 0xfffffff0; 
            Refresh = TRUE;
        }
    }

    Current = MainEditor.FileBuffer->LowVisibleOffset;
    LineOffset = (Offset % 0x10) * 3 + HEX_POSITION;
    if ((Offset % 0x10) > 0x07) {
        ++LineOffset;
    }

    MainEditor.FileBuffer->Offset = Offset;

    MainEditor.FileBuffer->SetPosition(DISP_START_ROW+(Offset-Current)/0x10,LineOffset);
    MainEditor.StatusBar->SetOffset(Offset);

    if (Refresh) {
        MainEditor.FileBuffer->Refresh();
    }

    return EFI_SUCCESS; 
}


STATIC
EFI_STATUS  
DiskOpen    (
    VOID
    )
{
    UINTN       n;
    CHAR16      *Str;
    EFI_STATUS  Status;

    Status = BufferClose ();
    if (EFI_ERROR(Status)){
        return Status;
    }
    
    MainEditor.BufferImage->DiskImage->Init();

    MenuHide();

    Str = PoolPrint(L"Enter Block Device: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(25);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize > 0) {
        Status = MainEditor.BufferImage->DiskImage->SetDevice(MainEditor.InputBar->ReturnString);
        FreePool(MainEditor.InputBar->ReturnString);
        if (EFI_ERROR(Status)) {
            return EFI_SUCCESS;
        }
    } else {
        return EFI_SUCCESS;
    }

    Str = PoolPrint(L"Starting Offset: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(16);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize > 0) {
        n = xtoi(MainEditor.InputBar->ReturnString);
        FreePool(MainEditor.InputBar->ReturnString);
    }

    MainEditor.BufferImage->DiskImage->SetOffset(n);

    Str = PoolPrint(L"Number of Blocks: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(8);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize > 0) {
        n = xtoi(MainEditor.InputBar->ReturnString);
        FreePool(MainEditor.InputBar->ReturnString);
    }

    MainEditor.BufferImage->DiskImage->SetSize(n);

    Status = MainEditor.BufferImage->Open ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Open Device");
        return EFI_NOT_FOUND;
    }

    Status = MainEditor.BufferImage->Read ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Read Device");
        return EFI_NOT_FOUND;
    }
    
    Status = MainEditor.FileBuffer->Refresh();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Refresh Buffer");
        return EFI_NOT_FOUND;
    }

    MainEditor.Refresh();

    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
MemOpen (
    VOID
    )
{
    UINTN   Num = 0;
    CHAR16  *Str;
    EFI_STATUS  Status;

    Status = BufferClose ();
    if (EFI_ERROR(Status)){
        return Status;
    }

    MainEditor.BufferImage->MemImage->Init();

    Str = PoolPrint(L"Starting Offset: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(20);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize > 0) {
        Num = xtoi(MainEditor.InputBar->ReturnString);
        FreePool(MainEditor.InputBar->ReturnString);
    }

    MainEditor.BufferImage->MemImage->SetOffset(Num);

    Str = PoolPrint(L"Buffer Size: ");
    MainEditor.InputBar->SetPrompt(Str);
    FreePool(Str);
    MainEditor.InputBar->SetStringSize(20);
    MainEditor.InputBar->Refresh();

    if (MainEditor.InputBar->StringSize > 0) {
        Num = xtoi(MainEditor.InputBar->ReturnString);
        FreePool(MainEditor.InputBar->ReturnString);
    }

    MainEditor.BufferImage->MemImage->SetSize(Num);

    Status = MainEditor.BufferImage->Open ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Open Device");
        return EFI_NOT_FOUND;
    }

    Status = MainEditor.BufferImage->Read ();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Read Device");
        return EFI_NOT_FOUND;
    }
    
    Status = MainEditor.FileBuffer->Refresh();
    if ( EFI_ERROR(Status) ) {
        EditorError(Status,L"Could Not Refresh Buffer");
        return EFI_NOT_FOUND;
    }

    MainEditor.Refresh();


    return EFI_SUCCESS;
}



#endif  /* _LIB_MENU_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libstatusbar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libStatus.c

  Abstract:
    Defines the StatusBar data type and the operations for it.

--*/

#ifndef _LIB_STATUS_BAR
#define _LIB_STATUS_BAR

#include "libMisc.h"

STATIC  EFI_STATUS  MainStatusBarInit (VOID);
STATIC  EFI_STATUS  MainStatusBarCleanup (VOID);
STATIC  EFI_STATUS  MainStatusBarRefresh (VOID);
STATIC  EFI_STATUS  MainStatusBarHide (VOID);
STATIC  EFI_STATUS  MainStatusBarSetStatusString (CHAR16*);
STATIC  EFI_STATUS  MainStatusBarSetOffset (UINTN);

EE_STATUS_BAR MainStatusBar = {
    NULL,
    0x00,
    MainStatusBarInit,
    MainStatusBarCleanup,
    MainStatusBarRefresh,
    MainStatusBarHide,
    MainStatusBarSetStatusString,
    MainStatusBarSetOffset
};

STATIC
EFI_STATUS
MainStatusBarInit ()
{
    /* Nothing to do.... */
    MainStatusBar.SetStatusString(L"");
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarCleanup ()
{
    MainEditor.FileBuffer->ClearLine(STATUS_BAR_LOCATION);
    if ( MainStatusBar.StatusString != NULL ) {
        FreePool ((VOID*)MainStatusBar.StatusString);
    }
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarRefresh ()
{
    EE_COLOR_UNION  Orig,New;
    Orig = MainEditor.ColorAttributes;
    New.Colors.Foreground = Orig.Colors.Background;
    New.Colors.Background = Orig.Colors.Foreground;

    Out->SetAttribute (Out,New.Data);

    MainEditor.FileBuffer->ClearLine(STATUS_BAR_LOCATION);
    PrintAt (0,STATUS_BAR_LOCATION,L"  Offset: %X       %s",
        MainStatusBar.Offset,MainStatusBar.StatusString);

    Out->SetAttribute (Out,Orig.Data);

    MainEditor.FileBuffer->RestorePosition();

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarHide ()
{
    MainEditor.FileBuffer->ClearLine(STATUS_BAR_LOCATION);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
MainStatusBarSetStatusString (
    IN CHAR16* Str
    )
{
    if ( MainStatusBar.StatusString != NULL ) {
        FreePool (MainStatusBar.StatusString);
    }
    MainStatusBar.StatusString = StrDuplicate (Str);
    MainStatusBarRefresh();
    return EFI_SUCCESS;
}


STATIC
EFI_STATUS
MainStatusBarSetOffset (
    IN  UINTN   Offset
    )
{
    MainStatusBar.Offset = Offset;

    MainStatusBar.Refresh();

    return EFI_SUCCESS;
}

#endif  /* _LIB_STATUS_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\libtitlebar.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    libTitle.c

  Abstract:
    Defines the TitleBar data type

--*/

#ifndef _LIB_TITLE_BAR
#define _LIB_TITLE_BAR

#include "libMisc.h"

STATIC  EFI_STATUS  TitleBarInit (VOID);
STATIC  EFI_STATUS  TitleBarCleanup (VOID);
STATIC  EFI_STATUS  TitleBarRefresh (VOID);
STATIC  EFI_STATUS  TitleBarHide (VOID);
STATIC  EFI_STATUS  TitleBarSetTitle (CHAR16*);

EE_TITLE_BAR    TitleBar = {
    NULL,
    TitleBarInit,
    TitleBarCleanup,
    TitleBarRefresh,
    TitleBarHide,
    TitleBarSetTitle
};


STATIC
EFI_STATUS
TitleBarInit ()
{
    CHAR16  *Filename;

    Filename = PoolPrint(L"New File");
    TitleBarSetTitle(Filename);

    FreePool(Filename);

    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
TitleBarCleanup ()
{
    MainEditor.FileBuffer->ClearLine (TITLE_BAR_LOCATION);
    if (TitleBar.Filename) { 
        FreePool (TitleBar.Filename);
    }
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
TitleBarRefresh ()
{
    EE_COLOR_UNION  Orig,New;
    Orig = MainEditor.ColorAttributes;
    New.Colors.Foreground = Orig.Colors.Background;
    New.Colors.Background = Orig.Colors.Foreground;

    Out->SetAttribute (Out,New.Data);

    MainEditor.FileBuffer->ClearLine(TITLE_BAR_LOCATION);
    PrintAt (0,TITLE_BAR_LOCATION,L"  %s  %s     %s   ",EDITOR_NAME,EDITOR_VERSION,TitleBar.Filename);

    Out->SetAttribute (Out,Orig.Data);
    
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
TitleBarHide ()
{
    MainEditor.FileBuffer->ClearLine (TITLE_BAR_LOCATION);
    return EFI_SUCCESS;
}

STATIC
EFI_STATUS
TitleBarSetTitle (CHAR16* Filename)
{
    if (TitleBar.Filename != NULL ) {
        FreePool (TitleBar.Filename);
    }
    TitleBar.Filename = StrDuplicate (Filename);
    TitleBar.Refresh();
    return EFI_SUCCESS;
}


#endif  /* _LIB_TITLE_BAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\inc\shellenv.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    shellenv.h

Abstract:

    Defines for shell environment



Revision History

--*/

/* 
 *  The shell environment is provided by a driver.  The shell links to the
 *  shell environment for services.  In addition, other drivers may connect
 *  to the shell environment and add new internal command handlers, or
 *  internal protocol handlers.
 * 
 *  A typical shell application would not include this header file
 */


#define SHELL_ENVIRONMENT_INTERFACE_PROTOCOL \
    { 0x47c7b221, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

/* 
 * 
 */

typedef 
EFI_STATUS 
(EFIAPI *SHELLENV_EXECUTE) (
    IN EFI_HANDLE   *ParentImageHandle,
    IN CHAR16       *CommandLine,
    IN BOOLEAN      DebugOutput
    );

typedef 
CHAR16 *
(EFIAPI *SHELLENV_GET_ENV) (
    IN CHAR16       *Name
    );

typedef 
CHAR16 *
(EFIAPI *SHELLENV_GET_MAP) (
    IN CHAR16       *Name
    );

/* 
 *  Add to shell's internal command list
 */

typedef
EFI_STATUS
(EFIAPI *SHELLENV_ADD_CMD) (
    IN SHELLENV_INTERNAL_COMMAND    Handler,
    IN CHAR16                       *Cmd,
    IN CHAR16                       *CmdFormat,
    IN CHAR16                       *CmdHelpLine,
    IN CHAR16                       *CmdVerboseHelp     /*  tbd */
    );

/* 
 *  Add to shell environment protocol information & protocol information dump handlers
 */

typedef
VOID
(EFIAPI *SHELLENV_DUMP_PROTOCOL_INFO) (
    IN EFI_HANDLE                   Handle,
    IN VOID                         *Interface
    );


typedef
VOID
(EFIAPI *SHELLENV_ADD_PROT) (
    IN EFI_GUID                     *Protocol,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpToken OPTIONAL,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpInfo OPTIONAL,
    IN CHAR16                       *IdString
    );

typedef
CHAR16 *
(EFIAPI *SHELLENV_GET_PROT) (
    IN EFI_GUID                     *Protocol,
    IN BOOLEAN                      GenId
    );



typedef
EFI_SHELL_INTERFACE *
(EFIAPI *SHELLENV_NEW_SHELL) (
    IN EFI_HANDLE                   ImageHandle
    );


typedef
CHAR16 *
(EFIAPI *SHELLENV_CUR_DIR) (
    IN CHAR16       *DeviceName OPTIONAL    
    );

typedef
EFI_STATUS
(EFIAPI *SHELLENV_FILE_META_ARG) (
    IN CHAR16               *Arg,
    IN OUT LIST_ENTRY       *ListHead
    );

typedef 
EFI_STATUS
(EFIAPI *SHELLENV_FREE_FILE_LIST) (
    IN OUT LIST_ENTRY       *ListHead
    );


/* 
 * 
 */

typedef struct {
    SHELLENV_EXECUTE                Execute;        /*  Execute a command line */
    SHELLENV_GET_ENV                GetEnv;         /*  Get an environment variable */
    SHELLENV_GET_MAP                GetMap;         /*  Get an environment variable */
    SHELLENV_ADD_CMD                AddCmd;         /*  Add an internal command handler */
    SHELLENV_ADD_PROT               AddProt;        /*  Add protocol info handler */
    SHELLENV_GET_PROT               GetProt;        /*  Get's the protocol ID */

    SHELLENV_CUR_DIR                CurDir;
    SHELLENV_FILE_META_ARG          FileMetaArg;
    SHELLENV_FREE_FILE_LIST         FreeFileList;

    /*  Only used by the shell itself */
    SHELLENV_NEW_SHELL              NewShell;
} EFI_SHELL_ENVIRONMENT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\iomod\iomod.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    io.c
    
Abstract:   




Revision History

--*/

#include "shelle.h"

typedef enum {
    EfiMemory,
    EFIMemoryMappedIo,
    EfiIo,
    EfiPciConfig
} EFI_ACCESS_TYPE;

EFI_STATUS
DumpIoModify (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

VOID
ReadMem (
    IN  EFI_IO_WIDTH    Width, 
    IN  UINT64          Address, 
    IN  UINTN           Size, 
    IN  VOID            *Buffer
    );

VOID
WriteMem (
    IN  EFI_IO_WIDTH    Width, 
    IN  UINT64          Address, 
    IN  UINTN           Size, 
    IN  VOID            *Buffer
    );

EFI_DRIVER_ENTRY_POINT(DumpIoModify)

EFI_STATUS
DumpIoModify (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

    iomod Address [Width] [;[MEM | MMIO | IO | PCI]] [:Value]
        if no Width 1 byte is default, 1|2|4|8 supported byte widths
        if no ; then default access type is memory (MEM)
        After a ; ;MEM = Memory, ;MMIO = Memmory Mapped IO, ;IO = in/out, PCI = PCI Config space
 --*/
{
    EFI_STATUS                      Status;
    EFI_HANDLE                      Handle;
    EFI_DEVICE_PATH                 *DevicePath;
    EFI_DEVICE_IO_INTERFACE         *IoDev;
    UINT64                          Address;
    UINT64                          Value;
    EFI_IO_WIDTH                    Width;
    EFI_ACCESS_TYPE                 AccessType;
    UINT64                          Buffer;
    UINTN                           Index;
    UINTN                           Size;
    CHAR16                          *AddressStr, *WidthStr, *p, *ValueStr;
    BOOLEAN                         Done;
    CHAR16                          InputStr[80];
    BOOLEAN                         Interactive;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   DumpIoModify, 
        L"mm",                            /*  command */
        L"mm Address [Width] [;Type]",      /*  command syntax */
        L"Memory Modify: Mem, MMIO, IO, PCI",       /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    /* 
     *  The End Device Path represents the Root of the tree, thus get the global IoDev
     *   for the system
     */
    InitializeShellApplication (ImageHandle, SystemTable);

    Width = IO_UINT8;
    Size = 1;
    AccessType = EfiMemory;
    AddressStr = WidthStr = NULL;
    ValueStr = NULL;
    Interactive = TRUE;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == ';') {
            switch (p[1]) {
            case 'I':
            case 'i':
                AccessType = EfiIo;
                continue;
            case 'P':
            case 'p':
                AccessType = EfiPciConfig;
                continue;
            default:
            case 'M':
            case 'm':
                if (p[2] == 'E' || p[2] == 'e') {
                    AccessType = EfiMemory;
                }
                if (p[2] == 'M' || p[2] == 'm') {
                    AccessType = EFIMemoryMappedIo;
                }
                continue;
            }  
        } else if (*p == ':') {
            ValueStr = &p[1];
            Value = xtoi(ValueStr);
            continue;
        } else if (*p == '-') {
            switch (p[1]) {
            case 'n':
            case 'N': Interactive = FALSE; 
                      break;
            case 'h':
            case 'H':
            case '?':
            default:
                goto UsageError;
            };
            continue;
        }
        if (!AddressStr) {
            AddressStr = p;
            Address = xtoi(AddressStr);
            continue;
        }
        if (!WidthStr) {
           WidthStr = p;
           switch (xtoi(WidthStr)) {
           case 2:
               Width = IO_UINT16;
               Size = 2;
               continue;
           case 4:
               Width = IO_UINT32;
               Size = 4;
               continue;
           case 8:
               Width = IO_UINT64;
               Size = 8;
               continue;
           case 1:
           default:
               Width = IO_UINT8;
               Size = 1;
               continue;
           }
        }
    }

    if (!AddressStr) {
        goto UsageError;
    }

    if ((Address & (Size - 1)) != 0) {
        goto UsageError;
    }

    if (AccessType != EfiMemory) {
        DevicePath = EndDevicePath;
        Status = BS->LocateDevicePath (&DeviceIoProtocol, &DevicePath, &Handle);
        if (!EFI_ERROR(Status)) {
            Status = BS->HandleProtocol (Handle, &DeviceIoProtocol, (VOID*)&IoDev);
        } 

        if (EFI_ERROR(Status)) {
            Print (L"%E - handle protocol error %r%N", Status);
            return Status;
        }
    }

    if (ValueStr) {
        if (AccessType == EFIMemoryMappedIo) {
            IoDev->Mem.Write (IoDev, Width, Address, 1, &Value);
        } else if (AccessType == EfiIo) {
            IoDev->Io.Write (IoDev, Width, Address, 1, &Value);
        } else if (AccessType == EfiPciConfig) {
            IoDev->Pci.Write (IoDev, Width, Address, 1, &Value);
        } else {
            WriteMem (Width, Address, 1, &Value);
        }
        return EFI_SUCCESS;
    }

    if (Interactive == FALSE) {
        Buffer = 0;
        if (AccessType == EFIMemoryMappedIo) {
            Print (L"%HMMIO%N");
            IoDev->Mem.Read (IoDev, Width, Address, 1, &Buffer);
        } else if (AccessType == EfiIo) {
            Print (L"%HIO%N");
            IoDev->Io.Read (IoDev, Width, Address, 1, &Buffer);
        } else if (AccessType == EfiPciConfig) {
            Print (L"%HPCI%N");
            IoDev->Pci.Read (IoDev, Width, Address, 1, &Buffer);
        } else {
            Print (L"%HMEM%N");
            ReadMem (Width, Address, 1, &Buffer);
        }

        Print (L"  0x%016lx : 0x", Address);
        if (Size == 1) {
            Print (L"%02x", Buffer);
        } else if (Size == 2) {
            Print (L"%04x", Buffer);
        } else if (Size == 4) {
            Print (L"%08x", Buffer);
        } else if (Size == 8) {
            Print (L"%016lx", Buffer);
        }
        Print(L"\n");
        return EFI_SUCCESS;
    }

    Done = FALSE;
    do {
        Buffer = 0;
        if (AccessType == EFIMemoryMappedIo) {
            Print (L"%HMMIO%N");
            IoDev->Mem.Read (IoDev, Width, Address, 1, &Buffer);
        } else if (AccessType == EfiIo) {
            Print (L"%HIO%N");
            IoDev->Io.Read (IoDev, Width, Address, 1, &Buffer);
        } else if (AccessType == EfiPciConfig) {
            Print (L"%HPCI%N");
            IoDev->Pci.Read (IoDev, Width, Address, 1, &Buffer);
        } else {
            Print (L"%HMEM%N");
            ReadMem (Width, Address, 1, &Buffer);
        }

        Print (L"  0x%016lx : 0x", Address);
        if (Size == 1) {
            Print (L"%02x", Buffer);
        } else if (Size == 2) {
            Print (L"%04x", Buffer);
        } else if (Size == 4) {
            Print (L"%08x", Buffer);
        } else if (Size == 8) {
            Print (L"%016lx", Buffer);
        }

        Input (L" > ", InputStr, sizeof(InputStr));
        if (*InputStr == '.' || *InputStr == 'e' || *InputStr == 'q' || *InputStr == 'E' || *InputStr == 'Q' ) {
            Done = TRUE;
        } else if (*InputStr != 0x00) {
            Buffer = xtoi(InputStr);
            if (AccessType == EFIMemoryMappedIo) {
                IoDev->Mem.Write (IoDev, Width, Address, 1, &Buffer);
            } else if (AccessType == EfiIo) {
                IoDev->Io.Write (IoDev, Width, Address, 1, &Buffer);
            } else if (AccessType == EfiPciConfig) {
                IoDev->Pci.Write (IoDev, Width, Address, 1, &Buffer);
            } else {
                WriteMem (Width, Address, 1, &Buffer);
            }
        }
        Address += Size;
        Print (L"\n");
    } while (!Done);

    return EFI_SUCCESS;

UsageError:
    Print (L"\n%Hmm%N %HAddress%N [%HWidth%N 1|2|4|8] [%H;MMIO | ;MEM | ;IO | ;PCI%N] [%H:Value%N] [%H-n%N]\n");
    Print (L"  Default access is %HMEM%N of width 1 byte with interactive mode off\n");
    Print (L"  Address must be aligned on a %HWidth%N boundary\n");
    Print (L"   %HMEM%N  - Memory Address 0 - 0xffffffff_ffffffff\n");
    Print (L"   %HMMIO%N - Memory Mapped IO Address 0 - 0xffffffff_ffffffff\n");
    Print (L"   %HIO%N   - IO Address 0 - 0xffff\n");
    Print (L"   %HPCI%N  - PCI Config Address 0x000000%Hss%Nbb%Hdd%Nff%Hrr%N\n");
    Print (L"          %Hss%N-> _SEG  bb-> bus  %Hdd%N-> Device  ff-> Func  %Hrr%N-> Register\n");
    Print (L"  [%H-n%N] - Interactive Mode Off\n");
    return EFI_SUCCESS;    
}


VOID
ReadMem (
    IN  EFI_IO_WIDTH    Width, 
    IN  UINT64          Address, 
    IN  UINTN           Size, 
    IN  VOID            *Buffer
    )
{
    do {
        if (Width == IO_UINT8) {
            *(UINT8 *)Buffer = *(UINT8 *)Address;
            Address -= 1;
        } else if (Width == IO_UINT16) {
            *(UINT16 *)Buffer = *(UINT16 *)Address;
            Address -= 2;
        } else if (Width == IO_UINT32) { 
            *(UINT32 *)Buffer = *(UINT32 *)Address;
            Address -= 4;
        } else if (Width == IO_UINT64) {
            *(UINT64 *)Buffer = *(UINT64 *)Address;
            Address -= 8;
        } else {
            ASSERT(FALSE);
        }
        Size--;
    } while (Size > 0);
}

VOID
WriteMem (
    IN  EFI_IO_WIDTH    Width, 
    IN  UINT64          Address, 
    IN  UINTN           Size, 
    IN  VOID            *Buffer
    )
{
    do {
        if (Width == IO_UINT8) {
            *(UINT8 *)Address = *(UINT8 *)Buffer;
            Address += 1;
        } else if (Width == IO_UINT16) {
            *(UINT16 *)Address = *(UINT16 *)Buffer;
            Address += 2;
        } else if (Width == IO_UINT32) { 
            *(UINT32 *)Address = *(UINT32 *)Buffer;
            Address += 4;
        } else if (Width == IO_UINT64) {
            *(UINT64 *)Address = *(UINT64 *)Buffer;
            Address += 8;
        }  else {
            ASSERT(FALSE);
        }
        Size--;
    } while (Size > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\lib\init.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    init.c

Abstract:

    Intialize the shell library



Revision History

--*/

#include "shelllib.h"

/* 
 * 
 */


EFI_STATUS
InitializeShellApplication (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_SYSTEM_TABLE             *SystemTable
    )
{
    EFI_STATUS      Status;
    EFI_HANDLE      Handle;
    UINTN           BufferSize;

    /* 
     *  Shell app lib is a super set of the default lib.
     *  Initialize the default lib first
     */

    InitializeLib (ImageHandle, SystemTable);
    ST = SystemTable;

    /* 
     *  Connect to the shell interface
     */

    Status = BS->HandleProtocol(ImageHandle, &ShellInterfaceProtocol, (VOID*)&SI);
    if (EFI_ERROR(Status)) {
        DEBUG((D_ERROR, "InitShellApp: Application not started from Shell\n"));
        Print (L"%EInitShellApp: Application not started from Shell%N\n");
        BS->Exit (ImageHandle, Status, 0, NULL);
    }

    /* 
     *  Connect to the shell environment
     */

    BufferSize = sizeof(Handle);
    Status = BS->LocateHandle(ByProtocol, &ShellEnvProtocol, NULL, &BufferSize, &Handle);
    if (EFI_ERROR(Status)) {
        DEBUG((D_ERROR, "InitShellApp: Shell environment interfaces not found\n"));
        Print (L"%EInitShellApp: Shell environment interfaces not found%N\n");
        BS->Exit (ImageHandle, Status, 0, NULL);
    }

    Status = BS->HandleProtocol(Handle, &ShellEnvProtocol, (VOID*)&SE);
    ASSERT (!EFI_ERROR(Status));

    /* 
     *  Done with init
     */

    return Status;
}


VOID
InstallInternalShellCommand (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_SYSTEM_TABLE             *SystemTable,
    IN SHELLENV_INTERNAL_COMMAND    Dispatch,
    IN CHAR16                       *Cmd,
    IN CHAR16                       *CmdFormat,
    IN CHAR16                       *CmdHelpLine,
    IN VOID                         *CmdVerboseHelp
    )
{
    VOID                        *Junk;
    UINTN                       BufferSize;
    EFI_HANDLE                  Handle;
    EFI_LOADED_IMAGE            *ImageInfo;
    EFI_STATUS                  Status;

    /* 
     *  Initialize lib functions
     */

    InitializeLib (ImageHandle, SystemTable);

    /* 
     *  If this app has a ShellInterface, then we are not installing as an
     *  internal command
     */

    Status = BS->HandleProtocol(ImageHandle, &ShellInterfaceProtocol, &Junk);
    if (!EFI_ERROR(Status)) {
        return ;
    }

    /* 
     *  Check to make sure we are loaded as a boot service driver.  if not
     *  we are not installing as an internal command
     */

    Status = BS->HandleProtocol(ImageHandle, &LoadedImageProtocol, (VOID*)&ImageInfo);
    if (EFI_ERROR(Status) || ImageInfo->ImageCodeType != EfiBootServicesCode) {
        return ;
    }

    /* 
     *  OK - we are to install this tool as an internal command.
     */

    BufferSize = sizeof(Handle);
    Status = BS->LocateHandle(ByProtocol, &ShellEnvProtocol, NULL, &BufferSize, &Handle);
    if (EFI_ERROR(Status)) {
        DEBUG((D_INIT|D_ERROR, "InstallInternalCommand: could not find shell environment\n"));
        BS->Exit (ImageHandle, Status, 0, NULL);
    }

    Status = BS->HandleProtocol(Handle, &ShellEnvProtocol, (VOID*)&SE);
    ASSERT (!EFI_ERROR(Status));

    /* 
     *  Add it to the environment
     */

    Status = SE->AddCmd (Dispatch, Cmd, CmdFormat, CmdHelpLine, CmdVerboseHelp);
    DEBUG((D_INIT, "InstallInternalCommand: %hs - %r\n", Cmd, Status));

    /* 
     *  Since we're only installing not (and not running), and we've done the install
     *  call exit.  The nshell app's entry point will be invoked again when it's
     *  run from "execute commandline"
     */

    BS->Exit (ImageHandle, Status, 0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\hexedit\main.c ===
/*++

  Copyright (c) 1999 Intel Corporation

  Module Name:
    main.c

  Abstract:
    

--*/

#include "hexedit.h"

typedef enum {
    NEW_FILE,
    OPEN_FILE,
    OPEN_DISK,
    OPEN_MEMORY
} IMAGE_TYPE;


STATIC
VOID
PrintUsage  (
    VOID
    )
{
    Print(L"\n\n    %Ehex Usage%N\n");
    Print(L"    %H[-f] Filename%N           Open File For Editing\n");
    Print(L"    %H-d   Offset   Size%N      Open Disk Area For Editing\n");
    Print(L"    %H-m   Offset   Size%N      Open Memory Area For Editing\n");
    Print(L"    %H-h%N                      Print This Screen\n");
    Print(L"\n\n");
}


EFI_STATUS
InitializeEFIHexEditor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_STATUS  Status;
    CHAR16      *Name;
    UINTN       Offset = 0;
    UINTN       Size = 0;
    IMAGE_TYPE  WhatToDo = NEW_FILE;

    InitializeLib (ImageHandle, SystemTable);
    InitializeShellApplication (ImageHandle, SystemTable);

    Name  = PoolPrint(L"New File");

    if ( SI->Argc > 1 ) {
        if (StrCmp(SI->Argv[1],L"-h") == 0) {
            PrintUsage();
            return EFI_SUCCESS;
        } else if (StrCmp(SI->Argv[1],L"-d") == 0) {
            if (SI->Argc < 5) {
                PrintUsage();
                return EFI_SUCCESS;
            }
            Name = SI->Argv[2];
            Offset = xtoi(SI->Argv[3]);
            Size = xtoi(SI->Argv[4]);
            WhatToDo = OPEN_DISK;
        } else if (StrCmp(SI->Argv[1],L"-m") == 0) {
            if (SI->Argc < 4) {
                PrintUsage();
                return EFI_SUCCESS;
            }

            Offset = xtoi(SI->Argv[2]);
            Size = xtoi(SI->Argv[3]);
            WhatToDo = OPEN_MEMORY;
        } else {
            if (StrCmp(SI->Argv[1],L"-f") == 0) {
                if (SI->Argc > 2) {
                    Name = SI->Argv[2];
                } else {
                    PrintUsage();
                    return EFI_SUCCESS;
                }
            } else {
                Name = SI->Argv[1];
            }
            WhatToDo = OPEN_FILE;
        }

    }



    Status = MainEditor.Init(&ImageHandle);
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"Initialization Failed");
        return EFI_SUCCESS;
    }
    Status = MainEditor.BufferImage->FileImage->Init ();
    if (EFI_ERROR(Status)) {
        EditorError(Status,L"File Handle Initialization Failed");
        return EFI_SUCCESS;
    }


    switch (WhatToDo) {
    case OPEN_FILE:
        MainEditor.BufferImage->FileImage->Init();
        MainEditor.BufferImage->FileImage->SetFilename(Name);
        break;
    case OPEN_DISK:
        MainEditor.BufferImage->DiskImage->Init();
        MainEditor.BufferImage->DiskImage->SetDevice(Name);
        MainEditor.BufferImage->DiskImage->SetOffset(Offset);
        MainEditor.BufferImage->DiskImage->SetSize(Size);
        break;
    case OPEN_MEMORY:
        MainEditor.BufferImage->MemImage->Init();
        MainEditor.BufferImage->DiskImage->SetOffset(Offset);
        MainEditor.BufferImage->DiskImage->SetSize(Size);
        break;
    default:
        ;
    }

    if (WhatToDo != NEW_FILE) {
        Status = MainEditor.BufferImage->Open();
        if ( EFI_ERROR(Status) ) {
            EditorError(Status,L"Could Not Open File");
            return EFI_SUCCESS;
        }
        MainEditor.TitleBar->SetTitleString (Name);
        MainEditor.BufferImage->Read();
    }

    MainEditor.Refresh ();
    MainEditor.MenuBar->Refresh();

    MainEditor.KeyInput ();

    MainEditor.Cleanup();

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\inc\shell.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    shell.h

Abstract:

    Defines for shell applications



Revision History

--*/

/* 
 *  This module is included by shell applications
 */


#include "efi.h"
#include "efilib.h"

/* 
 * 
 */

#define SHELL_FILE_ARG_SIGNATURE    EFI_SIGNATURE_32('g','r','a','f')
typedef struct {
    UINT32              Signature;
    LIST_ENTRY          Link;
    EFI_STATUS          Status;

    EFI_FILE_HANDLE     Parent;
    UINT64              OpenMode;
    CHAR16              *ParentName;
    EFI_DEVICE_PATH     *ParentDevicePath;

    CHAR16              *FullName;
    CHAR16              *FileName;

    EFI_FILE_HANDLE     Handle;
    EFI_FILE_INFO       *Info;
} SHELL_FILE_ARG;


EFI_STATUS
ShellFileMetaArg (
    IN CHAR16               *Arg,
    IN OUT LIST_ENTRY       *ListHead
    );

EFI_STATUS
ShellFreeFileList (
    IN OUT LIST_ENTRY       *ListHead
    );


/* 
 *  Shell application library functions
 */

EFI_STATUS
InitializeShellApplication (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_SYSTEM_TABLE             *SystemTable
    );

typedef
EFI_STATUS
(EFIAPI *SHELLENV_INTERNAL_COMMAND) (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_SYSTEM_TABLE             *SystemTable
    );

VOID
InstallInternalShellCommand (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_SYSTEM_TABLE             *SystemTable,
    IN SHELLENV_INTERNAL_COMMAND    Dispatch,
    IN CHAR16                       *Cmd,
    IN CHAR16                       *CmdFormat,
    IN CHAR16                       *CmdHelpLine,
    IN VOID                         *CmdVerboseHelp
    );

/* 
 *  Publics in shell.lib
 */

extern EFI_GUID ShellInterfaceProtocol;
extern EFI_GUID ShellEnvProtocol;


/* 
 *  GetEnvironmentVariable - returns a shell environment variable
 */

CHAR16 *
GetEnvironmentVariable (
    IN CHAR16       *Name
    );


/* 
 *  GetProtocolId - returns the short ID strings for a protocol guid
 */

CHAR16 *
GetProtocolId (
    IN EFI_GUID     *Protocol
    );


/* 
 *  AddProtoclId - records a new ID for a protocol guid such that anyone
 *  performing a GetProtocolId can find our id
 */

VOID
AddProtocolId (
    IN EFI_GUID     *Protocol,
    IN CHAR16       *ProtocolId
    );


/* 
 *  ShellExecute - causes the shell to parse & execute the command line
 */

EFI_STATUS
ShellExecute (
    IN EFI_HANDLE   ParentImageHandle,
    IN CHAR16       *CommandLine,
    IN BOOLEAN      Output
    );



/* 
 *  Misc
 */

CHAR16 *
MemoryTypeStr (
    IN EFI_MEMORY_TYPE  Type
    );


/* 
 *  IO
 */

EFI_FILE_HANDLE 
ShellOpenFilePath (
    IN EFI_DEVICE_PATH      *FilePath,
    IN UINT64               FileMode
    );


/* 
 *  ShellCurDir - returns the current directory on the current mapped device
 *                (note the result is allocated from pool and the caller must
 *                free it)
 */

CHAR16 *
ShellCurDir (
    IN CHAR16               *DeviceName OPTIONAL
    );

/* 
 *  ShellGetEnv - returns the current mapping for the Env Name
 */
CHAR16 *
ShellGetEnv (
    IN CHAR16       *Name
    );

CHAR16 *
ShellGetMap (
    IN CHAR16       *Name
    );

/* 
 *  **************************************
 *    Shell Interface prototypes
 */


/* 
 *  Shell Interface - additional information (over image_info) provided
 *  to an application started by the shell.
 * 
 *  ConIo - provides a file sytle interface to the console.  Note that the
 *  ConOut & ConIn interfaces in the system table will work as well, and both
 *  all will be redirected to a file if needed on a command line
 * 
 *  The shell interface's and data (including ConIo) are only valid during
 *  the applications Entry Point.  Once the application returns from it's
 *  entry point the data is freed by the invoking shell.
 */

#define SHELL_INTERFACE_PROTOCOL \
    { 0x47c7b223, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }


typedef struct _EFI_SHELL_INTERFACE {
    /*  Handle back to original image handle & image info */
    EFI_HANDLE                  ImageHandle;
    EFI_LOADED_IMAGE            *Info;

    /*  Parsed arg list */
    CHAR16                      **Argv;
    UINT32                      Argc;

    /*  Storage for file redirection args after parsing */
    CHAR16                      **RedirArgv;
    UINT32                      RedirArgc;

    /*  A file style handle for console io */
    EFI_FILE_HANDLE             StdIn;
    EFI_FILE_HANDLE             StdOut;
    EFI_FILE_HANDLE             StdErr;

} EFI_SHELL_INTERFACE;


/* 
 *  Shell library globals
 */

extern EFI_SHELL_INTERFACE     *SI;
extern EFI_GUID ShellInterfaceProtocol;
extern EFI_GUID ShellEnvProtocol;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\lib\data.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    data.c

Abstract:

    Shell Environment driver global data



Revision History

--*/

#include "shelllib.h"

/* 
 * 
 */

EFI_SHELL_INTERFACE     *SI;
EFI_SHELL_ENVIRONMENT   *SE;

/* 
 * 
 */

EFI_GUID ShellInterfaceProtocol = SHELL_INTERFACE_PROTOCOL;
EFI_GUID ShellEnvProtocol = SHELL_ENVIRONMENT_INTERFACE_PROTOCOL;

/* 
 * 
 */

CHAR16  *ShellLibMemoryTypeDesc[EfiMaxMemoryType]  = {
            L"reserved  ",
            L"LoaderCode",
            L"LoaderData",
            L"BS_code   ",
            L"BS_data   ",
            L"RT_code   ",
            L"RT_data   ",
            L"available ",
            L"Unusable  ",
            L"ACPI_recl ",
            L"ACPI_NVS  ",
            L"MemMapIO  ",
            L"MemPortIO ",
            L"PAL_code  "
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\lib\misc.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    init.c

Abstract:

    Intialize the shell library



Revision History

--*/

#include "shelllib.h"



EFI_STATUS
ShellExecute (
    IN EFI_HANDLE       ImageHandle,
    IN CHAR16           *CmdLine,
    IN BOOLEAN          Output
    )
{
    return SE->Execute (ImageHandle, CmdLine, Output);
}



CHAR16 *
MemoryTypeStr (
    IN EFI_MEMORY_TYPE  Type
    )
{
    return Type < EfiMaxMemoryType ? ShellLibMemoryTypeDesc[Type] : L"Unkown-Desc-Type";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\lib\shelllib.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    shelllib.h

Abstract:




Revision History

--*/


#include "shell.h"
#include "shellenv.h"


/* 
 *  Intenral shell lib globals
 */

extern CHAR16  *ShellLibMemoryTypeDesc[];
extern EFI_SHELL_ENVIRONMENT    *SE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\lib\io.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    io.c

Abstract:

    Intialize the shell library



Revision History

--*/

#include "shelllib.h"

CHAR16 *
ShellGetEnv (
    IN CHAR16       *Name
    )
{
    return SE->GetEnv (Name);
}

CHAR16 *
ShellGetMap (
    IN CHAR16       *Name
    )
{
    return SE->GetMap (Name);
}

CHAR16 *
ShellCurDir (
    IN CHAR16               *DeviceName OPTIONAL
    )
/*  N.B. Results are allocated from pool.  The caller must free the pool */
{
    return SE->CurDir (DeviceName);
}


EFI_STATUS
ShellFileMetaArg (
    IN CHAR16               *Arg,
    IN OUT LIST_ENTRY       *ListHead
    )
{
    return SE->FileMetaArg(Arg, ListHead);
}


EFI_STATUS
ShellFreeFileList (
    IN OUT LIST_ENTRY       *ListHead
    )
{
    return SE->FreeFileList(ListHead);
}


EFI_FILE_HANDLE 
ShellOpenFilePath (
    IN EFI_DEVICE_PATH      *FilePath,
    IN UINT64               FileMode
    )
{
    EFI_HANDLE              DeviceHandle;
    EFI_STATUS              Status;
    EFI_FILE_HANDLE         FileHandle, LastHandle;        
    FILEPATH_DEVICE_PATH    *FilePathNode;

    /* 
     *  File the file system for this file path
     */

    Status = BS->LocateDevicePath (&FileSystemProtocol, &FilePath, &DeviceHandle);
    if (EFI_ERROR(Status)) {
        return NULL;
    }

    /* 
     *  Attempt to access the file via a file system interface
     */

    FileHandle = LibOpenRoot (DeviceHandle);
    Status = FileHandle ? EFI_SUCCESS : EFI_UNSUPPORTED;

    /* 
     *  To access as a filesystem, the filepath should only
     *  contain filepath components.  Follow the filepath nodes
     *  and find the target file
     */

    FilePathNode = (FILEPATH_DEVICE_PATH *) FilePath;
    while (!IsDevicePathEnd(&FilePathNode->Header)) {

        /* 
         *  For filesystem access each node should be a filepath component
         */

        if (DevicePathType(&FilePathNode->Header) != MEDIA_DEVICE_PATH ||
            DevicePathSubType(&FilePathNode->Header) != MEDIA_FILEPATH_DP) {
            Status = EFI_UNSUPPORTED;
        }

        /* 
         *  If there's been an error, stop
         */

        if (EFI_ERROR(Status)) {
            break;
        }
        
        /* 
         *  Open this file path node
         */

        LastHandle = FileHandle;
        FileHandle = NULL;

        Status = LastHandle->Open (
                        LastHandle,
                        &FileHandle,
                        FilePathNode->PathName,
                        FileMode,
                        0
                        );
        
        /* 
         *  Close the last node
         */
        
        LastHandle->Close (LastHandle);

        /* 
         *  Get the next node
         */

        FilePathNode = (FILEPATH_DEVICE_PATH *) NextDevicePathNode(&FilePathNode->Header);
    }

    if (EFI_ERROR(Status)) {
        FileHandle = NULL;
    }

    return FileHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\load\load.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    mkdir.c
    
Abstract:

    Shell app "mkdir"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeLoad (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


VOID
LoadDriver (
    IN EFI_HANDLE           ImageHandle,
    IN SHELL_FILE_ARG       *Arg
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeLoad)

EFI_STATUS
InitializeLoad (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeLoad,
        L"load",                        /*  command */
        L"load driver_name",            /*  command syntax */
        L"Loads a driver",              /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *  Expand each arg
     */

    InitializeListHead (&FileList);
    for (Index = 1; Index < Argc; Index += 1) {
        ShellFileMetaArg (Argv[Index], &FileList);
    }

    if (IsListEmpty(&FileList)) {
        Print (L"load: no file specified\n");
        goto Done;
    }

    /* 
     *  Make each directory
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        LoadDriver (ImageHandle, Arg);
    }

Done:
    ShellFreeFileList (&FileList);
    return EFI_SUCCESS;
}


VOID
LoadDriver (
    IN EFI_HANDLE           ParentImage,
    IN SHELL_FILE_ARG       *Arg
    )
{
    EFI_HANDLE              ImageHandle;
    EFI_STATUS              Status;
    EFI_DEVICE_PATH         *NodePath, *FilePath;
    EFI_LOADED_IMAGE        *ImageInfo;

    NodePath = FileDevicePath (NULL, Arg->FileName);
    FilePath = AppendDevicePath (Arg->ParentDevicePath, NodePath);
    FreePool (NodePath);

    Status = BS->LoadImage (
                FALSE,
                ParentImage,
                FilePath,
                NULL,
                0,
                &ImageHandle
                );
    FreePool (FilePath);

    if (EFI_ERROR(Status)) {
        Print (L"load: LoadImage error %s - %r\n", Arg->FullName, Status);
        goto Done;
    }

    /* 
     *  Verify the image is a driver ?
     */

    BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID*)&ImageInfo);
    if (ImageInfo->ImageCodeType != EfiBootServicesCode &&
        ImageInfo->ImageCodeType != EfiRuntimeServicesCode) {

        Print (L"load: image %s is not a driver\n", Arg->FullName);
        BS->Exit (ImageHandle, EFI_SUCCESS, 0, NULL);
        goto Done;
    }

    /* 
     *  Start the image
     */

    Status = BS->StartImage (ImageHandle, 0, NULL);
    if (!EFI_ERROR(Status)) {
        Print (L"load: image %s loaded at %x. returned %r\n",
                Arg->FullName,
                ImageInfo->ImageBase,
                Status
                );
    } else {
        Print (L"load: image %s returned %r\n",
                Arg->FullName,
                Status
                );
    }
Done:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\memmap\memmap.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    memmap.c
    
Abstract:

    Shell app "memmap"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeMemmap (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

BOOLEAN
IsRealMemory (
    IN  EFI_MEMORY_TYPE     Type
    );
/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeMemmap)

EFI_STATUS
InitializeMemmap (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                      *p;
    UINTN                       Index;
    BOOLEAN                     PageBreaks;
    UINTN                       TempColumn;
    UINTN                       ScreenCount;
    UINTN                       ScreenSize;
    CHAR16                      ReturnStr[1];
    EFI_MEMORY_DESCRIPTOR       *Desc, *MemMap;
    UINTN                       DescriptorSize;
    UINT32                      DescriptorVersion;
    UINTN                       NoDesc, MapKey;
    UINT64                      Bytes;
    UINT64                      NoPages[EfiMaxMemoryType];
    UINT64                      TotalMemory;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeMemmap,
        L"memmap",                      /*  command */
        L"memmap [-b]",                 /*  command syntax */
        L"Dumps memory map",            /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    PageBreaks = FALSE;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == '-') {
            switch (p[1]) {
            case 'b' :
            case 'B' :
                PageBreaks = TRUE;
                ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                ScreenCount = 0;
                break;

            default:
                Print (L"%EDH: Unkown flag %s\n", p);
                return EFI_INVALID_PARAMETER;
            }
        }
    }

    /* 
     * 
     */

    MemMap = LibMemoryMap (&NoDesc, &MapKey, &DescriptorSize, &DescriptorVersion);
    if (!MemMap) {
        Print (L"Memory map was not returned\n");
    }

    ASSERT (DescriptorVersion == EFI_MEMORY_DESCRIPTOR_VERSION);
    for (Index=0; Index < EfiMaxMemoryType; Index += 1) {
        NoPages[Index] = 0;
    }

    Desc = MemMap;
    Print(L"\n%HType       Start            End               # Pages          Attributes%N\n");
    for (Index=0; Index < NoDesc; Index += 1) {
        Bytes = LShiftU64(Desc->NumberOfPages, 12);
        p = MemoryTypeStr(Desc->Type);
        Print(L"%s %lX-%lX  %lX %lX\n", p, Desc->PhysicalStart, Desc->PhysicalStart + Bytes - 1, Desc->NumberOfPages, Desc->Attribute);

        if (PageBreaks) {
            ScreenCount++;
            if (ScreenCount > ScreenSize - 4) {
                ScreenCount = 0;
                Print (L"\nPress Return to contiue :");
                Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                Print (L"\n\n");
            }
        }
        NoPages[Desc->Type] += Desc->NumberOfPages;
        Desc = NextMemoryDescriptor(Desc, DescriptorSize);
    }

    Print(L"\n");

    if (PageBreaks) {
        ScreenCount++;
        if (ScreenCount > ScreenSize - 4) {
            ScreenCount = 0;
            Print (L"\nPress Return to contiue :");
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
            Print (L"\n\n");
        }
    }

    for (Index=0, TotalMemory = 0; Index < EfiMaxMemoryType; Index += 1) {
        if (NoPages[Index]) {
            Print(L"  %s: %,7ld Pages (%,ld)\n", 
                MemoryTypeStr((EFI_MEMORY_TYPE)Index),
                NoPages[Index], 
                LShiftU64(NoPages[Index], 12)
                );

            if (PageBreaks) {
                ScreenCount++;
                if (ScreenCount > ScreenSize - 4) {
                    ScreenCount = 0;
                    Print (L"\nPress Return to contiue :");
                    Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                    Print (L"\n\n");
                }
            }

            if (IsRealMemory((EFI_MEMORY_TYPE)(Index))) {
                TotalMemory += NoPages[Index];
            }
        }
    }

    Print(L"Total Memory: %,ld MB (%,ld) Bytes\n",  
        RShiftU64(TotalMemory, 8),
        LShiftU64(TotalMemory, 12)
        );

    FreePool(MemMap);

    return EFI_SUCCESS;
}

BOOLEAN
IsRealMemory (
    IN  EFI_MEMORY_TYPE     Type
    )
{
    switch (Type) {
    case EfiLoaderCode:
    case EfiLoaderData:
    case EfiBootServicesCode:
    case EfiBootServicesData:
    case EfiRuntimeServicesCode:
    case EfiRuntimeServicesData:
    case EfiConventionalMemory:
    case EfiACPIReclaimMemory:
    case EfiACPIMemoryNVS:
    case EfiPalCode:
    /* 
     *  BugBug can EfiPalCode point to ROM?
     */
        return TRUE;
        break;
    default:
        return FALSE;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\mkdir\mkdir.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    mkdir.c
    
Abstract:

    Shell app "mkdir"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeMkDir (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


VOID
MkDir (
    IN SHELL_FILE_ARG       *Arg
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeMkDir)

EFI_STATUS
InitializeMkDir (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;


    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeMkDir,
        L"mkdir",                       /*  command */
        L"mkdir dir [dir] ...",         /*  command syntax */
        L"Make directory",              /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *  Expand each arg
     */

    InitializeListHead (&FileList);
    for (Index = 1; Index < Argc; Index += 1) {
        ShellFileMetaArg (Argv[Index], &FileList);
    }

    if (IsListEmpty(&FileList)) {
        Print (L"mkdir: no directory specified\n");
        goto Done;
    }

    /* 
     *  Make each directory
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        MkDir (Arg);
    }

Done:
    ShellFreeFileList (&FileList);
    return EFI_SUCCESS;
}


VOID
MkDir (
    IN SHELL_FILE_ARG       *Arg
    )
{
    EFI_FILE_HANDLE         NewDir;
    EFI_STATUS              Status;

    NewDir = NULL;
    Status = Arg->Status;

    if (!EFI_ERROR(Status)) {
        Print (L"mkdir: file %hs already exists\n", Arg->FullName);
        return ;
    }

    if (Status == EFI_NOT_FOUND) {

        Status = Arg->Parent->Open (
                        Arg->Parent,
                        &NewDir,
                        Arg->FileName,
                        EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE,
                        EFI_FILE_DIRECTORY
                        );  
    }

    if (EFI_ERROR(Status)) {
        Print (L"mkdir: failed to create %s - %r\n", Arg->FullName, Status);
    }


    if (NewDir) {
        NewDir->Close(NewDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\mem\mem.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    io.c
    
Abstract:   




Revision History

--*/

#include "shelle.h"

EFI_STATUS
DumpMem (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(DumpMem)


EFI_STATUS
DumpMem (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

    mem [Address] [Size] ;MMIO
        if no Address default address is EFI System Table
        if no size default size is 512;
        if ;MMIO then use memory mapped IO and not system memory
 --*/
{
    EFI_STATUS                      Status;
    EFI_HANDLE                      Handle;
    EFI_DEVICE_PATH                 *DevicePath;
    EFI_DEVICE_IO_INTERFACE         *IoDev;
    UINT64                          Address;
    UINTN                           Size;
    UINT8                           *Buffer;
    BOOLEAN                         MMIo;
    UINTN                           Index;
    CHAR16                          *AddressStr, *SizeStr, *p;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   DumpMem, 
        L"mem",                            /*  command */
        L"mem [Address] [size] [;MMIO]",      /*  command syntax */
        L"Dump Memory or Memory Mapped IO",       /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    /* 
     *  The End Device Path represents the Root of the tree, thus get the global IoDev
     *   for the system
     */
    InitializeShellApplication (ImageHandle, SystemTable);

    MMIo = FALSE;
    AddressStr = SizeStr = NULL;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == ';') {
            /*  Shortcut! assume MMIo if ; exists */
            MMIo = TRUE;
            continue;
        } else if (*p == '-') {
            switch (p[1]) {
            case 'h':
            case 'H':
            case '?':
            default:
                Print (L"\n%Hmem%N [%HAddress%N] [%HSize%N] [%H;MMIO%N]\n");
                Print (L"  if no %HAddress%N is specified the EFI System Table is used\n");
                Print (L"  if no %HSize%N is specified 512 bytes is used\n");
                Print (L"  if %H;MMIO%N is specified memory is referenced with the DeviceIo Protocol\n");
                return EFI_SUCCESS;
            };
            continue;
        }
        if (!AddressStr) {
            AddressStr = p;        
            continue;
        }
        if (!SizeStr) {
           SizeStr = p;
           continue;
        }
    }

    Address = (AddressStr) ? xtoi(AddressStr) : (UINT64)SystemTable;
    Size = (SizeStr) ? xtoi(SizeStr) : 512;

    Print (L"  Memory Address %016lx %0x Bytes\n", Address, Size);
    if (MMIo) {
        DevicePath = EndDevicePath;
        Status = BS->LocateDevicePath (&DeviceIoProtocol, &DevicePath, &Handle);
        if (!EFI_ERROR(Status)) {
            Status = BS->HandleProtocol (Handle, &DeviceIoProtocol, (VOID*)&IoDev);
        } 

        if (EFI_ERROR(Status)) {
            Print (L"%E - handle protocol error %r%N", Status);
            return Status;
        }
        Buffer = AllocatePool (Size);
        if (Buffer == NULL) {
            return EFI_OUT_OF_RESOURCES;
        }
        IoDev->Mem.Read (IoDev, IO_UINT8, Address, Size, Buffer);
    } else {
        Buffer = (UINT8 *)Address;
    }

    DumpHex (2, (UINTN)Address, Size, Buffer);
    EFIStructsPrint (Buffer, Size, Address, NULL);

    if (MMIo) {
        FreePool (Buffer);
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\ls\ls.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    ls.c
    
Abstract:

    Shell app "ls"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeLS (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
LsCurDir (
    IN CHAR16               *CurDir
    );

VOID
LsDir (
    IN SHELL_FILE_ARG       *Arg
    );

VOID
LsDumpFileInfo (
    IN EFI_FILE_INFO        *Info
    );

/* 
 * 
 */

CHAR16  *LsLastDir;
UINTN   LsCount;

UINTN   LsDirs;
UINTN   LsFiles;
UINT64  LsDirSize;
UINT64  LsFileSize;

UINTN   LsTotalDirs;
UINTN   LsTotalFiles;
UINT64  LsTotalDirSize;
UINT64  LsTotalFileSize;

BOOLEAN PageBreaks;
UINTN   TempColumn;
UINTN   ScreenCount;
UINTN   ScreenSize;

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeLS)

EFI_STATUS
InitializeLS (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    CHAR16                  *p;
    UINTN                   Index;
    LIST_ENTRY              DirList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeLS, 
        L"ls",                          /*  command */
        L"ls [-b] [dir] [dir] ...",     /*  command syntax */
        L"Obtain directory listing",    /*  1 line descriptor     */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    LsTotalDirs = 0;
    LsTotalFiles = 0;
    LsTotalDirSize = 0;
    LsTotalFileSize = 0;
    LsLastDir = NULL;
    LsCount = 0;
    InitializeListHead (&DirList);

    /* 
     *  Scan args for flags
     */

    PageBreaks = FALSE;
    for (Index = 1; Index < Argc; Index += 1) {
        if (Argv[Index][0] == '-') {
            for (p = Argv[Index]+1; *p; p++) {
                switch (*p) {
                case 'b' :
                case 'B' :
                    PageBreaks = TRUE;
                    ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                    ScreenCount = 0;
                    break;
                default:
                    Print (L"ls: Unkown flag %s\n", Argv[Index]);
                    goto Done;
                }
            }
        }
    }

    /* 
     *  Dir each directory indicated by the args
     */

    for (Index = 1; Index < Argc; Index += 1) {
        if (Argv[Index][0] != '-') {
            ShellFileMetaArg (Argv[Index], &DirList);
        }
    }

    /* 
     *  If no directory arguments supplied, then dir the current directory
     */

    if (IsListEmpty(&DirList)) {
        ShellFileMetaArg(L".", &DirList);
    }

    /* 
     *  Perform dir's on the directories
     */

    for (Link=DirList.Flink; Link!=&DirList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        LsDir (Arg);
    }


    /* 
     *  Dump final totals
     */

    LsCurDir (NULL);
    if (LsCount > 1) {
        Print (L"\n     Total %10,d File%c %12,ld bytes",
            LsTotalFiles,
            LsTotalFiles <= 1 ? ' ':'s',
            LsTotalFileSize
            );

        Print (L"\n     Total %10,d Dir%c  %12,ld bytes\n\n",
            LsTotalDirs,
            LsTotalDirs <= 1 ? ' ':'s',
            LsTotalDirSize
            );

    }

Done:
    ShellFreeFileList (&DirList);
    return EFI_SUCCESS;
}

VOID
LsCurDir (
    IN CHAR16               *CurDir
    )    
{
    if (!LsLastDir || !CurDir || StriCmp(LsLastDir, CurDir)) {
        if (LsLastDir) {
            Print (L"\n           %10,d File%c %12,ld bytes",
                LsFiles,
                LsFiles <= 1 ? ' ':'s',
                LsFileSize
                );

            Print (L"\n           %10,d Dir%c  %12,ld bytes\n\n",
                LsDirs,
                LsDirs <= 1 ? ' ':'s',
                LsTotalDirSize
                );

            LsCount += 1;
        }

        LsDirs = 0;
        LsFiles = 0;
        LsDirSize = 0;
        LsFileSize = 0;
        LsLastDir = CurDir;

        if (CurDir) {
            Print (L"Directory of %hs\n", CurDir);
        }
    }
}


VOID
LsDir (
    IN SHELL_FILE_ARG       *Arg
    )
{
    EFI_FILE_INFO           *Info;
    UINTN                   BufferSize, bs;
    EFI_STATUS              Status;
    
    Info = NULL;

    if (EFI_ERROR(Arg->Status)) {
        Print(L"ls: could not list file %hs - %r\n", Arg->FullName, Arg->Status);
        goto Done;
    }

    BufferSize = SIZE_OF_EFI_FILE_INFO + 1024;
    Info = AllocatePool (BufferSize);
    if (!Info) {
        goto Done;
    }

    
    if (Arg->Info->Attribute & EFI_FILE_DIRECTORY) {

        /*  BUGBUG: dump volume info here */
        LsCurDir (Arg->FullName);

        /* 
         *  Read all the file entries
         */

        Arg->Handle->SetPosition (Arg->Handle, 0);

        for (; ;) {

            bs = BufferSize;
            Status = Arg->Handle->Read (Arg->Handle, &bs, Info);

            if (EFI_ERROR(Status)) {
                goto Done;
            }

            if (bs == 0) {
                break;
            }

            LsDumpFileInfo (Info);
        }

    } else {

        /*  Dump the single file */

        LsCurDir (Arg->ParentName);
        LsDumpFileInfo (Arg->Info);

    }


Done:
    if (Info) {
        FreePool (Info);
    }
}



VOID
LsDumpFileInfo (
    IN EFI_FILE_INFO        *Info
    )
{
    CHAR16                      ReturnStr[1];

    Print (L"  %t %s %c  %11,ld  ",
                &Info->ModificationTime,
                Info->Attribute & EFI_FILE_DIRECTORY ? L"<DIR>" : L"     ",
                Info->Attribute & EFI_FILE_READ_ONLY ? 'r' : ' ',
                Info->FileSize,
                Info->FileName
                );

    Print (L"%s\n", Info->FileName);

    if (Info->Attribute & EFI_FILE_DIRECTORY) {
        LsTotalDirs++;
        LsDirs++;
        LsTotalDirSize += Info->FileSize;
        LsDirSize += Info->FileSize;
    } else {
        LsTotalFiles++;
        LsFiles++;
        LsTotalFileSize += Info->FileSize;
        LsFileSize += Info->FileSize;
    }

    if (PageBreaks) {
        ScreenCount++;
        if (ScreenCount > ScreenSize - 4) {
            ScreenCount = 0;
            Print (L"\nPress Return to contiue :");
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
            Print (L"\n\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\newshell\nshell.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    nshell.h
    
Abstract:

    Shell



Revision History

--*/


#include "shell.h"
#include "shellenv.h"

/* 
 *  Globals
 */

extern EFI_SHELL_ENVIRONMENT *SE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\mode\mode.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    mode.c
    
Abstract:

    Shell app "mode"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeMode (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeMode)

EFI_STATUS
InitializeMode (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   NewCol, NewRow;
    UINTN                   Col, Row;
    UINTN                   Index;
    INTN                    Mode;
    EFI_STATUS              Status;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;

    /*  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeMode,
        L"mode",                        /*  command */
        L"mode [col row]",              /*  command syntax */
        L"Set/get current text mode",   /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  Initialize app
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *  Scan args
     */

    NewRow = 0;
    NewCol = 0;

    for (Index = 1; Index < Argc; Index += 1) {

        if (!NewCol) {
            NewCol = Atoi (Argv[Index]);
            continue;
        }

        if (!NewRow) {
            NewRow = Atoi (Argv[Index]);
            continue;
        }

        Print (L"%Emode: too many arguments\n");
        goto Done;
    }

    ConOut = ST->ConOut;

    /* 
     *  If not setting a new mode, dump the available modes
     */

    if (!NewRow && !NewCol) {

        Print (L"Available modes on standard output\n");

        for (Mode=0; Mode < ConOut->Mode->MaxMode; Mode++) {
            Status = ConOut->QueryMode(ConOut, Mode, &Col, &Row);
            if (EFI_ERROR(Status)) {
                Print (L"%Emode: failed to query mode: %r\n", Status);
                goto Done;
            }

            Print (L"  col %3d row %3d  %c\n", Col, Row, Mode == ConOut->Mode->Mode ? '*' : ' ');
        }

    } else {

        for (Mode=0; Mode < ConOut->Mode->MaxMode; Mode++) {
            Status = ConOut->QueryMode(ConOut, Mode, &Col, &Row);
            if (EFI_ERROR(Status)) {
                Print (L"%Emode: failed to query mode: %r\n", Status);
                goto Done;
            }

            if (Row == NewRow && Col == NewCol) {
                ConOut->SetMode (ConOut, Mode);
                ConOut->ClearScreen (ConOut);
                goto Done;
            }
        }

        Print (L"%Emode: not found (%d,%d)\n", NewCol, NewRow);
    }

Done:
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\reset\reset.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    reset.c
    
Abstract:   


Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeReset (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeReset)

EFI_STATUS
InitializeReset (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

    reset [warm] 

 --*/
{
    EFI_RESET_TYPE  ResetType;
    UINTN           DataSize;
    CHAR16          *ResetData, *Str;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeReset, 
        L"reset",                           /*  command */
        L"reset [/warm] [reset string]",     /*  command syntax */
        L"Cold or Warm reset",              /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    InitializeShellApplication (ImageHandle, SystemTable);
    
    ResetType = EfiResetCold;
    if (SI->Argc > 1) {
        Str = SI->Argv[1];
        if (Str[0] == '-' || Str[0] == '/') {
            if (Str[1] = 'W' || Str[1] == 'w') {
                ResetType = EfiResetWarm;
            } else {
                Print(L"reset [/warm] [reset string]\n");
                return EFI_SUCCESS;
            }
        }
    }

    DataSize = 0;
    ResetData = NULL;
    if (SI->Argc > 2) {
        ResetData = SI->Argv[2];
        DataSize = StrSize(ResetData);
    }

    return RT->ResetSystem(ResetType, EFI_SUCCESS, DataSize, ResetData);
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\pci\pci.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    pci.c
    
Abstract:   




Revision History

--*/

#include "shelle.h"
#include "pci22.h"

EFI_STATUS
PciDump (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

#define HEADER_TYPE_MULTI_FUNCTION  0x80


typedef struct _PCI_CLASS_CODE {
    UINT8                       Class;
    CHAR16                      *Str;
    struct _PCI_CLASS_CODE      *SubClass;
} PCI_CLASS_CODE;


VOID
PciPrintClassCode (
    IN  PCI_DEVICE_INDEPENDENT_REGION   *Pci
    );


PCI_CLASS_CODE PciMassStoreSubClass[] = {
    0x00,    L"SCSI Bus",               NULL,
    0x01,    L"IDE",                    NULL,
    0x02,    L"Floppy",                 NULL,
    0x03,    L"IPI",                    NULL,
    0x04,    L"RAID",                   NULL,
    0x80,    L"Other",                  NULL,
    0xff,    L"ERROR",                  NULL
};

PCI_CLASS_CODE PciNetworkSubClass[] = {
    0x00,    L"Ethernet",               NULL,
    0x01,    L"Token Ring",             NULL,
    0x02,    L"FDDI",                   NULL,
    0x03,    L"ATM",                    NULL,
    0x80,    L"Other",                  NULL,
    0xff,    L"ERROR",                  NULL
};

PCI_CLASS_CODE PciDisplayControllerClass[] = {
    0x00,    L"VGA",                    NULL,
    0x01,    L"XVGA",                   NULL,
    0x02,    L"3D",                     NULL,
    0x80,    L"Other",                  NULL,
    0xff,    L"ERROR",                  NULL
};

PCI_CLASS_CODE PciBridgeSubClass[] = {
    0x00,    L"Host",               NULL,
    0x01,    L"ISA",                NULL,
    0x02,    L"EISA",               NULL,
    0x03,    L"MC",                 NULL,
    0x04,    L"PCI to PCI",         NULL,
    0x05,    L"PCMCIA",             NULL,
    0x06,    L"NuBus",              NULL,
    0x07,    L"CardBus",            NULL,
    0x08,    L"RACEway",            NULL,
    0xff,    L"ERROR",              NULL
};

PCI_CLASS_CODE PciSysPeriphSubClass[] = {
    0x00,    L"Interrupt Controller",   NULL,
    0x01,    L"DMA",                    NULL,
    0x02,    L"System Timer",           NULL,
    0x03,    L"RTC",                    NULL,
    0x80,    L"Other",                  NULL,
    0xff,    L"ERROR",                  NULL
};

PCI_CLASS_CODE PciSerialBusSubClass[] = {
    0x00,    L"1394",                    NULL,
    0x01,    L"ACCESS Bus",              NULL,
    0x02,    L"SSA",                     NULL,
    0x03,    L"USB",                     NULL,
    0x04,    L"Fibre Channel",           NULL,
    0x05,    L"SMBus",                   NULL,
    0x80,    L"Other",                   NULL,
    0xff,    L"ERROR",                   NULL
};

/* 
 *  BugBug: I got tired of typing, so this is only partial PCI info.
 */
PCI_CLASS_CODE PciClassCodes[] = {
    0x00,   L"Backward Compatible",         NULL,
    0x01,   L"Mass Storage Controller",     PciMassStoreSubClass,
    0x02,   L"Network Controller",          PciNetworkSubClass,
    0x03,   L"Display Controller",          PciDisplayControllerClass,
    0x04,   L"Multimedia Device",           NULL,
    0x05,   L"Memory Controller",           NULL,
    0x06,   L"PCI Bridge Device",           PciBridgeSubClass,
    0x07,   L"Communications Controller",   NULL,
    0x08,   L"Generic System Peripheral",   PciSysPeriphSubClass,
    0x09,   L"Input Devices",               NULL,
    0x0a,   L"Docking Stations",            NULL,
    0x0b,   L"Processors",                  NULL,
    0x0c,   L"Serial Bus Controller",       PciSerialBusSubClass,
    0x0d,   L"Wireless Controller",         NULL,
    0x0e,   L"I2O",                         NULL,
    0x0f,   L"Satellite Controller",        NULL,
    0x10,   L"Encryption Controller",       NULL,
    0x11,   L"Data Acquisition",            NULL,
    0xff,   L"No Class",                    NULL
};


VOID
PciPrintClassCode (
    IN  PCI_DEVICE_INDEPENDENT_REGION   *Pci
    )
{
    UINT16          *BaseClass, *SubClass;
    UINTN           i,j;
    PCI_CLASS_CODE  *ClassTable;

    BaseClass = SubClass = NULL;
    for (i=0; PciClassCodes[i].Class != 0xff; i++) {
        if (Pci->ClassCode[2] == PciClassCodes[i].Class) {
            BaseClass = PciClassCodes[i].Str;
            if (PciClassCodes[i].SubClass) {
                ClassTable = PciClassCodes[i].SubClass;
                for (j=0; ClassTable->Class != 0xff; j++, ClassTable++) {
                    if (Pci->ClassCode[1] == ClassTable->Class) {
                        SubClass = ClassTable->Str;
                    }
                }
            }
        }
    }

    Print (L"%s - %s", BaseClass, (SubClass == NULL ? L"" : SubClass));
}

EFI_DRIVER_ENTRY_POINT(PciDump)

EFI_STATUS
PciDump (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

pci [bus dev] [func]

---*/
{
    EFI_STATUS                      Status;
    UINT32                          Buffer[64];
    EFI_DEVICE_IO_INTERFACE         *IoDev;
    UINT64                          Address, FuncAddress;
    UINT16                          Bus, Device, Func;
    EFI_HANDLE                      Handle;
    EFI_DEVICE_PATH                 *DevicePath;
    PCI_DEVICE_INDEPENDENT_REGION   PciHeader;
    PCI_CONFIG_ACCESS_CF8           Pci;
    DEFIO_PCI_ADDR                  Defio;
    UINTN                           ScreenCount;
    UINTN                           TempColumn;
    UINTN                           ScreenSize;
    CHAR16                          ReturnStr[1];

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   PciDump, 
        L"pci",                             /*  command */
        L"pci [bus dev] [func]",            /*  command syntax */
        L"Display PCI device(s) info",      /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    
    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     *  The End Device Path represents the Root of the tree, thus get the global IoDev
     *   for the system
     */
    DevicePath = EndDevicePath;
    Status = BS->LocateDevicePath (&DeviceIoProtocol, &DevicePath, &Handle);
    if (!EFI_ERROR(Status)) {
        Status = BS->HandleProtocol (Handle, &DeviceIoProtocol, (VOID*)&IoDev);
    }
    if (EFI_ERROR(Status)) {
        Print (L"%E - handle protocol error %r%N", Status);
        return EFI_SUCCESS;
    }

    if ( SI->Argc < 3 ) {
        ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
        ScreenCount = 0;

        Print (L"\n   Bus  Dev  Func");
        Print (L"\n   ---  ---  ----");
        ScreenSize -= 4;

        for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
            for (Device = 0; Device < 32; Device++) {
                Address = (Bus << 24) + (Device << 16);
                for (Func = 0; Func < 8; Func++) {
                    FuncAddress = Address + (Func << 8);
                    IoDev->Pci.Read (IoDev, IO_UINT16, FuncAddress, 1, &PciHeader.VendorId);
                    if (PciHeader.VendorId != 0xffff) {
                        IoDev->Pci.Read (IoDev, IO_UINT32, FuncAddress, sizeof(PciHeader)/sizeof(UINT32), &PciHeader);
                        Print (L"%E");
                        Print (L"\n    %02x   %02x    %02x ==> %N", Bus, Device, Func);
                        PciPrintClassCode (&PciHeader);
                        Print (L"\n                       Vendor 0x%04x Device 0x%04x Prog Interface %x", PciHeader.VendorId, PciHeader.DeviceId, PciHeader.ClassCode[0]);
                        if (Func == 0) {
                            if ((PciHeader.HeaderType & HEADER_TYPE_MULTI_FUNCTION) == 0x00) {
                                /* 
                                 *  If this is not a multifucntion device leave the loop
                                 */
                                Func = 8;
                            }
                        }
                        ScreenCount += 2;
                        if (ScreenCount >= ScreenSize && ScreenSize != 0) {
                            /* 
                             *  If ScreenSize == 0 we have the console redirected so don't
                             *   block updates
                             */
                            ScreenCount = 0;
                            Print (L"\nPress Return to contiue :");
                            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                            Print (L"\n   Bus  Dev  Func");
                            Print (L"\n   ---  ---  ----");
                        }
                    } else {
                        /* 
                         *  If Func 0 does not exist there are no sub fucntions
                         */
                        Func = 8;
                    }
                }
            }
        }   
        Print (L"\n");
        return EFI_SUCCESS;
    }
    Bus = (UINT16) xtoi(SI->Argv[1]);
    Device = (UINT16) xtoi(SI->Argv[2]);
    if (SI->Argc > 3) {
        Func = (UINT16) xtoi(SI->Argv[3]);
    } else {
        Func = 0;
    }

    Address = (Bus << 24) + (Device << 16) + (Func << 8);
    CopyMem (&Defio, &Address, sizeof(Address));
    Pci.Reg = Defio.Register;
    Pci.Func = Defio.Function;
    Pci.Dev = Defio.Device;
    Pci.Bus = Defio.Bus;
    Pci.Reserved = 0;
    Pci.Enable = 1;

    Print (L"%H  PCI Bus %02x Device %02x Func %02x%N [0xcf8(0x%08x) EFI 0x00%02x%02x%02x00]\n", Bus, Device, Func, Pci, Bus, Device, Func);
    
    /* 
     *  Dump standard header
     */
    IoDev->Pci.Read (IoDev, IO_UINT32, Address, 16, Buffer);
    DumpHex (2, 0, 16*sizeof(UINT32), Buffer);
    Print(L"\n");

    /* 
     *  Dump Device Dependent Header
     */
    IoDev->Pci.Read (IoDev, IO_UINT32, Address + 0x40, 48, Buffer);
    DumpHex (2, 0x40, 48*sizeof(UINT32), Buffer);

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\cwd.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\rm\rm.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    rm.c
    
Abstract:

    Shell app "rm"



Revision History

--*/

#include "shell.h"

/* 
 * 
 */

#define FILE_INFO_SIZE  (SIZE_OF_EFI_FILE_INFO + 1024)
EFI_FILE_INFO   *RmInfo;


/* 
 * 
 */

EFI_STATUS
InitializeRM (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


VOID
RemoveRM (
    IN SHELL_FILE_ARG       *Arg,
    IN BOOLEAN              Quite
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeRM)

EFI_STATUS
InitializeRM (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeRM,
        L"rm",                          /*  command */
        L"rm file/dir [file/dir]",      /*  command syntax */
        L"Remove file/directories",     /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;
    InitializeListHead (&FileList);

    RmInfo = AllocatePool (FILE_INFO_SIZE);
    if (!RmInfo) {
        Print (L"rm: out of memory\n");
        goto Done;
    }

    /* 
     *  Expand each arg
     */

    for (Index = 1; Index < Argc; Index += 1) {
        ShellFileMetaArg (Argv[Index], &FileList);
    }

    if (IsListEmpty(&FileList)) {
        Print (L"rm: no file specified\n");
        goto Done;
    }

    /* 
     *  Remove each file
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        RemoveRM (Arg, 0);
    }

Done:
    ShellFreeFileList (&FileList);
    if (RmInfo) {
        FreePool (RmInfo);
        RmInfo = NULL;
    }

    return EFI_SUCCESS;
}


SHELL_FILE_ARG *
RmCreateChild (
    IN SHELL_FILE_ARG       *Parent,
    IN CHAR16               *FileName,
    IN OUT LIST_ENTRY       *ListHead
    )
{
    SHELL_FILE_ARG          *Arg;
    UINTN                   Len;

    Arg = AllocateZeroPool (sizeof(SHELL_FILE_ARG));
    if (!Arg) {
        return NULL;
    }

    Arg->Signature = SHELL_FILE_ARG_SIGNATURE;
    Parent->Parent->Open (Parent->Handle, &Arg->Parent, L".", EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    Arg->ParentName = StrDuplicate(Parent->FullName);
    Arg->FileName = StrDuplicate(FileName);

    /*  append filename to parent's name to get the file's full name */
    Len = StrLen(Arg->ParentName);
    if (Len && Arg->ParentName[Len-1] == '\\') {
        Len -= 1;
    }

    Arg->FullName = PoolPrint(L"%.*s\\%s", Len, Arg->ParentName, FileName);

    /*  open it */
    Arg->Status = Parent->Handle->Open (
                        Parent->Handle, 
                        &Arg->Handle, 
                        Arg->FileName,
                        EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
                        0
                        );

    InsertTailList (ListHead, &Arg->Link);
    return Arg;
}


VOID
RemoveRM (
    IN SHELL_FILE_ARG           *Arg,
    IN BOOLEAN                  Quite
    )
{
    EFI_STATUS                  Status;
    SHELL_FILE_ARG              *Child;
    LIST_ENTRY                  Cleanup;
    UINTN                       Size;    
    CHAR16                      Str[2];

    Status = Arg->Status;
    InitializeListHead (&Cleanup);

    if (EFI_ERROR(Status)) {
        goto Done;
    }

    /* 
     *  If the file is a directory check it
     */

    Size = FILE_INFO_SIZE;
    Status = Arg->Handle->GetInfo(Arg->Handle, &GenericFileInfo, &Size, RmInfo);
    if (EFI_ERROR(Status)) {
        Print(L"rm: can not get info of %hs\n", Arg->FullName);
        goto Done;
    }

    if (RmInfo->Attribute & EFI_FILE_DIRECTORY) {

        /* 
         *  Remove all child entries from the directory
         */

        Arg->Handle->SetPosition (Arg->Handle, 0);
        for (; ;) {
            Size = FILE_INFO_SIZE;
            Status = Arg->Handle->Read (Arg->Handle, &Size, RmInfo);
            if (EFI_ERROR(Status) || Size == 0) {
                break;
            }

            /* 
             *  Skip "." and ".."
             */

            if (StriCmp(RmInfo->FileName, L".") == 0 ||
                StriCmp(RmInfo->FileName, L"..") == 0) {
                continue;
            }

            /* 
             *  Build a shell_file_arg for the sub-entry
             */

            Child = RmCreateChild (Arg, RmInfo->FileName, &Cleanup);

            /* 
             *  Remove it
             */

            if (!Quite) {
                Print (L"rm: remove subtree '%hs' [y/n]? ", Arg->FullName);
                Input (NULL, Str, 2);
                Print (L"\n");

                Status = (Str[0] == 'y' || Str[0] == 'Y') ? EFI_SUCCESS : EFI_ACCESS_DENIED;

                if (EFI_ERROR(Status)) {
                    goto Done;
                }
            }    

            Quite = TRUE;
            RemoveRM (Child, TRUE);

            /* 
             *  Close the handles
             */

            ShellFreeFileList (&Cleanup);
        }
    }

    /* 
     *  Remove the file
     */

    Status = Arg->Handle->Delete(Arg->Handle);
    Arg->Handle = NULL;

Done:
    if (EFI_ERROR(Status)) {
        Print (L"rm %s : %hr\n", Arg->FullName, Status);
    } else {
        Print (L"rm %s [ok]\n", Arg->FullName);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\setsize\setsize.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    setsize.c
    
Abstract:

    Shell app "setsize"
    Test application to adjust the file's size via the SetInfo FS interface

Revision History

--*/

#include "shell.h"

/* 
 * 
 */

EFI_STATUS
InitializeSetSize (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
SetSizeFile (
    IN SHELL_FILE_ARG       *Arg,
    IN UINTN                NewSize
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeSetSize)

EFI_STATUS
InitializeSetSize (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;
    UINTN                   NewSize;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeSetSize,
        L"setsize",                     /*  command */
        L"setsize newsize fname",       /*  command syntax */
        L"sets the files size",         /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;
    InitializeListHead (&FileList);

    /* 
     *  Expand each arg
     */

    for (Index = 2; Index < Argc; Index += 1) {
        ShellFileMetaArg (Argv[Index], &FileList);
    }

    /*  if no file specified, get the whole directory */
    if (Argc < 3 || IsListEmpty(&FileList)) {
        Print (L"setsize: newsize filename\n");
        goto Done;
    }

    /* 
     *  Crack the file size param
     */

    NewSize = Atoi(Argv[1]);


    /* 
     *  Set the file size of each file
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        SetSizeFile (Arg, NewSize);
    }

Done:
    ShellFreeFileList (&FileList);
    return EFI_SUCCESS;
}

VOID
SetSizeFile (
    IN SHELL_FILE_ARG       *Arg,
    IN UINTN                NewSize
    )
{
    EFI_STATUS                  Status;

    Status = Arg->Status;
    if (!EFI_ERROR(Status)) {
        Arg->Info->FileSize = NewSize;
        Status = Arg->Handle->SetInfo(  
                    Arg->Handle,
                    &GenericFileInfo,
                    (UINTN) Arg->Info->Size,
                    Arg->Info
                    );
    }

    if (EFI_ERROR(Status)) {
        Print (L"setsize: %s to %,d : %hr\n", Arg->FullName, NewSize, Status);
    } else {
        Print (L"setsize: %s to %,d [ok]\n", Arg->FullName, NewSize);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\mv\mv.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    mv.c
    
Abstract:

    Shell app "mv" - moves files on the same volume

    Note this app is broke... I only used it to test the rename function
    in the SetInfo interface.  This app gets confused on simply requests like:

        mv \file .

    when "." is not the root directory, etc..


Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeMv (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
MvFile (
    IN SHELL_FILE_ARG       *Arg,
    IN CHAR16               *NewName
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeMv)

EFI_STATUS
InitializeMv (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              SrcList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;
    CHAR16                  *DestName, *FullDestName;
    BOOLEAN                 DestWild;
    CHAR16                  *s;
    UINTN                   BufferSize;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeMv,
        L"mv",                          /*  command */
        L"mv sfile dfile",              /*  command syntax */
        L"Moves files",                 /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;
    InitializeListHead (&SrcList);

    if (Argc < 3) {
        Print (L"mv: sfile dfile\n");
        goto Done;
    }

    /* 
     *  BUGBUG:
     *  If the last arg has wild cards then perform dos expansion
     */

    DestWild = FALSE;
    DestName = Argv[Argc-1];
    for (s = DestName; *s; s += 1) {
        if (*s == '*') {
            DestWild = TRUE;
        }
    }

    if (DestWild) {
        Print (L"mv: bulk rename with '*' not complete\n");
        goto Done;
    }

    /* 
     *  Verify destionation does not include a device mapping
     */

    for (s = DestName; *s; s += 1) {
        if (*s == ':') {
            Print (L"mv: dest can not include device mapping\n");
            goto Done;
        }

        if (*s == '\\') {
            break;
        }
    }

    /* 
     *  Expand each arg
     */

    for (Index = 1; Index < Argc-1; Index += 1) {
        ShellFileMetaArg (Argv[Index], &SrcList);
    }

    /* 
     *  If there's only 1 source name, then move it to the dest name
     */

    Arg = CR(SrcList.Flink, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
    if (Arg->Link.Flink == &SrcList) {

        MvFile (Arg, DestName);

    } else {

        BufferSize = StrSize(DestName) + EFI_FILE_STRING_SIZE;
        FullDestName = AllocatePool (BufferSize);

        if (!FullDestName) {
            Print (L"mv: out of resources\n");
            goto Done;
        }

        for (Link=SrcList.Flink; Link != &SrcList; Link=Link->Flink) {
            SPrint (FullDestName, BufferSize, L"%s\\%s", DestName, Arg->FileName);
            MvFile (Arg, FullDestName);
        }

        FreePool (FullDestName);
    }

Done:
    ShellFreeFileList (&SrcList);
    return EFI_SUCCESS;
}

VOID
MvFile (
    IN SHELL_FILE_ARG           *Arg,
    IN CHAR16                   *NewName
    )
{
    EFI_STATUS                  Status;
    EFI_FILE_INFO               *Info;
    UINTN                       NameSize;

    Status = Arg->Status;
    if (!EFI_ERROR(Status)) {

        NameSize = StrSize(NewName);
        Info = AllocatePool (SIZE_OF_EFI_FILE_INFO + NameSize);
        Status = EFI_OUT_OF_RESOURCES;

        if (Info) {
            CopyMem (Info, Arg->Info, SIZE_OF_EFI_FILE_INFO);
            CopyMem (Info->FileName, NewName, NameSize);
            Info->Size = SIZE_OF_EFI_FILE_INFO + NameSize;
            Status = Arg->Handle->SetInfo(
                        Arg->Handle,
                        &GenericFileInfo,
                        (UINTN) Info->Size,
                        Info
                        );

            FreePool (Info);
        }
    }

    if (EFI_ERROR(Status)) {
        Print (L"mv: %s -> %s : %hr\n", Arg->FullName, NewName, Status);
    } else {
        Print (L"mv: %s -> %s [ok]\n", Arg->FullName, NewName);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\newshell\init.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    init.c
    
Abstract:

    Shell



Revision History

--*/

#include "nshell.h"

/* 
 *  Globals
 */

CHAR16 *ShellEnvPathName[] = {
    L"shellenv.efi",
    L"efi\\shellenv.efi",
    L"efi\\tools\\shellenv.efi",
    NULL
} ;

/* 
 *  Prototypes
 */

EFI_STATUS
InitializeShell (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_STATUS
ShellLoadEnvDriver (
    IN EFI_HANDLE           ImageHandle
    );

EFI_STATUS
NShellPrompt (
    IN EFI_HANDLE           ImageHandle
    );

BOOLEAN
ParseLoadOptions(
    EFI_HANDLE  ImageHandle,
    OUT CHAR16  **CommandLine,
    OUT CHAR16  **CurrentDir
    );

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeShell)

EFI_STATUS
InitializeShell (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
/*++

Routine Description:

Arguments:

    ImageHandle     - The handle for this driver

    SystemTable     - The system table

Returns:

--*/
{
    EFI_STATUS              Status;
    EFI_HANDLE              Handle;
    UINTN                   BufferSize;
    VOID                    *Junk;
    BOOLEAN                 IsRootInstance;
    CHAR16                  *CommandLine;
    CHAR16                  *CurrentDir;

    /* 
     *  The shell may be started as either:
     *   1. the first time with no shell environment loaded yet
     *   2. not the first time, but with a shell environment loaded
     *   3. as a child of a parent shell image
     */

    IsRootInstance = FALSE;
    InitializeLib (ImageHandle, SystemTable);

    /* 
     *  If the shell environment is not loaded, load it now
     */

    BufferSize = sizeof(Handle);
    Status = BS->LocateHandle(ByProtocol, &ShellEnvProtocol, NULL, &BufferSize, &Handle);
    if (EFI_ERROR(Status)) {
        Status = ShellLoadEnvDriver (ImageHandle);
        if (EFI_ERROR(Status)) {
            Print(L"Shell environment driver not loaded\n");
            BS->Exit (ImageHandle, Status, 0, NULL);
        }
    }

    /* 
     *  Check to see if we're a child of a previous shell
     */

    Status = BS->HandleProtocol (ImageHandle, &ShellInterfaceProtocol, (VOID*)&Junk);
    if (EFI_ERROR(Status)) {

        /* 
         *  Special case were the shell is being started directly (e.g., not
         *  as a child of another shell)
         */

        BufferSize = sizeof(Handle);
        Status = BS->LocateHandle(ByProtocol, &ShellEnvProtocol, NULL, &BufferSize, &Handle);
        ASSERT (!EFI_ERROR(Status));
        Status = BS->HandleProtocol(Handle, &ShellEnvProtocol, (VOID*)&SE);
        ASSERT (!EFI_ERROR(Status));

        /* 
         *  Allocate a new shell interface structure, and assign it to our
         *  image handle
         */

        SI = SE->NewShell(ImageHandle);
        Status = LibInstallProtocolInterfaces (&ImageHandle, &ShellInterfaceProtocol, SI, NULL);
        ASSERT (!EFI_ERROR(Status));
        IsRootInstance = TRUE;
        
    }

    /* 
     *  Now we can initialize like a normal shell app
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     *  If there are load options, assume they contain a command line and
     *  possible current working directory
     */

    if (ParseLoadOptions (ImageHandle, &CommandLine, &CurrentDir)) {
            
        /* 
         *  Skip the 1st argument which should be us.
         */
            
        while (*CommandLine != L' ' && *CommandLine != 0) {
            CommandLine++;
        }

        /* 
         *  Get to the beginning of the next argument.
         */

        while (*CommandLine == L' ') {
            CommandLine++;
        }

        /* 
         *  If there was a current working directory, set it.
         */

        if (CurrentDir) {
            CHAR16  CmdLine[256], *Tmp;

            /* 
             *  Set a mapping
             */
            StrCpy (CmdLine, CurrentDir);
            for (Tmp = CmdLine; *Tmp && *Tmp != L':'; Tmp++)
                ;
            if ( *Tmp ) {
                *(++Tmp) = 0;
                ShellExecute (ImageHandle, CmdLine, TRUE);
            }

            /* 
             *  Now change to that directory
             */
            StrCpy (CmdLine, L"cd ");
            if ((StrLen (CmdLine) + StrLen (CurrentDir) + sizeof(CHAR16)) <
                                    (sizeof(CmdLine) / sizeof(CHAR16))) {
                StrCat (CmdLine, CurrentDir);
                ShellExecute (ImageHandle, CmdLine, TRUE);
            }
        }

        /* 
         *  Have the shell execute the remaining command line.  If there is
         *  nothing remaining, run the shell main loop below.
         */

        if ( *CommandLine != 0 )
            return (ShellExecute (ImageHandle, CommandLine, TRUE));
    }

    /* 
     *  If this is the root instance, execute the command to load the default values
     */

    if (IsRootInstance) {

        Print (L"%EEFI Shell version %01d.%02d [%d.%d]\n%N",
            (ST->Hdr.Revision >> 16),
            (ST->Hdr.Revision & 0xffff),
            (ST->FirmwareRevision >> 16),
            (ST->FirmwareRevision & 0xffff));

        ShellExecute (ImageHandle, L"_load_defaults", TRUE);

        /*  dump device mappings, -r to sync with current hardware */
        ShellExecute (ImageHandle, L"map -r", TRUE);

        /*  run startup script (if any) */
        
        /* 
         *  BugBug: I turned on echo so you can tell the startup.nsh is running
         * 
         * ShellExecute (ImageHandle, L"echo -off", FALSE); */
        ShellExecute (ImageHandle, L"startup.nsh", FALSE);
        /* ShellExecute (ImageHandle, L"echo -on", FALSE); */
    }

    /* 
     *  EFI Shell main loop
     */

    Status = EFI_SUCCESS;
    while (Status != -1) {
        Status = NShellPrompt (ImageHandle);
    }

    /* 
     *  Done - cleanup the shell
     */

    Status = EFI_SUCCESS;
    Print (L"Shell exit - %r\n", Status);

    /* 
     *  If this was a root instance, we allocate a dumby shell interface for ourselves
     *  free it now
     */

    if (IsRootInstance) {
        BS->UninstallProtocolInterface (ImageHandle, &ShellInterfaceProtocol, SI);
        FreePool (SI);
    }

    return Status;
}


EFI_STATUS 
ShellLoadEnvDriverByPath (
    IN EFI_HANDLE           ParentImageHandle,
    IN EFI_HANDLE           DeviceHandle
    )
{
    EFI_STATUS              Status;
    EFI_DEVICE_PATH         *FilePath;
    EFI_HANDLE              NewImageHandle;
    UINTN                   Index;
    BOOLEAN                 SearchNext;

    /* 
     *  If there's no device to search forget it
     */

    if (!DeviceHandle) {
        return EFI_NOT_FOUND;
    }

    /* 
     *  Try loading shellenv from each path
     */
    
    SearchNext = TRUE;
    for (Index=0; ShellEnvPathName[Index]  &&  SearchNext; Index++) {

        /* 
         *  Load it
         */

        FilePath = FileDevicePath (DeviceHandle, ShellEnvPathName[Index]);
        ASSERT (FilePath);
        Status = BS->LoadImage(FALSE, ParentImageHandle, FilePath, NULL, 0, &NewImageHandle);
        FreePool (FilePath);

        /* 
         *  Only search the next path if it was not found on this path
         */

        SearchNext = FALSE;
        if (Status == EFI_LOAD_ERROR || Status == EFI_NOT_FOUND) {
            SearchNext = TRUE;
        }

        /* 
         *  If there was no error, start the image
         */

        if (!EFI_ERROR(Status)) {
            Status = BS->StartImage(NewImageHandle, NULL, 0);
        }
    }

    return Status;
}



EFI_STATUS
ShellLoadEnvDriver (
    IN EFI_HANDLE           ImageHandle
    )
{
    EFI_STATUS              Status;
    EFI_LOADED_IMAGE        *Image;
    UINTN                   Index, NoHandles;
    EFI_HANDLE              *Handles;

    /* 
     *  Get the file path for the current image
     */

    Status = BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID*)&Image);
    ASSERT (!EFI_ERROR(Status));

    /* 
     *  Attempt to load shellenv
     */

    Status = ShellLoadEnvDriverByPath (Image->ParentHandle, Image->DeviceHandle);
    if (EFI_ERROR(Status)) {

        /* 
         *  shellenv was not found.  Search all filesystems for it
         */

        Status = LibLocateHandle (ByProtocol, &FileSystemProtocol, NULL, &NoHandles, &Handles);

        for (Index=0; Index < NoHandles; Index++) {
            Status = ShellLoadEnvDriverByPath (Image->ParentHandle, Handles[Index]);
            if (!EFI_ERROR(Status)) {
                break;
            }
        }

        if (Handles) {
            FreePool (Handles);
        }
    }

    /* 
     *  Done
     */

    return Status;
}


EFI_STATUS
NShellPrompt (
    IN EFI_HANDLE           ImageHandle
    )
{
    CHAR16                  CmdLine[256];
    CHAR16                  *CurDir;
    UINTN                   BufferSize;
    EFI_STATUS              Status;

    /* 
     *  Prompt for input
     */

    CurDir = ShellCurDir(NULL);
    if (CurDir) {
        Print (L"%E%s> ", CurDir);
        FreePool (CurDir);
    } else {
        Print (L"%EShell> ");
    }

    /* 
     *  Read a line from the console
     */

    BufferSize = sizeof(CmdLine)-1;
    Status = SI->StdIn->Read (SI->StdIn, &BufferSize, CmdLine);

    /* 
     *  Null terminate the string and parse it
     */

    if (!EFI_ERROR(Status)) {
        CmdLine[BufferSize/sizeof(CHAR16)] = 0;
        Status = ShellExecute (ImageHandle, CmdLine, TRUE);
    }

    /* 
     *  Done with this command
     */

    return Status;

}

BOOLEAN
ParseLoadOptions(
    EFI_HANDLE  ImageHandle,
    OUT CHAR16  **CommandLine,
    OUT CHAR16  **CurrentDir
    )
{
    EFI_LOADED_IMAGE    *Image;
    EFI_STATUS          Status;

    /* 
     *  Set defaults.
     */
    *CommandLine = NULL;
    *CurrentDir = NULL;

    Status = BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID*)&Image);
    if (!EFI_ERROR(Status)) {

        CHAR16 *CmdLine = Image->LoadOptions;
        UINT32  CmdSize = Image->LoadOptionsSize & ~1; /*  make sure it is power of 2 */

        if (CmdLine && CmdSize) {

            /* 
             *  Set command line pointer for caller
             */

            *CommandLine = CmdLine;

            /* 
             *  See if current working directory was passed.
             */
            
            while ((*CmdLine != 0) && CmdSize) {
                CmdLine++;
                CmdSize -= sizeof(CHAR16);
            }

            /* 
             *  If a current working directory was passed, set it.
             */

            if (CmdSize > sizeof(CHAR16)) {
                *CurrentDir = ++CmdLine;
            }

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\doskey.h ===
/*/###########################################################################
//**
//**  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** from the company.
//**
//###########################################################################
 *
 * $Header: /ITP_E-DOS/INC/Sys/DOSKEY.H 1     8/28/97 11:56a Ajfish $
 * $NoKeywords: $
 */
#ifndef _DOSKEY_H
#define _DOSKEY_H

#define MAX_CMDLINE     80
#define MAX_HISTORY     16
#define MODE_INSERT     1
#define MODE_BUFFER     0

typedef struct DosKey {
    BOOLEAN     InsertMode;
    UINTN       Start;
    UINTN       End;
    UINTN       Current;


    CHAR16          Buffer[MAX_HISTORY][MAX_CMDLINE];
} DosKey_t;


DosKey_t *InitDosKey(DosKey_t *DosKey, UINTN HistorySize);
CHAR16 *DosKeyGetCommandLine(DosKey_t *Doskey);

#define CNTL_Z          26

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\cmddisp.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    cmddisp.c
    
Abstract:

    Shell Environment internal command management



Revision History

--*/

#include "shelle.h"


#define COMMAND_SIGNATURE       EFI_SIGNATURE_32('c','m','d','s')

typedef struct {
    UINTN                       Signature;
    LIST_ENTRY                  Link;
    SHELLENV_INTERNAL_COMMAND   Dispatch;
    CHAR16                      *Cmd;
    CHAR16                      *CmdFormat;
    CHAR16                      *CmdHelpLine;
    VOID                        *CmdVerboseHelp;
} COMMAND;

/* 
 *  Internal prototype
 */

EFI_STATUS
SEnvHelp (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

/* 
 * 
 */

struct {
    SHELLENV_INTERNAL_COMMAND   Dispatch;
    CHAR16                      *Cmd;
    CHAR16                      *CmdFormat;
    CHAR16                      *CmdHelpLine;
    VOID                        *CmdVerboseHelp;
} SEnvInternalCommands[] = {
    SEnvHelp,       L"?",       NULL,                              NULL,                           NULL,
    SEnvLoadDefaults, L"_load_defaults", NULL,                     NULL,                           NULL,
    SEnvHelp,       L"help",    L"help [-b] [internal command]",   L"Displays this help",          NULL,
    SEnvCmdProt,    L"guid",    L"guid [-b] [sname]",              L"Dump known guid ids",         NULL,
    SEnvCmdSet,     L"set",     L"set [-bdv] [sname] [value]",     L"Set/get environment variable", NULL,
    SEnvCmdAlias,   L"alias",   L"alias [-bdv] [sname] [value]" ,  L"Set/get alias settings",      NULL,
    SEnvCmdDH,      L"dh",      L"dh [-b] [-p prot_id] | [handle]",L"Dump handle info",            NULL,
    SEnvCmdMap,     L"map",     L"map [-bdvr] [sname[:]] [handle]",L"Map shortname to device path", NULL,
    SEnvCmdMount,   L"mount",   L"mount BlkDevice [sname[:]]",     L"Mount a filesytem on a block device", NULL,
    SEnvCmdCd,      L"cd",      L"cd [path]",                      L"Updates the current directory",NULL,
    SEnvCmdEcho,    L"echo",    L"echo [[-on | -off] | [text]",    L"Echo text to stdout or toggle script echo",NULL,
    SEnvCmdIf,      L"if",      L"if [not] condition then",        L"Script-only: IF THEN construct",NULL,
    SEnvCmdEndif,   L"endif",   L"endif",                          L"Script-only: Delimiter for IF THEN construct",NULL,
    SEnvCmdGoto,    L"goto",    L"goto label",                     L"Script-only: Jump to label location in script",NULL,
    SEnvCmdFor,     L"for",     L"for var in <set>",               L"Script-only: Loop construct",                           NULL,
    SEnvCmdEndfor,  L"endfor",  L"endfor",                         L"Script-only: Delimiter for loop construct",                           NULL,
    SEnvCmdPause,   L"pause",   L"pause",                          L"Script-only: Prompt to quit or continue",                           NULL,
    SEnvExit,       L"exit",    NULL,                              NULL,                           NULL,
    NULL
} ;

/* 
 *  SEnvCmds - a list of all internal commands
 */

LIST_ENTRY  SEnvCmds;

/* 
 * 
 */

VOID
SEnvInitCommandTable (
    VOID
    )
{
    UINTN           Index;

    /* 
     *  Add all of our internal commands to the command dispatch table
     */

    InitializeListHead (&SEnvCmds);
    for (Index=0; SEnvInternalCommands[Index].Dispatch; Index += 1) {
        SEnvAddCommand (
            SEnvInternalCommands[Index].Dispatch,
            SEnvInternalCommands[Index].Cmd,
            SEnvInternalCommands[Index].CmdFormat,
            SEnvInternalCommands[Index].CmdHelpLine,
            SEnvInternalCommands[Index].CmdVerboseHelp
            );
    }
}



EFI_STATUS
SEnvAddCommand (
    IN SHELLENV_INTERNAL_COMMAND    Handler,
    IN CHAR16                       *CmdStr,
    IN CHAR16                       *CmdFormat,
    IN CHAR16                       *CmdHelpLine,
    IN CHAR16                       *CmdVerboseHelp
    )
{
    COMMAND         *Cmd;

    Cmd = AllocateZeroPool (sizeof(COMMAND));

    if (Cmd) {
        AcquireLock (&SEnvLock);

        Cmd->Signature = COMMAND_SIGNATURE;
        Cmd->Dispatch = Handler;
        Cmd->Cmd = CmdStr;
        Cmd->CmdFormat = CmdFormat;
        Cmd->CmdHelpLine = CmdHelpLine;
        Cmd->CmdVerboseHelp = CmdVerboseHelp;

        InsertTailList (&SEnvCmds, &Cmd->Link);
        ReleaseLock (&SEnvLock);
    }

    return Cmd ? EFI_SUCCESS : EFI_OUT_OF_RESOURCES;
}


SHELLENV_INTERNAL_COMMAND  
SEnvGetCmdDispath(
    IN CHAR16                   *CmdName
    )
{
    LIST_ENTRY                  *Link;
    COMMAND                     *Command;
    SHELLENV_INTERNAL_COMMAND   Dispatch;

    Dispatch = NULL;
    AcquireLock (&SEnvLock);

    for (Link=SEnvCmds.Flink; Link != &SEnvCmds; Link = Link->Flink) {
        Command = CR(Link, COMMAND, Link, COMMAND_SIGNATURE);
        if (StriCmp (Command->Cmd, CmdName) == 0) {
            Dispatch = Command->Dispatch;
            break;
        }
    }

    ReleaseLock (&SEnvLock);
    return Dispatch;
}


EFI_STATUS
SEnvHelp (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
{
    LIST_ENTRY                  *Link;
    COMMAND                     *Command;
    UINTN                       SynLen, Len;
    UINTN                       Index;
    CHAR16                      *p;
    BOOLEAN                     PageBreaks;
    UINTN                       TempColumn;
    UINTN                       ScreenCount;
    UINTN                       ScreenSize;
    CHAR16                      ReturnStr[1];

    /* 
     *  Intialize application
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    PageBreaks = FALSE;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == '-') {
            switch (p[1]) {
            case 'b' :
            case 'B' :
                PageBreaks = TRUE;
                ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                ScreenCount = 0;
                break;
            default:
                Print (L"%EDH: Unkown flag %s\n", p);
                return EFI_INVALID_PARAMETER;
            }
        }
    }

    AcquireLock (&SEnvLock);

    SynLen = 0;
    for (Link=SEnvCmds.Flink; Link != &SEnvCmds; Link = Link->Flink) {
        Command = CR(Link, COMMAND, Link, COMMAND_SIGNATURE);
        if (Command->CmdFormat && Command->CmdHelpLine) {
            Len = StrLen(Command->CmdFormat);
            if (Len > SynLen) {
                SynLen = Len;
            }
        }
    }

    for (Link=SEnvCmds.Flink; Link != &SEnvCmds; Link = Link->Flink) {
        Command = CR(Link, COMMAND, Link, COMMAND_SIGNATURE);
        if (Command->CmdFormat && Command->CmdHelpLine) {
            Print (L"%-.*hs - %s\n", SynLen, Command->CmdFormat, Command->CmdHelpLine);

            if (PageBreaks) {
                ScreenCount++;
                if (ScreenCount > ScreenSize - 4) {
                    ScreenCount = 0;
                    Print (L"\nPress Return to contiue :");
                    Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                    Print (L"\n\n");
                }
            }
        }
    }

    ReleaseLock (&SEnvLock);
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\conio.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    conio.c
    
Abstract:

    Shell Environment driver



Revision History

--*/

#include "shelle.h"

/* 
 * 
 */

#define MAX_HISTORY     20

#define INPUT_LINE_SIGNATURE     EFI_SIGNATURE_32('i','s','i','g')

typedef struct {
    UINTN           Signature;
    LIST_ENTRY      Link;
    CHAR16          Buffer[MAX_CMDLINE];
} INPUT_LINE;


/* 
 *  Globals
 */


static BOOLEAN      SEnvInsertMode;
static LIST_ENTRY   SEnvLineHistory;
static UINTN        SEnvNoHistory;


/* 
 * 
 */

VOID
SEnvConIoInitDosKey (
    VOID
    )
{
    InitializeListHead (&SEnvLineHistory);
    SEnvInsertMode = FALSE;
    SEnvNoHistory = 0;
}


/* 
 *  Functions used to access the console interface via a file handle
 *  Used if the console is not being redirected to a file
 */

EFI_STATUS
SEnvConIoOpen (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT struct _EFI_FILE_HANDLE **NewHandle,
    IN CHAR16                   *FileName,
    IN UINT64                   OpenMode,
    IN UINT64                   Attributes
    )
{
    return EFI_NOT_FOUND;
}

EFI_STATUS
SEnvConIoNop (
    IN struct _EFI_FILE_HANDLE  *File
    )
{
    return EFI_SUCCESS;
}

EFI_STATUS
SEnvConIoGetPosition (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  *Position
    )
{
    return EFI_UNSUPPORTED;
}

EFI_STATUS
SEnvConIoSetPosition (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  Position
    )
{
    return EFI_UNSUPPORTED;
}

EFI_STATUS
SEnvConIoGetInfo (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    )
{
    return EFI_UNSUPPORTED;
}

EFI_STATUS
SEnvConIoSetInfo (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN UINTN                    BufferSize,
    OUT VOID                    *Buffer
    )
{
    return EFI_UNSUPPORTED;
}


EFI_STATUS
SEnvConIoWrite (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    )
{
    Print (L"%.*s", *BufferSize, Buffer);
    return EFI_SUCCESS;
}

EFI_STATUS
SEnvErrIoWrite (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    )
{
    IPrint (ST->StdErr, L"%.*s", *BufferSize, Buffer);
    return EFI_SUCCESS;
}

EFI_STATUS
SEnvErrIoRead (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    )
{
    return EFI_UNSUPPORTED;
}


VOID
SEnvPrintHistory(
    VOID
    )
{
    LIST_ENTRY      *Link;
    INPUT_LINE      *Line;
    UINTN           Index;

    Print (L"\n");
    Index = 0;
    for (Link=SEnvLineHistory.Flink; Link != &SEnvLineHistory; Link=Link->Flink) {
        Index += 1;
        Line = CR(Link, INPUT_LINE, Link, INPUT_LINE_SIGNATURE);
        Print (L"%2d. %s\n", Index, Line->Buffer);
    }
}


EFI_STATUS
SEnvConIoRead (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    )
{
    CHAR16                          *Str;
    BOOLEAN                         Done;
    UINTN                           Column, Row;
    UINTN                           Update, Delete;
    UINTN                           Len, StrPos, MaxStr;
    UINTN                           Index;
    EFI_INPUT_KEY                   Key;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
    SIMPLE_INPUT_INTERFACE          *ConIn;
    INPUT_LINE                      *NewLine, *LineCmd;
    LIST_ENTRY                      *LinePos, *NewPos;

    ConOut = ST->ConOut;
    ConIn = ST->ConIn;
    Str = Buffer;

    if (*BufferSize < sizeof(CHAR16)*2) {
        *BufferSize = 0;
        return EFI_SUCCESS;
    }

    /* 
     *  Get input fields location
     */

    Column = ConOut->Mode->CursorColumn;
    Row = ConOut->Mode->CursorRow;
    ConOut->QueryMode (ConOut, ConOut->Mode->Mode, &MaxStr, &Index);

    /*  bugbug: for now wrapping is not handled */
    MaxStr = MaxStr - Column;

    /*  Clip to max cmdline */
    if (MaxStr > MAX_CMDLINE) {
        MaxStr = MAX_CMDLINE;
    }

    /*  Clip to user's buffer size */
    if (MaxStr > (*BufferSize / sizeof(CHAR16)) - 1) {
        MaxStr = (*BufferSize / sizeof(CHAR16)) - 1;
    }

    /* 
     *  Allocate a new key entry
     */

    NewLine = AllocateZeroPool (sizeof(INPUT_LINE));
    if (!NewLine) {
        return EFI_OUT_OF_RESOURCES;
    }

    NewLine->Signature = INPUT_LINE_SIGNATURE;
    LinePos = &SEnvLineHistory;

    /* 
     *  Set new input
     */

    Update = 0;
    Delete = 0;
    NewPos = &SEnvLineHistory;
    ZeroMem (Str, MaxStr * sizeof(CHAR16));

    Done = FALSE;
    do {
        /* 
         *  If we have a new position, reset
         */

        if (NewPos != &SEnvLineHistory) {
            LineCmd = CR(NewPos, INPUT_LINE, Link, INPUT_LINE_SIGNATURE);
            LinePos = NewPos;
            NewPos  = &SEnvLineHistory;

            CopyMem (Str, LineCmd->Buffer, MaxStr * sizeof(CHAR16));
            Index = Len;                /*  Save old len */
            Len = StrLen(Str);          /*  Get new len */
            StrPos = Len;
            Update = 0;                 /*  draw new input string */
            if (Index > Len) {
                Delete = Index - Len;   /*  if old string was longer, blank it */
            }
        }

        /* 
         *  If we need to update the output do so now
         */

        if (Update != -1) {
            PrintAt (Column+Update, Row, L"%s%.*s", Str + Update, Delete, L"");
            Len = StrLen (Str);

            if (Delete) {
                SetMem(Str+Len, Delete * sizeof(CHAR16), 0x00);
            }

            if (StrPos > Len) {
                StrPos = Len;
            }

            Update = -1;
            Delete = 0;
        }

        /* 
         *  Set the cursor position for this key
         */

        ConOut->SetCursorPosition (ConOut, Column+StrPos, Row);

        /* 
         *  Read the key
         */

        WaitForSingleEvent(ConIn->WaitForKey, 0);
        ConIn->ReadKeyStroke(ConIn, &Key);

        switch (Key.UnicodeChar) {
        case CHAR_CARRIAGE_RETURN:
            /* 
             *  All done, print a newline at the end of the string
             */

            PrintAt (Column+Len, Row, L"\n");
            Done = TRUE;
            break;

        case CHAR_BACKSPACE:
            if (StrPos) {
                StrPos -= 1;
                Update = StrPos;
                Delete = 1;
                CopyMem (Str+StrPos, Str+StrPos+1, sizeof(CHAR16) * (Len-StrPos));
            }
            break;

        default:
            if (Key.UnicodeChar >= ' ') {
                /*  If we are at the buffer's end, drop the key */
                if (Len == MaxStr-1 && 
                    (SEnvInsertMode || StrPos == Len)) {
                    break;
                }

                if (SEnvInsertMode) {
                    for (Index=Len; Index > StrPos; Index -= 1) {
                        Str[Index] = Str[Index-1];
                    }
                }

                Str[StrPos] = Key.UnicodeChar;
                Update = StrPos;
                StrPos += 1;
            }
            break;

        case 0:
            switch (Key.ScanCode) {
            case SCAN_DELETE:
                if (Len) {
                    Update = StrPos;
                    Delete = 1;
                    CopyMem (Str+StrPos, Str+StrPos+1, sizeof(CHAR16) * (Len-StrPos));
                }
                break;

            case SCAN_UP:
                NewPos = LinePos->Blink;
                if (NewPos == &SEnvLineHistory) {
                    NewPos = NewPos->Blink;
                }
                break;

            case SCAN_DOWN:
                NewPos = LinePos->Flink;
                if (NewPos == &SEnvLineHistory) {
                    NewPos = NewPos->Flink;
                }
                break;

            case SCAN_LEFT:
                if (StrPos) {
                    StrPos -= 1;
                }
                break;

            case SCAN_RIGHT:
                if (StrPos < Len) {
                    StrPos += 1;
                }
                break;

            case SCAN_HOME:
                StrPos = 0;
                break;

            case SCAN_END:
                StrPos = Len;
                break;

            case SCAN_ESC:
                Str[0] = 0;
                Update = 0;
                Delete = Len;
                break;

            case SCAN_INSERT:
                SEnvInsertMode = !SEnvInsertMode;
                break;

            case SCAN_F7:
                SEnvPrintHistory();
                *Str = 0;
                Done = TRUE;    
                break;
            }       
        }
    } while (!Done);

    /* 
     *  Copy the line to the history buffer
     */

    StrCpy (NewLine->Buffer, Str);
    if (Str[0]) {
        InsertTailList (&SEnvLineHistory, &NewLine->Link);
        SEnvNoHistory += 1;
    } else {
        FreePool (NewLine);
    }

    /* 
     *  If there's too much in the history buffer free an entry
     */

    if (SEnvNoHistory > MAX_HISTORY) {
        LineCmd = CR(SEnvLineHistory.Flink, INPUT_LINE, Link, INPUT_LINE_SIGNATURE);
        RemoveEntryList (&LineCmd->Link);
        SEnvNoHistory -= 1;
        FreePool (LineCmd);
    }

    /* 
     *  Return the data to the caller
     */

    *BufferSize = Len * sizeof(CHAR16);
    StrCpy(Buffer, Str);
    return EFI_SUCCESS;
}

/* 
 * 
 */


EFI_STATUS
SEnvReset (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                          ExtendedVerification
    )
{ 
    return EFI_SUCCESS;
}

EFI_STATUS
SEnvOutputString (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    )
{
    EFI_STATUS              Status;         
    ENV_SHELL_REDIR_FILE    *Redir;
    UINTN                   Len, Size, WriteSize, Index, Start;
    CHAR8                   Buffer[100];
    CHAR16                  UnicodeBuffer[100];
    BOOLEAN                 InvalidChar;
    SIMPLE_INPUT_INTERFACE        *TextIn           = NULL;
    SIMPLE_TEXT_OUTPUT_INTERFACE  *TextOut          = NULL;

    Redir = CR(This, ENV_SHELL_REDIR_FILE, Out, ENV_REDIR_SIGNATURE);
    if (EFI_ERROR(Redir->WriteError)) {
        return(Redir->WriteError);
    }
    Status = EFI_SUCCESS;
    InvalidChar = FALSE;

    if (Redir->Ascii) {

        Start = 0;
        Len   = StrLen (String);
        while (Len) {
            Size = Len > sizeof(Buffer) ? sizeof(Buffer) : Len;
            for (Index=0; Index < Size; Index +=1) {
                if (String[Start+Index] > 0xff) {
                    Buffer[Index] = '_';
                    InvalidChar = TRUE;
                } else {
                    Buffer[Index] = (CHAR8) String[Start+Index];
                }  
            }

            WriteSize = Size;
            Status = Redir->File->Write (Redir->File, &WriteSize, Buffer);
            if (EFI_ERROR(Status)) {
                break;
            }

            Len   -= Size;
            Start += Size;
        }


    } else {

        Len = StrSize (String) - sizeof(CHAR16);
        Status = Redir->File->Write (Redir->File, &Len, String);
    }

    if (EFI_ERROR(Status)) {
        Redir->WriteError = Status;
        SEnvBatchGetConsole( &TextIn, &TextOut );
        SPrint(UnicodeBuffer,100,L"write error: %r\n\r",Status);
        Status = TextOut->OutputString( TextOut, UnicodeBuffer);
    }

    if (InvalidChar && !EFI_ERROR(Status)) {
        Status = EFI_WARN_UNKOWN_GLYPH;
    }

    return Status;
}



EFI_STATUS
SEnvTestString (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    )
{
    EFI_STATUS              Status;         
    ENV_SHELL_REDIR_FILE    *Redir;

    Redir = CR(This, ENV_SHELL_REDIR_FILE, Out, ENV_REDIR_SIGNATURE);
    Status = ST->ConOut->TestString(ST->ConOut, String);

    if (!EFI_ERROR(Status) && Redir->Ascii) {
        while (*String && *String < 0x100) {
            String += 1;
        }

        if (*String > 0xff) {
            Status = EFI_UNSUPPORTED;
        }
    }

    return Status;
}


EFI_STATUS 
SEnvQueryMode (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber,
    OUT UINTN                       *Columns,
    OUT UINTN                       *Rows
    )
{
    if (ModeNumber > 0) {
        return EFI_INVALID_PARAMETER;
    }

    *Columns = 0;
    *Rows = 0;
    return EFI_SUCCESS;
}


EFI_STATUS
SEnvSetMode (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber
    )
{
    return ModeNumber > 0 ? EFI_INVALID_PARAMETER : EFI_SUCCESS;
}

EFI_STATUS
SEnvSetAttribute (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                            Attribute
    )
{
    This->Mode->Attribute = (UINT32) Attribute;
    return EFI_SUCCESS;
}

EFI_STATUS
SEnvClearScreen (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This
    )
{
    return EFI_SUCCESS;
}


EFI_STATUS
SEnvSetCursorPosition (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Column,
    IN UINTN                        Row
    )
{
    return EFI_UNSUPPORTED;
}

EFI_STATUS
SEnvEnableCursor (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      Enable
    )
{
    This->Mode->CursorVisible = Enable;
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\batch.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    batch.c
    
Abstract:

    Functions implementing batch scripting in the shell.

Revision History

--*/

#include "shelle.h"

/* 
 *   Constants
 */

#define ASCII_LF                 ((CHAR8)0x0a)
#define ASCII_CR                 ((CHAR8)0x0d)
#define UNICODE_LF               ((CHAR16)0x000a)
#define UNICODE_CR               ((CHAR16)0x000d)

/*  Can hold 64-bit hex error numbers + null char */
#define LASTERROR_BUFSIZ         (17)

/* 
 *   Statics
 *     (needed to maintain state across multiple calls or for callbacks)
 */
STATIC UINTN                         NestLevel;
STATIC UINTN                         LastError;
STATIC CHAR16                        LastErrorBuf[LASTERROR_BUFSIZ];
STATIC BOOLEAN                       Condition;
STATIC BOOLEAN                       GotoIsActive;
STATIC UINT64                        GotoFilePos;
STATIC BOOLEAN                       BatchIsActive;
STATIC BOOLEAN                       EchoIsOn;
STATIC BOOLEAN                       BatchAbort;
STATIC SIMPLE_INPUT_INTERFACE        *OrigConIn;
STATIC SIMPLE_TEXT_OUTPUT_INTERFACE  *OrigConOut;
STATIC EFI_FILE_HANDLE               CurrentBatchFile;

/* 
 *   Definitions for the argument list stack
 * 
 *   In order to support nested scripts (script calling script calling script...)
 *   there is an argument list stack "BatchInfoStack".  BatchInfoStack is a
 *   list of argument lists.  Each argument list contains Argv[0] - Argv[n] 
 *   for the corresponding script file.  The head of BatchInfoStack corresponds
 *   to the currently active script file.  
 * 
 *   This allows positional argument substitution to be done when each line 
 *   is read and scanned, and calls to other script files can overwrite the 
 *   shell interface's argument list.
 */

#define EFI_BATCH_INFO_SIGNATURE EFI_SIGNATURE_32('b','i','r','g')
typedef struct {
    UINTN       Signature;
    LIST_ENTRY  Link;
    CHAR16      *ArgValue;
} EFI_SHELL_BATCH_INFO;

#define EFI_BATCH_INFOLIST_SIGNATURE EFI_SIGNATURE_32('b','l','s','t')
typedef struct {
    UINTN       Signature;
    LIST_ENTRY  Link;          
    LIST_ENTRY  ArgListHead;    /*   Head of this argument list */
    UINT64      FilePosition;   /*   Current file position */
} EFI_SHELL_BATCH_INFOLIST;

STATIC LIST_ENTRY            BatchInfoStack;


/* 
 *   Prototypes
 */

STATIC EFI_STATUS
BatchIsAscii(
    IN EFI_FILE_HANDLE  File, 
    OUT BOOLEAN         *IsAscii
    );

STATIC EFI_STATUS
BatchGetLine(
    IN EFI_FILE_HANDLE        File, 
    IN BOOLEAN                Ascii,
    IN OUT UINT64             *FilePosition,
    IN OUT UINTN              *BufSize,
    OUT CHAR16                *CommandLine
    );


VOID
SEnvInitBatch(
    VOID 
    )
/*++
    Function Name:  
        SEnvInitBatch

    Description:
        Initializes global variables used for batch file processing.
--*/
{
    NestLevel         = 0;
    LastError         = EFI_SUCCESS;
    ZeroMem( LastErrorBuf, LASTERROR_BUFSIZ );
    Condition         = TRUE;
    GotoIsActive      = FALSE;
    GotoFilePos       = (UINT64)0x00;
    BatchIsActive     = FALSE;
    EchoIsOn          = TRUE;
    BatchAbort        = FALSE;
    OrigConIn         = ST->ConIn;
    OrigConOut        = ST->ConOut;
    InitializeListHead( &BatchInfoStack );
    SEnvInitForLoopInfo();
}


BOOLEAN
SEnvBatchIsActive( 
    VOID
    )
/*++
    Function Name:  
        SEnvBatchIsActive

    Description:
        Returns whether any batch files are currently being processed.
--*/
{
    /* 
     *   BUGBUG should be able to return IsListEmpty( &BatchInfoStack ); 
     *   instead of using this variable 
     */
    return BatchIsActive;
}


VOID
SEnvSetBatchAbort( 
    VOID
    )
/*++
    Function Name:  
        SEnvSetBatchAbort

    Description:
        Sets a flag to notify the main batch processing loop to exit.
--*/
{
    BatchAbort = TRUE;
    return;
}


VOID
SEnvBatchGetConsole( 
    OUT SIMPLE_INPUT_INTERFACE       **ConIn,
    OUT SIMPLE_TEXT_OUTPUT_INTERFACE **ConOut
    )
/*++
    Function Name:  
        SEnvBatchGetConsole

    Description:
        Returns the Console I/O interface pointers.
--*/
{
    *ConIn = OrigConIn;
    *ConOut = OrigConOut;
    return;
}


EFI_STATUS
SEnvBatchEchoCommand( 
    IN ENV_SHELL_INTERFACE  *Shell
    )
/*++
    Function Name:  
        SEnvBatchEchoCommand

    Description:
        Echoes the given command to stdout.
--*/
{
    UINTN       i;
    CHAR16      *BatchFileName;
    EFI_STATUS  Status;

     /* 
     *   Echo the parsed-and-expanded command to the console
     */

    if ( SEnvBatchIsActive() && EchoIsOn ) {

        BatchFileName = NULL;
        Status = SEnvBatchGetArg( 0, &BatchFileName );
        if ( EFI_ERROR(Status) ) {
            goto Done;
        }

        Print( L"%E" );
        for ( i=0; i<NestLevel; i++ ) {
            Print( L"+" );
        }
        Print( L"%s> ", BatchFileName );
        for ( i=0; i<Shell->ShellInt.Argc; i++ ) {
            Print( L"%s ", Shell->ShellInt.Argv[i] );
        }
        for ( i=0; i<Shell->ShellInt.RedirArgc; i++ ) {
            Print( L"%s ", Shell->ShellInt.RedirArgv[i] );
        }
        Print( L"\n" );
    }

Done:

    /* 
     *  Switch output attribute to normal
     */

    Print (L"%N");

    return Status;
}


VOID
SEnvBatchSetEcho( 
    IN BOOLEAN Val
    )
/*++
    Function Name:  
        SEnvBatchSetEcho

    Description:
        Sets the echo flag to the specified value.
--*/
{
    EchoIsOn = Val;
    return;
}


BOOLEAN
SEnvBatchGetEcho( 
    VOID
    )
/*++
    Function Name:  
        SEnvBatchGetEcho

    Description:
        Returns the echo flag.
--*/
{
    return EchoIsOn;
}


EFI_STATUS
SEnvBatchSetFilePos( 
    IN UINT64 NewPos
    )
/*++
    Function Name:  
        SEnvBatchSetFilePos

    Description:
        Sets the current script file position to the specified value.
--*/
{
    EFI_STATUS                  Status      = EFI_SUCCESS;
    EFI_SHELL_BATCH_INFOLIST    *BatchInfo  = NULL;

    Status = CurrentBatchFile->SetPosition( CurrentBatchFile, NewPos );
    if ( EFI_ERROR(Status) ) {
        goto Done;
    }
    if ( !IsListEmpty( &BatchInfoStack ) ) {
        BatchInfo = CR( BatchInfoStack.Flink, 
                        EFI_SHELL_BATCH_INFOLIST, 
                        Link, 
                        EFI_BATCH_INFOLIST_SIGNATURE );
    }
    if ( BatchInfo ) {
        BatchInfo->FilePosition = NewPos;
    } else {
        Status = EFI_NOT_FOUND;
        goto Done;
    }

Done:
    return Status;
}


EFI_STATUS
SEnvBatchGetFilePos( 
    UINT64  *FilePos
    )
/*++
    Function Name:  
        SEnvBatchGetFilePos

    Description:
        Returns the current script file position.
--*/
{
    EFI_SHELL_BATCH_INFOLIST    *BatchInfo    = NULL;
    EFI_STATUS                  Status      = EFI_SUCCESS;

    if ( !FilePos ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }
    if ( !IsListEmpty( &BatchInfoStack ) ) {
        BatchInfo = CR( BatchInfoStack.Flink, 
                        EFI_SHELL_BATCH_INFOLIST, 
                        Link, 
                        EFI_BATCH_INFOLIST_SIGNATURE );
    }
    if ( BatchInfo ) {
        *FilePos = BatchInfo->FilePosition;
    } else {
        Status = EFI_NOT_FOUND;
        goto Done;
    }

Done:
    return Status;
}


VOID
SEnvBatchSetCondition( 
    IN BOOLEAN Val
    )
/*++
    Function Name:  
        SEnvBatchSetCondition

    Description:
        Sets the condition flag to the specified value.
--*/
{
    Condition = Val;
    return;
}


VOID
SEnvBatchSetGotoActive( 
    VOID
    )
/*++
    Function Name:  
        SEnvBatchSetGotoActive

    Description:
        Sets the goto-is-active to TRUE and saves the current position
        of the active script file.
--*/
{
    GotoIsActive = TRUE;
    SEnvBatchGetFilePos( &GotoFilePos );
    return;
}


BOOLEAN
SEnvBatchVarIsLastError( 
    IN CHAR16 *Name
    )
/*++
    Function Name:  
        SEnvBatchVarIsLastError

    Description:
        Checks to see if variable's name is "lasterror".
--*/
{
    return (StriCmp( L"lasterror", Name ) == 0);
}


VOID
SEnvBatchSetLastError(
    IN UINTN NewLastError
    )
/*++
    Function Name:  
        SEnvBatchSetLastError

    Description:
        Sets the lasterror variable's value to the given value.
--*/
{
    LastError = NewLastError;
    return;
}


CHAR16*
SEnvBatchGetLastError( VOID 
               )
/*++
    Function Name:  
        SEnvBatchGetLastError

    Description:
        Returns a pointer to a string representation of the error value 
        returned by the last shell command.
--*/
{
    ValueToHex( LastErrorBuf, (UINT64)LastError );
    return LastErrorBuf;
}


STATIC EFI_STATUS
BatchIsAscii(
    IN EFI_FILE_HANDLE  File, 
    OUT BOOLEAN         *IsAscii
    )
/*++
    Function Name:  
        BatchIsAscii

    Description:
        Checks to see if the specified batch file is ASCII.
--*/
{
    EFI_STATUS Status=EFI_SUCCESS;
    CHAR8      Buffer8[2];  /*   UNICODE byte-order-mark is two bytes */
    UINTN      BufSize;

    /* 
     *   Read the first two bytes to check for byte order mark
     */

    BufSize = sizeof(Buffer8);
    Status = File->Read( File, &BufSize, Buffer8 );
    if ( EFI_ERROR(Status) ) {
        goto Done;
    }

    Status = File->SetPosition( File, (UINT64)0 );
    if ( EFI_ERROR(Status) ) {
        goto Done;
    }

    /* 
     *   If we find a UNICODE byte order mark assume it is UNICODE,
     *   otherwise assume it is ASCII.  UNICODE byte order mark on
     *   IA little endian is first byte 0xff and second byte 0xfe
     */

    if ( (Buffer8[0] | (Buffer8[1] << 8)) == UNICODE_BYTE_ORDER_MARK ) {
        *IsAscii = FALSE;
    } else {
        *IsAscii = TRUE;
    }

Done:
    return Status;
}


STATIC EFI_STATUS
BatchGetLine(
    IN EFI_FILE_HANDLE   File, 
    IN BOOLEAN           Ascii,
    IN OUT UINT64        *FilePosition,
    IN OUT UINTN         *BufSize,
    OUT CHAR16           *CommandLine
    )
/*++
    Function Name:  
        BatchGetLine

    Description:
        Reads the next line from the batch file, converting it from
        ASCII to UNICODE if necessary.  If end of file is encountered
        then it returns 0 in the BufSize parameter.
--*/
{
    EFI_STATUS Status;
    CHAR8      Buffer8[MAX_CMDLINE];
    CHAR16     Buffer16[MAX_CMDLINE];
    UINTN      i             = 0;
    UINTN      CmdLenInChars = 0;
    UINTN      CmdLenInBytes = 0;
    UINTN      CharSize      = 0;

    /* 
     *   Check params
     */

    if ( !CommandLine || !BufSize || !FilePosition ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *   Initialize OUT param
     */
    ZeroMem( CommandLine, MAX_CMDLINE );

    /* 
     *  If beginning of UNICODE file, move past the Byte-Order-Mark (2 bytes)
     */

    if ( !Ascii && *FilePosition == (UINT64)0 ) {
        *FilePosition = (UINT64)2;
        Status = File->SetPosition( File, *FilePosition );
        if ( EFI_ERROR(Status) ) {
            goto Done;
        }
    }

    /* 
     *  (1) Read a buffer-full from the file
     *  (2) Locate the end of the 1st line in the buffer
     *  ASCII version and UNICODE version
     */

    if ( Ascii ) {

        CharSize = sizeof(CHAR8);
        Status = File->Read( File, BufSize, Buffer8 );
        if ( EFI_ERROR(Status) || *BufSize == 0 ) {
            goto Done;
        }

        for ( i=0; i<*BufSize; i++ ) {
            if ( Buffer8[i] == ASCII_LF ) {
                CmdLenInChars = i;
                CmdLenInBytes = CmdLenInChars;
                break;
            }
        }
    } else {  /*  UNICODE */

        CharSize = sizeof(CHAR16);
        Status = File->Read( File, BufSize, Buffer16 );
        if ( EFI_ERROR(Status) || *BufSize == 0  ) {
            goto Done;
        }

        for ( i=0; i < *BufSize/CharSize; i++ ) {
            if ( Buffer16[i] == UNICODE_LF ) {
                CmdLenInChars = i;
                CmdLenInBytes = CmdLenInChars * CharSize;
                break;
            }
         }
    }

    /* 
     *   Reset the file position to just after the command line
     */
    *FilePosition += (UINT64)(CmdLenInBytes + CharSize);
    Status = File->SetPosition( File, *FilePosition );

    /* 
     *   Copy, converting chars to UNICODE if necessary
     */
    if ( Ascii ) {
        for ( i=0; i<CmdLenInChars; i++ ) {
            CommandLine[i] = (CHAR16)Buffer8[i];
        }
    } else {
        CopyMem( CommandLine, Buffer16, CmdLenInBytes );
    }
    CmdLenInChars = i;

Done:
    *BufSize = CmdLenInChars * CharSize;
    return Status;
}


EFI_STATUS
SEnvBatchGetArg(
    IN  UINTN  Argno,
    OUT CHAR16 **Argval
    )
/*++
    Function Name:  
        BatchGetArg

    Description:
        Extract the specified element from the arglist at the top of the arglist
        stack.  Return a pointer to the value field of the "Argno"th element of 
        the list.
--*/
{
    EFI_SHELL_BATCH_INFOLIST *BatchInfo = NULL;
    LIST_ENTRY               *Link      = NULL;
    EFI_SHELL_BATCH_INFO     *ArgEntry  = NULL;
    UINTN                    i          = 0;

    if ( !IsListEmpty( &BatchInfoStack ) ) {
        BatchInfo = CR( BatchInfoStack.Flink, 
                        EFI_SHELL_BATCH_INFOLIST, 
                        Link, 
                        EFI_BATCH_INFOLIST_SIGNATURE );
    }
    if ( !IsListEmpty( &BatchInfo->ArgListHead ) ) {
        for ( Link=BatchInfo->ArgListHead.Flink; 
              Link!=&BatchInfo->ArgListHead; 
              Link=Link->Flink) {
            ArgEntry = CR( Link, 
                           EFI_SHELL_BATCH_INFO, 
                           Link, 
                           EFI_BATCH_INFO_SIGNATURE);
            if ( i++ == Argno ) {
                *Argval = ArgEntry->ArgValue;
                return EFI_SUCCESS;
            }
        }
    }
    *Argval = NULL;
    return EFI_NOT_FOUND;
}


EFI_STATUS
SEnvExecuteScript(
    IN ENV_SHELL_INTERFACE      *Shell,
    IN EFI_FILE_HANDLE          File
    )
/*++

    Function Name:  
        SEnvExecuteScript

    Description:
        Execute the commands in the script file specified by the 
        file parameter.

    Arguments:
        Shell:  shell interface of the caller
        File:   file handle to open script file

    Returns:
        EFI_STATUS

--*/
{
    EFI_FILE_INFO               *FileInfo;
    UINTN                       FileNameLen   = 0;
    BOOLEAN                     EndOfFile     = FALSE;
    EFI_STATUS                  Status        = EFI_SUCCESS;
    UINTN                       BufSize       = 0;
    UINTN                       FileInfoSize  = 0;
    CHAR16                      CommandLine[MAX_CMDLINE];
    EFI_SHELL_BATCH_INFOLIST    *BatchInfo    = NULL;
    EFI_SHELL_BATCH_INFO        *ArgEntry     = NULL;
    UINTN                       i             = 0;
    BOOLEAN                     Output        = TRUE;
    ENV_SHELL_INTERFACE         NewShell;
    UINTN                       GotoTargetStatus;
    UINTN                       SkippedIfCount;

    /* 
     *   Initialize
     */
    BatchIsActive = TRUE;
    Status = EFI_SUCCESS;
    NestLevel++;
    SEnvInitTargetLabel();

    /* 
     *   Check params
     */

    if ( !File ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *  Figure out if the file is ASCII or UNICODE.
     */
    Status = BatchIsAscii( File, &Shell->StdIn.Ascii );
    if ( EFI_ERROR( Status ) ) {
        goto Done;
    }

    /* 
     *  Get the filename from the file handle.
     */

    /* 
     *    Allocate buffer for file info (including file name)
     *    BUGBUG  1024 arbitrary space for filename, as elsewhere in shell
     */
    FileInfoSize = SIZE_OF_EFI_FILE_INFO + 1024;
    FileInfo = AllocatePool(FileInfoSize);
    if (!FileInfo) {
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    /*    Get file info */
    Status = File->GetInfo( File, 
                            &GenericFileInfo, 
                            &FileInfoSize, 
                            FileInfo );
    if ( EFI_ERROR(Status) ) {
        return Status;
    }

    /* 
     *   Save the handle
     */
    CurrentBatchFile = File;

    /* 
     *   Initialize argument list for this script
     *     This list is needed since nested batch files would overwrite the 
     *     argument list in Shell->ShellInt.Argv[].  Here we maintain the args in
     *     a local list on the stack.
     */

    BatchInfo = AllocateZeroPool( sizeof( EFI_SHELL_BATCH_INFOLIST ) );
    if ( !BatchInfo ) {
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }
    BatchInfo->Signature = EFI_BATCH_INFOLIST_SIGNATURE;

    BatchInfo->FilePosition = (UINT64)0x00;

    InitializeListHead( &BatchInfo->ArgListHead );
    for ( i=0; i<Shell->ShellInt.Argc; i++ ) {
        
        /*   Allocate the new element of the argument list */
        ArgEntry = AllocateZeroPool( sizeof( EFI_SHELL_BATCH_INFO ) );
        if ( !ArgEntry ) {
            Status = EFI_OUT_OF_RESOURCES;
            goto Done;
        }

        /*   Allocate space for the argument string in the arglist element */
        ArgEntry->ArgValue = AllocateZeroPool(StrSize(Shell->ShellInt.Argv[i]));
        if ( !ArgEntry->ArgValue ) {
            Status = EFI_OUT_OF_RESOURCES;
            goto Done;
        }

        /*   Copy in the argument string */
        StrCpy( ArgEntry->ArgValue, Shell->ShellInt.Argv[i] );
        ArgEntry->Signature = EFI_BATCH_INFO_SIGNATURE;

        /*   Add the arglist element to the end of the list */
        InsertTailList( &BatchInfo->ArgListHead, &ArgEntry->Link );
    }

    /*   Push the arglist onto the arglist stack */
    InsertHeadList( &BatchInfoStack, &BatchInfo->Link );

    /* 
     *   Iterate through the file, reading a line at a time and executing each
     *   line as a shell command.  Nested shell scripts will come through 
     *   this code path recursively.
     */
    EndOfFile = FALSE;
    SkippedIfCount = 0;
    while (1) {

        /* 
         *   Read a command line from the file
         */
         BufSize = MAX_CMDLINE;
        Status = BatchGetLine( File, 
                               Shell->StdIn.Ascii, 
                               &BatchInfo->FilePosition, 
                               &BufSize, 
                               CommandLine );
        if ( EFI_ERROR( Status ) ) {
            goto Done;
        }

        /* 
         *   No error and no chars means EOF
         *   If we are in the middle of a GOTO then rewind to search for the
         *     label from the beginning of the file, otherwise we are done
         *     with this script.
         */

        if ( BufSize == 0 ) {
            if ( GotoIsActive ) {
                BatchInfo->FilePosition = (UINT64)(0x00);
                Status = File->SetPosition( File, BatchInfo->FilePosition );
                 if ( EFI_ERROR( Status ) ) {
                    goto Done;
                } else {
                    continue;
                }
            } else {
                goto Done;
            }
        }

        /* 
         *  Convert the command line to an arg list
         */

        ZeroMem( &NewShell, sizeof(NewShell ) );
        Status = SEnvStringToArg( 
                     CommandLine, 
                     TRUE, 
                     &NewShell.ShellInt.Argv, 
                     &NewShell.ShellInt.Argc
                     );
        if (EFI_ERROR(Status)) {
            goto Done;
        }

        /* 
         *   Skip comments and blank lines
         */

        if ( NewShell.ShellInt.Argc == 0 ) {
            continue;
        }

        /* 
         *   If a GOTO command is active, skip everything until we find 
         *   the target label or until we determine it doesn't exist.
         */

        if ( GotoIsActive ) {
            /* 
             *   Check if we have the right label or if we've searched 
             *   the whole file
             */
            Status = SEnvCheckForGotoTarget( NewShell.ShellInt.Argv[0],
                                             GotoFilePos, 
                                             BatchInfo->FilePosition, 
                                             &GotoTargetStatus );
            if ( EFI_ERROR( Status ) ) {
                goto Done;
            }
    
            switch ( GotoTargetStatus ) {
            case GOTO_TARGET_FOUND:
                GotoIsActive = FALSE;
                SEnvFreeTargetLabel();
                continue;
            case GOTO_TARGET_NOT_FOUND:
                continue;
            case GOTO_TARGET_DOESNT_EXIST:
                GotoIsActive = FALSE;
                Status = EFI_INVALID_PARAMETER;
                LastError = Status;
                SEnvPrintLabelNotFound();
                SEnvFreeTargetLabel();
                continue;
            default:
                Status = EFI_INVALID_PARAMETER;
                SEnvFreeTargetLabel();
                Print( L"Internal error: invalid GotoTargetStatus\n" );
                break;
            }
        } else if ( NewShell.ShellInt.Argv[0][0] == L':' ) {
            /* 
             *   Skip labels when no GOTO is active
             */
            continue;
        }

        /* 
         *   Skip everything between an 'if' whose condition was false and its
         *   matching 'endif'.  Note that 'endif' doesn't do anything if 
         *   Condition is TRUE, so we only track endif matching when it is false.
         */

        if ( !Condition ) {
            if ( StriCmp( NewShell.ShellInt.Argv[0], L"if") == 0 ) {
                /* 
                 *   Keep track of how many endifs we have to skip before we are
                 *   done with the FALSE Condition
                 */
                SkippedIfCount += 1;
                continue;
            } else if ( StriCmp( NewShell.ShellInt.Argv[0], L"endif") == 0 ) {
                if ( SkippedIfCount > 0 ) {
                    SkippedIfCount -= 1;
                    continue;
                }
                /* 
                 *   When SkippedIfCount goes to zero (as here), we have the
                 *   endif that matches the if with the FALSE condition that 
                 *   we are dealing with, so we want to fall through and have 
                 *   the endif command reset the Condition flag.
                 */
            } else {
                /* 
                 *   Condition FALSE, not an if or an endif, so skip
                 */
                continue;
            }
        }

        /* 
         *   Execute the command
         */
        LastError = SEnvDoExecute( 
                        Shell->ShellInt.ImageHandle, 
                        CommandLine, 
                        &NewShell, 
                        TRUE
                        );

        /* 
         *   Save the current file handle
         */
        CurrentBatchFile = File;

        if ( BatchAbort ) {
            goto Done;
        }
    }

Done:
    /* 
     *   Clean up
     */

    /*   Decrement the count of open script files */
    NestLevel--;

    /*   Free any potential remaining GOTO target label */
    SEnvFreeTargetLabel();

    /*   Reset the IF condition to TRUE, even if no ENDIF was found */
    SEnvBatchSetCondition( TRUE );
    
    /*   Close the script file */
    if ( File ) {
        File->Close( File );
    }

    /*   Free the file info structure used to get the file name from the handle */
    if ( FileInfo ) {
        FreePool( FileInfo );
        FileInfo = NULL;
    }

    /*   Pop the argument list for this script off the stack */
    if ( !IsListEmpty( &BatchInfoStack ) ) {
        BatchInfo = CR( BatchInfoStack.Flink, 
                        EFI_SHELL_BATCH_INFOLIST, 
                        Link, 
                        EFI_BATCH_INFOLIST_SIGNATURE );
        RemoveEntryList( &BatchInfo->Link );
    }

    /*   Free the argument list for this script file */
    while ( !IsListEmpty( &BatchInfo->ArgListHead ) ) {
        ArgEntry = CR( BatchInfo->ArgListHead.Flink, 
                       EFI_SHELL_BATCH_INFO, 
                       Link, 
                       EFI_BATCH_INFO_SIGNATURE );
        if ( ArgEntry ) {
            RemoveEntryList( &ArgEntry->Link );
            if ( ArgEntry->ArgValue ) {
                FreePool( ArgEntry->ArgValue );
                ArgEntry->ArgValue = NULL;
            }
            FreePool( ArgEntry );
            ArgEntry = NULL;
        }
    }
    FreePool( BatchInfo );
    BatchInfo = NULL;

    /* 
     *   If we are returning to the interactive shell, then reset 
     *   the batch-is-active flag
     */
    if ( IsListEmpty( &BatchInfoStack ) ) {
        BatchIsActive = FALSE;
        BatchAbort = FALSE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\echo.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    echo.c
    
Abstract:

    Shell app "echo"



Revision History

--*/

#include "shelle.h"


/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdEcho

    Description:
        Shell command "echo".
*/
EFI_STATUS
SEnvCmdEcho (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *   No args: print status
     *   One arg, either -on or -off: set console echo flag
     *   Otherwise: echo all the args.  Shell parser will expand any args or vars.
     */

    if ( Argc == 1 ) {
        Print( L"Echo is %s\n", (SEnvBatchGetEcho()?L"on":L"off") );

    } else if ( Argc == 2 && StriCmp( Argv[1], L"-on" ) == 0 ) {
        SEnvBatchSetEcho( TRUE );

    } else if ( Argc == 2 && StriCmp( Argv[1], L"-off" ) == 0 ) {
        SEnvBatchSetEcho( FALSE );

    } else {
        for (Index = 1; Index < Argc; Index += 1) {
            Print( L"%s ", Argv[Index] );
        }
        Print( L"\n" );
    }

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\data.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    data.c
    
Abstract:

    Shell Environment driver global data



Revision History

--*/

#include "shelle.h"


/* 
 *  IDs of different variables stored by the shell environment
 */

EFI_GUID SEnvEnvId = ENVIRONMENT_VARIABLE_ID;
EFI_GUID SEnvMapId = DEVICE_PATH_MAPPING_ID;
EFI_GUID SEnvProtId = PROTOCOL_ID_ID;
EFI_GUID SEnvAliasId = ALIAS_ID;

/* 
 * 
 */


EFI_SHELL_ENVIRONMENT SEnvInterface = {
    SEnvExecute,
    SEnvGetEnv,
    SEnvGetMap,
    SEnvAddCommand,
    SEnvAddProtocol,
    SEnvGetProtocol,
    SEnvGetCurDir,
    SEnvFileMetaArg,
    SEnvFreeFileList,

    SEnvNewShell
} ;


/* 
 *  SEnvIoFromCon - used to access the console interface as a file handle
 */

EFI_FILE SEnvIOFromCon = {
    EFI_FILE_HANDLE_REVISION,
    SEnvConIoOpen,
    SEnvConIoNop,
    SEnvConIoNop,
    SEnvConIoRead,
    SEnvConIoWrite,
    SEnvConIoGetPosition,
    SEnvConIoSetPosition,
    SEnvConIoGetInfo,
    SEnvConIoSetInfo,
    SEnvConIoNop
} ;

EFI_FILE SEnvErrIOFromCon = {
    EFI_FILE_HANDLE_REVISION,
    SEnvConIoOpen,
    SEnvConIoNop,
    SEnvConIoNop,
    SEnvErrIoRead,
    SEnvErrIoWrite,
    SEnvConIoGetPosition,
    SEnvConIoSetPosition,
    SEnvConIoGetInfo,
    SEnvConIoSetInfo,
    SEnvConIoNop
} ;

/* 
 *  SEnvConToIo - used to access the console interface as a file handle
 */

SIMPLE_TEXT_OUTPUT_MODE SEnvConToIoMode = {
    0,
    0,
    EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_BLACK),
    0,
    0,
    TRUE
} ;

SIMPLE_TEXT_OUTPUT_INTERFACE SEnvConToIo = {
    SEnvReset,
    SEnvOutputString,
    SEnvTestString,
    SEnvQueryMode,
    SEnvSetMode,
    SEnvSetAttribute,
    SEnvClearScreen,
    SEnvSetCursorPosition,
    SEnvEnableCursor,
    &SEnvConToIoMode
} ;

/* 
 *  SEnvLock - gaurds all shell data except the guid database
 */

FLOCK SEnvLock;

/* 
 *  SEnvGuidLock - gaurds the guid data
 */

FLOCK SEnvGuidLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\dprot.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    dprot.c
    
Abstract:   

    Shell environment - dump protocol functions for the "dh" command



Revision History

--*/

#include "shelle.h"


STATIC CHAR16 *SEnvDP_IlleagalStr[] = {
    L"Illegal" 
};

STATIC CHAR16 *SEnvDP_HardwareStr[] = {
    L"Illegal", L"PCI", L"PCCARD", L"MemMap", L"VENDOR" 
};

STATIC CHAR16 *SEnvDP_PnP_Str[] = {
    L"Illegal", L"PnP" 
};

STATIC CHAR16 *SEnvDP_MessageStr[] = {
    L"Illegal", L"ATAPI", L"SCSI", L"FIBRE Channel",  
    L"1394", L"USB", L"I2O", L"TCP/IPv4", L"TCP/IPv6", 
    L"NGIO", L"VENDOR" 
};

STATIC CHAR16 *SEnvDP_MediaStr[] = {
    L"Illegal", L"Hard Drive", L"CD-ROM", L"VENDOR", L"File Path", L"Media Protocol"
};

STATIC CHAR16 *SEnvDP_BBS_Str[] = {
    L"Illegal", L"BBS" 
};

struct DevicePathTypes {
    UINT8   Type;
    UINT8   MaxSubType;
    CHAR16  *TypeString;
    CHAR16  **SubTypeStr;
    VOID    (*Function)(EFI_DEVICE_PATH *);    
};

VOID
SEnvHardwareDevicePathEntry (
    IN EFI_DEVICE_PATH  *DevicePath
    )
{
    VENDOR_DEVICE_PATH  *VendorDevicePath;  

    if (DevicePathType(DevicePath) != HW_PCI_DP) {
        return;
    }
    if (DevicePathSubType(DevicePath) == HW_VENDOR_DP) {
        VendorDevicePath = (VENDOR_DEVICE_PATH *)DevicePath;
        Print(L"\n%N       Guid %g", 
            &VendorDevicePath->Guid
            );
    }
}


VOID
SEnvPnpDevicePathEntry (
    IN EFI_DEVICE_PATH      *DevicePath
    )
{
    ACPI_HID_DEVICE_PATH    *AcpiDevicePath;

    if (DevicePathType(DevicePath) != ACPI_DEVICE_PATH) {
        return;
    }

    if (DevicePathSubType(DevicePath) == ACPI_DP) {
        AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)DevicePath;
        Print(L"\n%N       HID %x, UID %x", 
            AcpiDevicePath->HID,
            AcpiDevicePath->UID
            );
    }
}


VOID
SEnvMediaDevicePathEntry (
    IN EFI_DEVICE_PATH  *DevicePath
    )
{
    HARDDRIVE_DEVICE_PATH       *HardDriveDevicePath;
    CDROM_DEVICE_PATH           *CDDevicePath;  
    VENDOR_DEVICE_PATH          *VendorDevicePath;
    FILEPATH_DEVICE_PATH        *FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH  *MediaProtocol;

    if (DevicePathType(DevicePath) != MEDIA_DEVICE_PATH) {
        return;
    }
    
    switch (DevicePathSubType(DevicePath)) {
    case MEDIA_HARDDRIVE_DP:
        HardDriveDevicePath = (HARDDRIVE_DEVICE_PATH *)DevicePath;
        Print(L"\n%N       Partition (%d) Start (%lX) Size (%lX)", 
            HardDriveDevicePath->PartitionNumber,
            HardDriveDevicePath->PartitionStart,
            HardDriveDevicePath->PartitionSize
            );
        break;
    case MEDIA_CDROM_DP:
        CDDevicePath = (CDROM_DEVICE_PATH *)DevicePath;
        Print(L"\n%N       BootEntry (%x) Start (%lX) Size (%lX)", 
            CDDevicePath->BootEntry,
            CDDevicePath->PartitionStart,
            CDDevicePath->PartitionSize
            );
        break;
    case MEDIA_VENDOR_DP:
        VendorDevicePath = (VENDOR_DEVICE_PATH *)DevicePath;
        Print(L"\n%N       Guid %g", 
            &VendorDevicePath->Guid
            );
        break;
    case MEDIA_FILEPATH_DP:
        FilePath = (FILEPATH_DEVICE_PATH *) DevicePath;
        Print(L"\n%N       File '%hs'", FilePath->PathName);
        break;
    case MEDIA_PROTOCOL_DP:
        MediaProtocol = (MEDIA_PROTOCOL_DEVICE_PATH *) DevicePath;
        Print(L"\n%N       Protocol '%hg'", &MediaProtocol->Protocol);
        break;
    };
}

struct DevicePathTypes SEnvDP_Strings[] = {
    0x00, 0x01, L"Illegal",     SEnvDP_IlleagalStr,     NULL,
    0x01, 0x03, L"Hardware",    SEnvDP_HardwareStr,     SEnvHardwareDevicePathEntry,
    0x02, 0x01, L"PNP",         SEnvDP_PnP_Str,         SEnvPnpDevicePathEntry,
    0x03, 0x0a, L"Messaging",   SEnvDP_MessageStr,      NULL,
    0x04, 0x05, L"Media",       SEnvDP_MediaStr,        SEnvMediaDevicePathEntry,
    0x05, 0x01, L"BBS",         SEnvDP_BBS_Str,         NULL,
    END_DEVICE_PATH_TYPE, 0x01, L"End", SEnvDP_IlleagalStr, NULL
};

VOID
SEnvPrintDevicePathEntry (
    IN EFI_DEVICE_PATH      *DevicePath,
    IN BOOLEAN              Verbose
    )
{
    UINT8   Type;
    UINT8   SubType;
    INTN    i;

    Type = DevicePathType(DevicePath);
    SubType = DevicePathSubType(DevicePath);
    for (i=0; SEnvDP_Strings[i].Type != END_DEVICE_PATH_TYPE;i++) {
        if (Type == SEnvDP_Strings[i].Type) {
            if (SubType > SEnvDP_Strings[i].MaxSubType) {
                SubType = 0;
            }
            Print(L"\n%N      %s Device Path for %s", 
                SEnvDP_Strings[i].TypeString,
                SEnvDP_Strings[i].SubTypeStr[SubType]
                );
            if (Verbose) {
                if(SEnvDP_Strings[i].Function != NULL) {
                    SEnvDP_Strings[i].Function(DevicePath);
                }
            }
            return;
        }
    }
    Print(L"\n%E      Device Path Error%N - Unknown Device Type");
    DbgPrint (D_ERROR, "%EDevice Path Error%N - Unknown Device Type");
}

VOID
SEnvDPath (
    IN EFI_HANDLE           h,
    IN VOID                 *Interface
    )
{
    EFI_DEVICE_PATH         *DevicePath, *DevicePathNode;
    CHAR16                  *Str;

    DevicePath = Interface;
    Str = DevicePathToStr (DevicePath);
    DevicePath = UnpackDevicePath (DevicePath);
    
    DevicePathNode = DevicePath;
    while (!IsDevicePathEnd(DevicePathNode)) {
        SEnvPrintDevicePathEntry(DevicePathNode, TRUE);
        DevicePathNode = NextDevicePathNode(DevicePathNode);
    }

    Print (L"\n   AsStr:%N '%s'\n", Str);
    FreePool (Str);
    FreePool (DevicePath);
}


VOID
SEnvDPathTok (
    IN EFI_HANDLE   h,
    IN VOID         *Interface
    )
{
    EFI_DEVICE_PATH         *DevicePath;
    CHAR16                  *Str, *Disp;
    UINTN                   Len;

    DevicePath = Interface;
    Str = DevicePathToStr (DevicePath);
    Disp = L"";

    if (Str) {
        Len = StrLen(Str);
        Disp = Str;
        if (Len > 30) {
            Disp = Str + Len - 30;
            Disp[0] = '.';
            Disp[1] = '.';
        }
    }

    Print (L"DevPath(%s)", Disp);

    if (Str) {
        FreePool (Str);
    }
}


VOID
SEnvTextOut (
    IN EFI_HANDLE   h,
    IN VOID         *Interface
    )
{
    SIMPLE_TEXT_OUTPUT_INTERFACE    *Dev;
    INTN                             i;  
    UINTN                            Col, Row;
    EFI_STATUS                      Status;

    Dev = Interface;
    Print (L"Attrib %x",
        Dev->Mode->Attribute
        );

    for (i=0; i < Dev->Mode->MaxMode; i++) {
        Status = Dev->QueryMode (Dev, i, &Col, &Row);
        Print (L"\n%N      %hc  mode %d: ",
            i == Dev->Mode->Mode ? '*' : ' ',
            i
            );

        if (EFI_ERROR(Status)) {
            Print (L"%error %rx\n", Status);
        } else {
            Print (L"col %3d row %3d", Col, Row);
        }
    }
}



VOID
SEnvBlkIo (
    IN EFI_HANDLE   h,
    IN VOID         *Interface
    )
{
    EFI_BLOCK_IO        *BlkIo;
    EFI_BLOCK_IO_MEDIA  *BlkMedia;
    VOID                *Buffer;

    BlkIo = Interface;
    BlkMedia = BlkIo->Media;

    /*  issue a dumby read to the device to check for media change */
    Buffer = AllocatePool (BlkMedia->BlockSize);
    if (Buffer) {
        BlkIo->ReadBlocks(BlkIo, BlkMedia->MediaId, 0, BlkMedia->BlockSize, Buffer);
        FreePool (Buffer);
    }

    Print (L"%s%esMId:%x ",
        BlkMedia->RemovableMedia ? L"Removable " : L"Fixed ",
        BlkMedia->MediaPresent ? L"" : L"not-present ",
        BlkMedia->MediaId
        );

    Print (L"bsize %x, lblock %lx (%,ld), %s %s %s",
        BlkMedia->BlockSize,
        BlkMedia->LastBlock,
        MultU64x32 (BlkMedia->LastBlock + 1, BlkMedia->BlockSize),
        BlkMedia->LogicalPartition ? L"partition" : L"raw",
        BlkMedia->ReadOnly ? L"ro" : L"rw",
        BlkMedia->WriteCaching ? L"cached" : L"!cached"
        );
}


VOID
SEnvImageTok (
    IN EFI_HANDLE       h,
    IN VOID             *Interface
    )
{
    EFI_LOADED_IMAGE    *Image;
    CHAR16              *Tok;
    
    Image = Interface;
    Tok = DevicePathToStr (Image->FilePath);
    Print (L"%HImage%N(%s) ", Tok);

    if (Tok) {
        FreePool (Tok);
    }
}

VOID
SEnvImage (
    IN EFI_HANDLE       h,
    IN VOID             *Interface
    )
{
    EFI_LOADED_IMAGE    *Image;
    CHAR16              *FilePath;
    
    Image = Interface;
    
    FilePath = DevicePathToStr (Image->FilePath);
    Print (L"  File:%hs\n", FilePath);
    
    if (!Image->ImageBase) {
        Print (L"     %EInternal Image:%N %s\n",  FilePath);
        Print (L"     CodeType......: %s\n",  MemoryTypeStr(Image->ImageCodeType));
        Print (L"     DataType......: %s\n",  MemoryTypeStr(Image->ImageDataType)); 

    } else {

        Print (L"     ParentHandle..: %X\n",  Image->ParentHandle);
        Print (L"     SystemTable...: %X\n",  Image->SystemTable);
        Print (L"     DeviceHandle..: %X\n",  Image->DeviceHandle);
        Print (L"     FilePath......: %s\n",  FilePath);
        Print (L"     ImageBase.....: %X - %X\n",  
                            Image->ImageBase,
                            (CHAR8 *) Image->ImageBase + Image->ImageSize
                            );
        Print (L"     ImageSize.....: %lx\n", Image->ImageSize);
        Print (L"     CodeType......: %s\n",  MemoryTypeStr(Image->ImageCodeType));
        Print (L"     DataType......: %s\n",  MemoryTypeStr(Image->ImageDataType)); 
    }

    if (FilePath) {
        FreePool (FilePath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\doskey.c ===
/*/###########################################################################
//**
//**  Copyright  (C) 1996-97 Intel Corporation. All rights reserved. 
//**
//** The information and source code contained herein is the exclusive 
//** property of Intel Corporation and may not be disclosed, examined
//** from the company.
//**
*//* ########################################################################### */

#include "EfiShell.h"
#include "doskey.h" 

#define isprint(a) ((a) >= ' ')

CHAR16 *DosKeyInsert (DosKey_t *DosKey);
CHAR16 *DosKeyPreviousCurrent (DosKey_t *DosKey);
CHAR16 *DosKeyGetCommandLine (DosKey_t *DosKey);


#define MAX_LINE        256
#define MAX_HISTORY     20


typedef struct {
    UINTN           Signature;
    LIST_ENTRY      Link;
    CHAR16          Buffer[MAX_LINE];
} INPUT_LINE;


/* 
 *  Globals
 */


static BOOLEAN      ShellEnvInsertMode;
static LIST_ENTRY   *ShellEnvCurrentLine;
static LIST_ENTRY   ShellEnvLineHistory;
static UINTN        ShellEnvNoHistory;


VOID
DosKeyDelete (
    IN OUT  DosKey_t *DosKey
    )
{                                                   
    INTN NewEnd;
    
    if (DosKey->Start != DosKey->End) {
        NewEnd = (DosKey->End==0)?(MAX_HISTORY-1):(DosKey->End - 1);
        if (DosKey->Current == NewEnd) {
            DosKey->Current = (DosKey->Current==0)?(MAX_HISTORY-1):(DosKey->Current - 1);
        }
        DosKey->End = NewEnd;
    }
}                            

CHAR16 *
DosKeyInsert (
    IN OUT  DosKey_t *DosKey
    )
{                                                       
    INTN     Next;
    INTN     Data;        
    INTN     i;
    
    Data = DosKey->End;
    Next = ((DosKey->End + 1) % MAX_HISTORY);
    if (DosKey->Start == Next) {
        /*  Wrap case */
        DosKey->Start = ((DosKey->Start + 1) % MAX_HISTORY);
    }
    DosKey->End = Next;
    for (i=0; i<MAX_CMDLINE; i++) {
        DosKey->Buffer[Data][i] = '\0';
    }
    DosKey->Current = Data;
    return (&(DosKey->Buffer[Data][0]));
}

CHAR16 *
DosKeyPreviousCurrent (
    IN OUT DosKey_t *DosKey
) 
{
    INTN Next;
    
    Next = (DosKey->Current==0)?(MAX_HISTORY-1):(DosKey->Current - 1);
    if (DosKey->Start < DosKey->End) {
        if ((Next >= DosKey->Start) && (Next != (MAX_HISTORY-1))) {
            DosKey->Current = Next;
        } 
    } else if (DosKey->Start > DosKey->End){
        /*  Allways a Full Buffer  */
        if (Next != DosKey->End) {
            DosKey->Current = Next; 
        }
    } else { 
        /*  No Data */
    }
    return (&(DosKey->Buffer[DosKey->Current][0]));
}

CHAR16 *
DosKeyNextCurrent (
    IN OUT  DosKey_t *DosKey
    ) 
{
    INTN Next;
    
    Next = ((DosKey->Current + 1) % MAX_HISTORY);
    if (DosKey->Start < DosKey->End) {
        if (Next != DosKey->End) {
            DosKey->Current = Next;
        } 
    } else if (DosKey->Start > DosKey->End){
        /*  Allways a Full Buffer  */
        if (Next != DosKey->Start) {
            DosKey->Current = Next; 
        }
    } else { 
        /*  No Data */
    }
    return (&(DosKey->Buffer[DosKey->Current][0]));
}

VOID
PrintDosKeyBuffer(
    IN OUT  DosKey_t *DosKey
    )
{
    INTN i;  
    INTN Index;

    Index = 1;
    if (DosKey->Start < DosKey->End) {  
        for (i = DosKey->End - 1; i >= DosKey->Start; i--) {
            if (DosKey->Buffer[i][0] != '\0') {
                Print (L"\n%2d:%2d: %s",Index++, i, DosKey->Buffer[i]);
            } else {
                Print (L"\n  :%2d:",i);
            }
        }
    } else if (DosKey->Start > DosKey->End) {
        for (i = DosKey->End -1; i >= 0; i--) {
            if (DosKey->Buffer[i][0] != '\0') {
                Print (L"\n%2d:%2d: %s",Index++, i, DosKey->Buffer[i]);
            } else {
                Print (L"\n  :%2d:",i);
            }
        }
        for (i = (MAX_HISTORY-1); i >= DosKey->Start; i--) {
            if (DosKey->Buffer[i][0] != '\0') {
                Print(L"\n%2d:%2d: %s",Index++, i, DosKey->Buffer[i]);
            } else {
                Print(L"\n  :%2d:",i);
            }
        }
    } else /* if (DosKey->Start == DosKey->End) */{
    }
}

CHAR16 *
ShellEnvReadLine (


DosKeyGetCommandLine (
    IN DosKey_t     *DosKey
    )
{ 
    CHAR16                          Str[MAX_CMDLINE];
    CHAR16                          *CommandLine;
    BOOLEAN                         Done;
    UINTN                           Column, Row;
    UINTN                           Update, Delete;
    UINTN                           Len, StrPos, MaxStr;
    UINTN                           Index;

    EFI_INPUT_KEY                   Key;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
    SIMPLE_INPUT_INTERFACE          *ConIn;


    ConOut = ST->ConOut;
    ConIn = ST->ConIn;

    /* 
     *  Get input fields location
     */

    Column = ConOut->CursorColumn;
    Row = ConOut->CursorRow;
    ConOut->QueryMode (ConOut, ConOut->Mode, &MaxStr, &Index);

    /*  bugbug: for now wrapping is not handled */
    MaxStr = MaxStr - Column;
    if (MaxStr > MAX_CMDLINE) {
        MaxStr = MAX_CMDLINE;
    }

        
    /* 
     *  Set new input
     */

    CommandLine = DosKeyInsert(DosKey);
    SetMem(Str, sizeof(Str), 0x00);
    Update = 0;
    Delete = 0;

    Done = FALSE;
    do {
        /* 
         *  If we need to update the output do so now
         */

        if (Update != -1) {
            PrintAt (Column+Update, Row, L"%s%.*s", Str + Update, Delete, L"");
            Len = StrLen (Str);

            if (Delete) {
                SetMem(Str+Len, Delete * sizeof(CHAR16), 0x00);
            }

            if (StrPos > Len) {
                StrPos = Len;
            }

            Update = -1;
            Delete = 0;
        }

        /* 
         *  Set the cursor position for this key
         */

        ConOut->SetCursorPosition (ConOut, Column+StrPos, Row);

        /* 
         *  Read the key
         */

        ConIn->ReadKeyStroke(ConIn, &Key);

        switch (Key.UnicodeChar) {
        case CHAR_CARRIAGE_RETURN:
            /* 
             *  All done, print a newline at the end of the string
             */

            PrintAt (Column+Len, Row, L"\n");
            if (*Str == 0) {
                DosKeyDelete(DosKey);
            }
            Done = TRUE;
            break;

        case CHAR_BACKSPACE:
            if (StrPos) {
                StrPos -= 1;
                Update = StrPos;
                Delete = 1;
                CopyMem (Str+StrPos, Str+StrPos+1, sizeof(CHAR16) * (Len-StrPos));
            }
            break;

        default:
            if (isprint(Key.UnicodeChar)) {
                /*  If we are at the buffer's end, drop the key */
                if (Len == MaxStr-1 && 
                    (DosKey->InsertMode || StrPos == Len)) {
                    break;
                }

                if (DosKey->InsertMode) {
                    for (Index=Len; Index > StrPos; Index -= 1) {
                        Str[Index] = Str[Index-1];
                    }
                }

                Str[StrPos] = Key.UnicodeChar;
                Update = StrPos;
                StrPos += 1;
            }
            break;

        case 0:
            switch (Key.ScanCode) {
            case SCAN_DELETE:
                if (StrLen) {
                    Update = StrPos;
                    Delete = 1;
                    CopyMem (Str+StrPos, Str+StrPos+1, sizeof(CHAR16) * (Len-StrPos));
                }
                break;

            case SCAN_UP:
                StrCpy(Str, DosKeyPreviousCurrent(DosKey));

                Index = Len;                /*  Save old len */
                Len = StrLen(Str);          /*  Get new len */
                StrPos = Len;
                Update = 0;                 /*  draw new input string */
                if (Index > Len) {
                    Delete = Index - Len;   /*  if old string was longer, blank it */
                }
                break;

            case SCAN_DOWN:
                StrCpy(Str, DosKeyNextCurrent(DosKey));

                Index = Len;                /*  Save old len */
                Len = StrLen(Str);          /*  Get new len */
                StrPos = Len;
                Update = 0;                 /*  draw new input string */
                if (Index > Len) {
                    Delete = Index - Len;   /*  if old string was longer, blank it */
                }

                break;

            case SCAN_LEFT:
                if (StrPos) {
                    StrPos -= 1;
                }
                break;

            case SCAN_RIGHT:
                if (StrPos < Len) {
                    StrPos += 1;
                }
                break;

            case SCAN_HOME:
                StrPos = 0;
                break;

            case SCAN_END:
                StrPos = Len;
                break;

            case SCAN_ESC:
                Str[0] = 0;
                Update = 0;
                Delete = Len;
                break;

            case SCAN_INSERT:
                DosKey->InsertMode = !DosKey->InsertMode;
                break;

            case SCAN_F7:
                DosKeyDelete(DosKey);
                PrintDosKeyBuffer(DosKey);
                *Str = 0;
                Done = TRUE;    
                break;
            }       
        }
    } while (!Done);

    StrCpy (CommandLine, Str);
    return (CommandLine);
}

VOID
RemoveFirstCharFromString(
    IN OUT  CHAR16  *Str
    )
{
    UINTN   Length;
    CHAR16  *NewData;

    NewData = Str + 1;
    Length = StrLen(NewData);
    while (Length-- != 0) {
        *Str++ = *NewData++;
    }
    *Str = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\handle.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    handle.c
    
Abstract:

    Shell environment handle information management



Revision History

--*/

#include "shelle.h"


UINTN       SEnvNoHandles;
EFI_HANDLE  *SEnvHandles;


VOID
INTERNAL
SEnvInitHandleGlobals (
    VOID
    )
{
    SEnvNoHandles   = 0;
    SEnvHandles     = NULL;
}

    
VOID
INTERNAL
SEnvLoadHandleTable (
    VOID
    )
{
    /* 
     *  For ease of use the shell maps handle #'s to short numbers.
     * 
     *  This is only done on request for various internal commands and
     *  the references are immediately freed when the internal command
     *  completes.
     */

    /*  Free any old info */
    SEnvFreeHandleTable();

    /*  Load new info */
    SEnvHandles = NULL;
    LibLocateHandle (AllHandles, NULL, NULL, &SEnvNoHandles, &SEnvHandles);
}


VOID
INTERNAL
SEnvFreeHandleTable (
    VOID
    )
{
    if (SEnvNoHandles) {
        SEnvFreeHandleProtocolInfo();

        FreePool (SEnvHandles);
        SEnvHandles = NULL;
        SEnvNoHandles = 0;
    }
}



UINTN
SEnvHandleNoFromStr(
    IN CHAR16       *Str
    )
{
    UINTN           HandleNo;

    HandleNo = xtoi(Str);
    HandleNo = HandleNo > SEnvNoHandles ? 0 : HandleNo;
    return HandleNo;
}


EFI_HANDLE
SEnvHandleFromStr(
    IN CHAR16       *Str
    )
{
    UINTN           HandleNo;
    EFI_HANDLE      Handle;

    HandleNo = xtoi(Str) - 1;
    Handle = HandleNo > SEnvNoHandles ? NULL : SEnvHandles[HandleNo];
    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\if.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    if.c
    
Abstract:

    Internal Shell cmd "if" & "endif"



Revision History

--*/

#include "shelle.h"


/* 
 *  Internal prototypes
 */

EFI_STATUS
CheckIfFileExists( 
    IN  CHAR16          *FileName,
    OUT BOOLEAN         *FileExists
    );

/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdIf

    Description:
        Builtin shell command "if" for conditional execution in script files.
*/
EFI_STATUS
SEnvCmdIf (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc      = 0;
    UINTN                   Index     = 0;
    UINTN                   NNots     = 0;
    EFI_STATUS              Status    = EFI_SUCCESS;
    CHAR16                  *FileName = NULL;
    BOOLEAN                 FileExists = FALSE;
    CHAR16                  *String1  = NULL;
    CHAR16                  *String2  = NULL;

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    if ( !SEnvBatchIsActive() ) {
        Print( L"Error: IF command only supported in script files\n" );
        Status = EFI_UNSUPPORTED;
        goto Done;
    }

    /* 
     *   Two forms of the if command:
     *     if [not] exist file then
     *     if [not] string1 == string2
     * 
     *   First, parse it
     */

    if ( Argc < 4 ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    if ( StriCmp( Argv[1], L"not" ) == 0 ) {
        NNots = 1;
    } else {
        NNots = 0;
    }

    if ( StriCmp( Argv[NNots+1], L"exist" ) == 0 ) {
        /* 
         *   first form of the command, test for file existence
         */
        if ( (Argc != NNots + 4) || (StriCmp( Argv[NNots+3], L"then" ) != 0) ) {
            Status = EFI_INVALID_PARAMETER;
            goto Done;
        }

        FileName = Argv[NNots+2];

        /* 
         *   Test for existence
         */

        Status = CheckIfFileExists( FileName, &FileExists );
        if ( EFI_ERROR( Status ) ) {
            goto Done;
        }
        SEnvBatchSetCondition( (BOOLEAN) ((NNots == 0 && FileExists) || 
                                          (NNots == 1 && !FileExists)) );

    } else {
        /* 
         *   second form of the command, compare two strings
         */
        if ( (Argc != NNots + 5) || (StriCmp( Argv[NNots+2], L"==" ) != 0)
                                 || (StriCmp( Argv[NNots+4], L"then" ) != 0) ) {
            Status = EFI_INVALID_PARAMETER;
            goto Done;
        }

        String1 = Argv[NNots+1];
        String2 = Argv[NNots+3];

        SEnvBatchSetCondition( 
            (BOOLEAN)((NNots == 0 && StriCmp( String1, String2 ) == 0) ||
                      (NNots == 1 && StriCmp( String1, String2 ) != 0)) );
    }

Done:
    return Status;
}


/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        CheckIfFileExists

    Description:
        Check file parameter to see if file exists.  Wildcards are supported,
        but if the argument expands to more than one file name an invalid
        parameter error is returned and "not found" is assumed.
*/
EFI_STATUS
CheckIfFileExists( 
    IN  CHAR16          *FileName,
    OUT BOOLEAN         *FileExists
    )
{
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;
    EFI_STATUS              Status = EFI_SUCCESS;
    UINTN                   NFiles = 0;

    *FileExists = FALSE;
    InitializeListHead (&FileList);

    /* 
     *   Attempt to open the file, expanding any wildcards.
     */
    Status = ShellFileMetaArg( FileName, &FileList);
    if ( EFI_ERROR( Status ) ) {
        if ( Status == EFI_NOT_FOUND ) {
            Status = EFI_SUCCESS;
            goto Done;
        }
    }
    
    /* 
     *  Make sure there is one and only one valid file in the file list
     */
    NFiles = 0;
    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        if ( Arg->Handle ) {
            /* 
             *   Non-NULL handle means file was there and open-able
             */
            NFiles += 1;
        }
    }

    if ( NFiles > 0 ) {
        /* 
         *   Found one or more files, so set the flag
         */
        *FileExists = TRUE;
    }

Done:
    ShellFreeFileList (&FileList);
    return Status;
}


/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdEndif

    Description:
        Builtin shell command "endif".
*/
EFI_STATUS
SEnvCmdEndif (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     *   Just reset the condition flag to resume normal execution.
     */

    SEnvBatchSetCondition( TRUE );

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\goto.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    goto.c
    
Abstract:

    Shell Environment batch goto command



Revision History

--*/

#include "shelle.h"


/* 
 *   Statics
 */
STATIC CHAR16 *TargetLabel;


/*/////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdGoto

    Description:
        Transfers execution of batch file to location following a label (:labelname).
*/
EFI_STATUS
SEnvCmdGoto(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc      = 0;
    EFI_STATUS Status = EFI_SUCCESS;

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    if ( !SEnvBatchIsActive() ) {
        Print( L"Error: GOTO command only supported in script files\n" );
        Status = EFI_UNSUPPORTED;
        goto Done;
    }

    if ( Argc > 2 ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    TargetLabel = StrDuplicate( Argv[1] );
    if ( !TargetLabel ) {
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    SEnvBatchSetGotoActive();
    
Done:
    return Status;
}

/*/////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCheckForGotoTarget

    Description:
        Check to see if we have found the target label of a GOTO command.
*/
EFI_STATUS
SEnvCheckForGotoTarget(
    IN  CHAR16 *Candidate,
    IN  UINT64 GotoFilePos, 
    IN  UINT64 FilePosition, 
    OUT UINTN  *GotoTargetStatus
    )
{
    EFI_STATUS Status = EFI_SUCCESS;

    if ( !Candidate ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *   See if we found the label (strip the leading ':' off the candidate)
     *   or if we have searched the whole file without finding it.
     */
    if ( StriCmp( &Candidate[1], TargetLabel ) == 0 ) {
        *GotoTargetStatus = GOTO_TARGET_FOUND;
        goto Done;

    } else if ( GotoFilePos == FilePosition ) {

        *GotoTargetStatus = GOTO_TARGET_DOESNT_EXIST;
        goto Done;

    } else {

        *GotoTargetStatus = GOTO_TARGET_NOT_FOUND;
        goto Done;
    }


Done:
    return Status;
}


/*/////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvPrintLabelNotFound

    Description:
        Print an error message when a label referenced by a GOTO is not
        found in the script file..
*/
VOID
SEnvPrintLabelNotFound( 
    VOID
    )
{
    Print( L"GOTO target label \":%s\" not found\n", TargetLabel );
    return;
}


/*/////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvInitTargetLabel

    Description:
        Initialize the target label for the GOTO command.
*/
VOID
SEnvInitTargetLabel(
    VOID
    )
{
    TargetLabel = NULL;
    return;
}
        
/*/////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvFreeTargetLabel

    Description:
        Free the target label saved from the GOTO command.
*/
VOID
SEnvFreeTargetLabel(
    VOID
    )
{
    if ( TargetLabel ) {
        FreePool( TargetLabel );
        TargetLabel = NULL;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\init.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    init.c
    
Abstract:

    Shell Environment driver



Revision History

--*/

#include "shelle.h"

/* 
 * 
 */

EFI_STATUS
InitializeShellEnvironment (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeShellEnvironment)

EFI_STATUS
InitializeShellEnvironment (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
/*++

Routine Description:

Arguments:

    ImageHandle     - The handle for this driver

    SystemTable     - The system table

Returns:

    EFI file system driver is enabled

--*/
{
    EFI_HANDLE              Handle;
    UINTN                   BufferSize;
    EFI_STATUS              Status;

    /* 
     *  Initialize EFI library
     */

    InitializeLib (ImageHandle, SystemTable);

    /* 
     *  If we are already installed, don't install again
     */

    BufferSize = sizeof(Handle);
    Status = BS->LocateHandle(ByProtocol, &ShellEnvProtocol, NULL, &BufferSize, &Handle);  
    if (!EFI_ERROR(Status)) {
        return EFI_LOAD_ERROR;
    }

    /* 
     *  Initialize globals
     */

    InitializeLock (&SEnvLock, TPL_APPLICATION);
    InitializeLock (&SEnvGuidLock, TPL_NOTIFY);

    SEnvInitCommandTable();
    SEnvInitProtocolInfo();
    SEnvInitVariables();
    SEnvInitHandleGlobals();
    SEnvInitMap();
    SEnvLoadInternalProtInfo();
    SEnvConIoInitDosKey();
    SEnvInitBatch();

    /* 
     *  Install our handle (or override the existing one)
     */

    BufferSize = sizeof(Handle);
    Handle = ImageHandle;
    BS->LocateHandle(ByProtocol, &ShellEnvProtocol, NULL, &BufferSize, &Handle);
    LibInstallProtocolInterfaces (&Handle, &ShellEnvProtocol, &SEnvInterface, NULL);

    return EFI_SUCCESS;
}



EFI_SHELL_INTERFACE *
SEnvNewShell (
    IN EFI_HANDLE                   ImageHandle
    )
{
    EFI_SHELL_INTERFACE             *ShellInt;

    /*  Allocate a new structure */
    ShellInt = AllocateZeroPool (sizeof(EFI_SHELL_INTERFACE));
    ASSERT (ShellInt);

    /*  Fill in the SI pointer */
    BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID*)&ShellInt->Info);

    /*  Fill in the std file handles */
    ShellInt->ImageHandle = ImageHandle;
    ShellInt->StdIn  = &SEnvIOFromCon;
    ShellInt->StdOut = &SEnvIOFromCon;
    ShellInt->StdErr = &SEnvErrIOFromCon;

    return ShellInt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\marg.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    marg.c
    
Abstract:



Revision History

--*/

#include "shelle.h"

/* 
 * 
 */

typedef struct _CWD {
    struct _CWD     *Next;
    CHAR16          Name[1];
} SENV_CWD;


CHAR16 *
SEnvFileHandleToFileName (
    IN EFI_FILE_HANDLE      Handle
    )
{
    UINTN                   BufferSize, bs;
    SENV_CWD                *CwdHead, *Cwd;
    POOL_PRINT              Str;
    EFI_FILE_INFO           *Info;
    EFI_STATUS              Status;
    EFI_FILE_HANDLE         NextDir;

    ASSERT_LOCKED(&SEnvLock);

    Status = EFI_SUCCESS;
    CwdHead = NULL;
    ZeroMem (&Str, sizeof(Str));

    /* 
     * 
     */

    Status = Handle->Open(Handle, &Handle, L".", EFI_FILE_MODE_READ, 0);
    if (EFI_ERROR(Status)) {
        Handle = NULL;
        goto Done;
    }


    BufferSize = SIZE_OF_EFI_FILE_INFO + 1024;
    Info = AllocatePool(BufferSize);
    if (!Info) {
        goto Done;
    }

    /* 
     *  Reverse out the current directory on the device
     */

    for (; ;) {
        bs = BufferSize;
        Status = Handle->GetInfo(Handle, &GenericFileInfo, &bs, Info);
        if (EFI_ERROR(Status)) {
            goto Done;
        }

        /* 
         *  Allocate & chain in a new name node
         */

        Cwd = AllocatePool (sizeof(SENV_CWD) + StrSize (Info->FileName));
        if (!Cwd) {
            goto Done;
        }

        StrCpy (Cwd->Name, Info->FileName);

        Cwd->Next = CwdHead;
        CwdHead = Cwd;

        /* 
         *  Move to the parent directory
         */

        Status = Handle->Open (Handle, &NextDir, L"..", EFI_FILE_MODE_READ, 0);
        if (EFI_ERROR(Status)) {
            break;
        }

        Handle->Close (Handle);
        Handle = NextDir;
    }

    /* 
     *  Build the name string of the current path
     */

    if (CwdHead->Next) {
        for (Cwd=CwdHead->Next; Cwd; Cwd=Cwd->Next) {
            CatPrint (&Str, L"\\%s", Cwd->Name);
        }
    } else {
        /*  must be in the root */
        Str.str = StrDuplicate (L"\\");
    }

Done:
    while (CwdHead) {
        Cwd = CwdHead;
        CwdHead = CwdHead->Next;
        FreePool (Cwd);
    }

    if (Info) {
        FreePool (Info);
    }

    if (Handle) {
        Handle->Close (Handle);
    }

    return Str.str;
}

    
VOID
SEnvFreeFileArg (
    IN SHELL_FILE_ARG   *Arg
    )
{
    if (Arg->Parent) {
        Arg->Parent->Close (Arg->Parent);
    }

    if (Arg->ParentName) {
        FreePool (Arg->ParentName);
    }

    if (Arg->ParentDevicePath) {
        FreePool (Arg->ParentDevicePath);
    }

    if (Arg->FullName) {
        FreePool (Arg->FullName);
    }

    if (Arg->FileName) {
        FreePool (Arg->FileName);
    }

    if (Arg->Handle) {
        Arg->Handle->Close (Arg->Handle);
    }

    if (Arg->Info) {
        FreePool (Arg->Info);
    }

    if (Arg->Link.Flink) {
        RemoveEntryList (&Arg->Link);
    }

    FreePool(Arg);
}


EFI_STATUS
SEnvFreeFileList (
    IN OUT LIST_ENTRY       *ListHead
    )
{
    SHELL_FILE_ARG          *Arg;

    while (!IsListEmpty(ListHead)) {
        Arg = CR(ListHead->Flink, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        SEnvFreeFileArg (Arg);
    }

    return EFI_SUCCESS;
}



SHELL_FILE_ARG *
SEnvNewFileArg (
    IN EFI_FILE_HANDLE      Parent,
    IN UINT64               OpenMode,
    IN EFI_DEVICE_PATH      *ParentPath,
    IN CHAR16               *ParentName,
    IN CHAR16               *FileName
    )
{
    SHELL_FILE_ARG          *Arg;
    CHAR16                  *LPath, *p;
    UINTN                   Len;

    Arg = NULL;

    /* 
     *  Allocate a new arg structure
     */

    Arg = AllocateZeroPool (sizeof(SHELL_FILE_ARG));
    if (!Arg) {
        goto Done;
    }

    Arg->Signature = SHELL_FILE_ARG_SIGNATURE;
    Parent->Open (Parent, &Arg->Parent, L".", OpenMode, 0);
    Arg->ParentDevicePath = DuplicateDevicePath (ParentPath);
    Arg->ParentName = StrDuplicate(ParentName);
    if (!Arg->Parent || !Arg->ParentDevicePath || !Arg->ParentName) {
        Arg->Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    /* 
     *  Open the target file
     */

    Arg->Status = Parent->Open(
                    Parent,
                    &Arg->Handle,
                    FileName,
                    OpenMode,
                    0
                    );

    if (Arg->Status == EFI_WRITE_PROTECTED) {
        OpenMode = OpenMode & ~EFI_FILE_MODE_WRITE;
        Arg->Status = Parent->Open (
                        Parent,
                        &Arg->Handle,
                        FileName,
                        OpenMode,
                        0
                        );
    }

    Arg->OpenMode = OpenMode;
    if (Arg->Handle) {
        Arg->Info = LibFileInfo(Arg->Handle);
    }

    /* 
     *  Compute the file's full name
     */

    Arg->FileName = StrDuplicate(FileName);
    if (StriCmp (FileName, L".") == 0) {
        /*  it is the same as the parent */
        Arg->FullName = StrDuplicate(Arg->ParentName);
    } else if (StriCmp(FileName, L"..") == 0) {

        LPath = NULL;
        for (p=Arg->ParentName; *p; p++) {
            if (*p == L'\\') {
                LPath = p;
            }
        }

        if (LPath) {
            Arg->FullName = PoolPrint(L"%.*s", (UINTN) (LPath - Arg->ParentName), Arg->ParentName);
        }
    }

    if (!Arg->FullName) {
        /*  append filename to parent's name to get the file's full name */
        Len = StrLen(Arg->ParentName);
        if (Len && Arg->ParentName[Len-1] == '\\') {
            Len -= 1;
        }

        if (FileName[0] == '\\') {
            FileName += 1;
        }

        Arg->FullName = PoolPrint(L"%.*s\\%s", Len, Arg->ParentName, FileName);
    }

    if (!Arg->FileName || !Arg->FileName) {
        Arg->Status = EFI_OUT_OF_RESOURCES;
    }

Done:
    if (Arg && Arg->Status == EFI_OUT_OF_RESOURCES) {
        SEnvFreeFileArg (Arg);
        Arg = NULL;
    }

    if (Arg && !EFI_ERROR(Arg->Status) && !Arg->Handle) {
        Arg->Status = EFI_NOT_FOUND;
    }
    
    return Arg;
}


EFI_STATUS
SEnvFileMetaArg (
    IN CHAR16               *Path,
    IN OUT LIST_ENTRY       *ListHead
    )
{
    VARIABLE_ID             *Var;
    EFI_STATUS              Status;
    EFI_DEVICE_PATH         *RPath, *TPath;
    EFI_DEVICE_PATH         *ParentPath;
    FILEPATH_DEVICE_PATH    *FilePath;
    EFI_FILE_INFO           *Info;
    UINTN                   bs, BufferSize;
    EFI_FILE_HANDLE         Parent;
    SHELL_FILE_ARG          *Arg;
    CHAR16                  *ParentName;
    CHAR16                  *LPath, *p;
    UINT64                  OpenMode;
    BOOLEAN                 Found;

    RPath = NULL;
    Parent = NULL;
    ParentPath = NULL;
    ParentName = NULL;

    AcquireLock (&SEnvLock);

    BufferSize = SIZE_OF_EFI_FILE_INFO + 1024;
    Info = AllocatePool (BufferSize);
    if (!Info) {
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }

    /* 
     *  Get the device
     */

    Var = SEnvMapDeviceFromName (&Path);
    if (!Var) {
        Arg = AllocateZeroPool (sizeof(SHELL_FILE_ARG));
        Arg->Signature = SHELL_FILE_ARG_SIGNATURE;
        Arg->Status = EFI_NO_MAPPING;
        Arg->ParentName = StrDuplicate(Path);
        Arg->FullName = StrDuplicate(Path);
        Arg->FileName = StrDuplicate(Path);
        InsertTailList (ListHead, &Arg->Link);
        Status = EFI_SUCCESS;
        goto Done;
    } 

    ParentPath = DuplicateDevicePath ((EFI_DEVICE_PATH *) Var->u.Value);

    /* 
     *  If the path is realitve, append the current dir of the device to the dpath
     */

    if (*Path != '\\') {
        RPath = SEnvIFileNameToPath (Var->CurDir ? Var->CurDir : L"\\");
        TPath = AppendDevicePath (ParentPath, RPath);
        if (!RPath || !TPath) {
            Status = EFI_OUT_OF_RESOURCES;
            goto Done;
        }

        FreePool (ParentPath);
        FreePool (RPath);
        RPath = NULL;
        ParentPath = TPath;
    }

    /* 
     *  If there is a path before the last node of the name, then
     *  append it and strip path to the last node.
     */

    LPath = NULL;
    for(p=Path; *p; p++) {
        if (*p == '\\') {
            LPath = p;
        }
    }

    if (LPath) {
        *LPath = 0;
        RPath = SEnvIFileNameToPath(Path);
        TPath = AppendDevicePath (ParentPath, RPath);
        if (!RPath || !TPath) {
            Status = EFI_OUT_OF_RESOURCES;
            goto Done;
        }

        FreePool (ParentPath);
        FreePool (RPath);
        RPath = NULL;
        ParentPath = TPath;
        Path = LPath + 1;
    }

    /* 
     *  Open the parent dir
     */

    OpenMode = EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE;
    Parent = ShellOpenFilePath(ParentPath, OpenMode);
    if (!Parent) {
        OpenMode = EFI_FILE_MODE_READ;
        Parent = ShellOpenFilePath(ParentPath, OpenMode);
    }

    if (Parent) {
        p = SEnvFileHandleToFileName(Parent);
        if (p) {
            ParentName = PoolPrint(L"%s:%s", Var->Name, p);
            FreePool (p);
        }
    }

    if (!Parent) {
        Status = EFI_NOT_FOUND;
        goto Done;
    }

    bs = BufferSize;
    Status = Parent->GetInfo(Parent, &GenericFileInfo, &bs, Info);
    if (EFI_ERROR(Status)) {
        goto Done;
    }

    /* 
     *  Parent - file handle to parent directory
     *  ParentPath - device path of parent dir
     *  ParentName - name string of parent directory
     *  ParentGuid - last guid of parent path
     * 
     *  Path - remaining node name
     */

    /* 
     *  BUGBUG: if the name doesn't have any meta chars,
     *  then just open the one file
     */

    Found = FALSE;
    for (p=Path; *p && !Found; p++) {
        /*  BUGBUG: need to handle '^' */

        switch (*p) {
        case '*':
        case '[':
        case '?':
            Found = TRUE;
            break;
        }
    }

    if (!Found) {

        TPath = SEnvIFileNameToPath (Path);
        ASSERT (DevicePathType(TPath) == MEDIA_DEVICE_PATH && DevicePathSubType(TPath) == MEDIA_FILEPATH_DP);
        FilePath = (FILEPATH_DEVICE_PATH *) TPath;

        Arg = SEnvNewFileArg(Parent, OpenMode, ParentPath, ParentName, FilePath->PathName);
        FreePool (TPath);

        if (!Arg) {
            Status = EFI_OUT_OF_RESOURCES;
            goto Done;
        }

        InsertTailList (ListHead, &Arg->Link);

    } else {

        /* 
         *  Check all the files for matches
         */

        Parent->SetPosition (Parent, 0);

        Found = FALSE;
        for (; ;) {

            /* 
             *  Read each file entry
             */

            bs = BufferSize;
            Status = Parent->Read (Parent, &bs, Info);
            if (EFI_ERROR(Status) || bs == 0) {
                break;
            }

            /* 
             *  Skip "." and ".."
             */

            if (StriCmp(Info->FileName, L".") == 0 ||
                StriCmp(Info->FileName, L"..") == 0) {
                continue;
            }

            /* 
             *  See if this one matches
             */

            if (!MetaiMatch(Info->FileName, Path)) {
                continue;
            }

            Found = TRUE;
            Arg = SEnvNewFileArg(Parent, OpenMode, ParentPath, ParentName, Info->FileName);
            if (!Arg) {
                Status = EFI_OUT_OF_RESOURCES;
                goto Done;
            }

            InsertTailList (ListHead, &Arg->Link);

            /*  check next file entry */
        }

        /* 
         *  If no match was found, then add a not-found entry for this name
         */

        if (!Found) {
            Arg = SEnvNewFileArg(Parent, OpenMode, ParentPath, ParentName, Path);
            if (!Arg) {
                Status = EFI_OUT_OF_RESOURCES;
                goto Done;
            }

            Arg->Status = EFI_NOT_FOUND;
            InsertTailList (ListHead, &Arg->Link);
        }
    }


    /* 
     *  Done
     */

Done:
    ReleaseLock (&SEnvLock);

    if (Parent) {
        Parent->Close (Parent);
    }

    if (RPath) {
        FreePool (RPath);
    }

    if (ParentPath) {
        FreePool (ParentPath);
    }

    if (ParentName) {
        FreePool (ParentName);
    }

    if (Info) {
        FreePool (Info);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\exec.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    exec.c
    
Abstract:




Revision History

--*/

#include "shelle.h"


typedef struct {
    CHAR16          **Arg;
    UINTN           ArgIndex;

    BOOLEAN         Output;
    BOOLEAN         Quote;
    UINTN           AliasLevel;
    UINTN           MacroParan;
    UINTN           RecurseLevel;

    CHAR16          Buffer[MAX_ARG_LENGTH];
} PARSE_STATE;


typedef struct _SENV_OPEN_DIR {
    struct _SENV_OPEN_DIR       *Next;
    EFI_FILE_HANDLE             Handle;
} SENV_OPEN_DIR;

/* 
 *  Internal macros
 */

#define ArgTooLong(i) (i > MAX_ARG_LENGTH-sizeof(CHAR16))


/* 
 *  Internal prototypes
 */

EFI_STATUS
ShellParseStr (
    IN CHAR16               *Str,
    IN OUT PARSE_STATE      *ParseState
    );

EFI_STATUS
SEnvDoExecute (
    IN EFI_HANDLE           *ParentImageHandle,
    IN CHAR16               *CommandLine,
    IN ENV_SHELL_INTERFACE  *Shell,
    IN BOOLEAN              Output
    );

VOID
INTERNAL
SEnvLoadImage (
    IN EFI_HANDLE       ParentImage,
    IN CHAR16           *IName,
    OUT EFI_HANDLE      *pImageHandle,
    OUT EFI_FILE_HANDLE *pScriptsHandle
    );

/* 
 *   Parser driver function
 */

EFI_STATUS
SEnvStringToArg (
    IN CHAR16       *Str,
    IN BOOLEAN      Output,
    OUT CHAR16      ***pArgv,
    OUT UINT32      *pArgc
    )
{
    PARSE_STATE     ParseState;
    EFI_STATUS      Status;

    /* 
     *  Initialize a new state
     */

    ZeroMem (&ParseState, sizeof(ParseState));
    ParseState.Output = Output;
    ParseState.Arg = AllocateZeroPool (MAX_ARG_COUNT * sizeof(CHAR16 *));
    if (!ParseState.Arg) {
        return EFI_OUT_OF_RESOURCES;
    }

    /* 
     *  Parse the string
     */

    Status = ShellParseStr (Str, &ParseState);

    *pArgv = ParseState.Arg;
    *pArgc = (UINT32) ParseState.ArgIndex;

    /* 
     *  Done
     */

    return Status;
}


EFI_STATUS
ShellParseStr (
    IN CHAR16               *Str,
    IN OUT PARSE_STATE      *ParseState
    )
{
    EFI_STATUS              Status;
    CHAR16                  *Alias;
    CHAR16                  *NewArg;
    CHAR16                  *SubstituteStr;
    UINTN                   Index;
    BOOLEAN                 Literal; 
    BOOLEAN                 Comment;
    UINTN                   ArgNo;

    ParseState->RecurseLevel += 1;
    if (ParseState->RecurseLevel > 5) {
        DEBUG ((D_PARSE, "Recursive alias or macro\n"));
        if (ParseState->Output) {
            Print (L"Recursive alias or macro\n");
        }

        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    NewArg = ParseState->Buffer;

    while (*Str) {

        /* 
         *  Skip leading white space
         */
        
        if (IsWhiteSpace(*Str)) {
            Str += 1;
            continue;
        }

        /* 
         *  Pull this arg out of the string
         */

        Index = 0;
        Literal = FALSE;
        Comment = FALSE;
        while (*Str) {

            /* 
             *  If we have white space (or the ',' arg separator) and we are
             *  not in a quote or macro expansion, move to the next word
             */

            if ((IsWhiteSpace(*Str) || *Str == ',') &&
                !ParseState->Quote && !ParseState->MacroParan) {

                break;
            }

            /* 
             *  Check arg length
             */

            if ( ArgTooLong(Index) ) {
                DEBUG((D_PARSE, "Argument too long\n"));
                if (ParseState->Output) {
                    Print (L"Argument too long\n");
                }

                Status = EFI_INVALID_PARAMETER;
                goto Done;
            }

            /* 
             *  Check char
             */

            switch (*Str) {
            case '#':
                /*   Comment, discard the rest of the characters in the line */
                Comment = TRUE;
                while( *Str++ );
                break;

            case '%':
                if ( IsDigit(Str[1]) && IsWhiteSpace(Str[2]) ) {
                    /*  Found a script argument - substitute */
                    ArgNo = Str[1] - '0';
                    Status = SEnvBatchGetArg( ArgNo, &SubstituteStr );
                    if ( EFI_ERROR(Status) ) {
                        /*  if not found, just ignore, as if no arg */
                        DEBUG((D_PARSE, "Argument %d not found - ignored\n", ArgNo));
                        Status = EFI_SUCCESS;
                        goto Done;
                    }
                    if ( ArgTooLong(StrLen(SubstituteStr)) ) {
                        DEBUG((D_PARSE, "Argument too long\n"));
                        if (ParseState->Output) {
                            Print (L"Argument too long\n");
                        }
                        Status = EFI_INVALID_PARAMETER;
                        goto Done;
                    }

                    StrCpy( &NewArg[Index], SubstituteStr );
                    Index += StrLen( SubstituteStr );
                    Str += 1;

                } else if ( IsAlpha(Str[1]) && IsWhiteSpace(Str[2]) ) {
                    /* 
                     *   For loop index
                     */
                    Status = SEnvSubstituteForLoopIndex( Str, &SubstituteStr );
                    if ( EFI_ERROR(Status) ) {
                        goto Done;
                    }

                    if ( SubstituteStr ) {
                        /*   Found a match */

                        if ( ArgTooLong(StrLen(SubstituteStr)) ) {
                            DEBUG((D_PARSE, "Argument too long\n"));
                            if (ParseState->Output) {
                                Print (L"Argument too long\n");
                            }
                            Status = EFI_INVALID_PARAMETER;
                            goto Done;
                        }
                        StrCpy( &NewArg[Index], SubstituteStr );
                        Index += StrLen( SubstituteStr );
                        /*  only advance one char - standard processing will get the 2nd char */
                        Str += 1;   
                    }
                    /*  if no match then just continue without substitution */

                } else {
                    /* 
                     *  Found a variable of some kind
                     *   If there is another '%' before any whitespace, look for
                     *      an environment variable to substitute.
                     *   If there is no environment variable, then the arg is the 
                     *      literal string including the '%' signs; otherwise substitute
                     */
                    SubstituteStr = Str + 1;
                    while ( !IsWhiteSpace(*SubstituteStr) ) {
                        if ( *SubstituteStr == '%' ) {
                            CHAR16 *VarName;
                            UINTN  VarNameLen;

                            /* 
                             *   Extract the (potential) variable name
                             */

                            VarNameLen = SubstituteStr - (Str + 1);
                            VarName = AllocateZeroPool( (VarNameLen + 1)*sizeof(CHAR16) );
                            if ( !VarName ) {
                                Status = EFI_OUT_OF_RESOURCES;
                                goto Done;
                            }
                            CopyMem( VarName, Str+1, (VarNameLen + 1)*sizeof(CHAR16) );
                            VarName[VarNameLen] = (CHAR16)0x0000;

                            /* 
                             *   Check for special case "lasterror" variable
                             *   Otherwise just get the matching environment variable
                             */

                            if ( SEnvBatchVarIsLastError( VarName ) ) {
                                SubstituteStr = SEnvBatchGetLastError();
                            } else {
                                SubstituteStr = SEnvGetEnv( VarName );
                            }
                            FreePool( VarName );
                            if ( !SubstituteStr ) {
                                /*   Not found - this is OK, then just use the original 
                                 *   string %xxx% in the arg.  Note that we know that
                                 *   this loop will terminate, since we found the % b4 */
                                NewArg[Index++] = *Str;
                                Str += 1;
                                while ( *Str != '%' ) {
                                    NewArg[Index++] = *Str;
                                    Str += 1;
                                }
                                NewArg[Index++] = *Str;
                                Str += 1;
                            } else {
                                /*   Insert the variable's value in the new arg - 
                                 *   the arg may include more than just the variable */
                                if ( ArgTooLong( Index + StrLen(SubstituteStr) ) ) {
                                    DEBUG((D_PARSE, "Argument too long\n"));
                                    if (ParseState->Output) {
                                        Print (L"Argument too long\n");
                                    }
                                    Status = EFI_INVALID_PARAMETER;
                                    goto Done;
                                }
                                StrCpy( &NewArg[Index], SubstituteStr );
                                Index += StrLen(SubstituteStr);
                                Str += VarNameLen + 1;
                            }
                            break;
                        }
                        SubstituteStr += 1;
                    }  /* end while */
                }
                break;

            case '^':
                /*   Literal, don't process aliases on this arg */
                if (Str[1]) {
                    Str += 1;
                    NewArg[Index++] = *Str;
                    Literal = TRUE;
                }
                break;

            case '"':
                /*   Quoted string entry and exit */
                ParseState->Quote = !ParseState->Quote;
                break;

            case '(':
                if (ParseState->MacroParan) {
                    ParseState->MacroParan = ParseState->MacroParan + 1;
                }

                NewArg[Index++] = *Str;
                break;

            case ')':
                if (ParseState->MacroParan) {
                    /*  End of a macro - go evaluate it */
                    ParseState->MacroParan -= 1;

                    /*  BUGBUG: code not complete */
                    ASSERT (FALSE);
                    
                } else {
                    NewArg[Index++] = *Str;
                }
                break;

            case '$':
                /*  If this is a start of a macro, pick it up */
                if (Str[1] == '(') {
                    Str += 1;
                    ParseState->MacroParan += 1;
                }

                NewArg[Index++] = *Str;
                break;

            default:
                if (!IsValidChar(*Str)) {
                    DEBUG((D_PARSE, "Invalid char %x in string\n", *Str));
                    if (ParseState->Output) {
                        Print (L"Invalid char %x in string\n", *Str);
                    }
                    Status = EFI_INVALID_PARAMETER;
                    goto Done;
                }
                NewArg[Index++] = *Str;
                break;
            }

            /* 
             *  Next char
             */

            Str += 1;
        }

        /* 
         *  Make sure the macro was terminated
         */

        if (ParseState->MacroParan) {
            DEBUG ((D_PARSE, "Too many '$(' parans\n"));
            if (ParseState->Output) {
                Print (L"Too many '$(' parans\n");
            }
                    
            Status = EFI_INVALID_PARAMETER;
            goto Done;
        }

        /* 
         *  If the new argument string is empty and we have encountered a 
         *  comment, then skip it.  Otherwise we have a new arg
         */

        if ( Comment && Index == 0 ) {
            break;
        } else {
            NewArg[Index] = 0;
            Alias = NULL;
        }

        /* 
         *  If it was composed with a literal, do not check to see if the arg has an alias
         */

        Alias = NULL;
        if (!Literal  &&  !ParseState->AliasLevel  &&  ParseState->ArgIndex == 0) {
            Alias = SEnvGetAlias(NewArg);
        }

        /* 
         *  If there's an alias, parse it
         */

        if (Alias) {
            
            ParseState->AliasLevel += 1;
            Status = ShellParseStr (Alias, ParseState);
            ParseState->AliasLevel -= 1;

            if (EFI_ERROR(Status)) {
                goto Done;
            }

        } else {

            /* 
             *  Otherwise, copy the word to the arg array
             */

            ParseState->Arg[ParseState->ArgIndex] = StrDuplicate(NewArg);
            if (!ParseState->Arg[ParseState->ArgIndex]) {
                Status = EFI_OUT_OF_RESOURCES;
                break;
            }

            ParseState->ArgIndex += 1;
            if (ParseState->ArgIndex >= MAX_ARG_COUNT-1) {
                DEBUG ((D_PARSE, "Too many arguments: %d\n", ParseState->ArgIndex));
                if (ParseState->Output) {
                    Print(L"Too many arguments: %d\n", ParseState->ArgIndex);
                }

                Status = EFI_OUT_OF_RESOURCES;
                goto Done;
            }
        }

        /* 
         *  If last word ended with a comma, skip it to move to the next word
         */

        if (*Str == ',') {
            Str += 1;
        }
    }

    Status = EFI_SUCCESS;


Done:
    ParseState->RecurseLevel -= 1;
    if (EFI_ERROR(Status)) {
        /*  Free all the args allocated */
        for (Index=0; Index < ParseState->ArgIndex; Index++) {
            if (ParseState->Arg[Index]) {
                FreePool (ParseState->Arg[Index]);
                ParseState->Arg[Index] = NULL;
            }
        }

        ParseState->ArgIndex = 0;
    }

    return Status;
}

EFI_STATUS
SEnvRedirOutput (
    IN OUT ENV_SHELL_INTERFACE  *Shell,
    IN BOOLEAN                  Ascii,
    IN BOOLEAN                  Append,
    IN OUT UINTN                *NewArgc,
    IN OUT UINTN                *Index,
    OUT ENV_SHELL_REDIR_FILE    *Redir
    )
{
    CHAR16                      *FileName;
    EFI_STATUS                  Status;
    EFI_FILE_INFO               *Info;
    UINTN                       Size;
    CHAR16                      UnicodeMarker = UNICODE_BYTE_ORDER_MARK;
    UINT64                      FileMode;
    /* 
     *  Update args
     */

    if (!*NewArgc) {
        *NewArgc = *Index;
    }

    *Index += 1;
    if (*Index >= Shell->ShellInt.Argc) {
        return EFI_INVALID_PARAMETER;
    }

    if (Redir->Handle) {
        return EFI_INVALID_PARAMETER;
    }

    /* 
     *  Open the output file
     */

    Redir->Ascii = Ascii;
    Redir->WriteError = EFI_SUCCESS;
    FileName = Shell->ShellInt.Argv[*Index];
    Redir->FilePath = SEnvNameToPath(FileName);
    if (Redir->FilePath) {
        FileMode = EFI_FILE_MODE_WRITE | ((Append)? 0 : EFI_FILE_MODE_CREATE);
        Redir->File = ShellOpenFilePath(Redir->FilePath, FileMode);
        if (Append && !Redir->File) {
            /* 
             *  If file does not exist make a new one. And send us down the other path
             */
            FileMode |= EFI_FILE_MODE_CREATE;
            Redir->File = ShellOpenFilePath(Redir->FilePath, FileMode);
            Append = FALSE;
        }
    }

    if (!Redir->File) {
        Print(L"Could not open output file %hs\n", FileName);
        return EFI_INVALID_PARAMETER;
    }

    Info = LibFileInfo (Redir->File);
    ASSERT (Info);
    if (Append) {
        Size = sizeof(UnicodeMarker);
        Redir->File->Read (Redir->File, &Size, &UnicodeMarker);
        if ((UnicodeMarker == UNICODE_BYTE_ORDER_MARK) && Ascii) {
            Print(L"Could not Append Ascii to Unicode file %hs\n", FileName);
            return EFI_INVALID_PARAMETER;
        } else if ((UnicodeMarker != UNICODE_BYTE_ORDER_MARK) && !Ascii) {
            Print(L"Could not Append Unicode to Asci file %hs\n", FileName);
            return EFI_INVALID_PARAMETER;
        }
        /* 
         *  Seek to end of the file
         */
        Redir->File->SetPosition (Redir->File, (UINT64)-1);
    } else {
        /* 
         *  Truncate the file
         */
        Info->FileSize = 0;
        Size = SIZE_OF_EFI_FILE_INFO + StrSize(Info->FileName);
        if (Redir->File->SetInfo) {
            Redir->File->SetInfo (Redir->File, &GenericFileInfo, Size, Info);
        } else {
            DEBUG ((D_ERROR, "SEnvRedirOutput: SetInfo in filesystem driver not complete\n"));
        }
        FreePool (Info);

        if (!Ascii) {
            Size = sizeof(UnicodeMarker);
            Redir->File->Write(Redir->File, &Size, &UnicodeMarker);
        }
    }

    /* 
     *  Allocate a new handle
     */

    CopyMem(&Redir->Out, &SEnvConToIo, sizeof(SIMPLE_TEXT_OUTPUT_INTERFACE));
    Status = LibInstallProtocolInterfaces (
                    &Redir->Handle, 
                    &TextOutProtocol,       &Redir->Out,
                    &DevicePathProtocol,    Redir->FilePath,
                    NULL
                    );
    Redir->Signature = ENV_REDIR_SIGNATURE;
    ASSERT (!EFI_ERROR(Status));

    return EFI_SUCCESS;
}


EFI_STATUS
SEnvExecRedir (
    IN OUT ENV_SHELL_INTERFACE  *Shell
    )
{
    UINTN                   NewArgc;
    UINTN                   Index;
    UINTN                   RedirIndex;
    EFI_STATUS              Status;
    CHAR16                  *p;
    CHAR16                  LastChar;
    BOOLEAN                 Ascii;
    BOOLEAN                 Append;
    EFI_SYSTEM_TABLE        *SysTable;
    UINTN                   StringLen;
    BOOLEAN                 RedirStdOut;
    
    Status = EFI_SUCCESS;
    NewArgc = 0;
    SysTable = Shell->SystemTable;

    for (Index=1; Index < Shell->ShellInt.Argc && !EFI_ERROR(Status); Index += 1) {
        p = Shell->ShellInt.Argv[Index];

        /* 
         *  Trailing a or A means do ASCII default is unicode */
        StringLen = StrLen(p);
        LastChar = p[StringLen - 1];
        Ascii =  ((LastChar == 'a') || (LastChar == 'A'));

        RedirStdOut = FALSE;
        if (StrnCmp(p, L"2>", 2) == 0) {
            Status = SEnvRedirOutput (Shell, Ascii, FALSE, &NewArgc, &Index, &Shell->StdErr);
            SysTable->StdErr = &Shell->StdErr.Out;
            SysTable->StandardErrorHandle = Shell->StdErr.Handle;
            Shell->ShellInt.StdErr = Shell->StdErr.File;
        } else if (StrnCmp(p, L"1>", 2) == 0) {
            Append = (p[2] == '>');
            RedirStdOut = TRUE;
        } else if (*p == '>') {
            Append = (p[1] == '>');
            RedirStdOut = TRUE;
        }
        if (RedirStdOut) {
            Status = SEnvRedirOutput (Shell, Ascii, Append, &NewArgc, &Index, &Shell->StdOut);
            SysTable->ConOut = &Shell->StdOut.Out;
            SysTable->ConsoleOutHandle = Shell->StdOut.Handle;
            Shell->ShellInt.StdOut = Shell->StdOut.File;
        }
    }

    /* 
     *   Strip redirection args from arglist, saving in RedirArgv so they can be
     *   echoed in batch scripts.
     */

    if (NewArgc) {
        Shell->ShellInt.RedirArgc = Shell->ShellInt.Argc - (UINT32) NewArgc;
        Shell->ShellInt.RedirArgv = AllocateZeroPool (Shell->ShellInt.RedirArgc * sizeof(CHAR16 *));
        if ( !Shell->ShellInt.RedirArgv ) {
            Status = EFI_OUT_OF_RESOURCES;
            goto Done;
        }
        RedirIndex = 0;
        for (Index = NewArgc; Index < Shell->ShellInt.Argc; Index += 1) {
            Shell->ShellInt.RedirArgv[RedirIndex++] = Shell->ShellInt.Argv[Index];
            Shell->ShellInt.Argv[Index] = NULL;
        }
        Shell->ShellInt.Argc = (UINT32) NewArgc;
    } else {
        Shell->ShellInt.RedirArgc = 0;
        Shell->ShellInt.RedirArgv = NULL;
    }

Done:
    return Status;
}

VOID
SEnvCloseRedir (
    IN OUT ENV_SHELL_REDIR_FILE    *Redir
    )
{
    if (Redir->File) {
        Redir->File->Close (Redir->File);
    }
    
    if (Redir->Handle) {
        BS->UninstallProtocolInterface (Redir->Handle, &TextOutProtocol, &Redir->Out);
        BS->UninstallProtocolInterface (Redir->Handle, &TextInProtocol, &Redir->In);
        BS->UninstallProtocolInterface (Redir->Handle, &DevicePathProtocol, Redir->FilePath);
        FreePool (Redir->FilePath);
    }
}
        


EFI_STATUS
SEnvDoExecute (
    IN EFI_HANDLE           *ParentImageHandle,
    IN CHAR16               *CommandLine,
    IN ENV_SHELL_INTERFACE  *Shell,
    IN BOOLEAN              Output
    )
{
    EFI_SHELL_INTERFACE         *ParentShell;
    EFI_SYSTEM_TABLE            *ParentSystemTable;
    EFI_STATUS                  Status;
    UINTN                       Index;
    SHELLENV_INTERNAL_COMMAND   InternalCommand;
    EFI_HANDLE                  NewImage;
    EFI_FILE_HANDLE             Script;

    /* 
     *  Switch output attribute to normal
     */

    Print (L"%N");

    /* 
     *   Chck that there is something to do
     */

    if (Shell->ShellInt.Argc < 1) {
        goto Done;
    }

    /* 
     *  Handle special case of the internal "set default device command"
     *  Is it one argument that ends with a ":"?
     */

    Index = StrLen(Shell->ShellInt.Argv[0]);
    if (Shell->ShellInt.Argc == 1 && Shell->ShellInt.Argv[0][Index-1] == ':') {
        Status = SEnvSetCurrentDevice (Shell->ShellInt.Argv[0]);
        goto Done;
    }

    /* 
     *  Assume some defaults
     */

    BS->HandleProtocol (ParentImageHandle, &LoadedImageProtocol, (VOID*)&Shell->ShellInt.Info);
    Shell->ShellInt.ImageHandle = ParentImageHandle;
    Shell->ShellInt.StdIn  = &SEnvIOFromCon;
    Shell->ShellInt.StdOut = &SEnvIOFromCon;
    Shell->ShellInt.StdErr = &SEnvErrIOFromCon;

    /* 
     *  Get parent's image stdout & stdin
     */

    Status = BS->HandleProtocol (ParentImageHandle, &ShellInterfaceProtocol, (VOID*)&ParentShell);
    if (EFI_ERROR(Status)) {
        goto Done;
    }

    ParentSystemTable = ParentShell->Info->SystemTable;
    Shell->ShellInt.StdIn  = ParentShell->StdIn;
    Shell->ShellInt.StdOut = ParentShell->StdOut;
    Shell->ShellInt.StdErr = ParentShell->StdErr;

    Shell->SystemTable = NULL;
    Status = BS->AllocatePool(EfiRuntimeServicesData, 
                              sizeof(EFI_SYSTEM_TABLE), 
                              (VOID **)&Shell->SystemTable);
    if (EFI_ERROR(Status)) {
        goto Done;
    }
    CopyMem (Shell->SystemTable, Shell->ShellInt.Info->SystemTable, sizeof(EFI_SYSTEM_TABLE));
    Status = SEnvExecRedir (Shell);
    SetCrc (&Shell->SystemTable->Hdr);
    if (EFI_ERROR(Status)) {
        goto Done;
    }

    /* 
     *  Attempt to dispatch it as an internal command
     */

    InternalCommand = SEnvGetCmdDispath(Shell->ShellInt.Argv[0]);
    if (InternalCommand) {

        /*  Push & replace the current shell info on the parent image handle.  (note we are using
         *  the parent image's loaded image information structure) */
        BS->ReinstallProtocolInterface (ParentImageHandle, &ShellInterfaceProtocol, ParentShell, &Shell->ShellInt);
        ParentShell->Info->SystemTable = Shell->SystemTable;

        InitializeShellApplication (ParentImageHandle, Shell->SystemTable);
        SEnvBatchEchoCommand( Shell );

        /*  Dispatch the command */
        Status = InternalCommand (ParentImageHandle, Shell->ShellInt.Info->SystemTable);

        /*  Restore the parent's image handle shell info */
        BS->ReinstallProtocolInterface (ParentImageHandle, &ShellInterfaceProtocol, &Shell->ShellInt, ParentShell);
        ParentShell->Info->SystemTable = ParentSystemTable;
        InitializeShellApplication (ParentImageHandle, ParentSystemTable);
        goto Done;
    }

    /* 
     *  Load the app, or open the script
     */

    SEnvLoadImage(ParentImageHandle, Shell->ShellInt.Argv[0], &NewImage, &Script);
    if (!NewImage  && !Script) {
        if ( Output ) {
            Print(L"'%es' not found\n", Shell->ShellInt.Argv[0]);
        }
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    if (NewImage) {
        CHAR16  *CurrentDir;
        CHAR16  *OptionsBuffer;
        UINT32  OptionsSize;

        /* 
         *  Put the shell info on the handle
         */

        BS->HandleProtocol (NewImage, &LoadedImageProtocol, (VOID*)&Shell->ShellInt.Info);
        LibInstallProtocolInterfaces (&NewImage, &ShellInterfaceProtocol, &Shell->ShellInt, NULL);

        /* 
         *  Create load options which may include command line and current
         *  working directory
         */

        CurrentDir = SEnvGetCurDir(NULL);
        OptionsSize = (UINT32)StrSize(CommandLine);     /*  StrSize includes NULL */
        if (CurrentDir)
            OptionsSize += (UINT32)StrSize(CurrentDir); /*  StrSize includes NULL */
        OptionsBuffer = AllocateZeroPool (OptionsSize);

        if (OptionsBuffer) {

            /* 
             *  Set the buffer before we manipulate it.
             */

            Shell->ShellInt.Info->LoadOptions = OptionsBuffer;
            Shell->ShellInt.Info->LoadOptionsSize = OptionsSize;

            /* 
             *  Copy the comamand line and current working directory
             */

            StrCpy ((CHAR16*)OptionsBuffer, CommandLine);
            if (CurrentDir)
                StrCpy (&OptionsBuffer[ StrLen (CommandLine) + 1 ], CurrentDir);

        } else {

            Shell->ShellInt.Info->LoadOptions = CommandLine;
            Shell->ShellInt.Info->LoadOptionsSize = (UINT32) StrSize(CommandLine);

        }

        /* 
         *  Pass a copy of the system table with new input & outputs
         */

        Shell->ShellInt.Info->SystemTable = Shell->SystemTable;

        /* 
         *  If the image is an app start it, else abort it
         */

        if (Shell->ShellInt.Info->ImageCodeType == EfiLoaderCode) {

            InitializeShellApplication (ParentImageHandle, Shell->SystemTable);
            SEnvBatchEchoCommand( Shell );

            Status = BS->StartImage (NewImage, 0, NULL);

        } else {

            Print (L"Image is not a application\n");
            BS->Exit(NewImage, EFI_INVALID_PARAMETER, 0, NULL);
            Status = EFI_INVALID_PARAMETER;

        }

        /* 
         *  App has exited, remove our data from the image handle
         */

        if (OptionsBuffer) {
            BS->FreePool (OptionsBuffer);
        }

        BS->UninstallProtocolInterface(NewImage, &ShellInterfaceProtocol, &Shell->ShellInt);
        InitializeShellApplication (ParentImageHandle, ParentSystemTable);

    } else if ( Script ) {

        SEnvBatchEchoCommand( Shell );

        /*  Push & replace the current shell info on the parent image handle.  (note we are using
         *  the parent image's loaded image information structure) */
        BS->ReinstallProtocolInterface (ParentImageHandle, &ShellInterfaceProtocol, ParentShell, &Shell->ShellInt);
        ParentShell->Info->SystemTable = Shell->SystemTable;

        Status = SEnvExecuteScript( Shell, Script );

        /*  Restore the parent's image handle shell info */
        BS->ReinstallProtocolInterface (ParentImageHandle, &ShellInterfaceProtocol, &Shell->ShellInt, ParentShell);
        ParentShell->Info->SystemTable = ParentSystemTable;
        InitializeShellApplication (ParentImageHandle, ParentSystemTable);
    }
    
Done:

    SEnvBatchSetLastError( Status );
    if (EFI_ERROR(Status)  &&  Output) {
        Print (L"Exit status code: %r\n", Status);
    }


    /* 
     *  Cleanup
     */

    if (Shell) {

        /* 
         *  Free copy of the system table
         */

        if (Shell->SystemTable) {
            BS->FreePool(Shell->SystemTable);
        }

        /* 
         *  If there's an arg list, free it
         */

        if (Shell->ShellInt.Argv) {
            for (Index=0; Index < Shell->ShellInt.Argc; Index += 1) {
                FreePool (Shell->ShellInt.Argv[Index]);
            }

            FreePool (Shell->ShellInt.Argv);
        }

        /* 
         *   If any redirection arguments were saved, free them
         */

        if (Shell->ShellInt.RedirArgv) {
            for (Index=0; Index < Shell->ShellInt.RedirArgc; Index++ ) {
                FreePool( Shell->ShellInt.RedirArgv[Index] );
            }
            FreePool( Shell->ShellInt.RedirArgv );
        }

        /* 
         *  Close any file redirection
         */

        SEnvCloseRedir(&Shell->StdOut);
        SEnvCloseRedir(&Shell->StdErr);
        SEnvCloseRedir(&Shell->StdIn);
    }

    /* 
     *  Switch output attribute to normal
     */

    Print (L"%N");

    return Status;
}


EFI_STATUS
SEnvExecute (
    IN EFI_HANDLE           *ParentImageHandle,
    IN CHAR16               *CommandLine,
    IN BOOLEAN              Output
    )
{
    ENV_SHELL_INTERFACE     Shell;
    EFI_STATUS              Status = EFI_SUCCESS;

    /* 
     *  Convert the command line to an arg list
     */

    ZeroMem( &Shell, sizeof(Shell ) );
    Status = SEnvStringToArg( CommandLine, Output, &Shell.ShellInt.Argv, &Shell.ShellInt.Argc );
    if (EFI_ERROR(Status)) {
        goto Done;
    }

    /* 
     *   Execute the command
     */
    Status = SEnvDoExecute( ParentImageHandle, CommandLine, &Shell, Output );
    if (EFI_ERROR(Status)) {
        goto Done;
    }

Done:
    return Status;
}




VOID
INTERNAL
SEnvLoadImage (
    IN EFI_HANDLE           ParentImage,
    IN CHAR16               *IName,
    OUT EFI_HANDLE          *pImageHandle,
    OUT EFI_FILE_HANDLE     *pScriptHandle
    )
{
    CHAR16                  *Path;
    CHAR16                  *p1, *p2;
    CHAR16                  *PathName;
    EFI_DEVICE_PATH         *DevicePath;
    FILEPATH_DEVICE_PATH    *FilePath;
    CHAR16                  *FilePathStr;
    CHAR16                  c;
    EFI_HANDLE              ImageHandle;
    EFI_STATUS              Status;
    SENV_OPEN_DIR           *OpenDir, *OpenDirHead;
    EFI_FILE_HANDLE         ScriptHandle;

    PathName = NULL;
    DevicePath = NULL;
    FilePathStr = NULL;
    ImageHandle = NULL;
    ScriptHandle = NULL;
    OpenDirHead = NULL;
    *pImageHandle = NULL;
    *pScriptHandle = NULL;

    /* 
     *  Get the path variable 
     */

    Path = SEnvGetEnv (L"path");
    if (!Path) {
        DEBUG ((D_PARSE, "SEnvLoadImage: no path variable\n"));
        return ;
    }

    p1 = StrDuplicate(Path);
    Path = p1;

    /* 
     *  Search each path component
     *  (using simple ';' as separator here - oh well)
     */

    c = *Path;
    for (p1=Path; *p1 && c; p1=p2+1) {
        for (p2=p1; *p2 && *p2 != ';'; p2++) ;

        if (p1 != p2) {
            c = *p2;
            *p2 = 0;        /*  null terminate the path */

            /* 
             *  Open the directory 
             */

            DevicePath = SEnvNameToPath(p1);
            if (!DevicePath) {
                continue;
            }

            OpenDir = AllocateZeroPool (sizeof(SENV_OPEN_DIR));
            if (!OpenDir) {
                break;
            }

            OpenDir->Handle = ShellOpenFilePath(DevicePath, EFI_FILE_MODE_READ);
            OpenDir->Next = OpenDirHead;
            OpenDirHead = OpenDir;
            FreePool (DevicePath);
            DevicePath = NULL;
            if (!OpenDir->Handle) {
                continue;
            }

            /* 
             *  Attempt to open it as an execuatble 
             */

            PathName = (p2[-1] == ':' || p2[-1] == '\\') ? L"%s%s.efi" : L"%s\\%s.efi";
            PathName = PoolPrint(PathName, p1, IName);
            if (!PathName) {
                break;
            }

            DevicePath = SEnvNameToPath(PathName);
            if (!DevicePath) {
                continue;
            }

            /* 
             *  Print the file path
             */

            FilePathStr = DevicePathToStr(DevicePath);
            /* DEBUG((D_PARSE, "SEnvLoadImage: load %hs\n", FilePathStr)); */

            /* 
             *  Attempt to load the image
             */

            Status = BS->LoadImage (FALSE, ParentImage, DevicePath, NULL, 0, &ImageHandle);
            if (!EFI_ERROR(Status)) {
                goto Done;
            }

            /* 
             *  Try as a ".nsh" file
             */

            FreePool(DevicePath);
            FreePool(PathName);
            DevicePath = NULL;
            PathName = NULL;

            if ( StriCmp( L".nsh", &(IName[StrLen(IName)-4]) ) == 0 ) {

                /*   User entered entire filename with .nsh extension */
                PathName = PoolPrint (L"%s", IName);

            } else {

                /*   User entered filename without .nsh extension */
                PathName = PoolPrint (L"%s.nsh", IName);
            }
            if (!PathName) {
                break;
            }

            DevicePath = SEnvFileNameToPath(PathName);
            if (DevicePath) {
                ASSERT (
                    DevicePathType(DevicePath) == MEDIA_DEVICE_PATH && 
                    DevicePathSubType(DevicePath) == MEDIA_FILEPATH_DP
                    );

                FilePath = (FILEPATH_DEVICE_PATH *) DevicePath;
                
                Status = OpenDir->Handle->Open (
                            OpenDir->Handle,
                            &ScriptHandle,
                            FilePath->PathName,
                            EFI_FILE_MODE_READ,
                            0
                            );

                FreePool(DevicePath);
                DevicePath = NULL;

                if (!EFI_ERROR(Status)) {
                    goto Done;
                }
            }

            ScriptHandle = NULL;            /*  BUGBUG */
        }    

        
        if (DevicePath) {
            FreePool (DevicePath);
            DevicePath = NULL;
        }

        if (PathName) {
            FreePool (PathName);
            PathName = NULL;
        }

        if (FilePathStr) {
            FreePool (FilePathStr);
            FilePathStr = NULL;
        }
    }


Done:
    while (OpenDirHead) {
        if (OpenDirHead->Handle) {
            OpenDirHead->Handle->Close (OpenDirHead->Handle);
        }
        OpenDir = OpenDirHead->Next;
        FreePool (OpenDirHead);
        OpenDirHead = OpenDir;
    }

    FreePool (Path);

    if (DevicePath) {
        FreePool (DevicePath);
        DevicePath = NULL;
    }

    if (PathName) {
        FreePool (PathName);
        PathName = NULL;
    }

    if (FilePathStr) {
        FreePool (FilePathStr);
        FilePathStr = NULL;
    }

    if (ImageHandle) {
        ASSERT (!ScriptHandle);
        *pImageHandle = ImageHandle;
    }

    if (ScriptHandle) {
        ASSERT (!ImageHandle);
        *pScriptHandle = ScriptHandle;
    }
}



EFI_STATUS
SEnvExit (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
{
    /*  BUGBUG: for now just use a "magic" return code to indicate EOF */
    return  -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\for.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    for.c
    
Abstract:

    Internal Shell cmd "for" & "endfor"



Revision History

--*/

#include "shelle.h"


/* 
 *  Datatypes
 */

#define FOR_LOOP_INFO_SIGNATURE EFI_SIGNATURE_32('f','l','i','s')
typedef struct {
    UINTN           Signature;
    LIST_ENTRY      Link;
    UINT64          LoopFilePos;
    CHAR16          *IndexVarName;
    LIST_ENTRY      IndexValueList;
} FOR_LOOP_INFO;

#define FOR_LOOP_INDEXVAL_SIGNATURE EFI_SIGNATURE_32('f','l','v','s')
typedef struct {
    UINTN           Signature;
    LIST_ENTRY      Link;
    CHAR16          *Value;
} FOR_LOOP_INDEXVAL;

/* 
 *   Statics
 */

STATIC LIST_ENTRY ForLoopInfoStack;
STATIC UINTN      NumActiveForLoops;

VOID
DumpForLoopInfoStack(VOID)
{
    LIST_ENTRY          *InfoLink;
    LIST_ENTRY          *IndexLink;
    FOR_LOOP_INFO       *LoopInfo;
    FOR_LOOP_INDEXVAL   *LoopIndexVal;

    Print( L"FOR LOOP INFO STACK DUMP\n" );
    for ( InfoLink = ForLoopInfoStack.Flink; InfoLink!=&ForLoopInfoStack; InfoLink=InfoLink->Flink) {
        LoopInfo = CR(InfoLink, FOR_LOOP_INFO, Link, FOR_LOOP_INFO_SIGNATURE);
        if ( LoopInfo ) {
            Print( L"  LoopFilePos 0x%X\n", LoopInfo->LoopFilePos );
            Print( L"  IndexVarName %s (0x%X)\n", LoopInfo->IndexVarName, LoopInfo->IndexVarName );
            for ( IndexLink = LoopInfo->IndexValueList.Flink; IndexLink!=&LoopInfo->IndexValueList; IndexLink=IndexLink->Flink ) {
                LoopIndexVal = CR(IndexLink, FOR_LOOP_INDEXVAL, Link, FOR_LOOP_INDEXVAL_SIGNATURE);
                if ( LoopIndexVal ) {
                    if ( LoopIndexVal->Value ) {
                        Print( L"    Loop index value %s\n", LoopIndexVal->Value );
                    } else {
                        Print( L"    Loop index value is NULL\n" );
                    }
                } else {
                    Print( L"    Loop index value structure pointer is NULL\n" );
                }
            }
        } else {
            Print( L"  LoopInfo NULL\n" );
        }
    }
    return;
}

/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvInitForLoopInfo

    Description:
        Initialize data structures used in or loop management.
*/
VOID
SEnvInitForLoopInfo (
    VOID
    )
{
    InitializeListHead( &ForLoopInfoStack );
    NumActiveForLoops = 0;
    return;
}

/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvSubstituteForLoopIndex

    Description:
        Builtin shell command "for" for conditional execution in script files.
*/
EFI_STATUS
SEnvSubstituteForLoopIndex( 
    IN CHAR16  *Str,
    OUT CHAR16 **Val
    )
{
    LIST_ENTRY          *InfoLink       = NULL;
    LIST_ENTRY          *IndexLink      = NULL;
    FOR_LOOP_INFO       *LoopInfo       = NULL;
    FOR_LOOP_INDEXVAL   *LoopIndexVal   = NULL;
    EFI_STATUS          Status          = EFI_SUCCESS;

    /* 
     *   Check if Str is a forloop index variable name on the forloop info stack
     *   If it is, return the current value
     *   Otherwise, just return the string.
     */

    if ( Str[0] != L'%' || !IsWhiteSpace(Str[2]) ) {
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *   We may have nested for loops, so we have to search through the variables for 
     *   each for loop on the stack to see if we can match the variable name.
     */
    for ( InfoLink = ForLoopInfoStack.Flink; InfoLink!=&ForLoopInfoStack; InfoLink=InfoLink->Flink) {
        LoopInfo = CR(InfoLink, FOR_LOOP_INFO, Link, FOR_LOOP_INFO_SIGNATURE);
        if ( LoopInfo ) {
            if ( Str[1] == LoopInfo->IndexVarName[0] ) {
                /*   Found a match */
                IndexLink = LoopInfo->IndexValueList.Flink;
                LoopIndexVal = CR(IndexLink, FOR_LOOP_INDEXVAL, Link, FOR_LOOP_INDEXVAL_SIGNATURE);
                if ( LoopIndexVal && LoopIndexVal->Value ) {
                    *Val = LoopIndexVal->Value;
                    Status = EFI_SUCCESS;
                    goto Done;
                } else {
                    Status = EFI_INVALID_PARAMETER;
                    goto Done;
                }
            }
        }
    }
    *Val = NULL;

Done:
    return Status;
}


/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdFor

    Description:
        Builtin shell command "for" for conditional execution in script files.
*/
EFI_STATUS
SEnvCmdFor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc         = 0;
    UINTN                   Index        = 0;
    EFI_STATUS              Status       = EFI_SUCCESS;
    UINTN                   i            = 0;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link        = NULL;
    SHELL_FILE_ARG          *Arg         = NULL;
    FOR_LOOP_INFO           *NewInfo     = NULL;
    FOR_LOOP_INDEXVAL       *NewIndexVal = NULL;

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    InitializeListHead( &FileList );

    if ( !SEnvBatchIsActive() ) {
        Print( L"Error: FOR command only supported in script files\n" );
        Status = EFI_UNSUPPORTED;
        goto Done;
    }

    /* 
     *   First, parse the command line arguments
     * 
     *   for %<var> in <string | file [[string | file]...]>
     */

    if ( Argc < 4 || 
         (StriCmp( Argv[2], L"in" ) != 0) || 
         !(StrLen(Argv[1]) == 1 && IsAlpha(Argv[1][0]) ) )
    {
        Print( L"Argc %d, Argv[2] %s, StrLen(Argv[1]) %d, Argv[1][0] %c\n", Argc, Argv[2], StrLen(Argv[1]), Argv[1][0] );
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *   Allocate a new forloop info structure for this for loop, and
     *   puch it on the for loop info stack.
     */
    NewInfo = AllocateZeroPool( sizeof( FOR_LOOP_INFO ) );
    if ( !NewInfo ) {
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
    }
    NewInfo->Signature = FOR_LOOP_INFO_SIGNATURE;
    InsertHeadList( &ForLoopInfoStack, &NewInfo->Link );

    /* 
     *   Save the current script file position and the index variable name on 
     *   the for-loop info stack.  Increment the active-for-loop counter.
     */
    SEnvBatchGetFilePos( &NewInfo->LoopFilePos );
    InitializeListHead( &NewInfo->IndexValueList );
    NumActiveForLoops++;
    NewInfo->IndexVarName = StrDuplicate( Argv[1] );

    /* 
     *   Put the set of index values in the index value list for this for loop
     */
    for ( i=3; i<Argc; i++ ) {

        /* 
         *   Expand any wildcard filename arguments
         *   Strings and non-wildcard filenames will accumulate in FileList
         */

        Status = ShellFileMetaArg( Argv[i], &FileList);
        if ( EFI_ERROR( Status ) ) {
            Print( L"ShellFileMetaArg error: %r\n", Status );
        }

        /* 
         *   Build the list of index values from the file list
         *   This will contain either the unexpanded argument or
         *   all the filenames matching an argument with wildcards
         */

        for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
            Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);

            NewIndexVal = AllocateZeroPool( sizeof(FOR_LOOP_INDEXVAL) );
            if ( !NewIndexVal ) {
                Status = EFI_OUT_OF_RESOURCES;
                goto Done;
            }
            NewIndexVal->Signature = FOR_LOOP_INDEXVAL_SIGNATURE;
            InsertTailList( &NewInfo->IndexValueList, &NewIndexVal->Link );

            NewIndexVal->Value = AllocateZeroPool( StrSize(Arg->FileName) + sizeof(CHAR16) );
            if ( !NewIndexVal->Value ) {
                Status = EFI_OUT_OF_RESOURCES;
                goto Done;
            }

            StrCpy( NewIndexVal->Value, Arg->FileName );
        }

        /* 
         *   Free the file list that was allocated by ShellFileMetaArg
         */
        ShellFreeFileList (&FileList);
    }

 

    /* 
     *   Return control to the batch processing loop until an ENDFOR is encountered
     */

Done:
    /* 
     *   Free the file list
     */
    if ( !IsListEmpty( &FileList ) ) {
        ShellFreeFileList (&FileList);
    }

    return Status;
}




/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdEndfor

    Description:
        Builtin shell command "endfor".
*/
EFI_STATUS
SEnvCmdEndfor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_STATUS              Status        = EFI_SUCCESS;
    LIST_ENTRY              *InfoLink     = NULL;
    LIST_ENTRY              *IndexLink    = NULL;
    FOR_LOOP_INFO           *LoopInfo     = NULL;
    FOR_LOOP_INDEXVAL       *LoopIndexVal = NULL;

    InitializeShellApplication (ImageHandle, SystemTable);

    if ( !SEnvBatchIsActive() ) {
        Print( L"Error: ENDFOR command only supported in script files\n" );
        Status = EFI_UNSUPPORTED;
        goto Done;
    }

    if ( NumActiveForLoops == 0 ) {
        Print( L"Error: ENDFOR with no corresponding FOR\n" );
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *   Discard the index value for the just-completed iteration
     */

    /*   Get a pointer to the FOR_LOOP_INFO structure at the top of the stack (list) */
    InfoLink = ForLoopInfoStack.Flink;
    LoopInfo = CR(InfoLink, FOR_LOOP_INFO, Link, FOR_LOOP_INFO_SIGNATURE);
    if ( LoopInfo ) {

        /*   Get a pointer to the FOR_LOOP_INDEXVAL structure at the front of the list */
        IndexLink = LoopInfo->IndexValueList.Flink;
        LoopIndexVal = CR(IndexLink, FOR_LOOP_INDEXVAL, Link, FOR_LOOP_INDEXVAL_SIGNATURE);
        if ( LoopIndexVal ) {

            /*   Free the string containing the index value */
            if ( LoopIndexVal->Value ) {
                FreePool( LoopIndexVal->Value );
                LoopIndexVal->Value = NULL;
            }

            /*   Remove the used index value structure from the list and free it */
            RemoveEntryList( &LoopIndexVal->Link );
            FreePool( LoopIndexVal );
            LoopIndexVal = NULL;

            /* 
             *   If there is another value, then jump back to top of loop,
             *   otherwise, exit this FOR loop & pop the FOR loop info stack.
             */

            if ( !IsListEmpty( &LoopInfo->IndexValueList ) ) {
                /* 
                 *   Set script file position back to top of this loop
                 */
                Status = SEnvBatchSetFilePos( LoopInfo->LoopFilePos );
                if ( EFI_ERROR(Status) ) {
                    goto Done;
                }

            } else {

                if ( LoopInfo->IndexVarName ) {
                    FreePool( LoopInfo->IndexVarName );
                    LoopInfo->IndexVarName = NULL;
                }

                /* 
                 *   Pop the stack and free the popped for loop info struct
                 */
                RemoveEntryList( &LoopInfo->Link );
                if ( LoopInfo->IndexVarName ) {
                    FreePool( LoopInfo->IndexVarName );
                }
                FreePool( LoopInfo );
                LoopInfo = NULL;
                NumActiveForLoops--;
            }
        }
    }

Done:
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\map.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    map.c
    
Abstract:

    Shell environment short device name mapping information management



Revision History

--*/

#include "shelle.h"

/* 
 * 
 */

extern LIST_ENTRY SEnvMap;
STATIC CHAR16 *SEnvCurDevice;


/* 
 * 
 */

VOID
SEnvInitMap (
    VOID
    )
{
    /* 
     *  The mapping data is read in from the variable init.
     */

    /* 
     *  Init the default map device
     */

    SEnvCurDevice = StrDuplicate(L"none");
}

CHAR16 *
SEnvGetDefaultMapping (
    IN EFI_HANDLE           ImageHandle
    )

{
    EFI_LOADED_IMAGE *LoadedImage;
    EFI_STATUS       Status;
    LIST_ENTRY       *Head;
    LIST_ENTRY       *Link;
    VARIABLE_ID      *Var;
    EFI_HANDLE       Handle;
    EFI_DEVICE_PATH  *DevicePath;

    Status = BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID*)&LoadedImage);
    if (EFI_ERROR(Status) || LoadedImage==NULL) {
        return NULL;
    }
    Head = &SEnvMap;
    for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
        Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
        DevicePath = (EFI_DEVICE_PATH *)Var->u.Str;
        Status = BS->LocateDevicePath(&DevicePathProtocol,&DevicePath,&Handle);
        if (!EFI_ERROR(Status) && Handle!=NULL) {
            if (LoadedImage->DeviceHandle == Handle) {
                return(Var->Name);
            }
        }
    }
    return NULL;
}


VOID
SEnvDumpMapping(
    IN UINTN            SLen,
    IN BOOLEAN          Verbose,
    IN VARIABLE_ID      *Var
    )
{
    CHAR16              *p;
    EFI_DEVICE_PATH     *DPath;
    EFI_STATUS          Status;
    EFI_HANDLE          DeviceHandle;

    p = DevicePathToStr ((EFI_DEVICE_PATH *) Var->u.Str);
    Print(L"  %h-.*s : %s\n", SLen, Var->Name, p);

    if (Verbose) {
        /*  lookup handle for this mapping */
        DPath = (EFI_DEVICE_PATH *) Var->u.Value;
        Status = BS->LocateDevicePath (&DevicePathProtocol, &DPath, &DeviceHandle);
        if (EFI_ERROR(Status)) {
            Print(L"%*s= Handle for this mapping not found\n", SLen+3);
        } else {
            Print(L"%*s= Handle", SLen + 3, L"");
            SEnvDHProt (FALSE, 0, DeviceHandle);
        }

        /*  print current directory for this mapping */
        Print(L"%*s> %s\n\n", SLen+3, L"", Var->CurDir ? Var->CurDir : L"\\");
    }
    
    FreePool (p);
}


EFI_STATUS
SEnvCmdMap (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*  Code for internal "map" command */
{
    LIST_ENTRY                  *Link, *Head;
    VARIABLE_ID                 *Var;
    VARIABLE_ID                 *Found;
    CHAR16                      *Name;
    CHAR16                      *Value;    
    UINTN                       SLen, Len;
    UINTN                       Size, DataSize;
    BOOLEAN                     Delete, Verbose, Remap;
    EFI_STATUS                  Status;
    UINTN                       Index;
    CHAR16                      *p;
    EFI_HANDLE                  Handle;
    EFI_DEVICE_PATH             *DevicePath;
    BOOLEAN                     PageBreaks;
    UINTN                       TempColumn;
    UINTN                       ScreenCount;
    UINTN                       ScreenSize;
    CHAR16                      ReturnStr[1];

    InitializeShellApplication (ImageHandle, SystemTable);
    Head = &SEnvMap;

    Name = NULL;
    Value = NULL;
    Delete = FALSE;
    Verbose = FALSE;
    Remap = FALSE;
    Status = EFI_SUCCESS;
    Found = NULL;

    /* 
     *  Crack arguments
     */

    PageBreaks = FALSE;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == '-') {
            switch (p[1]) {
            case 'd':
            case 'D':
                Delete = TRUE;
                break;

            case 'v':
            case 'V':
                Verbose = TRUE;
                break;

            case 'r':
            case 'R':
                Remap = TRUE;
                break;

            case 'b' :
            case 'B' :
                PageBreaks = TRUE;
                ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                ScreenCount = 0;
                break;
            
            default:
                Print (L"Map: Unkown flag %s\n", p);
                return EFI_INVALID_PARAMETER;
            }
            continue;
        }

        if (!Name) {
            Name = p;
            continue;
        }

        if (!Value) {
            Value = p;
            continue;
        }

        Print (L"Map: too many arguments\n");
        return EFI_INVALID_PARAMETER;
    }

    if (Delete && Value) {
        Print (L"Map: too many arguments\n");
    }

    /* 
     *  Process
     */

    if (Remap && !Value && !Delete) {
        AcquireLock (&SEnvLock);
        for (Link=Head->Flink; Link != Head;) {
            Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
            Status = RT->SetVariable (Var->Name, &SEnvMapId, 0, 0, NULL);
            Link = Link->Flink;
            RemoveEntryList (&Var->Link);
            FreePool (Var);
        }
        ReleaseLock (&SEnvLock);
        Status = SEnvReloadDefaults (ImageHandle,SystemTable);
        Remap = FALSE;
    }

    if (Value || Verbose) {
        SEnvLoadHandleTable ();

        if (Verbose) {
            SEnvLoadHandleProtocolInfo (&DevicePathProtocol);
        }
    }

    AcquireLock (&SEnvLock);

    SLen = 0;
    for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
        Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
        Len = StrLen(Var->Name);
        if (Len > SLen) {
            SLen = Len;
        }
    }

    if (!Name) {
        Print (L"%EDevice mapping table%N\n");
        for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
            Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
            SEnvDumpMapping(SLen, Verbose, Var);

            if (PageBreaks) {
                ScreenCount++;
                if (ScreenCount > ScreenSize - 4) {
                    ScreenCount = 0;
                    Print (L"\nPress Return to contiue :");
                    Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                    Print (L"\n\n");
                }
            }
        }

    } else {

        /* 
         *  Find the specified value
         */

        for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
            Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
            if (StriCmp(Var->Name, Name) == 0) {
                Found = Var;
                break;
            }
        }

        if (Found && Delete) {
            
            /* 
             *  Remove it from the store
             */

            Status = RT->SetVariable (Found->Name, &SEnvMapId, 0, 0, NULL);

        } else if (Value) {

            /* 
             *  Find the handle in question
             */

            Handle = SEnvHandleFromStr(Value);
            if (!Handle) {
                Print(L"map: Handle not found\n");
               Status = EFI_NOT_FOUND;   
                goto Done;
            }

            /* 
             *  Get the handle's device path
             */

            DevicePath = DevicePathFromHandle(Handle);
            if (!DevicePath) {
                Print(L"map: handle does not have a device path\n");
                Status = EFI_INVALID_PARAMETER;
                goto Done;
            }

            DataSize = DevicePathSize(DevicePath);


            /* 
             *  Add it to the store
             */

            Status = RT->SetVariable (
                            Found ? Found->Name : Name, 
                            &SEnvMapId,
                            EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_NON_VOLATILE, 
                            DataSize,
                            DevicePath
                            );


            if (!EFI_ERROR(Status)) {
    
                /* 
                 *  Make a new in memory copy
                 */

                Size = sizeof(VARIABLE_ID) + StrSize(Name) + DataSize;
                Var  = AllocateZeroPool (Size);

                Var->Signature = VARIABLE_SIGNATURE;
                Var->u.Value = ((UINT8 *) Var) + sizeof(VARIABLE_ID);
                Var->Name = (CHAR16*) (Var->u.Value + DataSize);
                Var->ValueSize = DataSize;
                CopyMem (Var->u.Value, DevicePath, DataSize);
                StrCpy (Var->Name, Found ? Found->Name : Name);
                InsertTailList (Head, &Var->Link);
            }

        } else {

            if (Found) {
                SEnvDumpMapping(SLen, Verbose, Var);
            } else {
                Print(L"map: '%es' not found\n", Name);
            }

            Found = NULL;
        }

        /* 
         *  Remove the old in memory copy if there was one
         */

        if (Found) {
            RemoveEntryList (&Found->Link);
            FreePool (Found);
        }
    }

Done:
    ReleaseLock (&SEnvLock);
    SEnvFreeHandleTable ();
    return Status;
}



VARIABLE_ID *
SEnvMapDeviceFromName (
    IN OUT CHAR16   **pPath
    )
/*  Check the Path for a device name, and updates the path to point after
 *  the device name.  If no device name is found, the current default is used. */
{
    CHAR16          *Path, *p;
    CHAR16          *MappedName, c;
    VARIABLE_ID     *Var;
    LIST_ENTRY      *Link;


    ASSERT_LOCKED (&SEnvLock);

    Var = NULL;
    Path = *pPath;

    /* 
     *  Check for a device name terminator
     */

    for(p = Path; *p && *p != ':' && *p != '\\'; p++) ;

    /* 
     *  Use either the passed in name or the current device name setting
     */

    MappedName = *p == ':' ? Path : SEnvCurDevice;
    
    /* 
     *  Null terminate the string in Path just in case that is the one we 
     *  are using
     */

    c = *p;
    *p = 0;

    /* 
     *  Find the mapping for the device
     */

    for (Link=SEnvMap.Flink; Link != &SEnvMap; Link=Link->Flink) {
        Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
        if (StriCmp(Var->Name, MappedName) == 0) {
            break;
        }
    }

    /* 
     *  Restore the path 
     */

    *p = c;

    /* 
     *  If the mapped device was not found, return NULL
     */

    if (Link == &SEnvMap) {
        DEBUG((D_PARSE, "SEnvNameToPath: Mapping for '%es' not found\n", Path));
        return NULL;
    }

    /* 
     *  If we found it as part of the path, skip the path over it
     */

    if (MappedName == Path) {
        *pPath = p + 1;
    }

    /* 
     *  Return the target mapping
     */
    
    return Var;
}


EFI_DEVICE_PATH *
SEnvIFileNameToPath (
    IN CHAR16               *Path
    )
/*  Builds a device path from the filename string.  Note that the
 *  device name must already be stripped off of the file name string */
{
    CHAR16                  *LPath, *ps;
    BOOLEAN                 UseLPath;
    EFI_DEVICE_PATH         *DPath, *Node, *NewPath;
    CHAR16                  Buffer[MAX_ARG_LENGTH];
    UINTN                   Index;

    ASSERT_LOCKED (&SEnvLock);

    DPath = NULL;

    /* 
     *  If no path, return the root
     */

    if (!*Path) {
        DPath = FileDevicePath(NULL, L"\\");
    }


    /* 
     *  Build a file path for the name component(s)
     */

    while (*Path) {

        Index = 0;
        LPath = NULL;
        UseLPath = FALSE;

        ps = Path;
        while (*ps) {

            /*  if buffer has run out, just handle to LPath */
            if (Index > MAX_ARG_LENGTH-2  || *ps == '#') {
                UseLPath = TRUE;
                break;
            }

            if (*ps == '^') {
                if (ps[1]) {
                    ps += 1;
                    Buffer[Index++] = *ps;
                }
                ps += 1;
                continue;
            }

            if (*ps == '\\') {
                LPath = ps;
            }

            Buffer[Index++] = *ps;
            ps += 1;
        }

        if (UseLPath) {
            Index = LPath ? LPath - Path : 0;
            ps = Path + Index;
        }

        /* 
         *  If we have part of a path name, append it to the device path
         */

        if (Index) {
            Buffer[Index] = 0;
            Node = FileDevicePath(NULL, Buffer);
            NewPath = AppendDevicePath (DPath, Node);
            FreePool (Node);
            if (DPath) {
                FreePool (DPath);
            }
            DPath = NewPath;
        }

        if (*ps == 0) {
            break;
        }

        Path = ps + 1;
    }

    return DPath;
}


EFI_DEVICE_PATH *
SEnvFileNameToPath (
    IN CHAR16               *Path
    )
{
    EFI_DEVICE_PATH         *FilePath;

    AcquireLock (&SEnvLock);
    FilePath = SEnvIFileNameToPath (Path);
    ReleaseLock (&SEnvLock);
    return FilePath;
}


EFI_DEVICE_PATH *
SEnvINameToPath (
    IN CHAR16               *Path
    )
/*  Convert a filesystem stlye name to an file path     */
{
    EFI_DEVICE_PATH         *DPath, *FPath, *RPath, *FilePath;
    VARIABLE_ID             *Var;
    BOOLEAN                 FreeDPath;
    
    DPath = NULL;
    RPath = NULL;
    FPath = NULL;
    FilePath = NULL;
    FreeDPath = FALSE;

    ASSERT_LOCKED (&SEnvLock);

    /* 
     *  Get the device for the name, and advance past the device name
     */

    Var = SEnvMapDeviceFromName (&Path);
    if (!Var) {
        DEBUG((D_PARSE, "SEnvNameToPath: mapped device not found\n"));
        goto Done;
    }

    /* 
     *  Start the file path with this mapping
     */

    DPath = (EFI_DEVICE_PATH *) Var->u.Value;

    /* 
     *  If the path is realitve, append the current dir of the device to the dpath
     */

    if (*Path != '\\') {
        RPath = SEnvIFileNameToPath (Var->CurDir ? Var->CurDir : L"\\");
        DPath = AppendDevicePath (DPath, RPath);
        FreeDPath = TRUE;
    }
    
    /* 
     *  Build a file path for the rest of the name string
     */

    FPath = SEnvIFileNameToPath (Path);

    /* 
     *  Append the 2 paths
     */

    FilePath = AppendDevicePath(DPath, FPath);

    /* 
     *  Done
     */

Done:
    if (DPath && FreeDPath) {
        FreePool (DPath);
    }

    if (RPath) {
        FreePool (RPath);
    }

    if (FPath) {
        FreePool (FPath);
    }

    return FilePath;
}



EFI_DEVICE_PATH *
SEnvNameToPath (
    IN CHAR16               *Path
    )
{
    EFI_DEVICE_PATH         *DPath;

    AcquireLock (&SEnvLock);
    DPath = SEnvINameToPath (Path);
    ReleaseLock (&SEnvLock);

    return DPath;
}



EFI_STATUS
SEnvCmdCd (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_DEVICE_PATH         *FilePath;
    EFI_STATUS              Status;
    EFI_FILE_HANDLE         OpenDir;
    CHAR16                  *Dir;
    CHAR16                  *CurDir;
    VARIABLE_ID             *Var;
    EFI_FILE_INFO           *FileInfo;


    InitializeShellApplication (ImageHandle, SystemTable);
    FilePath = NULL;

    /* 
     *  If no arguments, print the current directory
     */

    if (SI->Argc == 1) {
        Dir = SEnvGetCurDir(NULL);
        if (Dir) {
            Print (L"%s\n", Dir);
            FreePool (Dir);
        } else {
            Print (L"no current directory\n");
        }    
        return  EFI_SUCCESS;
    }

    AcquireLock (&SEnvLock);

    /* 
     *  If more then 1 argument, syntax
     */

    if (SI->Argc > 2) {
        Print (L"cd: too many arguments\n");
        Status =EFI_INVALID_PARAMETER;
        goto Done;
    }

    /* 
     *  Find the target device
     */

    Dir = SI->Argv[1];
    Var = SEnvMapDeviceFromName (&Dir);
    if (!Var) {
        Print(L"cd: mapped device not found\n");
        Status = EFI_NOT_FOUND;
        goto Done;
    }

    /* 
     *  If there's no path specified, print the current path for the device
     */

    if (*Dir == 0) {
        Print (L"%s\n", Var->CurDir ? Var->CurDir : L"\\");
        Status = EFI_SUCCESS;
        goto Done;
    }

    /* 
     *  Build a file path for the argument
     */

    FilePath = SEnvINameToPath (SI->Argv[1]);
    if (!FilePath) {
        Status = EFI_NOT_FOUND;
        goto Done;
    }

    /* 
     *  Open the target directory
     */

    OpenDir = ShellOpenFilePath(FilePath, EFI_FILE_MODE_READ);

    if (!OpenDir) {
        Print (L"cd: target directory not found\n");
        Status = EFI_NOT_FOUND;
        goto Done;
    }

    /* 
     *  Get information on the file path that was opened.
     */

    FileInfo = LibFileInfo(OpenDir);
    if (FileInfo == NULL) {
        Status = EFI_NOT_FOUND;
        goto Done;
    }

    /* 
     *  Verify that the file opened is a directory.
     */

    if (!(FileInfo->Attribute & EFI_FILE_DIRECTORY)) {
        Print (L"cd: target is not a directory\n");
        FreePool (FileInfo);
        OpenDir->Close (OpenDir);
        Status = EFI_NOT_FOUND;
        goto Done;
    }
    FreePool (FileInfo);

    CurDir = SEnvFileHandleToFileName(OpenDir);
    OpenDir->Close (OpenDir);
    
    /* 
     *  If we have a new path, update the device
     */

    if (CurDir) {
        if (Var->CurDir) {
            FreePool(Var->CurDir);
        }
        Var->CurDir = CurDir;

    } else {

        Print (L"cd: could not cd to '%hs%'\n", FilePath);

    }

    Status = EFI_SUCCESS;

Done:
    ReleaseLock (&SEnvLock);

    if (FilePath) {
        FreePool (FilePath);
    }

    return Status;
}



CHAR16 *
SEnvGetCurDir (
    IN CHAR16       *DeviceName OPTIONAL    
    )
/*  N.B. results are allocated in pool */
{
    CHAR16          *Dir;
    LIST_ENTRY      *Link;
    VARIABLE_ID     *Var;

    Dir = NULL;
    if (!DeviceName) {
        DeviceName = SEnvCurDevice;
    }

    AcquireLock (&SEnvLock);
    for (Link=SEnvMap.Flink; Link != &SEnvMap; Link=Link->Flink) {
        Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
        if (StriCmp(Var->Name, DeviceName) == 0) {
            Dir = PoolPrint(L"%s:%s", Var->Name, Var->CurDir ? Var->CurDir : L"\\");
            break;
        }
    }

    ReleaseLock (&SEnvLock);
    return Dir;
}


EFI_STATUS
SEnvSetCurrentDevice (
    IN CHAR16       *Name
    )
{
    VARIABLE_ID     *Var;
    LIST_ENTRY      *Link;
    EFI_STATUS      Status;
    UINTN           Len;
    CHAR16          *NewName, c;


    Len = StrLen(Name);
    if (Len < 1) {
        return EFI_INVALID_PARAMETER;
    }

    /* 
     *  If the name ends with a ":" strip it off
     */

    Len -= 1;
    c = Name[Len];
    if (c == ':') {
        Name[Len] = 0;
    }


    Status = EFI_NO_MAPPING;
    AcquireLock (&SEnvLock);

    for (Link=SEnvMap.Flink; Link != &SEnvMap; Link=Link->Flink) {
        Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
        if (StriCmp(Var->Name, Name) == 0) {
            NewName = StrDuplicate(Name);
            if (NewName) {
                FreePool (SEnvCurDevice);
                SEnvCurDevice = NewName;
            }
            Status = EFI_SUCCESS;
            break;
        }
    }

    ReleaseLock (&SEnvLock);

    /* 
     *  Restore the name
     */

    Name[Len] = c;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\pause.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    pause.c
    
Abstract:

    Internal Shell batch cmd "pause"



Revision History

--*/

#include "shelle.h"


/* 
 *  Internal prototypes
 */


/*///////////////////////////////////////////////////////////////////////
    Function Name:  
        SEnvCmdPause

    Description:
        Builtin shell command "pause" for interactive continue/abort 
        functionality from scripts.
*/
EFI_STATUS
SEnvCmdPause (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                        **Argv;
    UINTN                         Argc              = 0;
    UINTN                         Index             = 0;
    EFI_STATUS                    Status            = EFI_SUCCESS;
    SIMPLE_INPUT_INTERFACE        *TextIn           = NULL;
    SIMPLE_TEXT_OUTPUT_INTERFACE  *TextOut          = NULL;
    EFI_INPUT_KEY                 Key;
    CHAR16                        QStr[2];

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    if ( !SEnvBatchIsActive() ) {
        Print( L"Error: PAUSE command only supported in script files\n" );
        Status = EFI_UNSUPPORTED;
        goto Done;
    }

    SEnvBatchGetConsole( &TextIn, &TextOut );

    Status = TextOut->OutputString( TextOut, 
                                    L"Enter 'q' to quit, any other key to continue: " );
    if ( EFI_ERROR(Status) ) { 
        Print( L"PAUSE: error writing prompt\n" );
        goto Done;
    }

    WaitForSingleEvent (TextIn->WaitForKey, 0);
    Status = TextIn->ReadKeyStroke( TextIn, &Key );
    if ( EFI_ERROR(Status) ) { 
        Print( L"PAUSE: error reading keystroke\n" );
        goto Done;
    }

    /* 
     *   Check if input character is q or Q, if so set abort flag
     */

    if ( Key.UnicodeChar == L'q' || Key.UnicodeChar == L'Q' ) {
        SEnvSetBatchAbort();
    }
    if ( Key.UnicodeChar != (CHAR16)0x0000 ) {
        QStr[0] = Key.UnicodeChar;
        QStr[1] = (CHAR16)0x0000;
        TextOut->OutputString( TextOut, QStr );
    }
    TextOut->OutputString( TextOut, L"\n\r" );

Done:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\protid.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    protid.c
    
Abstract:

    Shell environment protocol id information management



Revision History

--*/

#include "shelle.h"
#include "efivar.h"
#include "LegacyBoot.h"
#include "VgaClass.h"
#include "EfiConSplit.h"
#include "intload.h"

#define PROTOCOL_INFO_SIGNATURE EFI_SIGNATURE_32('s','p','i','n')

typedef struct {
    UINTN                       Signature;
    LIST_ENTRY                  Link;

    /*  parsing info for the protocol */

    EFI_GUID                    ProtocolId;
    CHAR16                      *IdString;
    SHELLENV_DUMP_PROTOCOL_INFO DumpToken;
    SHELLENV_DUMP_PROTOCOL_INFO DumpInfo;

    /*  database info on which handles are supporting this protocol */

    UINTN                       NoHandles;
    EFI_HANDLE                  *Handles;

} PROTOCOL_INFO;


struct {
    CHAR16                      *IdString;
    SHELLENV_DUMP_PROTOCOL_INFO DumpInfo;
    SHELLENV_DUMP_PROTOCOL_INFO DumpToken;
    EFI_GUID                    ProtocolId;
} SEnvInternalProtocolInfo[] = {
    L"DevIo",       NULL,           NULL,           DEVICE_IO_PROTOCOL, 
    L"fs",          NULL,           NULL,           SIMPLE_FILE_SYSTEM_PROTOCOL,        
    L"diskio",      NULL,           NULL,           DISK_IO_PROTOCOL,                   
    L"blkio",       SEnvBlkIo,      NULL,           BLOCK_IO_PROTOCOL,
    L"txtin",       NULL,           NULL,           SIMPLE_TEXT_INPUT_PROTOCOL,
    L"txtout",      SEnvTextOut,    NULL,           SIMPLE_TEXT_OUTPUT_PROTOCOL,
    L"fs",          NULL,           NULL,           SIMPLE_FILE_SYSTEM_PROTOCOL,        
    L"load",        NULL,           NULL,           LOAD_FILE_PROTOCOL,
    L"image",       SEnvImage,      SEnvImageTok,   LOADED_IMAGE_PROTOCOL,
    L"varstore",    NULL,           NULL,           VARIABLE_STORE_PROTOCOL,            
    L"unicode",     NULL,           NULL,           UNICODE_COLLATION_PROTOCOL,         
    L"LegacyBoot",  NULL,           NULL,           LEGACY_BOOT_PROTOCOL,
    L"serialio",    NULL,           NULL,           SERIAL_IO_PROTOCOL,
    L"pxebc",       NULL,           NULL,           EFI_PXE_BASE_CODE_PROTOCOL,    
    L"net",         NULL,           NULL,           EFI_SIMPLE_NETWORK_PROTOCOL,
    L"VgaClass",    NULL,           NULL,           VGA_CLASS_DRIVER_PROTOCOL,
    L"TxtOutSplit", NULL,           NULL,           TEXT_OUT_SPLITER_PROTOCOL,      
    L"ErrOutSplit", NULL,           NULL,           ERROR_OUT_SPLITER_PROTOCOL,
    L"TxtInSplit",  NULL,           NULL,           TEXT_IN_SPLITER_PROTOCOL,

    L"dpath",       SEnvDPath,      SEnvDPathTok,   DEVICE_PATH_PROTOCOL,               
    /*  just plain old protocol ids */
   
    L"ShellInt",            NULL,   NULL,           SHELL_INTERFACE_PROTOCOL,           
    L"SEnv",                NULL,   NULL,           ENVIRONMENT_VARIABLE_ID,             
    L"ShellProtId",         NULL,   NULL,           PROTOCOL_ID_ID,
    L"ShellDevPathMap",     NULL,   NULL,           DEVICE_PATH_MAPPING_ID,
    L"ShellAlias",          NULL,   NULL,           ALIAS_ID,

    /*  ID guids */
    L"G0",                  NULL,   NULL,           { 0,0,0,0,0,0,0,0,0,0,0 },
    L"Efi",                 NULL,   NULL,           EFI_GLOBAL_VARIABLE,
    L"GenFileInfo",         NULL,   NULL,           EFI_FILE_INFO_ID,
    L"FileSysInfo",         NULL,   NULL,           EFI_FILE_SYSTEM_INFO_ID,
    L"PcAnsi",              NULL,   NULL,           DEVICE_PATH_MESSAGING_PC_ANSI,
    L"Vt100",               NULL,   NULL,           DEVICE_PATH_MESSAGING_VT_100,
    L"InternalLoad",        NULL,   NULL,           INTERNAL_LOAD_PROTOCOL,
    L"Unknown Device",      NULL,   NULL,           UNKNOWN_DEVICE_GUID,
    NULL
} ;

/* 
 *  SEnvProtocolInfo - A list of all known protocol info structures
 */

LIST_ENTRY  SEnvProtocolInfo;

/* 
 * 
 */

VOID
INTERNAL
SEnvInitProtocolInfo (
    VOID
    )
{
    InitializeListHead (&SEnvProtocolInfo);
}


VOID
INTERNAL
SEnvLoadInternalProtInfo (
    VOID
    )
/*  Initialize internal protocol handlers */
{
    UINTN               Index;

    for (Index=0; SEnvInternalProtocolInfo[Index].IdString; Index += 1) {
        SEnvAddProtocol (
            &SEnvInternalProtocolInfo[Index].ProtocolId,
            SEnvInternalProtocolInfo[Index].DumpToken,
            SEnvInternalProtocolInfo[Index].DumpInfo,
            SEnvInternalProtocolInfo[Index].IdString
            );
    }
}


PROTOCOL_INFO *
SEnvGetProtById (
    IN EFI_GUID         *Protocol,
    IN BOOLEAN          GenId
    )
/*  Locate a protocol handle by guid */
{
    PROTOCOL_INFO       *Prot;
    LIST_ENTRY          *Link;
    UINTN               LastId, Id;
    CHAR16              s[40];

    ASSERT_LOCKED(&SEnvGuidLock);

    /* 
     *  Find the protocol entry for this id
     */

    LastId = 0;
    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
        if (CompareGuid(&Prot->ProtocolId, Protocol) == 0) {
            return Prot;
        }

        if (Prot->IdString[0] == 'g') {
            Id = Atoi(Prot->IdString+1);
            LastId = Id > LastId ? Id : LastId;
        }
    }

    /* 
     *  If the protocol id is not found, gen a string for it if needed
     */

    Prot = NULL;
    if (GenId) {
        SPrint (s, sizeof(s), L"g%d", LastId+1);
        Prot = AllocateZeroPool (sizeof(PROTOCOL_INFO));
        if (Prot) {
            Prot->Signature = PROTOCOL_INFO_SIGNATURE;
            CopyMem (&Prot->ProtocolId, Protocol, sizeof(EFI_GUID));
            Prot->IdString = StrDuplicate(s);
            InsertTailList (&SEnvProtocolInfo, &Prot->Link);
        }
    }

    return Prot;
}



PROTOCOL_INFO *
SEnvGetProtByStr (
    IN CHAR16           *Str
    )
{
    PROTOCOL_INFO       *Prot;
    LIST_ENTRY          *Link;
    UINTN               Index;
    EFI_GUID            Guid;
    CHAR16              c;    
    CHAR16              *p;

    ASSERT_LOCKED(&SEnvGuidLock);

    /*  Search for short name match */
    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
        if (StriCmp(Prot->IdString, Str) == 0) {
            return Prot;
        }
    }

    /*  Convert Str to guid and then match */
    if (StrLen(Str) == 36  &&  Str[9] == '-'  &&  Str[19] == '-'  && Str[24] == '-') {
        Guid.Data1 = (UINT32) xtoi(Str+0);
        Guid.Data2 = (UINT16) xtoi(Str+10);
        Guid.Data3 = (UINT16) xtoi(Str+15);
        for (Index=0; Index < 8; Index++) {
            p = Str+25+Index*2;
            c = p[3];
            p[3] = 0;
            Guid.Data4[Index] = (UINT8) xtoi(p);
            p[3] = c;
        }

        for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
            Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
            if (CompareGuid(&Prot->ProtocolId, &Guid) == 0) {
                return Prot;
            }
        }
    }

    return NULL;
}

EFI_STATUS
SEnvIGetProtID (
    IN CHAR16           *Str,
    OUT EFI_GUID        *ProtId
    )
{
    PROTOCOL_INFO       *Prot;
    EFI_STATUS          Status;

    AcquireLock (&SEnvGuidLock);

    Status = EFI_NOT_FOUND;
    CopyMem (ProtId, &NullGuid, sizeof(EFI_GUID));

    Prot = SEnvGetProtByStr (Str);
    if (Prot) {
        CopyMem (ProtId, &Prot->ProtocolId, sizeof(EFI_GUID));
        Status = EFI_SUCCESS;
    }

    ReleaseLock (&SEnvGuidLock);

    return Status;
}

VOID
SEnvAddProtocol (
    IN EFI_GUID                     *Protocol,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpToken OPTIONAL,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpInfo OPTIONAL,
    IN CHAR16                       *IdString
    )
/*  Published interface to add protocol handlers */
{
    SEnvIAddProtocol (TRUE, Protocol, DumpToken, DumpInfo, IdString);
}


VOID
INTERNAL
SEnvIAddProtocol (
    IN BOOLEAN                      SaveId,
    IN EFI_GUID                     *Protocol,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpToken OPTIONAL,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpInfo OPTIONAL,
    IN CHAR16                       *IdString
    )
/*  Internal interface to add protocol handlers */
{
    PROTOCOL_INFO       *Prot;
    BOOLEAN             StoreInfo;
    CHAR16              *ObsoleteName;

    ObsoleteName = NULL;
    StoreInfo = FALSE;

    AcquireLock (&SEnvGuidLock);

    /* 
     *  Get the current protocol info
     */

    Prot = SEnvGetProtById (Protocol, FALSE);

    if (Prot) {
        /* 
         *  If the name has changed, delete the old var
         */

        if (StriCmp (Prot->IdString, IdString)) {
            ObsoleteName = Prot->IdString;
            StoreInfo = TRUE;
        } else {
            FreePool (Prot->IdString);
        }

        Prot->IdString = NULL;

    } else {

        /* 
         *  Allocate new protocol info
         */

        Prot = AllocateZeroPool (sizeof(PROTOCOL_INFO));
        Prot->Signature = PROTOCOL_INFO_SIGNATURE;
        StoreInfo = TRUE;

    }

    /* 
     *  Apply any updates to the protocol info
     */

    if (Prot) {
        CopyMem (&Prot->ProtocolId, Protocol, sizeof(EFI_GUID));
        Prot->IdString = StrDuplicate(IdString);
        Prot->DumpToken = DumpToken;
        Prot->DumpInfo = DumpInfo;

        if (Prot->Link.Flink) {
            RemoveEntryList (&Prot->Link);
        }

        InsertTailList (&SEnvProtocolInfo, &Prot->Link);
    }

    ReleaseLock (&SEnvGuidLock);

    /* 
     *  If the name changed, delete the old name
     */

    if (ObsoleteName) {
        RT->SetVariable (ObsoleteName, &SEnvProtId, 0, 0, NULL);
        FreePool (ObsoleteName);
    }

    /* 
     *  Store the protocol idstring to a variable
     */

    if (Prot && StoreInfo  && SaveId) {
        RT->SetVariable (
            Prot->IdString,
            &SEnvProtId,
            EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_NON_VOLATILE,
            sizeof(EFI_GUID),
            &Prot->ProtocolId
            );
    }
}


VOID
INTERNAL
SEnvLoadHandleProtocolInfo (
    IN EFI_GUID         *SkipProtocol
    )
/*  Code to load the internal handle cross-reference info for each protocol */
{
    PROTOCOL_INFO       *Prot;
    LIST_ENTRY          *Link;

    AcquireLock (&SEnvGuidLock);

    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
        if (!SkipProtocol || CompareGuid(SkipProtocol, &Prot->ProtocolId) != 0) {
            LibLocateHandle (
                ByProtocol,
                &Prot->ProtocolId,
                NULL,
                &Prot->NoHandles,
                &Prot->Handles
                );
        }
    }

    ReleaseLock (&SEnvGuidLock);
}

VOID
INTERNAL
SEnvFreeHandleProtocolInfo (
    VOID
    )
/*  Free the internal handle cross-reference protocol info */
{
    PROTOCOL_INFO       *Prot;
    LIST_ENTRY          *Link;

    AcquireLock (&SEnvGuidLock);

    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);

        if (Prot->NoHandles) {
            FreePool (Prot->Handles);
            Prot->Handles = NULL;
            Prot->NoHandles = 0;
        }
    }

    ReleaseLock (&SEnvGuidLock);
}


CHAR16 *
INTERNAL
SEnvIGetProtocol (
    IN EFI_GUID     *ProtocolId,
    IN BOOLEAN      GenId    
    )
/*  Published interface to lookup a protocol id string */
{
    PROTOCOL_INFO   *Prot;
    CHAR16          *Id;

    ASSERT_LOCKED (&SEnvGuidLock);
    Prot = SEnvGetProtById(ProtocolId, GenId);
    Id = Prot ? Prot->IdString : NULL;
    return Id;
}

CHAR16 *
SEnvGetProtocol (
    IN EFI_GUID     *ProtocolId,
    IN BOOLEAN      GenId    
    )
/*  Published interface to lookup a protocol id string */
{
    CHAR16          *Id;

    AcquireLock (&SEnvGuidLock);
    Id = SEnvIGetProtocol(ProtocolId, GenId);
    ReleaseLock (&SEnvGuidLock);
    return Id;
}


EFI_STATUS
INTERNAL
SEnvCmdProt (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*  Code for internal "prot" command */
{
    PROTOCOL_INFO       *Prot;
    LIST_ENTRY          *Link;
    UINTN               Len, SLen;
    CHAR16              *p;
    UINTN               Index;
    BOOLEAN             PageBreaks;
    UINTN               TempColumn;
    UINTN               ScreenCount;
    UINTN               ScreenSize;
    CHAR16              ReturnStr[1];

    InitializeShellApplication (ImageHandle, SystemTable);

    PageBreaks = FALSE;
    for (Index = 1;Index < SI->Argc; Index++) {
        p = SI->Argv[Index];
        if (*p == '-') {
            switch (p[1]) {
            case 'b' :
            case 'B' :
                PageBreaks = TRUE;
                ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                ScreenCount = 0;
                break;
            default :
                Print(L"guid : Unknown flag %s\n",p);
                return EFI_INVALID_PARAMETER;
            }
        }
    }

    AcquireLock (&SEnvGuidLock);

    /* 
     *  Find the protocol entry for this id
     */

    SLen = 0;
    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
        Len = StrLen(Prot->IdString);
        if (StrLen(Prot->IdString) > SLen) {
            SLen = Len;
        }
    }

    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
    
        /*  Can't use Lib function to dump the guid as it may lookup the "short name" for it */

        /* 
         *  BUGBUG : Have to release and reacquire the lock for output redirection of this command
         *           to work properly.  Otherwise, we get an ASSERT from RaiseTPL().
         */

        ReleaseLock (&SEnvGuidLock);

        Print(L"  %h-.*s : %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x  %c\n",
                    SLen, 
                    Prot->IdString, 
                    Prot->ProtocolId.Data1,
                    Prot->ProtocolId.Data2,
                    Prot->ProtocolId.Data3,
                    Prot->ProtocolId.Data4[0],
                    Prot->ProtocolId.Data4[1],
                    Prot->ProtocolId.Data4[2],
                    Prot->ProtocolId.Data4[3],
                    Prot->ProtocolId.Data4[4],
                    Prot->ProtocolId.Data4[5],
                    Prot->ProtocolId.Data4[6],
                    Prot->ProtocolId.Data4[7],
                    (Prot->DumpToken || Prot->DumpInfo) ? L'*' : L' '
                    );

        if (PageBreaks) {
            ScreenCount++;
            if (ScreenCount > ScreenSize - 4) {
                ScreenCount = 0;
                Print (L"\nPress Return to contiue :");
                Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                Print (L"\n\n");
            }
        }

        AcquireLock (&SEnvGuidLock);
    }

    ReleaseLock (&SEnvGuidLock);
    return EFI_SUCCESS;
}



VOID
SEnvDHProt (
    IN BOOLEAN          Verbose,
    IN UINTN            HandleNo,
    IN EFI_HANDLE       Handle
    )
{
    PROTOCOL_INFO               *Prot;
    LIST_ENTRY                  *Link;
    VOID                        *Interface;
    UINTN                       Index;
    EFI_STATUS                  Status;
    SHELLENV_DUMP_PROTOCOL_INFO Dump;
    
    if (!HandleNo) {
        for (HandleNo=0; HandleNo < SEnvNoHandles; HandleNo++) {
            if (SEnvHandles[HandleNo] == Handle) {
                break;
            }
        }
        HandleNo += 1;
    }

    Print (Verbose ? L"%NHandle %h02x (%hX)\n" : L"%N %h2x: ", HandleNo, Handle);

    for (Link=SEnvProtocolInfo.Flink; Link != &SEnvProtocolInfo; Link=Link->Flink) {
        Prot = CR(Link, PROTOCOL_INFO, Link, PROTOCOL_INFO_SIGNATURE);
        for (Index=0; Index < Prot->NoHandles; Index++) {

            /* 
             *  If this handle supports this protocol, dump it
             */

            if (Prot->Handles[Index] == Handle) {
                Dump = Verbose ? Prot->DumpInfo : Prot->DumpToken;
                Status = BS->HandleProtocol (Handle, &Prot->ProtocolId, &Interface);
                if (Verbose) {
                    Print (L"   %hs ", Prot->IdString);
                    if (Dump && !EFI_ERROR(Status)) {
                        Dump (Handle, Interface);
                    }
                    Print (L"\n");
                } else {
                    if (Dump && !EFI_ERROR(Status)) {
                        Dump (Handle, Interface);
                    }  else {
                        Print (L"%hs ", Prot->IdString);
                    }
                }
            }
        }
    }

    Print (Verbose ? L"%N" : L"%N\n");
}

EFI_STATUS
INTERNAL
SEnvCmdDH (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*  Code for internal "DH" command */
{
    BOOLEAN             ByProtocol;
    CHAR16              *Arg, *p;
    EFI_STATUS          Status;
    UINTN               Index;
    PROTOCOL_INFO       *Prot;
    BOOLEAN             PageBreaks;
    UINTN               TempColumn;
    UINTN               ScreenCount;
    UINTN               ScreenSize;
    CHAR16              ReturnStr[1];

    /*  
     *  Initialize
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    Arg = NULL;
    ByProtocol = FALSE;

    /* 
     *  Crack args
     */

    PageBreaks = FALSE;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == '-') {
            switch (p[1]) {
            case 'p':
            case 'P':
                ByProtocol = TRUE;
                break;

            case 'b' :
            case 'B' :
                PageBreaks = TRUE;
                ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                ScreenCount = 0;
                break;

            default:
                Print (L"%EDH: Unkown flag %s\n", p);
                Status = EFI_INVALID_PARAMETER;
                goto Done;
            }
            continue;
        }

        if (!Arg) {
            Arg = p;
            continue;
        }

        Print (L"%EDH: too many arguments\n");
        Status = EFI_INVALID_PARAMETER;
        goto Done;
    }

    /*  
     * 
     *  Load handle & protocol info tables
     */

    SEnvLoadHandleTable ();
    SEnvLoadHandleProtocolInfo (NULL);

    if (Arg) {

        if (ByProtocol) {
            
            AcquireLock (&SEnvGuidLock);
            Prot = SEnvGetProtByStr (Arg);
            ReleaseLock (&SEnvGuidLock);

            if (Prot) {
                
                /*  Dump the handles on this protocol */
                Print(L"%NHandle dump by protocol '%s'\n", Prot->IdString);
                for (Index=0; Index < Prot->NoHandles; Index++) {
                    SEnvDHProt (FALSE, 0, Prot->Handles[Index]);

                    if (PageBreaks) {
                        ScreenCount++;
                        if (ScreenCount > ScreenSize - 4) {
                            ScreenCount = 0;
                            Print (L"\nPress Return to contiue :");
                            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                            Print (L"\n\n");
                        }
                    }
                }

            } else {

                Print(L"%EDH: Protocol '%s' not found\n", Arg);
            }

        } else {

            /*  Dump 1 handle */
            Index = SEnvHandleNoFromStr(Arg) - 1;
            if (Index > SEnvNoHandles) {

                Print(L"%EDH: Invalid handle #\n");

            } else {

                SEnvDHProt (TRUE, Index+1, SEnvHandles[Index]);

            }
        }

    } else {

        /*  Dump all handles */
        Print(L"%NHandle dump\n");
        for (Index=0; Index < SEnvNoHandles; Index++) {
            SEnvDHProt (FALSE, Index+1, SEnvHandles[Index]);

            if (PageBreaks) {
                ScreenCount++;
                if (ScreenCount > ScreenSize - 4) {
                    ScreenCount = 0;
                    Print (L"\nPress Return to contiue :");
                    Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                    Print (L"\n\n");
                }
            }
        }
    }

    Status = EFI_SUCCESS;

Done:    
    SEnvFreeHandleTable ();
    return Status;
}


extern LIST_ENTRY SEnvMap;
extern LIST_ENTRY SEnvEnv;
extern LIST_ENTRY SEnvAlias;


EFI_STATUS
SEnvLoadDefaults (
    IN EFI_HANDLE           Image,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    LIST_ENTRY              DefCmds;
    POOL_PRINT              Path;
    DEFAULT_CMD             *Cmd;
    PROTOCOL_INFO           *ProtFs, *ProtBlkIo;
    UINTN                   Index, HandleNo;
    CHAR16                  *DefaultMapping;

    InitializeShellApplication (Image, SystemTable);

    /* 
     *  If we have some settings, use those
     */

    if (!IsListEmpty(&SEnvMap) || !IsListEmpty(&SEnvEnv) || !IsListEmpty(&SEnvAlias)) {
        return EFI_SUCCESS;
    }

    /* 
     *  There are no settings, build some defaults
     */

    InitializeListHead (&DefCmds);
    ZeroMem (&Path, sizeof(Path));

    AcquireLock (&SEnvLock);
    SEnvLoadHandleTable();
    SEnvLoadHandleProtocolInfo (NULL);
    AcquireLock (&SEnvGuidLock);
    ProtFs = SEnvGetProtByStr(L"fs");
    ProtBlkIo = SEnvGetProtByStr(L"blkio");
    ReleaseLock (&SEnvGuidLock);

    /* 
     *  Run all the devices that support a File System and add a default
     *  mapping and path setting for each device 
     */

    CatPrint (&Path, L"set path ");
    for (Index=0; Index < ProtFs->NoHandles; Index++) {
        for (HandleNo=0; HandleNo < SEnvNoHandles; HandleNo++) {
            if (SEnvHandles[HandleNo] == ProtFs->Handles[Index]) {
                break;
            }
        }
        HandleNo += 1;

        Cmd = AllocateZeroPool(sizeof(DEFAULT_CMD));
        Cmd->Line = Cmd->Buffer;
        SPrint(Cmd->Line, sizeof(Cmd->Buffer), L"map fs%x %x", Index, HandleNo);
        InsertTailList(&DefCmds, &Cmd->Link);

        /*  append this device to the path */
        CatPrint (&Path, L"fs%x:\\efi\\tools;fs%x:\\;", Index, Index);
    }
    CatPrint (&Path, L".");

    /* 
     *  Run all the devices that support a BlockIo and add a default
     *  mapping for the device
     */
    
    for (Index=0; Index < ProtBlkIo->NoHandles; Index++) {
        for (HandleNo=0; HandleNo < SEnvNoHandles; HandleNo++) {
            if (SEnvHandles[HandleNo] == ProtBlkIo->Handles[Index]) {
                break;
            }
        }
        HandleNo += 1;

        Cmd = AllocateZeroPool(sizeof(DEFAULT_CMD));
        Cmd->Line = Cmd->Buffer;
        SPrint(Cmd->Line, sizeof(Cmd->Buffer), L"map blk%x %x", Index, HandleNo);
        InsertTailList(&DefCmds, &Cmd->Link);
    }

    /*  release handle table resources & lock */
    SEnvFreeHandleTable();
    ReleaseLock (&SEnvLock);

    /* 
     *  execute all the queue commands
     */

    while (!IsListEmpty(&DefCmds)) {
        Cmd = CR(DefCmds.Flink, DEFAULT_CMD, Link, 0);
        SEnvExecute (Image, Cmd->Line, TRUE);
        RemoveEntryList (&Cmd->Link);
        FreePool (Cmd);
    }

    SEnvExecute (Image, Path.str, TRUE);
    SEnvExecute (Image, L"alias dir ls", TRUE);
    SEnvExecute (Image, L"alias md mkdir", TRUE);
    SEnvExecute (Image, L"alias rd rm", TRUE);
    SEnvExecute (Image, L"alias del rm", TRUE);
    SEnvExecute (Image, L"alias copy cp", TRUE);

    DefaultMapping = SEnvGetDefaultMapping(Image);
    if (DefaultMapping!=NULL) {
        ZeroMem (&Path, sizeof(Path));
        CatPrint(&Path,L"%s:",DefaultMapping);
        SEnvExecute (Image, Path.str, TRUE);
    }

    FreePool (Path.str);
    return EFI_SUCCESS;
}

EFI_STATUS
SEnvReloadDefaults (
    IN EFI_HANDLE           Image,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    LIST_ENTRY              DefCmds;
    POOL_PRINT              Path;
    DEFAULT_CMD             *Cmd;
    PROTOCOL_INFO           *ProtFs, *ProtBlkIo;
    UINTN                   Index, HandleNo;

    InitializeShellApplication (Image, SystemTable);

    /* 
     *  There are no settings, build some defaults
     */

    InitializeListHead (&DefCmds);
    ZeroMem (&Path, sizeof(Path));

    AcquireLock (&SEnvLock);
    SEnvLoadHandleTable();
    SEnvLoadHandleProtocolInfo (NULL);
    AcquireLock (&SEnvGuidLock);
    ProtFs = SEnvGetProtByStr(L"fs");
    ProtBlkIo = SEnvGetProtByStr(L"blkio");
    ReleaseLock (&SEnvGuidLock);

    /* 
     *  Run all the devices that support a File System and add a default
     *  mapping and path setting for each device 
     */

    CatPrint (&Path, L"set path ");
    for (Index=0; Index < ProtFs->NoHandles; Index++) {
        for (HandleNo=0; HandleNo < SEnvNoHandles; HandleNo++) {
            if (SEnvHandles[HandleNo] == ProtFs->Handles[Index]) {
                break;
            }
        }
        HandleNo += 1;

        Cmd = AllocateZeroPool(sizeof(DEFAULT_CMD));
        Cmd->Line = Cmd->Buffer;
        SPrint(Cmd->Line, sizeof(Cmd->Buffer), L"map fs%x %x", Index, HandleNo);
        InsertTailList(&DefCmds, &Cmd->Link);

        /*  append this device to the path */
        CatPrint (&Path, L"fs%x:\\efi\\tools;fs%x:\\;", Index, Index);
    }
    CatPrint (&Path, L".");

    /* 
     *  Run all the devices that support a BlockIo and add a default
     *  mapping for the device
     */
    
    for (Index=0; Index < ProtBlkIo->NoHandles; Index++) {
        for (HandleNo=0; HandleNo < SEnvNoHandles; HandleNo++) {
            if (SEnvHandles[HandleNo] == ProtBlkIo->Handles[Index]) {
                break;
            }
        }
        HandleNo += 1;

        Cmd = AllocateZeroPool(sizeof(DEFAULT_CMD));
        Cmd->Line = Cmd->Buffer;
        SPrint(Cmd->Line, sizeof(Cmd->Buffer), L"map blk%x %x", Index, HandleNo);
        InsertTailList(&DefCmds, &Cmd->Link);
    }

    /*  release handle table resources & lock */
    SEnvFreeHandleTable();
    ReleaseLock (&SEnvLock);

    /* 
     *  execute all the queue commands
     */

    while (!IsListEmpty(&DefCmds)) {
        Cmd = CR(DefCmds.Flink, DEFAULT_CMD, Link, 0);
        SEnvExecute (Image, Cmd->Line, TRUE);
        RemoveEntryList (&Cmd->Link);
        FreePool (Cmd);
    }

    SEnvExecute (Image, Path.str, TRUE);

    FreePool (Path.str);
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\shelle.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    shelle.h
    
Abstract:




Revision History

--*/


#include "shell.h"
#include "shellenv.h"

/* 
 *  Internal defines
 */

typedef struct {
    UINTN           Signature;
    LIST_ENTRY      Link;
    CHAR16          *Line;
    CHAR16          Buffer[80];
} DEFAULT_CMD;

#define MAX_CMDLINE         256
#define MAX_ARG_COUNT        32
#define MAX_ARG_LENGTH      256

#define NON_VOL             1
#define VOL                 0


#define IsWhiteSpace(c)     (c == ' ' || c == '\t' || c == '\n' || c == '\r')
#define IsValidChar(c)      (c >= ' ')
#define IsDigit(c)          (c >= '0' && c <= '9')
#define IsAlpha(c)          ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z' ))

#define GOTO_TARGET_FOUND        (1)
#define GOTO_TARGET_NOT_FOUND    (2)
#define GOTO_TARGET_DOESNT_EXIST (3)

/* 
 *  Internal structures
 */

#define VARIABLE_SIGNATURE  EFI_SIGNATURE_32('v','i','d',' ')
typedef struct {
    UINTN               Signature;
    LIST_ENTRY          Link;
    CHAR16              *Name;

    UINTN               ValueSize;
    union {
        UINT8           *Value;
        CHAR16          *Str;
    } u;

    CHAR16              *CurDir;
    UINT8               Flags ;
} VARIABLE_ID;


/* 
 *  IDs of different variables stored by the shell environment
 */

#define ENVIRONMENT_VARIABLE_ID  \
    { 0x47c7b224, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define DEVICE_PATH_MAPPING_ID  \
    { 0x47c7b225, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define PROTOCOL_ID_ID  \
    { 0x47c7b226, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

#define ALIAS_ID  \
    { 0x47c7b227, 0xc42a, 0x11d2, 0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

/* 
 * 
 */

#define ENV_REDIR_SIGNATURE         EFI_SIGNATURE_32('r','i','d','s')
typedef struct {
    UINTN                           Signature;
    BOOLEAN                         Ascii;
    EFI_STATUS                      WriteError;
    EFI_FILE_HANDLE                 File;
    EFI_DEVICE_PATH                 *FilePath;
    EFI_HANDLE                      Handle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    Out;
    SIMPLE_INPUT_INTERFACE          In;
} ENV_SHELL_REDIR_FILE;

typedef struct {
    EFI_SHELL_INTERFACE             ShellInt;
    EFI_SYSTEM_TABLE                *SystemTable;

    ENV_SHELL_REDIR_FILE            StdIn;
    ENV_SHELL_REDIR_FILE            StdOut;
    ENV_SHELL_REDIR_FILE            StdErr;

} ENV_SHELL_INTERFACE;

/* 
 *  Internal prototypes from init.c
 */

EFI_SHELL_INTERFACE *
SEnvNewShell (
    IN EFI_HANDLE                   ImageHandle
    );


/* 
 *  Internal prototypes from cmddisp.c
 */

VOID
SEnvInitCommandTable (
    VOID
    );

EFI_STATUS
SEnvAddCommand (
    IN SHELLENV_INTERNAL_COMMAND    Handler,
    IN CHAR16                       *Cmd,
    IN CHAR16                       *CmdFormat,
    IN CHAR16                       *CmdHelpLine,
    IN CHAR16                       *CmdVerboseHelp
    );


SHELLENV_INTERNAL_COMMAND
SEnvGetCmdDispath(
    IN CHAR16                   *CmdName
    );

/* 
 *  From exec.c
 */

EFI_STATUS
SEnvExecute (
    IN EFI_HANDLE           *ParentImageHandle,
    IN CHAR16               *CommandLine,
    IN BOOLEAN              DebugOutput
    );

EFI_STATUS
SEnvDoExecute (
    IN EFI_HANDLE           *ParentImageHandle,
    IN CHAR16               *CommandLine,
    IN ENV_SHELL_INTERFACE  *Shell,
    IN BOOLEAN              Output
    );

EFI_STATUS
SEnvExit (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_STATUS
SEnvStringToArg (
    IN CHAR16       *Str,
    IN BOOLEAN      Output,
    OUT CHAR16      ***pArgv,
    OUT UINT32      *pArgc
    );

/* 
 *  Internal prototypes from protid.c
 */

VOID
INTERNAL
SEnvInitProtocolInfo (
    VOID
    );

EFI_STATUS
SEnvLoadDefaults (
    IN EFI_HANDLE           Parent,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_STATUS
SEnvReloadDefaults (
    IN EFI_HANDLE           Parent,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
INTERNAL
SEnvLoadInternalProtInfo (
    VOID
    );

VOID
INTERNAL
SEnvFreeHandleProtocolInfo (
    VOID
    );

VOID
SEnvAddProtocol (
    IN EFI_GUID                     *Protocol,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpToken OPTIONAL,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpInfo OPTIONAL,
    IN CHAR16                       *IdString
    );

VOID
INTERNAL
SEnvIAddProtocol (
    IN BOOLEAN                      SaveId,
    IN EFI_GUID                     *Protocol,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpToken OPTIONAL,
    IN SHELLENV_DUMP_PROTOCOL_INFO  DumpInfo OPTIONAL,
    IN CHAR16                       *IdString
    );

VOID
INTERNAL
SEnvLoadHandleProtocolInfo (
    IN EFI_GUID                     *Skip
    );

CHAR16 *
SEnvGetProtocol (
    IN EFI_GUID                     *ProtocolId,
    IN BOOLEAN                      GenId
    );

EFI_STATUS
INTERNAL
SEnvCmdProt (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_SYSTEM_TABLE             *SystemTable
    );

VOID
SEnvDHProt (
    IN BOOLEAN                      Verbose,
    IN UINTN                        HandleNo,
    IN EFI_HANDLE                   Handle
    );

EFI_STATUS
INTERNAL
SEnvCmdDH (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_STATUS
SEnvIGetProtID (
    IN CHAR16           *Str,
    OUT EFI_GUID        *ProtId
    );


/* 
 *  Handle.c
 */

VOID
INTERNAL
SEnvInitHandleGlobals(
    VOID
    );

VOID
INTERNAL
SEnvLoadHandleTable (
    VOID
    );

VOID
INTERNAL
SEnvFreeHandleTable (
    VOID
    );

UINTN
SEnvHandleNoFromStr(
    IN CHAR16       *Str
    );

EFI_HANDLE
SEnvHandleFromStr(
    IN CHAR16       *Str
    );

/* 
 *  Internal prototypes from var.c
 */


VOID
SEnvInitVariables (
    VOID
    );

EFI_STATUS
SEnvCmdSet (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_STATUS
SEnvCmdAlias (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );


CHAR16 *
SEnvGetMap (
    IN CHAR16           *Name
    );

CHAR16 *
SEnvGetEnv (
    IN CHAR16           *Name
    );

CHAR16 *
SEnvGetAlias (
    IN CHAR16           *Name
    );


/* 
 *  Prototypes from conio.c
 */

VOID
SEnvConIoInitDosKey (
    VOID
    );

EFI_STATUS
SEnvConIoOpen (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT struct _EFI_FILE_HANDLE **NewHandle,
    IN CHAR16                   *FileName,
    IN UINT64                   OpenMode,
    IN UINT64                   Attributes
    );

EFI_STATUS
SEnvConIoNop (
    IN struct _EFI_FILE_HANDLE  *File
    );

EFI_STATUS
SEnvConIoGetPosition (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  *Position
    );

EFI_STATUS
SEnvConIoSetPosition (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  Position
    );

EFI_STATUS
SEnvConIoGetInfo (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

EFI_STATUS
SEnvConIoSetInfo (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN UINTN                    BufferSize,
    OUT VOID                    *Buffer
    );

EFI_STATUS
SEnvConIoWrite (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );

EFI_STATUS
SEnvConIoRead (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );

EFI_STATUS
SEnvErrIoWrite (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );

EFI_STATUS
SEnvErrIoRead (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );


EFI_STATUS
SEnvReset (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                          ExtendedVerification
    );

EFI_STATUS
SEnvOutputString (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

EFI_STATUS
SEnvTestString (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

EFI_STATUS 
SEnvQueryMode (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber,
    OUT UINTN                       *Columns,
    OUT UINTN                       *Rows
    );

EFI_STATUS
SEnvSetMode (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber
    );

EFI_STATUS
SEnvSetAttribute (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                            Attribute
    );

EFI_STATUS
SEnvClearScreen (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This
    );

EFI_STATUS
SEnvSetCursorPosition (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Column,
    IN UINTN                        Row
    );

EFI_STATUS
SEnvEnableCursor (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      Enable
    );

/* 
 *  Prototypes from batch.c
 */
VOID
SEnvInitBatch(
    VOID
    );

BOOLEAN
SEnvBatchIsActive( 
    VOID
    );

VOID
SEnvSetBatchAbort( 
    VOID
    );

VOID
SEnvBatchGetConsole( 
    OUT SIMPLE_INPUT_INTERFACE       **ConIn,
    OUT SIMPLE_TEXT_OUTPUT_INTERFACE **ConOut
    );

EFI_STATUS
SEnvBatchEchoCommand( 
    IN ENV_SHELL_INTERFACE  *Shell
    );

VOID
SEnvBatchSetEcho( 
    IN BOOLEAN Val
    );

BOOLEAN
SEnvBatchGetEcho( 
    VOID
    );

EFI_STATUS
SEnvBatchSetFilePos( 
    IN UINT64 NewPos
    );

EFI_STATUS
SEnvBatchGetFilePos( 
    UINT64  *FilePos
    );

VOID
SEnvBatchSetCondition( 
    IN BOOLEAN Val 
    );

VOID
SEnvBatchSetGotoActive( 
    VOID
    );

BOOLEAN
SEnvBatchVarIsLastError( 
    IN CHAR16 *Name 
    );

CHAR16*
SEnvBatchGetLastError( 
    VOID 
    );

VOID
SEnvBatchSetLastError( 
    IN UINTN NewLastError 
    );

EFI_STATUS
SEnvBatchGetArg(
    IN  UINTN  Argno,
    OUT CHAR16 **Argval
    );

EFI_STATUS
SEnvExecuteScript(
    IN ENV_SHELL_INTERFACE          *Shell,
    IN EFI_FILE_HANDLE          File
    );

/* 
 *  Prototypes from dprot.c
 */

VOID SEnvDPath (EFI_HANDLE, VOID *);
VOID SEnvDPathTok (EFI_HANDLE, VOID *);
VOID SEnvTextOut (EFI_HANDLE, VOID *);
VOID SEnvBlkIo (EFI_HANDLE, VOID *);
VOID SEnvImageTok (EFI_HANDLE, VOID *);
VOID SEnvImage (EFI_HANDLE, VOID *);

/* 
 *  Prototypes from map.c
 */

VOID
SEnvInitMap (
    VOID
    );

CHAR16 *
SEnvGetDefaultMapping (
    IN EFI_HANDLE ImageHandle
    );

EFI_STATUS
INTERNAL
SEnvCmdMap (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_STATUS
INTERNAL
SEnvCmdMount (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

VARIABLE_ID *
SEnvMapDeviceFromName (
    IN OUT CHAR16   **pPath
    );

EFI_DEVICE_PATH *
SEnvIFileNameToPath (
    IN CHAR16               *Path
    );

EFI_DEVICE_PATH *
SEnvFileNameToPath (
    IN CHAR16               *Path
    );

EFI_DEVICE_PATH *
SEnvNameToPath (
    IN CHAR16                   *PathName
    );

EFI_STATUS
SEnvSetCurrentDevice (
    IN CHAR16       *Name
    );

CHAR16 *
SEnvGetCurDir (
    IN CHAR16       *DeviceName OPTIONAL    
    );

EFI_STATUS
SEnvCmdCd (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 *  Prototypes from echo.c
 */

EFI_STATUS
SEnvCmdEcho (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 *  Prototypes from if.c
 */

EFI_STATUS
SEnvCmdIf (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_STATUS
SEnvCmdEndif (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 *  Prototypes from goto.c
 */

EFI_STATUS
SEnvCmdGoto (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_STATUS
SEnvCheckForGotoTarget(
    IN  CHAR16 *Candidate,
    IN  UINT64 GotoFilePos, 
    IN  UINT64 FilePosition, 
    OUT UINTN  *GotoTargetStatus
    );

VOID
SEnvPrintLabelNotFound( 
    VOID
    );

VOID
SEnvInitTargetLabel(
    VOID
    );

VOID
SEnvFreeTargetLabel(
    VOID
    );

/* 
 *  Prototypes from for.c
 */

VOID
SEnvInitForLoopInfo (
    VOID
    );

EFI_STATUS
SEnvSubstituteForLoopIndex( 
    IN CHAR16  *Str,
    OUT CHAR16 **Val
    );

EFI_STATUS
SEnvCmdFor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_STATUS
SEnvCmdEndfor (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 *  Prototypes from pause.c
 */

EFI_STATUS
SEnvCmdPause (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 *  Prototypes from marg.c
 */

CHAR16 *
SEnvFileHandleToFileName (
    IN EFI_FILE_HANDLE      Handle
    );

EFI_STATUS
SEnvFreeFileList (
    IN OUT LIST_ENTRY       *ListHead
    );

EFI_STATUS
SEnvFileMetaArg (
    IN CHAR16               *Arg,
    IN OUT LIST_ENTRY       *ListHead
    );

VOID
EFIStructsPrint (
    IN  VOID            *Buffer,
    IN  UINTN           BlockSize,
    IN  UINT64          BlockAddress,
    IN  EFI_BLOCK_IO    *BlkIo
);

EFI_STATUS
DumpBlockDev (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

/* 
 *  Global data
 */

extern EFI_GUID SEnvEnvId;
extern EFI_GUID SEnvMapId;
extern EFI_GUID SEnvProtId;
extern EFI_GUID SEnvAliasId;
extern EFI_SHELL_ENVIRONMENT SEnvInterface;
extern EFI_FILE SEnvIOFromCon;
extern EFI_FILE SEnvErrIOFromCon;
extern FLOCK SEnvLock;
extern FLOCK SEnvGuidLock;
extern UINTN SEnvNoHandles;
extern EFI_HANDLE *SEnvHandles;
extern SIMPLE_TEXT_OUTPUT_INTERFACE SEnvConToIo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\mount.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    mount.c
    
Abstract:
    Mount a file system on removable media   




Revision History

--*/

#include "shelle.h"


EFI_STATUS
SEnvCmdMount (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*
    mount BlockDeviceName 
 */
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;          
    EFI_BLOCK_IO        *BlkIo;
    EFI_HANDLE          Handle;
    UINT8               *Buffer;
    UINTN               Count;

    DEFAULT_CMD         Cmd;
    UINTN               HandleNo;
    CHAR16              *Sname;

    InitializeShellApplication (ImageHandle, SystemTable);

    if ( SI->Argc < 2 ) {
        Print (L"Usage - %Hmount%N BlockDeviceName [ShortName]\n");
        return EFI_SUCCESS;
    }

    if (SI->Argc >= 3) {
        Sname = SI->Argv[2];
        if (*Sname == '/' || *Sname == '-') {
            Print (L"Usage - %Hmount%N BlockDeviceName [ShortName]\n");
            return EFI_SUCCESS;
        }
    } else {
        Sname = NULL;
    }
    /* 
     *  Check for the device mapping
     */

    DevicePath = (EFI_DEVICE_PATH *)ShellGetMap (SI->Argv[1]);
    if (DevicePath == NULL) {
        return EFI_INVALID_PARAMETER;
    }

    Status = BS->LocateDevicePath (&BlockIoProtocol, &DevicePath, &Handle);
    if (EFI_ERROR(Status)) {
        Print (L"%E - Device Path Not a BlockIo Device %r%N", Status);
        return Status;
    }
    Status = BS->HandleProtocol (Handle, &BlockIoProtocol, (VOID*)&BlkIo);
    if (EFI_ERROR(Status)) {
        Print (L"%E - Device Not a BlockIo Device %r%N", Status);
        return Status;
    }

    /* 
     * 
     */
    Buffer = AllocatePool (BlkIo->Media->BlockSize);
    if (Buffer == NULL) {
        return EFI_OUT_OF_RESOURCES;
    }

    /* 
     *  In EFI the filesystem driver registers to get notified when DiskIo Devices are
     *   added to the system. DiskIo devices register to get notified when BlkIo devices
     *   are added to the system. So when a block device shows up a DiskIo is added, and 
     *   then a filesystem if added if the media contains a filesystem. This works great,
     *   but when you boot with no media in the device and then put media in the device
     *   there is no way to make the notify happen.
     * 
     *  This code reads a block device. If the BlkIo device returns EFI_MEDIA_CHANGE 
     *   then it must reinstall in BlkIo protocol. This cause the notifes that make the
     *   filesystem show up. The 4 loops is just a guess it has no magic meaning. 
     */
    for (Count = 0; Count < 4; Count++) {
        Status = BlkIo->ReadBlocks (BlkIo, BlkIo->Media->MediaId, 0, BlkIo->Media->BlockSize, Buffer);
        if (Status == EFI_SUCCESS) {
            break;
        }
        if (Status == EFI_MEDIA_CHANGED) {
            Print (L"\nMedia Changed - File System will attempt to mount\n");
            break;
        }
    }

    if (Sname) {
        SEnvLoadHandleTable();

        for (HandleNo=0; HandleNo < SEnvNoHandles; HandleNo++) {
            if (Handle == SEnvHandles[HandleNo]) {
                break;
            }
        }
        HandleNo += 1;

        Print (L"\nmap %s %x\n", Sname, HandleNo);
        Cmd.Line = Cmd.Buffer;
        SPrint (Cmd.Line, sizeof(Cmd.Buffer), L"map %s %x", Sname, HandleNo);
        SEnvExecute (ImageHandle, Cmd.Line, TRUE);

        SEnvFreeHandleTable();
    }

    /* 
     *  This print is for debug. From the BlkIo protocol you can do a memory dump
     *   and get the instance data.
     */
    Print (L"\n%EDebug Code%N Handle -> 0x%08x BlkIo -> 0x%08x\n", Handle, BlkIo);
    FreePool (Buffer);
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\time\time.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    time.c
    
Abstract:   


Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeTime (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeTime)

EFI_STATUS
InitializeTime (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

    time [hh:mm:ss] 

 --*/
{
    EFI_STATUS  Status;
    EFI_TIME    Time;
    CHAR16      *TimeString;
    UINT32      i;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeTime, 
        L"time",                            /*  command */
        L"time [hh:mm:ss]",                 /*  command syntax */
        L"Get or set time",                 /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    InitializeShellApplication (ImageHandle, SystemTable);
    
    if (SI->Argc > 2) {
        Print(L"time [hh:mm:ss]\n");
        return EFI_SUCCESS;
    }

    if (SI->Argc == 1) {
        Status = RT->GetTime(&Time,NULL);

        if (!EFI_ERROR(Status)) {
            Print(L"%02d:%02d:%02d\n",Time.Hour,Time.Minute,Time.Second);
        }
        return EFI_SUCCESS;
    }

    if (StrCmp(SI->Argv[1],L"/?") == 0) {
        Print(L"time [hh:mm:ss]\n");
        return EFI_SUCCESS;
    }
    if (StrCmp(SI->Argv[1],L"/h") == 0) {
        Print(L"time [hh:mm:ss]\n");
        return EFI_SUCCESS;
    }

    Status = RT->GetTime(&Time,NULL);
    if (EFI_ERROR(Status)) {
        Print(L"error : RTC not functional\n");
        return Status;
    }

    TimeString = SI->Argv[1];
    Time.Hour = (UINT8)Atoi(TimeString);
    if ((INT8)Time.Hour<0 || Time.Hour>23) {
        Print(L"error : invalid hour\n");
        return EFI_INVALID_PARAMETER;
    }
    for(i=0;i<StrLen(TimeString) && TimeString[i]!=':';i++);
    if (TimeString[i]==':') {
        i++;
        Time.Minute = (UINT8)Atoi(&(TimeString[i]));
        if ((INT8)Time.Minute<0 || Time.Minute>59) {
            Print(L"error : invalid minutes\n");
            return EFI_INVALID_PARAMETER;
        }
        for(;i<StrLen(TimeString) && TimeString[i]!=':';i++);
        if (TimeString[i]==':') {
            i++;
            Time.Second = (UINT8)Atoi(&(TimeString[i]));
        } else {
            Time.Second = 0;
        }
        if ((INT8)Time.Second<0 || Time.Second>59) {
            Print(L"error : invalid seconds\n");
            return EFI_INVALID_PARAMETER;
        }
        Status = RT->SetTime(&Time);
        if (EFI_ERROR(Status)) {
            Print(L"error : RTC not functional\n");
            return Status;
        }
        return EFI_SUCCESS;
    }    
    Print(L"error : invalid time format\n");
    return EFI_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\touch\touch.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    touch.c
    
Abstract:

    Shell app "touch" - touches the files last modification time

Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeTouch (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
TouchFile (
    IN SHELL_FILE_ARG       *Arg
    );


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeTouch)

EFI_STATUS
InitializeTouch (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeTouch,
        L"touch",                       /*  command */
        L"touch [filename]",            /*  command syntax */
        L"View/sets file attributes",   /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;
    InitializeListHead (&FileList);

    /* 
     *  Expand each arg
     */

    for (Index = 1; Index < Argc; Index += 1) {
        ShellFileMetaArg (Argv[Index], &FileList);
    }

    /* 
     *  Attrib each file
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        TouchFile (Arg);
    }

    ShellFreeFileList (&FileList);
    return EFI_SUCCESS;
}

VOID
TouchFile (
    IN SHELL_FILE_ARG           *Arg
    )
{
    EFI_STATUS                  Status;

    Status = Arg->Status;
    if (!EFI_ERROR(Status)) {
        RT->GetTime (&Arg->Info->ModificationTime, NULL);
        Status = Arg->Handle->SetInfo(  
                    Arg->Handle,
                    &GenericFileInfo,
                    (UINTN) Arg->Info->Size,
                    Arg->Info
                    );
    }

    if (EFI_ERROR(Status)) {
        Print (L"touch: %s : %hr\n", Arg->FullName, Status);
    } else {
        Print (L"touch: %s [ok]\n", Arg->FullName);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\stall\stall.c ===
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    stall.c
    
Abstract:   


Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeStall (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeStall)

EFI_STATUS
InitializeStall (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*+++

    stall [microseconds]

 --*/
{
    UINTN      Microseconds;

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeStall, 
        L"stall",                           /*  command */
        L"stall microseconds",              /*  command syntax */
        L"Delay for x microseconds",        /*  1 line descriptor     */
        NULL                                /*  command help page */
        );

    InitializeShellApplication (ImageHandle, SystemTable);
    
    if (SI->Argc != 2) {
        Print(L"stall [microseconds]\n");
        return EFI_SUCCESS;
    }

    if (BS->Stall == NULL) {
        Print(L"ERROR : Stall service is not available.\n");
        return EFI_UNSUPPORTED;
    }
    Microseconds = Atoi(SI->Argv[1]);
    Print(L"Stall for %d uS\n",Microseconds);
    BS->Stall(Microseconds);
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\shellenv\var.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    protid.c
    
Abstract:

    Shell environment variable management



Revision History

--*/


#include "shelle.h"

/* 
 *  The different variable catagories
 */

LIST_ENTRY  SEnvEnv;
LIST_ENTRY  SEnvMap;
LIST_ENTRY  SEnvAlias;



VOID
SEnvInitVariables (
    VOID
    )
{
    CHAR16              *Name;
    CHAR16              *Data;
    UINTN               BufferSize;
    UINTN               NameSize, DataSize;
    EFI_GUID            Id;
    LIST_ENTRY          *ListHead;
    VARIABLE_ID         *Var;
    EFI_STATUS          Status;
    BOOLEAN             IsString;
    UINT32              Attributes;
    UINTN               Size;


    /* 
     *  Initialize the different variable lists
     */

    InitializeListHead (&SEnvEnv);
    InitializeListHead (&SEnvMap);
    InitializeListHead (&SEnvAlias);

    BufferSize = 1024;
    Name = AllocatePool (BufferSize);
    Data = AllocatePool (BufferSize);
    ASSERT(Name && Data); 

    /* 
     *  Read all the variables in the system and collect ours
     */

    Name[0] = 0;
    for (; ;) {
        NameSize = BufferSize;
        Status = RT->GetNextVariableName (&NameSize, Name, &Id);
        if (EFI_ERROR(Status)) {
            break;
        }

        /* 
         *  See if it's a shellenv variable
         */

        ListHead = NULL;
        IsString = FALSE;
        if (CompareGuid (&Id, &SEnvEnvId) == 0) {
            ListHead = &SEnvEnv;
            IsString = TRUE;
        }

        if (CompareGuid (&Id, &SEnvMapId) == 0) {
            ListHead = &SEnvMap;
        }


        if (CompareGuid (&Id, &SEnvAliasId) == 0) {
            ListHead = &SEnvAlias;
            IsString = TRUE;
        }

        if (ListHead) {
            DataSize = BufferSize;
            Status = RT->GetVariable (Name, &Id, &Attributes, &DataSize, Data);

            if (!EFI_ERROR(Status)) {

                /* 
                 *  Add this value
                 */

                Size = sizeof(VARIABLE_ID) + StrSize(Name) + DataSize;
                Var  = AllocateZeroPool (Size);

                Var->Signature = VARIABLE_SIGNATURE;
                Var->u.Value = ((UINT8 *) Var) + sizeof(VARIABLE_ID);
                Var->Name = (CHAR16*) (Var->u.Value + DataSize);
                Var->ValueSize = DataSize;
                CopyMem (Var->u.Value, Data, DataSize);
                CopyMem (Var->Name, Name, NameSize);

                if( Attributes & EFI_VARIABLE_NON_VOLATILE ) {
                    Var->Flags = NON_VOL ; 
                }
                else {
                    Var->Flags = VOL ; 
                }

                InsertTailList (ListHead, &Var->Link);
            }
        }

        /* 
         *  If this is a protocol entry, add it
         */

        if (CompareGuid (&Id, &SEnvProtId) == 0) {

            DataSize = BufferSize;
            Status = RT->GetVariable (Name, &Id, &Attributes, &DataSize, Data);

            if (!EFI_ERROR(Status)  && DataSize == sizeof (EFI_GUID)) {

                SEnvIAddProtocol (FALSE, (EFI_GUID *) Data, NULL, NULL, Name);

            } else {

                DEBUG ((D_INIT|D_WARN, "SEnvInitVariables: skipping bogus protocol id %s\n", Var->Name));
                RT->SetVariable (Name, &SEnvProtId, 0, 0, NULL);

            }
        }
    }

    FreePool (Name);
    FreePool (Data);
}


CHAR16 *
SEnvIGetStr (
    IN CHAR16           *Name,
    IN LIST_ENTRY       *Head
    )
{
    LIST_ENTRY          *Link;
    VARIABLE_ID         *Var;
    CHAR16              *Value;

    AcquireLock (&SEnvLock);

    Value = NULL;
    for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
        Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
        if (StriCmp (Var->Name, Name) == 0) {
            Value = Var->u.Str;
            break;
        }
    }

    ReleaseLock (&SEnvLock);
    return Value;
}

CHAR16 *
SEnvGetMap (
    IN CHAR16           *Name
    )
{
    return SEnvIGetStr (Name, &SEnvMap);
}

CHAR16 *
SEnvGetEnv (
    IN CHAR16           *Name
    )
{
    return SEnvIGetStr (Name, &SEnvEnv);
}

CHAR16 *
SEnvGetAlias (
    IN CHAR16           *Name
    )
{
    return SEnvIGetStr (Name, &SEnvAlias);
}


VOID
SEnvSortVarList (
    IN LIST_ENTRY               *Head
    )
{
    ASSERT_LOCKED(&SEnvLock);


    return ;
}


EFI_STATUS
SEnvCmdSA (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable,
    IN LIST_ENTRY               *Head,
    IN EFI_GUID                 *Guid
    )
/*  Code for shell "set" & "alias" command */
{
    LIST_ENTRY                  *Link;
    VARIABLE_ID                 *Var;
    VARIABLE_ID                 *Found;
    CHAR16                      *Name;
    CHAR16                      *Value;    
    UINTN                       Size, SLen, Len;
    BOOLEAN                     Delete;    
    EFI_STATUS                  Status;
    UINTN                       Index;
    CHAR16                      *p;
    BOOLEAN                     PageBreaks;
    UINTN                       TempColumn;
    UINTN                       ScreenCount;
    UINTN                       ScreenSize;
    CHAR16                      ReturnStr[1];
    BOOLEAN                     Volatile;    

    InitializeShellApplication (ImageHandle, SystemTable);

    Name = NULL;
    Value = NULL;
    Delete = FALSE;
    Status = EFI_SUCCESS;
    Found = NULL;
    Volatile = FALSE;

    /* 
     *  Crack arguments
     */

    PageBreaks = FALSE;
    for (Index = 1; Index < SI->Argc; Index += 1) {
        p = SI->Argv[Index];
        if (*p == '-') {
            switch (p[1]) {
            case 'd':
            case 'D':
                Delete = TRUE;
                break;

            case 'b' :
            case 'B' :
                PageBreaks = TRUE;
                ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                ScreenCount = 0;
                break;

            case 'v' :
            case 'V' :
                Volatile = TRUE;
                break;

            default:
                Print (L"%ESet/Alias: Unknown flag %s\n", p);
                return EFI_INVALID_PARAMETER;
            }
            continue;
        }

        if (!Name) {
            Name = p;
            continue;
        }

        if (!Value) {
            Value = p;
            continue;
        }

        Print (L"%ESet/Alias: too many arguments\n");
        return EFI_INVALID_PARAMETER;
    }

    if (Delete && Value) {
        Print (L"%ESet/Alias: too many arguments\n");
    }

    /* 
     *  Process
     */

    AcquireLock (&SEnvLock);

    if (!Name) {
        /*  dump the list */
        SEnvSortVarList (Head);

        SLen = 0;
        for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
            Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
            Len = StrLen(Var->Name);
            if (Len > SLen) {
                SLen = Len;
            }
        }


        for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
            Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
            if( Var->Flags == VOL ) {
                Print(L"  * %h-.*s : %s\n", SLen, Var->Name, Var->u.Str);
            }
            else {
                Print(L"    %h-.*s : %s\n", SLen, Var->Name, Var->u.Str);
            }

            if (PageBreaks) {
                ScreenCount++;
                if (ScreenCount > ScreenSize - 4) {
                    ScreenCount = 0;
                    Print (L"\nPress Return to contiue :");
                    Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                    Print (L"\n\n");
                }
            }
        }

    } else {
        /* 
         *  Find the specified value
         */


        for (Link=Head->Flink; Link != Head; Link=Link->Flink) {
            Var = CR(Link, VARIABLE_ID, Link, VARIABLE_SIGNATURE);
            if (StriCmp(Var->Name, Name) == 0) {
                Found = Var;
                break;
            }
        }

        if (Found && Delete) {
            
            /* 
             *  Remove it from the store
             */

            Status = RT->SetVariable (Found->Name, Guid, 0, 0, NULL);
            if (Status == EFI_NOT_FOUND) {
                Print (L"Set/Alias: could not find '%hs'\n", Found->Name);
                Status = EFI_SUCCESS;
            }

        } else if (Value) {

            /* 
             *  Add it to the store
             */

            if( Found && ( ( Volatile && ( Found->Flags == NON_VOL ) ) ||
                    ( !Volatile && ( Found->Flags == VOL ) ) ) )
            {
                if( Found->Flags == NON_VOL ) {
                    Print (L"Set/Alias: '%hs' already exists as non-volatile variable\n", Found->Name ) ;
                }
                else {
                    Print (L"Set/Alias: '%hs' already exists as volatile variable\n", Found->Name ) ;
                }
                Found = NULL ;
                Status = EFI_ACCESS_DENIED ;
            }
            else
            {
                Status = RT->SetVariable (
                    Found ? Found->Name : Name,
                    Guid, 
                    EFI_VARIABLE_BOOTSERVICE_ACCESS | ( Volatile ? 0 : EFI_VARIABLE_NON_VOLATILE ),
                    StrSize(Value), 
                    Value
                    );

                if (!EFI_ERROR(Status)) {

                    /* 
                     *  Make a new in memory copy
                     */

                    Size = sizeof(VARIABLE_ID) + StrSize(Name) + StrSize(Value);
                    Var  = AllocateZeroPool (Size);

                    Var->Signature = VARIABLE_SIGNATURE;
                    Var->u.Value = ((UINT8 *) Var) + sizeof(VARIABLE_ID);
                    Var->Name = (CHAR16*) (Var->u.Value + StrSize(Value));
                    Var->ValueSize = StrSize(Value);
                    StrCpy (Var->u.Str, Value);
                    StrCpy (Var->Name, Found ? Found->Name : Name);
                    if( Volatile ) {
                        Var->Flags = VOL ; 
                    }
                    else {
                        Var->Flags = NON_VOL ; 
                    }

                    InsertTailList (Head, &Var->Link);
                }
            }

        } else {

            if (Found) {
                Print(L"  %hs : %s\n", Var->Name, Var->u.Str);
            } else {
                Print(L"'%es' not found\n", Name);
            }

            Found = NULL;
        }


        /* 
         *  Remove the old in memory copy if there was one
         */

        if (Found) {
            RemoveEntryList (&Found->Link);
            FreePool (Found);
        }
    }

    ReleaseLock (&SEnvLock);
    return Status;
}


EFI_STATUS
SEnvCmdSet (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*  Code for internal shell "set" command */
{
    return SEnvCmdSA (ImageHandle, SystemTable, &SEnvEnv, &SEnvEnvId);
}


EFI_STATUS
SEnvCmdAlias (
    IN EFI_HANDLE               ImageHandle,
    IN EFI_SYSTEM_TABLE         *SystemTable
    )
/*  Code for internal shell "set" command */
{
    return SEnvCmdSA (ImageHandle, SystemTable, &SEnvAlias, &SEnvAliasId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\ver\ver.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    ver.h

Abstract:

    declares interface functions

Revision History

--*/

/* 
 * 
 */

VOID
DisplayExtendedVersionInfo (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\ver\ver.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    ver.c
    
Abstract:

    Shell app "ver"



Revision History

--*/

#include "shell.h"
#include "ver.h"


/* 
 * 
 */

EFI_STATUS
InitializeVer (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeVer)

EFI_STATUS
InitializeVer (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeVer,
        L"ver",                      /*  command */
        L"ver",                      /*  command syntax */
        L"Displays version info",    /*  1 line descriptor */
        NULL                         /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     * 
     */

    Print(L"EFI Specification Revision      %d.%d\n",ST->Hdr.Revision>>16,ST->Hdr.Revision&0xffff);
    Print(L"  EFI Vendor        = %s\n", ST->FirmwareVendor);
    Print(L"  EFI Revision      = %d.%d\n", ST->FirmwareRevision >> 16, ST->FirmwareRevision & 0xffff);


    /* 
     *  Display additional version info depending on processor type
     */

    DisplayExtendedVersionInfo(ImageHandle,SystemTable);

    /* 
     *  Done
     */

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\type\type.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    type.c
    
Abstract:

    Shell app "type"



Revision History

--*/

#include "shell.h"


/* 
 * 
 */

EFI_STATUS
InitializeType (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


VOID
TypeFile (
    IN SHELL_FILE_ARG          *Arg,
    IN BOOLEAN                 PageBreaks,
    IN UINTN                   ScreenSize
    );


BOOLEAN     TypeAscii;
BOOLEAN     TypeUnicode;


/* 
 * 
 */

EFI_DRIVER_ENTRY_POINT(InitializeType)

EFI_STATUS
InitializeType (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  **Argv;
    UINTN                   Argc;
    UINTN                   Index;
    LIST_ENTRY              FileList;
    LIST_ENTRY              *Link;
    SHELL_FILE_ARG          *Arg;
    CHAR16                  *p;
    BOOLEAN                 PageBreaks;
    UINTN                   TempColumn;
    UINTN                   ScreenSize;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeType,
        L"type",                        /*  command */
        L"type [-a] [-u] [-b] file",    /*  command syntax */
        L"Type file",                   /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);
    Argv = SI->Argv;
    Argc = SI->Argc;

    /* 
     *  Scan args for flags
     */

    InitializeListHead (&FileList);
    TypeAscii   = FALSE;
    TypeUnicode = FALSE;
    PageBreaks  = FALSE;
    for (Index = 1; Index < Argc; Index += 1) {
        if (Argv[Index][0] == '-') {
            for (p = Argv[Index]+1; *p; p++) {
                switch (*p) {
                case 'a':
                case 'A':
                    TypeAscii = TRUE;
                    break;
                case 'u':
                case 'U':
                    TypeUnicode = TRUE;
                    break;
                case 'b' :
                case 'B' :
                    PageBreaks = TRUE;
                    ST->ConOut->QueryMode (ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
                    break;

                default:
                    Print (L"type: Unknown flag %s\n", Argv[Index]);
                    goto Done;
                }
            }
        }
    }

    /* 
     *  Expand each arg
     */

    for (Index = 1; Index < Argc; Index += 1) {
        if (Argv[Index][0] != '-') {
            ShellFileMetaArg (Argv[Index], &FileList);
        }
    }

    if (IsListEmpty(&FileList)) {
        Print (L"type: No file specified\n");
        goto Done;
    }

    /* 
     *  Type each file
     */

    for (Link=FileList.Flink; Link!=&FileList; Link=Link->Flink) {
        Arg = CR(Link, SHELL_FILE_ARG, Link, SHELL_FILE_ARG_SIGNATURE);
        TypeFile (Arg, PageBreaks, ScreenSize);
    }

Done:    
    ShellFreeFileList (&FileList);
    return EFI_SUCCESS;
}


VOID
TypeFile (
    IN SHELL_FILE_ARG          *Arg,
    IN BOOLEAN                 PageBreaks,
    IN UINTN                   ScreenSize
    )
{
    EFI_STATUS                  Status;
    CHAR16                      Buffer[512];
    CHAR8                       *CharBuffer;
    CHAR16                      *WideBuffer;
    EFI_FILE_HANDLE             Handle;
    UINTN                       Size;
    BOOLEAN                     FormatAscii;
    UINTN                       Index;
    UINTN                       j;
    UINTN                       ScreenCount;
    CHAR16                      ReturnStr[1];
    CHAR16                      ch;

    ScreenCount = 0;
    Status = Arg->Status;
    if (!EFI_ERROR(Status)) {
        if (Arg->Info->Attribute & EFI_FILE_DIRECTORY) {
            Print(L"type: %hs is a directory\n", Arg->FullName);
            return;
        }

        Handle = Arg->Handle;
        Print(L"%HFile: %s, Size %,ld%N\n", Arg->FullName, Arg->Info->FileSize);

        /* 
         *  Unicode files start with a marker of 0xff, 0xfe.  Skip it.
         */

        FormatAscii = TypeAscii;

        if (!TypeAscii) {
            Size = 2;
            Status = Handle->Read (Handle, &Size, Buffer);
            if (Buffer[0] != UNICODE_BYTE_ORDER_MARK) {
                if (TypeUnicode) {
                    Print (L"%.*s", Size/sizeof(CHAR16), Buffer);
                } else {
                    FormatAscii = TRUE;
                    Print (L"%.*a", Size, Buffer);
                }
            }
        }

        for (; ;) {
            Size = sizeof(Buffer);
            Status = Handle->Read (Handle, &Size, Buffer);
            if (EFI_ERROR(Status) || !Size) {
                break;
            }

            if (FormatAscii) {
                Size = Size / sizeof(CHAR8);
            } else {
                Size = Size / sizeof(CHAR16);
            }
            WideBuffer = (CHAR16 *)Buffer;
            CharBuffer = (CHAR8 *)Buffer;

            if (PageBreaks) {
                for (Index = 0; Index < Size && ScreenCount <= (ScreenSize - 4); ) {
                    for (j=0; Index < Size && ScreenCount <= (ScreenSize - 4); j++,Index++) {
                        if (FormatAscii) {
                            ch = (CHAR16)CharBuffer[j];
                        } else {
                            ch = WideBuffer[j];
                        }
                        if (ch == '\n') {
                            ScreenCount++;
                        }
                    }
                    if (FormatAscii) {
                        Print (L"%.*a", j, CharBuffer);
                        CharBuffer = CharBuffer + j;
                    } else {
                        Print (L"%.*s", j, WideBuffer);
                        WideBuffer = WideBuffer + j;
                    }
                    if (ScreenCount > (ScreenSize - 4)) {
                        ScreenCount = 0;
                        Print (L"\nPress Return to continue :");
                        Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
                        Print (L"\n\n");
                    }
                }
            } else {
                if (FormatAscii) {
                    Print (L"%.*a", Size, CharBuffer);
                } else {
                    Print (L"%.*s", Size, Buffer);
                }
            }
        }
    }

    if (EFI_ERROR(Status)) {
        Print (L"type: %hs - %hr\n", Arg->FullName, Status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\ver\ia32\ver32.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    ver32.c
    
Abstract:

    Part of shell app "ver"



Revision History

--*/

#include "shell.h"
#include "ver.h"

/* 
 * 
 */

VOID
DisplayExtendedVersionInfo (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    
    /* 
     *  Done
     */

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\vol\vol.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    vol.c
    
Abstract:

    Shell app "vol"



Revision History

--*/

#include "shell.h"

EFI_STATUS
InitializeVol (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

EFI_DRIVER_ENTRY_POINT(InitializeVol)

EFI_STATUS
InitializeVol (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    CHAR16                  *VolumeLabel = NULL;
    EFI_STATUS              Status;
    EFI_DEVICE_PATH         *DevicePath;
    EFI_FILE_IO_INTERFACE   *Vol;
    EFI_FILE_HANDLE         RootFs;
    EFI_FILE_SYSTEM_INFO    *VolumeInfo;
    UINTN                   Size;
    CHAR16                  *CurDir;
    UINTN                   i;

    /* 
     *  Check to see if the app is to install as a "internal command" 
     *  to the shell
     */

    InstallInternalShellCommand (
        ImageHandle,   SystemTable,   InitializeVol,
        L"vol",                         /*  command */
        L"vol fs [Volume Label]",       /*  command syntax */
        L"Set or display volume label", /*  1 line descriptor */
        NULL                            /*  command help page */
        );

    /* 
     *  We are no being installed as an internal command driver, initialize
     *  as an nshell app and run
     */

    InitializeShellApplication (ImageHandle, SystemTable);

    /* 
     * 
     */


    if ( SI->Argc < 1 || SI->Argc > 3 ) {
        Print(L"vol [fs] [volume label]\n");
        BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);
    }

    DevicePath = NULL;
    if (SI->Argc == 1) {
        CurDir = ShellCurDir(NULL);
        if (CurDir) {
            for (i=0; i < StrLen(CurDir) && CurDir[i] != ':'; i++);
            CurDir[i] = 0;
            DevicePath = (EFI_DEVICE_PATH *)ShellGetMap (CurDir);
        }
    } else {
        DevicePath = (EFI_DEVICE_PATH *)ShellGetMap (SI->Argv[1]);
    }
    if (DevicePath == NULL) {
        Print (L"%s is not a mapped short name\n", SI->Argv[1]);
        return EFI_INVALID_PARAMETER;
    }
    Status = LibDevicePathToInterface (&FileSystemProtocol, DevicePath, (VOID **)&Vol);
    if (EFI_ERROR(Status)) {
        Print (L"%s is not a file system\n",SI->Argv[1]);
        return Status;
    }

    if ( SI->Argc == 3 ) {
        VolumeLabel = SI->Argv[2];
        if (StrLen(VolumeLabel) > 11) {
            Print(L"Volume label %s is longer than 11 characters\n",VolumeLabel);
            return EFI_INVALID_PARAMETER;
        }
    }

    Status = Vol->OpenVolume (Vol, &RootFs);

    if (EFI_ERROR(Status)) {
        Print(L"Can not open the volume %s\n",SI->Argv[1]);
        return Status;
    }

    /* 
     *  
     */

    Size = SIZE_OF_EFI_FILE_SYSTEM_INFO + 100;
    VolumeInfo = (EFI_FILE_SYSTEM_INFO *)AllocatePool(Size);
    Status = RootFs->GetInfo(RootFs,&FileSystemInfo,&Size,VolumeInfo);

    if (EFI_ERROR(Status)) {
        Print(L"Can not get a volume information for %s\n",SI->Argv[1]);
        return Status;
    }

    if (VolumeLabel) {
        StrCpy (VolumeInfo->VolumeLabel, VolumeLabel);

        Size = SIZE_OF_EFI_FILE_SYSTEM_INFO + StrSize(VolumeLabel);

        Status = RootFs->SetInfo(RootFs,&FileSystemInfo,Size,VolumeInfo);

        if (EFI_ERROR(Status)) {
            Print(L"Can not set volume information for %s\n",SI->Argv[1]);
            return Status;
        }

        Status = RootFs->GetInfo(RootFs,&FileSystemInfo,&Size,VolumeInfo);

        if (EFI_ERROR(Status)) {
            Print(L"Can not verify a volume information for %s\n",SI->Argv[1]);
            return Status;
        }
    }

    if (StrLen(VolumeInfo->VolumeLabel) == 0) {
        Print(L"Volume has no label",VolumeInfo->VolumeLabel);
    } else {
        Print(L"Volume %s",VolumeInfo->VolumeLabel);
    }
    if (VolumeInfo->ReadOnly) {
        Print(L" (ro)\n");
    } else {
        Print(L" (rw)\n");
    }
    Print(L"  %13,d bytes total disk space\n",VolumeInfo->VolumeSize);
    Print(L"  %13,d bytes available on disk\n",VolumeInfo->FreeSpace);
    Print(L"  %13,d bytes in each allocation unit\n",VolumeInfo->BlockSize);

    RootFs->Close(RootFs);

    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\imports.h ===
#include <nt.h>
#include <windef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\sdk\shell\ver\ia64\ver64.c ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    ver64.c
    
Abstract:

    Part of shell app "ver"



Revision History

--*/

#include "shell.h"
#include "ver.h"
#include "SalProc.h"

/* 
 * 
 */
BOOLEAN
IsCacheEnabled (
    VOID
    );

VOID
DisplayExtendedVersionInfo (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    
    EFI_STATUS              Status;
    SAL_SYSTEM_TABLE_HDR    *SST_Hdr;
    VOID                    *SalSystemTable;
    FIT_ENTRY               *FIT;
    UINTN                   FitCount;
    UINT64                  *FIT_Entry_Start_Ptr;
    UINT8                   FIT_Type;
    PLABEL                  SalPlabel;
    UINT64                  PalEntry;
    UINT64                  IoPortBase;
    CHAR8                   BuildInfo[33];

    /* 
     *  walk the SST header to get SAL version info
     */

    Status = LibGetSystemConfigurationTable(&SalSystemTableGuid,&SalSystemTable);
    if (!EFI_ERROR(Status)) {
        /* 
         *  SAL revisions
         */
        
        Print(L"\n");
        SST_Hdr = (SAL_SYSTEM_TABLE_HDR *)SalSystemTable;
        Print(L"SAL Specification Revision      %d.%2d\n",BCDtoDecimal((UINT8)(SST_Hdr->Revision >> 8)),
                                                     BCDtoDecimal((UINT8)(SST_Hdr->Revision & 0x00FF)));

        Print(L"  SAL_A Revision    = %d.%2d\n",    BCDtoDecimal((UINT8)(SST_Hdr->SALA_Ver >> 8)),
                                                   BCDtoDecimal((UINT8)(SST_Hdr->SALA_Ver & 0x00FF)));

        Print(L"  SAL_B Revision    = %d.%2d\n",    BCDtoDecimal((UINT8)(SST_Hdr->SALB_Ver >> 8)),
                                                   BCDtoDecimal((UINT8)(SST_Hdr->SALB_Ver & 0x00FF)));
    

        /* 
         *  PAL revisions
         */

        Print(L"\n");
        FIT = (FIT_ENTRY *) FIT_PALA_ENTRY;
        Print(L"PAL_A Revision        %d.%2d\n",BCDtoDecimal((UINT8)(FIT->Revision >> 8)),
                                                         BCDtoDecimal((UINT8)(FIT->Revision & 0x00FF)));

        FIT_Entry_Start_Ptr = (UINT64 *) FIT_ENTRY_PTR;
        FIT = (FIT_ENTRY *) (*FIT_Entry_Start_Ptr);
        FitCount = (FIT->Size[0]) + (FIT->Size[1]*256) + (FIT->Size[2]*256*256);

        while (FitCount) {
            FIT_Type = FIT->Type & 0x7F;
            if (FIT_Type == FIT_PALB_TYPE) {
                Print(L"PAL_B Revision        %d.%2d\n",BCDtoDecimal((UINT8)(FIT->Revision >> 8)),
                                                                 BCDtoDecimal((UINT8)(FIT->Revision & 0x00FF)));
            } /*  end of if */

            FitCount--;
            FIT++;
        }   /*  end of while */


        FIT = (FIT_ENTRY *) (*FIT_Entry_Start_Ptr);
        FitCount = (FIT->Size[0]) + (FIT->Size[1]*256) + (FIT->Size[2]*256*256);

        while (FitCount) {
            FIT_Type = FIT->Type & 0x7F;
            if (FIT_Type == 0x1D) {
                CopyMem (BuildInfo, (VOID *)FIT->Address, 32);
                BuildInfo[32] = 0;
                Print(L"Build Info            %a\n",BuildInfo);
            } /*  end of if */

            FitCount--;
            FIT++;
        }   /*  end of while */


        /* 
         *  Other Modules revision
         */

        Print(L"\n");
        FIT = (FIT_ENTRY *) (*FIT_Entry_Start_Ptr);
        FitCount = (FIT->Size[0]) + (FIT->Size[1]*256) + (FIT->Size[2]*256*256);

        Print(L"Other modules mentioned in FIT (Firmware Interface Table)\n");
        while (FitCount) {
            FIT_Type = FIT->Type & 0x7F;
            if ((FIT_Type != 0x7F) && (FIT_Type != FIT_PALB_TYPE)) {
                Print(L"FIT_Entry Type %3d, Revision    %d.%2d\n",FIT_Type,
                                                                 BCDtoDecimal((UINT8)(FIT->Revision >> 8)),
                                                                 BCDtoDecimal((UINT8)(FIT->Revision & 0x00FF)));
            } /*  end of if */

            FitCount--;
            FIT++;
        }   /*  end of while */
        
    } /*  end of if */

    LibInitSalAndPalProc(&SalPlabel, &PalEntry);
    LibGetSalIoPortMapping (&IoPortBase);

    Print (L"\n SalProc Entry %016x and GP %016x", SalProcPlabel.ProcEntryPoint, SalProcPlabel.GP);
    Print (L"\n PalProc Entry %016x IO Port Base %016x", PalProcPlabel.ProcEntryPoint, IoPortBase);

    /* 
     *  BugBug: The IsCacheEnabled() Function does not work. Looks like the Lib
     *          call to make a PAL call is not working.
     */
    Print (L"\n %HCache %a\n%N", IsCacheEnabled() ? "Enabled": "Disabled");
    return;
}

/* 
 *  BugBug: Debug code. Get an include file for PAL and make this a lib function.
 */

#define BIT59   (1I64<<59)

BOOLEAN
IsCacheEnabled (
    VOID
    )
{
    rArg                    PalReturn;

    LibPalProc (0x11, 0, 0, 0, &PalReturn);
    if (PalReturn.p0 != 0x00) {
        DEBUG((D_ERROR, "PAL Call Get Features Failed\n"));
        return FALSE;
    }
    
    if ((PalReturn.p2 & BIT59) == BIT59) {
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\elfcommn.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfcommn.h

Abstract:

    Common defines for client and server.

Author:

    Rajen Shah (rajens) 12-Aug-1991

Revision History:

--*/

#ifndef _ELFCOMMON_
#define _ELFCOMMON_

//
// Current default names of modules supported
//

#define     ELF_MAX_LOG_MODULES 256

#define     ELF_SYSTEM_MODULE_NAME            L"System"
#define     ELF_APPLICATION_MODULE_NAME       L"Application"
#define     ELF_SECURITY_MODULE_NAME          L"Security"

#define     ELF_SYSTEM_MODULE_NAME_ASCII      "System"
#define     ELF_APPLICATION_MODULE_NAME_ASCII "Application"
#define     ELF_SECURITY_MODULE_NAME_ASCII    "Security"


//
// Version numbers for the file header and the client
//

#define     ELF_VERSION_MAJOR    0x0001
#define     ELF_VERSION_MINOR    0x0001

//
// The following are definitions for the Flags field in the context handle.
//
// ELF_LOG_HANDLE_INVALID is used to indicate that the handle is no
//                        longer valid - i.e. the contents of the file
//                        or the file itself have changed. It is used for
//                        READs to cause the reader to "resync".
//
// ELF_LOG_HANDLE_BACKUP_LOG indicates that this was created with the
//                        OpenBackupEventlog API and is not an active log.
//                        This means we do some additional work at close time
//                        and we disallow clear, backup, write and
//                        ChangeNotify operations.
//
// ELF_LOG_HANDLE_REMOTE_HANDLE indicates that this handle was created via
//                        a remote RPC call.  This handle cannot be used for
//                        ElfChangeNotify
//
// ELF_LOG_HANDLE_GENERATE_ON_CLOSE indicates that NtCloseAuditAlarm must
//                        be called when this handle is closed.  This flag
//                        is set when an audit is generated on open.
//

#define     ELF_LOG_HANDLE_INVALID_FOR_READ     0x0001
#define     ELF_LOG_HANDLE_BACKUP_LOG           0x0002
#define     ELF_LOG_HANDLE_REMOTE_HANDLE        0x0004
#define     ELF_LOG_HANDLE_LAST_READ_FORWARD    0x0008
#define     ELF_LOG_HANDLE_GENERATE_ON_CLOSE    0x0010

#endif /* _ELFCOMMON_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\event.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    EVENT.H

Abstract:

    Contains the common data structures that should be put in one
    place in the tree.

Author:

    Rajen Shah   (rajens)   21-Aug-1991

Revision History:

--*/

//
// Switch to using the commonly defined (in ntdef.h) UNICODE_STRING
// Do a munge to fix this if it works ok
//

typedef UNICODE_STRING RPC_UNICODE_STRING, *PRPC_UNICODE_STRING;


//
// RPC definition of the SID structure.  Note the use of the [size_is()]
// qualifier to specify the number of elements in the variable size
// imbedded SubAuthorityCount array at runtime.
//
//
typedef struct _RPC_SID {
   UCHAR Revision;
   UCHAR SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   [size_is(SubAuthorityCount)] ULONG SubAuthority[*];
} RPC_SID, *PRPC_SID, **PPRPC_SID;

//
// ANSI counted string
//

typedef struct _RPC_STRING {
    USHORT Length;
    USHORT MaximumLength;
//    [size_is(MaximumLength+0), length_is(Length+1)] PCHAR Buffer;
    [size_is(MaximumLength)] PCHAR Buffer;
} RPC_STRING,  *PRPC_STRING, RPC_ANSI_STRING, *PRPC_ANSI_STRING;

typedef struct _RPC_CLIENT_ID {
    ULONG UniqueProcess;
    ULONG UniqueThread;
} RPC_CLIENT_ID, *PRPC_CLIENT_ID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\elfclnt\elfclntp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    elfclntp.h

Abstract:

    Common include file for all the client-side modules for the
    event logging facility.

Author:

    Rajen Shah	(rajens)    29-Jul-1991


Revision History:

    29-Jul-1991 	RajenS
        Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <rpc.h>
#include <ntrpcp.h>
#include <lmcons.h>
#include <lmerr.h>

#include <elf.h>
#include <elfcommn.h>


DWORD
ElfpGetComputerName (
    OUT  LPSTR   *ComputerNamePtrA,
    OUT  LPWSTR  *ComputerNamePtrW
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\elfclnt\apistub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    APISTUB.C

Abstract:

    This module contains the client ends of the Elf APIs.


Author:

    Rajen Shah  (rajens)    29-Jul-1991


Revision History:

    29-Jul-1991         RajenS
        Created

    13-Jan-1997         Added extensions for clustering to support replicated
                        eventlogs
--*/
/****
@doc    EXTERNAL INTERFACES EVTLOG
****/

#include <elfclntp.h>
#include <lmerr.h>
#include <stdlib.h>
#include <string.h>

//
// Global data
//
PUNICODE_STRING     pGlobalComputerNameU;
PANSI_STRING        pGlobalComputerNameA;

long glInitNameCount = 0;

VOID
w_GetComputerName ( )

/*++

Routine Description:

    This routine gets the name of the computer. It checks the global
    variable to see if the computer name has already been determined.
    If not, it updates that variable with the name.
    It does this for the UNICODE and the ANSI versions.

Arguments:

    NONE

Return Value:

    NONE


--*/
{
    PUNICODE_STRING     pNameU;
    PANSI_STRING        pNameA;
    LPSTR               szName;
    LPWSTR              wszName;
    DWORD               dwStatus;

    long lTemp;

    // Grab the lock.

    lTemp = InterlockedExchange(&glInitNameCount, 1);
    if(lTemp != 0)
    {
        // someone else got the lock, spin till they are done and then return.
        while(lTemp == 1)
        {
            Sleep(100);
            lTemp = InterlockedExchange(&glInitNameCount, 1);
        }
        if(pGlobalComputerNameU)
        {
            glInitNameCount = 0;
            return;    
        }
    }
    
    //
    // now that we own the lock, do one last check to make sure someone else didnt do the allocation
    //
    if(pGlobalComputerNameU)
    {
        glInitNameCount = 0;
        return;    
    }

    pNameU = MIDL_user_allocate (sizeof (UNICODE_STRING));
    pNameA = MIDL_user_allocate (sizeof (ANSI_STRING));

    if ((pNameU != NULL) && (pNameA != NULL)) {

        dwStatus = ElfpGetComputerName(&szName, &wszName);

        if (dwStatus == NO_ERROR) {

            //
            // ElfpComputerName has allocated a buffer to contain the
            // ASCII name of the computer. We use that for the ANSI
            // string structure.
            //
            RtlInitAnsiString ( pNameA, szName );
            RtlInitUnicodeString ( pNameU, wszName );

        } else {

            //
            // We could not get the computer name for some reason. Set up
            // the golbal pointer to point to the NULL string.
            //
            RtlInitAnsiString ( pNameA, "\0");
            RtlInitUnicodeString ( pNameU, L"\0");
        }

        pGlobalComputerNameU = pNameU;
        pGlobalComputerNameA = pNameA;
    }
    else {

        //
        // In case one of the two was allocated.
        // 
        MIDL_user_free (pNameU);
        MIDL_user_free (pNameA);
    }
    glInitNameCount = 0;
}




PUNICODE_STRING
TmpGetComputerNameW ( )

/*++

Routine Description:

    This routine gets the UNICODE name of the computer. It checks the global
    variable to see if the computer name has already been determined.
    If not, it calls the worker routine to do that.

Arguments:

    NONE

Return Value:

    Returns a pointer to the computer name, or a NULL.


--*/
{
    if (pGlobalComputerNameU == NULL) {
        w_GetComputerName();
    }
    return (pGlobalComputerNameU);
}



PANSI_STRING
TmpGetComputerNameA ( )

/*++

Routine Description:

    This routine gets the ANSI name of the computer. It checks the global
    variable to see if the computer name has already been determined.
    If not, it calls the worker routine to do that.

Arguments:

    NONE

Return Value:

    Returns a pointer to the computer name, or a NULL.


--*/
{

    if (pGlobalComputerNameA == NULL) {
        w_GetComputerName();
    }
    return (pGlobalComputerNameA);
}

//
// These APIs only have one interface, since they don't take or return strings
//

NTSTATUS
ElfNumberOfRecords(
    IN      HANDLE      LogHandle,
    OUT     PULONG      NumberOfRecords
    )
{
    NTSTATUS status;

    //
    // Make sure the output pointer is valid
    //

    if (!NumberOfRecords) {
       return(STATUS_INVALID_PARAMETER);
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service entry point

        status = ElfrNumberOfRecords (
                        (IELF_HANDLE) LogHandle,
                        NumberOfRecords
                        );

    }
    RpcExcept (1) {
            status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}

NTSTATUS
ElfOldestRecord(
    IN      HANDLE      LogHandle,
    OUT     PULONG      OldestRecordNumber
    )
{
    NTSTATUS status;

    //
    //
    // Make sure the output pointer is valid
    //

    if (!OldestRecordNumber) {
       return(STATUS_INVALID_PARAMETER);
    }

    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service entry point

        status = ElfrOldestRecord (
                        (IELF_HANDLE) LogHandle,
                        OldestRecordNumber
                        );

    }
    RpcExcept (1) {
            status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


NTSTATUS
ElfChangeNotify(
    IN      HANDLE      LogHandle,
    IN      HANDLE      Event
    )
{

    NTSTATUS status;
    RPC_CLIENT_ID RpcClientId;
    CLIENT_ID ClientId;

    //
    // Map the handles to something that RPC can understand
    //

    ClientId = NtCurrentTeb()->ClientId;
    RpcClientId.UniqueProcess = (ULONG)((ULONG_PTR)ClientId.UniqueProcess);
    RpcClientId.UniqueThread = (ULONG)((ULONG_PTR)ClientId.UniqueThread);

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        // Call service entry point

        status = ElfrChangeNotify (
                        (IELF_HANDLE)((ULONG_PTR)LogHandle),
                        RpcClientId,
                        (DWORD)(ULONG_PTR)Event
                        );

    }
    RpcExcept (1) {
            status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


NTSTATUS
ElfGetLogInformation(
    IN     HANDLE        LogHandle,
    IN     ULONG         InfoLevel,
    OUT    PVOID         lpBuffer,
    IN     ULONG         cbBufSize,
    OUT    PULONG        pcbBytesNeeded
    )
{
    NTSTATUS ntStatus;

    //
    // Make sure the Infolevel is valid
    //

    switch (InfoLevel) {

        case EVENTLOG_FULL_INFO:

            RpcTryExcept {

                // Call service entry point

                ntStatus = ElfrGetLogInformation(
                               (IELF_HANDLE) LogHandle,
                               InfoLevel,
                               lpBuffer,
                               cbBufSize,
                               pcbBytesNeeded);

            }
            RpcExcept (1) {
                ntStatus = I_RpcMapWin32Status(RpcExceptionCode());
            }
            RpcEndExcept

            break;

        default:

            ntStatus = STATUS_INVALID_LEVEL;
            break;
    }

    return ntStatus;
}


//
// UNICODE APIs
//

NTSTATUS
ElfOpenEventLogW (
    IN  PUNICODE_STRING         UNCServerName,
    IN  PUNICODE_STRING         LogName,
    OUT PHANDLE                 LogHandle
    )

/*++

Routine Description:

    This is the client DLL entry point for the ElfOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    LogName         - Supplies the name of the module for the logfile
                      to associate with this handle.

    LogHandle       - Location where log handle is to be returned.


Return Value:

    Returns an NTSTATUS code and, if no error, a handle that can be used
    for subsequent Elf API calls.


--*/
{
    NTSTATUS            status    = STATUS_SUCCESS;
    NTSTATUS            ApiStatus;
    UNICODE_STRING      RegModuleName;
    EVENTLOG_HANDLE_W   ServerNameString;
    BOOLEAN             fWasEnabled = FALSE;
    BOOL                fIsSecurityLog;

    //
    // Make sure input & output pointers are valid
    //

    if (!LogHandle || !LogName || LogName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0)) {
        ServerNameString = UNCServerName->Buffer;
    } else {
        ServerNameString = NULL;
    }

    RtlInitUnicodeString( &RegModuleName, UNICODE_NULL);

    // Call service via RPC. Pass in major and minor version numbers.

    *LogHandle = NULL;          // Must be NULL so RPC fills it in

    fIsSecurityLog = (_wcsicmp(ELF_SECURITY_MODULE_NAME, LogName->Buffer) == 0);

    if (fIsSecurityLog) {

        //
        // Tacitly attempt to enable the SE_SECURITY_PRIVILEGE so we can
        // can check it on the server side.  We ignore the return value
        // because it's possible for this call to fail here but for the
        // user to have this privilege if the log is on a remote server.
        //
        // Note that we make this call on behalf of the client to avoid
        // a regression when we check for the privilege on the server
        // side -- without this call, 3rd party apps that successfully
        // called this API before would fail.  Under normal circumstances,
        // this is not an encouraged practice.
        //

        //
        //  -- This should really be done via ImpersonateSelf()
        //     and adjusting the thread token
        //
        ApiStatus = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                                       TRUE,
                                       FALSE,
                                       &fWasEnabled);
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        status = ElfrOpenELW(
                    ServerNameString,
                    (PRPC_UNICODE_STRING) LogName,
                    (PRPC_UNICODE_STRING) &RegModuleName,
                    ELF_VERSION_MAJOR,
                    ELF_VERSION_MINOR,
                    (PIELF_HANDLE) LogHandle
                    );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept


    if (fIsSecurityLog && NT_SUCCESS(ApiStatus)) {

        //
        // Restore the state
        //

        RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                           fWasEnabled,
                           FALSE,
                           &fWasEnabled);
    }

    return (status);
}


NTSTATUS
ElfRegisterEventSourceW (
    IN  PUNICODE_STRING         UNCServerName,
    IN  PUNICODE_STRING         ModuleName,
    OUT PHANDLE                 LogHandle
    )

/*++

Routine Description:

    This is the client DLL entry point for the ElfRegisterEventSource API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    ModuleName      - Supplies the name of the module to associate with
                      this handle.

    LogHandle       - Location where log handle is to be returned.


Return Value:

    Returns an NTSTATUS code and, if no error, a handle that can be used
    for subsequent Elf API calls.


--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      RegModuleName;
    EVENTLOG_HANDLE_W   ServerNameString;

    //
    // Make sure input & output pointers are valid
    //

    if (!LogHandle || !ModuleName || ModuleName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0)) {
        ServerNameString = UNCServerName->Buffer;
    } else {
        ServerNameString = NULL;
    }

    RtlInitUnicodeString( &RegModuleName, UNICODE_NULL);

    // Call service via RPC. Pass in major and minor version numbers.

    *LogHandle = NULL;          // Must be NULL so RPC fills it in

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        status = ElfrRegisterEventSourceW(
                    ServerNameString,
                    (PRPC_UNICODE_STRING)ModuleName,
                    (PRPC_UNICODE_STRING)&RegModuleName,
                    ELF_VERSION_MAJOR,
                    ELF_VERSION_MINOR,
                    (PIELF_HANDLE) LogHandle
                    );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept


    return (status);
}


NTSTATUS
ElfOpenBackupEventLogW (
    IN  PUNICODE_STRING UNCServerName,
    IN  PUNICODE_STRING BackupFileName,
    OUT PHANDLE LogHandle
    )

/*++

Routine Description:

    This is the client DLL entry point for the ElfOpenBackupEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    BackupFileName  - Supplies the filename of the module to associate with
                      this handle.

    LogHandle       - Location where log handle is to be returned.


Return Value:

    Returns an NTSTATUS code and, if no error, a handle that can be used
    for subsequent Elf API calls.


--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    EVENTLOG_HANDLE_W   ServerNameString;

    //
    // Make sure input & output pointers are valid
    //

    if (!LogHandle || !BackupFileName || BackupFileName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0)) {
        ServerNameString = UNCServerName->Buffer;
    } else {
        ServerNameString = NULL;
    }

    // Call service via RPC. Pass in major and minor version numbers.

    *LogHandle = NULL;          // Must be NULL so RPC fills it in

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        status = ElfrOpenBELW(
                    ServerNameString,
                    (PRPC_UNICODE_STRING)BackupFileName,
                    ELF_VERSION_MAJOR,
                    ELF_VERSION_MINOR,
                    (PIELF_HANDLE) LogHandle
                    );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);
}



NTSTATUS
ElfClearEventLogFileW (
    IN      HANDLE          LogHandle,
    IN      PUNICODE_STRING BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfClearEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service entry point

        status = ElfrClearELFW (
                        (IELF_HANDLE) LogHandle,
                        (PRPC_UNICODE_STRING)BackupFileName
                        );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


NTSTATUS
ElfBackupEventLogFileW (
    IN      HANDLE          LogHandle,
    IN      PUNICODE_STRING BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfBackupEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;
    NTSTATUS ApiStatus;
    BOOLEAN  fWasEnabled;

    //
    // Make sure input pointers are valid
    //

    if (!BackupFileName || BackupFileName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    //
    // Tacitly attempt to enable the SE_BACKUP_PRIVILEGE so we can
    // can check it on the server side
    //
    // Note that we make this call on behalf of the client to avoid
    // a regression when we check for the privilege on the server
    // side -- without this call, 3rd party apps that successfully
    // called this API before would fail.  Under normal circumstances,
    // this is not an encouraged practice.
    //

    //
    //  -- This should really be done via ImpersonateSelf()
    //     and adjusting the thread token
    //
    ApiStatus = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                                   TRUE,
                                   FALSE,
                                   &fWasEnabled);

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service entry point

        status = ElfrBackupELFW (
                        (IELF_HANDLE) LogHandle,
                        (PRPC_UNICODE_STRING)BackupFileName);

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    //
    // Restore the client's privilege state to what it was before
    //

    if (NT_SUCCESS(ApiStatus)) {

        RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                           fWasEnabled,
                           TRUE,
                           &fWasEnabled);
    }

    return (status);
}


NTSTATUS
ElfCloseEventLog (
    IN  HANDLE  LogHandle
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfCloseEventLog API.
  It closes the RPC binding, and frees any memory allocated for the
  handle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call server

        status = ElfrCloseEL (
                        (PIELF_HANDLE)  &LogHandle
                        );
    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


NTSTATUS
ElfDeregisterEventSource (
    IN  HANDLE  LogHandle
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfDeregisterEventSource API.
  It closes the RPC binding, and frees any memory allocated for the
  handle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call server

        status = ElfrDeregisterEventSource (
                        (PIELF_HANDLE)  &LogHandle
                        );
    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}



NTSTATUS
ElfReadEventLogW (
    IN          HANDLE      LogHandle,
    IN          ULONG       ReadFlags,
    IN          ULONG       RecordNumber,
    OUT         PVOID       Buffer,
    IN          ULONG       NumberOfBytesToRead,
    OUT         PULONG      NumberOfBytesRead,
    OUT         PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfReadEventLog API.

Arguments:



Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;
    ULONG    FlagBits;

    //
    // Make sure the output pointers are valid
    //

    if (!Buffer || !NumberOfBytesRead || !MinNumberOfBytesNeeded) {
       return(STATUS_INVALID_PARAMETER);
    }

    //
    // Ensure that the ReadFlags we got are valid.
    // Make sure that one of each type of bit is set.
    //
    FlagBits = ReadFlags & (EVENTLOG_SEQUENTIAL_READ | EVENTLOG_SEEK_READ);

    if ((FlagBits > 2) || (FlagBits == 0)) {
        return(STATUS_INVALID_PARAMETER);
    }

    FlagBits = ReadFlags & (EVENTLOG_FORWARDS_READ | EVENTLOG_BACKWARDS_READ);

    if ((FlagBits > 8) || (FlagBits == 0)) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrReadELW (
                        (IELF_HANDLE) LogHandle,
                        ReadFlags,
                        RecordNumber,
                        NumberOfBytesToRead,
                        Buffer,
                        NumberOfBytesRead,
                        MinNumberOfBytesNeeded
                        );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    // Return status and bytes read/required.

    return (status);

}



NTSTATUS
ElfReportEventW (
    IN      HANDLE          LogHandle,
    IN      USHORT          EventType,
    IN      USHORT          EventCategory OPTIONAL,
    IN      ULONG           EventID,
    IN      PSID            UserSid,
    IN      USHORT          NumStrings,
    IN      ULONG           DataSize,
    IN      PUNICODE_STRING *Strings,
    IN      PVOID           Data,
    IN      USHORT          Flags,
    IN OUT  PULONG          RecordNumber OPTIONAL,
    IN OUT  PULONG          TimeWritten  OPTIONAL
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfReportEvent API.

Arguments:


Return Value:

    Returns an NTSTATUS code.

Note:

    The last three parameters (Flags, RecordNumber and TimeWritten) are
    designed to be used by Security Auditing for the implementation of
    paired events (associating a file open event with the subsequent file
    close). This will not be implemented in Product 1, but the API is
    defined to allow easier support of this in a later release.


--*/
{
    NTSTATUS status;
    PUNICODE_STRING pComputerNameU;
    LARGE_INTEGER Time;
    ULONG EventTime;

    //
    // Generate the time of the event. This is done on the client side
    // since that is where the event occurred.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time,
                          &EventTime
                         );

    //
    // Generate the ComputerName of the client.
    // We have to do this in the client side since this call may be
    // remoted to another server and we would not necessarily have
    // the computer name there.
    //
    pComputerNameU = TmpGetComputerNameW();

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrReportEventW (
                    (IELF_HANDLE)   LogHandle,
                    EventTime,
                    EventType,
                    EventCategory,
                    EventID,
                    NumStrings,
                    DataSize,
                    (PRPC_UNICODE_STRING)pComputerNameU,
                    UserSid,
                    (PRPC_UNICODE_STRING *)Strings,
                    Data,
                    Flags,
                    RecordNumber,
                    TimeWritten
                    );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


//
// ANSI APIs
//

NTSTATUS
ElfOpenEventLogA (
    IN  PANSI_STRING    UNCServerName,
    IN  PANSI_STRING    LogName,
    OUT PHANDLE         LogHandle
    )

/*++

Routine Description:

    This is the client DLL entry point for the ElfOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    LogName         - Supplies the name of the module for the logfile to
                      associate with this handle.

    LogHandle       - Location where log handle is to be returned.


Return Value:

    Returns an NTSTATUS code and, if no error, a handle that can be used
    for subsequent Elf API calls.


--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    NTSTATUS            ApiStatus;
    ANSI_STRING         RegModuleName;
    EVENTLOG_HANDLE_A   ServerNameString;
    BOOLEAN             fWasEnabled = FALSE;
    BOOL                fIsSecurityLog;

    //
    // Make sure input & output pointers are valid
    //

    if (!LogHandle || !LogName || LogName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0)) {
        ServerNameString = UNCServerName->Buffer;
    } else {
        ServerNameString = NULL;
    }

    RtlInitAnsiString( &RegModuleName, ELF_APPLICATION_MODULE_NAME_ASCII );

    // Call service via RPC. Pass in major and minor version numbers.

    *LogHandle = NULL;          // Must be NULL so RPC fills it in

    fIsSecurityLog = (_stricmp(ELF_SECURITY_MODULE_NAME_ASCII, LogName->Buffer) == 0);

    if (fIsSecurityLog) {

        //
        // Tacitly attempt to enable the SE_SECURITY_PRIVILEGE so we can
        // can check it on the server side.  We ignore the return value
        // because it's possible for this call to fail here but for the
        // user to have this privilege if the log is on a remote server
        //
        // Note that we make this call on behalf of the client to avoid
        // a regression when we check for the privilege on the server
        // side -- without this call, 3rd party apps that successfully
        // called this API before would fail.  Under normal circumstances,
        // this is not an encouraged practice.
        //

        //
        //  -- This should really be done via ImpersonateSelf()
        //     and adjusting the thread token
        //
        ApiStatus = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                                       TRUE,
                                       FALSE,
                                       &fWasEnabled);
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

         status = ElfrOpenELA (
                    ServerNameString,
                    (PRPC_STRING) LogName,
                    (PRPC_STRING) &RegModuleName,
                    ELF_VERSION_MAJOR,
                    ELF_VERSION_MINOR,
                    (PIELF_HANDLE) LogHandle);

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    if (fIsSecurityLog && NT_SUCCESS(ApiStatus)) {

        //
        // Restore the state
        //

        RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                           fWasEnabled,
                           FALSE,
                           &fWasEnabled);
    }

    return (status);
}


NTSTATUS
ElfRegisterEventSourceA (
    IN  PANSI_STRING    UNCServerName,
    IN  PANSI_STRING    ModuleName,
    OUT PHANDLE         LogHandle
    )

/*++

Routine Description:

    This is the client DLL entry point for the ElfOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    ModuleName      - Supplies the name of the module to associate with
                      this handle.

    LogHandle       - Location where log handle is to be returned.


Return Value:

    Returns an NTSTATUS code and, if no error, a handle that can be used
    for subsequent Elf API calls.


--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    ANSI_STRING         RegModuleName;
    EVENTLOG_HANDLE_A   ServerNameString;

    //
    // Make sure input & output pointers are valid
    //

    if (!LogHandle || !ModuleName || ModuleName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0)) {
        ServerNameString = UNCServerName->Buffer;
    } else {
        ServerNameString = NULL;
    }

    RtlInitAnsiString( &RegModuleName, ELF_APPLICATION_MODULE_NAME_ASCII );

    if ( NT_SUCCESS (status) ) {

        // Call service via RPC. Pass in major and minor version numbers.

        *LogHandle = NULL;          // Must be NULL so RPC fills it in

        //
        // Do the RPC call with an exception handler since RPC will raise an
        // exception if anything fails. It is up to us to figure out what
        // to do once the exception is raised.
        //
        RpcTryExcept {

            status = ElfrRegisterEventSourceA (
                        ServerNameString,
                        (PRPC_STRING)ModuleName,
                        (PRPC_STRING)&RegModuleName,
                        ELF_VERSION_MAJOR,
                        ELF_VERSION_MINOR,
                        (PIELF_HANDLE) LogHandle
                        );

        }
        RpcExcept (1) {

            status = I_RpcMapWin32Status(RpcExceptionCode());
        }
        RpcEndExcept


    }

    return (status);
}



NTSTATUS
ElfOpenBackupEventLogA (
    IN  PANSI_STRING    UNCServerName,
    IN  PANSI_STRING    FileName,
    OUT PHANDLE         LogHandle
    )

/*++

Routine Description:

    This is the client DLL entry point for the ElfOpenBackupEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    FileName        - Supplies the filename of the logfile to associate with
                      this handle.

    LogHandle       - Location where log handle is to be returned.


Return Value:

    Returns an NTSTATUS code and, if no error, a handle that can be used
    for subsequent Elf API calls.


--*/
{
    EVENTLOG_HANDLE_A   ServerNameString;
    NTSTATUS            status;

    //
    // Make sure input & output pointers are valid
    //

    if (!LogHandle || !FileName || FileName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0)) {
        ServerNameString = UNCServerName->Buffer;
    } else {
        ServerNameString = NULL;
    }

    // Call service via RPC. Pass in major and minor version numbers.

    *LogHandle = NULL;          // Must be NULL so RPC fills it in

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        status = ElfrOpenBELA (
                    ServerNameString,
                    (PRPC_STRING)FileName,
                    ELF_VERSION_MAJOR,
                    ELF_VERSION_MINOR,
                    (PIELF_HANDLE) LogHandle
                    );
    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);
}



NTSTATUS
ElfClearEventLogFileA (
    IN      HANDLE          LogHandle,
    IN      PANSI_STRING BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfClearEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service entry point

        status = ElfrClearELFA (
                        (IELF_HANDLE) LogHandle,
                        (PRPC_STRING)BackupFileName
                        );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


NTSTATUS
ElfBackupEventLogFileA (
    IN      HANDLE       LogHandle,
    IN      PANSI_STRING BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfBackupEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;
    NTSTATUS ApiStatus;
    BOOLEAN  fWasEnabled;

    //
    // Make sure input pointers are valid
    //

    if (!BackupFileName || BackupFileName->Length == 0) {
       return(STATUS_INVALID_PARAMETER);
    }

    //
    // Tacitly attempt to enable the SE_BACKUP_PRIVILEGE so we can
    // can check it on the server side
    //
    // Note that we make this call on behalf of the client to avoid
    // a regression when we check for the privilege on the server
    // side -- without this call, 3rd party apps that successfully
    // called this API before would fail.  Under normal circumstances,
    // this is not an encouraged practice.
    //

    //
    //  -- This should really be done via ImpersonateSelf()
    //     and adjusting the thread token
    //
    ApiStatus = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                                   TRUE,
                                   FALSE,
                                   &fWasEnabled);

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service entry point

        status = ElfrBackupELFA (
                        (IELF_HANDLE) LogHandle,
                        (PRPC_STRING)BackupFileName
                        );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    //
    // Restore the client's privilege state to what it was before
    //

    if (NT_SUCCESS(ApiStatus)) {

        RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                           fWasEnabled,
                           TRUE,
                           &fWasEnabled);
    }

    return (status);
}



NTSTATUS
ElfReadEventLogA (
    IN          HANDLE      LogHandle,
    IN          ULONG       ReadFlags,
    IN          ULONG       RecordNumber,
    OUT         PVOID       Buffer,
    IN          ULONG       NumberOfBytesToRead,
    OUT         PULONG      NumberOfBytesRead,
    OUT         PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfReadEventLog API.

Arguments:



Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;
    ULONG    FlagBits;

    //
    // Make sure the output pointers are valid
    //

    if (!Buffer || !NumberOfBytesRead || !MinNumberOfBytesNeeded) {
       return(STATUS_INVALID_PARAMETER);
    }

    //
    // Ensure that the ReadFlags we got are valid.
    // Make sure that one of each type of bit is set.
    //
    FlagBits = ReadFlags & (EVENTLOG_SEQUENTIAL_READ | EVENTLOG_SEEK_READ);

    if (   (FlagBits == (EVENTLOG_SEQUENTIAL_READ | EVENTLOG_SEEK_READ))
        || (FlagBits == 0)) {
        return(STATUS_INVALID_PARAMETER);
    }

    FlagBits = ReadFlags & (EVENTLOG_FORWARDS_READ | EVENTLOG_BACKWARDS_READ);

    if (   (FlagBits == (EVENTLOG_FORWARDS_READ | EVENTLOG_BACKWARDS_READ))
        || (FlagBits == 0)) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrReadELA (
                        (IELF_HANDLE) LogHandle,
                        ReadFlags,
                        RecordNumber,
                        NumberOfBytesToRead,
                        Buffer,
                        NumberOfBytesRead,
                        MinNumberOfBytesNeeded
                        );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    // Return status and bytes read/required.

    return (status);

}



NTSTATUS
ElfReportEventA (
    IN      HANDLE          LogHandle,
    IN      USHORT          EventType,
    IN      USHORT          EventCategory OPTIONAL,
    IN      ULONG           EventID,
    IN      PSID            UserSid,
    IN      USHORT          NumStrings,
    IN      ULONG           DataSize,
    IN      PANSI_STRING    *Strings,
    IN      PVOID           Data,
    IN      USHORT          Flags,
    IN OUT  PULONG          RecordNumber OPTIONAL,
    IN OUT  PULONG          TimeWritten  OPTIONAL
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfReportEvent API.

Arguments:


Return Value:

    Returns an NTSTATUS code.

Note:

    The last three parameters (Flags, RecordNumber and TimeWritten) are
    designed to be used by Security Auditing for the implementation of
    paired events (associating a file open event with the subsequent file
    close). This will not be implemented in Product 1, but the API is
    defined to allow easier support of this in a later release.


--*/
{
    NTSTATUS status;
    PANSI_STRING pComputerNameA;
    LARGE_INTEGER Time;
    ULONG EventTime;

    //
    // Generate the time of the event. This is done on the client side
    // since that is where the event occurred.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time,
                          &EventTime
                         );

    //
    // Generate the ComputerName of the client.
    // We have to do this in the client side since this call may be
    // remoted to another server and we would not necessarily have
    // the computer name there.
    //
    pComputerNameA = TmpGetComputerNameA();

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrReportEventA (
                    (IELF_HANDLE)   LogHandle,
                    EventTime,
                    EventType,
                    EventCategory,
                    EventID,
                    NumStrings,
                    DataSize,
                    (PRPC_STRING)pComputerNameA,
                    UserSid,
                    (PRPC_STRING*)Strings,
                    Data,
                    Flags,
                    RecordNumber,
                    TimeWritten
                    );

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}


/****
@func       NTSTATUS | ElfRegisterClusterSvc|  The cluster service registers
            itself with the event log service at initialization by calling this api.

@parm       IN PUNICODE_STRING | UNCServerName | Inidicates the server on which the
            cluster service will register with the eventlog service.  This must
            be the local node.

@parm       OUT PULONG | pulSize | A pointer to a long that returns the size of the
            packed event information structure that is returned.

@parm       OUT PPACKEDEVENTINFO | *ppPackedEventInfo| A pointer to the packed event information
            structure for propagation is returned via this parameter.

@comm       The elf client validates parameters and called the servier entry point.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref        <f ElfrRegisterClusterSvc>
****/
NTSTATUS
ElfRegisterClusterSvc (
    IN  PUNICODE_STRING     UNCServerName,
    OUT PULONG              pulSize,
    OUT PPACKEDEVENTINFO    *ppPackedEventInfo
    )
{
    EVENTLOG_HANDLE_W   ServerNameString;

    NTSTATUS status;

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0))
    {
        ServerNameString = UNCServerName->Buffer;
    }
    else
    {
        ServerNameString = NULL;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrRegisterClusterSvc (ServerNameString, pulSize,
                (PBYTE *)ppPackedEventInfo);

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return(status);
}

/****
@func       NTSTATUS | ElfDeregisterClusterSvc|  Before stopping the cluster
            service deregisters itself for propagation of events from the
            eventlog service.

@parm       IN PUNICODE_STRING | UNCServerName | Inidicates the server on which the
            cluster service will register with the eventlog service.  This must
            be on the local node.

@comm       The elf client forwards this to the appropriate eventlog server entry point.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f ElfDeregisterClusterSvc> <f ElfrDeregisterClusterSvc>
****/
NTSTATUS
ElfDeregisterClusterSvc(
    IN  PUNICODE_STRING     UNCServerName
    )
{

    NTSTATUS status;
    EVENTLOG_HANDLE_W   ServerNameString;

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0))
    {
        ServerNameString = UNCServerName->Buffer;
    }
    else
    {
        ServerNameString = NULL;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrDeregisterClusterSvc (ServerNameString);

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept
    return(status);

}


/****
@func       NTSTATUS | ElfWriteClusterEvents| The cluster service calls this
            api to log events reported at other nodes of the cluster.

@parm       IN EVENTLOG_HANDLE_W | UNCServerName | Not used.

@parm       IN ULONG | ulSize | The size of the    packed event information structure.

@parm       IN PACKEDEVENTINFO | pPackedEventInfo| A pointer to the packed event information
            structure for propagation.

@comm       The elf client validates the parameters and forwards this to the appropriate
            entry point in the eventlog server.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/
NTSTATUS
ElfWriteClusterEvents(
    IN  PUNICODE_STRING     UNCServerName,
    IN  ULONG               ulSize,
    IN  PPACKEDEVENTINFO    pPackedEventInfo)
{

    NTSTATUS status;
    EVENTLOG_HANDLE_W   ServerNameString;

    //validate input parameters
    if (!pPackedEventInfo || !ulSize || (pPackedEventInfo->ulSize != ulSize))
       return(STATUS_INVALID_PARAMETER);

    if ((UNCServerName != NULL) && (UNCServerName->Length != 0))
    {
        ServerNameString = UNCServerName->Buffer;
    }
    else
    {
        ServerNameString = NULL;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call service

        status = ElfrWriteClusterEvents (ServerNameString, ulSize,
            (PBYTE)pPackedEventInfo);

    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept
    return(status);

}
NTSTATUS
ElfFlushEventLog (
    IN  HANDLE  LogHandle
    )

/*++

Routine Description:

  This is the client DLL entry point for the ElfFlushEventLog API.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {

        // Call server

        status = ElfrFlushEL (
                        (IELF_HANDLE)  LogHandle
                        );
    }
    RpcExcept (1) {

        status = I_RpcMapWin32Status(RpcExceptionCode());
    }
    RpcEndExcept

    return (status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\elfclnt\rpcbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Eventlog
    client-side APIs.

Author:

    Rajen Shah      (rajens)    30-Jul-1991

Revision History:

    30-Jul-1991     RajenS
        created

--*/

//
// INCLUDES
//
#include <elfclntp.h>
#include <lmsvc.h>
#include <svcsp.h>  // SVCS_LRPC_*

#define SERVICE_EVENTLOG    L"EVENTLOG"


/****************************************************************************/
handle_t
EVENTLOG_HANDLE_W_bind (
    EVENTLOG_HANDLE_W   ServerName)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the ElfOpenEventLog API client stub when
    it is necessary to bind to a server.
    The binding is done to allow impersonation by the server since that is
    necessary for the API calls.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;

    // If we're connecting to the local services use LRPC to avoid bugs
    // with cached tokens in named pipes.  (Talk to AlbertT/MarioGo)
    // SVCS_LRPC_* defines come from svcsp.h

    if (ServerName == NULL ||
        wcscmp(ServerName, L"\\\\.") == 0 ) {
        
        PWSTR sb;
        status = RpcStringBindingComposeW(0,
                                          SVCS_LRPC_PROTOCOL, 
                                          0,
                                          SVCS_LRPC_PORT,
                                          0,
                                          &sb);

        if (status == RPC_S_OK) {
            status = RpcBindingFromStringBindingW(sb, &bindingHandle);

            RpcStringFreeW(&sb);

            if (status == RPC_S_OK) {
                return bindingHandle;
            }
        }
        return NULL;
    }

    status = RpcpBindRpc (
                ServerName,   
                SERVICE_EVENTLOG,
                NULL,
                &bindingHandle);

    // DbgPrint("EVENTLOG_bind: handle=%d\n",bindingHandle);
    return( bindingHandle);
}



/****************************************************************************/
void
EVENTLOG_HANDLE_W_unbind (
    EVENTLOG_HANDLE_W   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS  status;

    // DbgPrint("EVENTLOG_HANDLE_unbind: handle=%d\n",BindingHandle);
    status = RpcpUnbindRpc ( BindingHandle);
    return;

    UNREFERENCED_PARAMETER(ServerName);

}


handle_t
EVENTLOG_HANDLE_A_bind (
    EVENTLOG_HANDLE_A   ServerName)

/*++

Routine Description:

    This routine calls EVENTLOG_HANDLE_W_bind to do the work.

Arguments:

    ServerName - A pointer to a UNICODE string containing the name of
    the server to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    UNICODE_STRING  ServerNameU;
    ANSI_STRING     ServerNameA;
    handle_t        bindingHandle;

    //
    // Convert the ANSI string to a UNICODE string before calling the
    // UNICODE routine.
    //
    RtlInitAnsiString (&ServerNameA, (PSTR)ServerName);

	ServerNameU.Buffer = NULL;

    RtlAnsiStringToUnicodeString (
            &ServerNameU,
            &ServerNameA,
            TRUE
            );

    bindingHandle = EVENTLOG_HANDLE_W_bind(
                (EVENTLOG_HANDLE_W)ServerNameU.Buffer
                );

    RtlFreeUnicodeString (&ServerNameU);

    return( bindingHandle);
}



/****************************************************************************/
void
EVENTLOG_HANDLE_A_unbind (
    EVENTLOG_HANDLE_A   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls EVENTLOG_HANDLE_W_unbind.

Arguments:

    ServerName - This is the ANSI name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNICODE_STRING  ServerNameU;
    ANSI_STRING     ServerNameA;

    //
    // Convert the ANSI string to a UNICODE string before calling the
    // UNICODE routine.
    //
    RtlInitAnsiString (&ServerNameA, (PSTR)ServerName);

	ServerNameU.Buffer = NULL;

    RtlAnsiStringToUnicodeString (
            &ServerNameU,
            &ServerNameA,
            TRUE
            );

    EVENTLOG_HANDLE_W_unbind( (EVENTLOG_HANDLE_W)ServerNameU.Buffer,
                 BindingHandle );

    RtlFreeUnicodeString (&ServerNameU);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\ntsdexts\elfmain.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wmiexts.h

Author:

    Ivan Brugiolo
    
Revision History:

--*/

# ifndef _ELFMAIN_H_
# define _ELFMAIN_H_

#ifdef _WIN64
  #define KDEXT_64BIT
#else
  #define KDEXT_32BIT
#endif

#ifdef KDEXT_64BIT
  #define MEMORY_ADDRESS ULONG64
#else
  #define MEMORY_ADDRESS ULONG_PTR
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#ifdef PowerSystemMaximum
#undef PowerSystemMaximum
#endif

#include <windows.h>

#include <wdbgexts.h>


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>


//
// To obtain the private & protected members of C++ class,
// let me fake the "private" keyword
//
# define private    public
# define protected  public


//
// Turn off dllexp et al so this DLL won't export tons of unnecessary garbage.
//



/************************************************************
 *   Macro Definitions
 ************************************************************/

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
extern USHORT g_MajorVersion;
extern USHORT g_MinorVersion;




#define moveBlock(dst, src, size)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#define MoveWithRet(dst, src, retVal)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return  retVal;\
}

#define MoveBlockWithRet(dst, src, size, retVal)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return retVal;\
}

#ifdef _WIN64
#define INIT_API()                                                                       \
    LPSTR lpArgumentString = (LPSTR)args;                                                \
  	ExtensionCurrentProcess = hCurrentProcess;                                           
#else
#define INIT_API()                                                                       \
    LPSTR lpArgumentString = (LPSTR)args;                                                \
  	ExtensionCurrentProcess = hCurrentProcess;                                           \
   	if (ExtensionApis.nSize != sizeof(WINDBG_EXTENSION_APIS)){                           \
   	    WINDBG_OLD_EXTENSION_APIS * pOld = (WINDBG_OLD_EXTENSION_APIS *)&ExtensionApis;  \
   	    *pOld = *((WINDBG_OLD_EXTENSION_APIS *)dwProcessor);                             \
	}
#endif	


# define BoolValue( b) ((b) ? "    TRUE" : "   FALSE")


#define DumpDword( symbol )                                     \
        {                                                       \
            ULONG_PTR dw = 0;                                   \
            if (ExtensionApis.nSize != sizeof(WINDBG_EXTENSION_APIS)){ \
                dw = GetExpression( "&" symbol );               \
            } else {                                            \
                dw = GetExpression( symbol );                   \
            };                                                  \
			                                                    \
            ULONG_PTR dwValue = 0;                              \
            if ( dw )                                           \
            {                                                   \
                if ( ReadMemory( (ULONG_PTR) dw,                \
                                 &dwValue,                      \
                                 sizeof(dwValue),               \
                                 NULL ))                        \
                {                                               \
                    dprintf( "\t" symbol "   = %8d (0x%p)\n",   \
                             dwValue,                           \
                             dwValue );                         \
                }                                               \
            }                                                   \
        }


//
// C++ Structures typically require the constructors and most times
//  we may not have default constructors
//  => trouble in defining a copy of these struct/class inside the
//     Debugger extension DLL for debugger process
// So we will define them as CHARACTER arrays with appropriate sizes.
// This is okay, since we are not really interested in structure as is,
//  however, we will copy over data block from the debuggee process to
//  these structure variables in the debugger process.
//
# define DEFINE_CPP_VAR( className, classVar) \
   CHAR  classVar[sizeof(className)]

# define GET_CPP_VAR_PTR( className, classVar) \
   (className * ) &classVar

#ifndef KDEXT_64BIT

/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}

#endif /* KDEXT_64BIT */

#endif //  _ELFMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\ntsdexts\elfmain.c ===
/*++


Module Name:

    elfmain.cpp

Abstract:

    This module contains the default ntsd debugger extensions for


Author:

    Ivan Brugiolo 21-06-2001  adapted from wmiexts.cpp

Revision History:

--*/

#include "elfmain.h"

#undef DBG_ASSERT


/************************************************************
 *   Debugger Utility Functions
 ************************************************************/

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

USHORT  g_MajorVersion;
USHORT  g_MinorVersion;

/************************************************************
 * The WinDBG required Export
 ************************************************************/
 
LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )

/*++

Function Description:

    Windbg calls this function to match between the version of windbg and the
    extension. If the versions doesn't match, windbg will not load the 
extension.

--*/

{
    static EXT_API_VERSION ApiVersion =
#ifdef KDEXT_64BIT
       { 5, 0, EXT_API_VERSION_NUMBER64, 0 };
#else
       { 5, 0, EXT_API_VERSION_NUMBER, 0 };
#endif       
        
    return &ApiVersion;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )

/*++

Function Description:

    When windbg loads the extension, it first call this function. You can
    perform various intialization here.

Arguments:

    lpExtensionApis - A structure that contains the callbacks to functions that
        I can use to do standard operation. I must store this in a global
        variable called 'ExtensionApis'.

    MajorVersion - Indicates if target machine is running checked build or 
free.
        0x0C - Checked build.
        0x0F - Free build.

    MinorVersion - The Windows NT build number (for example, 1381 for NT4).

--*/

{
    ExtensionApis = *lpExtensionApis;

    g_MajorVersion = MajorVersion;
    g_MinorVersion = MinorVersion;
}


void
CheckVersion( void )

/*++

Function Description:

    This function is called before every command. It gives the extension
    a chance to compare between the versions of the target and the extension.
    In this demo, I don't do much with that.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\elfclnt\getconfg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    getconfg.c

Abstract:

    This routine calls GetComputerName[A,W] to obtain the computer name
    in both Ansi and Unicode

Author:

    Dan Lafferty (danl)     09-Apr-1991

Environment:

    User Mode -Win32 (also uses nt RTL routines)

Revision History:

    09-Apr-1991     danl
        created

--*/

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>
#include <ntdef.h>
#include <windef.h>
#include <winbase.h>    // LocalAlloc



DWORD
ElfpGetComputerName (
    OUT  LPSTR   *ComputerNamePtrA,
    OUT  LPWSTR  *ComputerNamePtrW
    )
/*++

Routine Description:

    This routine obtains the computer name from a persistent database,
    by calling the GetcomputerName[A,W] Win32 Base APIs

    This routine assumes the length of the computername is no greater
    than MAX_COMPUTERNAME_LENGTH, space for which it allocates using
    LocalAlloc.  It is necessary for the user to free that space using
    LocalFree when finished.

Arguments:

    ComputerNamePtrA - Pointer to the location of the Ansi computer name
    ComputerNamePtrW - Pointer to the location of the Unicode computer name

Return Value:

    NO_ERROR - If the operation was successful.

    Any other Win32 error if unsuccessful

--*/
{
    DWORD dwError = NO_ERROR;
    DWORD nSize   = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // Allocate a buffer to hold the largest possible computer name.
    //

    *ComputerNamePtrA = LocalAlloc(LMEM_ZEROINIT, nSize);
    *ComputerNamePtrW = LocalAlloc(LMEM_ZEROINIT, nSize * sizeof(WCHAR));

    if (*ComputerNamePtrA == NULL || *ComputerNamePtrW == NULL) {
        goto CleanExit;
    }

    //
    // Get the computer name string into the locally allocated buffers
    // by calling the Win32 GetComputerName[A,W] APIs.
    //

    if (!GetComputerNameA(*ComputerNamePtrA, &nSize)) {
        goto CleanExit;
    }

    //
    // GetComputerName always updates nSize
    //

    nSize = MAX_COMPUTERNAME_LENGTH + 1;

    if (!GetComputerNameW(*ComputerNamePtrW, &nSize)) {
        goto CleanExit;
    }

    return (NO_ERROR);

CleanExit:

    dwError = GetLastError();
    LocalFree(*ComputerNamePtrA);
    LocalFree(*ComputerNamePtrW);
    *ComputerNamePtrA = NULL;
    *ComputerNamePtrW = NULL;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\ntsdexts\elfexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    elfexts.c

Abstract:

    This function contains the eventlog ntsd debugger extensions

Author:

    Dan Hinsley (DanHi) 22-May-1993
    IvanBrug 06 21 2001 converted to the latest debugger

Revision History:

--*/


#include <elfmain.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <time.h>
#include <elf.h>
#include <elfdef.h>
#include <elfcommn.h>
#include <elfproto.h>
#include <svcsp.h>
#include <elfextrn.h>


#define DbgPrint(_x_)
#define MAX_NAME 256
#define GET_DATA(DebugeeAddr, LocalAddr, Length) \
    Status = ReadMemory(                  \
                (MEMORY_ADDRESS)DebugeeAddr,     \
                (PVOID)LocalAddr,                       \
                (ULONG)(Length),                          \
                NULL                             \
                );

HANDLE GlobalhCurrentProcess;
BOOL Status;

LPWSTR
GetUnicodeString(
    PUNICODE_STRING pUnicodeString
    )
{
    MEMORY_ADDRESS Pointer;
    UNICODE_STRING UnicodeString;

    GET_DATA(pUnicodeString, &UnicodeString, sizeof(UNICODE_STRING))
    Pointer = (MEMORY_ADDRESS) UnicodeString.Buffer;
    UnicodeString.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
        UnicodeString.Length + sizeof(WCHAR));
    GET_DATA(Pointer, UnicodeString.Buffer, UnicodeString.Length)

    return(UnicodeString.Buffer);
}

MEMORY_ADDRESS
GetLogFileAddress(
    LPSTR LogFileName,
    PLOGFILE LogFile
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    MEMORY_ADDRESS Pointer = 0;
    MEMORY_ADDRESS LogFileAnchor = 0;
    LPWSTR ModuleName = 0;
    
    //
    // Convert the string to UNICODE
    //

    RtlInitAnsiString(&AnsiString, LogFileName);
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

    //
    // Walk the logfile list looking for a match
    //

    LogFileAnchor = (MEMORY_ADDRESS)GetExpression("eventlog!LogFilesHead");

    if (LogFileAnchor) {
	    GET_DATA(LogFileAnchor, &Pointer, sizeof(MEMORY_ADDRESS));

	    while (Pointer != LogFileAnchor) {
	        GET_DATA(Pointer, LogFile, sizeof(LOGFILE))
	        ModuleName = GetUnicodeString(LogFile->LogModuleName);	        
	        if (!_wcsicmp(ModuleName, UnicodeString.Buffer)) {
	            break;
	        }
	        LocalFree(ModuleName);
	        Pointer = (MEMORY_ADDRESS) LogFile->FileList.Flink;
	    }
    } else {
        dprintf("unable to resolve %s\n","eventlog!LogFilesHead");
    }

    RtlFreeUnicodeString(&UnicodeString);

    if (Pointer == LogFileAnchor) {
        return(0);
    }
    else {
        LocalFree(ModuleName);
        return(Pointer);
    }
}

//
// Dump an individual record
//

MEMORY_ADDRESS
DumpRecord(
    MEMORY_ADDRESS Record,
    DWORD RecordNumber,
    MEMORY_ADDRESS StartOfFile,
    MEMORY_ADDRESS EndOfFile
    )
{
    MEMORY_ADDRESS BufferLen = 0;
    PCHAR TimeBuffer;
    PEVENTLOGRECORD EventLogRecord;
    LPWSTR Module;
    LPWSTR Computer;
    MEMORY_ADDRESS FirstPiece = 0;
    time_t TempAligned;

    GET_DATA(Record, &BufferLen, sizeof(DWORD));

    //
    // See if it's a ELF_SKIP_DWORD, and if it is, return the top of the
    // file
    //

    if (BufferLen == ELF_SKIP_DWORD) {
        return(StartOfFile + sizeof(ELF_LOGFILE_HEADER));
    }

    //
    // See if it's the EOF record
    //

    if (BufferLen == ELFEOFRECORDSIZE) {
        return(0);
    }

    BufferLen += sizeof(DWORD); // get room for length of next record
    EventLogRecord = (PEVENTLOGRECORD) LocalAlloc(LMEM_ZEROINIT, BufferLen);

    //
    // If the record wraps, grab it piecemeal
    //

    if (EndOfFile && BufferLen + Record > EndOfFile) {
        FirstPiece = EndOfFile - Record;
        GET_DATA(Record, EventLogRecord, FirstPiece);
        GET_DATA((StartOfFile + sizeof(ELF_LOGFILE_HEADER)),
            ((PBYTE) EventLogRecord + FirstPiece), BufferLen - FirstPiece);
    }
    else {
        GET_DATA(Record, EventLogRecord, BufferLen);
    }

    //
    // If it's greater than the starting record, print it out
    //

    if (EventLogRecord->RecordNumber >= RecordNumber) {
        dprintf("\nRecord %d is %d [0x%X] bytes long starting at %p\n",
            EventLogRecord->RecordNumber, EventLogRecord->Length,
            EventLogRecord->Length, Record);
        Module = (LPWSTR)(EventLogRecord+1);
        Computer = (LPWSTR)((PBYTE) Module + ((wcslen(Module) + 1) * sizeof(WCHAR)));
        dprintf("\tGenerated by %ws from system %ws\n", Module, Computer);

        
        TempAligned = EventLogRecord->TimeGenerated;
        TimeBuffer = ctime(&TempAligned);
        if (TimeBuffer) {
            dprintf("\tGenerated at %s", TimeBuffer);
        }
        else {
            dprintf("\tGenerated time field is blank\n");
        }
        TempAligned = EventLogRecord->TimeWritten;
        TimeBuffer = ctime(&TempAligned);
        if (TimeBuffer) {
            dprintf("\tWritten at %s", TimeBuffer);
        }
        else {
            dprintf("\tTime written field is blank\n");
        }

        dprintf("\tEvent Id = %d\n", EventLogRecord->EventID);
        dprintf("\tEventType = ");
        switch (EventLogRecord->EventType) {
            case EVENTLOG_SUCCESS:
                dprintf("Success\n");
                break;
            case EVENTLOG_ERROR_TYPE:
                dprintf("Error\n");
                break;
            case EVENTLOG_WARNING_TYPE:
                dprintf("Warning\n");
                break;
            case EVENTLOG_INFORMATION_TYPE:
                dprintf("Information\n");
                break;
            case EVENTLOG_AUDIT_SUCCESS:
                dprintf("Audit Success\n");
                break;
            case EVENTLOG_AUDIT_FAILURE:
                dprintf("Audit Failure\n");
                break;
            default:
                dprintf("Invalid value 0x%X\n", EventLogRecord->EventType);
        }
        dprintf("\t%d strings at offset 0x%X\n", EventLogRecord->NumStrings,
            EventLogRecord->StringOffset);
        dprintf("\t%d bytes of data at offset 0x%X\n", EventLogRecord->DataLength,
            EventLogRecord->DataOffset);
    }

    if (FirstPiece) {
        Record = StartOfFile + sizeof(ELF_LOGFILE_HEADER) + BufferLen -FirstPiece;
    }
    else {
        Record += EventLogRecord->Length;
    }

    LocalFree(EventLogRecord);
    return(Record);
}

//
// Dump a record, or all records, or n records
//


DECLARE_API(record)
{    
    MEMORY_ADDRESS Pointer = 0;
    LOGFILE LogFile;
    MEMORY_ADDRESS StartOfFile;
    MEMORY_ADDRESS EndOfFile = 0;
    DWORD RecordNumber = 0;

    INIT_API();    
   
    //
    // Evaluate the argument string to get the address of
    // the record to dump.
    //

    while (isspace(*lpArgumentString)) lpArgumentString++;

    if (lpArgumentString && *lpArgumentString) {
        if (*lpArgumentString == '.') {
            if (GetLogFileAddress(lpArgumentString+1, &LogFile) == 0) {
                dprintf("Logfile %s not found\n", lpArgumentString+1);
                return;
            }
            Pointer = ((MEMORY_ADDRESS ) (LogFile.BaseAddress)) + LogFile.BeginRecord;
        }
        else if (*lpArgumentString == '#') {
            RecordNumber = atoi(lpArgumentString + 1);
            dprintf("Dumping records starting at record #%d\n", RecordNumber);
            lpArgumentString = NULL;
        }
        else if (*lpArgumentString) {
            Pointer = GetExpression(lpArgumentString);
        }
        else {
            dprintf("Invalid lead character 0x%02X\n", *lpArgumentString);
            return;
        }
    }

    //if (!lpArgumentString || *lpArgumentString) {
    if (0 == Pointer){
        if (GetLogFileAddress("system", &LogFile) == 0) {
            dprintf("System Logfile not found\n");
            return;
        }
        Pointer = ((MEMORY_ADDRESS ) (LogFile.BaseAddress)) + LogFile.BeginRecord;
    }

    StartOfFile = (MEMORY_ADDRESS ) LogFile.BaseAddress;
    EndOfFile = (MEMORY_ADDRESS ) LogFile.BaseAddress + LogFile.ActualMaxFileSize;

    dprintf("%p %p %p\n",Pointer,StartOfFile,EndOfFile );
    //
    // Dump records starting wherever they told us to
    //
    
    while (Pointer < EndOfFile && Pointer && !CheckControlC()) {
        Pointer = DumpRecord(Pointer, RecordNumber, StartOfFile, EndOfFile);
    }


    return;
}

//
// Dump a single LogModule structure if it matches MatchName (NULL matches
// all)
//

PLIST_ENTRY
DumpLogModule(
    MEMORY_ADDRESS pLogModule,
    LPWSTR MatchName
    )
{
    LOGMODULE LogModule;
    WCHAR ModuleName[MAX_NAME / sizeof(WCHAR)];

    GET_DATA(pLogModule, &LogModule, sizeof(LogModule));
    GET_DATA(LogModule.ModuleName, &ModuleName, MAX_NAME);

    if (!MatchName || !_wcsicmp(MatchName, ModuleName)) {
        dprintf("\tModule Name        %S\n", ModuleName);
        dprintf("\tModule Atom        0x%2x\n", LogModule.ModuleAtom);
        dprintf("\tPointer to LogFile %p\n", LogModule.LogFile);
    }

    return (LogModule.ModuleList.Flink);
}

//
// Dump selected, or all, LogModule structures
//


DECLARE_API(logmodule)
{
    
    MEMORY_ADDRESS pLogModule = 0;
    MEMORY_ADDRESS LogModuleAnchor = 0;
    LPWSTR wArgumentString = NULL;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    INIT_API();

    UnicodeString.Buffer = NULL;

    //
    // Evaluate the argument string to get the address of
    // the logmodule to dump.  If no parm, dump them all.
    //
    while (isspace(*lpArgumentString)) lpArgumentString++;
    
    if (lpArgumentString && *lpArgumentString == '.') {
        lpArgumentString++;
        RtlInitAnsiString(&AnsiString, lpArgumentString);
        RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    }
    else if (lpArgumentString && *lpArgumentString) {
        pLogModule = GetExpression(lpArgumentString);
        DumpLogModule( pLogModule, NULL);
        return;
    }

    LogModuleAnchor = GetExpression("eventlog!LogModuleHead");

    if (LogModuleAnchor)
    {
	    GET_DATA(LogModuleAnchor, &pLogModule, sizeof(MEMORY_ADDRESS));

	    while (pLogModule != LogModuleAnchor && !CheckControlC()) {
	        pLogModule =
	            (MEMORY_ADDRESS) DumpLogModule( pLogModule,
                        	                     UnicodeString.Buffer);
	        if (!UnicodeString.Buffer) {
	            dprintf("\n");
	        }
	    }
    }
    else
    {
        dprintf("Unable ro resolve %s\n","eventlog!LogModuleHead");
    }
    if (UnicodeString.Buffer) {
        RtlFreeUnicodeString(&UnicodeString);
    }

    return;
}

//
// Dump a single LogFile structure if it matches MatchName (NULL matches
// all)
//

PLIST_ENTRY
DumpLogFile(
    HANDLE hCurrentProcess,
    MEMORY_ADDRESS pLogFile,
    LPWSTR MatchName
    )
{
    LOGFILE LogFile;
    LPWSTR UnicodeName;

    //
    // Get the fixed part of the structure
    //

    GET_DATA(pLogFile, &LogFile, sizeof(LogFile))

    //
    // Get the Default module name
    //

    UnicodeName = GetUnicodeString(LogFile.LogModuleName);

    //
    // See if we're just looking for a particular one.  If we are and
    // this isn't it, bail out.
    //

    if (MatchName && _wcsicmp(MatchName, UnicodeName)) {
        LocalFree(UnicodeName);
        return (LogFile.FileList.Flink);
    }

    //
    // Otherwise print it out
    //

    dprintf("%ws", UnicodeName);
    LocalFree(UnicodeName);

    //
    // Now the file name of this logfile
    //

    UnicodeName = GetUnicodeString(LogFile.LogFileName);
    dprintf(" : %ws\n", UnicodeName);
    LocalFree(UnicodeName);

    if (LogFile.Notifiees.Flink == LogFile.Notifiees.Blink) {
        dprintf("\tNo active ChangeNotifies on this log\n");
    }
    else {
        dprintf("\tActive Change Notify!  Dump of this list not implemented\n");
    }

    dprintf("\tReference Count: %d\n\tFlags: ", LogFile.RefCount);
    if (LogFile.Flags == 0) {
        dprintf("No flags set ");
    }
    else {
        if (LogFile.Flags & ELF_LOGFILE_HEADER_DIRTY) {
            dprintf("Dirty ");
        }
        if (LogFile.Flags & ELF_LOGFILE_HEADER_WRAP) {
            dprintf("Wrapped ");
        }
        if (LogFile.Flags & ELF_LOGFILE_LOGFULL_WRITTEN) {
             dprintf("Logfull Written ");
        }
    }
    dprintf("\n");

    dprintf("\tMax Files Sizes [Cfg:Curr:Next]  0x%X : 0x%X : 0x%X\n",
        LogFile.ConfigMaxFileSize, LogFile.ActualMaxFileSize,
        LogFile.NextClearMaxFileSize);

    dprintf("\tRecord Numbers [Oldest:Curr] %d : %d\n",
        LogFile.OldestRecordNumber, LogFile.CurrentRecordNumber);

    dprintf("\tRetention period in days: %d\n", LogFile.Retention / 86400);

    dprintf("\tBase Address: 0x%X\n", LogFile.BaseAddress);

    dprintf("\tView size: 0x%X\n", LogFile.ViewSize);

    dprintf("\tOffset of beginning record: 0x%X\n", LogFile.BeginRecord);

    dprintf("\tOffset of ending record: 0x%X\n", LogFile.EndRecord);

    return (LogFile.FileList.Flink);
}

//
// Dump selected, or all, LogFile structures
//


DECLARE_API(logfile)
{
    
    MEMORY_ADDRESS pLogFile;
    MEMORY_ADDRESS LogFileAnchor;
    LPWSTR wArgumentString = NULL;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    BOOL AllocateString = FALSE;

    INIT_API();

    UnicodeString.Buffer = NULL;

    //
    // Evaluate the argument string to get the address of
    // the logfile to dump.  If no parm, dump them all.
    //
    while (isspace(*lpArgumentString)) lpArgumentString++;

    if (lpArgumentString && *lpArgumentString) {
        if(*lpArgumentString == '.') {
            lpArgumentString++;
            RtlInitAnsiString(&AnsiString, lpArgumentString);
            RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
        }
        else {
            pLogFile = GetExpression(lpArgumentString);
            DumpLogFile(hCurrentProcess, pLogFile, NULL);
            return;
        }
    }

    LogFileAnchor = GetExpression("eventlog!LogFilesHead");

    GET_DATA(LogFileAnchor, &pLogFile, sizeof(MEMORY_ADDRESS))

    while (pLogFile != LogFileAnchor) {
        pLogFile =
            (MEMORY_ADDRESS) DumpLogFile(hCurrentProcess, pLogFile,
                UnicodeString.Buffer);
        if (!UnicodeString.Buffer) {
            dprintf("\n");
        }
    }

    if (UnicodeString.Buffer) {
        RtlFreeUnicodeString(&UnicodeString);
    }

    return;
}

//
// Dump a request packet structure
//


DECLARE_API(request)
{    
    ELF_REQUEST_RECORD Request;
    MEMORY_ADDRESS Pointer;
    DWORD RecordSize;
    WRITE_PKT WritePkt;
    READ_PKT ReadPkt;
    CLEAR_PKT ClearPkt;
    BACKUP_PKT BackupPkt;
    LPWSTR FileName;
    CHAR Address[32];

    INIT_API();    

    //
    // Evaluate the argument string to get the address of
    // the request packet to dump.
    //
    while (isspace(*lpArgumentString)) lpArgumentString++;

    if (lpArgumentString && *lpArgumentString) {
        Pointer = GetExpression(lpArgumentString);
    }
    else {
        dprintf("Must supply a request packet address\n");
        return;
    }

    GET_DATA(Pointer, &Request, sizeof(ELF_REQUEST_RECORD))

    switch (Request.Command ) {
        case ELF_COMMAND_READ:
            dprintf("\nRead packet\n");
            GET_DATA(Request.Pkt.ReadPkt, &ReadPkt, sizeof(READ_PKT))
            dprintf("\tLast Seek Position = %d\n", ReadPkt.LastSeekPos);
            dprintf("\tLast Seek Record = %d\n", ReadPkt.LastSeekRecord);
            dprintf("\tStart at record number %d\n", ReadPkt.RecordNumber);
            dprintf("\tRead %d bytes into buffer at 0x%X\n",
                ReadPkt.BufferSize, ReadPkt.Buffer);
            if (ReadPkt.Flags & ELF_IREAD_UNICODE) {
                dprintf("\tReturn in ANSI\n");
            }
            else {
                dprintf("\tReturn in UNICODE\n");
            }
            dprintf("\tRead flags: ");
            if (ReadPkt.ReadFlags & EVENTLOG_SEQUENTIAL_READ) {
                dprintf("Sequential ");
            }
            if (ReadPkt.ReadFlags & EVENTLOG_SEEK_READ) {
                dprintf("Seek ");
            }
            if (ReadPkt.ReadFlags & EVENTLOG_FORWARDS_READ) {
                dprintf("Forward ");
            }
            if (ReadPkt.ReadFlags & EVENTLOG_BACKWARDS_READ) {
                dprintf("Backwards ");
            }
            dprintf("\n");
            break;

        case ELF_COMMAND_WRITE:
            dprintf("\nWrite packet\n");
            if (Request.Flags == ELF_FORCE_OVERWRITE) {
                dprintf("with ELF_FORCE_OVERWRITE enabled\n");
            }
            else {
                dprintf("\n");
            }
            GET_DATA(Request.Pkt.WritePkt, &WritePkt, sizeof(WRITE_PKT))
            RecordSize = (WritePkt.Datasize);
            DumpRecord((MEMORY_ADDRESS)WritePkt.Buffer, 0, 0, 0);
            break;

        case ELF_COMMAND_CLEAR:
            dprintf("\nClear packet\n");
            GET_DATA(Request.Pkt.ClearPkt, &ClearPkt, sizeof(CLEAR_PKT))
            FileName = GetUnicodeString(ClearPkt.BackupFileName);
            dprintf("Backup filename = %ws\n", FileName);
            LocalFree(FileName);
            break;

        case ELF_COMMAND_BACKUP:
            dprintf("\nBackup packet\n");
            GET_DATA(Request.Pkt.BackupPkt, &BackupPkt, sizeof(BACKUP_PKT))
            FileName = GetUnicodeString(BackupPkt.BackupFileName);
            dprintf("Backup filename = %ws\n", FileName);
            LocalFree(FileName);
            break;

        case ELF_COMMAND_WRITE_QUEUED:
            dprintf("\nQueued Write packet\n");
            if (Request.Flags == ELF_FORCE_OVERWRITE) {
                dprintf("with ELF_FORCE_OVERWRITE enabled\n");
            }
            else {
                dprintf("\n");
            }
            dprintf("NtStatus = 0x%X\n", Request.Status);
            break;

        default:
            dprintf("\nInvalid packet\n");
    }

    dprintf("\nLogFile for this packet:\n\n");
    sprintf(Address,"%p",Request.LogFile);
    logfile(hCurrentProcess, 
    	  hCurrentThread, dwCurrentPc, dwProcessor,
        Address);

    dprintf("\nLogModule for this packet:\n\n");
    sprintf(Address,"%p",Request.Module);
    logmodule(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor,
        Address);

    return;
}

//
// Online help
//


DECLARE_API(help)
{
    INIT_API();
    
    dprintf("\nEventlog debugger Extensions\n");

    if (!lpArgumentString || *lpArgumentString == '\0' ||
        *lpArgumentString == '\n' || *lpArgumentString == '\r') {
        dprintf("\tlogmodule - dump a logmodule structure\n");
        dprintf("\tlogfile   - dump a logfile structure\n");
        dprintf("\trequest   - dump a request record\n");
        dprintf("\trecord    - dump a eventlog record\n");
        dprintf("\n\tEnter help <cmd> for detailed help on a command\n");
    }
    else {
        if (!_stricmp(lpArgumentString, "logmodule")) {
            dprintf("\tlogmodule <arg>, where <arg> can be one of:\n");
            dprintf("\t\tno argument - dump all logmodule structures\n");
            dprintf("\t\taddress     - dump the logmodule at specified address\n");
            dprintf("\t\t.string     - dump the logmodule with name string\n");
        }
        else if (!_stricmp(lpArgumentString, "logfile")) {
            dprintf("\tlogfile <arg>, where <arg> can be one of:\n");
            dprintf("\t\tno argument - dump all logfile structures\n");
            dprintf("\t\taddress     - dump the logfile at specified address\n");
            dprintf("\t\t.string     - dump the logfile with name string\n");
        }
        else if (!_stricmp(lpArgumentString, "record")) {
            dprintf("\trecord <arg>, where <arg> can be one of:\n");
            dprintf("\t\tno argument - dump all records in system log\n");
            dprintf("\t\taddress     - dump records starting at specified address\n");
            dprintf("\t\t.string     - dump all records in the <string> log\n");
            dprintf("\t\t#<nnn>      - dumps records starting at nnn in system log\n");
            dprintf("\t\t#<nnn> .string  - dumps records starting at nnn in <string> log\n");
        }
        else if (!_stricmp(lpArgumentString, "request")) {
            dprintf("\trequest - dump the request record at specified address\n");
        }
        else {
            dprintf("\tInvalid command [%s]\n", lpArgumentString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\alert.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ALERT.C

Abstract:

    This file contains the routine that sends the alert to the admin.

Author:

    Rajen Shah  (rajens)    28-Aug-1991


Revision History:


--*/

//
// INCLUDES
//

#include <eventp.h>
#include <string.h>
#include <lmalert.h>                // LAN Manager alert structures



BOOL
SendAdminAlert(
    ULONG           MessageID,
    ULONG           NumStrings,
    UNICODE_STRING  *pStrings
    )
/*++

Routine Description:

    This routine raises an ADMIN alert with the message specified.


Arguments:

    MessageID  - Message ID.
    NumStrings - Number of replacement strings.
    pStrings   - Array of UNICODE_STRING Replacement strings.

Return Value:

    NONE

--*/
{
    NET_API_STATUS NetStatus;

    BYTE AlertBuffer[ELF_ADMIN_ALERT_BUFFER_SIZE + sizeof(ADMIN_OTHER_INFO)];
    ADMIN_OTHER_INFO UNALIGNED *VariableInfo = (PADMIN_OTHER_INFO) AlertBuffer;
    BYTE * pToFar = AlertBuffer + ELF_ADMIN_ALERT_BUFFER_SIZE + sizeof(ADMIN_OTHER_INFO);
    DWORD DataSize;
    DWORD i;
    LPWSTR pReplaceString;

    VariableInfo->alrtad_errcode = MessageID;
    VariableInfo->alrtad_numstrings = NumStrings;

    pReplaceString = (LPWSTR)(AlertBuffer + sizeof(ADMIN_OTHER_INFO));

    //
    // Copy over the replacement strings
    //

    for (i = 0; i < NumStrings; i++)
    {
        if((BYTE *)(pReplaceString + pStrings[i].MaximumLength) < pToFar)
            RtlMoveMemory(pReplaceString, pStrings[i].Buffer, pStrings[i].MaximumLength);
        pReplaceString = (LPWSTR) ((PBYTE) pReplaceString + pStrings[i].MaximumLength);
    }

    DataSize = (DWORD) ((PBYTE) pReplaceString - (PBYTE) AlertBuffer);

    NetStatus = NetAlertRaiseEx(ALERT_ADMIN_EVENT,
                                AlertBuffer,
                                DataSize,
                                EVENTLOG_SVC_NAMEW);

    if (NetStatus != NERR_Success)
    {
        ELF_LOG2(ERROR,
                 "SendAdminAlert: NetAlertRaiseEx for alert %d failed %d\n",
                 MessageID,
                 NetStatus);

        //
        // Probably just not started yet, try again later
        //

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\config.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CONFIG.C

Abstract:

    This file contains the routines that walk the configuration registry.

Author:

    Rajen Shah  (rajens)    1-Jul-1991


Revision History:

    29-Aug-1994     Danl
        We no longer grow log files in place.  Therefore, the MaxSize value
        in the registery ends up being advisory only.  We don't try to reserve
        that much memory at init time.  So it could happen that when we need
        a larger file size that we may not have enough memory to allocate
        MaxSize bytes.
    28-Mar-1994     Danl
        ReadRegistryInfo:  LogFileInfo->LogFileName wasn't getting updated
        when using the default (generated) LogFileName.
    16-Mar-1994     Danl
        Fixed Memory Leaks in ReadRegistryInfo().  Call to
        RtlDosPathNameToNtPathName allocates memory that wasn't being free'd.
    03-Mar-1995     MarkBl
        Added GuestAccessRestriction flag initialization in ReadRegistryInfo.

--*/

//
// INCLUDES
//

#include <eventp.h>
#include <elfcfg.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>

//
// STRUCTURES
//

//
// This structure contains all the information used to setup and
// for listening to registry changes in the eventlog tree.
//
typedef struct _REG_MONITOR_INFO
{
    HANDLE      NotifyEventHandle;
    DWORD       Timeout;
    HANDLE      WorkItemHandle;
    HANDLE      RegMonitorHandle;
}
REG_MONITOR_INFO, *LPREG_MONITOR_INFO;


//
// GLOBALS
//

//
// IMPORTANT: If NUM_KEYS_MONITORED is changed, be sure to update the initialization of GlRegMonitorInfo and
//            the ElfAllEventsCleared macro accordingly.
//
#define NUM_KEYS_MONITORED 2
REG_MONITOR_INFO    GlRegMonitorInfo[NUM_KEYS_MONITORED] = { {NULL, 0, NULL, NULL}, {NULL, 0, NULL, NULL} };

#define ElfAllEventsCleared() (GlRegMonitorInfo[0].NotifyEventHandle == NULL && \
                               GlRegMonitorInfo[1].NotifyEventHandle == NULL )
//
// LOCAL FUNCTIONS
//
VOID
ElfRegistryMonitor(
    PVOID   pParms,
    BOOLEAN fWaitStatus
    );

BOOL
ElfSetupMonitor(
    LPREG_MONITOR_INFO  pMonitorInfo
    );



VOID
ProcessChange (
    HANDLE          hLogFile,
    PUNICODE_STRING ModuleName,
    PUNICODE_STRING LogFileName,
    ULONG           MaxSize,
    ULONG           Retention,
    LOGPOPUP        logpLogPopup,
    BOOL *              pbAcquiredString,
    DWORD dwAutoBackup
    )

/*++

Routine Description:

    This routine is called by ProcessRegistryChanges for each log file.

Arguments:


Return Value:

    None

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PLOGMODULE      pModule;
    PLOGFILE        pLogFile;
    ULONG           Size;
    PVOID           BaseAddress;
    PUNICODE_STRING pFileNameString;
    LPWSTR          FileName;
    PVOID           FreeAddress;
    BOOL bSDChanged;
    LPWSTR pwsSaveCustomSDDL = NULL;
    PSECURITY_DESCRIPTOR pSavedSd = NULL;
    DWORD dwType;
    *pbAcquiredString = FALSE;
    pModule = GetModuleStruc (ModuleName);

    //
    // If this module didn't exist, this was a brand new log file and
    // we need to create all the structures
    //
    if (pModule == ElfDefaultLogModule &&
        wcscmp(ModuleName->Buffer, ELF_DEFAULT_MODULE_NAME))
    {
        ELF_LOG1(MODULES,
                 "ProcessChange: %ws log doesn't exist -- creating\n",
                 ModuleName->Buffer);

        Status = SetUpDataStruct(LogFileName,
                                 MaxSize,
                                 Retention,
                                 ModuleName,
                                 hLogFile,
                                 ElfNormalLog,
                                 logpLogPopup,
                                 dwAutoBackup);
        if (NT_SUCCESS(Status))
            *pbAcquiredString = TRUE;
        return;
    }

    // check for changes in the security setting
    pLogFile = pModule->LogFile;
    dwType = GetModuleType(pLogFile->LogModuleName->Buffer);
    RtlAcquireResourceExclusive(&pLogFile->Resource, TRUE);                  // Wait until available
    pwsSaveCustomSDDL = pLogFile->pwsCurrCustomSD;
    pSavedSd = pLogFile->Sd;
    Status = ElfpCreateLogFileObject(
                                                pLogFile,
                                                dwType,
                                                hLogFile,
                                                FALSE,
                                                &bSDChanged);
    RtlReleaseResource(&pLogFile->Resource);
    if(NT_SUCCESS(Status) && bSDChanged == TRUE)
    {
        ElfpFreeBuffer (pwsSaveCustomSDDL);
        RtlDeleteSecurityObject(&pSavedSd);
    }

    //
    // Update values
    //

    pLogFile = pModule->LogFile;

    pLogFile->Retention = Retention;
    pLogFile->logpLogPopup = logpLogPopup;
    pLogFile->AutoBackupLogFiles = dwAutoBackup;

    //
    // Check to see if the name has changed.  If it has, and the log
    // hasn't been used yet, then use the new name.  Be sure to free
    // memory that was used for the old name.
    //
    if ((wcscmp(pLogFile->LogFileName->Buffer, LogFileName->Buffer) != 0)
          &&
        (pLogFile->BeginRecord == pLogFile->EndRecord))
    {
        pFileNameString = ElfpAllocateBuffer(sizeof(UNICODE_STRING)
                                               + LogFileName->MaximumLength);

        if (pFileNameString != NULL)
        {
            FileName = (LPWSTR)(pFileNameString + 1);
            StringCchCopyW(FileName, LogFileName->MaximumLength/sizeof(WCHAR), 
                                            LogFileName->Buffer);
            RtlInitUnicodeString(pFileNameString, FileName);

            ElfpFreeBuffer(pLogFile->LogFileName);
            pLogFile->LogFileName = pFileNameString;
        }
    }

    //
    // The log file can only be grown dynamically.  To shrink it,
    // it has to be cleared.
    //
    if (pLogFile->ConfigMaxFileSize < ELFFILESIZE(MaxSize))
    {
        /*
            Description of recent changes.  Problem and Solution:
            A couple of problems exist.  (1) There is no error
            checking if memory can't be allocated or mapped, and
            therefore, no error paths exist for handling these
            situations.  (2) Now that the eventlog is in services.exe
            there isn't a good way to synchronize memory allocations.

            Solution:
            I considered having some utility routines for managing
            memory in the eventlog.  These would attempt to
            extend a reserved block, or get a new reserved block.
            However, there are so many places where that could fail,
            it seemed very cumbersome to support the reserved blocks.
            So the current design only deals with mapped views.
            The ConfigMaxFileSize is only used to limit the size of
            the mapped view, and doesn't reserve anything.  This
            means you are not guaranteed to be operating with a file as
            large as the MaxSize specified in the registry.  But then,
            you weren't guarenteed that it would even work with the
            original design.
        */

        ELF_LOG3(TRACE,
                 "ProcessChange: Growing %ws log from %x bytes to %x bytes\n",
                 ModuleName->Buffer,
                 pLogFile->ConfigMaxFileSize,
                 ELFFILESIZE(MaxSize));

        pLogFile->ConfigMaxFileSize    = ELFFILESIZE(MaxSize);
        pLogFile->NextClearMaxFileSize = ELFFILESIZE(MaxSize);
    }
    else if (pLogFile->ConfigMaxFileSize > ELFFILESIZE(MaxSize))
    {
        //
        // They're shrinking the size of the log file.
        // Next time we clear the log file, we'll use the new size
        // and new retention.
        //
        ELF_LOG3(TRACE,
                 "ProcessChange: Shrinking %ws log from %x bytes to %x bytes at next clear\n",
                 ModuleName->Buffer,
                 pLogFile->ConfigMaxFileSize,
                 ELFFILESIZE(MaxSize));

        pLogFile->NextClearMaxFileSize = ELFFILESIZE(MaxSize);
    }

    //
    // Now see if they've added any new modules for this log file
    //
    SetUpModules(hLogFile, pLogFile, TRUE);

    return;
}

VOID
ProcessRegistryChanges (
    VOID
    )

/*++

Routine Description:

    This routine processes that changes that have occurred in the
    eventlog node. It does this by rescanning the whole Eventlog node
    and then comparing with what it has as the current configuration.

Arguments:

    NONE.

Return Value:

    NONE

--*/
{
    NTSTATUS              Status;
    HANDLE                hLogFile;
    UNICODE_STRING        SubKeyName;
    ULONG                 Index = 0;
    BYTE                  Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_NODE_INFORMATION KeyBuffer = (PKEY_NODE_INFORMATION) Buffer;
    ULONG                 ActualSize;
    LOG_FILE_INFO         LogFileInfo;
    PWCHAR                SubKeyString;
    OBJECT_ATTRIBUTES     ObjectAttributes;
    PLOGMODULE            pModule;
    LOGPOPUP              logpLogPopup;
    BOOL bAcquiredString;
#if DBG

    ULONG    ulActualSize;

#endif  // DBG


    ELF_LOG0(TRACE,
             "ProcessRegistryChanges: Handling change in Eventlog service key\n");

    //
    // Take the global resource so that nobody is making changes or
    // using the existing configured information.
    //

    GetGlobalResource (ELF_GLOBAL_SHARED);


#if DBG

    //
    // See if the Debug flag changed
    //

    RtlInitUnicodeString(&SubKeyName, VALUE_DEBUG);

    Status = NtQueryValueKey(hEventLogNode,
                             &SubKeyName,
                             KeyValuePartialInformation,
                             KeyBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);

    if (NT_SUCCESS(Status))
    {
        if (((PKEY_VALUE_PARTIAL_INFORMATION) KeyBuffer)->Type == REG_DWORD)
        {
            ElfDebugLevel = *(LPDWORD) (((PKEY_VALUE_PARTIAL_INFORMATION) KeyBuffer)->Data);
        }
    }
    else
    {
        ELF_LOG1(TRACE,
                 "ProcessRegistryChanges: NtQueryValueKey for ElfDebugLevel failed %#x\n",
                 Status);
    }

    ELF_LOG1(TRACE,
             "ProcessRegistryChanges: New ElfDebugLevel is %#x\n",
             ElfDebugLevel);

#endif  // DBG


    Status = STATUS_SUCCESS;

    //
    // Loop thru the subkeys under Eventlog and set up each logfile
    //

    while (NT_SUCCESS(Status))
    {
        Status = NtEnumerateKey(hEventLogNode,
                                Index++,
                                KeyNodeInformation,
                                KeyBuffer,
                                ELF_MAX_REG_KEY_INFO_SIZE,
                                &ActualSize);

        if (NT_SUCCESS(Status))
        {
            //
            // It turns out the Name isn't null terminated, so we need
            // to copy it somewhere and null terminate it before we use it
            //
            SubKeyString = ElfpAllocateBuffer(KeyBuffer->NameLength + sizeof (WCHAR));
            bAcquiredString =   FALSE;
            
            if (!SubKeyString)
            {
                //
                // No one to notify, just give up till next time.
                //
                ELF_LOG0(ERROR,
                         "ProcessRegistryChanges: Unable to allocate subkey -- returning\n");

                ReleaseGlobalResource();
                return;
            }

            memcpy(SubKeyString, KeyBuffer->Name, KeyBuffer->NameLength);
            SubKeyString[KeyBuffer->NameLength / sizeof(WCHAR)] = L'\0' ;

            //
            // Open the node for this logfile and extract the information
            // required by SetupDataStruct, and then call it.
            //

            RtlInitUnicodeString(&SubKeyName, SubKeyString);

            InitializeObjectAttributes(&ObjectAttributes,
                                      &SubKeyName,
                                      OBJ_CASE_INSENSITIVE,
                                      hEventLogNode,
                                      NULL
                                      );

            Status = NtOpenKey(&hLogFile,
                               KEY_READ | KEY_SET_VALUE,
                               &ObjectAttributes);

            //
            // Should always succeed since I just enum'ed it, but if it
            // doesn't, just skip it
            //
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ProcessRegistryChanges: NtOpenKey for subkey %ws failed %#x\n",
                         SubKeyName,
                         Status);

                ElfpFreeBuffer(SubKeyString);
                Status = STATUS_SUCCESS; // to keep the enum going
                continue;
            }

            //
            // Get the updated information from the registry.  Note that we
            // have to initialize the "log full" popup policy before doing
            // so since ReadRegistryInfo will compare the value found in the
            // registry (if there is one) to the current value.
            //

            pModule = GetModuleStruc(&SubKeyName);

            LogFileInfo.logpLogPopup = pModule->LogFile->logpLogPopup;

            Status = ReadRegistryInfo(hLogFile,
                                      &SubKeyName,
                                      &LogFileInfo);

            if (NT_SUCCESS(Status))
            {
                //
                // Now process any changes for the log file.
                // ProcessChange deals with any errors.
                //
                ProcessChange (
                    hLogFile,
                    &SubKeyName,
                    LogFileInfo.LogFileName,
                    LogFileInfo.MaxFileSize,
                    LogFileInfo.Retention,
                    LogFileInfo.logpLogPopup,
                    &bAcquiredString,
                    LogFileInfo.dwAutoBackup);

                //
                // Free the buffer that was allocated in ReadRegistryInfo.
                //
                ElfpFreeBuffer(LogFileInfo.LogFileName);
            }
            else
            {
                ELF_LOG2(ERROR,
                         "ProcessRegistryChanges: ReadRegistryInfo for subkey %ws failed %#x\n",
                         SubKeyString,
                         Status);
            }
            if(bAcquiredString == FALSE)
                ElfpFreeBuffer(SubKeyString);
            NtClose(hLogFile);
        }
    }

    //
    // Release the global resource.
    //
    ReleaseGlobalResource();

} // ProcessRegistryChanges


NTSTATUS
ElfCheckForComputerNameChange(
    )

/*++

Routine Description:

    This routine checks to determine if the computer name has changed.  If
    it has, then it generates an event.
Arguments:

    NONE

Return Value:

    NONE

--*/
{
    LPWSTR      Dates[2];
    NTSTATUS           Status;
    UNICODE_STRING     ValueName;
    ULONG              ulActualSize;
    DWORD dwLen;
    WCHAR wElfComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR wComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    BYTE            Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION ValueBuffer =
        (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;

    RtlInitUnicodeString(&ValueName, VALUE_COMPUTERNAME);

    // Read the name that the event log stored.

    Status = NtQueryValueKey(hEventLogNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);
    if (!NT_SUCCESS(Status) || ValueBuffer->DataLength == 0)
    {
        ELF_LOG1(ERROR,
                 "ElfCheckForComputerNameChange: NtQueryValueKey for current name failed %#x\n",
                 Status);
        return Status;
    }
    StringCchCopyW(wElfComputerName, MAX_COMPUTERNAME_LENGTH + 1, (WCHAR *)ValueBuffer->Data);

    // Read the active name.

    Status = NtQueryValueKey(hComputerNameNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);
    if (!NT_SUCCESS(Status) || ValueBuffer->DataLength == 0)
    {
        ELF_LOG1(ERROR,
                 "ElfCheckForComputerNameChange: NtQueryValueKey for active name failed %#x\n",
                 Status);
        return Status;
    }
    StringCchCopyW(wComputerName, MAX_COMPUTERNAME_LENGTH + 1,(WCHAR *)ValueBuffer->Data);

    // If the names are the same, just return STATUS_SUCCESS

    if (!_wcsicmp(wElfComputerName, wComputerName))
        return STATUS_SUCCESS;

    Dates[0] = wElfComputerName;
    Dates[1] = wComputerName;
    ElfpCreateElfEvent(EVENT_ComputerNameChange,
                       EVENTLOG_INFORMATION_TYPE,
                       0,                    // EventCategory
                       2,                    // NumberOfStrings
                       Dates,                 // Strings
                       NULL,                 // Data
                       0,                    // Datalength
                       0,                    // flags
                       FALSE);               // for security file    

    dwLen = sizeof(WCHAR) * (wcslen(wComputerName) + 1);
    Status = NtSetValueKey(hEventLogNode,
                                   &ValueName,
                                   0,
                                   REG_SZ,
                                   wComputerName,
                                   dwLen);

    if (!NT_SUCCESS(Status))
        ELF_LOG1(ERROR,
                 "ElfCheckForComputerNameChange: NtSetValueKey failed %#x\n",
                 Status);

    return Status;
                       
}

VOID
ElfRegistryMonitor (
    PVOID     pParms,
    BOOLEAN   fWaitStatus
    )

/*++

Routine Description:

    This is the entry point for the thread that will monitor changes in
    the registry. If anything changes, it will have to scan the change
    and then make the appropriate changes to the data structures in the
    service to reflect the new information.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    NTSTATUS            ntStatus;
    LPREG_MONITOR_INFO  pMonitorInfo = (LPREG_MONITOR_INFO)pParms;

    ELF_LOG0(TRACE,
             "ElfRegistryMonitor: Registry monitor thread waking up\n");

    //
    // Deregister the work item (must be done even if the
    // WT_EXECUTEONLYONCE flag is specified)
    //
    if (pMonitorInfo->WorkItemHandle != NULL)
    {
        ntStatus = RtlDeregisterWait(pMonitorInfo->WorkItemHandle);
        pMonitorInfo->WorkItemHandle = NULL;

        if (!NT_SUCCESS(ntStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfRegistryMonitor: RtlDeregisterWorkItem failed %#x\n",
                     ntStatus);
        }
    }

    if (GetElState() == STOPPING)
    {
        //
        // If the eventlog is shutting down, then we need
        // to terminate this thread.
        //
        ELF_LOG0(TRACE, "ElfRegistryMonitor: Shutdown\n");

        //
        // Close the registry handle and registry event handle.
        //
        if( pMonitorInfo->NotifyEventHandle != NULL )
        {
            NtClose( pMonitorInfo->NotifyEventHandle );
            pMonitorInfo->NotifyEventHandle = NULL;
        }

        if( pMonitorInfo->RegMonitorHandle != NULL )
        {
            NtClose(pMonitorInfo->RegMonitorHandle);
            pMonitorInfo->RegMonitorHandle = NULL;
        }

        //
        // This thread will perform the final cleanup for the eventlog.
        // Cleanup is not initiated until all events have been signaled 
        //  and closed
        //
        if( ElfAllEventsCleared() )
        {
            ElfpCleanUp(EventFlags);
        }
        return;
    }

    if (fWaitStatus == TRUE)
    {
       ELF_LOG0(TRACE,
                "ElfRegistryMonitor: Running because of a timeout -- running queued list\n");

       //
       // Timer popped, try running the list
       //
       if (!IsListEmpty(&QueuedEventListHead))
       {
           //
           // There are things queued up to write, do it
           //
           WriteQueuedEvents();
       }

       //
       // Don't wait again
       //
       pMonitorInfo->Timeout = INFINITE;
    }
    else
    {
        ELF_LOG0(TRACE,
                 "ElfRegistryMonitor: Running because of notification\n");

        ProcessRegistryChanges ();
        ElfCheckForComputerNameChange();
    }

    if (!ElfSetupMonitor(pMonitorInfo))
    {
        ELF_LOG0(ERROR,
                 "ElfRegistryMonitor: ElfSetupMonitor failed -- "
                     "no longer listening for reg changes\n");
    }

    ELF_LOG0(TRACE,
             "ElfRegistryMonitor: Returning\n");

    return;

} // ElfRegistryMonitor

VOID
InitNotify(
    PVOID   pData
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    DWORD               status   = NO_ERROR;
    DWORD               Buffer;
    PVOID               pBuffer  = &Buffer;
    LPREG_MONITOR_INFO  pMonitorInfo;

    static IO_STATUS_BLOCK IoStatusBlock;

    ELF_LOG0(TRACE,
             "InitNotify: Registering Eventlog key with NtNotifyChangeKey\n");

    pMonitorInfo = (LPREG_MONITOR_INFO)pData;

    NtStatus = NtNotifyChangeKey (
                    pMonitorInfo->RegMonitorHandle,
                    pMonitorInfo->NotifyEventHandle,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    REG_NOTIFY_CHANGE_LAST_SET |
                    REG_NOTIFY_CHANGE_NAME,
                    TRUE,
                    pBuffer,
                    1,
                    TRUE);    // return and wait on event

    if (!NT_SUCCESS(NtStatus))
    {
        ELF_LOG1(ERROR,
                 "InitNotify: NtNotifyChangeKey on Eventlog key failed %#x\n",
                 NtStatus);

        status = RtlNtStatusToDosError(NtStatus);
    }

    ELF_LOG0( TRACE, "InitNotify: Returning\n" );

    return;

} // InitNotify

BOOL
ElfSetupMonitor(
    LPREG_MONITOR_INFO  pMonitorInfo
    )

/*++

Routine Description:

    This function submits a request for a registry NotifyChangeKey
    and then submits a work item to the service controller thread
    management system to wait for the Notification handle to become
    signaled.

Arguments:

    pMonitorInfo - This is a pointer to a MONITOR_INFO structure.  This
        function fills in the WorkItemHandle member of that structure
        if successfully adds a new work item.

Return Value:

    TRUE - if successful in setting up.
    FALSE - if unsuccessful.  A work item hasn't been submitted, and
        we won't be listening for registry changes.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;

    //
    // Call NtNotifyChange Key via the thread pool
    // and make sure the thread that created the I/O
    // request will always be around.
    //
    Status = RtlQueueWorkItem(InitNotify,              // Callback
                              pMonitorInfo,            // pContext
                              WT_EXECUTEONLYONCE |
                                WT_EXECUTEINPERSISTENTIOTHREAD);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfSetupMonitor: RtlQueueWorkItem failed %#x\n",
                 Status);

        return FALSE;
    }

    //
    // Add the work item that is to be called when the
    // NotifyEventHandle is signalled.
    //

    Status = RtlRegisterWait(&pMonitorInfo->WorkItemHandle,
                             pMonitorInfo->NotifyEventHandle,  // Waitable handle
                             ElfRegistryMonitor,               // Callback
                             pMonitorInfo,                     // pContext
                             pMonitorInfo->Timeout,            // Timeout
                             WT_EXECUTEONLYONCE |
                               WT_EXECUTEINPERSISTENTIOTHREAD);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfSetupMonitor: RtlRegisterWait failed %#x\n",
                 Status);

        return FALSE;
    }

    return TRUE;

}  // ElfSetupMonitor

BOOL
ElfStartRegistryMonitor()

/*++

Routine Description:

    This routine starts up the thread that monitors changes in the registry.

    This function calls ElfSetupMonitor() to register for the change
    notification and to submit a work item to wait for the registry
    change event to get signaled.  When signalled, the ElfRegistryMonitor()
    callback function is called by a thread from the services thread pool.
    This callback function services the notification.

Arguments:

    NONE

Return Value:

    TRUE if thread creation succeeded, FALSE otherwise.

Note:


--*/
{
    NTSTATUS        Status       = STATUS_SUCCESS;
    DWORD           LoopCounter  = 0;
    BOOL            ReturnStatus = TRUE;
    DWORD           LoopCount;

    ELF_LOG0(TRACE, "ElfStartRegistryMonitor: Setting up registry change notification\n");

    if (hEventLogNode == NULL)
    {
        ELF_LOG0(ERROR, "ElfStartRegistryMonitor: No Eventlog key -- exiting\n");

        return FALSE;
    }

    if (hComputerNameNode == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfStartRegistryMonitor: No ComputerName key -- exiting\n");

        return FALSE;
    }

    GlRegMonitorInfo[0].RegMonitorHandle = hEventLogNode;
    GlRegMonitorInfo[1].RegMonitorHandle = hComputerNameNode;

    //
    // Create the events on which to wait
    //

    for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
    {

        Status = NtCreateEvent(&GlRegMonitorInfo[LoopCount].NotifyEventHandle,
                               EVENT_ALL_ACCESS,
                               NULL,
                               NotificationEvent,
                               FALSE);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR, "ElfStartRegistryMonitor: NtCreateEvent failed %#x\n",
                     Status);

            GlRegMonitorInfo[LoopCount].NotifyEventHandle = NULL;

            break;

        }

        //
        // Fill in the Monitor info structure with the event handle
        // and a 5 minute timeout.
        //
        GlRegMonitorInfo[LoopCount].Timeout           = 5 * 60 * 1000;
        GlRegMonitorInfo[LoopCount].WorkItemHandle    = NULL;
    }

    //
    // Cleanup all events, its all or nothing
    //
    if(!NT_SUCCESS(Status))
    {
        for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
        {
            if( GlRegMonitorInfo[LoopCount].NotifyEventHandle != NULL )
            {
                NtClose( GlRegMonitorInfo[LoopCount].NotifyEventHandle );
                GlRegMonitorInfo[LoopCount].NotifyEventHandle = NULL;
            }

        }

        return FALSE;
    }


    //
    // Setup for the change notify and
    // submit the work item to the eventlog threadpool.
    //
    for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
    {

        if (!ElfSetupMonitor(&GlRegMonitorInfo[LoopCount]))
        {
            ELF_LOG0(ERROR,
                     "ElfStartRegistryMonitor: ElfSetupMonitor failed -- exiting\n");
    
            //
            // Note that it's OK to close this handle as there's no way
            // the handle was used for a registered wait at this point
            // (since ElfSetupMonitor failed).
            //
            NtClose( GlRegMonitorInfo[LoopCount].NotifyEventHandle );
            GlRegMonitorInfo[LoopCount].NotifyEventHandle = NULL;

            return FALSE;
        }

        //
        //Set this flag since we have at least one success
        //If any startup fails, then this setting will ensure that all
        // started monitors are shutdown
        //
        EventFlags |= ELF_STARTED_REGISTRY_MONITOR;
    }
    
    ELF_LOG0(TRACE, "ElfStartRegistryMonitor: Exiting after successful call\n");

    return TRUE;

} // ElfStartRegistryMonitor

VOID
StopRegistryMonitor ()

/*++

Routine Description:

    This routine wakes up the work item that has been submitted for the
    purpose of monitoring registry eventlog changes.  The thread created
    to service that work item will actually do the clean-up of the monitor
    thread.


Arguments:

    NONE

Return Value:

    NONE

--*/

{
    DWORD LoopCount = 0;

    ELF_LOG0(TRACE, "StopRegistryMonitor: Stopping registry monitor\n");

    //
    // Wake up the RegistryMonitorThread.
    //
    for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
    {
        if (GlRegMonitorInfo[LoopCount].NotifyEventHandle != NULL)
        {
            SetEvent(GlRegMonitorInfo[LoopCount].NotifyEventHandle);
        }
    }

    return;

} // StopRegistryMonitor

NTSTATUS
ReadRegistryValue (
    HANDLE          hLogFile,
    PCWSTR  pName,
    PKEY_VALUE_FULL_INFORMATION ValueBuffer
    )

/*++

Routine Description:

    This routine reads a single value from the registry.  It retrys after waiting
    a short period if the return code is c000034.  This takes care of certain
    race conditions.

Arguments:

    hLogFile - A handle to the Eventlog\<somelogfile> node in the registry
    ValueName  - Value name
    ValueBuffer - Where the data is to be copied

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        Status;
    ULONG           ActualSize;
    UNICODE_STRING  ValueName;
    RtlInitUnicodeString(&ValueName, pName);

    Status = NtQueryValueKey(hLogFile,
                             &ValueName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ActualSize);
    if(Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        if(g_dwLastDelayTickCount == 0 || 
            ((GetTickCount() - g_dwLastDelayTickCount) > 30000))
        {
            Sleep(2000);
            Status = NtQueryValueKey(hLogFile,
                                 &ValueName,
                                 KeyValueFullInformation,
                                 ValueBuffer,
                                 ELF_MAX_REG_KEY_INFO_SIZE,
                                 &ActualSize);
            g_dwLastDelayTickCount = GetTickCount();       // used up our kindness
        }
    }
    return Status;
}

NTSTATUS
ReadRegistryInfo (
    HANDLE          hLogFile,
    PUNICODE_STRING SubKeyName,
    PLOG_FILE_INFO  LogFileInfo
    )

/*++

Routine Description:

    This routine reads in the information from the node pointed to by
    hLogFile and stores it in the a structure so that the
    necessary data structures can be set up for the service.

    ALLOCATIONS:  If successful, this function allocates memory for
        LogFileInfo->LogFileName.  It is the responsiblilty of the caller
        to free this memory.

Arguments:

    hLogFile - A handle to the Eventlog\<somelogfile> node in the registry
    KeyName  - The subkey for this logfile to open
    LogFileInfo - The structure to fill in with the data

Return Value:

    NTSTATUS

--*/
{

#define EXPAND_BUFFER_SIZE 64

    NTSTATUS        Status;
    BOOLEAN         RegistryCorrupt = FALSE;
    BYTE            Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    ULONG           ActualSize;
    UNICODE_STRING  ValueName;
    UNICODE_STRING  UnexpandedName;
    UNICODE_STRING  ExpandedName;
    ULONG           NumberOfBytes = 0;
    BYTE            ExpandNameBuffer[EXPAND_BUFFER_SIZE];
    PUNICODE_STRING FileNameString;
    LPWSTR          FileName;
    BOOL            ExpandedBufferWasAllocated=FALSE;
    PKEY_VALUE_FULL_INFORMATION ValueBuffer =
        (PKEY_VALUE_FULL_INFORMATION) Buffer;

    ASSERT(hLogFile != NULL);

    ELF_LOG1(TRACE,
             "ReadRegistryInfo: Reading information for %ws log\n",
             SubKeyName->Buffer);

    //
    // MaxSize
    //

    Status = ReadRegistryValue (hLogFile,
                        VALUE_MAXSIZE,
                        ValueBuffer);
   
    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ReadRegistryInfo: Can't read MaxSize value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        LogFileInfo->MaxFileSize = ELF_DEFAULT_MAX_FILE_SIZE;
        RegistryCorrupt = TRUE;
    }
    else
    {
        LogFileInfo->MaxFileSize = *((PULONG)(Buffer +
            ValueBuffer->DataOffset));

    ELF_LOG2(TRACE,
             "ReadRegistryInfo: New MaxSize value for %ws log is %#x\n",
             SubKeyName->Buffer,
             LogFileInfo->MaxFileSize);
    }

    //
    // The security log has an optional warning level.
    //

    if(0 == _wcsicmp(SubKeyName->Buffer, ELF_SECURITY_MODULE_NAME))
    {

        Status = ReadRegistryValue (hLogFile,
                            VALUE_WARNINGLEVEL,
                            ValueBuffer);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(TRACE,
                 "ReadRegistryInfo: Can't read WarningLevel value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

            giWarningLevel= ELF_DEFAULT_WARNING_LEVEL;
        }
        else
        {
            giWarningLevel = *((PULONG)(Buffer +
                ValueBuffer->DataOffset));

          ELF_LOG2(TRACE,
                 "ReadRegistryInfo: New WarningLevel value for %ws log is %#x\n",
                 SubKeyName->Buffer,
                 LogFileInfo->Retention);
            if(giWarningLevel < 0 || giWarningLevel > 99)
            {
                giWarningLevel = ELF_DEFAULT_WARNING_LEVEL;
                ELF_LOG0(ERROR,
                 "ReadRegistryInfo: New WarningLevel is invalid, being set to 0\n");
            }
        }
    }

    //
    // Retention period
    //

    Status = ReadRegistryValue (hLogFile,
                        VALUE_RETENTION,
                        ValueBuffer);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ReadRegistryInfo: Can't read Retention value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        LogFileInfo->Retention = ELF_DEFAULT_RETENTION_PERIOD;
        RegistryCorrupt = TRUE;
    }
    else
    {
        LogFileInfo->Retention = *((PULONG)(Buffer +
            ValueBuffer->DataOffset));

    ELF_LOG2(TRACE,
             "ReadRegistryInfo: New Retention value for %ws log is %#x\n",
             SubKeyName->Buffer,
             LogFileInfo->Retention);
    }

    //
    // Autobackup value (optional!)
    //

    Status = ReadRegistryValue (hLogFile,
                        REGSTR_VAL_AUTOBACKUPLOGFILES,
                        ValueBuffer);

    if (!NT_SUCCESS(Status))
    {
        LogFileInfo->dwAutoBackup = 0;
    }
    else
    {
        LogFileInfo->dwAutoBackup = *((PULONG)(Buffer +
            ValueBuffer->DataOffset));

        ELF_LOG2(TRACE,
             "ReadRegistryInfo: New autobackup value for %ws log is %#x\n",
             SubKeyName->Buffer,
             LogFileInfo->dwAutoBackup);
    }

    //
    // Filename
    //

    Status = ReadRegistryValue (hLogFile,
                        VALUE_FILENAME,
                        ValueBuffer);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ReadRegistryInfo: Can't read Filename value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        //
        // Allocate the buffer for the UNICODE_STRING for the filename and
        // initialize it. (41 = \Systemroot\system32\config\xxxxxxxx.evt)
        //
        #define REG_NAME_SIZE 41
        FileNameString = ElfpAllocateBuffer(REG_NAME_SIZE * sizeof(WCHAR) + sizeof(UNICODE_STRING));

        if (!FileNameString)
        {
            ELF_LOG0(ERROR,
                     "ReadRegistryInfo: Unable to allocate FileNameString\n");

            return STATUS_NO_MEMORY;
        }

        LogFileInfo->LogFileName = FileNameString;
        FileName = (LPWSTR)(FileNameString + 1);
        StringCchCopyW(FileName, REG_NAME_SIZE, L"\\Systemroot\\System32\\Config\\");
        StringCchCatW(FileName, REG_NAME_SIZE, SubKeyName->Buffer);
        StringCchCatW(FileName, REG_NAME_SIZE,L".evt");
        RtlInitUnicodeString(FileNameString, FileName);

        RegistryCorrupt = TRUE;
    }
    else
    {
        //
        // If it's a REG_EXPAND_SZ expand it
        //

        if (ValueBuffer->Type == REG_EXPAND_SZ)
        {
            ELF_LOG0(TRACE,
                     "ReadRegistryInfo: Filename is a REG_EXPAND_SZ -- expanding\n");

            //
            // Initialize the UNICODE_STRING, when the string isn't null
            // terminated
            //
            UnexpandedName.MaximumLength = UnexpandedName.Length =
                (USHORT) ValueBuffer->DataLength;

            UnexpandedName.Buffer = (PWSTR) ((PBYTE) ValueBuffer +
                ValueBuffer->DataOffset);

            //
            // Call the magic expand-o api
            //
            ExpandedName.Length = ExpandedName.MaximumLength = EXPAND_BUFFER_SIZE;
            ExpandedName.Buffer = (LPWSTR) ExpandNameBuffer;

            Status = RtlExpandEnvironmentStrings_U(NULL,
                                                   &UnexpandedName,
                                                   &ExpandedName,
                                                   &NumberOfBytes);

            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                ELF_LOG0(TRACE,
                         "ReadRegistryInfo: Expansion buffer too small -- retrying\n");

                //
                // The default buffer wasn't big enough.  Allocate a
                // bigger one and try again
                //
                ExpandedName.Length = ExpandedName.MaximumLength = (USHORT) NumberOfBytes;

                ExpandedName.Buffer = ElfpAllocateBuffer(ExpandedName.Length);

                if (!ExpandedName.Buffer)
                {
                    ELF_LOG0(ERROR,
                             "ReadRegistryInfo: Unable to allocate larger Filename buffer\n");

                    return(STATUS_NO_MEMORY);
                }

                ExpandedBufferWasAllocated = TRUE;

                Status = RtlExpandEnvironmentStrings_U(NULL,
                                                       &UnexpandedName,
                                                       &ExpandedName,
                                                       &NumberOfBytes);
            }

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG1(ERROR,
                         "ReadRegistryInfo: RtlExpandEnvironmentStrings_U failed %#x\n",
                         Status);

                if (ExpandedBufferWasAllocated)
                {
                    ElfpFreeBuffer(ExpandedName.Buffer);
                }

                return Status;
            }
        }
        else
        {
            //
            // It doesn't need to be expanded, just set up the UNICODE_STRING
            // for the conversion to an NT pathname
            //
            ExpandedName.MaximumLength = ExpandedName.Length =
                (USHORT) ValueBuffer->DataLength;

            ExpandedName.Buffer = (PWSTR) ((PBYTE) ValueBuffer +
                ValueBuffer->DataOffset);
        }

        //
        // Now convert from a DOS pathname to an NT pathname
        //
        // NOTE:  this allocates a buffer for ValueName.Buffer.
        //
        if (!RtlDosPathNameToNtPathName_U(ExpandedName.Buffer,
                                          &ValueName,
                                          NULL,
                                          NULL))
        {
            ELF_LOG0(ERROR,
                     "ReadRegistryInfo: RtlDosPathNameToNtPathName_U failed\n");

            if (ExpandedBufferWasAllocated)
            {
                ElfpFreeBuffer(ExpandedName.Buffer);
            }

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Allocate memory for the unicode string structure and the buffer
        // so that it can be free'd with a single call.
        //
        FileNameString = ElfpAllocateBuffer(
                            sizeof(UNICODE_STRING) +
                                ((ValueName.Length + 1) * sizeof(WCHAR)));

        if (FileNameString == NULL)
        {
            ELF_LOG0(ERROR,
                     "ReadRegistryInfo: Unable to allocate copy of NT filename\n");

            if (ExpandedBufferWasAllocated)
            {
                ElfpFreeBuffer(ExpandedName.Buffer);
            }

            //
            // RtlDosPathNameToNtPathName_U allocates off the process heap
            //
            RtlFreeHeap(RtlProcessHeap(), 0, ValueName.Buffer);

            return STATUS_NO_MEMORY;
        }

        //
        // Copy the NtPathName string into the new buffer, and initialize
        // the unicode string.
        //
        FileName = (LPWSTR)(FileNameString + 1);
        wcsncpy(FileName, ValueName.Buffer, ValueName.Length);
        *(FileName+ValueName.Length) = L'\0';
        RtlInitUnicodeString(FileNameString, FileName);

        //
        // RtlDosPathNameToNtPathName_U allocates off the process heap
        //
        RtlFreeHeap(RtlProcessHeap(), 0, ValueName.Buffer);

        //
        // Clean up if I had to allocate a bigger buffer than the default
        //

        if (ExpandedBufferWasAllocated)
        {
            ElfpFreeBuffer(ExpandedName.Buffer);
        }
    }

    //
    // Add the LogFileName to the LogFileInfo structure.
    //
    LogFileInfo->LogFileName = FileNameString;

    ELF_LOG2(TRACE,
             "ReadRegistryInfo: New (expanded) Filename value for %ws log is %ws\n",
             SubKeyName->Buffer,
             LogFileInfo->LogFileName->Buffer);


    //
    // "Log full" popup policy -- never change the security log
    //
    if (_wcsicmp(SubKeyName->Buffer, ELF_SECURITY_MODULE_NAME) != 0)
    {
        RtlInitUnicodeString(&ValueName, VALUE_LOGPOPUP);

        Status = NtQueryValueKey(hLogFile,
                                 &ValueName,
                                 KeyValueFullInformation,
                                 ValueBuffer,
                                 ELF_MAX_REG_KEY_INFO_SIZE,
                                 &ActualSize);

        if (NT_SUCCESS(Status))
        {
            LOGPOPUP  logpRegValue = *(PULONG)(Buffer + ValueBuffer->DataOffset);

            //
            // Only update the value if this constitutes a change in the current policy
            //
            if (LogFileInfo->logpLogPopup == LOGPOPUP_NEVER_SHOW
                 ||
                logpRegValue == LOGPOPUP_NEVER_SHOW)
            {
                LogFileInfo->logpLogPopup =
                                (logpRegValue == LOGPOPUP_NEVER_SHOW ? LOGPOPUP_NEVER_SHOW :
                                                                       LOGPOPUP_CLEARED);
            }
        }
        else
        {
            //
            // TRACE rather than ERROR as this value is optional
            //
            ELF_LOG2(TRACE,
                     "ReadRegistryInfo: Can't read LogPopup value for %ws log %#x\n",
                     SubKeyName->Buffer,
                     Status);
        }
    }

    
    //
    // If we didn't find all the required values, tell someone
    //

    if (RegistryCorrupt)
    {
        ELF_LOG1(ERROR,
                 "ReadRegistryInfo: One or more registry values for %ws log invalid\n",
                 SubKeyName->Buffer);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\eltest\eltest.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ELTEST.C

Abstract:

    Test Routines for the EventLog.

THINGS I WANT THIS TO DO...
    AddReg <ServerName> <logname> <EntryName> <EventMessageFile>
        <CategoryMessageFile> <CategoryCount> <ParameterMessageFile>
        <TypesSupported>   - Creates A Registry Entry.

        eltest addreg application mytest mf= eltest.dll cat=

    CreateMessageFile <??? Is this possible ???>

    WriteEvent <ServerName> <EventSource> <Type> <Category> <EventId> <UserSid?>
        <NumStrings> <Strings> <RawData>

    ReadLog <Server> <LogFile> <ReadFlags> <RecordOffset> <bufSize>
        If LogFile isn't one of the popular ones, then it could be a backup
        logfile.

    GetNumEvents <Server> <LogFile>

    GetOldest <Server> <LogFile>

    Clear <Server> <LogFile>

    Backup <Server> <LogFile> <BackupFile>


    LOOPTESTS....
    I should be able to run this test like mprtest such that it doesn't leave
    the test process until told.  This way we can register an event source,
    then if we call WriteEvent without a specified EventSource, it will use
    the stored source.  Calling RegisterEventSource twice without calling
    DeRegisterSource would be an error.  (Or better yet, I could keep a table
    of sources and handles).

    RegisterEventSource <EventSource>
    DeRegisterSource <EventSource>




PROTOTYPES FOR FUNCTION....

BOOL
CloseEventLog (
    HANDLE hEventLog
    )
BOOL
DeregisterEventSource (
    HANDLE hEventLog
    )

BOOL
NotifyChangeEventLog(
    HANDLE  hEventLog,
    HANDLE  hEvent
    )
BOOL
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    )
BOOL
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    )
BOOL
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )
BOOL
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )
HANDLE
OpenEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )
HANDLE
RegisterEventSourceW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )
HANDLE
OpenBackupEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  FileName
    )
BOOL
ReadEventLogW (
    HANDLE      hEventLog,
    DWORD       dwReadFlags,
    DWORD       dwRecordOffset,
    LPVOID      lpBuffer,
    DWORD       nNumberOfBytesToRead,
    DWORD       *pnBytesRead,
    DWORD       *pnMinNumberOfBytesNeeded
    )
BOOL
ReportEventW (
    HANDLE      hEventLog,
    WORD        wType,
    WORD        wCategory       OPTIONAL,
    DWORD       dwEventID,
    PSID        lpUserSid       OPTIONAL,
    WORD        wNumStrings,
    DWORD       dwDataSize,
    LPCWSTR     *lpStrings      OPTIONAL,
    LPVOID      lpRawData       OPTIONAL
    )




Author:

    Dan Lafferty    (danl)  09-March-1994

Environment:

    User Mode - Win32

Revision History:

    09-Mar-1994     danl
        created

--*/

//
// INCLUDES
//
#define UNICODE 1
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h


#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <conio.h>      // getch
#include <string.h>     // strcmp
#include <windows.h>    // win32 typedefs
#include <tstr.h>       // Unicode
#include <debugfmt.h>   // FORMAT_LPTSTR

//------------------
// DEFINES
//------------------
#define APPLICATION_LOG     "Application"
#define SYSTEM_LOG          "System"
#define SECURITY_LOG        "Security"

#define REG_APPLICATION_KEY "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"
#define REG_SYSTEM_KEY      "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"
#define REG_SECURITY_KEY    "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security\\"

#define EVENT_SOURCE_NAME       "tevent"
#define MSG_DLL                 "%SystemRoot%\\System32\\tevent.dll"

#define VALUE_EVENT_MF          TEXT("EventMessageFile")
#define VALUE_CATEGORY_MF       TEXT("CategoryMessageFile")
#define VALUE_PARAMETER_MF      TEXT("ParameterMessageFile")
#define VALUE_TYPES_SUPPORTED   TEXT("TypesSupported")
#define VALUE_CATEGORY_COUNT    TEXT("CategoryCount")

#define TYPES_SUPPORTED        (EVENTLOG_ERROR_TYPE     |   \
                                EVENTLOG_WARNING_TYPE   |   \
                                EVENTLOG_INFORMATION_TYPE)
//----------------------
// GLOBALS
//----------------------
    LPTSTR  ApplLogRegName=TEXT(REG_APPLICATION_KEY);
    LPTSTR  SysLogRegName =TEXT(REG_SYSTEM_KEY);
    LPTSTR  SecLogRegName =TEXT(REG_SECURITY_KEY);
    LPTSTR  ApplLogName   = TEXT(APPLICATION_LOG);
    LPTSTR  SysLogName    = TEXT(SYSTEM_LOG);
    LPTSTR  SecLogName    = TEXT(SECURITY_LOG);

//----------------------
// FUNCTION PROTOTYPES
//----------------------

VOID
AddRegUsage(VOID);

DWORD
AddSourceToRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );

DWORD
DelSourceInRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName
    );

VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSERVICE_STATUS    ServiceStatus
    );

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    );

BOOL
ProcessArgs (
    LPTSTR      ServerName,
    DWORD       argc,
    LPTSTR      argv[]
    );

VOID
Usage(
    VOID);

VOID
ConfigUsage(VOID);

VOID
CreateUsage(VOID);

VOID
QueryUsage(VOID);

LONG
wtol(
    IN LPWSTR string
    );

VOID
UserInputLoop(
    LPTSTR  ServerName
    );
DWORD
ReadLogFile(
    LPTSTR  ServerName,
    LPTSTR  LogName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    );
VOID
ReadLogUsage(VOID);

VOID
DisplayRecord(
    PEVENTLOGRECORD     pElRecord,
    BOOL                PrintTheHeader
    );

/****************************************************************************/
VOID __cdecl
main (
    DWORD           argc,
    PCHAR           argvAnsi[]
    )

/*++

Routine Description:

    Allows manual testing of the EVENTLOG API.

        eltest



Arguments:



Return Value:



--*/
{
    UCHAR   i;
    DWORD   j;
    DWORD   argIndex;
    LPTSTR  pServerName=NULL;
    LPTSTR  *argv;

    if (argc <2) {
        Usage();
        return;
    }

    //
    // Make the arguments unicode if necessary.
    //
#ifdef UNICODE
    if (!MakeArgsUnicode(argc, argvAnsi)) {
        return;
    }
#endif

    argv = (LPTSTR *)argvAnsi;

    argIndex = 1;
    if (STRNCMP (argv[1], TEXT("\\\\"), 2) == 0) {
        pServerName = argv[1];
        argIndex = 2;               // skip over servername.
    }

    //
    // Check to see if we are to run in Loop Mode, or in single function
    // mode.  In Loop Mode, we go into a loop, and ask the user for
    // input until the user decides to quit.
    //
    // Process Arguments:
    //
    // INDEX   0       1            2              3
    //         EL <ServerName> <Function> <FunctionOptions...>
    //

    if (STRICMP (argv[argIndex], TEXT("Loop")) == 0) {
        UserInputLoop(pServerName);
    }
    else {
        ProcessArgs(pServerName, argc-argIndex, &(argv[argIndex]));
    }


#ifdef UNICODE
    //
    // Free up the unicode strings if there are any
    //
    for(j=0; j<argc; j++) {
        LocalFree(argv[j]);
    }
#endif

    return;
}

VOID
UserInputLoop(
    LPTSTR  ServerName
    )

/*++

Routine Description:

    This function sits in a loop, gathering input from the user, and
    processing that input until the user indicates that it should stop.
    The following user commands indicate that we should stop:
        done
        exit
        stop
        quit

Arguments:


Return Value:


--*/
{
    UCHAR   i;
    DWORD   j;
    LPTSTR  *argv;
    UCHAR   buffer[255];
    LPSTR   argvA[20];
    DWORD   argc=0;
    BOOL    KeepGoing;

    do {
        //------------------------------
        // Get input from the user
        //------------------------------
        buffer[0] = 90-2;

        printf("\nwaiting for instructions... \n");
        _cgets(buffer);

        if (buffer[1] > 0) {
            //--------------------------------------
            // put the string in argv/argc format.
            //--------------------------------------
            buffer[1]+=2;       // make this an end offset
            argc=0;
            for (i=2,j=0; i<buffer[1]; i++,j++) {
                argc++;
                argvA[j] = &(buffer[i]);
                while ((buffer[i] != ' ') && (buffer[i] != '\0')) {
                    i++;
                }
                buffer[i] = '\0';
            }

            //------------------------------------------
            // Make the arguments unicode if necessary.
            //------------------------------------------
#ifdef UNICODE

            if (!MakeArgsUnicode(argc, argvA)) {
                return;
            }

#endif
            //-----------------------------------------------
            // If the first argument doesn't indicate that
            // we should stop, then process the arguments.
            //-----------------------------------------------
            argv = (LPTSTR *)argvA;

            if((STRICMP (argv[0], TEXT("done")) == 0) ||
               (STRICMP (argv[0], TEXT("stop")) == 0) ||
               (STRICMP (argv[0], TEXT("exit")) == 0) ||
               (STRICMP (argv[0], TEXT("quit")) == 0)) {
                KeepGoing  = FALSE;
            }
            else {
                KeepGoing = ProcessArgs(ServerName, argc, argv);
            }

#ifdef UNICODE
            //-----------------------------------------------
            // Free up the unicode strings if there are any
            //-----------------------------------------------
            for(j=0; j<argc; j++) {
                LocalFree(argv[j]);
            }
#endif
        }
    } while (KeepGoing);

    return;

}

/****************************************************************************/
BOOL
ProcessArgs (
    LPTSTR      ServerName,
    DWORD       argc,
    LPTSTR      argv[]
    )

/*++

Routine Description:


Arguments:



Return Value:



--*/

{
    DWORD           status;
    DWORD           specialFlag = FALSE;
    DWORD           argIndex;       // index to unchecked portion of arglist.


    argIndex = 0;

    //
    // If we are adding a registry entry, the get a handle to it.
    // Otherwise, get a handle to the LogFile.
    //
    //-----------------------
    // AddSourceToRegistry
    //-----------------------
    if (STRICMP (argv[argIndex], TEXT("AddReg")) == 0 ) {

        //
        // Must have at least "AddReg logname EntryName"
        //
        if (argc < (argIndex + 3)) {
            AddRegUsage();
            goto CleanExit;
        }

        status = AddSourceToRegistry(
                    ServerName,
                    argv[argIndex+1],    // LogName
                    argv[argIndex+2],    // SourceName
                    &argv[argIndex+1],
                    argc-(argIndex+2)
                    );
    }
    //-----------------------
    // DeleteFromRegistry
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("DelReg")) == 0) {
        //
        // Must have at least "DelReg logname EntryName"
        //
        if (argc < (argIndex + 3)) {
            goto CleanExit;
        }

        status = DelSourceInRegistry(
                    ServerName,
                    argv[argIndex+1],    // LogName
                    argv[argIndex+2]     // SourceName
                    );

    }
    //-----------------------
    // WriteEvent
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("WriteEvent")) == 0) {
        printf("In WriteEvent\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // ReadLog
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("ReadLog")) == 0) {
        printf("In ReadLog\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
        //
        // Must have at least "ReadLog logname"
        //
        if (argc < (argIndex + 2)) {
            ReadLogUsage();
            goto CleanExit;
        }

        status = ReadLogFile(
                    ServerName,         // ServerName
                    argv[argIndex+1],   // LogName
                    &argv[argIndex+1],  // argv
                    argc-(argIndex+1)); // argc
    }
    //-----------------------
    // GetNumEvents
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("GetNumEvents")) == 0) {
        printf("in GetNumEvents\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // GetOldest
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("GetOldest")) == 0) {
        printf("in GetOldest\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // ClearLog
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("ClearLog")) == 0) {
        printf("in ClearLog\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // Backup
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("Backup")) == 0) {
        printf("in Backup\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // RegisterSource
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("RegisterSource")) == 0) {
        printf("in RegisterSource\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // DeRegisterSource
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("DeRegisterSource")) == 0) {
        printf("in DeRegisterSource\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //****************
    // Exit Program
    //****************
    else if (STRICMP (argv[0], TEXT("Exit")) == 0) {
        //
        // THIS SHOULD CLOSE HANDLES.
        //
        return(FALSE);
    }
    else {
        printf("Bad argument\n");
        Usage();
    }

CleanExit:


    return(TRUE);
}



BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   i;

    //
    // ScConvertToUnicode allocates storage for each string.
    // We will rely on process termination to free the memory.
    //
    for(i=0; i<argc; i++) {

        if(!ConvertToUnicode( (LPWSTR *)&(argv[i]), argv[i])) {
            printf("Couldn't convert argv[%d] to unicode\n",i);
            return(FALSE);
        }


    }
    return(TRUE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT)bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                (BOOLEAN)FALSE);    // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}

/****************************************************************************/
VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSERVICE_STATUS    ServiceStatus
    )

/*++

Routine Description:

    Displays the service name and  the service status.

    |
    |SERVICE_NAME: messenger
    |DISPLAY_NAME: messenger
    |        TYPE       : WIN32
    |        STATE      : ACTIVE,STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN
    |        EXIT_CODE  : 0xC002001
    |        CHECKPOINT : 0x00000001
    |        WAIT_HINT  : 0x00003f21
    |

Arguments:

    ServiceName - This is a pointer to a string containing the name of
        the service.

    DisplayName - This is a pointer to a string containing the display
        name for the service.

    ServiceStatus - This is a pointer to a SERVICE_STATUS structure from
        which information is to be displayed.

Return Value:

    none.

--*/
{

    printf("\nSERVICE_NAME: "FORMAT_LPTSTR"\n", ServiceName);
    if (DisplayName != NULL) {
        printf("DISPLAY_NAME: "FORMAT_LPTSTR"\n", DisplayName);
    }

    printf("        TYPE               : %lx  ", ServiceStatus->dwServiceType);

    switch(ServiceStatus->dwServiceType){
    case SERVICE_WIN32_OWN_PROCESS:
        printf("WIN32_OWN_PROCESS \n");
        break;
    case SERVICE_WIN32_SHARE_PROCESS:
        printf("WIN32_SHARE_PROCESS \n");
        break;
    case SERVICE_WIN32:
        printf("WIN32 \n");
        break;
    case SERVICE_ADAPTER:
        printf("ADAPTER \n");
        break;
    case SERVICE_KERNEL_DRIVER:
        printf("KERNEL_DRIVER \n");
        break;
    case SERVICE_FILE_SYSTEM_DRIVER:
        printf("FILE_SYSTEM_DRIVER \n");
        break;
    case SERVICE_DRIVER:
        printf("DRIVER \n");
        break;
    default:
        printf(" ERROR \n");
    }

    printf("        STATE              : %lx  ", ServiceStatus->dwCurrentState);

    switch(ServiceStatus->dwCurrentState){
        case SERVICE_STOPPED:
            printf("STOPPED ");
            break;
        case SERVICE_START_PENDING:
            printf("START_PENDING ");
            break;
        case SERVICE_STOP_PENDING:
            printf("STOP_PENDING ");
            break;
        case SERVICE_RUNNING:
            printf("RUNNING ");
            break;
        case SERVICE_CONTINUE_PENDING:
            printf("CONTINUE_PENDING ");
            break;
        case SERVICE_PAUSE_PENDING:
            printf("PAUSE_PENDING ");
            break;
        case SERVICE_PAUSED:
            printf("PAUSED ");
            break;
        default:
            printf(" ERROR ");
    }

    //
    // Print Controls Accepted Information
    //

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP) {
        printf("\n                                (STOPPABLE,");
    }
    else {
        printf("\n                                (NOT_STOPPABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) {
        printf("PAUSABLE,");
    }
    else {
        printf("NOT_PAUSABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) {
        printf("ACCEPTS_SHUTDOWN)\n");
    }
    else {
        printf("IGNORES_SHUTDOWN)\n");
    }

    //
    // Print Exit Code
    //
    printf("        WIN32_EXIT_CODE    : %d\t(0x%lx)\n",
        ServiceStatus->dwWin32ExitCode,
        ServiceStatus->dwWin32ExitCode);
    printf("        SERVICE_EXIT_CODE  : %d\t(0x%lx)\n",
        ServiceStatus->dwServiceSpecificExitCode,
        ServiceStatus->dwServiceSpecificExitCode  );

    //
    // Print CheckPoint & WaitHint Information
    //

    printf("        CHECKPOINT         : 0x%lx\n", ServiceStatus->dwCheckPoint);
    printf("        WAIT_HINT          : 0x%lx\n", ServiceStatus->dwWaitHint  );

    return;
}

VOID
Usage(
    VOID)
{
    printf("DESCRIPTION:\n");
    printf("\tEL is a command line program used for testing the eventlog \n");
    printf("USAGE:\n");
    printf("\tEL <ServerName> [Function] <FunctionOptions...> \n\n");
    printf("\tThe option <server> has the form \"\\\\ServerName\"\n");
    printf("\tFurther help on Functions can be obtained by typing: \"el [Function]\"\n");
    printf("\tFunctions:\n"
           "\t  AddReg-----------Creates a registry entry for an event source.\n"
           "\t  DelReg-----------Deletes a registry entry.\n"
           "\t  WriteEvent-------Writes an event.\n"
           "\t  ReadLog----------Reads from the logfile.\n"
           "\t  GetNumEvents-----Gets the number of events in the specified log.\n"
           "\t  GetOldest--------Gets the record number for the oldest record"
           "\t                   in the log\n"
           "\t  ClearLog---------Clears the specified Log.\n"
           "\t  Backup-----------Copies the specified log to a new file.\n"
           "\t  RegisterSource---Registers a name for the event source.\n"
           "\t                   The handle is stored internally.\n"
           "\t  DeRegisterSource-Closes handle opened with RegSource.\n"
           "\t  NotifyChange-----A thread is created which gets notified of EL changes.\n");

    printf("\n");
}

VOID
AddRegUsage(VOID)
{

    printf("\nAdds a subkey under one of the logfiles listed in the registry.\n");
    printf("SYNTAX: \n  eltest addreg <ServerName> logfile <SubKeyName> <option1> <option2>...\n");
    printf("ADDREG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n");

    printf("    MsgFile=    Name of Event Message File\n"
           "    CatFile=    Name of Category Message File\n"
           "    ParamFile=  Name of Parameter Message File\n"
           "    CatCount=   Category Count\n"
           "    Type=       <error|warning|information|AuditSuccess|AuditFailure|All>\n");
    printf("EXAMPLE:\n   eltest addreg application myapp MsgFile= MyMsgs.dll"
           " Type= error Type= warning\n");

}

VOID
ConfigUsage(VOID)
{
    printf("Modifies a service entry in the registry and Service Database.\n");
    printf("SYNTAX: \nsc config <service> <option1> <option2>...\n");
    printf("CONFIG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n"
        " type= <own|share|kernel|filesys|rec|adapt|error>\n"
        " start= <boot|system|auto|demand|disabled|error>\n"
        " error= <normal|severe|critical|error|ignore>\n"
        " binPath= <BinaryPathName>\n"
        " group= <LoadOrderGroup>\n"
        " tag= <yes|no>\n"
        " depend= <Dependencies(space seperated)>\n"
        " obj= <AccountName|ObjectName>\n"
        " DisplayName= <display name>\n"
        " password= <password> \n");
}
VOID
CreateUsage(VOID)
{
    printf("Creates a service entry in the registry and Service Database.\n");
    printf("SYNTAX: \nsc create <service> <option1> <option2>...\n");
    printf("CREATE OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n"
        " type= <own|share|kernel|filesys|rec|error>\n"
        " start= <boot|system|auto|demand|disabled|error>\n"
        " error= <normal|severe|critical|error|ignore>\n"
        " binPath= <BinaryPathName>\n"
        " group= <LoadOrderGroup>\n"
        " tag= <yes|no>\n"
        " depend= <Dependencies(space seperated)>\n"
        " obj= <AccountName|ObjectName>\n"
        " DisplayName= <display name>\n"
        " password= <password> \n");
}

VOID
ReadLogUsage(VOID)
{

    printf("\nReads a logfile and dumps the contents.\n");
    printf("SYNTAX: \n  eltest readlog <ServerName> logfile <option1> <option2>...\n");
    printf("READLOG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n");

    printf("    ReadFlag=  <fwd|back|seek|seq> (default = fwd) \n"
           "    RecordNum=  record number where read should start (default=0)\n"
           "    BufSize=    size of the buffer (default = 10000)\n");
    printf("EXAMPLE:\n   eltest addreg application myapp MsgFile= MyMsgs.dll"
           " Type= error Type= warning\n");
}

DWORD
AddSourceToRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    )

/*++

Routine Description:

    This function writes to the registry all the information to register
    this application as an event source.

Arguments:


Return Value:


--*/
{
    TCHAR   tempName[MAX_PATH];
    HKEY    hKey;
    DWORD   dwStatus=NO_ERROR;
    HKEY    hRegistry=HKEY_LOCAL_MACHINE;

    LPTSTR  EventMessageFile=NULL;
    LPTSTR  CategoryMessageFile=NULL;
    LPTSTR  ParameterMessageFile=NULL;
    DWORD   dwTypes=0;
    DWORD   dwCategoryCount=0;
    DWORD   i;

    //
    // Look at the LogName, and generate the appropriate registry key
    // path for that log.
    //
    if (STRICMP(LogName, ApplLogName) == 0) {
        STRCPY(tempName, ApplLogRegName);
    }
    else if (STRICMP(LogName, SysLogName) == 0) {
        STRCPY(tempName, SysLogRegName);
    }
    else if (STRICMP(LogName, SecLogName) == 0) {
        STRCPY(tempName, SecLogRegName);
    }
    else {
        printf("AddSourceToRegistry: Invalid LogName\n");
        return(ERROR_INVALID_PARAMETER);
    }
    STRCAT(tempName, EventSourceName);


    //
    // Get Variable Arguments
    //
    for (i=0; i<argc ;i++ ) {
        if (STRICMP(argv[i], TEXT("EventMsgFile=")) == 0) {
            EventMessageFile = argv[i+1];
            i++;
        }
        if (STRICMP(argv[i], TEXT("CategoryMsgFile=")) == 0) {
            CategoryMessageFile = argv[i+1];
            i++;
        }
        if (STRICMP(argv[i], TEXT("ParameterMsgFile=")) == 0) {
            ParameterMessageFile = argv[i+1];
            i++;
        }
        if (STRICMP(argv[i], TEXT("Type=")) == 0) {
            //--------------------------------------------------------
            // We want to allow for several arguments of type= in the
            // same line.  These should cause the different arguments
            // to be or'd together.
            //--------------------------------------------------------
            if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwTypes |= EVENTLOG_ERROR_TYPE;
            }
            if (STRICMP(argv[i+1],TEXT("warning")) == 0) {
                dwTypes |= EVENTLOG_WARNING_TYPE;
            }
            if (STRICMP(argv[i+1],TEXT("information")) == 0) {
                dwTypes |= EVENTLOG_INFORMATION_TYPE;
            }
            if (STRICMP(argv[i+1],TEXT("AuditSuccess")) == 0) {
                dwTypes |= EVENTLOG_AUDIT_SUCCESS;
            }
            if (STRICMP(argv[i+1],TEXT("AuditFailure")) == 0) {
                dwTypes |= EVENTLOG_AUDIT_FAILURE;
            }
            if (STRICMP(argv[i+1],TEXT("All")) == 0) {
                dwTypes |= (EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
                            EVENTLOG_INFORMATION_TYPE | EVENTLOG_AUDIT_SUCCESS |
                            EVENTLOG_AUDIT_FAILURE);
            }
            else {
                printf("Invalid Type\n");
                AddRegUsage();
                return(ERROR_INVALID_PARAMETER);
            }
            i++;
        }
        if (STRICMP(argv[i], TEXT("CategoryCount=")) == 0) {
            dwCategoryCount = ATOL(argv[i+1]);
            i++;
        }

    }

    //
    // Connect to the registry on the correct machine.
    //
    printf("Connect to Registry\n");
    dwStatus = RegConnectRegistry(ServerName, HKEY_LOCAL_MACHINE, &hRegistry);
    if (dwStatus != NO_ERROR) {
        printf("RegConnectRegistry Failed %d\n",GetLastError());
        return(dwStatus);
    }

    //
    // Create the new key for this source
    //
    printf("Create Key\n");
    dwStatus = RegCreateKey(hRegistry, tempName, &hKey);
    if (dwStatus != ERROR_SUCCESS) {
        printf("Couldn't create Source Key in registry %d\n",dwStatus);
        return(dwStatus);
    }
    if (EventMessageFile != NULL) {
        printf("Set EventMessageFile\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_EVENT_MF,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)EventMessageFile,
                STRLEN(EventMessageFile) + sizeof(TCHAR));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (messageFile) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }
    //
    // Set the Category Message File
    //
    if (CategoryMessageFile != NULL) {
        printf("Set Category Message File\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_CATEGORY_MF,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)CategoryMessageFile,
                STRLEN(CategoryMessageFile) + sizeof(TCHAR));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (category mf) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }

    //
    // Set the Parameter Message File
    //
    if (ParameterMessageFile != NULL) {
        printf("Set Parameter Message File\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_PARAMETER_MF,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)ParameterMessageFile,
                STRLEN(ParameterMessageFile) + sizeof(TCHAR));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (Parameter mf) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }

    //
    // Set the Types Supported
    //
    if (dwTypes != 0) {
        printf("Set Types Supported\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_TYPES_SUPPORTED,
                0,
                REG_DWORD,
                (LPBYTE) &dwTypes,
                sizeof(DWORD));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (TypesSupported) failed %d\n",GetLastError());
            goto CleanExit;
        }

    }

    //
    // Set the Category Count
    //
    if (dwCategoryCount != 0) {
        printf("Set CategoryCount\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_CATEGORY_COUNT,
                0,
                REG_DWORD,
                (LPBYTE) &dwCategoryCount,
                sizeof(DWORD));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (CategoryCount) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }
    dwStatus = NO_ERROR;
CleanExit:
    RegCloseKey(hKey);
    RegCloseKey(hRegistry);
    return(dwStatus);
}

DWORD
DelSourceInRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName
    )

/*++

Routine Description:

    This function writes to the registry all the information to register
    this application as an event source.

Arguments:


Return Value:


--*/
{
    LPTSTR  tempName;
    HKEY    hParentKey;
    BOOL    status=FALSE;
    DWORD   dwStatus;
    HKEY    hRegistry=HKEY_LOCAL_MACHINE;


    //
    // Look at the LogName, and generate the appropriate registry key
    // path for that log.
    //
    if (STRICMP(LogName, ApplLogName) == 0) {
        tempName = ApplLogRegName;
    }
    else if (STRICMP(LogName, SysLogName) == 0) {
        tempName = SysLogRegName;
    }
    else if (STRICMP(LogName, SecLogName) == 0) {
        tempName = SecLogRegName;
    }
    else {
        printf("AddSourceToRegistry: Invalid LogName\n");
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Connect to the registry on the correct machine.
    //
    dwStatus = RegConnectRegistry(ServerName, HKEY_LOCAL_MACHINE, &hRegistry);
    if (dwStatus != NO_ERROR) {
        printf("RegConnectRegistry Failed %d\n",GetLastError());
        return(status);
    }

    //
    // Open the Parent Key of the key we want to delete.
    //
    dwStatus = RegOpenKeyEx(
                hRegistry,
                tempName,
                0,
                KEY_ALL_ACCESS,
                &hParentKey);

    if (dwStatus != ERROR_SUCCESS) {
        printf("Couldn't open Parent of key to be deleted. %d\n",dwStatus);
        goto CleanExit;
    }
    //
    // Delete the subkey.
    //
    dwStatus = RegDeleteKey(hParentKey, EventSourceName);
    if (dwStatus != ERROR_SUCCESS) {
        printf("Couldn't delete "FORMAT_LPTSTR" key from registry %d\n",
            EventSourceName, dwStatus);
    }

    RegCloseKey(hParentKey);
CleanExit:
    RegCloseKey(hRegistry);
    return(status);
}

DWORD
ReadLogFile(
    LPTSTR  ServerName,
    LPTSTR  LogName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   dwReadFlag = EVENTLOG_FORWARDS_READ;
    DWORD   dwRecordNum = 0;
    DWORD   BufSize = 10000;
    DWORD   numBytesRead;
    DWORD   numBytesReqd;
    LPVOID  pElBuffer = NULL;
    PEVENTLOGRECORD    pElRecord;
    BOOL    PrintTheHeader;
    DWORD   i;
    HANDLE  hEventLog=NULL;

    //
    // Get Variable Arguments
    //
    for (i=0; i<argc ;i++ ) {
        if (STRICMP(argv[i], TEXT("ReadFlag=")) == 0) {
            if (STRICMP(argv[i+1],TEXT("fwd")) == 0) {
                dwReadFlag |= EVENTLOG_FORWARDS_READ;
            }
            if (STRICMP(argv[i+1],TEXT("back")) == 0) {
                dwReadFlag |= EVENTLOG_BACKWARDS_READ;
            }
            if (STRICMP(argv[i+1],TEXT("seek")) == 0) {
                dwReadFlag |= EVENTLOG_SEEK_READ;
            }
            if (STRICMP(argv[i+1],TEXT("seq")) == 0) {
                dwReadFlag |= EVENTLOG_SEQUENTIAL_READ;
            }
            i++;
        }
        if (STRICMP(argv[i], TEXT("RecordNum=")) == 0) {
            dwRecordNum = ATOL(argv[i+1]);
            i++;
        }
        if (STRICMP(argv[i], TEXT("BufSize=")) == 0) {
            BufSize = ATOL(argv[i+1]);
            i++;
        }
        hEventLog = OpenEventLog(ServerName,LogName);
        if (hEventLog == NULL) {
            printf("OpenEventLog failed %d\n",GetLastError());
            return(0);
        }
        pElBuffer = LocalAlloc(LPTR, BufSize);
        if (pElBuffer == NULL) {
            printf("ReadLogFile: LocalAlloc Failed %d\n",GetLastError());
            goto CleanExit;
        }

        //---------------------------------------------------------
        // Read and Display the contents of the eventlog
        //---------------------------------------------------------
        PrintTheHeader = TRUE;
TryAgain:
        while(ReadEventLog(
                hEventLog,
                dwReadFlag,
                dwRecordNum,
                pElBuffer,
                BufSize,
                &numBytesRead,
                &numBytesReqd)) {

            pElRecord = (PEVENTLOGRECORD) pElBuffer;
            while ((PBYTE) pElRecord < (PBYTE) pElBuffer + numBytesRead) {
                //
                // Print the record to the display
                //
                DisplayRecord(pElRecord,PrintTheHeader);
                PrintTheHeader = FALSE;
                //
                // Move to the next event in the buffer
                //
                pElRecord = (PEVENTLOGRECORD)((PBYTE) pElRecord +
                    pElRecord->Length);
            }
        }
        switch(GetLastError()) {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // Increase the size of the buffer and try again
            //
            if (numBytesReqd > BufSize) {
                LocalFree(pElBuffer);
                BufSize = numBytesReqd;
                pElBuffer = LocalAlloc(LPTR, BufSize);
                if (!pElBuffer) {
                    printf("ReadLogFile: LocalAlloc Failed %d\n",GetLastError());
                }
                goto TryAgain;
            }
            else {
                printf("ReadLogFile #1: THIS SHOULD NEVER HAPPEN\n");
            }
            break;
        case ERROR_EVENTLOG_FILE_CHANGED:
            //
            // The current read position for this handle has been overwritten.
            // Reopen the file and print a message to the effect that some
            // records may have been missed.
            //
            printf("ReadLogFile: Current Read position has been overwritten\n");

            hEventLog = OpenEventLog(ServerName,LogName);
            if (hEventLog == NULL) {
                printf("OpenEventLog failed %d\n",GetLastError());
                goto CleanExit;
            }
            goto TryAgain;
        case ERROR_HANDLE_EOF:
            printf("EOF\n");
            break;
        default:
            printf("UnknownError: %d\n",GetLastError());
            break;
        }
    }
CleanExit:
    if (pElBuffer != NULL) {
        LocalFree(pElBuffer);
    }
    if (hEventLog != NULL) {
        CloseEventLog(hEventLog);
    }
    return(0);
}

VOID
DisplayRecord(
    PEVENTLOGRECORD     pElRecord,
    BOOL                PrintTheHeader
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    if (PrintTheHeader) {
        printf("RecNum/tTimeGen/tWriteTime/tEventID/tType/tNumStr/tCat/n");
    }
    printf("%d/t%d/t%d/t%d/t%d/t%d/t%d\n",
        pElRecord->RecordNumber,
        pElRecord->TimeGenerated,
        pElRecord->TimeWritten,
        pElRecord->EventID,
        pElRecord->EventType,
        pElRecord->NumStrings,
        pElRecord->EventCategory);
}

LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  &&
            (*string >= L'0') &&
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\control.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CONTROL.C

Abstract:

    This file contains the control handler for the eventlog service.

Author:

    Rajen Shah  (rajens)    16-Jul-1991

Revision History:


--*/

//
// INCLUDES
//

#include <eventp.h>
#include <msaudite.h>
//
// DEFINITIONS
//

//
// Controls accepted by the service
//
#define     ELF_CONTROLS_ACCEPTED           SERVICE_ACCEPT_SHUTDOWN;


//
// GLOBALS
//

    CRITICAL_SECTION StatusCriticalSection = {0};
    SERVICE_STATUS   ElStatus              = {0};
    DWORD            HintCount             = 0;
    DWORD            ElUninstallCode       = 0;  // reason for uninstalling
    DWORD            ElSpecificCode        = 0;
    DWORD            ElState               = STARTING;

//
//  Generate Event with Noon Event Inforamtion.
//
VOID
ElfWriteNoonEvent(
    TIMESTAMPEVENT  EventType,
    ULONG           ulTimeStampInterval
    );


VOID
ElfControlResponse(
    DWORD   opCode
    )

{
    DWORD   state;

    ELF_LOG1(TRACE,
             "ElfControlResponse: Received control %d\n",
             opCode);

    //
    // Determine the type of service control message and modify the
    // service status, if necessary.
    //
    switch(opCode)
    {
        case SERVICE_CONTROL_SHUTDOWN:
        {
            HKEY    hKey;
            ULONG   ValueSize;
            ULONG   ShutdownReason = 0xFF;
            ULONG   rc;

            //
            // If the service is installed, shut it down and exit.
            //

            ElfStatusUpdate(STOPPING);

            GetGlobalResource (ELF_GLOBAL_EXCLUSIVE);
            
            //
            // Cause the timestamp writing thread to exit
            //

            if (g_hTimestampEvent != NULL)
            {
                SetEvent (g_hTimestampEvent);
            }

            //
            // Indicate a normal shutdown in the registry
            //

            ElfWriteTimeStamp(EVENT_NormalShutdown,
                              FALSE);
#if 0
            //
            // Determine the reason for this normal shutdown
            //

            rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                REGSTR_PATH_RELIABILITY,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

            if (rc == ERROR_SUCCESS)
            {
                ValueSize = sizeof(ULONG);

                rc = RegQueryValueEx(hKey,
                                     REGSTR_VAL_SHUTDOWNREASON,
                                     0,
                                     NULL,
                                     (PUCHAR) &ShutdownReason,
                                     &ValueSize);

                if (rc == ERROR_SUCCESS)
                {
                    RegDeleteValue (hKey, REGSTR_VAL_SHUTDOWNREASON);
                }                                                                  

                RegCloseKey (hKey);
            }
#endif
            //
            // Log an event that says we're stopping
            //
            ElfWriteNoonEvent(EVENT_EventlogStopped,
                                GetNoonEventTimeStamp());

#if 0
            ElfpCreateElfEvent(EVENT_EventlogStopped,
                               EVENTLOG_INFORMATION_TYPE,
                               0,                    // EventCategory
                               0,                    // NumberOfStrings
                               NULL,                 // Strings
                               &ShutdownReason,      // Data
                               sizeof(ULONG),        // Datalength
                               0,                    // flags
                               FALSE);               // for security file    
#endif

            ElfpCreateElfEvent(SE_AUDITID_SYSTEM_SHUTDOWN,
                               EVENTLOG_AUDIT_SUCCESS,
                               SE_CATEGID_SYSTEM,                    // EventCategory
                               0,                    // NumberOfStrings
                               NULL,                 // Strings
                               NULL,      // Data
                               0,        // Datalength
                               0,                    // flags
                               TRUE);               // for security file    

            //
            // Now force it to be written before we shut down
            //
            WriteQueuedEvents();

            ReleaseGlobalResource();

            //
            // If the RegistryMonitor is started, wakeup that
            // worker thread and have it handle the rest of the
            // shutdown.
            //
            // Otherwise The main thread should pick up the
            // fact that a shutdown during startup is occuring.
            //
            if (EventFlags & ELF_STARTED_REGISTRY_MONITOR)
            {
                StopRegistryMonitor();
            }

            break ;
        }

        case SERVICE_CONTROL_INTERROGATE:

            ElfStatusUpdate(UPDATE_ONLY);
            break;

        default:

            //
            // This should never happen.
            //
            ELF_LOG1(ERROR,
                     "ElfControlResponse: Received unexpected control %d\n",
                     opCode);

            ASSERT(FALSE);
            break ;
    }

    return;
}


DWORD
ElfBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    ExitCode,
    IN DWORD    ServiceSpecificCode
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD  status;

    EnterCriticalSection(&StatusCriticalSection);

    ELF_LOG2(ERROR,
             "ElfBeginForcedShutdown: error %d, service-specific error %d\n",
             ExitCode,
             ServiceSpecificCode);

    //
    // See if the eventlog is already stopping for some reason.
    // It could be that the ControlHandler thread received a control to
    // stop the eventlog just as we decided to stop ourselves.
    //
    if ((ElState != STOPPING) && (ElState != STOPPED))
    {
        if (PendingCode == PENDING)
        {
            ELF_LOG0(TRACE,
                     "ElfBeginForcedShutdown: Starting pending shutdown\n");

            ElStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ElState = STOPPING;
        }
        else
        {
            //
            // The shutdown is to take immediate effect.
            //
            ELF_LOG0(TRACE,
                     "ElfBeginForcedShutdown: Starting immediate shutdown\n");

            ElStatus.dwCurrentState = SERVICE_STOPPED;
            ElStatus.dwControlsAccepted = 0;
            ElStatus.dwCheckPoint = 0;
            ElStatus.dwWaitHint = 0;
            ElState = STOPPED;
        }

        ElUninstallCode = ExitCode;
        ElSpecificCode = ServiceSpecificCode;

        ElStatus.dwWin32ExitCode = ExitCode;
        ElStatus.dwServiceSpecificExitCode = ServiceSpecificCode;
    }

    //
    // Cause the timestamp writing thread to exit
    //

    if (g_hTimestampEvent != NULL)
    {
        SetEvent (g_hTimestampEvent);
    }

    //
    // Send the new status to the service controller.
    //

    ASSERT(ElfServiceStatusHandle != 0);

    if (!SetServiceStatus( ElfServiceStatusHandle, &ElStatus ))
    {
        ELF_LOG1(ERROR,
                 "ElfBeginForcedShutdown: SetServicestatus failed %d\n",
                 GetLastError());
    }

    status = ElState;

    ELF_LOG1(TRACE,
             "ElfBeginForcedShutdown: New state is %d\n",
             status);

    LeaveCriticalSection(&StatusCriticalSection);
    return status;
}


DWORD
ElfStatusUpdate(
    IN DWORD    NewState
    )

/*++

Routine Description:

    Sends a status to the Service Controller via SetServiceStatus.

    The contents of the status message is controlled by this routine.
    The caller simply passes in the desired state, and this routine does
    the rest.  For instance, if the Eventlog passes in a STARTING state,
    This routine will update the hint count that it maintains, and send
    the appropriate information in the SetServiceStatus call.

    This routine uses transitions in state to determine which status
    to send.  For instance if the status was STARTING, and has changed
    to RUNNING, this routine sends SERVICE_RUNNING to the Service
    Controller.

Arguments:

    NewState - Can be any of the state flags:
                UPDATE_ONLY - Simply send out the current status
                STARTING    - The Eventlog is in the process of initializing
                RUNNING     - The Eventlog has finished with initialization
                STOPPING    - The Eventlog is in the process of shutting down
                STOPPED     - The Eventlog has completed the shutdown.

Return Value:

    CurrentState - This may not be the same as the NewState that was
        passed in.  It could be that the main thread is sending in a new
        install state just after the Control Handler set the state to
        STOPPING.  In this case, the STOPPING state will be returned so as
        to inform the main thread that a shut-down is in process.

--*/

{
    DWORD       status;
    BOOL        inhibit = FALSE;    // Used to inhibit sending the status
                                    // to the service controller.

    EnterCriticalSection(&StatusCriticalSection);

    ELF_LOG2(TRACE,
             "ElfStatusUpdate: old state = %d, new state = %d\n",
             ElState,
             NewState);

    if (NewState == STOPPED)
    {
        if (ElState == STOPPED)
        {
            //
            // It was already stopped, don't send another SetServiceStatus.
            //
            inhibit = TRUE;
        }
        else
        {
            //
            // The shut down is complete, indicate that the eventlog
            // has stopped.
            //
            ElStatus.dwCurrentState =  SERVICE_STOPPED;
            ElStatus.dwControlsAccepted = 0;
            ElStatus.dwCheckPoint = 0;
            ElStatus.dwWaitHint = 0;

            ElStatus.dwWin32ExitCode = ElUninstallCode;
            ElStatus.dwServiceSpecificExitCode = ElSpecificCode;
        }

        ElState = NewState;
    }
    else if (NewState != UPDATE_ONLY)
    {
        //
        // We are not being asked to change to the STOPPED state.
        //
        switch(ElState)
        {
            case STARTING:

                if (NewState == STOPPING)
                {
                    ElStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                    ElStatus.dwControlsAccepted = 0;
                    ElStatus.dwCheckPoint = HintCount++;
                    ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                    ElState = NewState;

                    EventlogShutdown = TRUE;
                }
                else if (NewState == RUNNING)
                {
                    //
                    // The Eventlog Service has completed installation.
                    //
                    ElStatus.dwCurrentState =  SERVICE_RUNNING;
                    ElStatus.dwCheckPoint = 0;
                    ElStatus.dwWaitHint = 0;

                    ElStatus.dwControlsAccepted = ELF_CONTROLS_ACCEPTED;
                    ElState = NewState;
                }
                else
                {
                    //
                    // The NewState must be STARTING.  So update the pending
                    // count
                    //

                    ElStatus.dwCurrentState =  SERVICE_START_PENDING;
                    ElStatus.dwControlsAccepted = 0;
                    ElStatus.dwCheckPoint = HintCount++;
                    ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                }

                break;

            case RUNNING:

                if (NewState == STOPPING)
                {
                    ElStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                    ElStatus.dwControlsAccepted = 0;

                    EventlogShutdown = TRUE;
                }

                ElStatus.dwCheckPoint = HintCount++;
                ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                ElState = NewState;

                break;

            case STOPPING:

                //
                // No matter what else was passed in, force the status to
                // indicate that a shutdown is pending.
                //
                ElStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                ElStatus.dwControlsAccepted = 0;
                ElStatus.dwCheckPoint = HintCount++;
                ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                EventlogShutdown = TRUE;

                break;

            case STOPPED:

                ASSERT(NewState == STARTING);

                //
                // The Eventlog Service is starting up after being stopped.
                // This can occur if the service is manually started after
                // failing to start.
                //
                ElStatus.dwCurrentState =  SERVICE_START_PENDING;
                ElStatus.dwCheckPoint = 0;
                ElStatus.dwWaitHint = 0;
                ElStatus.dwControlsAccepted = ELF_CONTROLS_ACCEPTED;
                ElState = NewState;

                break;
        }
    }

    if (!inhibit)
    {
        ASSERT(ElfServiceStatusHandle != 0);

        if (!SetServiceStatus(ElfServiceStatusHandle, &ElStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfStatusUpdate: SetServiceStatus failed %d\n",
                     GetLastError());
        }
    }

    status = ElState;

    ELF_LOG1(TRACE,
             "ElfStatusUpdate: Exiting with state = %d\n",
             ElState);

    LeaveCriticalSection(&StatusCriticalSection);

    return status;
}


DWORD
GetElState (
    VOID
    )

/*++

Routine Description:

    Obtains the state of the Eventlog Service.  This state information
    is protected as a critical section such that only one thread can
    modify or read it at a time.

Arguments:

    none

Return Value:

    The Eventlog State is returned as the return value.

--*/
{
    DWORD   status;

    EnterCriticalSection(&StatusCriticalSection);
    status = ElState;
    LeaveCriticalSection(&StatusCriticalSection);

    return status;
}


NTSTATUS
ElfpInitStatus(
    VOID
    )
/*++

Routine Description:

    Initializes the critical section that is used to guard access to the
    status database.

Arguments:

    none

Return Value:

    none

--*/
{
    ElStatus.dwCurrentState = SERVICE_START_PENDING;
    ElStatus.dwServiceType  = SERVICE_WIN32;

    return ElfpInitCriticalSection(&StatusCriticalSection);
}


VOID
ElCleanupStatus(VOID)

/*++

Routine Description:

    Deletes the critical section used to control access to the thread and
    status database.

Arguments:

    none

Return Value:

    none

Note:


--*/
{
    DeleteCriticalSection(&StatusCriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\copy.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This module contains the routine to copy a file.

Author:

    Dan Hinsley (DanHi) 24-Feb-1991

Revision History:

    02-Feb-1994     Danl
        Fixed memory leak where ioBuffer wasn't getting free'd when doing
        an error exit from ElfpCopyFile.

--*/

//
// INCLUDES
//

#include <eventp.h>


NTSTATUS
ElfpCopyFile (
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING TargetFileName
    )

/*++

Routine Description:

    This routine copies or appends from the source file to the target file.
    If the target file already exists, the copy fails.

Arguments:

    SourceHandle - An open handle to the source file.

    TargetFileName - The name of the file to copy to.


Return Value:

    NTSTATUS - STATUS_SUCCESS or error.

--*/

{
    NTSTATUS Status;

    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION sourceStandardInfo;

    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE TargetHandle;

    PCHAR ioBuffer;
    ULONG ioBufferSize;
    ULONG bytesRead;

    //
    // Get the size of the file so we can set the attributes of the target
    // file.
    //
    Status = NtQueryInformationFile(
                 SourceHandle,
                 &IoStatusBlock,
                 &sourceStandardInfo,
                 sizeof(sourceStandardInfo),
                 FileStandardInformation
                 );

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpCopyFile: Unable to query size of source file %#x\n",
                 Status);

        return Status;
    }

    //
    // Open the target file, fail if the file already exists.
    //

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    TargetFileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

    Status = NtCreateFile(&TargetHandle,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          &(sourceStandardInfo.EndOfFile),
                          FILE_ATTRIBUTE_NORMAL,
                          0,                       // Share access
                          FILE_CREATE,
                          FILE_SYNCHRONOUS_IO_ALERT | FILE_SEQUENTIAL_ONLY,
                          NULL,                    // EA buffer
                          0);                      // EA length

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfpCopyFile: NtCreateFile of file %ws failed %#x\n",
                 TargetFileName->Buffer,
                 Status);

        return Status;
    }

    //
    // Allocate a buffer to use for the data copy.
    //
    ioBufferSize = 4096;

    ioBuffer = ElfpAllocateBuffer (ioBufferSize);

    if (ioBuffer == NULL)
    {
        ELF_LOG1(ERROR,
                 "ElfpCopyFile: Unable to allocate I/O buffer to copy file %ws\n",
                 TargetFileName->Buffer);

        NtClose(TargetHandle);
        return STATUS_NO_MEMORY;
    }

    //
    // Copy data--read from source, write to target.  Do this until
    // all the data is written or an error occurs.
    //
    while ( TRUE )
    {
        Status = NtReadFile(
                         SourceHandle,
                         NULL,                // Event
                         NULL,                // ApcRoutine
                         NULL,                // ApcContext
                         &IoStatusBlock,
                         ioBuffer,
                         ioBufferSize,
                         NULL,                // ByteOffset
                         NULL);               // Key

        if (!NT_SUCCESS(Status) && Status != STATUS_END_OF_FILE)
        {
            ELF_LOG1(ERROR,
                     "ElfpCopyFile: NtReadFile of source file failed %#x\n",
                     Status);

            ElfpFreeBuffer(ioBuffer);
            NtClose(TargetHandle);
            return Status;
        }

        if (IoStatusBlock.Information == 0 || Status == STATUS_END_OF_FILE)
        {
            break;
        }

        bytesRead = (ULONG)IoStatusBlock.Information;

        Status = NtWriteFile(
                          TargetHandle,
                          NULL,               // Event
                          NULL,               // ApcRoutine
                          NULL,               // ApcContext
                          &IoStatusBlock,
                          ioBuffer,
                          bytesRead,
                          NULL,               // ByteOffset
                          NULL);              // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpCopyFile: NtWriteFile to file %ws failed %#x\n",
                     TargetFileName->Buffer,
                     Status);

            ElfpFreeBuffer(ioBuffer);
            NtClose(TargetHandle);
            return Status;
        }
    }

    ElfpFreeBuffer (ioBuffer);

    Status = NtClose(TargetHandle);

    ASSERT(NT_SUCCESS(Status));

    return STATUS_SUCCESS;

} // ElfpCopyFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfcfg.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfcfg.h

Abstract:

    This file contains default settings for the eventlog service.

Author:

    Rajen Shah (rajens) 16-Aug-1991

Revision History:

--*/

#ifndef _EVENTDEFAULTS_
#define _EVENTDEFAULTS_

//
// Default for the Application log file
//
//

#define     ELF_DEFAULT_MODULE_NAME           ELF_APPLICATION_MODULE_NAME
#define     ELF_APPLICATION_DEFAULT_LOG_FILE  L"%SystemRoot%\\system32\\config\\appevent.evt"
#define     ELF_SYSTEM_DEFAULT_LOG_FILE       L"%SystemRoot%\\system32\\config\\sysevent.evt"
#define     ELF_SECURITY_DEFAULT_LOG_FILE     L"%SystemRoot%\\system32\\config\\secevent.evt"
#define     ELF_DEFAULT_MAX_FILE_SIZE         512*1024
#define     ELF_DEFAULT_RETENTION_PERIOD      7*24*3600
#define     ELF_DEFAULT_WARNING_LEVEL         0
#define     ELF_DEFAULT_AUTOBACKUP         0

#define     ELF_GUEST_ACCESS_UNRESTRICTED     0
#define     ELF_GUEST_ACCESS_RESTRICTED       1

//
// Default title for the "log full" message box
//
#define     ELF_DEFAULT_MESSAGE_BOX_TITLE     L"Eventlog Service"

//
// Maximum size for the buffer that will read the key values from the
// registry.
//

#define     ELF_MAX_REG_KEY_INFO_SIZE         200

//
// String defines for the pre-defined nodes in the registry
// These are used to get to the appropriate nodes.
//

#define     REG_EVENTLOG_NODE_PATH  \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Eventlog"

#define REGSTR_VAL_AUTOBACKUPLOGFILES  L"AutoBackupLogFiles"

#define     REG_COMPUTERNAME_NODE_PATH  \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"

//SS: start of changes for replicated event logging across the cluster
#define     REG_CLUSSVC_NODE_PATH  \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ClusSvc"

//SS: end of changes for replicated event logging across the cluster

//
// String defines for the values for each of the configured pieces of
// information in the eventlog\logfiles node.  These exist per logfile.
//
//

#define     VALUE_FILENAME              L"File"
#define     VALUE_MAXSIZE               L"Maxsize"
#define     VALUE_RETENTION             L"Retention"
#define     VALUE_RESTRICT_GUEST_ACCESS L"RestrictGuestAccess"
#define     VALUE_LOGPOPUP              L"LogFullPopup"
#define     VALUE_DEBUG                 L"ElfDebugLevel"
#define     VALUE_COMPUTERNAME          L"ComputerName"
#define     VALUE_WARNINGLEVEL          L"WarningLevel"
#define     VALUE_CUSTOM_SD             L"CustomSD"

#if defined(_WIN64)
#define ALIGN_UP_64(x,t) (((x) + (t) - 1) & ~((t)-1))
#else
#define ALIGN_UP_64(x,t) (x)
#endif


#endif // ifndef _EVENTDEFAULTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfdef.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfdef.h

Abstract:

    This file contains defines for the eventlog service.

Author:

    Rajen Shah (rajens) 1-Jul-1991

Revision History:

--*/

#ifndef _EVENTDEF_
#define _EVENTDEF_

//
// Logfile object specific access type
//
#define ELF_LOGFILE_READ             0x0001
#define ELF_LOGFILE_WRITE            0x0002
#define ELF_LOGFILE_CLEAR            0x0004
#define ELF_LOGFILE_BACKUP           0x0020     // Set iff a backup operator
                                                // opens the security log -
                                                // this overrides all other
                                                // flags.

#define ELF_LOGFILE_ALL_ACCESS       (STANDARD_RIGHTS_REQUIRED       | \
                                         ELF_LOGFILE_READ            | \
                                         ELF_LOGFILE_WRITE           | \
                                         ELF_LOGFILE_CLEAR)

//
// Three types of logfiles are defined from a security perspective:
//
//    ELF_LOGFILE_SECURITY    - Only Admins/LocalSystem can RW these files
//    ELF_LOGFILE_SYSTEM      - Only Admins/LocalSystem can W these files
//    ELF_LOGFILE_APPLICATION - interactive can R/W these files
//    ELF_LOGFILE_CUSTOM      - normally same as application,  but can be SDDL string
//
// System and Security will be SECURE, Application will be NON_SECURE
//

#define ELF_LOGFILE_SECURITY      0x0000
#define ELF_LOGFILE_SYSTEM        0x0001
#define ELF_LOGFILE_APPLICATION   0x0002
#define ELF_LOGFILE_CUSTOM        0x0003

//
// Macro to convert a given file size into one that is "acceptable" for
// eventlogging. It basically truncates it to a 64K boundary making sure
// that it is as least 64K
//

#define     ELFFILESIZE(x) ((x & 0xFFFF0000) ? (x & 0xFFFF0000) : 65536)

//
// The largest possible buffer we would need to hold an admin alert
// information. This primarily depends on the number and length of the
// replacement strings that would be passed with the message ID.
//

#define     ELF_ADMIN_ALERT_BUFFER_SIZE     256

//
// Timeout defines.
//

#define     INFINITE_WAIT_TIME          -1      // Wait time for events
#define     ELF_GLOBAL_RESOURCE_WAIT    2000    // 2-second timeout for global resource

//
// Signature placed before each event record in a file. Is used to
// validate where we are in a file.
//

#define     ELF_RECORD_SIGNATURE    0x654c6652 // ASCII for eLfR

//
// Size by which to grow a log file until it reaches the max size
//

#define     ELF_DEFAULT_LOG_SIZE 65536

//
// Bits for whether to take the global resource exclusively or shared.
//

#define     ELF_GLOBAL_SHARED       0x0001
#define     ELF_GLOBAL_EXCLUSIVE    0x0002

//
// Flag bits to keep track of what resources have been allocated at INIT time
//

#define     ELF_INIT_LOGHANDLE_CRIT_SEC       0x0001
#define     ELF_INIT_GLOBAL_RESOURCE          0x0002
#define     ELF_STARTED_LPC_THREAD            0x0004
#define     ELF_STARTED_REGISTRY_MONITOR      0x0008
#define     ELF_STARTED_RPC_SERVER            0x0010
#define     ELF_INIT_LOGFILE_CRIT_SEC         0x0020
#define     ELF_INIT_LOGMODULE_CRIT_SEC       0x0040
#define     ELF_INIT_WELL_KNOWN_SIDS          0x0080
#define     ELF_INIT_QUEUED_EVENT_CRIT_SEC    0x0100
#define     ELF_INIT_QUEUED_MESSAGE_CRIT_SEC  0x0200
#define     ELF_INIT_CLUS_CRIT_SEC            0x0400

//
// Enumeration and macro to keep track of the "log full" popup per log
//

#define     IS_WORKSTATION()        (USER_SHARED_DATA->NtProductType == NtProductWinNt)

typedef enum
{
    LOGPOPUP_NEVER_SHOW = 0,         // Never show it for this log (e.g., Security)
    LOGPOPUP_CLEARED,                // Show it when this log fills up
    LOGPOPUP_ALREADY_SHOWN           // Don't show it again until this log is cleared
}
LOGPOPUP, *PLOGPOPUP;


//
// Structure containing information on each log file
//
// ActualMaxFileSize and ConfigMaxFileSize are stored in BYTEs.
// ActualMaxFileSize is the actual size of the file on the disk.
// ConfigMaxFileSize is the configured size of the file, which may not
// be the same as the actual size of the file.
//
// CurrentRecordNumber is the next absolute record number to write
//
// OldestRecordNumber is the next one to get overwritten
//
// Retention time is stored as the number of seconds.
//
// BaseAddress points to the physical beginning of the file.
//
// ViewSize is ALWAYS the size of the file in bytes.
//
// For the Flag bits, see the ELF_LOGFILE_HEADER_xxxx bits defined below.
//

typedef struct _LOGFILE {
    LIST_ENTRY      FileList;
    LIST_ENTRY      Notifiees;          // List of ChangeNotify recipients
    PUNICODE_STRING LogFileName;        // Full path name of log file
    PUNICODE_STRING LogModuleName;      // Name of default module for this log
    ULONG           RefCount;           // Number of modules using this file
    ULONG           Flags;              // Autowrap, dirty, etc. - See bits below
    ULONG           ConfigMaxFileSize;  // Max it can be
    ULONG           ActualMaxFileSize;  // How big it is now
    ULONG           NextClearMaxFileSize; // Can't be shrunk on the fly
    ULONG           CurrentRecordNumber;// The next one to be created
    ULONG           OldestRecordNumber; // The next one to overwrite
    ULONG           SessionStartRecordNumber; //the first record number logged in this session
    ULONG           Retention;          // Max. Retention time
    ULONG           NextClearRetention; // they shrank the file when they set this
    HANDLE          FileHandle;         // Handle to open file
    HANDLE          SectionHandle;      // Memory mapped section handle
    PVOID           BaseAddress;        // Map view base address
    ULONG           ViewSize;           // Mapped view size
    ULONG           BeginRecord;        // Offset of first log record
    ULONG           EndRecord;          // Offset of byte after last log record
    ULONG           ulLastPulseTime;    // Time this log was last notified of a change
    LOGPOPUP        logpLogPopup;       // "Log full" policy for this log
    PSECURITY_DESCRIPTOR Sd;            // User security object for this log
    RTL_RESOURCE    Resource;
    BOOL              bHosedByClear;
    NTSTATUS      LastStatus;
    BOOL              bFullAlertDone;
    DWORD           AutoBackupLogFiles;
    LPWSTR          pwsCurrCustomSD;
    BOOL            bFailedExpansion;
} LOGFILE, *PLOGFILE;

//
// Structure containing information on each module that is registered to
// log events.
//

typedef struct _LOGMODULE {
    LIST_ENTRY  ModuleList;
    PWSTR       ModuleName;         // Name of module
    ATOM        ModuleAtom;         // Atom identifying this module
    PLOGFILE    LogFile;            // Log file for this module
} LOGMODULE, *PLOGMODULE;

//
// Command codes put in the request packets.
//

#define     ELF_COMMAND_READ         1
#define     ELF_COMMAND_WRITE        2
#define     ELF_COMMAND_CLEAR        3
#define     ELF_COMMAND_BACKUP       4
#define     ELF_COMMAND_WRITE_QUEUED 5

//
// Structures that contain the operation-specific information.
//

typedef struct _WRITE_PKT {
    DWORD       Datasize;           // Size of data in the buffer
    PVOID       Buffer;             // Contains filled event log record
} WRITE_PKT, *PWRITE_PKT;


//
// The following flag bits are used in the READ_PKT Flag field.
//

#define     ELF_IREAD_UNICODE       0x0001
#define     ELF_IREAD_ANSI          0x0002
#define     ELF_LAST_READ_FORWARD   0x0004

typedef struct _READ_PKT {
    ULONG       Flags;              // UNICODE or ANSI
    ULONG       BufferSize;         // Bytes to read
    PVOID       Buffer;             // User's buffer
    ULONG       ReadFlags;          // Sequential? Forwards? Random-access? Backwards?
    ULONG       RecordNumber;       // Where to start the READ
    ULONG       MinimumBytesNeeded; // For return info if buffer too small
    ULONG       LastSeekPos;        // Last seek position in terms of bytes
    ULONG       LastSeekRecord;     // Last seek position in terms of records
    ULONG       BytesRead;          // Bytes read - for return to caller
    ULONG       RecordsRead;
    IELF_HANDLE ContextHandle;    
} READ_PKT, *PREAD_PKT;

typedef struct _CLEAR_PKT {
    PUNICODE_STRING         BackupFileName; // File to back up current log file (or NULL)
} CLEAR_PKT, *PCLEAR_PKT;

typedef struct _BACKUP_PKT {
    PUNICODE_STRING         BackupFileName; // File to back up current log file (or NULL)
} BACKUP_PKT, *PBACKUP_PKT;

//
// Flags used in the ELF_REQUEST_RECORD
//

#define ELF_FORCE_OVERWRITE    0x01  // Ignore retention period for this write

//
// Structure for the packet that contains all the information needed
// to perform the request.
//

typedef struct _ELF_REQUEST_RECORD {
    USHORT      Flags;
    NTSTATUS    Status;             // To return status of operation
    PLOGFILE    LogFile;            // File on which to operate
    PLOGMODULE  Module;             // Information on module
    USHORT      Command;            // Operation to be performed
    union {
        PWRITE_PKT      WritePkt;
        PREAD_PKT       ReadPkt;
        PCLEAR_PKT      ClearPkt;
        PBACKUP_PKT     BackupPkt;
    } Pkt;
} ELF_REQUEST_RECORD, *PELF_REQUEST_RECORD;

typedef 
#ifdef _WIN64
__declspec(align(8))
#endif
struct _ELF_ALERT_RECORD {
    DWORD    TimeOut;
    DWORD    MessageId;
    DWORD    NumberOfStrings;
    // array of UNICODE_STRINGs NumberOfStringsLong
    // each string
} ELF_ALERT_RECORD, * PELF_ALERT_RECORD;

typedef struct _ELF_MESSAGE_RECORD {
    DWORD    MessageId;
    DWORD    NumberOfStrings;
    // UNICODE null terminated strings
} ELF_MESSAGE_RECORD, * PELF_MESSAGE_RECORD;

//
// Record for the linked list of deferred events (these are raised by the
// eventlog service itself for writing once the current operation is complete
//

typedef struct _ELF_QUEUED_EVENT {
    LIST_ENTRY  Next;
    enum _ELF_QUEUED_EVENT_TYPE {
        Event,
        Alert,
        Message
    } Type;
    union _ELF_QUEUED_EVENT_DATA {
        ELF_REQUEST_RECORD Request;
        ELF_ALERT_RECORD Alert;
        ELF_MESSAGE_RECORD Message;
    } Event;
} ELF_QUEUED_EVENT, *PELF_QUEUED_EVENT;

//
// Structure containing information on callers of ElfChangeNotify
//

typedef struct _NOTIFIEE {
    LIST_ENTRY      Next;
    IELF_HANDLE     Handle;
    HANDLE          Event;
} NOTIFIEE, *PNOTIFIEE;


//
// Structure that describes the header that is at the beginning of the
// log files.
//
// To see if there are any records in the file, one must subtract the
// EndOffset from the StartOffset (allowing for the file having wrapped
// around) and check for a difference of greater than 1.
//
// The header size is stored at the beginning and end so that it looks
// just like any other event log record (the lengths do at any rate).
//

typedef struct _ELF_LOGFILE_HEADER {
    ULONG       HeaderSize;             // Size of this header
    ULONG       Signature;              // Signature field
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       StartOffset;            // Where the first record is located
    ULONG       EndOffset;              // The end of the last record + 1
    ULONG       CurrentRecordNumber;    // The next record to create
    ULONG       OldestRecordNumber;     // The next record to overwrite
    ULONG       MaxSize;                // Max. size when file was created
    ULONG       Flags;                  // DIRTY, etc.
    ULONG       Retention;              // Last Retention period.
    ULONG       EndHeaderSize;          // Size of this header
} ELF_LOGFILE_HEADER, *PELF_LOGFILE_HEADER;

#define     FILEHEADERBUFSIZE       sizeof(ELF_LOGFILE_HEADER)
#define     ELF_LOG_FILE_SIGNATURE  0x654c664c  // ASCII for eLfL

//
// The following flag bits are used in ELF_LOGFILE_HEADER and in the
// LOGFILE structures' Flag fields.
//

#define     ELF_LOGFILE_HEADER_DIRTY    0x0001  // File has been written to
#define     ELF_LOGFILE_HEADER_WRAP     0x0002  // The file has wrapped
#define     ELF_LOGFILE_LOGFULL_WRITTEN 0x0004  // Written logfull record
#define     ELF_LOGFILE_ARCHIVE_SET     0x0008  // Archive bit flag


//
// Structure that defines the record that identifies the end of the
// circular log file.
// This record is used to identify where the last record in the circular
// buffer is located.
//
// NOTE: It is *essential* that this record is of a size that a "normal"
//       event log record can never have. There is code that relies on
//       this fact to detect an "EOF" record.
//
//       Care must be taken to not disturb the first part of this record.  It
//       is used to identify an EOF record.  ELFEOFUNIQUEPART must be the
//       number of bytes that are constant.
//

typedef struct _ELF_EOF_RECORD {
    ULONG       RecordSizeBeginning;
    ULONG       One;
    ULONG       Two;
    ULONG       Three;
    ULONG       Four;
    ULONG       BeginRecord;
    ULONG       EndRecord;
    ULONG       CurrentRecordNumber;
    ULONG       OldestRecordNumber;
    ULONG       RecordSizeEnd;
} ELF_EOF_RECORD, *PELF_EOF_RECORD;

#define     ELFEOFRECORDSIZE        sizeof (ELF_EOF_RECORD)

//
// The following constant is how much of the EOF record is constant, and can
// be used to identify an EOF record
//

#define     ELFEOFUNIQUEPART        5 * sizeof(ULONG)

//
// This is used to fill the end of a log record so that the fixed portion
// of a log record doesn't split the end of the file.  It must be less than
// the minimum size of any valid record
//

#define ELF_SKIP_DWORD sizeof(ELF_EOF_RECORD) - 1


//
// Time for the sender of a start or stop request to the Eventlog
// service to wait (in milliseconds) before checking on the
// Eventlog service again to see if it is done
//

#define ELF_WAIT_HINT_TIME            20000     // 20 seconds


//
// Flags used by ElfpCloseLogFile
//

#define ELF_LOG_CLOSE_NORMAL                    0x0000
#define ELF_LOG_CLOSE_FORCE                     0x0001
#define ELF_LOG_CLOSE_BACKUP                    0x0002

//
// Structure used to store information read from the registry
//

typedef struct _LOG_FILE_INFO {
    PUNICODE_STRING LogFileName;
    ULONG           MaxFileSize;
    ULONG           Retention;
    LOGPOPUP        logpLogPopup;
    DWORD           dwAutoBackup;
} LOG_FILE_INFO, *PLOG_FILE_INFO;


//
// DEBUG stuff.
//

//
// This signature is placed in the context handle for debug purposes only,
// to track down a bug in freeing the structures.
//

#define     ELF_CONTEXTHANDLE_SIGN          0x654c6648  // ASCII for eLfH

//
// The different file open (or create) options are based on the type of file.
// The types, and their meanings are:
//
//      ElfNormalLog        Normal log file, opened for cached io
//      ElfSecurityLog      Audit logs, opened for write-thru
//      ElfBackupLog        Not an active log file, opened read only, cached
//

typedef enum _ELF_LOG_TYPE {
    ElfNormalLog,
    ElfSecurityLog,
    ElfBackupLog
} ELF_LOG_TYPE, *PELF_LOG_TYPE;


//
// Eventlog States (used as return codes)
//

#define UPDATE_ONLY         0   // no change in state - just send current status.
#define STARTING            1   // the messenger is initializing.
#define RUNNING             2   // initialization completed normally - now running
#define STOPPING            3   // uninstall pending
#define STOPPED             4   // uninstalled
#define PAUSED              5   // Paused
#define PAUSING             6   // In the process of pausing
#define CONTINUING          7   // In the process of continuing

//
// Forced Shutdown PendingCodes
//
#define PENDING     TRUE
#define IMMEDIATE   FALSE

//
// defines for reliability logging
//
#define DEFAULT_INTERVAL 0

#define SHUTDOWN_UNPLANNED   0x80000000
#define SHUTDOWN_REASON_MASK 0xFFFF

typedef enum _TIMESTAMPEVENT {

    EVENT_Boot=0,
    EVENT_NormalShutdown,
    EVENT_AbNormalShutdown
} TIMESTAMPEVENT, *PTIMESTAMPEVENT;

//
// SS: Clustering specific extensions
//
typedef struct _PROPLOGFILEINFO {
    PLOGFILE    pLogFile;
    PVOID       pStartPosition;
    PVOID       pEndPosition;
    ULONG       ulTotalEventSize; 
    ULONG       ulNumRecords;
} PROPLOGFILEINFO, *PPROPLOGFILEINFO;

typedef struct _PROPINFO
{
    UNICODE_STRING  LogFileName;               // Log file name used to find the log file ptr
    DWORD           dwCurrentRecordNum;        // Currently propagated record
} PROPINFO, *PPROPINFO;

typedef struct _BATCH_QUEUE_ELEMENT {
    LPWSTR   	    lpszLogicalLogFile;        // Name of the logical file - security/application/system
    DWORD           dwRecordLength;            // Event record length
    PVOID           pEventBuffer;              // Event buffer
    PROPINFO        PropagatedInfo;            // Propagated info
} BATCH_QUEUE_ELEMENT, *PBATCH_QUEUE_ELEMENT;

//
// Structure for propagation is preallocated.
//
#define MAXSIZE_OF_EVENTSTOPROP (1 * 1024)
#define BATCHING_SUPPORT_TIMER_DUE_TIME ( 20 * 1000 ) // 20 sec

#endif // ifndef _EVENTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfdbg.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scdebug.h

Abstract:

    Contains debug macros used by the Service Controller.

Author:

    Jonathan Schwartz (jschwart)    18-Nov-1999

Revision History:

    18-Nov-1999    jschwart
        Created from Service Controller's debugging macros

--*/

#ifndef _ELFDBG_H
#define _ELFDBG_H

#if DBG

//
// Debug output macros.
//
#define ELF_LOG0(level,string)               \
    if( ElfDebugLevel & (DEBUG_ ## level)){  \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId());         \
    }

#define ELF_LOG1(level,string,var)           \
    if( ElfDebugLevel & (DEBUG_ ## level)){  \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var);     \
    }

#define ELF_LOG2(level,string,var1,var2)             \
    if( ElfDebugLevel & (DEBUG_ ## level)){          \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var1,var2); \
    }

#define ELF_LOG3(level,string,var1,var2,var3)        \
    if( ElfDebugLevel & (DEBUG_ ## level)){          \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var1,var2,var3); \
    }

#define ELF_LOG4(level,string,var1,var2,var3,var4)       \
    if( ElfDebugLevel & (DEBUG_ ## level)){              \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var1,var2,var3,var4); \
    }

#else

#define ELF_LOG0(level,string)
#define ELF_LOG1(level,string,var)
#define ELF_LOG2(level,string,var1,var2)
#define ELF_LOG3(level,string,var1,var2,var3)
#define ELF_LOG4(level,string,var1,var2,var3,var4)

#endif  // DBG

#define DEBUG_NONE        0x00000000
#define DEBUG_ERROR       0x00000001
#define DEBUG_TRACE       0x00000002
#define DEBUG_MODULES     0x00000004
#define DEBUG_CLUSTER     0x00000008
#define DEBUG_LPC         0x00000010
#define DEBUG_HANDLE      0x00000020
#define DEBUG_FILES       0x00000040

#define DEBUG_ALL         0xffffffff

#endif  // _ELFDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ELFAPI.C

Abstract:

    This module contains the server end of the Elf APIs.


Author:

    Rajen Shah  (rajens)    29-Jul-1991


Revision History:

    14-May-01           a-jyotig
        Removed impersonation from ElfrClearELFW as it is no longer required to
		identify the client that clears a log.

	02-Mar-01           drbeck
        Modified ElfrClearELFW to impersonate client so that a SACL placed on the
        system event log will correctly identify the client that clears a log.
        
                
    10-Sep-1998         jschwart
        Added ElfrGetLogInformation (GetEventlogInformation) API

    30-Jan-1995         MarkBl
        Backup operators are allowed to open the security log, but only
        to perform backup operations. All other operations are prohibited.

    13-Oct-1993         Danl
        ElfrOpenELA:  Fixed Memory Leak bug where it was not calling
        RtlFreeUnicodeString for pRegModuleNameU and PModuleNameU.

    29-Jul-1991         RajenS
        Created

--*/
/****
@doc    EXTERNAL INTERFACES EVTLOG
****/


#include <eventp.h>
#include <elfcfg.h>
#include <stdio.h>  // swprintf
#include <stdlib.h>
#include <memory.h>
#include <clussprt.h>
#include <tstr.h>
#include <strsafe.h>

//
// Maximum number of ChangeNotify requests per context handle
//
#define MAX_NOTIFY_REQUESTS     5


//
//  Batch queue support. Note that only in cluster machines resources will be allocated
//  for batch queue support. For non-cluster machines, the following few bytes are the
//  only ones allocated.
//
#define MAX_BATCH_QUEUE_ELEMENTS    256

PBATCH_QUEUE_ELEMENT    g_pBatchQueueElement = NULL;
DWORD                   g_dwFirstFreeIndex = 0;
RTL_CRITICAL_SECTION    g_CSBatchQueue;
LPDWORD                 g_pcbRecordsOfSameType = NULL;
LPDWORD                 g_pdwRecordType = NULL;
PPROPINFO               g_pPropagatedInfo = NULL;
HANDLE                  g_hBatchingSupportTimer = NULL;
HANDLE                  g_hBatchingSupportTimerQueue = NULL;
BOOL                    g_fBatchingSupportInitialized = FALSE;
    
//
//  PROTOTYPES
//
NTSTATUS
ElfpOpenELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    );

NTSTATUS
ElfpOpenELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    );

VOID
FreePUStringArray (
    IN  PUNICODE_STRING  * pUStringArray,
    IN  USHORT             NumStrings
    );

NTSTATUS
VerifyElfHandle(
    IN IELF_HANDLE LogHandle
    );

NTSTATUS
VerifyAnsiString(
    IN PANSI_STRING pAString
    );

NTSTATUS
ElfpClusterRpcAccessCheck(
    VOID
    );


//
// These APIs only have one interface, since they don't take or return strings
//

NTSTATUS
ElfrNumberOfRecords(
    IN  IELF_HANDLE     LogHandle,
    OUT PULONG          NumberOfRecords
    )
/*++

Routine Description:

  This is the RPC server entry point for the ElfrCurrentRecord API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    NumberOfRecords - Where to return the total number of records in the
                      log file.

Return Value:

    Returns an NTSTATUS code.


--*/
{
    PLOGMODULE Module;
    NTSTATUS   Status;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrNumberOfRecords: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Insure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //

    if (NumberOfRecords == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: NumberOfRecords is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // If the OldestRecordNumber is 0, that means we have an empty
    // file, else we calculate the difference between the oldest
    // and next record numbers
    //

    Module = FindModuleStrucFromAtom(LogHandle->Atom);

    if (Module != NULL)
    {
        *NumberOfRecords = Module->LogFile->OldestRecordNumber == 0 ? 0 :
        Module->LogFile->CurrentRecordNumber -
            Module->LogFile->OldestRecordNumber;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


NTSTATUS
ElfrOldestRecord(
    IN  IELF_HANDLE         LogHandle,
    OUT PULONG          OldestRecordNumber
    )
{
    PLOGMODULE Module;
    NTSTATUS   Status;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrOldestRecord: VerifyElfHandle failed %#x\n",
                  Status);

        return Status;
    }

    //
    // Insure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    if (OldestRecordNumber == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: OldestRecordNumber is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    if (Module != NULL)
    {
        *OldestRecordNumber = Module->LogFile->OldestRecordNumber;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}

NTSTATUS
CheckFileValidity(PUNICODE_STRING pUFileName)
{
    NTSTATUS Status;
    Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

    if (NT_SUCCESS(Status))
    {
        Status = VerifyFileIsFile(pUFileName);
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                 "CheckFileValidity: VerifyFileIsFile failed %#x\n",
                 Status);
            RpcRevertToSelf();
            return Status;
        }
        Status = I_RpcMapWin32Status(RpcRevertToSelf());
    }
    else
    {
        ELF_LOG1(ERROR,
                 "CheckFileValidity: RpcImpersonateClient failed %#x\n",
                 Status);
    }
    return Status;
}

NTSTATUS
ElfrChangeNotify(
    IN  IELF_HANDLE         LogHandle,
    IN  RPC_CLIENT_ID       ClientId,
    IN  ULONG               Event
    )
{
    NTSTATUS Status;
    NTSTATUS RpcStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    HANDLE EventHandle;
    PLOGMODULE Module;
    PNOTIFIEE Notifiee;
    CLIENT_ID tempCli;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: VerifyElfHandle failed %#x\n",
                  Status);

        return Status;
    }

    //
    // Ensure the caller has read access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrChangeNotify: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // First make sure that this is a local call and that it is not a
    // handle that was created for a backup log file
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_REMOTE_HANDLE ||
        LogHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: Handle is for a %ws log\n",
                 LogHandle->Flags & ELF_LOG_HANDLE_REMOTE_HANDLE ? L"remote" :
                                                                   L"backup");

        return STATUS_INVALID_HANDLE;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrChangeNotify: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the client has the right to open this process
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: RpcImpersonateClient failed %#x\n",
                 RpcStatus);

        return I_RpcMapWin32Status(RpcStatus);
    }

    //
    // First get a handle to the process using the passed in ClientId. Note
    // that the ClientId is supplied by the client so a rogue client may
    // supply any client ID. However, because we impersonate when opening
    // the process we don't get any additional access the client doesn't have.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,                   // UNICODE string
                               0,                      // Attributes
                               NULL,                   // Root directory
                               NULL);                  // Security descriptor

#ifdef _WIN64

    tempCli.UniqueProcess = (HANDLE)ULongToPtr(ClientId.UniqueProcess);
    tempCli.UniqueThread = (HANDLE)ULongToPtr(ClientId.UniqueThread);

    Status = NtOpenProcess(&ProcessHandle,
                           PROCESS_DUP_HANDLE,
                           &ObjectAttributes,
                           &tempCli);

#else
    Status = NtOpenProcess(&ProcessHandle,
                           PROCESS_DUP_HANDLE,
                           &ObjectAttributes,
                           (PCLIENT_ID) &ClientId);
#endif

    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: RpcRevertToSelf failed %#x\n",
                 RpcStatus);
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Now dupe the handle they passed in for the event
        //
        Status = NtDuplicateObject(ProcessHandle,
                                   LongToHandle(Event),
                                   NtCurrentProcess(),
                                   &EventHandle,
                                   0,
                                   0,
                                   DUPLICATE_SAME_ACCESS);

         if (NT_SUCCESS(Status))
         {
             //
             // Create a new NOTIFIEE control block to link in
             //
             Notifiee = ElfpAllocateBuffer(sizeof(NOTIFIEE));

             if (Notifiee)
             {
                 //
                 // Fill in the fields
                 //
                 Notifiee->Handle = LogHandle;
                 Notifiee->Event = EventHandle;

                 //
                 // Find the LOGFILE associated with this handle
                 //
                 Module = FindModuleStrucFromAtom(LogHandle->Atom);

                 if (Module != NULL)
                 {
                     //
                     // Get exclusive access to the log file. This will ensure
                     // no one else is accessing the file.
                     //
                     RtlAcquireResourceExclusive(&Module->LogFile->Resource,
                                                 TRUE);   // Wait until available

                     //
                     // Enforce the limit of ChangeNotify requests per context handle
                     //
                     if (LogHandle->dwNotifyRequests == MAX_NOTIFY_REQUESTS)
                     {
                         ELF_LOG1(ERROR,
                                  "ElfrChangeNotify: Already %d requests for this handle\n",
                                  MAX_NOTIFY_REQUESTS);

                         NtClose(EventHandle);
                         ElfpFreeBuffer(Notifiee);
                         Status = STATUS_INSUFFICIENT_RESOURCES;
                     }
                     else
                     {
                         //
                         // Insert the new notifiee into the list and increment this
                         // context handle's ChangeNotify request count
                         //
                         InsertHeadList(&Module->LogFile->Notifiees,
                                        &Notifiee->Next);

                         LogHandle->dwNotifyRequests++;
                     }

                     //
                     // Free the resource
                     //
                     RtlReleaseResource ( &Module->LogFile->Resource );
                 }
                 else
                 {
                     ELF_LOG0(ERROR,
                              "ElfrChangeNotify: No module struc associated with atom\n");

                     NtClose(EventHandle);
                     ElfpFreeBuffer(Notifiee);
                     Status = STATUS_INVALID_HANDLE;
                 }
             }
             else
             {
                 ELF_LOG0(ERROR,
                          "ElfrChangeNotify: Unable to allocate NOTIFIEE block\n");

                 Status = STATUS_NO_MEMORY;

                 //
                 // Free the duplicated handle
                 //
                 CloseHandle(EventHandle);
             }
         }
         else
         {
             ELF_LOG1(ERROR,
                      "ElfrChangeNotify: NtDuplicateObject failed %#x\n",
                      Status);
         }
    }
    else
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: NtOpenProcess failed %#x\n",
                 Status);

        if (Status == STATUS_INVALID_CID)
        {
            Status = STATUS_INVALID_HANDLE;
        }
    }

    if (ProcessHandle)
    {
        NtClose(ProcessHandle);
    }

    return Status;
}


NTSTATUS
ElfrGetLogInformation(
    IN     IELF_HANDLE    LogHandle,
    IN     ULONG          InfoLevel,
    OUT    PBYTE          lpBuffer,
    IN     ULONG          cbBufSize,
    OUT    PULONG         pcbBytesNeeded
    )
/*++

Routine Description:

  This is the RPC server entry point for the ElfrGetLogInformation API.

Arguments:

    LogHandle      - The context-handle for this module's call.
    InfoLevel      - Infolevel that specifies which information the user is requesting
    lpBuffer       - Buffer into which to place the information
    cbBufSize      - Size of lpBuffer, in bytes
    pcbBytesNeeded - Required size of the buffer

Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS   ntStatus;
    PLOGMODULE pLogModule;

    //
    // Check the handle before proceeding.
    //
    ntStatus = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfrGetLogInformation: VerifyElfHandle failed %#x\n",
                 ntStatus);

        return ntStatus;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrGetLogInformation: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Take the appropriate actions based on the Infolevel
    //
    switch (InfoLevel)
    {
        case EVENTLOG_FULL_INFO:

            *pcbBytesNeeded = sizeof(EVENTLOG_FULL_INFORMATION);

            if (cbBufSize < *pcbBytesNeeded)
            {
                ELF_LOG2(ERROR,
                         "ElfrGetLogInformation: buffer size = %d, required size = %d\n",
                         cbBufSize,
                         *pcbBytesNeeded);

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Get the module associated with this log handle
            //
            pLogModule = FindModuleStrucFromAtom(LogHandle->Atom);

            if (pLogModule != NULL)
            {
                //
                // The caller has the permission for this operation.  Note
                // that an access check is done when opening the log, so
                // there's no need to repeat it here.
                //
                ((LPEVENTLOG_FULL_INFORMATION)lpBuffer)->dwFull =

                    (pLogModule->LogFile->Flags & ELF_LOGFILE_LOGFULL_WRITTEN ?
                         TRUE :
                         FALSE);

                ELF_LOG2(TRACE,
                         "ElfrGetLogInformation: %ws log is %ws\n",
                         pLogModule->LogFile->LogModuleName->Buffer,
                         pLogModule->LogFile->Flags & ELF_LOGFILE_LOGFULL_WRITTEN ?
                             L"full" :
                             L"not full");
            }
            else
            {
                ELF_LOG0(ERROR,
                         "ElfrGetLogInformation: No module struc associated with atom\n");

                ntStatus = STATUS_INVALID_HANDLE;
            }

            break;

        default:

            ELF_LOG1(ERROR,
                     "ElfrGetLogInformation: Invalid InfoLevel %d\n",
                     InfoLevel);

            ntStatus = STATUS_INVALID_LEVEL;
            break;
    }

    return ntStatus;
}


//
// UNICODE APIs
//



NTSTATUS
ElfrClearELFW (
    IN  IELF_HANDLE         LogHandle,
    IN  PRPC_UNICODE_STRING BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrClearELFW API.

  CleanExit lable was written to add some cleanup code. The cleanup code was 
  removed later as it was not required but the lable is retained in order to 
  add any cleanup code if required in future 

Arguments:

    LogHandle       - The context-handle for this module's call.  This must
                      not have been returned from OpenBackupEventlog, or
                      this call will fail with invalid handle.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    CLEAR_PKT           ClearPkt;
    DWORD               status = NO_ERROR;
    LPWSTR pwsClientSidString = NULL;
    LPWSTR  pwsComputerName = NULL;
    PTOKEN_USER pToken = NULL;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrClearELFW: VerifyElfHandle failed %#x\n",
                 Status);

        goto CleanExit;
    }

    //
    // Ensure the caller has clear access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_CLEAR))
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: LogHandle doesn't have clear access\n");

        Status = STATUS_ACCESS_DENIED;
        goto CleanExit;
    }

    //
    // Verify additional arguments.
    //
    if (BackupFileName != NULL)
    {
        Status = VerifyUnicodeString(BackupFileName);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG0(ERROR,
                     "ElfrClearELFW: BackupFileName is an invalid Unicode string\n");

            goto CleanExit;
        }
        if(BackupFileName->Length > 0)
        {
            Status = VerifyFileIsFile (BackupFileName);
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfrClearELFW: VerifyFileIsFile of backup file %ws failed %#x\n",
                         BackupFileName,
                         Status);
                goto CleanExit;
            }
        }
    }

    //
    // Can't clear a backup log
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: Handle is for a backup log\n");

        Status = STATUS_INVALID_HANDLE;
        goto CleanExit;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: Handle is a backup handle\n");

        Status = STATUS_ACCESS_DENIED;
        goto CleanExit;
    }

    //
    // Find the matching module structure
    //

    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    Request.Pkt.ClearPkt = &ClearPkt;
    Request.Flags = 0;

    if (Module != NULL)
    {
        //
        // Verify that the caller has clear access to this logfile
        //

        if (!RtlAreAllAccessesGranted(LogHandle->GrantedAccess,
                                      ELF_LOGFILE_CLEAR))
        {
            ELF_LOG1(ERROR,
                     "ElfrClearELFW: Caller does not have clear access to %ws log\n",
                     Module->LogFile->LogModuleName->Buffer);

            Status = STATUS_ACCESS_DENIED;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Fill in the request packet
            //

            Request.Module = Module;
            Request.LogFile = Module->LogFile;
            Request.Command = ELF_COMMAND_CLEAR;
            Request.Status = STATUS_SUCCESS;
            Request.Pkt.ClearPkt->BackupFileName =
                                (PUNICODE_STRING)BackupFileName;

            //
            // Call the worker routine to do the operation.
            //
            if (_wcsicmp(ELF_SECURITY_MODULE_NAME,
                          Module->LogFile->LogModuleName->Buffer) == 0)
            {

                // for the security log, make sure that the most basic info is there
                // so that the cleared event audit will always succeed
                
                Status = ElfpGetClientSidString(&pwsClientSidString, &pToken);
                if (!NT_SUCCESS(Status))
                    goto CleanExit;
                pwsComputerName = ElfpGetComputerName();
                if(pwsComputerName == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanExit;
                }
                ElfPerformRequest(&Request);
                if (NT_SUCCESS(Request.Status))
                    ElfpGenerateLogClearedEvent(LogHandle,pwsClientSidString,pwsComputerName,pToken);
            }
            else
                ElfPerformRequest(&Request);

            //
            // Extract status of operation from the request packet
            //

            Status = Request.Status;

        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

CleanExit:
    if(pwsComputerName)
        ElfpFreeBuffer(pwsComputerName);
    if(pwsClientSidString)
        ElfpFreeBuffer(pwsClientSidString);
    if(pToken)
        ElfpFreeBuffer(pToken);

    return Status;
}


NTSTATUS
ElfrBackupELFW (
    IN  IELF_HANDLE         LogHandle,
    IN  PRPC_UNICODE_STRING BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrBackupELFW API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    BACKUP_PKT          BackupPkt;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrBackupELFW: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has read access.
    // This has been removed by davj since backup should be verified via the priviledge

//    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
//    {
//        ELF_LOG0(ERROR,
//                 "ElfrBackupELFW: LogHandle doesn't have read access\n");
//
//        return STATUS_ACCESS_DENIED;
//    }

    //
    // Make sure the client has SE_BACKUP_PRIVILEGE enabled.  Note
    // that we attempted to enable this on the client side
    //
    if (ElfpTestClientPrivilege(SE_BACKUP_PRIVILEGE, NULL) != STATUS_SUCCESS)
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: Client does not have SE_BACKUP_PRIVILEGE\n");

        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyUnicodeString(BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: BackupFileName is not a valid Unicode string\n");

        return Status;
    }

    //
    // A filename must be specified.
    //

    if (BackupFileName->Length == 0) {
        return(STATUS_INVALID_PARAMETER);
    }

    Status = CheckFileValidity(BackupFileName);
    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: CheckFileValidity failed\n");

        return Status;
    }

    Request.Pkt.BackupPkt = &BackupPkt;
    Request.Flags = 0;

    //
    // Find the matching module structure
    //
    Module = FindModuleStrucFromAtom(LogHandle->Atom);

    if (Module != NULL)
    {
        //
        // Fill in the request packet

        Request.Module  = Module;
        Request.LogFile = Module->LogFile;
        Request.Command = ELF_COMMAND_BACKUP;
        Request.Status  = STATUS_SUCCESS;
        Request.Pkt.BackupPkt->BackupFileName =
                            (PUNICODE_STRING)BackupFileName;

        //
        // Call the worker routine to do the operation.
        //
        ElfPerformRequest (&Request);

        //
        // Extract status of operation from the request packet
        //
        Status = Request.Status;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


NTSTATUS
ElfrCloseEL (
    IN OUT  PIELF_HANDLE    LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrCloseEL API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS Status;

    //
    // Check the handle before proceeding.
    //
    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrCloseEL: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    Status = VerifyElfHandle(*LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrCloseEL: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Call the rundown routine to do all the work
    //
    IELF_HANDLE_rundown(*LogHandle);

    *LogHandle = NULL; // so RPC knows it's closed

    return STATUS_SUCCESS;
}


NTSTATUS
ElfrDeregisterEventSource(
    IN OUT  PIELF_HANDLE    LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrDeregisterEventSource API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS Status;

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrDeregisterEventSource: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(*LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrDeregisterEventSource: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if ((*LogHandle)->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrDeregisterEventSource: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Call the rundown routine to do all the work
    //
    IELF_HANDLE_rundown(*LogHandle);

    *LogHandle = NULL; // so RPC knows it's closed

    return STATUS_SUCCESS;
}



NTSTATUS
ElfrOpenBELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING BackupFileName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenBELW API.  It creates
  a module structure $BACKUPnnn where nnn is a unique number for every backup
  log that is opened.  It then calls ElfpOpenELW to actually open the file.


Arguments:

    UNCServerName   - Not used.

    BackupFileName  - Name of the backup log file.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                              context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{

    NTSTATUS        Status;
    UNICODE_STRING  BackupStringW;
    LPWSTR          BackupModuleName;
    PLOGMODULE      pModule;
    DWORD           dwModuleNumber;

//
// Size of buffer (in bytes) required for a UNICODE string of $BACKUPnnn
//

#define SIZEOF_BACKUP_MODULE_NAME 64

    UNREFERENCED_PARAMETER(UNCServerName);

    //
    // Check arguments.
    //

    Status = VerifyUnicodeString(BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: BackupFileName is not a Unicode string\n");

        return Status;
    }

    //
    // A filename must be specified.
    //
    if (BackupFileName->Length == 0)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: Length of BackupFileName is 0\n");

        return STATUS_INVALID_PARAMETER;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create a unique module name by incrementing a global value
    //
    BackupModuleName = ElfpAllocateBuffer(SIZEOF_BACKUP_MODULE_NAME);

    if (BackupModuleName == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: Unable to allocate memory for BackupModuleName\n");

        return STATUS_NO_MEMORY;
    }

    //
    // Serialize read, increment of the global backup module number.
    // Note: double-timing the log file list critical section so as to not
    // require another critical section specifically dedicated to this
    // operation.
    //
    RtlEnterCriticalSection (&LogFileCritSec);

    dwModuleNumber = BackupModuleNumber++;

    RtlLeaveCriticalSection (&LogFileCritSec);

    StringCbPrintf(BackupModuleName, SIZEOF_BACKUP_MODULE_NAME,
                      L"$BACKUP%06d", dwModuleNumber);
    RtlInitUnicodeString(&BackupStringW, BackupModuleName);

    ELF_LOG2(TRACE,
             "ElfrOpenBELW: Backing up module %ws to file %ws\n",
             BackupModuleName,
             BackupFileName->Buffer);

    //
    // Call SetupDataStruct to build the module and log data structures
    // and actually open the file.
    //
    // NOTE:  If this call is successful, the Unicode String Buffer for
    //  BackupStringW (otherwise known as BackupModuleName) will be attached
    //  to the LogModule structure, and should not be free'd.
    //
    Status = SetUpDataStruct(
                    BackupFileName,  // Filename
                    0,               // Max size, it will use actual
                    0,               // retention period, not used for bkup
                    &BackupStringW,  // Module name
                    NULL,            // Handle to registry, not used
                    ElfBackupLog,    // Log type
                    LOGPOPUP_NEVER_SHOW,
                    ELF_DEFAULT_AUTOBACKUP);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG3(ERROR,
                 "ElfrOpenBELW: SetUpDataStruct for file %ws (module %ws) failed %#x\n",
                 BackupFileName->Buffer,
                 BackupModuleName,
                 Status);

        ElfpFreeBuffer(BackupModuleName);
        return Status;
    }

    //
    // Call ElfOpenELW to actually open the log file and get a handle.
    //
    Status = ElfpOpenELW(NULL,
                         (PRPC_UNICODE_STRING) &BackupStringW,
                         NULL,
                         MajorVersion,
                         MinorVersion,
                         LogHandle,
                         ELF_LOGFILE_READ);

    if (NT_SUCCESS(Status))
    {
        //
        // Mark this as a handle for a backup log, so we can clean up
        // differently when it's closed, as well as disallow clear, backup
        // and write operations.
        //

        (*LogHandle)->Flags |= ELF_LOG_HANDLE_BACKUP_LOG;
    }
    else
    {
        ELF_LOG3(ERROR,
                 "ElfrOpenBELW: ElfpOpenELW for file %ws (module %ws) failed %#x\n",
                 BackupFileName->Buffer,
                 BackupModuleName,
                 Status);

        //
        // If we couldn't open the log file, then we need to tear down
        // the DataStruct we set up with SetUpDataStruct.
        //
        pModule = GetModuleStruc(&BackupStringW);

        //
        // We'd better be unlinking the same module we just created
        //
        ASSERT(_wcsicmp(pModule->ModuleName, BackupModuleName) == 0);

        Status = ElfpCloseLogFile(pModule->LogFile, ELF_LOG_CLOSE_BACKUP, TRUE);

        UnlinkLogModule(pModule);
        DeleteAtom(pModule->ModuleAtom);

        ElfpFreeBuffer(pModule->ModuleName);
        ElfpFreeBuffer(pModule);
    }

    return Status;
}


NTSTATUS
ElfrRegisterEventSourceW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrRegisterEventSourceW API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.

    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

Note:

    For now, just call ElfpOpenELW.

--*/
{
    //
    // All arguments checked in ElfpOpenELW.
    //
    return ElfpOpenELW(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_WRITE);
}


NTSTATUS
ElfrOpenELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenELW API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{
    //
    // All arguments checked in ElfpOpenELW.
    //

    return ElfpOpenELW(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_READ);
}


NTSTATUS
ElfpOpenELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    )

/*++

Routine Description:

  Looks alot like ElfrOpenELW but also gets passed a DesiredAccess.

Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

    DesiredAccess   - Indicates the access desired for this logfile.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

--*/
{
    NTSTATUS        Status;
    PLOGMODULE      Module;
    IELF_HANDLE     LogIHandle;
    BOOL            ForSecurityLog = FALSE;

    //
    // Check arguments.
    //

    Status = VerifyUnicodeString(ModuleName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELW: ModuleName is not a Unicode string\n");

        return Status;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELW: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a new structure for the context handle
    //

    LogIHandle = (IELF_HANDLE) ElfpAllocateBuffer (
                                    sizeof (*LogIHandle)
                                  + ModuleName->Length
                                  + sizeof (WCHAR)
                                  );

    if (LogIHandle)
    {
        //
        // Find the module structure in order to pull out the Atom.
        //
        // GetModuleStruc *always* succeeds! (returns default if module
        // not found).
        //

        Module = GetModuleStruc((PUNICODE_STRING) ModuleName);

        //
        // Validate the caller has appropriate access to this logfile.
        // If this is the security log, then check privilege instead.
        //
        if (_wcsicmp(ELF_SECURITY_MODULE_NAME, Module->LogFile->LogModuleName->Buffer) == 0)
        {
            ELF_LOG0(TRACE,
                     "ElfpOpenELW: Opening Security log\n");

            ForSecurityLog = TRUE;
        }

        LogIHandle->Flags            = 0;
        RtlAcquireResourceExclusive(&Module->LogFile->Resource,
                                TRUE);                  // Wait until available
        Status = ElfpAccessCheckAndAudit(
                     L"EventLog",            // SubSystemName
                     L"LogFile",             // ObjectTypeName
                     Module->ModuleName,     // ObjectName
                     LogIHandle,             // Context handle - required?
                     Module->LogFile->Sd,    // Security Descriptor
                     DesiredAccess,          // Requested Access
                     NULL,                   // GENERIC_MAPPING
                     ForSecurityLog
                     );
        RtlReleaseResource(&Module->LogFile->Resource);

        if (NT_SUCCESS(Status))
        {
            LogIHandle->Atom = Module->ModuleAtom;

            LogIHandle->NameLength = ModuleName->Length + sizeof(WCHAR);

            RtlCopyMemory(LogIHandle->Name, ModuleName->Buffer, ModuleName->Length);

            LogIHandle->Name[ModuleName->Length / sizeof(WCHAR)] = L'\0';

            LogIHandle->MajorVersion = MajorVersion; // Store the version
            LogIHandle->MinorVersion = MinorVersion; // of the client

            //
            // Initialize seek positions to zero.
            //

            LogIHandle->SeekRecordPos    = 0;
            LogIHandle->SeekBytePos      = 0;
            LogIHandle->dwNotifyRequests = 0;

            //
            // Link in this structure to the list of context handles
            //

            LogIHandle->Signature = ELF_CONTEXTHANDLE_SIGN; // DEBUG
            LinkContextHandle (LogIHandle);

            *LogHandle = LogIHandle;                // Set return handle
            Status = STATUS_SUCCESS;                // Set return status
        }
        else
        {
            ELF_LOG1(TRACE,
                     "ElfpOpenELW: ElfpAccessCheckAndAudit failed %#x\n",
                     Status);

            ElfpFreeBuffer(LogIHandle);
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELW: Unable to allocate LogIHandle\n");

        Status = STATUS_NO_MEMORY;
    }

    return Status;

    UNREFERENCED_PARAMETER(UNCServerName);
    UNREFERENCED_PARAMETER(RegModuleName);
}


NTSTATUS
w_ElfrReadEL (
    IN      ULONG       Flags,                  // ANSI or UNICODE
    IN      IELF_HANDLE LogHandle,
    IN      ULONG       ReadFlags,
    IN      ULONG       RecordNumber,
    IN      ULONG       NumberOfBytesToRead,
    IN      PBYTE       Buffer,
    OUT     PULONG      NumberOfBytesRead,
    OUT     PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the worker for the ElfrReadEL APIs.

Arguments:

   Same as ElfrReadELW API except that Flags contains an indication
   of whether this is ANSI or UNICODE.

Return Value:

    Same as the main API.

NOTES:

    We assume that the client-side has validated the flags to ensure that
    only one type of each bit is set. No checking is done at the server end.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    READ_PKT            ReadPkt;
    memset(&ReadPkt, 0, sizeof(ReadPkt));

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "w_ElfrReadEL: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: LogHandle does not have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //

    if (Buffer == NULL || !NumberOfBytesRead || !MinNumberOfBytesNeeded)
    {
        ELF_LOG1(ERROR,
                 "w_ElfrReadEL: %ws\n",
                 (Buffer == NULL ? L"Buffer is NULL" :
                      (!NumberOfBytesRead ? L"NumberOfBytesRead is 0" :
                                            L"MinNumberOfBytesNeeded is 0")));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // The ELF_HANDLE_INVALID_FOR_READ flag bit would be set if the
    // file changed underneath this handle.
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_INVALID_FOR_READ)
    {
//        ELF_LOG0(ERROR,
//                 "w_ElfrReadEL: Logfile changed under this handle -- invalid for read\n");

        return STATUS_EVENTLOG_FILE_CHANGED;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    Request.Pkt.ReadPkt = &ReadPkt; // Set up read packet in request packet

    //
    // Find the matching module structure
    //
    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    //
    // Only continue if the module was found
    //

    if (Module != NULL)
    {
        ELF_LOG1(TRACE,
                 "w_ElfrReadEL: Performing read on module %ws\n",
                 Module->ModuleName);

        //
        // Fill in the request packet
        //
        Request.Module = Module;
        Request.Flags = 0;
        Request.LogFile = Module->LogFile;
        Request.Command = ELF_COMMAND_READ;
        Request.Status = STATUS_SUCCESS;

        Request.Pkt.ReadPkt->ContextHandle = LogHandle;
        Request.Pkt.ReadPkt->MinimumBytesNeeded = *MinNumberOfBytesNeeded;
        Request.Pkt.ReadPkt->BufferSize = NumberOfBytesToRead;
        Request.Pkt.ReadPkt->Buffer = (PVOID)Buffer;
        Request.Pkt.ReadPkt->ReadFlags = ReadFlags;
        Request.Pkt.ReadPkt->RecordNumber = RecordNumber;
        Request.Pkt.ReadPkt->Flags = Flags;     // Indicate UNICODE or ANSI

        //
        // Pass along whether the last read was in a forward or backward
        // direction (affects how we treat being at EOF). Then reset the
        // bit in the handle depending on what this read is.
        //
        if (LogHandle->Flags & ELF_LOG_HANDLE_LAST_READ_FORWARD)
        {
            Request.Pkt.ReadPkt->Flags |= ELF_LAST_READ_FORWARD;
        }

        if (ReadFlags & EVENTLOG_FORWARDS_READ)
        {
            LogHandle->Flags |= ELF_LOG_HANDLE_LAST_READ_FORWARD;
        }
        else
        {
            LogHandle->Flags &= ~(ELF_LOG_HANDLE_LAST_READ_FORWARD);
        }


        //
        // Perform the operation
        //
        ElfPerformRequest(&Request);

        //
        // Set up return values
        //
        *NumberOfBytesRead      = Request.Pkt.ReadPkt->BytesRead;
        *MinNumberOfBytesNeeded = Request.Pkt.ReadPkt->MinimumBytesNeeded;

        Status = Request.Status;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: No module associated with atom in LogHandle\n");

        Status = STATUS_INVALID_HANDLE;

        //
        // Set the NumberOfBytesNeeded to zero since there are no bytes to
        // transfer.
        //
        *NumberOfBytesRead = 0;
        *MinNumberOfBytesNeeded = 0;
    }

    return Status;
}


NTSTATUS
ElfrReadELW (
    IN      IELF_HANDLE LogHandle,
    IN      ULONG       ReadFlags,
    IN      ULONG       RecordNumber,
    IN      ULONG       NumberOfBytesToRead,
    IN      PBYTE       Buffer,
    OUT     PULONG      NumberOfBytesRead,
    OUT     PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReadELW API.

Arguments:



Return Value:

    Returns an NTSTATUS code, NumberOfBytesRead if the read was successful
    and MinNumberOfBytesNeeded if the buffer was not big enough.


--*/
{
    //
    // Call the worker with the UNICODE flag.
    // All arguments checked in w_ElfrReadEL.
    //
    return w_ElfrReadEL(ELF_IREAD_UNICODE,
                        LogHandle,
                        ReadFlags,
                        RecordNumber,
                        NumberOfBytesToRead,
                        Buffer,
                        NumberOfBytesRead,
                        MinNumberOfBytesNeeded);
}


NTSTATUS
ElfrReportEventW (
    IN      IELF_HANDLE LogHandle,
    IN      ULONG               EventTime,
    IN      USHORT              EventType,
    IN      USHORT              EventCategory OPTIONAL,
    IN      ULONG               EventID,
    IN      USHORT              NumStrings,
    IN      ULONG               DataSize,
    IN      PRPC_UNICODE_STRING ComputerName,
    IN      PRPC_SID            UserSid,
    IN      PRPC_UNICODE_STRING Strings[],
    IN      PBYTE               Data,
    IN      USHORT              Flags,
    IN OUT  PULONG              RecordNumber OPTIONAL,
    IN OUT  PULONG              TimeWritten  OPTIONAL
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReportEventW API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    WRITE_PKT           WritePkt;

    ULONG RecordLength;
    ULONG StringOffset, DataOffset;
    ULONG StringsSize;
    USHORT i;
    USHORT iFirstString = 0;
    PVOID EventBuffer;
    PEVENTLOGRECORD EventLogRecord;
    PWSTR  ReplaceStrings, SrcString;
    PBYTE  BinaryData;
    PUNICODE_STRING  UComputerName;
    PWSTR   UModuleName;
    ULONG   PadSize;
    ULONG   UserSidLength = 0;              // Init to zero
    ULONG   UserSidOffset;
    ULONG   ModuleNameLen, ComputerNameLen; // Length in bytes
    ULONG   zero = 0;                       // For pad bytes
    LARGE_INTEGER    Time;
    ULONG   LogTimeWritten;

    //
    // These will be for Security Auditing to use for paired events.
    //
//    UNREFERENCED_PARAMETER(RecordNumber);
//    UNREFERENCED_PARAMETER(TimeWritten);

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Insure the caller has write access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_WRITE))
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: LogHandle does not have write access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyUnicodeString(ComputerName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: ComputerName is not a valid Unicode string %#x\n",
                 Status);

        return Status;
    }

    if (Strings == NULL && NumStrings != 0)
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: Strings is NULL and NumStrings is non-zero (%d)\n",
                 NumStrings);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the SID passed in is valid
    //

    if (ARGUMENT_PRESENT(UserSid))
    {
        if (!IsValidSid(UserSid))
        {
            ELF_LOG0(ERROR,
                     "ElfrReportEventW: UserSid is invalid\n");

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Verify the string arguments
    //
    for (i = 0; i < NumStrings; i++ )
    {
        Status = VerifyUnicodeString(Strings[i]);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfrReportEventW: String %d is not a valid Unicode string %#x\n",
                     i,
                     Status);

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Can't write to a backup log
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: Handle is for a backup log\n");

        return STATUS_INVALID_HANDLE;
    }

    //
    // Make sure they didn't pass in a null pointer for the data, but tell
    // me there was something there (I still think RPC should protect me from
    // this!)
    //
    if (!Data && DataSize != 0)
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: Data is NULL and DataSize is non-zero (%d)\n",
                 DataSize);

        return STATUS_INVALID_PARAMETER;
    }

    UComputerName = (PUNICODE_STRING)ComputerName;

    // special hack for auditing.  For the special event, the source name is packed
    // into the first string and the actual event id is packed into the second string

    if(gElfSecurityHandle == LogHandle && EventID == 573)
    {
        if(NumStrings < 2)
        {
            ELF_LOG0(ERROR,
                 "ElfrReportEventW: Special security event had insufficient number of strings\n");
            return STATUS_INVALID_PARAMETER;
        }
        iFirstString = 2;
        UModuleName = (PWSTR) Strings[0]->Buffer;
        EventID = _wtoi(Strings[1]->Buffer);
        ELF_LOG2(TRACE,
                     "ElfrReportEventW: Special 3rd party audit event.  Source is %ws and event ID is %d\n",
                     UModuleName,
                     EventID);
        
    }
    else
    {
        UModuleName   = LogHandle->Name;
        iFirstString = 0;
    }

    Request.Pkt.WritePkt = &WritePkt;   // Set up write packet in request packet
    Request.Flags = 0;

    //
    // Find the matching module structure
    //

    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    if (Module != NULL)
    {

        //
        // Generate any additional information needed in the record.
        //
        // Info that we have                Info to generate
        // -----------------                ----------------
        //  Modulename                      UserSidLength
        //  EventType                       Length
        //  EventID                         StringOffset
        //  NumStrings                      DataOffset
        //  Strings                         PadBytes
        //  DataLength                      LogTimeWritten
        //  Data
        //  UserSidOffset
        //  UserSid
        //  ComputerName
        //  TimeGenerated
        //

        // LogTimeWritten
        // We need to generate a time when the log is written. This
        // gets written in the log so that we can use it to test the
        // retention period when wrapping the file.
        //

        NtQuerySystemTime(&Time);
        RtlTimeToSecondsSince1970(&Time,
                                  &LogTimeWritten);


        //
        // USERSIDLENTGH
        //
        if (UserSid)
        {
            UserSidLength = RtlLengthSid((PSID)UserSid);

            ELF_LOG1(TRACE,
                     "ElfrReportEventW: Length of sid is %d\n",
                     UserSidLength);
        }

        //
        // USERSIDOFFSET
        //
        // Extract the lengths from the STRING structure, and take care of
        // the trailing NULLs.
        //
        ModuleNameLen   = (wcslen(UModuleName) + 1) * sizeof (WCHAR);
        ComputerNameLen = UComputerName->Length + sizeof(WCHAR);

        ELF_LOG1(TRACE,
                 "ElfrReportEventW: Module name length (bytes) is %d\n",
                 ModuleNameLen);

        ELF_LOG1(TRACE,
                 "ElfrReportEventW: Computer name length (bytes) is %d\n",
                 UComputerName->Length + sizeof(WCHAR));

        UserSidOffset = sizeof(EVENTLOGRECORD) + ModuleNameLen + ComputerNameLen;
        UserSidOffset = ALIGN_UP_64(UserSidOffset, sizeof(PVOID));

        //
        // STRING OFFSET:
        //
        StringOffset = UserSidOffset + UserSidLength;

        //
        // Calculate the length of strings so that we can see how
        // much space is needed for that.
        //
        StringsSize = 0;

        for (i = iFirstString; i < NumStrings; i++)
        {
            ELF_LOG3(TRACE,
                     "ElfrReportEventW: Length (bytes) of string %d (%ws) is %d\n",
                     i,
                     Strings[i]->Buffer,
                     Strings[i]->Length + sizeof(WCHAR));

            StringsSize += Strings[i]->Length + sizeof(WCHAR);
        }

        //
        // DATA OFFSET:
        //
        DataOffset = StringOffset + StringsSize;

        //
        // Determine how big a buffer is needed for the eventlog record.
        //
        RecordLength = DataOffset
                         + DataSize
                         + sizeof(RecordLength); // Size excluding pad bytes

        ELF_LOG1(TRACE,
                 "ElfrReportEventW: RecordLength (no pad bytes) is %d\n",
                 RecordLength);

        //
        // Determine how many pad bytes are needed to align to a DWORD
        // boundary.
        //

        PadSize = sizeof(ULONG) - (RecordLength % sizeof(ULONG));

        RecordLength += PadSize;    // True size needed

        ELF_LOG2(TRACE,
                 "ElfrReportEventW: RecordLength (with %d pad bytes) is %d\n",
                 PadSize,
                 RecordLength);

        //
        // Allocate the buffer for the Eventlog record
        //
        EventBuffer = ElfpAllocateBuffer(RecordLength);

        if (EventBuffer != NULL)
        {
            //
            // Fill up the event record
            //
            EventLogRecord = (PEVENTLOGRECORD)EventBuffer;

            EventLogRecord->Length = RecordLength;
            EventLogRecord->TimeGenerated = EventTime;
            EventLogRecord->Reserved  = ELF_LOG_FILE_SIGNATURE;
            EventLogRecord->TimeWritten = LogTimeWritten;
            EventLogRecord->EventID = EventID;
            EventLogRecord->EventType = EventType;
            EventLogRecord->EventCategory = EventCategory;
            EventLogRecord->ReservedFlags = Flags;
            EventLogRecord->ClosingRecordNumber = 0;
            EventLogRecord->NumStrings = NumStrings;
            EventLogRecord->StringOffset = StringOffset;
            EventLogRecord->DataLength = DataSize;
            EventLogRecord->DataOffset = DataOffset;
            EventLogRecord->UserSidLength = UserSidLength;
            EventLogRecord->UserSidOffset = UserSidOffset;

            //
            // Fill in the variable-length fields
            //

            //
            // STRINGS
            //
            ReplaceStrings = (PWSTR)((ULONG_PTR)EventLogRecord + (ULONG)StringOffset);

            for (i = iFirstString; i < NumStrings; i++)
            {
                SrcString = (PWSTR) Strings[i]->Buffer;

                ELF_LOG1(TRACE,
                         "ElfrReportEventW: Copying string %d into record\n",
                         i);

                RtlCopyMemory(ReplaceStrings, SrcString, Strings[i]->Length);

                ReplaceStrings[Strings[i]->Length / sizeof(WCHAR)] = L'\0';
                ReplaceStrings = (PWSTR)((PBYTE) ReplaceStrings
                                                     + Strings[i]->Length
                                                     + sizeof(WCHAR));
            }

            //
            // MODULENAME
            //
            BinaryData = (PBYTE) EventLogRecord + sizeof(EVENTLOGRECORD);

            RtlCopyMemory(BinaryData,
                          UModuleName,
                          ModuleNameLen);

            ELF_LOG1(TRACE,
                     "ElfrReportEventW: Copying module name (%ws) into record\n",
                     UModuleName);

            //
            // COMPUTERNAME
            //
            ReplaceStrings = (LPWSTR) (BinaryData + ModuleNameLen);

            RtlCopyMemory(ReplaceStrings,
                          UComputerName->Buffer,
                          UComputerName->Length);

            ReplaceStrings[UComputerName->Length / sizeof(WCHAR)] = L'\0';

            ELF_LOG1(TRACE,
                     "ElfrReportEventW: Copying computer name (%ws) into record\n",
                     ReplaceStrings);

            //
            // USERSID
            //

            BinaryData = ((PBYTE) EventLogRecord) + UserSidOffset;

            RtlCopyMemory(BinaryData,
                          UserSid,
                          UserSidLength);

            //
            // BINARY DATA
            //
            BinaryData = (PBYTE) ((ULONG_PTR)EventLogRecord + DataOffset);

            if (Data)
            {
                RtlCopyMemory(BinaryData,
                              Data,
                              DataSize);
            }

            //
            // PAD  - Fill with zeros
            //
            BinaryData = (PBYTE) ((ULONG_PTR)BinaryData + DataSize);

            RtlCopyMemory(BinaryData,
                          &zero,
                          PadSize);

            //
            // LENGTH at end of record
            //
            BinaryData = (PBYTE)((ULONG_PTR) BinaryData + PadSize); // Point after pad bytes

            ((PULONG) BinaryData)[0] = RecordLength;

            //
            // Make sure we are in the right place
            //
            ASSERT ((ULONG_PTR)BinaryData
                == (RecordLength + (ULONG_PTR)EventLogRecord) - sizeof(ULONG));

            //
            // Set up request packet.
            // Link event log record into the request structure.
            //
            Request.Module = Module;
            Request.LogFile = Request.Module->LogFile;
            Request.Command = ELF_COMMAND_WRITE;

            Request.Pkt.WritePkt->Buffer = (PVOID)EventBuffer;
            Request.Pkt.WritePkt->Datasize = RecordLength;

            //
            // Perform the operation
            //
            ElfPerformRequest( &Request );

            //
            // Save the event for replication if this node is part of a cluster
            //
            ElfpSaveEventBuffer( Module, EventBuffer, RecordLength );

            Status = Request.Status;                // Set status of WRITE
        }
        else
        {
            ELF_LOG0(ERROR,
                     "ElfrReportEventW: Unable to allocate EventLogRecord\n");

            Status = STATUS_NO_MEMORY;
        }

    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: No module associated with atom in LogHandle\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


//
// ANSI APIs
//

NTSTATUS
ElfrClearELFA (
    IN  IELF_HANDLE     LogHandle,
    IN  PRPC_STRING     BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrClearELFA API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  BackupFileNameU;

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrClearELFA: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has clear access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_CLEAR))
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFA: Handle doesn't have clear access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //

    Status = VerifyAnsiString((PANSI_STRING) BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrClearELFA: BackupFileName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    //
    // Convert the BackupFileName to a UNICODE STRING and call the
    // UNICODE API to do the work.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &BackupFileNameU,
                                          (PANSI_STRING) BackupFileName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        Status = ElfrClearELFW(LogHandle,
                               (PRPC_UNICODE_STRING) &BackupFileNameU);

        RtlFreeUnicodeString (&BackupFileNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrClearELFA: Conversion of Ansi string %s to Unicode failed %#x\n",
                 BackupFileName->Buffer,
                 Status);
    }

    return Status;

}



NTSTATUS
ElfrBackupELFA (
    IN  IELF_HANDLE     LogHandle,
    IN  PRPC_STRING     BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrBackupELFA API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  BackupFileNameU;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrBackupELFA: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has backup access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP))
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFA: Handle does not have backup access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyAnsiString((PANSI_STRING) BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrBackupELFA: BackupFileName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    //
    // Convert the BackupFileName to a UNICODE STRING and call the
    // UNICODE API to do the work.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &BackupFileNameU,
                                          (PANSI_STRING) BackupFileName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        Status = ElfrBackupELFW(LogHandle,
                                (PRPC_UNICODE_STRING) &BackupFileNameU);

        RtlFreeUnicodeString(&BackupFileNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrBackupELFA: Conversion of Ansi string %s to Unicode failed %#x\n",
                 BackupFileName->Buffer,
                 Status);
    }

    return Status;

}


NTSTATUS
ElfrRegisterEventSourceA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrRegisterEventSourceA API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

Note:

    For now, just call ElfrOpenELA.


--*/
{

    NTSTATUS Status;
    PLOGMODULE Module;
    UNICODE_STRING ModuleNameU;

    //
    // Check arguments.
    //
    // LogHandle check in ElfpOpenELA.
    //

    Status = VerifyAnsiString((PANSI_STRING) ModuleName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrRegisterEventSourceA: ModuleName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &ModuleNameU,
                                          (PANSI_STRING) ModuleName,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfrRegisterEventSourceA: Conversion of Ansi string %s "
                     "to Unicode failed %#x\n",
                 ModuleName->Buffer,
                 Status);

        return Status;
    }

    Module = GetModuleStruc((PUNICODE_STRING) &ModuleNameU);

    RtlFreeUnicodeString(&ModuleNameU);

    return ElfpOpenELA(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_WRITE);
}

NTSTATUS
ElfrOpenELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenEL API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Name of module to use to determine the log file.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{
    //
    // All arguments checked in ElfpOpenELA.
    //
    return ElfpOpenELA(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_READ);
}


NTSTATUS
ElfpOpenELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    )

/*++

Routine Description:

  Looks alot loke ElfrOpenELA, only this also takes a DesiredAccess parameter.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Name of module to use to determine the log file.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

--*/
{
    NTSTATUS       Status;
    UNICODE_STRING ModuleNameU;

    //
    // Check arguments.
    //
    Status = VerifyAnsiString((PANSI_STRING) ModuleName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpOpenELA: ModuleName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELA: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the ModuleName and RegModulename to UNICODE STRINGs and call
    // the UNICODE API to do the work.
    //

    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &ModuleNameU,
                                          (PANSI_STRING) ModuleName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        //
        // We *KNOW* that the UNCServerName is not used
        // by ElfpOpenELW so we save ourselves some work
        // and just pass in a NULL.
        //
        Status = ElfpOpenELW((EVENTLOG_HANDLE_W) NULL,
                             (PRPC_UNICODE_STRING) &ModuleNameU,
                             NULL,
                             MajorVersion,
                             MinorVersion,
                             LogHandle,
                             DesiredAccess);

        RtlFreeUnicodeString(&ModuleNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfpOpenELA: Conversion of Ansi string %s to Unicode failed %#x\n",
                 ModuleName->Buffer,
                 Status);
    }

    return (Status);
    UNREFERENCED_PARAMETER(UNCServerName);
}


NTSTATUS
ElfrOpenBELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         FileName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenBEL API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    FileName        - Filename of the logfile

    MajorVersion/MinorVersion - The version of the client.

    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  FileNameU;

    //
    // Check arguments.
    //

    Status = VerifyAnsiString((PANSI_STRING) FileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrOpenBELA: FileName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    //
    // A filename must be specified.
    //
    if (FileName->Length == 0)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELA: Filename length is 0\n");

        return STATUS_INVALID_PARAMETER;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELA: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the FileName to a UNICODE STRINGs and call
    // the UNICODE API to do the work.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &FileNameU,
                                          (PANSI_STRING) FileName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        //
        // We *KNOW* that the UNCServerName is not used
        // by ElfrOpenELW so we save ourselves some work
        // and just pass in a NULL.
        //
        Status = ElfrOpenBELW ((EVENTLOG_HANDLE_W) NULL,
                               (PRPC_UNICODE_STRING) &FileNameU,
                               MajorVersion,
                               MinorVersion,
                               LogHandle);

        RtlFreeUnicodeString(&FileNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrOpenBELA: Error converting Ansi string %s to Unicode %#x\n",
                 FileName->Buffer,
                 Status);
    }

    return Status;
    UNREFERENCED_PARAMETER(UNCServerName);

}



NTSTATUS
ElfrReadELA (
    IN      IELF_HANDLE LogHandle,
    IN      ULONG       ReadFlags,
    IN      ULONG       RecordNumber,
    IN      ULONG       NumberOfBytesToRead,
    IN      PBYTE       Buffer,
    OUT     PULONG      NumberOfBytesRead,
    OUT     PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReadEL API.

Arguments:



Return Value:

    Returns an NTSTATUS code, NumberOfBytesRead if the read was successful
    and MinNumberOfBytesNeeded if the buffer was not big enough.


--*/
{
    //
    // Call the worker with the ANSI flag.
    // All arguments checked in w_ElfrReadEL.
    //
    return w_ElfrReadEL(ELF_IREAD_ANSI,
                        LogHandle,
                        ReadFlags,
                        RecordNumber,
                        NumberOfBytesToRead,
                        Buffer,
                        NumberOfBytesRead,
                        MinNumberOfBytesNeeded);
}



NTSTATUS
ConvertStringArrayToUnicode (
    PUNICODE_STRING *pUStringArray,
    PANSI_STRING    *Strings,
    USHORT          NumStrings
    )

/*++

Routine Description:

  This routine takes an array of PANSI_STRINGs and generates an array of
  PUNICODE_STRINGs. The destination array has already been allocated
  by the caller, but the structures for the UNICODE_STRINGs will need
  to be allocated by this routine.

Arguments:

    pUStringArray   - Array of PUNICODE_STRINGs.
    Strings         - Array of PANSI_STRINGs.
    NumStrings      