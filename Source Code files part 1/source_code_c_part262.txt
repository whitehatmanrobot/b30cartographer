amespace ? tableSchemaMap[node.LocalName] : tableSchemaMap[node]);
            }

            if (tableSchemaInfo != null) {
                return tableSchemaInfo.TableSchema;
            }else {
                return GetColumnSchema(node, fIgnoreNamespace);
            }
        }        

        public DataTable GetTableForNode(XmlReader node, bool fIgnoreNamespace) {
            TableSchemaInfo tableSchemaInfo = null;
            tableSchemaInfo = (TableSchemaInfo)(fIgnoreNamespace ? tableSchemaMap[node.LocalName] : tableSchemaMap[node]);
            
            if (tableSchemaInfo!=null)
                return tableSchemaInfo.TableSchema;
            else
                return null;
        }        

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\adapterswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdapterSwitches.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Diagnostics;

#if DEBUG
    sealed internal class AdapterSwitches {

        private static TraceSwitch dataError;
        private static TraceSwitch dataSchema;
        private static TraceSwitch dataTrace;
        private static TraceSwitch dataValue;

        private static BooleanSwitch providerParse;
        private static BooleanSwitch oledbMemory;

        private static TraceSwitch adoTrace;
        private static TraceSwitch adoSQL;

        private static TraceSwitch sqlPacketInfo;
        private static TraceSwitch sqlNetlibVersion;
        private static TraceSwitch sqlNetlibInfo;
        private static TraceSwitch sqlExceptionInfo;
        private static TraceSwitch sqlTDSStream;
        private static TraceSwitch sqlTimeout;
        private static TraceSwitch sqlExceptionStack;
        private static TraceSwitch sqlConnectionInfo;
        private static TraceSwitch sqlMetadataInfo;
        private static TraceSwitch sqlParameterInfo;
        private static TraceSwitch sqlAutoGenUpdate;
        private static TraceSwitch sqlStorage;
        private static TraceSwitch sqlDebugIL;
        private static TraceSwitch sqlPooling;
        private static TraceSwitch sqlParsing;

        public static TraceSwitch DataError {
            get {
                if (dataError == null) {
                    dataError = new TraceSwitch("Data.Error", "trace exceptions");
                }
                return dataError;
            }
        }

        public static TraceSwitch DataSchema {
            get {
                if (dataSchema == null) {
                    dataSchema = new TraceSwitch("Data.Schema", "Enable tracing for schema actions.");
                }
                return dataSchema;
            }
        }

        public static TraceSwitch DataTrace {
            get {
                if (dataTrace == null) {
                    dataTrace = new TraceSwitch("Data.Trace", "Enable tracing of Data calls.");
                }
                return dataTrace;
            }
        }

        public static TraceSwitch DataValue {
            get {
                if (dataValue == null) {
                    dataValue = new TraceSwitch("Data.Value", "trace the setting of data");
                }
                return dataValue;
            }
        }

        public static BooleanSwitch ProviderParse {
            get {
                if (providerParse == null) {
                    providerParse = new BooleanSwitch("Provider.Parse", "Enable tracing of connection string parsing.");
                }
                return providerParse;
            }
        }

        public static BooleanSwitch OleDbMemory {
            get {
                if (oledbMemory == null) {
                    oledbMemory = new BooleanSwitch("OleDb.Memory", "Enable tracing of OleDb memory allocaton and free");
                }
                return oledbMemory;
            }
        }

        public static TraceSwitch OleDbTrace {
            get {
                if (adoTrace == null) {
                    adoTrace = new TraceSwitch("OleDb.Trace", "Enable tracing of OleDb to OLEDB interaction");
                }
                return adoTrace;
            }
        }

        public static TraceSwitch OleDbSql {
            get {
                if (adoSQL == null) {
                    adoSQL = new TraceSwitch("OleDb.SQL", "Enable tracing of OleDb generating SQL statements");
                }
                return adoSQL;
            }
        }
        public static TraceSwitch SqlPacketInfo {
            get {
                if (sqlPacketInfo == null) {
                    sqlPacketInfo = new TraceSwitch("SqlPacketInfo", "info on packets sent");
                }
                return sqlPacketInfo;
            }
        }

        public static TraceSwitch SqlNetlibVersion {
            get {
                if (sqlNetlibVersion == null) {
                    sqlNetlibVersion = new TraceSwitch("SqlNetlibVersion", "version of netlib used for connections");
                }
                return sqlNetlibVersion;
            }
        }

        public static TraceSwitch SqlNetlibInfo {
            get {
                if (sqlNetlibInfo == null) {
                    sqlNetlibInfo = new TraceSwitch("SqlNetlibInfo", "trace netlib reads");
                }
                return sqlNetlibInfo;
            }
        }

        public static TraceSwitch SqlExceptionInfo {
            get {
                if (sqlExceptionInfo == null) {
                    sqlExceptionInfo = new TraceSwitch("SqlExceptionInfo", "exception information");
                }
                return sqlExceptionInfo;
            }
        }

        public static TraceSwitch SqlTDSStream {
            get {
                if (sqlTDSStream == null) {
                    sqlTDSStream = new TraceSwitch("SqlTDSStream", "tds stream info");
                }
                return sqlTDSStream;
            }
        }

        public static TraceSwitch SqlTimeout {
            get {
                if (sqlTimeout == null) {
                    sqlTimeout = new TraceSwitch("SqlTimeout", "timeout tracing");
                }
                return sqlTimeout;
            }
        }

        public static TraceSwitch SqlExceptionStack {
            get {
                if (sqlExceptionStack == null) {
                    sqlExceptionStack = new TraceSwitch("SqlExceptionStack", "prints correct call stack for exceptions");
                }
                return sqlExceptionStack;
            }
        }

        public static TraceSwitch SqlConnectionInfo {
            get {
                if (sqlConnectionInfo == null) {
                    sqlConnectionInfo = new TraceSwitch("SqlConnectionInfo", "connection information");
                }
                return sqlConnectionInfo;
            }
        }

        public static TraceSwitch SqlMetadataInfo {
            get {
                if (sqlMetadataInfo == null) {
                    sqlMetadataInfo = new TraceSwitch("SqlMetadataInfo", "metadata information");
                }
                return sqlMetadataInfo;
            }
        }

        public static TraceSwitch SqlParameterInfo {
            get {
                if (sqlParameterInfo == null) {
                    sqlParameterInfo = new TraceSwitch("SqlParameterInfo", "parameter information");
                }
                return sqlParameterInfo;
            }
        }

        public static TraceSwitch SqlAutoGenUpdate {
            get {
                if (sqlAutoGenUpdate == null) {
                    sqlAutoGenUpdate = new TraceSwitch("SqlAutoGenUpdate", "trace autogen'd update statements");
                }
                return sqlAutoGenUpdate;
            }
        }

        public static TraceSwitch SqlStorage {
            get {
                if (sqlStorage == null) {
                    sqlStorage = new TraceSwitch("SqlStorage", "trace creation and destruction of storage objects");
                }
                return sqlStorage;
            }
        }

        public static TraceSwitch SqlDebugIL {
            get {
                if (sqlDebugIL == null) {
                    sqlDebugIL = new TraceSwitch("SqlDebugIL", "turn on debug dynamic IL generation statements");
                }
                return sqlDebugIL;
            }
        }

        public static TraceSwitch SqlPooling {
            get {
                if (sqlPooling == null) {
                    sqlPooling = new TraceSwitch("SqlPooling", "trace operation of pooled objects");
                }
                return sqlPooling;
            }
        }

        public static TraceSwitch SqlParsing {
            get {
                if (sqlParsing == null) {
                    sqlParsing = new TraceSwitch("SqlParsing", "trace parsing of connection string");
                }
                return sqlParsing;
            }
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmlschema.cs ===
//------------------------------------------------------------------------------
// <copyright file="XMLSchema.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Xml.Schema;
    using System.Diagnostics;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;

    internal class XMLSchema {
        internal static void SetProperties(Object instance, XmlAttributeCollection attrs) {
            // This is called from both XSD and XDR schemas. 
            // Do we realy need it in XSD ???
            for (int i = 0; i < attrs.Count; i++) {
                if (attrs[i].NamespaceURI == Keywords.MSDNS) {
                    string name  = attrs[i].LocalName;
                    string value = attrs[i].Value;

                    if (name == "DefaultValue")
                        continue;

                    PropertyDescriptor pd = TypeDescriptor.GetProperties(instance)[name];
                    if (pd != null) {
                        // Standard property
                        Type type = pd.PropertyType;

                        TypeConverter converter = TypeDescriptor.GetConverter(type);
                        object propValue;
                        if (converter.CanConvertFrom(typeof(string))) {
                            propValue = converter.ConvertFromString(value);
                        }else if (type == typeof(Type)) {
                            propValue = Type.GetType(value);
                        }else if (type == typeof(CultureInfo)) {
                            propValue = new CultureInfo(value);
                        }else {
                            throw ExceptionBuilder.CannotConvert(value,type.FullName);
                        }
                        pd.SetValue(instance, propValue);
                    }
                }
            }
        }// SetProperties

        internal static bool FEqualIdentity(XmlNode node, String name, String ns) {
            if (node != null && node.LocalName == name && node.NamespaceURI == ns)
                return true;

            return false;
        }

        internal static bool GetBooleanAttribute(XmlElement element, String attrName, String attrNS, bool defVal) {
            string value = element.GetAttribute(attrName, attrNS);
            if (value == null || value.Length == 0) {
                return defVal;
            }
            if ((value == Keywords.TRUE) || (value == Keywords.ONE_DIGIT)){
                return true;
            }
            if ((value == Keywords.FALSE) || (value == Keywords.ZERO_DIGIT)){
                return false;
            }
            // Error processing:
            throw ExceptionBuilder.InvalidAttributeValue(attrName, value);
        }

        internal static String GetStringAttribute(XmlElement element, String attrName, String attrNS, String defVal) {
            string value = element.GetAttribute(attrName, attrNS);
            if (value == null || value.Length == 0) {
                return defVal;
            }
            return value;
        }

        internal static string GenUniqueColumnName(string proposedName, DataTable table) {

            if (table.Columns.IndexOf(proposedName) >= 0) {
                for (int i=0; i <= table.Columns.Count; i++) {
                    string tempName = proposedName + "_" + (i).ToString();
                    if (table.Columns.IndexOf(tempName) >= 0) {
                        continue;
                    }
                    else {
                        return tempName;
                    }
                }
            }
            return proposedName;
        }

        internal static string GenUniqueTableName(string proposedName, DataSet ds ) {

            if (ds.Tables.IndexOf(proposedName) >= 0) {
                for (int i=0; i <= ds.Tables.Count; i++) {
                    string tempName = proposedName + "_" + (i).ToString();
                    if (ds.Tables.IndexOf(tempName) >= 0) {
                        continue;
                    }
                    else {
                        return tempName;
                    }
                }
            }
            return proposedName;
        }

     }

    internal class ConstraintTable {
        public DataTable table;
        public XmlSchemaIdentityConstraint constraint;
        public ConstraintTable(DataTable t, XmlSchemaIdentityConstraint c) {
            table = t;
            constraint = c;
        }
    }

    internal class XSDSchema :  XMLSchema 
	{
		XmlSchema _schemaRoot = null;	
        XmlSchemaElement dsElement = null;
		DataSet _ds = null;
        String _schemaUri = null;
        String _schemaName = null;
	    private ArrayList ColumnExpressions;
        private Hashtable ConstraintNodes;
        private ArrayList RefTables;
        private ArrayList complexTypes;

        private void CollectElementsAnnotations(XmlSchema schema, XmlSchemaObjectCollection elements, XmlSchemaObjectCollection annotations) {
            foreach(object item in schema.Items) {
                if (item is XmlSchemaAnnotation) {
                    annotations.Add((XmlSchemaAnnotation)item);
                }
                if (item is XmlSchemaElement) {
                    elements.Add((XmlSchemaElement)item);
                }
            }
            foreach(XmlSchemaExternal include in schema.Includes) {
                if (include.Schema != null) {
                    CollectElementsAnnotations(include.Schema, elements, annotations);
                }
            }
        }

        internal static string QualifiedName(string name) {
            int iStart = name.IndexOf(":");
            if (iStart == -1)
                return Keywords.XSD_PREFIXCOLON + name;
            else
                return name;
        }

        internal static void SetProperties(Object instance, XmlAttribute[] attrs) {
            // This is called from both XSD and XDR schemas. 
            // Do we realy need it in XSD ???
            if (attrs == null)
                return;
            for (int i = 0; i < attrs.Length; i++) {
                if (attrs[i].NamespaceURI == Keywords.MSDNS) {
                    string name  = attrs[i].LocalName;
                    string value = attrs[i].Value;

                    if (name == "DefaultValue" || name == "Ordinal" || name == "Locale")
                        continue;

                    if (name == "DataType") {
                        DataColumn col = instance as DataColumn;
                        if (col != null) {
                            Type dataType = Type.GetType(value);
                            col.DataType = dataType;
                        }

                        continue;
                    }

                    PropertyDescriptor pd = TypeDescriptor.GetProperties(instance)[name];
                    if (pd != null) {
                        // Standard property
                        Type type = pd.PropertyType;

                        TypeConverter converter = TypeDescriptor.GetConverter(type);
                        object propValue;
                        if (converter.CanConvertFrom(typeof(string))) {
                            propValue = converter.ConvertFromString(value);
                        }else if (type == typeof(Type)) {
                            propValue = Type.GetType(value);
                        }else if (type == typeof(CultureInfo)) {
                            propValue = new CultureInfo(value);
                        }else {
                            throw ExceptionBuilder.CannotConvert(value,type.FullName);
                        }
                        pd.SetValue(instance, propValue);
                    }
                }
            }
        }// SetProperties

        private static void SetExtProperties(Object instance, XmlAttribute[] attrs) {
            PropertyCollection props = null;
            if (attrs == null)
                return;
            for (int i = 0; i < attrs.Length; i++) {
                if (attrs[i].NamespaceURI == Keywords.MSPROPNS) {
                    if(props == null) {
                        object val = TypeDescriptor.GetProperties(instance)["ExtendedProperties"].GetValue(instance);
                        Debug.Assert(val is PropertyCollection, "We can set values only for classes that have ExtendedProperties");
                        props = (PropertyCollection) val;
                    }
                    string propName = XmlConvert.DecodeName(attrs[i].LocalName);

                    if (instance is ForeignKeyConstraint) {
                        if (propName.StartsWith(Keywords.MSD_FK_PREFIX)) 
                            propName = propName.Substring(3);
                        else 
                            continue; 
                    }
                    if ((instance is DataRelation) && (propName.StartsWith(Keywords.MSD_REL_PREFIX))) {
                            propName = propName.Substring(4);
                    }
                    props.Add(propName, attrs[i].Value);
                }
            }
        }// SetExtProperties

		internal String GetMsdataAttribute(XmlSchemaAnnotated node, String ln) {
            XmlAttribute[]   nodeAttributes = node.UnhandledAttributes;
            if (nodeAttributes!=null)
                for(int i=0; i<nodeAttributes.Length;i++)
                    if (nodeAttributes[i].LocalName == ln && nodeAttributes[i].NamespaceURI == Keywords.MSDNS)
                        return nodeAttributes[i].Value;
            return null;
        }
         

        internal void HandleRelation(XmlElement node) {
            HandleRelation(node, false);
        }

        private static void SetExtProperties(Object instance, XmlAttributeCollection attrs) {
            PropertyCollection props = null;
            for (int i = 0; i < attrs.Count; i++) {
                if (attrs[i].NamespaceURI == Keywords.MSPROPNS) {
                    if(props == null) {
                        object val = TypeDescriptor.GetProperties(instance)["ExtendedProperties"].GetValue(instance);
                        Debug.Assert(val is PropertyCollection, "We can set values only for classes that have ExtendedProperties");
                        props = (PropertyCollection) val;
                    }
                    string propName = XmlConvert.DecodeName(attrs[i].LocalName);
                    props.Add(propName, attrs[i].Value);
                }
            }
        }// SetExtProperties

        
        internal void HandleRelation(XmlElement node, bool fNested) {
            string          strName;
            string          parentName;
            string          childName;
            string []       parentNames;
            string []       childNames;
            string          value;
            bool            fCreateConstraints = false; //if we have a relation,
                                                        //we do not have constraints
            DataRelationCollection rels = _ds.Relations;
            DataRelation    relation;
            DataColumn []   parentKey;
            DataColumn []   childKey;
            DataTable       parent;
            DataTable       child;
            int             keyLength;

            strName = XmlConvert.DecodeName(node.GetAttribute(Keywords.NAME));
            for (int i = 0; i < rels.Count; ++i) {
                if (0 == String.Compare(rels[i].RelationName, strName, false, CultureInfo.InvariantCulture)) 
                    return;
            }

            parentName = node.GetAttribute(Keywords.MSD_PARENT, Keywords.MSDNS);
            if (parentName == null || parentName.Length==0)
                throw ExceptionBuilder.RelationParentNameMissing(strName);
            parentName = XmlConvert.DecodeName(parentName);
            
            childName = node.GetAttribute(Keywords.MSD_CHILD, Keywords.MSDNS);
            if (childName == null || childName.Length==0)
                throw ExceptionBuilder.RelationChildNameMissing(strName);
            childName = XmlConvert.DecodeName(childName);

            value = node.GetAttribute(Keywords.MSD_PARENTKEY, Keywords.MSDNS);
            if (value == null || value.Length==0)
                throw ExceptionBuilder.RelationTableKeyMissing(strName);

            parentNames = value.TrimEnd(null).Split(new char[] {Keywords.MSD_KEYFIELDSEP, Keywords.MSD_KEYFIELDOLDSEP});
            value = node.GetAttribute(Keywords.MSD_CHILDKEY, Keywords.MSDNS);
            if (value == null || value.Length==0)
                throw ExceptionBuilder.RelationChildKeyMissing(strName);

            childNames = value.TrimEnd(null).Split(new char[] {Keywords.MSD_KEYFIELDSEP, Keywords.MSD_KEYFIELDOLDSEP});

            keyLength = parentNames.Length;
            if (keyLength != childNames.Length)
                throw ExceptionBuilder.MismatchKeyLength();

            parentKey = new DataColumn[keyLength];
            childKey = new DataColumn[keyLength];
            parent = _ds.Tables[parentName];
            if (parent == null)
                throw ExceptionBuilder.ElementTypeNotFound(parentName);
            child = _ds.Tables[childName];
            if (child == null)
                throw ExceptionBuilder.ElementTypeNotFound(childName);

            for (int i = 0; i < keyLength; i++) {
                parentKey[i] = parent.Columns[XmlConvert.DecodeName(parentNames[i])];
                if (parentKey[i] == null)
                    throw ExceptionBuilder.ElementTypeNotFound(parentNames[i]);
                childKey[i] = child.Columns[XmlConvert.DecodeName(childNames[i])];
                if (childKey[i] == null)
                    throw ExceptionBuilder.ElementTypeNotFound(childNames[i]);
            }

            relation = new DataRelation(strName, parentKey, childKey, fCreateConstraints);
            relation.Nested = fNested;
            SetExtProperties(relation, node.Attributes);
            _ds.Relations.Add(relation);
        }

        private bool HasAttributes(XmlSchemaObjectCollection attributes){
	        foreach (XmlSchemaObject so in attributes) {
                if (so is XmlSchemaAttribute) {
                   return true;
                }
                if (so is XmlSchemaAttributeGroup) {
                   return true;
                }
                if (so is XmlSchemaAttributeGroupRef) {
                   return true;
                }
            }
            return false;
        }

        private bool IsDatasetParticle(XmlSchemaParticle pt){
    		XmlSchemaObjectCollection items = GetParticleItems(pt);
    
            if (items == null)
                return false; // empty element, threat it as table
            

            foreach (XmlSchemaAnnotated el in items){
				if (el is XmlSchemaElement) {
                    if(((XmlSchemaElement)el).RefName.Name!="")
                        continue;

                    if (!IsTable ((XmlSchemaElement)el))
                        return false;

                    continue;
                }
			
                if (el is XmlSchemaParticle) {
                    if (!IsDatasetParticle((XmlSchemaParticle)el))
                        return false;
                }
            } 

            return true;
        }

        private XmlSchemaElement FindDatasetElement(XmlSchemaObjectCollection elements) {
            foreach(XmlSchemaElement XmlElement in elements) {
                if (GetBooleanAttribute(XmlElement, Keywords.MSD_ISDATASET,  /*default:*/ false)) 
                    return XmlElement;
            }
            if (elements.Count == 1) { //let's see if this element looks like a DataSet

                XmlSchemaElement node = (XmlSchemaElement)elements[0];
                if (!GetBooleanAttribute(node, Keywords.MSD_ISDATASET,  /*default:*/ true)) 
                    return null;

                XmlSchemaComplexType ct = node.SchemaType as XmlSchemaComplexType;
                if (ct == null)
                    return null;

                while (ct != null) {
                    if (HasAttributes(ct.Attributes))
                        return null;
                    XmlSchemaParticle particle = GetParticle(ct);
                    if (particle != null) {
                        if (!IsDatasetParticle(particle))
                            return null; // it's a table
                        } 

                    if (ct.BaseSchemaType is XmlSchemaComplexType) 
                        ct = (XmlSchemaComplexType)ct.BaseSchemaType;
                    else
                        break;
                }


                //if we are here there all elements are tables
                return node;
            }
            return null;
        }

        public void LoadSchema(XmlSchema schemaRoot , DataSet ds) { //Element schemaRoot, DataSet ds) {
            ConstraintNodes = new Hashtable();
            RefTables = new ArrayList();
            ColumnExpressions = new ArrayList();
            complexTypes = new ArrayList();

            if (schemaRoot == null)
                return;
			_schemaRoot = schemaRoot;
			_ds = ds;
            ds.fIsSchemaLoading = true;

            _schemaName = schemaRoot.Id;
            _schemaUri = schemaRoot.TargetNamespace;
            if (_schemaUri == null) _schemaUri = string.Empty;


            if (_schemaName == "" || _schemaName == null) 
                _schemaName = "NewDataSet";

            ds.DataSetName = XmlConvert.DecodeName(_schemaName);
            ds.Namespace = _schemaUri;

            
            XmlSchemaObjectCollection annotations = new XmlSchemaObjectCollection();
            XmlSchemaObjectCollection elements = new XmlSchemaObjectCollection();
            CollectElementsAnnotations(schemaRoot, elements, annotations);

            dsElement = FindDatasetElement(elements);


            // Walk all the top level Element tags.  
            foreach (XmlSchemaElement element in elements) {
				if (element == dsElement)
                    continue;

                String typeName = GetInstanceName(element);
                if (RefTables.Contains(typeName))
                        continue;

                DataTable table = HandleTable(element);
            } 
			
            if (dsElement!=null)
                HandleDataSet(dsElement);

            foreach (XmlSchemaAnnotation annotation in annotations) {
                HandleRelations(annotation, false);
            }
             

            for (int i=0; i<ColumnExpressions.Count; i++)
                ((DataColumn)(ColumnExpressions[i])).BindExpression();

            for (int i=0; i<ColumnExpressions.Count; i++) {
                DataTable table = ((DataColumn)(ColumnExpressions[i])).Table;
                table.Columns.columnQueue = new ColumnQueue(table, table.Columns.columnQueue);
            }

            foreach (DataTable dt in ds.Tables) {
                if (dt.nestedParentRelation == null && dt.Namespace == ds.Namespace)
                    dt.tableNamespace = null;
            }
            
            ds.fIsSchemaLoading = false; //reactivate column computations

		}

        private void HandleRelations(XmlSchemaAnnotation ann, bool fNested) {
            foreach (object __items in ann.Items)
            if (__items is XmlSchemaAppInfo) {
                XmlNode[] relations = ((XmlSchemaAppInfo) __items).Markup;
                for (int i = 0; i<relations.Length; i++)
                if (FEqualIdentity(relations[i], Keywords.MSD_RELATION, Keywords.MSDNS))
                    HandleRelation((XmlElement)relations[i], fNested);
            }
        }
		
        internal XmlSchemaObjectCollection GetParticleItems(XmlSchemaParticle pt){
            if (pt is XmlSchemaSequence)
                return ((XmlSchemaSequence)pt).Items;
            if (pt is XmlSchemaAll)
                return ((XmlSchemaAll)pt).Items;
            if (pt is XmlSchemaChoice)
                return ((XmlSchemaChoice)pt).Items;
            if (pt is XmlSchemaAny)
                return null;
            // the code below is a little hack for the SOM behavior	    
            if (pt is XmlSchemaElement) {
                XmlSchemaObjectCollection Items = new XmlSchemaObjectCollection();
                Items.Add(pt);
                return Items;
            }
            if (pt is XmlSchemaGroupRef)
                return GetParticleItems( ((XmlSchemaGroupRef)pt).Particle );
            // should never get here.
            return null;

        }

        internal void HandleParticle(XmlSchemaParticle pt, DataTable table, ArrayList tableChildren, bool isBase){
    		XmlSchemaObjectCollection items = GetParticleItems(pt);
            
            if (items == null)
                return;

            foreach (XmlSchemaAnnotated item in items){
                XmlSchemaElement el = item as XmlSchemaElement;
				if (el != null) {
                    DataTable child = null;
                    if (((el.Name == null) && (el.RefName.Name == table.EncodedTableName)) ||
                        (IsTable(el) && el.Name == table.TableName))
                        child = table;
                    else
                        child = HandleTable ((XmlSchemaElement)el);
					
                    if (child==null)
						HandleElementColumn((XmlSchemaElement)el, table, isBase);
					else {
                        DataRelation relation = null;
                        if (el.Annotation != null)
                            HandleRelations(el.Annotation, true);

                        DataRelationCollection childRelations = table.ChildRelations;
                        for (int j = 0; j < childRelations.Count; j++) {
                            if (!childRelations[j].Nested)
                                continue;

                            if (child == childRelations[j].ChildTable)
                                relation = childRelations[j];
                        }

                        if (relation == null) {
                            tableChildren.Add(child);
                        }
                        else {
                            Debug.Assert(relation.ParentKey.columns.Length == 1, "Invalid nested relation: multi-column parentkey");
                        }
					}
                } 
                else {
                    HandleParticle((XmlSchemaParticle)item, table, tableChildren, isBase);
                }

            }
        }

        internal void HandleAttributes(XmlSchemaObjectCollection attributes, DataTable table, bool isBase) {
	    foreach (XmlSchemaObject so in attributes) {
                if (so is XmlSchemaAttribute) {
                    HandleAttributeColumn((XmlSchemaAttribute) so, table, isBase);
                }
                else {  // XmlSchemaAttributeGroupRef
                    XmlSchemaAttributeGroup schemaGroup = _schemaRoot.AttributeGroups[((XmlSchemaAttributeGroupRef) so).RefName] as XmlSchemaAttributeGroup;
                    if (schemaGroup!=null) {
                        HandleAttributeGroup(schemaGroup, table, isBase);
                    }
                }
            }
        }

       private void HandleAttributeGroup(XmlSchemaAttributeGroup attributeGroup, DataTable table, bool isBase) {
           foreach (XmlSchemaObject obj in attributeGroup.Attributes) {
               if (obj is XmlSchemaAttribute) {
                   HandleAttributeColumn((XmlSchemaAttribute) obj, table, isBase);
               }
               else { // XmlSchemaAttributeGroupRef
                   XmlSchemaAttributeGroupRef attributeGroupRef = (XmlSchemaAttributeGroupRef)obj;
                   XmlSchemaAttributeGroup attributeGroupResolved;
                   if (attributeGroup.RedefinedAttributeGroup != null && attributeGroupRef.RefName == new XmlQualifiedName(attributeGroup.Name, _schemaRoot.TargetNamespace)) {
                       attributeGroupResolved = (XmlSchemaAttributeGroup)attributeGroup.RedefinedAttributeGroup;
                   }
                   else {
                       attributeGroupResolved = (XmlSchemaAttributeGroup)_schemaRoot.AttributeGroups[attributeGroupRef.RefName];
                   }
                   if (attributeGroupResolved != null) {
                       HandleAttributeGroup(attributeGroupResolved, table, isBase);
                   }
               }
           }
       }

        internal void HandleComplexType(XmlSchemaComplexType ct, DataTable table, ArrayList tableChildren,  bool isNillable){
            if (complexTypes.Contains(ct))
                throw ExceptionBuilder.CircularComplexType(ct.Name);
            bool isBase = false;
            complexTypes.Add(ct);


            if (ct.ContentModel != null) {
                /*
                HandleParticle(ct.CompiledParticle, table, tableChildren, isBase);
		        foreach (XmlSchemaAttribute s in ct.Attributes){
			        HandleAttributeColumn(s, table, isBase);
                }
                */

                
                if (ct.ContentModel is XmlSchemaComplexContent) {
                    XmlSchemaAnnotated cContent = ((XmlSchemaComplexContent) (ct.ContentModel)).Content;
                    if (cContent is XmlSchemaComplexContentExtension) {
                        XmlSchemaComplexContentExtension ccExtension = ((XmlSchemaComplexContentExtension) cContent );
			            HandleAttributes(ccExtension.Attributes, table, isBase);
                        if (ct.BaseSchemaType is XmlSchemaComplexType) {
                            HandleComplexType((XmlSchemaComplexType)ct.BaseSchemaType, table, tableChildren, isNillable);
                        }
                        else {
			                HandleSimpleContentColumn(ccExtension.BaseTypeName.Name, table, isBase, ct.ContentModel.UnhandledAttributes, isNillable);
                        }
                        if (ccExtension.Particle != null)
                            HandleParticle(ccExtension.Particle, table, tableChildren, isBase);

                    } else {
                        Debug.Assert(cContent is XmlSchemaComplexContentRestriction, "Expected complexContent extension or restriction");
                        XmlSchemaComplexContentRestriction ccRestriction = ((XmlSchemaComplexContentRestriction) cContent );
			            HandleAttributes(ccRestriction.Attributes, table, isBase);
                        if (ccRestriction.Particle != null)
                            HandleParticle(ccRestriction.Particle, table, tableChildren, isBase);
                    }
                } else {
                    Debug.Assert(ct.ContentModel is XmlSchemaSimpleContent, "expected simpleContent or complexContent");
                    XmlSchemaAnnotated cContent = ((XmlSchemaSimpleContent) (ct.ContentModel)).Content;
                    if (cContent is XmlSchemaSimpleContentExtension) {
                        XmlSchemaSimpleContentExtension ccExtension = ((XmlSchemaSimpleContentExtension) cContent );
			            HandleAttributes(ccExtension.Attributes, table, isBase);
                        if (ct.BaseSchemaType is XmlSchemaComplexType) {
                            HandleComplexType((XmlSchemaComplexType)ct.BaseSchemaType, table, tableChildren, isNillable);
                        }
                        else {
			                HandleSimpleContentColumn(ccExtension.BaseTypeName.Name, table, isBase, ct.ContentModel.UnhandledAttributes, isNillable);
                        }
                        //BUG BUG: what do we do if the base is a simpleType
                    } else {
                        Debug.Assert(cContent is XmlSchemaSimpleContentRestriction, "Expected SimpleContent extension or restriction");
                        XmlSchemaSimpleContentRestriction ccRestriction = ((XmlSchemaSimpleContentRestriction) cContent );
			            HandleAttributes(ccRestriction.Attributes, table, isBase);
                    }

                }

            }
            else {
                isBase = true;
			    HandleAttributes(ct.Attributes, table, isBase);
                if (ct.Particle != null)
                    HandleParticle(ct.Particle, table, tableChildren, isBase);
            }

            complexTypes.Remove(ct);
        }

        internal XmlSchemaParticle GetParticle(XmlSchemaComplexType ct){
            if (ct.ContentModel != null) {
                if (ct.ContentModel is XmlSchemaComplexContent) {
                    XmlSchemaAnnotated cContent = ((XmlSchemaComplexContent) (ct.ContentModel)).Content;
                    if (cContent is XmlSchemaComplexContentExtension) {
                        return ((XmlSchemaComplexContentExtension) cContent ).Particle;
                    } else {
                        Debug.Assert(cContent is XmlSchemaComplexContentRestriction, "Expected complexContent extension or restriction");
                        return ((XmlSchemaComplexContentRestriction) cContent ).Particle;
                    }
                } else {
                    Debug.Assert(ct.ContentModel is XmlSchemaSimpleContent, "expected simpleContent or complexContent");
                    return null;

                }
 
            }
            else {
                return ct.Particle;
            }

        }

        internal DataColumn FindField(DataTable table, string field) {
            bool attribute = false;
            String colName = field;
 
            if (field.StartsWith("@")) {
                attribute = true;
                colName = field.Substring(1);
            }

            String [] split = colName.Split(':');
            colName = split [split.Length - 1];

            colName = XmlConvert.DecodeName(colName);
            DataColumn col = table.Columns[colName];
            if (col == null )
                throw ExceptionBuilder.InvalidField(field);

            bool _attribute = (col.ColumnMapping == MappingType.Attribute) || (col.ColumnMapping == MappingType.Hidden);
    
            if  (_attribute != attribute)
                throw ExceptionBuilder.InvalidField(field);
                
            return col;
        }

        internal DataColumn[] BuildKey(XmlSchemaIdentityConstraint keyNode, DataTable table){
            ArrayList keyColumns = new ArrayList();
         
            foreach (XmlSchemaXPath node in keyNode.Fields) {
                keyColumns.Add(FindField(table, node.XPath));
            }
         
            DataColumn [] key = new DataColumn[keyColumns.Count];
            keyColumns.CopyTo(key, 0);
          
            return key;
        } 
          
        internal bool GetBooleanAttribute(XmlSchemaAnnotated element, String attrName, bool defVal) {
            string value = GetMsdataAttribute(element, attrName);
            if (value == null || value.Length == 0) {
                return defVal;
            }
            if (value == Keywords.TRUE) {
                return true;
            }
            if (value == Keywords.FALSE) {
                return false;
            }
            // Error processing:
            throw ExceptionBuilder.InvalidAttributeValue(attrName, value);
        }

        internal String GetStringAttribute(XmlSchemaAnnotated element, String attrName, String defVal) {
            string value = GetMsdataAttribute(element, attrName);
            if (value == null || value.Length == 0) {
                return defVal;
            }
            return value;
        }
                    
        /*
        <key name="fk">
            <selector>../Customers</selector>
            <field>ID</field>
        </key>
        <keyref refer="fk">
            <selector>.</selector>
            <field>CustID</field>
        </keyref>
        */

        internal static AcceptRejectRule TranslateAcceptRejectRule( string strRule ) {
            if (strRule == "Cascade")
                return AcceptRejectRule.Cascade;
            else if (strRule == "None")
                return AcceptRejectRule.None;
            else
                return ForeignKeyConstraint.AcceptRejectRule_Default;
        }

        internal static Rule TranslateRule( string strRule ) {
            if (strRule == "Cascade")
                return Rule.Cascade;
            else if (strRule == "None")
                return Rule.None;
            else if (strRule == "SetDefault")
                return Rule.SetDefault;
            else if (strRule == "SetNull")
                return Rule.SetNull;
            else
                return ForeignKeyConstraint.Rule_Default;
        }

        internal void HandleKeyref(XmlSchemaKeyref keyref) {
            string refer = XmlConvert.DecodeName(keyref.Refer.Name); // BUGBUG check here!!!
            string name = XmlConvert.DecodeName(keyref.Name);
            name = GetStringAttribute( keyref, "ConstraintName", /*default:*/ name);
            
            // we do not process key defined outside the current node
            
            String tableName = GetTableName(keyref);
            DataTable table = _ds.Tables[tableName];
            if (table == null)
                return;

            if (refer == null || refer.Length == 0)
                throw ExceptionBuilder.MissingRefer(name);
            
            ConstraintTable key = (ConstraintTable) ConstraintNodes[refer];

            if (key == null) {
                throw ExceptionBuilder.InvalidKey(name);
            }

            DataColumn[] pKey = BuildKey(key.constraint, key.table);
            DataColumn[] fKey = BuildKey(keyref, table);

            ForeignKeyConstraint fkc = null;

            if (GetBooleanAttribute(keyref, Keywords.MSD_CONSTRAINTONLY,  /*default:*/ false)) {
                int iExisting = fKey[0].Table.Constraints.InternalIndexOf(name);
                if (iExisting > -1) {
                    if (fKey[0].Table.Constraints[iExisting].ConstraintName != name)
                        iExisting = -1;
                }
       
                if (iExisting < 0) {
                    fkc = new ForeignKeyConstraint( name, pKey, fKey );
                    fKey[0].Table.Constraints.Add(fkc);
                }
            }
            else {
                string relName = XmlConvert.DecodeName(GetStringAttribute( keyref, Keywords.MSD_RELATIONNAME, keyref.Name));

                if (relName == null || relName.Length == 0)
                    relName = name;

                int iExisting = fKey[0].Table.DataSet.Relations.InternalIndexOf(relName);
                if (iExisting > -1) {
                    if (fKey[0].Table.DataSet.Relations[iExisting].RelationName != relName)
                        iExisting = -1;
                }
                DataRelation relation = null;
                if (iExisting < 0) {
                    relation = new DataRelation(relName, pKey, fKey);
                    SetExtProperties(relation, keyref.UnhandledAttributes);
                    pKey[0].Table.DataSet.Relations.Add(relation);
                    fkc = relation.ChildKeyConstraint;
                    fkc.ConstraintName = name;
                } 
                else {
                    relation = fKey[0].Table.DataSet.Relations[iExisting];
                }
                if (GetBooleanAttribute(keyref, Keywords.MSD_ISNESTED,  /*default:*/ false))
                    relation.Nested = true;
            }

            string acceptRejectRule = GetMsdataAttribute(keyref, Keywords.MSD_ACCEPTREJECTRULE);
            string updateRule       = GetMsdataAttribute(keyref, Keywords.MSD_UPDATERULE);
            string deleteRule       = GetMsdataAttribute(keyref, Keywords.MSD_DELETERULE);

            if (fkc != null) {
                if (acceptRejectRule != null)
                    fkc.AcceptRejectRule = TranslateAcceptRejectRule(acceptRejectRule);

                if (updateRule != null)
                    fkc.UpdateRule = TranslateRule(updateRule);

                if (deleteRule != null)
                    fkc.DeleteRule = TranslateRule(deleteRule);

                SetExtProperties(fkc, keyref.UnhandledAttributes);
            }
        }


        internal void HandleConstraint(XmlSchemaIdentityConstraint keyNode){
            String name = null;
            
            name = XmlConvert.DecodeName(keyNode.Name);
            if (name==null || name.Length==0)
                throw ExceptionBuilder.MissingAttribute(Keywords.NAME);

            if (ConstraintNodes.ContainsKey(name))
                throw ExceptionBuilder.DuplicateConstraintRead(name);

            // we do not process key defined outside the current node
            String tableName = GetTableName(keyNode);

            DataTable table = _ds.Tables[tableName];
            if (table == null)
                return;

            ConstraintNodes.Add(name, new ConstraintTable(table, keyNode));

            bool   fPrimaryKey = GetBooleanAttribute(keyNode, Keywords.MSD_PRIMARYKEY,  /*default:*/ false);
            name        = GetStringAttribute(keyNode, "ConstraintName", /*default:*/ name);



            DataColumn[] key = BuildKey(keyNode, table);

            if (0 < key.Length) {
                UniqueConstraint found = (UniqueConstraint) key[0].Table.Constraints.FindConstraint(new UniqueConstraint(name, key));

                if (found == null) {
                    key[0].Table.Constraints.Add(name, key, fPrimaryKey);
                    SetExtProperties(key[0].Table.Constraints[name], keyNode.UnhandledAttributes);
                }
                else {
                        key = found.Columns;
                        SetExtProperties(found, keyNode.UnhandledAttributes);
                        if (fPrimaryKey)
                            key[0].Table.PrimaryKey = key;
                    }
                if (keyNode is XmlSchemaKey) {
                    for (int i=0; i<key.Length; i++)
                        key[i].AllowDBNull = false;
                }
            }
        }

		internal DataTable InstantiateSimpleTable(XmlSchemaElement node) {
			DataTable table;
            String typeName = XmlConvert.DecodeName(GetInstanceName(node));
            String _TableUri;
            
            _TableUri = node.QualifiedName.Namespace;
            table = _ds.Tables[typeName, _TableUri];
            if (table!=null) {
                    throw ExceptionBuilder.DuplicateDeclaration(typeName);
            }
            
            table = new DataTable( typeName);
            table.Namespace = _TableUri;
            table.Namespace = GetStringAttribute(node, "targetNamespace", table.Namespace);

            table.MinOccurs = node.MinOccurs;
            table.MaxOccurs = node.MaxOccurs;

            SetProperties(table, node.UnhandledAttributes);
            SetExtProperties(table, node.UnhandledAttributes);
            HandleElementColumn(node, table, false);

            table.Columns[0].ColumnName = typeName+"_Column";
            table.Columns[0].ColumnMapping = MappingType.SimpleContent;
            _ds.Tables.Add(table);

            // handle all the unique and key constraints related to this table

			if ((dsElement != null) && (dsElement.Constraints!=null)) {
                foreach (XmlSchemaIdentityConstraint key in dsElement.Constraints) {
                    if (key is XmlSchemaKeyref) 
                        continue;
                    if (GetTableName(key) == table.TableName)
                        HandleConstraint(key);
                }
            }
            table.fNestedInDataset = false;

			return (table);
		}

        internal string GetInstanceName(XmlSchemaAnnotated node) {
            string  instanceName = null;

            Debug.Assert( (node is XmlSchemaElement) || (node is XmlSchemaAttribute), "GetInstanceName should only be called on attribute or elements");

            if (node is XmlSchemaElement) {
                XmlSchemaElement el = (XmlSchemaElement) node;
                instanceName = el.Name != null ? el.Name : el.RefName.Name;
            }
            else if (node is XmlSchemaAttribute) {
                XmlSchemaAttribute el = (XmlSchemaAttribute) node;
                instanceName = el.Name != null ? el.Name : el.RefName.Name;
            }

            Debug.Assert( (instanceName != null) && (instanceName!=""), "instanceName cannot be null or empty. There's an error in the XSD compiler");

            return instanceName;
        }

        // Sequences of handling Elements, Attributes and Text-only column should be the same as in InferXmlSchema
		internal DataTable InstantiateTable(XmlSchemaElement node, XmlSchemaComplexType typeNode, bool isRef) {
			DataTable table;
            String typeName = GetInstanceName(node);
            ArrayList tableChildren = new ArrayList();
            
            String _TableUri;
            
            _TableUri = node.QualifiedName.Namespace;
            

            table = _ds.Tables[XmlConvert.DecodeName(typeName), _TableUri];
            if (table!=null) {
                if (isRef)
                    return table;
                else
                    throw ExceptionBuilder.DuplicateDeclaration(typeName);
            }

            if (isRef)
                RefTables.Add(typeName);

            table = new DataTable( XmlConvert.DecodeName(typeName) );
			table.typeName = node.SchemaTypeName;

            table.Namespace = _TableUri;
            table.Namespace = GetStringAttribute(node, "targetNamespace", table.Namespace);

            //table.Prefix = node.Prefix;
            String value= GetStringAttribute(typeNode, Keywords.MSD_CASESENSITIVE,  "") ;
            if (value!=""){
                if (value == Keywords.TRUE) 
                    table.CaseSensitive = true;                
                if (value == Keywords.FALSE) 
                    table.CaseSensitive = false;                
            }

            value = GetMsdataAttribute(node, Keywords.MSD_LOCALE);
            if (value!=null && value.Length != 0) {
                table.Locale = new CultureInfo(value);
            }
 
            table.MinOccurs = node.MinOccurs;
            table.MaxOccurs = node.MaxOccurs;

            _ds.Tables.Add(table);
         
			HandleComplexType(typeNode, table, tableChildren, node.IsNillable);

            for (int i=0; i < table.Columns.Count ; i++)
                table.Columns[i].SetOrdinal(i);

/*
            if (xmlContent == XmlContent.Mixed) {
                string textColumn = GenUniqueColumnName(table.TableName+ "_Text", table);
                table.XmlText = new DataColumn(textColumn, typeof(string), null, MappingType.Text);
            } */

            SetProperties(table, node.UnhandledAttributes);
            SetExtProperties(table, node.UnhandledAttributes);

            // handle all the unique and key constraints related to this table
			if ((dsElement != null) && (dsElement.Constraints!=null)) {
                foreach (XmlSchemaIdentityConstraint key in dsElement.Constraints) {
                    if (key is XmlSchemaKeyref) 
                        continue;
                    if (GetTableName(key) == table.TableName)
                        HandleConstraint(key);
                }
            }

            foreach(DataTable _tableChild in tableChildren) {
                if (_tableChild != table && table.Namespace == _tableChild.Namespace)
                    _tableChild.tableNamespace = null;

                if ((dsElement != null) && (dsElement.Constraints!=null)) {
                    foreach (XmlSchemaIdentityConstraint key in dsElement.Constraints) {
                        XmlSchemaKeyref keyref = key as XmlSchemaKeyref;
                        if (keyref == null)
                            continue;

                        bool isNested = GetBooleanAttribute(keyref, Keywords.MSD_ISNESTED,  /*default:*/ false);                                
                        if (!isNested)
                            continue;
                        
                        if (GetTableName(keyref) == _tableChild.TableName)
                            HandleKeyref(keyref);
                    }
                } 

                DataRelation relation = null;

                DataRelationCollection childRelations = table.ChildRelations;
                for (int j = 0; j < childRelations.Count; j++) {
                    if (!childRelations[j].Nested)
                        continue;

                    if (_tableChild == childRelations[j].ChildTable)
                        relation = childRelations[j];
                }

                if (relation!=null)
                    continue;

                DataColumn parentKey = table.AddUniqueKey();
                // foreign key in the child table
                DataColumn childKey = _tableChild.AddForeignKey(parentKey);

                // create relationship
                // setup relationship between parent and this table
                relation = new DataRelation(table.TableName + "_" + _tableChild.TableName, parentKey, childKey, true);
                relation.Nested = true;
                _tableChild.DataSet.Relations.Add(relation);
            }

			return (table);
		}

        private class NameTypeComparer : IComparer {
            public int Compare(object x, object y) {return String.Compare(((NameType)x).name, ((NameType)y).name, false, CultureInfo.InvariantCulture);}
        }
        private class NameType : IComparable {
            public String   name;
            public Type     type;
            public NameType(String n, Type t) { 
                name = n;
                type = t;
            }
            public int CompareTo(object obj) { return String.Compare(name, (string)obj, false, CultureInfo.InvariantCulture); }
        };
        // XSD spec: http://www.w3.org/TR/xmlschema-2/
        //    April: http://www.w3.org/TR/2000/WD-xmlschema-2-20000407/datatypes.html
        //    Fabr:  http://www.w3.org/TR/2000/WD-xmlschema-2-20000225/
        private static NameType[] mapNameTypeXsd = {
            new NameType("string"              , typeof(string)  ), /* XSD Apr */
            new NameType("normalizedString"    , typeof(string)  ), /* XSD Apr */
            new NameType("boolean"             , typeof(bool)    ), /* XSD Apr */
            new NameType("float"               , typeof(Single)  ), /* XSD Apr */
            new NameType("double"              , typeof(double)  ), /* XSD Apr */
            new NameType("decimal"              , typeof(decimal) ), /* XSD 2001 March */
            new NameType("duration"            , typeof(TimeSpan)), /* XSD Apr */
            new NameType("base64Binary"        , typeof(Byte[])  ), /* XSD Apr : abstruct */
            new NameType("hexBinary"           , typeof(Byte[])  ), /* XSD Apr : abstruct */
            new NameType("anyURI"              , typeof(System.Uri)  ), /* XSD Apr */
            new NameType("ID"                  , typeof(string)  ), /* XSD Apr */
            new NameType("IDREF"               , typeof(string)  ), /* XSD Apr */
            new NameType("ENTITY"              , typeof(string)  ), /* XSD Apr */
            new NameType("NOTATION"            , typeof(string)  ), /* XSD Apr */
            new NameType("QName"               , typeof(string)  ), /* XSD Apr */
            new NameType("language"            , typeof(string)  ), /* XSD Apr */
            new NameType("IDREFS"              , typeof(string)  ), /* XSD Apr */
            new NameType("ENTITIES"            , typeof(string)  ), /* XSD Apr */
            new NameType("NMTOKEN"             , typeof(string)  ), /* XSD Apr */
            new NameType("NMTOKENS"            , typeof(string)  ), /* XSD Apr */
            new NameType("Name"                , typeof(string)  ), /* XSD Apr */
            new NameType("NCName"              , typeof(string)  ), /* XSD Apr */
            new NameType("integer"             , typeof(Int64)   ), /* XSD Apr */
            new NameType("nonPositiveInteger"  , typeof(Int64)   ), /* XSD Apr */
            new NameType("negativeInteger"     , typeof(Int64)   ), /* XSD Apr */
            new NameType("long"                , typeof(Int64)   ), /* XSD Apr */
            new NameType("int"                 , typeof(Int32)   ), /* XSD Apr */
            new NameType("short"               , typeof(Int16)   ), /* XSD Apr */
            new NameType("byte"                , typeof(SByte)   ), /* XSD Apr */
            new NameType("nonNegativeInteger"  , typeof(UInt64)  ), /* XSD Apr */
            new NameType("unsignedLong"        , typeof(UInt64)  ), /* XSD Apr */
            new NameType("unsignedInt"         , typeof(UInt32)  ), /* XSD Apr */
            new NameType("unsignedShort"       , typeof(UInt16)  ), /* XSD Apr */
            new NameType("unsignedByte"        , typeof(Byte)    ), /* XSD Apr */
            new NameType("positiveInteger"     , typeof(UInt64)  ), /* XSD Apr */
            new NameType("dateTime"            , typeof(DateTime)), /* XSD Apr */
            new NameType("time"                , typeof(DateTime)), /* XSD Apr */
            new NameType("date"                , typeof(DateTime)), /* XSD Apr */
            new NameType("gYear"               , typeof(DateTime)), /* XSD Apr */
            new NameType("gYearMonth"          , typeof(DateTime)), /* XSD Apr */
            new NameType("gMonth"              , typeof(DateTime)), /* XSD Apr */
            new NameType("gMonthDay"           , typeof(DateTime)), /* XSD Apr */
            new NameType("gDay"                , typeof(DateTime)), /* XSD Apr */
        };

        private static bool _wasSorted;

        private static NameType FindNameType(string name) {
            if(! _wasSorted) {
                lock(typeof(NameType)) {
                    if(! _wasSorted) {
                        NameTypeComparer comparer = new NameTypeComparer(); 
                        // REVIEW: (davidgut) why not sort the static list?
                        Array.Sort(mapNameTypeXsd, comparer);
                        _wasSorted = true;
                    }
                }
            }
            int index = Array.BinarySearch(mapNameTypeXsd, name);
            if (index < 0) {
                throw ExceptionBuilder.UndefinedDatatype(name);
            }
            return mapNameTypeXsd[index];
        }

        private Type ParseDataType(string dt) {
            NameType nt = FindNameType(dt);

            return nt.type;
        }

        internal static Boolean IsXsdType(string name) {
            if(! _wasSorted) {
                lock(typeof(NameType)) {
                    if(! _wasSorted) {
                        NameTypeComparer comparer = new NameTypeComparer(); 
                        // REVIEW: (davidgut) why not sort the static list?
                        Array.Sort(mapNameTypeXsd, comparer);
                        _wasSorted = true;
                    }
                }
            }
            int index = Array.BinarySearch(mapNameTypeXsd, name);
            if (index < 0) {
#if DEBUG
                // Let's check that we realy don't have this name:
                foreach (NameType nt in mapNameTypeXsd) {
                    Debug.Assert(nt.name != name, "FindNameType('" + name + "') -- failed. Existed name not found");
                }
#endif
                return false;
            }
            Debug.Assert(mapNameTypeXsd[index].name == name, "FindNameType('" + name + "') -- failed. Wrong name found");
            return true;
        }


        internal XmlSchemaAnnotated FindTypeNode(XmlSchemaAnnotated node) {
			XmlSchemaAttribute attr = node as XmlSchemaAttribute;
            XmlSchemaElement el = node as XmlSchemaElement;
            bool isAttr = attr != null;

            String _type = isAttr ? attr.SchemaTypeName.Name :  el.SchemaTypeName.Name;
    		XmlSchemaAnnotated typeNode;
    		if (_type == null || _type == String.Empty) {
   				_type = isAttr ? attr.RefName.Name :  el.RefName.Name;
                if (_type == null || _type == String.Empty) 
                    typeNode = (XmlSchemaAnnotated) (isAttr ? attr.SchemaType :  el.SchemaType);
                else 
                    typeNode = isAttr ? FindTypeNode((XmlSchemaAnnotated)_schemaRoot.Attributes[attr.RefName]) :FindTypeNode((XmlSchemaAnnotated)_schemaRoot.Elements[el.RefName]);
            }
    		else
    			typeNode = (XmlSchemaAnnotated)_schemaRoot.SchemaTypes[isAttr ? ((XmlSchemaAttribute)node).SchemaTypeName :  ((XmlSchemaElement)node).SchemaTypeName];
            return typeNode;
        }

		internal void HandleSimpleContentColumn(String strType, DataTable table, bool isBase, XmlAttribute[] attrs, bool isNillable){
            
            Type type = null;            
            if (strType == null) {
                return;
            }
            type = ParseDataType(strType);
            DataColumn column;
            string columnName = table.TableName+"_text";
            bool isToAdd = true;
			if ((!isBase) && (table.Columns.Contains(columnName, true))){
                column = table.Columns[columnName];
                isToAdd = false;
            }
            else {
    			column = new DataColumn(columnName, type, null, MappingType.SimpleContent);
            }
			
            SetProperties(column, attrs);
            SetExtProperties(column, attrs);
            
            String tmp = "-1";
            string defValue = null;
            //try to see if attributes contain allownull
            column.AllowDBNull = isNillable;

            if(attrs!=null)
                for(int i=0; i< attrs.Length;i++) {
                    if ( attrs[i].LocalName == Keywords.MSD_ALLOWDBNULL &&  attrs[i].NamespaceURI == Keywords.MSDNS)
                        if ( attrs[i].Value == Keywords.FALSE) 
                            column.AllowDBNull = false;
                    if ( attrs[i].LocalName == Keywords.MSD_ORDINAL &&  attrs[i].NamespaceURI == Keywords.MSDNS)
                        tmp = attrs[i].Value;
                    if ( attrs[i].LocalName == Keywords.MSD_DEFAULTVALUE &&  attrs[i].NamespaceURI == Keywords.MSDNS)
                        defValue = attrs[i].Value;
                }
			int ordinal = (int)Convert.ChangeType(tmp, typeof(int));

            
            //SetExtProperties(column, attr.UnhandledAttributes);

            if ((column.Expression!=null)&&(column.Expression.Length!=0)) {
                ColumnExpressions.Add(column);
            } 

            column.XmlDataType = strType;
            column.SimpleType = null;

			//column.Namespace = typeNode.SourceUri;
            if (isToAdd) {
    			if(ordinal>-1 && ordinal<table.Columns.Count)
    	            table.Columns.AddAt(ordinal, column);
    			else
    	            table.Columns.Add(column);
            }

            if (defValue != null)
                try {
                    column.DefaultValue = column.ConvertXmlToObject(defValue);
                }
                catch (System.FormatException) {
                    throw ExceptionBuilder.CannotConvert(defValue, type.FullName);
                }    


		}

		internal void HandleAttributeColumn(XmlSchemaAttribute attrib, DataTable table, bool isBase){
			Type type = null;
            XmlSchemaAttribute attr = attrib.Name != null ? attrib : (XmlSchemaAttribute) _schemaRoot.Attributes[attrib.RefName];


            XmlSchemaAnnotated typeNode = FindTypeNode(attr);
            String strType = null;
            SimpleType xsdType = null;

            if (typeNode == null) {
                strType = attr.SchemaTypeName.Name;
                if (strType == null || strType.Length == 0) {
                    strType = "";
                    type = typeof(string);
                }
                else {
                    type = ParseDataType(attr.SchemaTypeName.Name);
                }
            }
            else if (typeNode is XmlSchemaSimpleType) {
                // UNDONE: parse simple type
                xsdType = new SimpleType((XmlSchemaSimpleType)typeNode);
                type = ParseDataType(xsdType.BaseType);
                strType = xsdType.Name;
                if(xsdType.Length == 1 && type == typeof(string)) {
                    type = typeof(Char);
                }
            }
            else if (typeNode is XmlSchemaElement) {
                strType = ((XmlSchemaElement)typeNode).SchemaTypeName.Name;
                type = ParseDataType(strType);
            }
            else {
                if (typeNode.Id == null)
                    throw ExceptionBuilder.DatatypeNotDefined();
                else
                    throw ExceptionBuilder.UndefinedDatatype(typeNode.Id);
            }

            DataColumn column;
            string columnName = XmlConvert.DecodeName(GetInstanceName(attr));
            bool isToAdd = true;
			if ((!isBase) && (table.Columns.Contains(columnName, true))){
                column = table.Columns[columnName];
                isToAdd = false;
            }
            else {
    			column = new DataColumn(columnName, type, null, MappingType.Attribute);
            }

            SetProperties(column, attr.UnhandledAttributes);
            SetExtProperties(column, attr.UnhandledAttributes);

            if ((column.Expression!=null)&&(column.Expression.Length!=0)) {
                ColumnExpressions.Add(column);
            }

            column.XmlDataType = strType;
            column.SimpleType = xsdType;

			column.AllowDBNull = !(attrib.Use == XmlSchemaUse.Required);
			column.Namespace = attrib.QualifiedName.Namespace;
            column.Namespace = GetStringAttribute(attrib, "targetNamespace", column.Namespace);

            if (isToAdd)
                table.Columns.Add(column);

			if (attrib.Use == XmlSchemaUse.Prohibited) {
                column.ColumnMapping = MappingType.Hidden;
                column.AllowDBNull = GetBooleanAttribute(attr, Keywords.MSD_ALLOWDBNULL, true)  ;
                String defValue = GetMsdataAttribute(attr, Keywords.MSD_DEFAULTVALUE);
                if (defValue != null)
                    try {
                        column.DefaultValue = column.ConvertXmlToObject(defValue);
                    }
                    catch (System.FormatException) {
                        throw ExceptionBuilder.CannotConvert(defValue, type.FullName);
                    }    

            }


            // XDR March change
            string strDefault = (attrib.Use == XmlSchemaUse.Required) ? GetMsdataAttribute(attr, Keywords.MSD_DEFAULTVALUE) : attr.DefaultValue;
            if ((attr.Use == XmlSchemaUse.Optional) && (strDefault == null ))
                strDefault = attr.FixedValue;
            
            if (strDefault != null)
                try {
                    column.DefaultValue = column.ConvertXmlToObject(strDefault);
                }
                catch (System.FormatException) {
                    throw ExceptionBuilder.CannotConvert(strDefault, type.FullName);
                }    
		}

		internal void HandleElementColumn(XmlSchemaElement elem, DataTable table, bool isBase){
			Type type = null;
            XmlSchemaElement el = elem.Name != null ? elem : (XmlSchemaElement) _schemaRoot.Elements[elem.RefName];

            if (el == null) // it's possible due to some XSD compiler optimizations
                return; // do nothing
            
            XmlSchemaAnnotated typeNode = FindTypeNode(el);
            String strType = null;
            SimpleType xsdType = null;

            if (typeNode == null) {
                strType = el.SchemaTypeName.Name;
                if (strType == null || strType.Length == 0) {
                    strType = "";
                    type = typeof(string);
                }
                else {
                    type = ParseDataType(el.SchemaTypeName.Name);
                }
            }
            else if (typeNode is XmlSchemaSimpleType) {
                // UNDONE: parse simple type
                XmlSchemaSimpleType simpleTypeNode = typeNode as XmlSchemaSimpleType;
                xsdType = new SimpleType(simpleTypeNode);
                simpleTypeNode = xsdType.XmlBaseType!= null ? _schemaRoot.SchemaTypes[xsdType.XmlBaseType] as XmlSchemaSimpleType : null;
                while (simpleTypeNode != null) {
                    xsdType.LoadTypeValues(simpleTypeNode);
                    simpleTypeNode = xsdType.XmlBaseType!= null ? _schemaRoot.SchemaTypes[xsdType.XmlBaseType] as XmlSchemaSimpleType : null;
                }
                type = ParseDataType(xsdType.BaseType);
                strType = xsdType.Name;
                if(xsdType.Length == 1 && type == typeof(string)) {
                    type = typeof(Char);
                }
            }
            else if (typeNode is XmlSchemaElement) {
                strType = ((XmlSchemaElement)typeNode).SchemaTypeName.Name;
                type = ParseDataType(strType);
            }
            else {
                if (typeNode.Id == null)
                    throw ExceptionBuilder.DatatypeNotDefined();
                else
                    throw ExceptionBuilder.UndefinedDatatype(typeNode.Id);
            }

            DataColumn column;
            string columnName = XmlConvert.DecodeName(GetInstanceName(el));
            bool isToAdd = true;
			if ((!isBase) && (table.Columns.Contains(columnName, true))){
                column = table.Columns[columnName];
                isToAdd = false;
            }
            else {
    			column = new DataColumn(columnName, type, null, MappingType.Element);
            }

            SetProperties(column, el.UnhandledAttributes);
            SetExtProperties(column, el.UnhandledAttributes);

            if ((column.Expression!=null)&&(column.Expression.Length!=0)) {
                ColumnExpressions.Add(column);
            }
            
            column.XmlDataType = strType;
            column.SimpleType = xsdType; 

			column.AllowDBNull = (elem.MinOccurs == 0 ) || elem.IsNillable;

            column.Namespace = elem.QualifiedName.Namespace;

            column.Namespace = GetStringAttribute(el, "targetNamespace", column.Namespace);


			String tmp = GetStringAttribute(elem, Keywords.MSD_ORDINAL, "-1");
			int ordinal = (int)Convert.ChangeType(tmp, typeof(int));

			if(isToAdd) {
                if(ordinal>-1 && ordinal<table.Columns.Count)
    	            table.Columns.AddAt(ordinal, column);
    			else
    	            table.Columns.Add(column);
            }

            if (column.Namespace == table.Namespace)
                column._columnUri = null; // to not raise a column change namespace again

            string strDefault = el.DefaultValue;
            if (strDefault != null )
                try {
                    column.DefaultValue = column.ConvertXmlToObject(strDefault);
                }
                catch (System.FormatException) {

                    throw ExceptionBuilder.CannotConvert(strDefault, type.FullName);
                }    
		}

        internal void HandleDataSet(XmlSchemaElement node) {
            string dsName = node.Name;
            _ds.Locale = new CultureInfo(0x409);
            String value = GetMsdataAttribute(node, Keywords.MSD_LOCALE);
            if (value!=null && value.Length != 0) {
                _ds.Locale = new CultureInfo(value);
            }

            SetProperties(_ds, node.UnhandledAttributes);
            SetExtProperties(_ds, node.UnhandledAttributes);


            if (dsName != null && dsName.Length != 0)
                _ds.DataSetName = XmlConvert.DecodeName(dsName);

            Debug.Assert(node.SchemaType is XmlSchemaComplexType, "dataset node can only be complexType");
            XmlSchemaComplexType ct = (XmlSchemaComplexType) FindTypeNode(node);
            if (ct.Particle != null) {
    		    XmlSchemaObjectCollection items = GetParticleItems(ct.Particle);
            
                if (items == null)
                    return;

                foreach (XmlSchemaAnnotated el in items){
				    if (el is XmlSchemaElement) {
                        if(((XmlSchemaElement)el).RefName.Name!="")
                            continue;
                      
                        DataTable child = HandleTable ((XmlSchemaElement)el);
                        if (child!=null) {
                            child.fNestedInDataset = true;
                        }
                    }
                } 
            }

            // Handle the non-nested keyref constraints
            if (node.Constraints != null) {
                foreach (XmlSchemaIdentityConstraint key in node.Constraints) {
                        XmlSchemaKeyref keyref = key as XmlSchemaKeyref;
                        if (keyref == null)
                            continue;

                        bool isNested = GetBooleanAttribute(keyref, Keywords.MSD_ISNESTED,  /*default:*/ false);                                
                        if (isNested)
                            continue;

                        HandleKeyref(keyref);
                    }
            }
        }

        private String GetTableName(XmlSchemaIdentityConstraint key) {
            string xpath = key.Selector.XPath;
            string [] split = xpath.Split('/',':');
            String tableName = split[split.Length - 1]; //get the last string after '/' and ':'
            
            if ((tableName == null) || (tableName == ""))
                throw ExceptionBuilder.InvalidSelector(xpath);
                
            tableName = XmlConvert.DecodeName(tableName);
            return tableName;            
        }
        
        internal bool IsTable(XmlSchemaElement node) {
            if (node.MaxOccurs == decimal.Zero)
                return false;

            Object typeNode = FindTypeNode(node);

            if ( (node.MaxOccurs > decimal.One) && typeNode == null ){
				return true;
            }
			

			if ((typeNode==null) || !(typeNode is XmlSchemaComplexType)) {
				return false;
			}

            XmlSchemaComplexType ctNode = (XmlSchemaComplexType) typeNode;

            if (ctNode.IsAbstract)
                return false;

            return true;
        }

		internal DataTable HandleTable(XmlSchemaElement node) {
		
            if (!IsTable(node))
                return null;
            
            Object typeNode = FindTypeNode(node);

            if ( (node.MaxOccurs > decimal.One) && typeNode == null ){
				return InstantiateSimpleTable(node);
            }
			
            DataTable table = InstantiateTable(node,(XmlSchemaComplexType)typeNode, (node.RefName != null)); 

            table.fNestedInDataset = false;
            return table;

		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\booleanstorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="BooleanStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class BooleanStorage : DataStorage {

        private const Boolean defaultValue = false;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Boolean[] values;

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.BooleanStorage"]/*' />
        /// <internalonly/>
        public BooleanStorage()
        : base(typeof(Boolean)) {
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Min:
                        Boolean min = true;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=values[record] && min;
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Boolean max = false;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=values[record] || max;
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Boolean));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Boolean valueNo1 = values[recordNo1];
            Boolean valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return valueNo1 == valueNo2 ? 0 : (valueNo1 ? 1 : -1);
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Boolean valueNo1 = values[recordNo];
            Boolean valueNo2 = Convert.ToBoolean(value);
            return valueNo1 == valueNo2 ? 0 : (valueNo1 ? 1 : -1);
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Boolean value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = BooleanStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToBoolean(value);
            }
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.SetCapacity"]/*' />
        /// <internalonly/>
         override public void SetCapacity(int capacity) {
            Boolean[] newValues = new Boolean[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
         override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToBoolean(s);
        }

        /// <include file='doc\BooleanStorage.uex' path='docs/doc[@for="BooleanStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
         override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Boolean) value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\bytestorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ByteStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage"]/*' />
    /// <internalonly/>
     [Serializable]
    internal class ByteStorage : DataStorage {

        private const Byte defaultValue = 0;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Byte[] values;

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.ByteStorage"]/*' />
        /// <internalonly/>
         public ByteStorage()
        : base(typeof(Byte)) {
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.DefaultValue"]/*' />
        /// <internalonly/>
         public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.Aggregate"]/*' />
        /// <internalonly/>
         override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        UInt64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Int64 meanSum = (Int64)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Int64)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Byte mean;
                            checked {mean = (Byte)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        Byte min = Byte.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Byte max = Byte.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Byte));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.Compare"]/*' />
        /// <internalonly/>
         override public int Compare(int recordNo1, int recordNo2) {
            Byte valueNo1 = values[recordNo1];
            Byte valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.CompareToValue"]/*' />
        /// <internalonly/>
         override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Byte valueNo1 = values[recordNo];
            Byte valueNo2 = Convert.ToByte(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.Copy"]/*' />
        /// <internalonly/>
         override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.Get"]/*' />
        /// <internalonly/>
         override public Object Get(int record) {
            Byte value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.Set"]/*' />
        /// <internalonly/>
         override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = ByteStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToByte(value);
            }
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.SetCapacity"]/*' />
        /// <internalonly/>
         override public void SetCapacity(int capacity) {
            Byte[] newValues = new Byte[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
         override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToByte(s);
        }

        /// <include file='doc\ByteStorage.uex' path='docs/doc[@for="ByteStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
         override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Byte) value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\charstorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="CharStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage"]/*' />
    /// <internalonly/>
     [Serializable]
    internal class CharStorage : DataStorage {

        private const Char defaultValue = '\0';
        static private readonly Object defaultValueAsObject = defaultValue;

        private Char[] values;

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.CharStorage"]/*' />
        /// <internalonly/>
         public CharStorage()
        : base(typeof(Char)) {
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.DefaultValue"]/*' />
        /// <internalonly/>
         public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.Aggregate"]/*' />
        /// <internalonly/>
         override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Min:
                        Char min = Char.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=(values[record] < min) ? values[record] : min;
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Char max = Char.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=(values[record] > max) ? values[record] : max;
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Char));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.Compare"]/*' />
        /// <internalonly/>
         override public int Compare(int recordNo1, int recordNo2) {
            Char valueNo1 = values[recordNo1];
            Char valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.CompareToValue"]/*' />
        /// <internalonly/>
         override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Char valueNo1 = values[recordNo];
            Char valueNo2 = Convert.ToChar(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.Copy"]/*' />
        /// <internalonly/>
         override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.Get"]/*' />
        /// <internalonly/>
         override public Object Get(int record) {
            Char value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.Set"]/*' />
        /// <internalonly/>
         override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = CharStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToChar(value);
            }

            // Check special characters which would cause problems for XmlReader
            if (value != null && value != DBNull.Value) {
                Char ch = (Char) value;
                if ((ch >= (char)0xd800 && ch <= (char)0xdfff) ||
            	    (ch < (char)0x21 && (ch == (char)0x9 || ch == (char)0xa || ch == (char)0xd || ch == (char)0x20)))
            	    throw ExceptionBuilder.ProblematicChars("0x" + ((UInt16)ch).ToString("X"));
            }
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.SetCapacity"]/*' />
        /// <internalonly/>
         override public void SetCapacity(int capacity) {
            Char[] newValues = new Char[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
         override public object ConvertXmlToObject(string s) {
	        return XmlConvert.ToChar(s);
        }

        /// <include file='doc\CharStorage.uex' path='docs/doc[@for="CharStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
         override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Char) value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datacolumnmapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping"]/*' />
    [
    TypeConverterAttribute(typeof(DataColumnMappingConverter))
    ]
    sealed public class DataColumnMapping : MarshalByRefObject, IColumnMapping, ICloneable {
        private DataColumnMappingCollection parent;
        private string sourceColumnName;
        private string dataSetColumnName;

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.DataColumnMapping"]/*' />
        public DataColumnMapping() {
        }

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.DataColumnMapping1"]/*' />
        public DataColumnMapping(string sourceColumn, string dataSetColumn) {
            SourceColumn = sourceColumn;
            DataSetColumn = dataSetColumn;
        }

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.DataSetColumn"]/*' />
        [
        DefaultValue(""),
        DataSysDescription(Res.DataColumnMapping_DataSetColumn)
        ]
        public string DataSetColumn {
            get {
                return ((null != dataSetColumnName) ? dataSetColumnName : String.Empty);
            }
            set {
                dataSetColumnName = value;
            }
        }

        internal DataColumnMappingCollection Parent {
            get {
                return parent;
            }
            set {
                parent = value;
            }
        }

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.SourceColumn"]/*' />
        [
        DefaultValue(""),
        DataSysDescription(Res.DataColumnMapping_SourceColumn)
        ]
        public string SourceColumn {
            get {
                return ((null != sourceColumnName) ? sourceColumnName : String.Empty);
            }
            set {
                if ((null != Parent) && (0 != ADP.SrcCompare(sourceColumnName, value))) {
                    Parent.ValidateSourceColumn(-1, value);
                }
                sourceColumnName = value;
            }
        }

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            DataColumnMapping clone = new DataColumnMapping(); // MDAC 81448
            clone.SourceColumn = SourceColumn;
            clone.DataSetColumn = DataSetColumn;
            return clone;
        }

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.GetDataColumnBySchemaAction"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        public DataColumn GetDataColumnBySchemaAction(DataTable dataTable, Type dataType, MissingSchemaAction schemaAction) {
            if (null == dataTable) {
                throw ADP.NullDataTable("dataTable");
            }
            string dataSetColumn = DataSetColumn;
            if (ADP.IsEmpty(dataSetColumn)) {
#if DEBUG
                if (AdapterSwitches.DataSchema.TraceWarning) {
                    Debug.WriteLine("explicit filtering of SourceColumn \"" + SourceColumn + "\"");
                }
#endif
                return null;
            }
            DataColumnCollection columns = dataTable.Columns;
            Debug.Assert(null != columns, "GetDataColumnBySchemaAction: unexpected null DataColumnCollection");

            int index = columns.IndexOf(dataSetColumn);
            if ((0 <= index) && (index < columns.Count)) {
                DataColumn dataColumn = columns[index];
                Debug.Assert(null != dataColumn, "GetDataColumnBySchemaAction: unexpected null dataColumn");

                if (!ADP.IsEmpty(dataColumn.Expression)) {
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceError) {
                        Debug.WriteLine("schema mismatch on DataColumn \"" + dataSetColumn + "\" which is a computed column");
                    }
#endif
                    throw ADP.ColumnSchemaExpression(SourceColumn, dataSetColumn);
                }
                if ((null == dataType) || (dataType.IsArray == dataColumn.DataType.IsArray)) {
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceInfo) {
                        Debug.WriteLine("schema match on DataColumn \"" + dataSetColumn + "\"");
                    }
#endif
                    return dataColumn;
                }
#if DEBUG
                if (AdapterSwitches.DataSchema.TraceWarning) {
                    Debug.WriteLine("schema mismatch on DataColumn \"" + dataSetColumn + "\" " + dataType.Name + " != " + dataColumn.DataType.Name);
                }
#endif
                throw ADP.ColumnSchemaMismatch(SourceColumn, dataType, dataColumn);
            }
            switch (schemaAction) {
                case MissingSchemaAction.Add:
                case MissingSchemaAction.AddWithKey:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceInfo) {
                        Debug.WriteLine("schema add of DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType) +">");
                    }
#endif
                    return new DataColumn(dataSetColumn, dataType);

                case MissingSchemaAction.Ignore:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceWarning) {
                        Debug.WriteLine("schema filter of DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType) +">");
                    }
#endif
                    return null;

                case MissingSchemaAction.Error:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceError) {
                        Debug.WriteLine("schema error on DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType) +">");
                    }
#endif
                    throw ADP.ColumnSchemaMissing(dataSetColumn, dataTable.TableName, SourceColumn);
            }
            throw ADP.InvalidSchemaAction((int) schemaAction);
        }

        /// <include file='doc\DataColumnMapping.uex' path='docs/doc[@for="DataColumnMapping.ToString"]/*' />
        public override String ToString() {
            return SourceColumn;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datacolumnmappingcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnMappingCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection"]/*' />
    sealed public class DataColumnMappingCollection : MarshalByRefObject, IColumnMappingCollection {        
        private ArrayList items; // delay creation until AddWithoutEvents, Insert, CopyTo, GetEnumerator

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.DataColumnMappingCollection"]/*' />
        public DataColumnMappingCollection() {
        }

        // explicit ICollection implementation
        bool System.Collections.ICollection.IsSynchronized {
            get { return false;}
        }
        object System.Collections.ICollection.SyncRoot {
            get { return this;}
        }

        // explicit IList implementation
        bool System.Collections.IList.IsReadOnly {
            get { return false;}
        }
        bool System.Collections.IList.IsFixedSize {
            get { return false;}
        }
        object System.Collections.IList.this[int index] {
            get {
                return this[index];
            }
            set { 
                ValidateType(value);
                this[index] = (DataColumnMapping) value;
            }
        }

        // explicit IColumnMappingCollection implementation
        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.IColumnMappingCollection.this"]/*' />
        /// <internalonly/>
        object IColumnMappingCollection.this[string index] {
            get {
                return this[index];
            }
            set { 
                ValidateType(value);
                this[index] = (DataColumnMapping) value;
            }
        }
        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.IColumnMappingCollection.Add"]/*' />
        /// <internalonly/>
        IColumnMapping IColumnMappingCollection.Add(string sourceColumnName, string dataSetColumnName) {
            return Add(sourceColumnName, dataSetColumnName);
        }
        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.IColumnMappingCollection.GetByDataSetColumn"]/*' />
        /// <internalonly/>
        IColumnMapping IColumnMappingCollection.GetByDataSetColumn(string dataSetColumnName) {
            return GetByDataSetColumn(dataSetColumnName);
        }
        
        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Count"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataColumnMappings_Count)
        ]
        public int Count {
            get {
                return ((null != items) ? items.Count : 0);
            }
        }

        private Type ItemType {
            get { return typeof(DataColumnMapping); }
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.this"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataColumnMappings_Item)
        ]
        public DataColumnMapping this[int index] {
            get {
                RangeCheck(index);
                return(DataColumnMapping) items[index];
            }
            set {
                RangeCheck(index);
                Replace(index, value);
            }
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.this1"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataColumnMappings_Item)
        ]
        public DataColumnMapping this[string sourceColumn] {
            get {
                int index = RangeCheck(sourceColumn);
                return(DataColumnMapping) items[index];
            }
            set {
                int index = RangeCheck(sourceColumn);
                Replace(index, value);
            }
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Add"]/*' />
        public int Add(object value) {
            ValidateType(value);
            Add((DataColumnMapping) value);
            return Count-1;
        }

        private DataColumnMapping Add(DataColumnMapping value) {
            AddWithoutEvents(value);
            return value;
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Add2"]/*' />
        public DataColumnMapping Add(string sourceColumn, string dataSetColumn) {
            return Add(new DataColumnMapping(sourceColumn, dataSetColumn));
        }
        
        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.AddRange"]/*' />
        public void AddRange(DataColumnMapping[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            int length = values.Length;
            for (int i = 0; i < length; ++i) {
                ValidateType(values[i]);
            }
            for (int i = 0; i < length; ++i) {
                AddWithoutEvents(values[i]);
            }
        }

        private void AddWithoutEvents(DataColumnMapping value) {
            Validate(-1, value);
            value.Parent = this;
            ArrayList().Add(value);
        }

        // implemented as a method, not as a property because the VS7 debugger 
        // object browser calls properties to display their value, and we want this delayed
        private ArrayList ArrayList() {
            if (null == this.items) {
                this.items = new ArrayList();
            }
            return this.items;
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Clear"]/*' />
        public void Clear() {
            if (0 < Count) {
                ClearWithoutEvents();
            }
        }

        private void ClearWithoutEvents() {
            if (null != items) {
                int count = items.Count;
                for(int i = 0; i < count; ++i) {
                    ((DataColumnMapping) items[i]).Parent = null;
                }
                items.Clear();
            }
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Contains"]/*' />
        public bool Contains(string value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Contains1"]/*' />
        public bool Contains(object value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            ArrayList().CopyTo(array, index);
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.GetByDataSetColumn"]/*' />
        public DataColumnMapping GetByDataSetColumn(string value) {
            int index = IndexOfDataSetColumn(value);
            if (0 > index) {
                throw ADP.ColumnsDataSetColumn(value);
            }
            return(DataColumnMapping) items[index];
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return ArrayList().GetEnumerator();
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.IndexOf"]/*' />
        public int IndexOf(object value) {
            if (null != value) {
                ValidateType(value);
                for (int i = 0; i < Count; ++i) {
                    if (items[i] == value) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.IndexOf1"]/*' />
        public int IndexOf(string sourceColumn) {
            if (!ADP.IsEmpty(sourceColumn)) {
                int count = Count;
                for (int i = 0; i < count; ++i) {
                    if (0 == ADP.SrcCompare(sourceColumn, ((DataColumnMapping) items[i]).SourceColumn)) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.IndexOfDataSetColumn"]/*' />
        public int IndexOfDataSetColumn(string dataSetColumn) {
            if (!ADP.IsEmpty(dataSetColumn)) {
                int count = Count;
                for (int i = 0; i < count; ++i) {
                    if ( 0 == ADP.DstCompare(dataSetColumn, ((DataColumnMapping) items[i]).DataSetColumn)) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Insert"]/*' />
        public void Insert(int index, Object value) {
            ValidateType(value);
            Validate(-1, (DataColumnMapping) value);
            ((DataColumnMapping) value).Parent = this;
            ArrayList().Insert(index, value);
        }

        private void RangeCheck(int index) {
            if ((index < 0) || (Count <= index)) {
                throw ADP.ColumnsIndexInt32(index, this);
            }
        }

        private int RangeCheck(string sourceColumn) {
            int index = IndexOf(sourceColumn);
            if (index < 0) {
                throw ADP.ColumnsIndexSource(sourceColumn);
            }
            return index;
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.RemoveAt"]/*' />
        public void RemoveAt(int index) {
            RangeCheck(index);
            RemoveIndex(index);
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.RemoveAt1"]/*' />
        public void RemoveAt(string sourceColumn) {
            int index = RangeCheck(sourceColumn);
            RemoveIndex(index);
        }

        private void RemoveIndex(int index) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            ((DataColumnMapping) items[index]).Parent = null;
            items.RemoveAt(index);
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.Remove"]/*' />
        public void Remove(object value) {
            ValidateType(value);
            int index = IndexOf((DataColumnMapping) value);
            if (-1 != index) {
                RemoveIndex(index);
            }
            else {
                throw ADP.CollectionRemoveInvalidObject(ItemType, this);
            }
        }

        private void Replace(int index, DataColumnMapping newValue) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");            
            Validate(index, newValue);
            ((DataColumnMapping) items[index]).Parent = null;
            newValue.Parent = this;
            items[index] = newValue;
        }

        private void ValidateType(object value) {
            if (null == value) {
                throw ADP.ColumnsAddNullAttempt("value");
            }
            else if (!ItemType.IsInstanceOfType(value)) {
                throw ADP.NotADataColumnMapping(value);
            }
        }

        private void Validate(int index, DataColumnMapping value) {
            if (null == value) {
                throw ADP.ColumnsAddNullAttempt("value");
            }
            if (null != value.Parent) {
                if (this != value.Parent) {
                    throw ADP.ColumnsIsNotParent(value.SourceColumn);
                }
                else if (index != IndexOf(value)) {
                    throw ADP.ColumnsIsParent(value.SourceColumn);
                }
            }

            String name = value.SourceColumn;
            if (ADP.IsEmpty(name)) {
                index = 1;
                do {
                    name = ADP.SourceColumn + index.ToString();
                    index++;
                } while (-1 != IndexOf(name));
                value.SourceColumn = name;
            }
            else {
                ValidateSourceColumn(index, name);
            }
        }

        internal void ValidateSourceColumn(int index, string value) {
            int pindex = IndexOf(value);
            if ((-1 != pindex) && (index != pindex)) { // must be non-null and unique
                throw ADP.ColumnsUniqueSourceColumn(value);
            }
        }

        /// <include file='doc\DataColumnMappingCollection.uex' path='docs/doc[@for="DataColumnMappingCollection.GetColumnMappingBySchemaAction"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        static public DataColumnMapping GetColumnMappingBySchemaAction(DataColumnMappingCollection columnMappings, string sourceColumn, MissingMappingAction mappingAction) {
            if (null != columnMappings) {
                int index = columnMappings.IndexOf(sourceColumn);
                if (-1 != index) {
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceInfo) {
                        Debug.WriteLine("mapping match on SourceColumn \"" + sourceColumn + "\"");
                    }
#endif
                    return (DataColumnMapping) columnMappings.items[index];
                }
            }
            if (ADP.IsEmpty(sourceColumn)) {
                throw ADP.InvalidSourceColumn("sourceColumn");
            }
            switch (mappingAction) {
                case MissingMappingAction.Passthrough:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceInfo) {
                        Debug.WriteLine("mapping passthrough of SourceColumn \"" + sourceColumn + "\"");
                    }
#endif
                    return new DataColumnMapping(sourceColumn, sourceColumn);

                case MissingMappingAction.Ignore:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceWarning) {
                        Debug.WriteLine("mapping filter of SourceColumn \"" + sourceColumn + "\"");
                    }
#endif
                    return null;

                case MissingMappingAction.Error:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceError) {
                        Debug.WriteLine("mapping error on SourceColumn \"" + sourceColumn + "\"");
                    }
#endif
                    throw ADP.MissingColumnMapping(sourceColumn);
            }
            throw ADP.InvalidMappingAction((int) mappingAction);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\crypto.cs ===
//------------------------------------------------------------------------------
// <copyright file="Crypto.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if USECRYPTO // MDAC 82831

namespace System.Data.Common {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;

    internal class Crypto {
        private static SymmetricAlgorithm s_oDes;
        private static InterlockedStack   s_oEncryptorStack;
        private static InterlockedStack   s_oDecryptorStack;
        private static InterlockedStack   s_oHashAlgoStack;

        private static object             s_initLock = new object();
        private static bool               s_useEncryption = true;

        private static void EnsureConfig() {
            if (null == s_oDes) {
                ConfigureEncryptionObject();
            }
        }

        private static void ConfigureEncryptionObject() {
            lock (s_initLock) {
                if (null == s_oDes) {
                    s_oEncryptorStack = new InterlockedStack();
                    s_oDecryptorStack = new InterlockedStack();
                    s_oHashAlgoStack = new InterlockedStack();

                    DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                    des.GenerateKey();
                    des.GenerateIV();
                    s_oDes = des;
                }
            }
        }

        private static ICryptoTransform GetCryptoTransform(bool fEncrypt) {
            InterlockedStack st = (fEncrypt ? s_oEncryptorStack : s_oDecryptorStack);
            ICryptoTransform ct = (st.Pop() as ICryptoTransform);
            if (null == ct) {
                ct = NewCryptTransform(fEncrypt);
            }
            return ct;
        }

        private static ICryptoTransform NewCryptTransform(bool fEncrypt) {
            lock(s_oDes) {
                return (fEncrypt ? s_oDes.CreateEncryptor() : s_oDes.CreateDecryptor());
            }
        }

        private static HashAlgorithm NewHashAlgorithm() {
            return new SHA1Managed();
        }

        private static void ReturnCryptoTransform(bool fEncrypt, ICryptoTransform ct) {
            InterlockedStack st = (fEncrypt ? s_oEncryptorStack : s_oDecryptorStack);
            st.Push(ct);
        }

        internal static byte [] EncryptOrDecryptData(bool fEncrypt, byte[] inputBuffer, int inputOffset, int inputCount) {
            byte[] outputBuffer;
            if (s_useEncryption) {
                EnsureConfig();
                ICryptoTransform ct = GetCryptoTransform(fEncrypt);
                outputBuffer = ct.TransformFinalBlock(inputBuffer, inputOffset, inputCount);
                ReturnCryptoTransform(fEncrypt, ct); // if an exception occurs, don't return ct to stack
            }
            else {
                outputBuffer = new byte[inputCount];
                Buffer.BlockCopy(inputBuffer, inputOffset, outputBuffer, 0, inputCount);
            }
            return outputBuffer;
        }

        internal static string ComputeHash(string value) {
            if (s_useEncryption) {
                EnsureConfig();
                HashAlgorithm algorithm = (HashAlgorithm) s_oHashAlgoStack.Pop();
                if (null == algorithm) { algorithm = NewHashAlgorithm(); }

                byte[] encrypted;
                byte[] bytes = new byte[ADP.CharSize * value.Length];
                GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
                try {
                    System.Text.Encoding.Unicode.GetBytes(value, 0, value.Length, bytes, 0);
                    encrypted = algorithm.ComputeHash(bytes);
                }
                finally {
                    Array.Clear(bytes, 0, bytes.Length);
                    if (handle.IsAllocated) {
                        handle.Free();
                    }
                }
                s_oHashAlgoStack.Push(algorithm);
                return System.Text.Encoding.Unicode.GetString(encrypted, 0, encrypted.Length);
            }
            return value;
        }

        static internal int DecryptToBlock(string value, byte[] outblock, int offset, int length) {
            int plainLength = 0;
            if ((null != value) && (0 < value.Length)) {
                try {
                    byte[] plainText = null;
                    try {
                        byte[] encrypted = new byte[ADP.CharSize*value.Length];
                        System.Text.Encoding.Unicode.GetBytes(value, 0, value.Length, encrypted, 0);
                        if (s_useEncryption) {
                            plainText = EncryptOrDecryptData(false, encrypted, 0, encrypted.Length);
                        }
                        else {
                            plainText = encrypted;
                        }
                        Debug.Assert((0 <= offset) && (0 < length) && (plainText.Length <= length), "Decrypt outblock too small");
                        Buffer.BlockCopy(plainText, 0, outblock, offset, Math.Min(plainText.Length, length)); 
                    }
                    finally {
                        if (null != plainText) {
                            plainLength = plainText.Length;
                            Array.Clear(plainText, 0, plainLength);
                            plainText = null;
                        }
                    }
                }
                catch {
                    throw;
                }
            }
            return plainLength;
        }

        static internal byte[] DecryptString(string value) { // UNDONE: MDAC 82612
            byte[] plainText = null;            
            if ((null != value) && (0 < value.Length)) {
                byte[] encrypted = System.Text.Encoding.Unicode.GetBytes(value);
                if (s_useEncryption) {
                    plainText = EncryptOrDecryptData(false, encrypted, 0, encrypted.Length);
                }
                else {
                    plainText = encrypted;
                }
            }
            return ((null != plainText) ? plainText : ADP.EmptyByteArray);
        }

        static internal string EncryptString(string value) {
            if (s_useEncryption) {
                Debug.Assert(!ADP.IsEmpty(value), "empty string");
                byte[] encryptedBlock = null;
                try {
                    byte[] plainText = new byte[ADP.CharSize*value.Length];
                    GCHandle handle = GCHandle.Alloc(plainText, GCHandleType.Pinned); // MDAC 82612
                    try {
                        System.Text.Encoding.Unicode.GetBytes(value, 0, value.Length, plainText, 0);
                        encryptedBlock = EncryptOrDecryptData(true, plainText, 0, plainText.Length);
                    }
                    finally {
                        Array.Clear(plainText, 0, plainText.Length);
                        if (handle.IsAllocated) {
                            handle.Free();
                        }
                        plainText = null;
                    }
                }
                catch {
                    throw;
                }
                value = ((null != encryptedBlock) ? System.Text.Encoding.Unicode.GetString(encryptedBlock, 0, encryptedBlock.Length) : ADP.StrEmpty);
            }
            return ((null != value) ? value : ADP.StrEmpty);
        }

        static internal string EncryptFromBlock(char[] inblock, int offset, int length) {
            Debug.Assert((null != inblock) && (0 <= inblock.Length) , "no data to encrypt");
            Debug.Assert((0 <= offset) && (0 <= length) && (offset+length <= inblock.Length), "data to encrypt outofbound");

            string encrypted = null;
            if ((null != inblock) && (0 < length)) {
                if (s_useEncryption) {
                    byte[] encryptedBlock = null;
                    try {
                        byte[] plainText = new byte[ADP.CharSize*length];
                        GCHandle handle = GCHandle.Alloc(plainText, GCHandleType.Pinned); // MDAC 82612
                        try {
                            Buffer.BlockCopy(inblock, ADP.CharSize*offset, plainText, 0, ADP.CharSize*length);
                            encryptedBlock = EncryptOrDecryptData(true, plainText, 0, plainText.Length);
                        }
                        finally {
                            Array.Clear(plainText, 0, plainText.Length);
                            if (handle.IsAllocated) {
                                handle.Free();
                            }
                            plainText = null;
                        }
                    }
                    catch {
                        throw;
                    }
                    encrypted = System.Text.Encoding.Unicode.GetString(encryptedBlock, 0, encryptedBlock.Length);
                }
                else {
                    encrypted = new String(inblock, offset, length);
                }
            }
            return ((null != encrypted) ? encrypted : ADP.StrEmpty);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\adapterutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdapterUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;
    using System.Security;
    using System.Runtime.Serialization;
    using Microsoft.Win32;

#if DEBUG
    using System.Data.Odbc;
    using System.Data.OleDb;
    using System.Data.SqlClient;
#endif

    internal class ADP {
        // The class ADP defines the exceptions that are specific to the Adapters.
        // The class contains functions that take the proper informational variables and then construct
        // the appropriate exception with an error string obtained from the resource Framework.txt.
        // The exception is then returned to the caller, so that the caller may then throw from its
        // location so that the catcher of the exception will have the appropriate call stack.
        // This class is used so that there will be compile time checking of error messages.
        // The resource Framework.txt will ensure proper string text based on the appropriate
        // locale.
        static internal Exception TraceException(Exception e) {
#if DEBUG
            Debug.Assert(null != e, "TraceException: null Exception");
            if (AdapterSwitches.DataError.TraceError) {
                if (null != e) {
                    Debug.WriteLine(e.ToString());
                }
                if (AdapterSwitches.DataError.TraceVerbose) {
                    Debug.WriteLine(Environment.StackTrace);
                }
            }
#endif
            return e;
        }

        /*[Serializable]
        internal class DataMappingException : InvalidOperationException { // MDAC 68427

            /// <include file='doc\DataMappingException.uex' path='docs/doc[@for="DataMappingException.DataMappingException"]/*' />
            internal DataMappingException(SerializationInfo info, StreamingContext context) : base(info, context) {
            }

            /// <include file='doc\DataMappingException.uex' path='docs/doc[@for="DataMappingException.DataMappingException"]/*' />
            internal DataMappingException() : base() {
                HResult = HResults.Data;
            }

            /// <include file='doc\DataMappingException.uex' path='docs/doc[@for="DataMappingException.DataMappingException1"]/*' />
            internal DataMappingException(string s) : base(s) {
                HResult = HResults.Data;
            }

            /// <include file='doc\DataMappingException.uex' path='docs/doc[@for="DataMappingException.DataMappingException2"]/*' />
            internal DataMappingException(string s, Exception innerException) : base(s, innerException) {
            }
        };

        [Serializable]
        internal class DataProviderException : InvalidOperationException { // MDAC 68426

            /// <include file='doc\DataProviderException.uex' path='docs/doc[@for="DataProviderException.DataProviderException"]/*' />
            internal DataProviderException(SerializationInfo info, StreamingContext context) : base(info, context) {
            }

            /// <include file='doc\DataProviderException.uex' path='docs/doc[@for="DataProviderException.DataProviderException"]/*' />
            internal DataProviderException() : base() {
                HResult = HResults.Data;
            }

            /// <include file='doc\DataProviderException.uex' path='docs/doc[@for="DataProviderException.MappingException1"]/*' />
            internal DataProviderException(string s) : base(s) {
                HResult = HResults.Data;
            }

            /// <include file='doc\DataProviderException.uex' path='docs/doc[@for="DataProviderException.MappingException2"]/*' />
            internal DataProviderException(string s, Exception innerException) : base(s, innerException) {
            }
        };*/

        //
        // COM+ exceptions
        //
        static internal Exception Argument(string error) {
            return TraceException(new ArgumentException(error));
        }
        static protected Exception Argument(string error, Exception inner) {
            return TraceException(new ArgumentException(error, inner));
        }
        static protected Exception Argument(string error, string parameter) {
            return TraceException(new ArgumentException(error, parameter));
        }
        static protected Exception Argument(string error, string parameter, Exception inner) {
            return TraceException(new ArgumentException(error, parameter, inner));
        }
        static internal Exception ArgumentNull(string parameter) {
            return TraceException(new ArgumentNullException(parameter));
        }
        static internal Exception ArgumentNull(string parameter, string error) {
            return TraceException(new ArgumentNullException(parameter, error));
        }
        static internal Exception ArgumentOutOfRange(string error) {
            return TraceException(new ArgumentOutOfRangeException(error));
        }
        static internal Exception IndexOutOfRange(string error) {
            return TraceException(new IndexOutOfRangeException(error));
        }
        static protected Exception InvalidCast(string error) {
            return TraceException(new InvalidCastException(error));
        }
        static internal Exception InvalidOperation(string error) {
            return TraceException(new InvalidOperationException(error));
        }
        static protected Exception InvalidOperation(string error, Exception inner) {
            return TraceException(new InvalidOperationException(error, inner));
        }
        static protected Exception NullReference(string error) {
            return TraceException(new NullReferenceException(error));
        }
        static internal Exception NotSupported() {
            return TraceException(new NotSupportedException());
        }
        static internal Exception Overflow(string error) {
            return TraceException(new OverflowException(error));
        }
        static protected Exception Security(string error, Exception inner) {
            return TraceException(new SecurityException(error, inner));
        }
        static protected Exception TypeLoad(string error) {
            return TraceException(new TypeLoadException(error));
        }
        static internal Exception InvalidCast() {
            return TraceException(new InvalidCastException());
        }
        
        static protected Exception Data(string error) {
            return TraceException(new DataException(error));
        }
        static protected Exception Data(string error, Exception inner) {
            return TraceException(new DataException(error, inner));
        }
        static protected Exception DataProvider(string error) {
            return TraceException(new InvalidOperationException(error));
            //return TraceException(new DataProviderException(error));
        }
        static protected Exception DataProvider(string error, Exception inner) {
            return TraceException(new InvalidOperationException(error, inner));
            //return TraceException(new DataProviderException(error, inner));
        }
        static protected Exception DataMapping(string error) {
            return TraceException(new InvalidOperationException(error));
            //return TraceException(new DataMappingException(error));
        }
        static protected Exception DataMapping(string error, Exception inner) {
            return TraceException(new InvalidOperationException(error, inner));
            //return TraceException(new DataMappingException(error, inner));
        }

        //
        // ConnectionStringPermission
        //
        static internal Exception InvalidXMLBadVersion() {
            return Argument(Res.GetString(Res.ADP_InvalidXMLBadVersion));
        }
        static internal Exception NotAPermissionElement() {
            return Argument(Res.GetString(Res.ADP_NotAPermissionElement));
        }
        static internal Exception WrongType(Type type) {
            return Argument(Res.GetString(Res.ADP_WrongType, type.FullName));
        }

        //
        // DBConnectionString, DataAccess
        //
        static internal Exception ConnectionStringSyntax(int index) {
            return Argument(Res.GetString(Res.ADP_ConnectionStringSyntax, index));
        }
        static internal Exception KeywordNotSupported(string keyword) {
            return Argument(Res.GetString(Res.ADP_KeywordNotSupported, keyword));
        }
        static internal Exception UdlFileError(Exception inner) {
            return Argument(Res.GetString(Res.ADP_UdlFileError), inner); // MDAC 80882
        }
        static internal Exception InvalidUDL() {
            return Argument(Res.GetString(Res.ADP_InvalidUDL)); // MDAC 80882
        }

        //
        // : DBConnectionString, DataAccess, SqlClient
        //
        static internal Exception InvalidConnectionOptionValue(string key) {
            return InvalidConnectionOptionValue(key, null);
        }
        static internal Exception InvalidConnectionOptionValue(string key, Exception inner) {
            return Argument(Res.GetString(Res.ADP_InvalidConnectionOptionValue, key), inner);
        }
        
        //
        // Generic Data Provider Collection
        //
        static internal Exception CollectionUniqueValue(Type itemType, string propertyName, string propertyValue) {
            return Argument(Res.GetString(Res.ADP_CollectionUniqueValue, itemType.Name, propertyName, propertyValue));
        }
        static internal Exception CollectionIsNotParent(Type itemType, string propertyName, string propertyValue, Type collection) {
            return Argument(Res.GetString(Res.ADP_CollectionIsNotParent, itemType.Name, propertyName, propertyValue, collection.Name));
        }
        static internal Exception CollectionIsParent(Type itemType, string propertyName, string propertyValue, Type collection) {
            return Argument(Res.GetString(Res.ADP_CollectionIsParent, itemType.Name, propertyName, propertyValue, collection.Name));
        }
        static internal Exception CollectionRemoveInvalidObject(Type itemType, ICollection collection) {
            return Argument(Res.GetString(Res.ADP_CollectionRemoveInvalidObject, itemType.Name, collection.GetType().Name)); // MDAC 68201
        }
        static internal Exception CollectionNullValue(string parameter, Type collection, Type itemType) {
            return ArgumentNull(parameter, Res.GetString(Res.ADP_CollectionNullValue, collection.Name, itemType.Name));
        }
        static internal Exception CollectionIndexInt32(int index, Type collection, int count) {
            return IndexOutOfRange(Res.GetString(Res.ADP_CollectionIndexInt32, index.ToString(), collection.Name, count.ToString()));
        }
        static internal Exception CollectionIndexString(Type itemType, string propertyName, string propertyValue, Type collection) {
            return IndexOutOfRange(Res.GetString(Res.ADP_CollectionIndexString, itemType.Name, propertyName, propertyValue, collection.Name));
        }
        static internal Exception CollectionInvalidType(Type collection, Type itemType, object invalidValue) {
            return InvalidCast(Res.GetString(Res.ADP_CollectionInvalidType, collection.Name, itemType.Name, invalidValue.GetType().Name));
        }

        //
        // DataColumnMapping
        //
        static internal Exception NullDataTable(string parameter) {
            return ArgumentNull(parameter, Res.GetString(Res.ADP_NullDataTable));
        }
        static internal Exception ColumnSchemaExpression(string srcColumn, string cacheColumn) {
            return DataMapping(Res.GetString(Res.ADP_ColumnSchemaExpression, srcColumn, cacheColumn));
        }
        static internal Exception ColumnSchemaMismatch(string srcColumn, Type srcType, DataColumn column) {
            return DataMapping(Res.GetString(Res.ADP_ColumnSchemaMismatch, srcColumn, srcType.Name, column.ColumnName, column.DataType.Name));
        }
        static internal Exception ColumnSchemaMissing(string cacheColumn, string tableName, string srcColumn) {
            if (ADP.IsEmpty(tableName)) {
                return DataMapping(Res.GetString(Res.ADP_ColumnSchemaMissing1, cacheColumn, tableName, srcColumn));
            }
            return DataMapping(Res.GetString(Res.ADP_ColumnSchemaMissing2, cacheColumn, tableName, srcColumn));
        }

        //
        // DataColumnMappingCollection
        //
        static internal Exception InvalidSourceColumn(string parameter) {
            return Argument(Res.GetString(Res.ADP_InvalidSourceColumn), parameter);
        }
        static internal Exception MissingColumnMapping(string srcColumn) {
            return DataMapping(Res.GetString(Res.ADP_MissingColumnMapping, srcColumn));
        }
        static internal Exception ColumnsUniqueSourceColumn(string srcColumn) {
            return CollectionUniqueValue(typeof(DataColumnMapping), ADP.SourceColumn, srcColumn);
        }
        static internal Exception ColumnsAddNullAttempt(string parameter) {
            return CollectionNullValue(parameter, typeof(DataColumnMappingCollection), typeof(DataColumnMapping));
        }
        static internal Exception ColumnsDataSetColumn(string cacheColumn) {
            return CollectionIndexString(typeof(DataColumnMapping), ADP.DataSetColumn, cacheColumn, typeof(DataColumnMappingCollection));
        }
        static internal Exception ColumnsIndexInt32(int index, IColumnMappingCollection collection) {
            return CollectionIndexInt32(index, collection.GetType(), collection.Count);
        }
        static internal Exception ColumnsIndexSource(string srcColumn) {
            return CollectionIndexString(typeof(DataColumnMapping), ADP.SourceColumn, srcColumn, typeof(DataColumnMappingCollection));
        }
        static internal Exception ColumnsIsNotParent(string srcColumn) {
            return CollectionIsNotParent(typeof(DataColumnMapping), ADP.SourceColumn, srcColumn, typeof(DataColumnMappingCollection));
        }
        static internal Exception ColumnsIsParent(string srcColumn) {
            return CollectionIsParent(typeof(DataColumnMapping), ADP.SourceColumn, srcColumn, typeof(DataColumnMappingCollection));
        }
        static internal Exception NotADataColumnMapping(object value) {
            return CollectionInvalidType(typeof(DataColumnMappingCollection), typeof(DataColumnMapping), value);
        }

        //
        // DataAdapter
        //
        static internal Exception InvalidMappingAction(int value) {
            return Argument(Res.GetString(Res.ADP_InvalidMappingAction, value.ToString()));
        }
        static internal Exception InvalidSchemaAction(int value) {
            return Argument(Res.GetString(Res.ADP_InvalidSchemaAction, value.ToString()));
        }

        //
        // DataTableMapping
        //
        static internal Exception MissingTableSchema(string cacheTable, string srcTable) {
            return DataMapping(Res.GetString(Res.ADP_MissingTableSchema, cacheTable, srcTable));
        }
        static internal Exception NullDataSet(string parameter) {
            return ArgumentNull(parameter, Res.GetString(Res.ADP_NullDataSet));
        }

        //
        // DataTableMappingCollection
        //
        static internal Exception InvalidSourceTable(string parameter) {
            return Argument(Res.GetString(Res.ADP_InvalidSourceTable), parameter);
        }
        static internal Exception MissingTableMapping(string srcTable) {
            return DataMapping(Res.GetString(Res.ADP_MissingTableMapping, srcTable));
        }
        static internal Exception TablesUniqueSourceTable(string srcTable) {
            return CollectionUniqueValue(typeof(DataTableMapping), ADP.SourceTable, srcTable);
        }
        static internal Exception TablesAddNullAttempt(string parameter) {
            return CollectionNullValue(parameter, typeof(DataTableMappingCollection), typeof(DataTableMapping));
        }
        static internal Exception TablesDataSetTable(string cacheTable) {
            return CollectionIndexString(typeof(DataTableMapping), ADP.DataSetTable, cacheTable, typeof(DataTableMappingCollection));
        }
        static internal Exception TablesIndexInt32(int index, ITableMappingCollection collection) {
            return CollectionIndexInt32(index, collection.GetType(), collection.Count);
        }
        static internal Exception TablesSourceIndex(string srcTable) {
            return CollectionIndexString(typeof(DataTableMapping), ADP.SourceTable, srcTable, typeof(DataTableMappingCollection));
        }
        static internal Exception TablesIsNotParent(string srcTable) {
            return CollectionIsNotParent(typeof(DataTableMapping), ADP.SourceTable, srcTable, typeof(DataTableMappingCollection));
        }
        static internal Exception TablesIsParent(string srcTable) {
            return CollectionIsParent(typeof(DataTableMapping), ADP.SourceTable, srcTable, typeof(DataTableMappingCollection));
        }
        static internal Exception NotADataTableMapping(object value) {
            return CollectionInvalidType(typeof(DataTableMappingCollection), typeof(DataTableMapping), value);
        }

        //
        // IDbCommand
        //
        static internal Exception InvalidCommandType(CommandType cmdType) {
            return Argument(Res.GetString(Res.ADP_InvalidCommandType, ((int) cmdType).ToString()));
        }
        static internal Exception InvalidUpdateRowSource(int rowsrc) {
            return Argument(Res.GetString(Res.ADP_InvalidUpdateRowSource, rowsrc.ToString()));
        }
        static internal Exception CommandTextRequired(string method) {
#if DEBUG
            switch(method) {
            case ADP.ExecuteReader:
            case ADP.ExecuteNonQuery:
            case ADP.ExecuteScalar:
            case ADP.Prepare:
            case ADP.DeriveParameters:
                break;
            default:
                Debug.Assert(false, "unexpected method: " + method);
                break;
            }
#endif
            return InvalidOperation(Res.GetString(Res.ADP_CommandTextRequired, method));
        }
        static internal Exception ConnectionIsDead (Exception InnerException) {
            return InvalidOperation(Res.GetString(Res.ADP_ConnectionIsDead), InnerException);
        }
        static internal Exception ConnectionRequired(string method) {
            string resource = "ADP_ConnectionRequired_" + method;
#if DEBUG
            switch(resource) {
            case Res.ADP_ConnectionRequired_Cancel:
            case Res.ADP_ConnectionRequired_ExecuteReader:
            case Res.ADP_ConnectionRequired_ExecuteNonQuery:
            case Res.ADP_ConnectionRequired_ExecuteScalar:
            case Res.ADP_ConnectionRequired_Prepare:
            case Res.ADP_ConnectionRequired_PropertyGet:
            case Res.ADP_ConnectionRequired_PropertySet:
            case Res.ADP_ConnectionRequired_DeriveParameters:
            case Res.ADP_ConnectionRequired_FillSchema:
            case Res.ADP_ConnectionRequired_Fill:
            case Res.ADP_ConnectionRequired_Select:
            case Res.ADP_ConnectionRequired_Insert:
            case Res.ADP_ConnectionRequired_Update:
            case Res.ADP_ConnectionRequired_Delete:
            case Res.ADP_ConnectionRequired_Clone:
                break;
            default:
                Debug.Assert(false, "missing resource string: " + resource);
                break;
            }
#endif
            return InvalidOperation(Res.GetString(resource, method));
        }
        static internal Exception NoStoredProcedureExists(string sproc) {
            return InvalidOperation(Res.GetString(Res.ADP_NoStoredProcedureExists, sproc));
        }
        static internal Exception OpenConnectionRequired(string method, ConnectionState state) {
            string resource = "ADP_OpenConnectionRequired_" + method;
#if DEBUG
            switch(resource) {
            case Res.ADP_OpenConnectionRequired_BeginTransaction:
            case Res.ADP_OpenConnectionRequired_CommitTransaction:
            case Res.ADP_OpenConnectionRequired_RollbackTransaction:
            case Res.ADP_OpenConnectionRequired_SaveTransaction:
            case Res.ADP_OpenConnectionRequired_ChangeDatabase:
            case Res.ADP_OpenConnectionRequired_Cancel:
            case Res.ADP_OpenConnectionRequired_ExecuteReader:
            case Res.ADP_OpenConnectionRequired_ExecuteNonQuery:
            case Res.ADP_OpenConnectionRequired_ExecuteScalar:
            case Res.ADP_OpenConnectionRequired_Prepare:
            case Res.ADP_OpenConnectionRequired_PropertyGet:
            case Res.ADP_OpenConnectionRequired_PropertySet:
            case Res.ADP_OpenConnectionRequired_DeriveParameters:
            case Res.ADP_OpenConnectionRequired_FillSchema:
            case Res.ADP_OpenConnectionRequired_Fill:
            case Res.ADP_OpenConnectionRequired_Select:
            case Res.ADP_OpenConnectionRequired_Insert:
            case Res.ADP_OpenConnectionRequired_Update:
            case Res.ADP_OpenConnectionRequired_Delete:
            case Res.ADP_OpenConnectionRequired_Clone:
                break;
            default:
                Debug.Assert(false, "missing resource string: " + resource);
                break;
            }
#endif
            return InvalidOperation(Res.GetString(resource, method, state.ToString("G")));
        }
        static internal Exception OpenReaderExists() {
            return InvalidOperation(Res.GetString(Res.ADP_OpenReaderExists));
        }
        static internal Exception TransactionConnectionMismatch() {
            return InvalidOperation(Res.GetString(Res.ADP_TransactionConnectionMismatch));
        }
        static internal Exception TransactionRequired() {
            return InvalidOperation(Res.GetString(Res.ADP_TransactionRequired_Execute));
        }
        static internal Exception TransactionCompleted() {
            return InvalidOperation(Res.GetString(Res.ADP_TransactionCompleted));
        }

        //
        // DbDataAdapter
        //
        static internal Exception MissingSelectCommand(string method) {
            return InvalidOperation(Res.GetString(Res.ADP_MissingSelectCommand, method));
        }
        static internal Exception NonSequentialColumnAccess(int badCol, int currCol) {
            return InvalidOperation(Res.GetString(Res.ADP_NonSequentialColumnAccess, badCol.ToString(), currCol.ToString()));
        }

        //
        // DbDataAdapter.FillSchema
        //
        static internal Exception InvalidSchemaType(int value) {
            return Argument(Res.GetString(Res.ADP_InvalidSchemaType, value.ToString()));
        }
        static internal Exception FillSchemaRequires(string parameter) {
            return ArgumentNull(parameter);
        }
        static internal Exception FillSchemaRequiresSourceTableName(string parameter) {
            return Argument(Res.GetString(Res.ADP_FillSchemaRequiresSourceTableName), parameter);
        }

        //
        // DbDataAdapter.Fill
        //
        static internal Exception InvalidMaxRecords(string parameter, int max) {
            return Argument(Res.GetString(Res.ADP_InvalidMaxRecords, (max).ToString()), parameter);
        }
        static internal Exception InvalidStartRecord(string parameter, int start) {
            return Argument(Res.GetString(Res.ADP_InvalidStartRecord, (start).ToString()), parameter);
        }
        static internal Exception FillRequires(string parameter) {
            return ArgumentNull(parameter);
        }
        static internal Exception FillRequiresSourceTableName(string parameter) {
            return Argument(Res.GetString(Res.ADP_FillRequiresSourceTableName), parameter);
        }
        static internal Exception FillChapterAutoIncrement() {
            return InvalidOperation(Res.GetString(Res.ADP_FillChapterAutoIncrement));
        }

        //
        // DbDataAdapter.Update
        //
        static internal Exception UpdateRequiresNonNullDataSet(string parameter) {
            return ArgumentNull(parameter);
        }
        static internal Exception UpdateRequiresSourceTable(string defaultSrcTableName) {
            return InvalidOperation(Res.GetString(Res.ADP_UpdateRequiresSourceTable, defaultSrcTableName));
        }
        static internal Exception UpdateRequiresSourceTableName(string srcTable) {
            return InvalidOperation(Res.GetString(Res.ADP_UpdateRequiresSourceTableName, srcTable)); // MDAC 70448
        }
        static internal Exception UpdateRequiresDataTable(string parameter) {
            return ArgumentNull(parameter);
        }
        static internal Exception MissingTableMappingDestination(string dstTable) {
            return DataMapping(Res.GetString(Res.ADP_MissingTableMappingDestination, dstTable));
        }
        static internal Exception InvalidUpdateStatus(int status) {
            return Argument(Res.GetString(Res.ADP_InvalidUpdateStatus, status.ToString()));
        }
        static internal Exception UpdateConcurrencyViolation(StatementType statementType, DataRow dataRow) {
            string resource = "ADP_UpdateConcurrencyViolation_" + statementType.ToString("G");
#if DEBUG
            switch(resource) {
            case Res.ADP_UpdateConcurrencyViolation_Update:
            case Res.ADP_UpdateConcurrencyViolation_Delete:
                break;
            default:
                Debug.Assert(false, "missing resource string: " + resource);
                break;
            }
#endif
            DBConcurrencyException exception = new DBConcurrencyException(Res.GetString(resource));
            exception.Row = dataRow;
            return TraceException(exception);
        }
        static internal Exception UpdateRequiresCommand(string commandType) {
            string resource = "ADP_UpdateRequiresCommand" + commandType;
#if DEBUG
            switch(resource) {
            case Res.ADP_UpdateRequiresCommandClone:
            case Res.ADP_UpdateRequiresCommandSelect:
            case Res.ADP_UpdateRequiresCommandInsert:
            case Res.ADP_UpdateRequiresCommandUpdate:
            case Res.ADP_UpdateRequiresCommandDelete:
                break;
            default:
                Debug.Assert(false, "missing resource string: " + resource);
                break;
            }
#endif
            return InvalidOperation(Res.GetString(resource));
        }
        static internal Exception UpdateUnknownRowState(int rowState) {
            return InvalidOperation(Res.GetString(Res.ADP_UpdateUnknownRowState, rowState.ToString()));
        }
        static internal Exception UpdateNullRow(int i) {
            return Argument(Res.GetString(Res.ADP_UpdateNullRow, i.ToString()));
        }
        static internal Exception UpdateNullRowTable() {
            return Argument(Res.GetString(Res.ADP_UpdateNullRowTable));
        }
        static internal Exception UpdateMismatchRowTable(int i) {
            return Argument(Res.GetString(Res.ADP_UpdateMismatchRowTable, i.ToString()));
        }
        static internal Exception RowUpdatedErrors() {
            return Data(Res.GetString(Res.ADP_RowUpdatedErrors));
        }
        static internal Exception RowUpdatingErrors() {
            return Data(Res.GetString(Res.ADP_RowUpdatingErrors));
        }

        //
        // : IDbCommand
        //
        static internal Exception InvalidCommandTimeout(int value) {
            return Argument(Res.GetString(Res.ADP_InvalidCommandTimeout, value.ToString()));
        }
        static internal Exception DeriveParametersNotSupported(IDbCommand value) {
            return DataProvider(Res.GetString(Res.ADP_DeriveParametersNotSupported, value.GetType().Name, value.CommandType.ToString("G")));
        }
        static internal Exception CommandIsActive(IDbCommand cmd, ConnectionState state) {
            return InvalidOperation(Res.GetString(Res.ADP_CommandIsActive, cmd.GetType().Name, state.ToString("G")));
        }
        static internal Exception UninitializedParameterSize(int index, string name, Type dataType, int size) {
            return InvalidOperation(Res.GetString(Res.ADP_UninitializedParameterSize, index.ToString(), name, dataType.Name, size.ToString()));
        }
        static internal Exception PrepareParameterType(IDbCommand cmd) {
            return InvalidOperation(Res.GetString(Res.ADP_PrepareParameterType, cmd.GetType().Name));
        }
        static internal Exception PrepareParameterSize(IDbCommand cmd) {
            return InvalidOperation(Res.GetString(Res.ADP_PrepareParameterSize, cmd.GetType().Name));
        }
        static internal Exception PrepareParameterScale(IDbCommand cmd, string type) {
            return InvalidOperation(Res.GetString(Res.ADP_PrepareParameterScale, cmd.GetType().Name, type));
        }        

        //
        // : IDbConnection
        //
        static internal Exception ClosedConnectionError() {
            return InvalidOperation(Res.GetString(Res.ADP_ClosedConnectionError));
        }
        static internal Exception ConnectionAlreadyOpen(ConnectionState state) {
            return InvalidOperation(Res.GetString(Res.ADP_ConnectionAlreadyOpen, state.ToString("G")));
        }
        static internal Exception LocalTransactionPresent() {
            return InvalidOperation(Res.GetString(Res.ADP_LocalTransactionPresent));
        }
        static internal Exception NoConnectionString() {
            return InvalidOperation(Res.GetString(Res.ADP_NoConnectionString));
        }
        static internal Exception OpenConnectionPropertySet(string property, ConnectionState state) {
            return InvalidOperation(Res.GetString(Res.ADP_OpenConnectionPropertySet, property, state.ToString("G")));
        }
        static internal Exception EmptyDatabaseName() {
            return Argument(Res.GetString(Res.ADP_EmptyDatabaseName));
        }
        static internal Exception InvalidConnectTimeoutValue() {
            return Argument(Res.GetString(Res.ADP_InvalidConnectTimeoutValue));
        }
        static internal Exception InvalidIsolationLevel(int isoLevel) {
            return Argument(Res.GetString(Res.ADP_InvalidIsolationLevel, isoLevel.ToString()));
        }

        //
        // : DBDataReader
        //
        static internal Exception InvalidSourceBufferIndex(int maxLen, long srcOffset) {
            return ArgumentOutOfRange(Res.GetString(Res.ADP_InvalidSourceBufferIndex, maxLen.ToString(), srcOffset.ToString()));
        }
        static internal Exception InvalidDestinationBufferIndex(int maxLen, int dstOffset) {
            return ArgumentOutOfRange(Res.GetString(Res.ADP_InvalidDestinationBufferIndex, maxLen.ToString(), dstOffset.ToString()));
        }
        static internal Exception InvalidBufferSizeOrIndex(int numBytes, int bufferIndex) {
            return IndexOutOfRange(Res.GetString(Res.ADP_InvalidBufferSizeOrIndex, numBytes.ToString(), bufferIndex.ToString()));
        }
        static internal Exception InvalidDataLength(long length) {
            return IndexOutOfRange(Res.GetString(Res.ADP_InvalidDataLength, length.ToString()));
        }
        static internal Exception DataReaderNoData() {
            return InvalidOperation(Res.GetString(Res.ADP_DataReaderNoData));
        }
        static internal Exception DataReaderClosed(string method) {
            return InvalidOperation(Res.GetString(Res.ADP_DataReaderClosed, method));
        }
        static internal Exception NonSeqByteAccess(long badIndex, long currIndex, string method) {
            return InvalidOperation(Res.GetString(Res.ADP_NonSeqByteAccess, badIndex.ToString(), currIndex.ToString(), method));
        }



        //
        // : Stream
        //
        static internal Exception StreamClosed(string method) {
            return InvalidOperation(Res.GetString(Res.ADP_StreamClosed, method));
        }

        //
        // : DbDataAdapter
        //
        static internal Exception DynamicSQLJoinUnsupported() {
            return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLJoinUnsupported));
        }
        static internal Exception DynamicSQLNoTableInfo() {
            return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLNoTableInfo));
        }
        static internal Exception DynamicSQLNoKeyInfo(string command) {
            return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLNoKeyInfo, command));
        }
        static internal Exception DynamicSQLReadOnly(string command) {
            return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLReadOnly, command));
        }
        static internal Exception DynamicSQLNestedQuote(string name, string quote) {
            return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLNestedQuote, name, quote));
        }
        static internal Exception NoQuoteChange() {
            return InvalidOperation(Res.GetString(Res.ADP_NoQuoteChange));
        }
        static internal Exception MissingSourceCommand() {
            return InvalidOperation(Res.GetString(Res.ADP_MissingSourceCommand));
        }
        static internal Exception MissingSourceCommandConnection() {
            return InvalidOperation(Res.GetString(Res.ADP_MissingSourceCommandConnection));
        }

        //
        // : IDataParameter
        //
        static internal Exception InvalidDataRowVersion(string param, int value) {
            return Argument(Res.GetString(Res.ADP_InvalidDataRowVersion, param, value.ToString()));
        }
        static internal Exception InvalidParameterDirection(int value, string parameterName) {
            return Argument(Res.GetString(Res.ADP_InvalidParameterDirection, value.ToString(), parameterName));
        }
        static internal Exception InvalidDataType(TypeCode typecode) {
            return Argument(Res.GetString(Res.ADP_InvalidDataType, typecode.ToString("G")));
        }
        static internal Exception UnknownDataType(Type dataType) {
            return Argument(Res.GetString(Res.ADP_UnknownDataType, dataType.FullName));
        }
        static internal Exception DbTypeNotSupported(System.Data.DbType type, Type enumtype) {
            return Argument(Res.GetString(Res.ADP_UnknownDataType, type.ToString("G"), enumtype.Name));
        }

        static internal Exception UnknownDataTypeCode(Type dataType, TypeCode typeCode) {
            return Argument(Res.GetString(Res.ADP_UnknownDataTypeCode, ((int) typeCode).ToString( dataType.FullName)));
        }
        static internal Exception InvalidSizeValue(int value) {
            return Argument(Res.GetString(Res.ADP_InvalidSizeValue, value.ToString()));
        }
        static internal Exception WhereClauseUnspecifiedValue(string parameterName, string sourceColumn, string columnName) {
            return InvalidOperation(Res.GetString(Res.ADP_WhereClauseUnspecifiedValue, parameterName, sourceColumn, columnName));
        }
        static internal Exception TruncatedBytes(int len) {
            return InvalidOperation(Res.GetString(Res.ADP_TruncatedBytes, len.ToString()));
        }
        static internal Exception TruncatedString(int maxLen, int len, string value) {
            return InvalidOperation(Res.GetString(Res.ADP_TruncatedString, maxLen.ToString(), len.ToString(), value));
        }

        //
        // : IDataParameterCollection
        //
        static internal Exception ParametersIsNotParent(Type parameterType, string parameterName, IDataParameterCollection collection) {
            return CollectionIsNotParent(parameterType, ADP.ParameterName, parameterName, collection.GetType());
        }
        static internal Exception ParametersIsParent(Type parameterType, string parameterName, IDataParameterCollection collection) {
            return CollectionIsParent(parameterType, ADP.ParameterName, parameterName, collection.GetType());
        }
        static internal Exception ParametersMappingIndex(int index, IDataParameterCollection collection) {
            return CollectionIndexInt32(index, collection.GetType(), collection.Count);
        }
        static internal Exception ParametersSourceIndex(string parameterName, IDataParameterCollection collection, Type parameterType) {
            return CollectionIndexString(parameterType, ADP.ParameterName, parameterName, collection.GetType());
        }
        static internal Exception ParameterNull(string parameter, IDataParameterCollection collection, Type parameterType) {
            return CollectionNullValue(parameter, collection.GetType(), parameterType);
        }
        static internal Exception InvalidParameterType(IDataParameterCollection collection, Type parameterType, object invalidValue) {
            return CollectionInvalidType(collection.GetType(), parameterType, invalidValue);
        }

        //
        // : IDbTransaction
        //
        static internal Exception ParallelTransactionsNotSupported(IDbConnection obj) {
            return InvalidOperation(Res.GetString(Res.ADP_ParallelTransactionsNotSupported, obj.GetType().Name));
        }
        static internal Exception TransactionZombied(IDbTransaction obj) {
            return InvalidOperation(Res.GetString(Res.ADP_TransactionZombied, obj.GetType().Name));
        }

        //
        // Helper Functions
        //
        static internal void CheckArgumentLength(string value, string parameterName) {
            CheckArgumentNull(value, parameterName);
            if (0 == value.Length) {
                throw Argument("0 == "+parameterName+".Length", parameterName);
            }
        }
        static internal void CheckArgumentLength(Array value, string parameterName) {
            CheckArgumentNull(value, parameterName);
            if (0 == value.Length) {
                throw Argument("0 == "+parameterName+".Length", parameterName);
            }
        }
        static internal void CheckArgumentNull(object value, string parameterName) {
            if (null == value) {
                throw ArgumentNull(parameterName);
            }
        }

		static internal void CopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int length) {
			Buffer.BlockCopy(src, ADP.CharSize*srcOffset, dst, ADP.CharSize*dstOffset, ADP.CharSize*length);
        }

        static internal void SafeDispose(IDisposable value) {
            if (null != value) {
                value.Dispose();
            }
        }
        
        // flush the ConnectionString cache when it reaches a certain size
        public const int MaxConnectionStringCacheSize = 250; // MDAC 68200

        static internal readonly object EventRowUpdated = new object(); 
        static internal readonly object EventRowUpdating = new object(); 

        static internal readonly object EventInfoMessage = new object();
        static internal readonly object EventStateChange = new object();

        // global constant strings
        internal const string BeginTransaction = "BeginTransaction";
        internal const string ChangeDatabase = "ChangeDatabase";
        internal const string Cancel = "Cancel";
        internal const string Clone = "Clone";
        internal const string CommitTransaction = "CommitTransaction";
        internal const string ConnectionString = "ConnectionString";
        internal const string DataSetColumn = "DataSetColumn";
        internal const string DataSetTable = "DataSetTable";
        internal const string Delete = "Delete";
        internal const string DeleteCommand = "DeleteCommand";
        internal const string DeriveParameters = "DeriveParameters";
        internal const string ExecuteReader = "ExecuteReader";
        internal const string ExecuteNonQuery = "ExecuteNonQuery";
        internal const string ExecuteScalar = "ExecuteScalar";
        internal const string ExecuteXmlReader = "ExecuteXmlReader";
        internal const string Fill = "Fill";
        internal const string FillSchema = "FillSchema";
        internal const string GetBytes = "GetBytes";
        internal const string GetChars = "GetChars";
        internal const string Insert = "Insert";
        internal const string Parameter = "Parameter";
        internal const string ParameterName = "ParameterName";
        internal const string Prepare = "Prepare";
        internal const string Remove = "Remove";
        internal const string RollbackTransaction = "RollbackTransaction";
        internal const string SaveTransaction = "SaveTransaction";
        internal const string Select = "Select";
        internal const string SelectCommand = "SelectCommand";
        internal const string SourceColumn = "SourceColumn";
        internal const string SourceVersion = "SourceVersion";
        internal const string SourceTable = "SourceTable";
        internal const string Update = "Update";
        internal const string UpdateCommand = "UpdateCommand";

        internal const CompareOptions compareOptions = CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth | CompareOptions.IgnoreCase;
        internal const int DefaultCommandTimeout = 30;
        internal const int DefaultConnectionTimeout = 15;
        static internal readonly IntPtr InvalidIntPtr = new IntPtr(-1); // use for INVALID_HANDLE

        // security issue, don't rely upon public static readonly values - AS/URT 109635
        static internal readonly String StrEmpty = ""; // String.Empty

        static internal readonly IntPtr PtrZero = new IntPtr(0); // IntPtr.Zero
        static internal readonly int    PtrSize = IntPtr.Size;

        static internal readonly HandleRef NullHandle = new HandleRef(null, PtrZero);
        
        static internal readonly int CharSize = System.Text.UnicodeEncoding.CharSize;

        static internal readonly byte[] EmptyByteArray = new Byte[0];

        static internal DataTable CreateSchemaTable(DataTable schemaTable, int capacity) {
            if (null == schemaTable) {
                schemaTable = new DataTable("SchemaTable");
                if (0 < capacity) {
                    schemaTable.MinimumCapacity = capacity;
                }
            }
            DataColumnCollection columns = schemaTable.Columns;

            AddColumn(columns, null, "ColumnName",   typeof(System.String));
            AddColumn(columns,    0, "ColumnOrdinal", typeof(System.Int32)); // UInt32

            AddColumn(columns, null, "ColumnSize", typeof(System.Int32)); // UInt32
            AddColumn(columns, null, "NumericPrecision", typeof(System.Int16)); // UInt16
            AddColumn(columns, null, "NumericScale", typeof(System.Int16));

            // add these ahead of time
            AddColumn(columns, null, "IsUnique", typeof(System.Boolean));
            AddColumn(columns, null, "IsKey", typeof(System.Boolean));
            AddColumn(columns, null, "BaseServerName", typeof(System.String));
            AddColumn(columns, null, "BaseCatalogName", typeof(System.String));
            AddColumn(columns, null, "BaseColumnName", typeof(System.String));
            AddColumn(columns, null, "BaseSchemaName", typeof(System.String));
            AddColumn(columns, null, "BaseTableName", typeof(System.String));

            AddColumn(columns, null, "DataType", typeof(System.Object));
            AddColumn(columns, null, "AllowDBNull", typeof(System.Boolean));
            AddColumn(columns, null, "ProviderType", typeof(System.Int32));
            AddColumn(columns, null, "IsAliased", typeof(System.Boolean));
            AddColumn(columns, null, "IsExpression", typeof(System.Boolean));
            AddColumn(columns, null, "IsIdentity", typeof(System.Boolean));
            AddColumn(columns, null, "IsAutoIncrement", typeof(System.Boolean));
            AddColumn(columns, null, "IsRowVersion", typeof(System.Boolean));
            AddColumn(columns, null, "IsHidden", typeof(System.Boolean));
            AddColumn(columns,false, "IsLong", typeof(System.Boolean));
            AddColumn(columns, null, "IsReadOnly", typeof(System.Boolean));

            return schemaTable;
        }

        static private void AddColumn(DataColumnCollection columns, object defaultValue, string name, Type type) {
            if (!columns.Contains(name)) {
                DataColumn tmp = new DataColumn(name, type);
                if (null != defaultValue) {
                    tmp.DefaultValue = defaultValue;
                }
                columns.Add(tmp);
            }
        }

        static internal DataRow[] SelectRows(DataTable dataTable, DataViewRowState rowStates) {
            // equivalent to but faster than 'return dataTable.Select("", "", rowStates);'
            int count = 0;
            DataRowCollection rows = dataTable.Rows;
            int rowCount = rows.Count;
            for (int i = 0; i < rowCount; ++i) {
                if (0 != ((int)rowStates & (int) rows[i].RowState)) {
                    count++;
                }
            }
            DataRow[] dataRows = new DataRow[count];

            if (0 < count) {
                int index = 0;
                for (int i = 0; index < count; ++i) {
                    if (0 != ((int)rowStates & (int) rows[i].RowState)) {
                        dataRows[index++] = rows[i];
                    }
                }
            }
            Debug.Assert(null != dataRows, "SelectRows: null return value");
            return dataRows;
        }

        // { "a", "a", "a" } -> { "a", "a1", "a2" }
        // { "a", "a", "a1" } -> { "a", "a2", "a1" }
        // { "a", "A", "a" } -> { "a", "A1", "a2" }
        // { "a", "A", "a1" } -> { "a", "A2", "a1" } // MDAC 66718
        static internal void BuildSchemaTableInfoTableNames(string[] columnNameArray) {
            int length = columnNameArray.Length;
            Hashtable hash = new Hashtable(length);

            int startIndex = length; // lowest non-unique index
            for (int i = length - 1; 0 <= i; --i) {
                string columnName = columnNameArray[i];
                if ((null != columnName) && (0 < columnName.Length)) {
                    columnName = columnName.ToLower(CultureInfo.InvariantCulture);
                    if (hash.Contains(columnName)) {
                        startIndex = Math.Min(startIndex, (int) hash[columnName]);
                    }
                    hash[columnName] = i;
                }
                else {
                    columnNameArray[i] = ""; // MDAC 66681
                    startIndex = i;
                }
            }
            int uniqueIndex = 1;
            for (int i = startIndex; i < length; ++i) {
                string columnName = columnNameArray[i];
                if (0 == columnName.Length) { // generate a unique name
                    columnNameArray[i] = "Column";
                    uniqueIndex = GenerateUniqueName(hash, ref columnNameArray[i], i, uniqueIndex);
                }
                else {
                    columnName = columnName.ToLower(CultureInfo.InvariantCulture);
                    if (i != (int) hash[columnName]) {
                        GenerateUniqueName(hash, ref columnNameArray[i], i, 1); // MDAC 66718
                    }
                }
            }
        }

        static private int GenerateUniqueName(Hashtable hash, ref string columnName, int index, int uniqueIndex) {
            for (;; ++uniqueIndex) {
                string uniqueName = columnName + uniqueIndex.ToString();
                string lowerName = uniqueName.ToLower(CultureInfo.InvariantCulture); // MDAC 66978
                if (!hash.Contains(lowerName)) {

                    columnName = uniqueName;
                    hash.Add(lowerName, index);
                    break;
                }
            }
            return uniqueIndex;
        }

        static internal string GetFullPath(string filename) { // MDAC 77686
            try { // try-filter-finally so and catch-throw
                FileIOPermission fiop = new FileIOPermission(PermissionState.None);
                fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
                fiop.Assert();
                try {
                    return Path.GetFullPath(filename);
                }
                finally { // RevertAssert w/ catch-throw
                    FileIOPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }

        static internal FileVersionInfo GetVersionInfo(string filename) {            
            try { // try-filter-finally so and catch-throw
                (new FileIOPermission(FileIOPermissionAccess.Read, filename)).Assert(); // MDAC 62038
                try {
                    return FileVersionInfo.GetVersionInfo(filename); // MDAC 60411
                }
                finally { // RevertAssert w/ catch-throw
                    FileIOPermission.RevertAssert();
                }
            }
            catch {  // MDAC 80973, 81286
                throw;
            }
        }

        static internal object ClassesRootRegistryValue(string subkey, string queryvalue) { // MDAC 77697
            try { // try-filter-finally so and catch-throw
                (new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_CLASSES_ROOT\\" + subkey)).Assert(); // MDAC 62028
                try {
                    using(RegistryKey key = Registry.ClassesRoot.OpenSubKey(subkey, false)) {
                        return ((null != key) ? key.GetValue(queryvalue) : null);
                    }
                }
                finally { // RevertAssert w/ catch-throw
                    RegistryPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }

        static internal object LocalMachineRegistryValue(string subkey, string queryvalue) { // MDAC 77697
            try { // try-filter-finally so and catch-throw
                (new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\" + subkey)).Assert(); // MDAC 62028
                try {
                    using(RegistryKey key = Registry.LocalMachine.OpenSubKey(subkey, false)) {
                        return ((null != key) ? key.GetValue(queryvalue) : null);
                    }
                }
                finally { // RevertAssert w/ catch-throw
                    RegistryPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }

        static internal IntPtr IntPtrOffset(IntPtr pbase, Int32 offset) {
            if (4 == IntPtr.Size) {
                return (IntPtr) (pbase.ToInt32() + offset);
            }
            Debug.Assert(8 == IntPtr.Size, "8 != IntPtr.Size"); // MDAC 73747
            return (IntPtr) (pbase.ToInt64() + offset);
        }
        
        static internal int SrcCompare(string strA, string strB) { // this is null safe
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, CompareOptions.None);
        }

        static internal int DstCompare(string strA, string strB) { // this is null safe
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, ADP.compareOptions);
        }

        static internal bool IsEmpty(string str) {
            return ((null == str) || (0 == str.Length));
        }

        static internal bool IsEmpty(string[] array) {
            return ((null == array) || (0 == array.Length));
        }

        static internal bool IsNull(object value) {
            return ((null == value) || Convert.IsDBNull(value) || ((value is INullable) && (value as INullable).IsNull));
        }

        static internal string[] ParseProcedureName(string procedure) { // MDAC 70930, 70932
            // Procedure may consist of up to four parts:
            // 0) Server
            // 1) Catalog
            // 2) Schema
            // 3) ProcedureName

            // Parse the string into four parts, allowing the last part to contain '.'s.
            // If less than four period delimited parts, use the parts from procedure backwards.

            string[] restrictions = new string[4];

            if (!IsEmpty(procedure)) {
                int index = 0;
                for (int offset = 0, periodOffset = 0; index < 4; index++) {
                    periodOffset = procedure.IndexOf('.', offset);
                    if (-1 == periodOffset) {
                        restrictions[index] = procedure.Substring(offset);
                        break;
                    }

                    restrictions[index] = procedure.Substring(offset, periodOffset - offset);
                    offset = periodOffset + 1;

                    if (procedure.Length <= offset) {
                        break;
                    }
                }

                switch(index) {
                    case 3: // we have all four parts
                        break;
                    case 2:
                        restrictions[3] = restrictions[2];
                        restrictions[2] = restrictions[1];
                        restrictions[1] = restrictions[0];
                        restrictions[0] = null;
                        break;
                    case 1:
                        restrictions[3] = restrictions[1];
                        restrictions[2] = restrictions[0];
                        restrictions[1] = null;
                        restrictions[0] = null;
                        break;
                    case 0:
                        restrictions[3] = restrictions[0];
                        restrictions[2] = null;
                        restrictions[1] = null;
                        restrictions[0] = null;
                        break;
                    default:
                        Debug.Assert(false, "ParseProcedureName: internal invalid number of parts: " + index);
                        break;
                }
            }
            return restrictions;
        }


#if DEBUG
        static internal void DebugWrite(string value) {
            if (null == value) {
                return;
            }
            int index;
            int length = value.Length - 512;
            for (index = 0; index < length; index += 512) {
                Debug.Write(value.Substring(index, 512));
            }
            Debug.Write(value.Substring(index, value.Length - index));
        }

        static internal void DebugWriteLine(string value) {
            if (null == value) {
                return;
            }
            int index;
            int length = value.Length - 512;
            for (index = 0; index < length; index += 512) {
                Debug.Write(value.Substring(index, 512));
            }
            Debug.WriteLine(value.Substring(index, value.Length - index));
        }


        static internal void TraceDataTable(string prefix, DataTable dataTable) {
            Debug.Assert(null != dataTable, "TraceDataTable: null DataTable");

            bool flag = (null == dataTable.DataSet);
            if (flag) {
                (new DataSet()).Tables.Add(dataTable);
            }
            TraceDataSet(prefix, dataTable.DataSet);

            if (flag) {
                dataTable.DataSet.Tables.Remove(dataTable);
            }
        }

        static internal void TraceDataSet(string prefix, DataSet dataSet) {
            Debug.Assert(null != dataSet, "TraceDataSet: null DataSet");
            System.IO.StringWriter sw = new System.IO.StringWriter();
            System.Xml.XmlTextWriter xmlTextWriter = new System.Xml.XmlTextWriter(sw);
            xmlTextWriter.Formatting = System.Xml.Formatting.Indented;

            dataSet.WriteXmlSchema(sw);
            sw.WriteLine();
            dataSet.WriteXml(xmlTextWriter, XmlWriteMode.DiffGram);
            sw.WriteLine();

            ADP.DebugWriteLine(prefix);
            ADP.DebugWriteLine(sw.ToString());
        }

        static public string ValueToString(object value) {
            return DbConvertToString(value, System.Globalization.CultureInfo.InvariantCulture);
        }

        static public string DbConvertToString(object value, System.Globalization.CultureInfo cultureInfo) {
            if (null == cultureInfo) {
                throw ADP.ArgumentNull("cultureInfo");
            }
            if (null == value) {
                return "DEFAULT";
            }
            else if (Convert.IsDBNull(value)) {
                return "IS NULL";
            }
            else if (value is INullable && ((INullable)value).IsNull) {
                return value.GetType().Name + " IS NULL";
            }
            else if (value is String) {
                return value.GetType().Name + "[" + ((String)value).Length.ToString() + "]<" + (String) value + ">";
            }
            else if (value is SqlString) {
                string str = ((SqlString)value).Value;
                return value.GetType().Name + "[" + str.Length.ToString() + "]<" + str + ">";
            }
            else if (value is DateTime) {
                return value.GetType().Name + "<" + ((DateTime)value).ToString(cultureInfo) + ">";
            }
            else if (value is Single) {
                return value.GetType().Name + "<" + ((Single)value).ToString(cultureInfo) + ">";
            }
            else if (value is Double) {
                return value.GetType().Name + "<" + ((Double)value).ToString(cultureInfo) + ">";
            }
            else if (value is Decimal) {
                return value.GetType().Name + "<" + ((Decimal)value).ToString(cultureInfo) + ">";
            }
            else if (value is SqlDateTime) {
                return value.GetType().Name + "<" + ((SqlDateTime)value).Value.ToString(cultureInfo) + ">";
            }
            else if (value is SqlDecimal) {
                return value.GetType().Name + "<" + ((SqlDecimal)value).Value.ToString(cultureInfo) + ">";
            }
            else if (value is SqlDouble) {
                return value.GetType().Name + "<" + ((SqlDouble)value).Value.ToString(cultureInfo) + ">";
            }
            else if (value is SqlMoney) {
                return value.GetType().Name + "<" + ((SqlMoney)value).Value.ToString(cultureInfo) + ">";
            }
            else if (value is SqlSingle) {
                return value.GetType().Name + "<" + ((SqlSingle)value).Value.ToString(cultureInfo) + ">";
            }
            else if (value is byte[]) {
                byte[] array = (byte[]) value;
                int length = array.Length;
                StringBuilder builder = new StringBuilder(50 + length);
                builder.Append("Byte[" + length.ToString() + "]<");
                for (int i = 0; i < length; ++i) {
                    builder.Append(array[i].ToString("X2"));
                }
                builder.Append(">");
                return builder.ToString();
            }
            else if (value.GetType().IsArray) {
                return value.GetType().Name + "[" + ((Array)value).Length.ToString() + "]";
            }
            else {
                return value.GetType().Name + "<" + value.ToString() + ">";
            }
        }

        static internal void TraceValue(string prefix, object value) {
            ADP.DebugWriteLine(prefix + ValueToString(value));
        }

        static internal void Trace_Parameter(string prefix, OdbcParameter p) {
            Debug.WriteLine("\t" + prefix + " \"" + p.ParameterName + "\" AS " + p.DbType.ToString("G") + " OF " + p.OdbcType.ToString("G") + " FOR " + p.SourceVersion.ToString("G") + " \"" + p.SourceColumn + "\"");
            Debug.WriteLine("\t\t" + p.Size.ToString() + ", " + p.Precision.ToString() + ", " + p.Scale.ToString() + ", " + p.Direction.ToString("G") + ", " + ADP.ValueToString(p.Value));
        }

        static internal void Trace_Parameter(string prefix, OleDbParameter p) {
            Debug.WriteLine("\t" + prefix + " \"" + p.ParameterName + "\" AS " + p.DbType.ToString("G") + " OF " + p.OleDbType.ToString("G") + " FOR " + p.SourceVersion.ToString("G") + " \"" + p.SourceColumn + "\"");
            Debug.WriteLine("\t\t" + p.Size.ToString() + ", " + p.Precision.ToString() + ", " + p.Scale.ToString() + ", " + p.Direction.ToString("G") + ", " + ADP.ValueToString(p.Value));
        }

        static internal void Trace_Parameter(string prefix, SqlParameter p) {
            Debug.WriteLine("\t" + prefix + " \"" + p.ParameterName + "\" AS " + p.DbType.ToString("G") + " OF " + p.SqlDbType.ToString("G") + " FOR " + p.SourceVersion.ToString("G") + " \"" + p.SourceColumn + "\"");
            Debug.WriteLine("\t\t" + p.Size.ToString() + ", " + p.Precision.ToString() + ", " + p.Scale.ToString() + ", " + p.Direction.ToString("G") + ", " + ADP.ValueToString(p.Value));
        }

        // exists to ensure that we don't accidently modify read-only hashtables
        [Serializable] // MDAC 83147
        private class ProtectedHashtable : Hashtable {

            internal ProtectedHashtable(int size) : base(size) {
            }

            override public object this[object key] {
                set {
                    ReadOnly();
                }
            }
            override public void Add(object key, object value) {
                ReadOnly();
            }
            override public void Clear() {
                ReadOnly();
            }
            override public void Remove(object key) {
                ReadOnly();
            }
            internal void AddInternal(object key, object value) {
                base.Add(key, value);
            }
            private void ReadOnly() {
                Debug.Assert(false, "debug internal readonly hashtable protection");
                throw new InvalidOperationException("debug internal readonly hashtable protection");
            }
        }

        static internal Hashtable ProtectHashtable(Hashtable value) {
            ProtectedHashtable hash = null;
            if (null != value) {
                hash = new ProtectedHashtable(value.Count);
                foreach(DictionaryEntry entry in value) {
                    hash.AddInternal(entry.Key, entry.Value);
                }
            }
            return hash;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dataadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Diagnostics;
    using System.Threading;

    /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter"]/*' />
    abstract public class DataAdapter : Component, IDataAdapter {

        private bool acceptChangesDuringFill = true;
        private bool continueUpdateOnError = false;

        private MissingMappingAction missingMappingAction = System.Data.MissingMappingAction.Passthrough;
        private MissingSchemaAction missingSchemaAction = System.Data.MissingSchemaAction.Add;
        private DataTableMappingCollection tableMappings;

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.DataAdapter"]/*' />
        protected DataAdapter() : base() {
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.DataAdapter1"]/*' />
        protected DataAdapter(DataAdapter adapter) : base() { // MDAC 81448
            AcceptChangesDuringFill = adapter.AcceptChangesDuringFill;
            ContinueUpdateOnError = adapter.ContinueUpdateOnError;
            MissingMappingAction = adapter.MissingMappingAction;
            MissingSchemaAction = adapter.MissingSchemaAction;

            if ((null != adapter.tableMappings) && (0 < adapter.TableMappings.Count)) {
                DataTableMappingCollection parameters = this.TableMappings;
                foreach(ICloneable parameter in adapter.TableMappings) {
                    parameters.Add(parameter.Clone());
                }
            }
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.AcceptChangesDuringFill"]/*' />
        [
        DataCategory(Res.DataCategory_Fill),
        DefaultValue(true),
        DataSysDescription(Res.DataAdapter_AcceptChangesDuringFill)
        ]
        public bool AcceptChangesDuringFill {
            get {
                return this.acceptChangesDuringFill;
            }
            set {
                this.acceptChangesDuringFill = value;
            }
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.ContinueUpdateOnError"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(false),
        DataSysDescription(Res.DataAdapter_ContinueUpdateOnError)
        ]
        public bool ContinueUpdateOnError { // MDAC 66900
            get {
                return this.continueUpdateOnError;
            }
            set {
                this.continueUpdateOnError = value;
            }
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.MissingMappingAction"]/*' />
        [
        DataCategory(Res.DataCategory_Mapping),
        DefaultValue(System.Data.MissingMappingAction.Passthrough),
        DataSysDescription(Res.DataAdapter_MissingMappingAction)
        ]
        public MissingMappingAction MissingMappingAction {
            get {
                return missingMappingAction;
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case MissingMappingAction.Passthrough:
                case MissingMappingAction.Ignore:
                case MissingMappingAction.Error:
                    this.missingMappingAction = value;
                    break;
                default:
                    throw ADP.InvalidMappingAction((int) value);
                }
            }
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.MissingSchemaAction"]/*' />
        [
        DataCategory(Res.DataCategory_Mapping),
        DefaultValue(Data.MissingSchemaAction.Add),
        DataSysDescription(Res.DataAdapter_MissingSchemaAction)
        ]
        public MissingSchemaAction MissingSchemaAction {
            get {
                return missingSchemaAction;
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case MissingSchemaAction.Add:
                case MissingSchemaAction.Ignore:
                case MissingSchemaAction.Error:
                case MissingSchemaAction.AddWithKey:
                    this.missingSchemaAction = value;
                    break;
                default:
                    throw ADP.InvalidSchemaAction((int) value);
                }
            }
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.TableMappings"]/*' />
        [
        DataCategory(Res.DataCategory_Mapping),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataSysDescription(Res.DataAdapter_TableMappings)
        ]
        public DataTableMappingCollection TableMappings {
            get {
                if (null == this.tableMappings) {
                    this.tableMappings = CreateTableMappings();
                    if (null == this.tableMappings) {
                        Debug.Assert(false, "DataAdapter.CreateTableMappings returned null");
                        this.tableMappings = new DataTableMappingCollection();
                    }
                }
                return tableMappings; // constructed by base class
            }
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.IDataAdapter.TableMappings"]/*' />
        /// <internalonly/>
        ITableMappingCollection IDataAdapter.TableMappings {
            get { return TableMappings;}
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.ShouldSerializeTableMappings"]/*' />
        virtual protected bool ShouldSerializeTableMappings() { // MDAC 65548
            return true; /*(null != this.tableMappings) && (0 < TableMappings.Count);*/ // VS7 300569 
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.CloneInternals"]/*' />
        [ Obsolete("use 'protected DataAdapter(DataAdapter)' ctor") ] // MDAC 81448
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name="FullTrust")] // MDAC 82936
        virtual protected DataAdapter CloneInternals() {
            DataAdapter clone = (DataAdapter) Activator.CreateInstance(GetType());

            clone.AcceptChangesDuringFill = AcceptChangesDuringFill;
            clone.ContinueUpdateOnError = ContinueUpdateOnError;
            clone.MissingMappingAction = MissingMappingAction;
            clone.MissingSchemaAction = MissingSchemaAction;

            if ((null != this.tableMappings) && (0 < TableMappings.Count)) {
                DataTableMappingCollection parameters = clone.TableMappings;
                foreach(ICloneable parameter in TableMappings) {
                    parameters.Add(parameter.Clone());
                }
            }
            return clone;
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.CreateTableMappings"]/*' />
        virtual protected DataTableMappingCollection CreateTableMappings() {
            return new DataTableMappingCollection();
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects
                this.tableMappings = null;
            }
            // release unmanaged objects

            base.Dispose(disposing); // notify base classes
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.FillSchema"]/*' />
        abstract public DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.Fill"]/*' />
        abstract public int Fill(DataSet dataSet);

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.GetFillParameters"]/*' />
        abstract public IDataParameter[] GetFillParameters();

        internal DataTableMapping GetTableMappingBySchemaAction(string sourceTableName, string dataSetTableName, MissingMappingAction mappingAction) {
            return DataTableMappingCollection.GetTableMappingBySchemaAction(this.tableMappings, sourceTableName, dataSetTableName, mappingAction);
        }

        internal int IndexOfDataSetTable(string dataSetTable) {
            if (null != this.tableMappings) {
                return TableMappings.IndexOfDataSetTable(dataSetTable);
            }
            return -1;
        }

        /// <include file='doc\DataAdapter.uex' path='docs/doc[@for="DataAdapter.Update"]/*' />
        abstract public int Update(DataSet dataSet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\commandbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Odbc;
    using System.Data.OleDb;
    using System.Data.SqlClient;
    using System.Diagnostics;
    using System.Text;

    [ Flags() ] internal enum CommandBuilderBehavior {
        Default = 0,
        UpdateSetSameValue = 1,
        UseRowVersionInUpdateWhereClause = 2,
        UseRowVersionInDeleteWhereClause = 4,
        UseRowVersionInWhereClause = UseRowVersionInUpdateWhereClause | UseRowVersionInDeleteWhereClause,
        PrimaryKeyOnlyUpdateWhereClause = 16,
        PrimaryKeyOnlyDeleteWhereClause = 32,
        PrimaryKeyOnlyWhereClause = PrimaryKeyOnlyUpdateWhereClause | PrimaryKeyOnlyDeleteWhereClause,
    }

    sealed internal class CommandBuilder : IDisposable {
        // WHERE clause string format
        private const string WhereClause1 = @"((@p{1} = 1 AND {0} IS NULL) OR ({0} = @p{2}))";
        private const string WhereClause2 = @"((? = 1 AND {0} IS NULL) OR ({0} = ?))";

        // primary keys don't get the extra @p1 IS NULL treatment
        private const string WhereClause1p = @"({0} = @p{1})";
        private const string WhereClause2p = @"({0} = ?)";
        private const string WhereClausepn = @"({0} IS NULL)";

        private const string AndClause = " AND ";

        private IDbDataAdapter adapter;

        private MissingMappingAction missingMapping;
        private const MissingSchemaAction missingSchema = MissingSchemaAction.Error;
        private CommandBuilderBehavior options; // = CommandBuilderBehavior.Default;

        private OdbcRowUpdatingEventHandler  odbchandler;
        private OleDbRowUpdatingEventHandler adohandler;
        private SqlRowUpdatingEventHandler   sqlhandler;

        private DataTable dbSchemaTable;
        private DBSchemaRow[] dbSchemaRows;
        private string[] sourceColumnNames;

        // quote strings to use around SQL object names
        private string quotePrefix, quoteSuffix;
        private bool namedParameters;

        // sorted list of unique BaseTableNames
        private string quotedBaseTableName;

        private IDbCommand insertCommand, updateCommand, deleteCommand;

        internal CommandBuilder() : base() {
        }

        internal IDbDataAdapter DataAdapter {
            get {
                return this.adapter;
            }
            set {
                if (this.adapter != value) {
                    Dispose(true);

                    this.adapter = value;
                    if (null != this.adapter) { // MDAC 65499
                        if (this.adapter is OleDbDataAdapter) {
                            Debug.Assert(null == this.adohandler, "handler not clear");
                            this.adohandler = new OleDbRowUpdatingEventHandler(this.OleDbRowUpdating);
                            ((OleDbDataAdapter) this.adapter).RowUpdating += this.adohandler;
                            this.namedParameters = false;
                        }
                        else if (this.adapter is SqlDataAdapter) {
                            Debug.Assert(null == this.sqlhandler, "handler not clear");
                            this.sqlhandler = new SqlRowUpdatingEventHandler(this.SqlRowUpdating);
                            ((SqlDataAdapter) this.adapter).RowUpdating += this.sqlhandler;
                            this.namedParameters = true;
                        }
                        else if (this.adapter is OdbcDataAdapter) {
                            Debug.Assert(null == this.sqlhandler, "handler not clear");
                            this.odbchandler = new OdbcRowUpdatingEventHandler(this.OdbcRowUpdating);
                            ((OdbcDataAdapter) this.adapter).RowUpdating += this.odbchandler;
                            this.namedParameters = false;
                        }
                        else {
                            Debug.Assert(false, "not a recognized XxxDataAdapter");
                        }
                    }
                }
            }
        }

        /*internal CommandBuilderBehavior Behavior {
            get {
                return this.options;
            }
            set {
                this.options = value;
            }
        }*/

        internal string QuotePrefix {
            get {
                if (null == this.quotePrefix) {
                    return "";
                }
                return this.quotePrefix;
            }
            set {
                if (null != this.dbSchemaTable) {
                    throw ADP.NoQuoteChange();
                }
                this.quotePrefix = value;
            }
        }

        internal string QuoteSuffix {
            get {
                if (null == this.quoteSuffix) {
                    return "";
                }
                return this.quoteSuffix;
            }
            set {
                if (null != this.dbSchemaTable) {
                    throw ADP.NoQuoteChange();
                }
                this.quoteSuffix = value;
            }
        }

        private bool IsBehavior(CommandBuilderBehavior behavior) {
            return (behavior == (this.options & behavior));
        }
        private bool IsNotBehavior(CommandBuilderBehavior behavior) {
            return (behavior != (this.options & behavior));
        }

        private string QuotedColumn(string column) {
            return QuotePrefix + column + QuoteSuffix;
        }

        private string QuotedBaseTableName {
            get {
                return this.quotedBaseTableName;
            }
        }

        internal IDbCommand SourceCommand {
            get {
                if (null != this.adapter) {
                    return this.adapter.SelectCommand;
                }
                return null;
            }
        }

        private void ClearHandlers() {
            if (null != this.adohandler) {
                ((OleDbDataAdapter) this.adapter).RowUpdating -= this.adohandler;
                this.adohandler = null;
            }
            else if (null != this.sqlhandler) {
                ((SqlDataAdapter) this.adapter).RowUpdating -= this.sqlhandler;
                this.sqlhandler = null;
            }
            else if (null != this.odbchandler) {
                ((OdbcDataAdapter) this.adapter).RowUpdating -= this.odbchandler;
                this.odbchandler = null;
            }
        }

        private void ClearState() {
            this.dbSchemaTable = null;
            this.dbSchemaRows = null;
            this.sourceColumnNames = null;
            this.quotedBaseTableName = null;
        }

        public void Dispose() {
            Dispose(true);
            // don't need to GC.SuppressFinalize since we don't have a Finalize method
        }

        /*virtual protected*/private void Dispose(bool disposing) {
            if (disposing) {
                ClearHandlers();

                RefreshSchema();
                this.adapter = null;
            }
            // release unmanaged objects

            //base.Dispose(disposing); // notify base classes
        }

        private IDbCommand GetXxxCommand(IDbCommand cmd) { // MDAC 62616
            /*if (null != cmd) {
                IDbCommand src = SourceCommand;
                if (null != src) {
                    cmd.Connection = src.Connection;
                    cmd.Transaction = src.Transaction;
                }
            }*/
            return cmd;
        }

        internal IDbCommand GetInsertCommand() {
            BuildCache(true);
            return GetXxxCommand(BuildInsertCommand(null, null));
        }

        internal IDbCommand GetUpdateCommand() {
            BuildCache(true);
            return GetXxxCommand(BuildUpdateCommand(null, null));
        }

        internal IDbCommand GetDeleteCommand() {
            BuildCache(true);
            return GetXxxCommand(BuildDeleteCommand(null, null));
        }

        internal void RefreshSchema() {
            ClearState();

            if (null != this.adapter) { // MDAC 66016
                if (this.insertCommand == this.adapter.InsertCommand) {
                    this.adapter.InsertCommand = null;
                }
                if (this.updateCommand == this.adapter.UpdateCommand) {
                    this.adapter.UpdateCommand = null;
                }
                if (this.deleteCommand == this.adapter.DeleteCommand) {
                    this.adapter.DeleteCommand = null;
                }
            }

            if (null != this.insertCommand)
                this.insertCommand.Dispose();

            if (null != this.updateCommand)
                this.updateCommand.Dispose();

            if (null != this.deleteCommand)
                this.deleteCommand.Dispose();

            this.insertCommand = null;
            this.updateCommand = null;
            this.deleteCommand = null;
        }

        private void OdbcRowUpdating(object sender, OdbcRowUpdatingEventArgs ruevent) {
            RowUpdating(sender, ruevent);
        }
        private void OleDbRowUpdating(object sender, OleDbRowUpdatingEventArgs ruevent) {
            RowUpdating(sender, ruevent);
        }
        private void SqlRowUpdating(object sender, SqlRowUpdatingEventArgs ruevent) {
            RowUpdating(sender, ruevent);
        }

        private void RowUpdating(object sender, RowUpdatingEventArgs ruevent) {
            if (UpdateStatus.Continue != ruevent.Status) { // MDAC 60538
                return;
            }
            if (null != ruevent.Command) {
                switch(ruevent.StatementType) {
                case StatementType.Insert:
                    if (this.insertCommand != ruevent.Command) {
                        return;
                    }
                    break;
                case StatementType.Update:
                    if (this.updateCommand != ruevent.Command) {
                        return;
                    }
                    break;
                case StatementType.Delete:
                    if (this.deleteCommand != ruevent.Command) {
                        return;
                    }
                    break;
                default:
                    Debug.Assert(false, "RowUpdating: unexpected StatementType");
                    return;
                }
            }
            try {
                // MDAC 58710 - unable to tell Update method that Event opened connection and Update needs to close when done
                // HackFix - the Update method will close the connection if command was null and returned command.Connection is same as SelectCommand.Connection
                BuildCache(false);

                switch(ruevent.StatementType) {
                case StatementType.Insert:
                    ruevent.Command = BuildInsertCommand(ruevent.TableMapping, ruevent.Row);
                    break;
                case StatementType.Update:
                    ruevent.Command = BuildUpdateCommand(ruevent.TableMapping, ruevent.Row);
                    break;
                case StatementType.Delete:
                    ruevent.Command = BuildDeleteCommand(ruevent.TableMapping, ruevent.Row);
                    break;
                default:
                    Debug.Assert(false, "RowUpdating: unexpected StatementType");
                    break;
                }
                if (null == ruevent.Command) { // MDAC 60667
                    if (null != ruevent.Row) {
                        ruevent.Row.AcceptChanges(); // MDAC 65103
                    }
                    ruevent.Status = UpdateStatus.SkipCurrentRow;
                }
            }
            catch(Exception e) { // MDAC 66706
                ADP.TraceException(e);

                ruevent.Errors = e;
                ruevent.Status = UpdateStatus.ErrorsOccurred;
            }
        }

        private void BuildCache(bool closeConnection) {
            IDbCommand srcCommand = SourceCommand;
            if (null == srcCommand) {
                throw ADP.MissingSourceCommand();
            }

            IDbConnection connection = srcCommand.Connection;
            if (null == connection) {
                throw ADP.MissingSourceCommandConnection();
            }

            if (null != DataAdapter) {
                this.missingMapping = DataAdapter.MissingMappingAction;
                if (MissingMappingAction.Passthrough != missingMapping) {
                    missingMapping = MissingMappingAction.Error;
                }
            }

            if (null == this.dbSchemaTable) {
                if (0 == (ConnectionState.Open & connection.State)) {
                    connection.Open();
                }
                else {
                    closeConnection = false; // MDAC 58710
                }
                try { // try-filter-finally so and catch-throw
                    try {
                        DataTable schemaTable = null;
                        using(IDataReader dataReader = srcCommand.ExecuteReader(CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo)) {
                            schemaTable = dataReader.GetSchemaTable();
                        }

                        if (null != schemaTable) {
#if DEBUG
                            if (AdapterSwitches.OleDbSql.TraceVerbose) {
                                ADP.TraceDataTable("CommandBuilder", schemaTable);
                            }
#endif
                            BuildInformation(schemaTable);
                            this.dbSchemaTable = schemaTable;

                            int count = this.dbSchemaRows.Length;
                            sourceColumnNames = new string[count];
                            for (int i = 0; i < count; ++i) {
                                if (null != dbSchemaRows[i]) {
                                    sourceColumnNames[i] = dbSchemaRows[i].ColumnName;
                                }
                            }
                            ADP.BuildSchemaTableInfoTableNames(sourceColumnNames);
                        }
                        else { // MDAC 66620
                            throw ADP.DynamicSQLNoTableInfo();
                        }
                    }
                    finally { // Close
                        if (closeConnection) {
                            connection.Close();
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        private void BuildInformation(DataTable schemaTable) {
            DBSchemaRow[] rows = DBSchemaRow.GetSortedSchemaRows(schemaTable); // MDAC 60609
            if ((null == rows) || (0 == rows.Length)) {
                throw ADP.DynamicSQLNoTableInfo();
            }

            string baseServerName = ""; // MDAC 72721, 73599
            string baseCatalogName = "";
            string baseSchemaName = "";
            string baseTableName = null;

            for (int i = 0; i < rows.Length; ++i) {
                DBSchemaRow row = rows[i];
                string tableName = row.BaseTableName;
                if ((null == tableName) || (0 == tableName.Length)) {
                    rows[i] = null;
                    continue;
                }

                string serverName = row.BaseServerName;
                string catalogName = row.BaseCatalogName;
                string schemaName = row.BaseSchemaName;
                if (null == serverName) {
                    serverName = "";
                }
                if (null == catalogName) {
                    catalogName = "";
                }
                if (null == schemaName) {
                    schemaName = "";
                }
                if (null == baseTableName) {
                    baseServerName = serverName;
                    baseCatalogName = catalogName;
                    baseSchemaName = schemaName;
                    baseTableName = tableName;
                }
                else if (  (0 != ADP.SrcCompare(baseTableName, tableName))
                        || (0 != ADP.SrcCompare(baseSchemaName, schemaName))
                        || (0 != ADP.SrcCompare(baseCatalogName, catalogName))
                        || (0 != ADP.SrcCompare(baseServerName, serverName))) {
                    throw ADP.DynamicSQLJoinUnsupported();
                }
            }
            if (0 == baseServerName.Length) {
                baseServerName = null;
            }
            if (0 == baseCatalogName.Length) {
                baseServerName = null;
                baseCatalogName = null;
            }
            if (0 == baseSchemaName.Length) {
                baseServerName = null;
                baseCatalogName = null;
                baseSchemaName = null;
            }
            if ((null == baseTableName) || (0 == baseTableName.Length)) {
                throw ADP.DynamicSQLNoTableInfo();
            }

            if (!ADP.IsEmpty(this.quotePrefix) && (-1 != baseTableName.IndexOf(quotePrefix))) {
                throw ADP.DynamicSQLNestedQuote(baseTableName, quotePrefix);
            }
            if (!ADP.IsEmpty(this.quoteSuffix) && (-1 != baseTableName.IndexOf(quoteSuffix))) {
                throw ADP.DynamicSQLNestedQuote(baseTableName, quoteSuffix);
            }

            System.Text.StringBuilder quoted = new System.Text.StringBuilder();
            if (null != baseServerName) {
                quoted.Append(QuotePrefix);
                quoted.Append(baseServerName);
                quoted.Append(QuoteSuffix);
                quoted.Append(".");
            }
            if (null != baseCatalogName) {
                quoted.Append(QuotePrefix);
                quoted.Append(baseCatalogName);
                quoted.Append(QuoteSuffix);
                quoted.Append(".");
            }
            if (null != baseSchemaName) {
                quoted.Append(QuotePrefix);
                quoted.Append(baseSchemaName);
                quoted.Append(QuoteSuffix);
                quoted.Append(".");
            }
            quoted.Append(QuotePrefix);
            quoted.Append(baseTableName);
            quoted.Append(QuoteSuffix);
            this.quotedBaseTableName = quoted.ToString();
            this.dbSchemaRows = rows;
        }

        private IDbCommand BuildNewCommand(IDbCommand cmd) {
            IDbCommand src = SourceCommand;
            if (null == cmd) {
                cmd = src.Connection.CreateCommand();
                cmd.CommandTimeout = src.CommandTimeout;
                cmd.Transaction = src.Transaction;
            }
            cmd.CommandType = CommandType.Text;
            cmd.UpdatedRowSource = UpdateRowSource.None; // no select or output parameters expected // MDAC 60562
            return cmd;
        }

        private void ApplyParameterInfo(OdbcParameter parameter, int pcount, DBSchemaRow row) {
            parameter.OdbcType = (OdbcType) row.ProviderType;
            parameter.IsNullable = row.AllowDBNull;
            parameter.Precision = (byte) row.Precision;
            parameter.Scale = (byte) row.Scale;
            parameter.Size = 0; //don't specify parameter.Size so that we don't silently truncate to the metadata size
#if DEBUG
            if (AdapterSwitches.OleDbSql.TraceVerbose) {
                ADP.Trace_Parameter("OdbcParameter", parameter);
            }
#endif
        }

        private void ApplyParameterInfo(OleDbParameter parameter, int pcount, DBSchemaRow row) {
            parameter.OleDbType = (OleDbType) row.ProviderType;
            parameter.IsNullable = row.AllowDBNull;
            parameter.Precision = (byte) row.Precision;
            parameter.Scale = (byte) row.Scale;
            parameter.Size = 0; //don't specify parameter.Size so that we don't silently truncate to the metadata size
#if DEBUG
            if (AdapterSwitches.OleDbSql.TraceVerbose) {
                ADP.Trace_Parameter("OleDbParameter", parameter);
            }
#endif
        }

        private void ApplyParameterInfo(SqlParameter parameter, int pcount, DBSchemaRow row) {
            parameter.SqlDbType = (SqlDbType) row.ProviderType;
            parameter.IsNullable = row.AllowDBNull;
            // MDAC 72662.  Do not set precision or scale if values are default of 0xff (unspecified, or do not apply).
            if ((byte) row.Precision != 0xff) {
                parameter.Precision = (byte) row.Precision;
            }
            if ((byte) row.Scale != 0xff) {
                parameter.Scale = (byte) row.Scale;
            }
            parameter.Size = 0; //don't specify parameter.Size so that we don't silently truncate to the metadata size
#if DEBUG
            if (AdapterSwitches.OleDbSql.TraceVerbose) {
              ADP.Trace_Parameter("SqlParameter", parameter);
            }
#endif
        }

        private IDbCommand BuildInsertCommand(DataTableMapping mappings, DataRow dataRow) {
            if (ADP.IsEmpty(this.quotedBaseTableName)) {
                return null;
            }
            IDbCommand cmd = BuildNewCommand(this.insertCommand);

            // count the columns for the ?
            int valueCount = 0;
            int pcount = 1; // @p1, @p2, ...

            StringBuilder builder = new StringBuilder();
            builder.Append("INSERT INTO ");
            builder.Append(QuotedBaseTableName);

            // search for the columns in that base table, to be the column clause
            int length = this.dbSchemaRows.Length;
            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = this.dbSchemaRows[i];
                if (null == row) {
                    continue;
                }
                if (0 == row.BaseColumnName.Length) {
                    continue;
                }
                if (!row.IsAutoIncrement && !row.IsHidden && !row.IsExpression && !row.IsRowVersion) { // MDAC 68339

                    object value = null;
                    string sourceColumn = this.sourceColumnNames[i]; // MDAC 60079
                    if ((null != mappings) && (null != dataRow)) {
                        value = GetParameterInsertValue(sourceColumn, mappings, dataRow, row.IsReadOnly);
                        if (null == value) {
                            // SQL auto-gen appear to have if (Updatable) then value = DEFAULT
                            // and not check Updateable(IsExpression && IsReadOnly) in the main loop
                            if (row.IsReadOnly || (cmd is SqlCommand)) { // MDAC 65473, 68339
                                continue;
                            }
                        }
                        else if (Convert.IsDBNull(value) && !row.AllowDBNull) { // MDAC 70230
                            continue;
                        }
                    }
                    if (0 == valueCount) {
                        builder.Append("( ");
                    }
                    else {
                        builder.Append(" , ");
                    }
                    builder.Append(QuotedColumn(row.BaseColumnName));

                    IDataParameter p = GetNextParameter(cmd, valueCount);
                    p.ParameterName = "@p" + pcount.ToString();
                    p.Direction = ParameterDirection.Input;
                    p.SourceColumn = sourceColumn;
                    p.SourceVersion = DataRowVersion.Current;
                    p.Value = value;

                    if (p is OleDbParameter) {
                        ApplyParameterInfo((OleDbParameter) p, pcount, row);
                    }
                    else if (p is SqlParameter) {
                        ApplyParameterInfo((SqlParameter) p, pcount, row);
                    }
                    else if (p is OdbcParameter) {
                        ApplyParameterInfo((OdbcParameter) p, pcount, row);
                    }
                    if (!cmd.Parameters.Contains(p)) {
                        cmd.Parameters.Add(p);
                    }
                    valueCount++;
                    pcount++;
                }
            }
            if (0 == valueCount) {
                builder.Append(" DEFAULT VALUES");
            }
            else if (this.namedParameters) {
                builder.Append(" ) VALUES ( @p1");
                for (int i = 2; i <= valueCount; ++i) {
                    builder.Append(" , @p");
                    builder.Append(i.ToString());
                }
                builder.Append(" )");
            }
            else {
                builder.Append(" ) VALUES ( ?");
                for (int i = 2; i <= valueCount; ++i) {
                    builder.Append(" , ?");
                }
                builder.Append(" )");
            }
            cmd.CommandText = builder.ToString();
            RemoveExtraParameters(cmd, valueCount);
#if DEBUG
            if (AdapterSwitches.OleDbSql.TraceInfo) {
              ADP.DebugWriteLine(cmd.CommandText);
            }
#endif

            this.insertCommand = cmd;
            return cmd;
        }

        private IDbCommand BuildUpdateCommand(DataTableMapping mappings, DataRow dataRow) {
            if (ADP.IsEmpty(this.quotedBaseTableName)) {
                return null;
            }
            IDbCommand cmd = BuildNewCommand(this.updateCommand);

            // count the columns for the @p, key count, ?
            int pcount = 1; // @p1, @p2, ...
            int columnCount = 0;
            int valueCount = 0;
            int setCount = 0;

            StringBuilder builder = new StringBuilder();
            builder.Append("UPDATE ");
            builder.Append(QuotedBaseTableName);
            builder.Append(" SET ");

            // search for the columns in that base table, to build the set clause
            int length = this.dbSchemaRows.Length;
            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = this.dbSchemaRows[i];
                if ((null == row) || (0 == row.BaseColumnName.Length) || ExcludeFromUpdateSet(row)) {
                    continue;
                }
                columnCount++;

                object value = null;
                string sourceColumn = this.sourceColumnNames[i];  // MDAC 60079
                if ((null != mappings) && (null != dataRow)) {
                    value = GetParameterUpdateValue(sourceColumn, mappings, dataRow, row.IsReadOnly); // MDAC 61424
                    if (null == value) { // unspecified values are skipped
                        if (row.IsReadOnly) { // MDAC 68339
                            columnCount--;
                        }
                        continue;
                    }
                }
                if (0 < valueCount) {
                    builder.Append(" , ");
                }

                builder.Append(QuotedColumn(row.BaseColumnName));
                AppendParameterText(builder, pcount);

                IDataParameter p = GetNextParameter(cmd, valueCount);
                p.ParameterName = "@p" + pcount.ToString();
                p.Direction = ParameterDirection.Input;
                p.SourceColumn = sourceColumn;
                p.SourceVersion = DataRowVersion.Current;
                p.Value = value;

                if (p is OleDbParameter) {
                    ApplyParameterInfo((OleDbParameter) p, pcount, row);
                }
                else if (p is SqlParameter) {
                    ApplyParameterInfo((SqlParameter) p, pcount, row);
                }
                else if (p is OdbcParameter) {
                    ApplyParameterInfo((OdbcParameter) p, pcount, row);
                }
                if (!cmd.Parameters.Contains(p)) {
                    cmd.Parameters.Add(p);
                }
                pcount++;
                valueCount++;
            }
            setCount = valueCount;
            builder.Append(" WHERE ( ");

            // search the columns again to build the where clause with optimistic concurrency
            string andclause = "";
            int whereCount = 0;
            string nullWhereParameter = null, nullWhereSourceColumn = null;
            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = this.dbSchemaRows[i];

                if ((null == row) ||  (0 == row.BaseColumnName.Length) || !IncludeForUpdateWhereClause(row)) {
                    continue;
                }
                builder.Append(andclause);
                andclause = CommandBuilder.AndClause;

                object value = null;
                string sourceColumn = this.sourceColumnNames[i]; // MDAC 60079
                if ((null != mappings) && (null != dataRow)) {
                    value = GetParameterValue(sourceColumn, mappings, dataRow, DataRowVersion.Original);
                }

                bool pkey = IsPKey(row);
                string backendColumnName = QuotedColumn(row.BaseColumnName);
                if (pkey) {
                    if (Convert.IsDBNull(value)) {
                        builder.Append(String.Format(WhereClausepn, backendColumnName));
                    }
                    else if (this.namedParameters) {
                        builder.Append(String.Format(WhereClause1p, backendColumnName, pcount));
                    }
                    else {
                        builder.Append(String.Format(WhereClause2p, backendColumnName));
                    }
                }
                else if (this.namedParameters) {
                    builder.Append(String.Format(WhereClause1, backendColumnName, pcount, 1+pcount));
                }
                else {
                    builder.Append(String.Format(WhereClause2, backendColumnName));
                }

                if (!pkey || !Convert.IsDBNull(value)) {
                    IDataParameter p = GetNextParameter(cmd, valueCount); // first parameter value
                    p.ParameterName = "@p" + pcount.ToString();
                    p.Direction = ParameterDirection.Input;
                    if (pkey) {
                        p.SourceColumn = sourceColumn;
                        p.SourceVersion = DataRowVersion.Original;
                        p.Value = value;
                    }
                    else {
                        p.SourceColumn = null;
                        p.Value = (ADP.IsNull(value)) ? 1 : 0;
                    }
                    pcount++;
                    valueCount++;

                    if (p is OleDbParameter) {
                        ApplyParameterInfo((OleDbParameter) p, pcount, row);
                    }
                    else if (p is SqlParameter) {
                        ApplyParameterInfo((SqlParameter) p, pcount, row);
                    }
                    else if (p is OdbcParameter) {
                        ApplyParameterInfo((OdbcParameter) p, pcount, row);
                    }
                    if (!pkey) {
                        p.DbType = DbType.Int32;
                    }

                    if (!cmd.Parameters.Contains(p)) {
                        cmd.Parameters.Add(p);
                    }
                }

                if (!pkey) {
                    IDataParameter p = GetNextParameter(cmd, valueCount);
                    p.ParameterName = "@p" + pcount.ToString();
                    p.Direction = ParameterDirection.Input;
                    p.SourceColumn = sourceColumn;
                    p.SourceVersion = DataRowVersion.Original;
                    p.Value = value;
                    pcount++;
                    valueCount++;

                    if (p is OleDbParameter) {
                        ApplyParameterInfo((OleDbParameter) p, pcount, row);
                    }
                    else if (p is SqlParameter) {
                        ApplyParameterInfo((SqlParameter) p, pcount, row);
                    }
                    else if (p is OdbcParameter) {
                        ApplyParameterInfo((OdbcParameter) p, pcount, row);
                    }

                    if (!cmd.Parameters.Contains(p)) {
                        cmd.Parameters.Add(p);
                    }
                }

                if (IncrementUpdateWhereCount(row)) {
                    whereCount++;
                }
            }
            builder.Append(" )");
            cmd.CommandText = builder.ToString();
            RemoveExtraParameters(cmd, valueCount);

#if DEBUG
            if (AdapterSwitches.OleDbSql.TraceInfo) {
                ADP.DebugWriteLine(cmd.CommandText);
            }
#endif
            this.updateCommand = cmd;

            if (0 == columnCount) {
                throw ADP.DynamicSQLReadOnly(ADP.UpdateCommand);
            }
            if (0 == setCount) { // MDAC 60667
                cmd = null;
            }
            if (0 == whereCount) {
                throw ADP.DynamicSQLNoKeyInfo(ADP.UpdateCommand);
            }
            if (null != nullWhereParameter) {
                DataColumn column = GetParameterDataColumn(nullWhereSourceColumn, mappings, dataRow);
                throw ADP.WhereClauseUnspecifiedValue(nullWhereParameter, nullWhereSourceColumn, column.ColumnName);
            }
            return cmd;
        }

        private IDbCommand BuildDeleteCommand(DataTableMapping mappings, DataRow dataRow) {
            if (ADP.IsEmpty(this.quotedBaseTableName)) {
                return null;
            }
            IDbCommand cmd = BuildNewCommand(this.deleteCommand);

            StringBuilder builder = new StringBuilder();
            builder.Append("DELETE FROM  ");
            builder.Append(QuotedBaseTableName);
            builder.Append(" WHERE ( ");

            int pcount = 1; // @p1, @p2, ...
            int valueCount = 0;
            int whereCount = 0;
            string andclause = "";
            string nullWhereParameter = null, nullWhereSourceColumn = null;

            int length = this.dbSchemaRows.Length;
            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = this.dbSchemaRows[i];

                if ((null == row) || (0 == row.BaseColumnName.Length) || !IncludeForDeleteWhereClause(row)) {
                    continue;
                }
                builder.Append(andclause);
                andclause = CommandBuilder.AndClause;

                object value = null;
                string sourceColumn = this.sourceColumnNames[i]; // MDAC 60079
                if ((null != mappings) && (null != dataRow)) {
                    value = GetParameterValue(sourceColumn, mappings, dataRow, DataRowVersion.Original);
                }

                bool pkey = IsPKey(row);
                string backendColumnName = QuotedColumn(row.BaseColumnName);
                if (pkey) {
                    if (Convert.IsDBNull(value)) {
                        builder.Append(String.Format(WhereClausepn, backendColumnName));
                    }
                    else if (this.namedParameters) {
                        builder.Append(String.Format(WhereClause1p, backendColumnName, pcount));
                    }
                    else {
                        builder.Append(String.Format(WhereClause2p, backendColumnName));
                    }
                }
                else if (this.namedParameters) {
                    builder.Append(String.Format(WhereClause1, backendColumnName, pcount, 1+pcount));
                }
                else {
                    builder.Append(String.Format(WhereClause2, backendColumnName));
                }

                if (!pkey || !Convert.IsDBNull(value)) {
                    IDataParameter p = GetNextParameter(cmd, valueCount); // first parameter value
                    p.ParameterName = "@p" + pcount.ToString();
                    p.Direction = ParameterDirection.Input;
                    if (pkey) {
                        p.SourceColumn = sourceColumn;
                        p.SourceVersion = DataRowVersion.Original;
                        p.Value = value;
                    }
                    else {
                        p.SourceColumn = null;
                        p.Value = (ADP.IsNull(value)) ? 1 : 0;
                    }
                    pcount++;
                    valueCount++;

                    if (p is OleDbParameter) {
                        ApplyParameterInfo((OleDbParameter) p, pcount, row);
                    }
                    else if (p is SqlParameter) {
                        ApplyParameterInfo((SqlParameter) p, pcount, row);
                    }
                    else if (p is OdbcParameter) {
                        ApplyParameterInfo((OdbcParameter) p, pcount, row);
                    }
                    if (!pkey) {
                        p.DbType = DbType.Int32;
                    }

                    if (!cmd.Parameters.Contains(p)) {
                        cmd.Parameters.Add(p);
                    }
                }

                if (!pkey) {
                    IDataParameter p = GetNextParameter(cmd, valueCount);
                    p.ParameterName = "@p" + pcount.ToString();
                    p.Direction = ParameterDirection.Input;
                    p.SourceColumn = sourceColumn;
                    p.SourceVersion = DataRowVersion.Original;
                    p.Value = value;
                    pcount++;
                    valueCount++;

                    if (p is OleDbParameter) {
                        ApplyParameterInfo((OleDbParameter) p, pcount, row);
                    }
                    else if (p is SqlParameter) {
                        ApplyParameterInfo((SqlParameter) p, pcount, row);
                    }
                    else if (p is OdbcParameter) {
                        ApplyParameterInfo((OdbcParameter) p, pcount, row);
                    }

                    if (!cmd.Parameters.Contains(p)) {
                        cmd.Parameters.Add(p);
                    }
                }

                if (IncrementDeleteWhereCount(row)) {
                    whereCount++;
                }
            }

            builder.Append(" )");
            cmd.CommandText = builder.ToString();
            RemoveExtraParameters(cmd, valueCount);
#if DEBUG
            if (AdapterSwitches.OleDbSql.TraceInfo) {
              ADP.DebugWriteLine(cmd.CommandText);
            }
#endif
            this.deleteCommand = cmd;

            if (0 == whereCount) {
                throw ADP.DynamicSQLNoKeyInfo(ADP.DeleteCommand);
            }
            if (null != nullWhereParameter) {
                DataColumn column = GetParameterDataColumn(nullWhereSourceColumn, mappings, dataRow);
                throw ADP.WhereClauseUnspecifiedValue(nullWhereParameter, nullWhereSourceColumn, column.ColumnName);
            }

            return cmd;
        }

        private bool ExcludeFromUpdateSet(DBSchemaRow row) {
            return row.IsAutoIncrement || row.IsRowVersion || row.IsHidden;
        }

        private bool IncludeForUpdateWhereClause(DBSchemaRow row) {
            // @devnote: removed IsRowVersion so that MS SQL timestamp columns aren't included in UPDATE WHERE clause
            if (IsBehavior(CommandBuilderBehavior.UseRowVersionInUpdateWhereClause)) {
                return (row.IsRowVersion || row.IsKey || row.IsUnique) && !row.IsLong && !row.IsHidden;
            }
            return ((IsNotBehavior(CommandBuilderBehavior.PrimaryKeyOnlyUpdateWhereClause) || row.IsKey || row.IsUnique)
                    && !row.IsLong && (row.IsKey || !row.IsRowVersion) && !row.IsHidden);
        }

        private bool IncludeForDeleteWhereClause(DBSchemaRow row) { // MDAC 74213
            if (IsBehavior(CommandBuilderBehavior.UseRowVersionInDeleteWhereClause)) {
                return (row.IsRowVersion || row.IsKey || row.IsUnique) && !row.IsLong && !row.IsHidden;
            }
            return ((IsNotBehavior(CommandBuilderBehavior.PrimaryKeyOnlyDeleteWhereClause) || row.IsKey || row.IsUnique)
                    && !row.IsLong && (row.IsKey || !row.IsRowVersion) && !row.IsHidden);
        }

        private bool IsPKey(DBSchemaRow row) {
            return (row.IsKey/* && !row.IsUnique*/);
        }

        private bool IncrementUpdateWhereCount(DBSchemaRow row) { // MDAC 59255
            return (row.IsKey || row.IsUnique);
        }
        private bool IncrementDeleteWhereCount(DBSchemaRow row) { // MDAC 59255
            return (row.IsKey || row.IsUnique);
        }

        private DataColumn GetParameterDataColumn(String columnName, DataTableMapping mappings, DataRow row) {
            if (!ADP.IsEmpty(columnName)) {

                DataColumnMapping columnMapping = mappings.GetColumnMappingBySchemaAction(columnName, this.missingMapping);
                if (null != columnMapping) {
                    return columnMapping.GetDataColumnBySchemaAction(row.Table, null, missingSchema);
                }
            }
            return null;
        }

        private object GetParameterValue(String columnName, DataTableMapping mappings, DataRow row, DataRowVersion version) {
            DataColumn dataColumn = GetParameterDataColumn(columnName, mappings, row);
            if (null != dataColumn) {
                return row[dataColumn, version];
            }
            return null;
        }

        private object GetParameterInsertValue(String columnName, DataTableMapping mappings, DataRow row, bool readOnly) {
            DataColumn dataColumn = GetParameterDataColumn(columnName, mappings, row);
            if (null != dataColumn) {
                if (readOnly && dataColumn.ReadOnly) { // MDAC 68339
                    return null;
                }
                return row[dataColumn, DataRowVersion.Current];
            }
            return null;
        }

        private object GetParameterUpdateValue(String columnName, DataTableMapping mappings, DataRow row, bool readOnly) {
            DataColumn dataColumn = GetParameterDataColumn(columnName, mappings, row);
            if (null != dataColumn) {
                if (readOnly && dataColumn.ReadOnly) { // MDAC 68339
                    return null;
                }
                object current = row[dataColumn, DataRowVersion.Current];

                if (IsNotBehavior(CommandBuilderBehavior.UpdateSetSameValue)) {
                    object original = row[dataColumn, DataRowVersion.Original];

                    if ((original != current) && ((null == original) || !original.Equals(current))) { // MDAC 61424
                        return current;
                    }
                }
                else {
                    return current;
                }
            }
            return null;
        }

        private void AppendParameterText(StringBuilder builder, int pcount) {
            if (this.namedParameters) {
                builder.Append(" = @p");
                builder.Append(pcount.ToString());
            }
            else {
                builder.Append(" = ?");
            }
        }

        // see if another builder is already attached, if so return it
        static internal Delegate FindBuilder(MulticastDelegate mcd) {
            if (null != mcd) {
                Delegate[] d = mcd.GetInvocationList();
                for (int i = 0; i < d.Length; i++) {
                    if (d[i].Target is CommandBuilder) {
                        return d[i];
                    }
                }
            }

            return null;
        }

        static private IDataParameter GetNextParameter(IDbCommand cmd, int pcount) {
            if (pcount < cmd.Parameters.Count) {
                IDataParameter p = (IDataParameter) cmd.Parameters[pcount];
#if DEBUG
                if (AdapterSwitches.OleDbSql.TraceVerbose) {
                    Debug.WriteLine("reusing " + p.GetType().Name + " " + p.ParameterName);
                }
#endif
                return p;
            }
            return cmd.CreateParameter();
        }

        static private void RemoveExtraParameters(IDbCommand cmd, int pcount) {
            while (pcount < cmd.Parameters.Count) {
#if DEBUG
                if (AdapterSwitches.OleDbSql.TraceVerbose) {
                    IDataParameter p = (IDataParameter) cmd.Parameters[cmd.Parameters.Count-1];
                    Debug.WriteLine("removing extra " + p.GetType().Name + " " + p.ParameterName);
                }
#endif
                cmd.Parameters.RemoveAt(cmd.Parameters.Count-1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datastorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Collections;

    /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage"]/*' />
    /// <internalonly/>
    abstract internal class DataStorage {


        private Type type;
        private DataTable table;
        private BitArray dbNullBits;

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.DataStorage"]/*' />
        /// <internalonly/>
        internal DataStorage(Type type) {
            this.type = type;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.Table"]/*' />
        /// <internalonly/>
        public DataTable Table {
            get {
                return this.table;
            }
            set {
                this.table = value;
            }
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.DataType"]/*' />
        /// <internalonly/>
        public Type DataType {
            get {
                return this.type;
            }
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.DefaultValue"]/*' />
        /// <internalonly/>
        abstract public Object DefaultValue {
            get;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.Aggregate"]/*' />
        /// <internalonly/>
         public virtual Object Aggregate(int[] recordNos, AggregateType kind) {
            if (AggregateType.Count == kind) {
                int count = 0;
                for (int i = 0; i < recordNos.Length; i++) {
                    if (!this.dbNullBits.Get(recordNos[i]))
                        count++;
                }
                return count;
            }
            return null;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.ClearBits"]/*' />
        /// <internalonly/>
        protected void ClearBits(int recordNo) {
            this.dbNullBits.Set(recordNo, false);
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.CompareBits"]/*' />
        /// <internalonly/>
        protected int CompareBits(int recordNo1, int recordNo2) {
            bool recordNo1Null = this.dbNullBits.Get(recordNo1);
            bool recordNo2Null = this.dbNullBits.Get(recordNo2);
            if (recordNo1Null ^ recordNo2Null) {
                if (recordNo1Null)
                    return -1;
                else
                    return 1;
            }

            return 0;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.Compare"]/*' />
        /// <internalonly/>
        public virtual int Compare(int recordNo1, int recordNo2) {
            object valueNo1 = Get(recordNo1);
            if (valueNo1 is IComparable) {
                object valueNo2 = Get(recordNo2);
                if (valueNo2.GetType() == valueNo1.GetType())
                    return((IComparable) valueNo1).CompareTo(valueNo2);
                else
                    CompareBits(recordNo1, recordNo2);
            }
            return 0;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.CompareToValue"]/*' />
        /// <internalonly/>
        public virtual int CompareToValue(int recordNo1, Object value) {
            object valueNo1 = Get(recordNo1);

            if (valueNo1 is IComparable) {
                if (value.GetType() == valueNo1.GetType())
                    return((IComparable) valueNo1).CompareTo(value);
            }

            if (valueNo1 == value)
                return 0;

            if (valueNo1 == DBNull.Value)
                return -1;

            if (value == DBNull.Value)
                return 1;
                
            return 0;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.CopyBits"]/*' />
        /// <internalonly/>
        protected void CopyBits(int srcRecordNo, int dstRecordNo) {
            this.dbNullBits.Set(dstRecordNo, this.dbNullBits.Get(srcRecordNo));
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.Copy"]/*' />
        /// <internalonly/>
        virtual public void Copy(int recordNo1, int recordNo2) {
            Set(recordNo2, Get(recordNo1));
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.Get"]/*' />
        /// <internalonly/>
        abstract public Object Get(int recordNo);

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.GetBits"]/*' />
        /// <internalonly/>
        protected Object GetBits(int recordNo) {
            if (this.dbNullBits.Get(recordNo)) {
                return DBNull.Value;
            }
            return DefaultValue;
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.IsNull"]/*' />
        /// <internalonly/>
        public virtual bool IsNull(int recordNo) {
           return this.dbNullBits.Get(recordNo);
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.Set"]/*' />
        /// <internalonly/>
        abstract public void Set(int recordNo, Object value);

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.SetBits"]/*' />
        /// <internalonly/>
        protected bool SetBits(int recordNo, Object value) {
            bool flag = (value == DBNull.Value);
            this.dbNullBits.Set(recordNo, flag);
            return (flag || value == null);
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.SetCapacity"]/*' />
        /// <internalonly/>
        virtual public void SetCapacity(int capacity) {
            if (null == this.dbNullBits) {
                this.dbNullBits = new BitArray(capacity);
            }
            else {
                this.dbNullBits.Length = capacity;
            }
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        abstract public object ConvertXmlToObject(string s);

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        abstract public string ConvertObjectToXml(object value);

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.CreateStorage"]/*' />
        /// <internalonly/>
        public static DataStorage CreateStorage(Type dataType) {
            switch (Type.GetTypeCode(dataType)) {
                case TypeCode.Empty:     throw ExceptionBuilder.InvalidStorageType(TypeCode.Empty);
                case TypeCode.DBNull:    throw ExceptionBuilder.InvalidStorageType(TypeCode.DBNull);
                case TypeCode.Boolean:   return new BooleanStorage();
                case TypeCode.Char:      return new CharStorage();
                case TypeCode.SByte:     return new SByteStorage();
                case TypeCode.Byte:      return new ByteStorage();
                case TypeCode.Int16:     return new Int16Storage();
                case TypeCode.UInt16:    return new UInt16Storage();
                case TypeCode.Int32:     return new Int32Storage();
                case TypeCode.UInt32:    return new UInt32Storage();
                case TypeCode.Int64:     return new Int64Storage();
                case TypeCode.UInt64:    return new UInt64Storage();
                case TypeCode.Single:    return new SingleStorage();
                case TypeCode.Double:    return new DoubleStorage();
                case TypeCode.Decimal:   return new DecimalStorage();
                case TypeCode.DateTime:  return new DateTimeStorage();
                case TypeCode.String:    return new StringStorage();
                case TypeCode.Object:
                    if (typeof(TimeSpan) == dataType) {
                        return new TimeSpanStorage();
                    }
                    return new ObjectStorage(dataType);
                default:                 return new ObjectStorage(dataType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datatablemappingcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTableMappingCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection"]/*' />
    [
    Editor("Microsoft.VSDesigner.Data.Design.DataTableMappingCollectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
    ListBindable(false)
    ]
    sealed public class DataTableMappingCollection : MarshalByRefObject, ITableMappingCollection {
        private ArrayList items; // delay creation until AddWithoutEvents, Insert, CopyTo, GetEnumerator

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.DataTableMappingCollection"]/*' />
        public DataTableMappingCollection() {
        }

        // explicit ICollection implementation
        bool System.Collections.ICollection.IsSynchronized {
            get { return false;}
        }
        object System.Collections.ICollection.SyncRoot {
            get { return this;}
        }

        // explicit IList implementation
        bool System.Collections.IList.IsReadOnly {
            get { return false;}
        }
         bool System.Collections.IList.IsFixedSize {
            get { return false;}
        }
        object System.Collections.IList.this[int index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (DataTableMapping) value;
            }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.ITableMappingCollection.this"]/*' />
        /// <internalonly/>
        object ITableMappingCollection.this[string index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (DataTableMapping) value;
            }
        }
        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.ITableMappingCollection.Add"]/*' />
        /// <internalonly/>
        ITableMapping ITableMappingCollection.Add(string sourceTableName, string dataSetTableName) {
            return Add(sourceTableName, dataSetTableName);
        }
        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.ITableMappingCollection.GetByDataSetTable"]/*' />
        /// <internalonly/>
        ITableMapping ITableMappingCollection.GetByDataSetTable(string dataSetTableName) {
            return GetByDataSetTable(dataSetTableName);
        }
        
        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Count"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataTableMappings_Count)
        ]
        public int Count {
            get {
                return ((null != items) ? items.Count : 0);
            }
        }

        private Type ItemType {
            get { return typeof(DataTableMapping); }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.this"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataTableMappings_Item)
        ]
        public DataTableMapping this[int index] {
            get {
                RangeCheck(index);
                return(DataTableMapping) items[index];
            }
            set {
                RangeCheck(index);
                Replace(index, value);
            }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.this1"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataTableMappings_Item)
        ]
        public DataTableMapping this[string sourceTable] {
            get {
                int index = RangeCheck(sourceTable);
                return(DataTableMapping) items[index];
            }
            set {
                int index = RangeCheck(sourceTable);
                Replace(index, value);
            }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Add"]/*' />
        public int Add(object value) {
            ValidateType(value);
            Add((DataTableMapping) value);
            return Count-1;
        }

        private DataTableMapping Add(DataTableMapping value) {
            AddWithoutEvents(value);
            return value;
        }
        
        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.AddRange"]/*' />
        public void AddRange(DataTableMapping[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            int length = values.Length;
            for (int i = 0; i < length; ++i) {
                ValidateType(values[i]);
            }
            for (int i = 0; i < length; ++i) {
                AddWithoutEvents(values[i]);
            }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Add2"]/*' />
        public DataTableMapping Add(string sourceTable, string dataSetTable) {
            return Add(new DataTableMapping(sourceTable, dataSetTable));
        }

        private void AddWithoutEvents(DataTableMapping value) {
            Validate(-1, value);
            value.Parent = this;
            ArrayList().Add(value);
        }

        // implemented as a method, not as a property because the VS7 debugger 
        // object browser calls properties to display their value, and we want this delayed
        private ArrayList ArrayList() {
            if (null == this.items) {
                this.items = new ArrayList();
            }
            return this.items;
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Clear"]/*' />
        public void Clear() {
            if (0 < Count) {
                ClearWithoutEvents();
            }
        }

        private void ClearWithoutEvents() {
            if (null != items) {
                int count = items.Count;
                for(int i = 0; i < count; ++i) {
                    ((DataTableMapping) items[i]).Parent = null;
                }
                items.Clear();
            }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Contains"]/*' />
        public bool Contains(string value) {
            return (-1 != IndexOf(value));
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Contains1"]/*' />
        public bool Contains(object value) {
            return (-1 != IndexOf(value));
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            ArrayList().CopyTo(array, index);
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.GetByDataSetTable"]/*' />
        public DataTableMapping GetByDataSetTable(string dataSetTable) {
            int index = IndexOfDataSetTable(dataSetTable);
            if (0 > index) {
                throw ADP.TablesDataSetTable(dataSetTable);
            }
            return(DataTableMapping) items[index];
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return ArrayList().GetEnumerator();
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.IndexOf"]/*' />
        public int IndexOf(object value) {
            if (null != value) {
                ValidateType(value);
                for (int i = 0; i < Count; ++i) {
                    if (items[i] == value) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.IndexOf1"]/*' />
        public int IndexOf(string sourceTable) {
            if (!ADP.IsEmpty(sourceTable)) {
                for (int i = 0; i < Count; ++i) {
                    string value = ((DataTableMapping) items[i]).SourceTable;
                    if ((null != value) && (0 == ADP.SrcCompare(sourceTable, value))) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.IndexOfDataSetTable"]/*' />
        public int IndexOfDataSetTable(string dataSetTable) {
            if (!ADP.IsEmpty(dataSetTable)) {
                for (int i = 0; i < Count; ++i) {
                    string value = ((DataTableMapping) items[i]).DataSetTable;
                    if ((null != value) && (0 == ADP.DstCompare(dataSetTable, value))) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Insert"]/*' />
        public void Insert(int index, Object value) {
            ValidateType(value);
            Validate(-1, (DataTableMapping) value);
            ((DataTableMapping) value).Parent = this;
            ArrayList().Insert(index, value);
        }

        private void RangeCheck(int index) {
            if ((index < 0) || (Count <= index)) {
                throw ADP.TablesIndexInt32(index, this);
            }
        }

        private int RangeCheck(string sourceTable) {
            int index = IndexOf(sourceTable);
            if (index < 0) {
                throw ADP.TablesSourceIndex(sourceTable);
            }
            return index;
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.RemoveAt"]/*' />
        public void RemoveAt(int index) {
            RangeCheck(index);
            RemoveIndex(index);
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.RemoveAt1"]/*' />
        public void RemoveAt(string sourceTable) {
            int index = RangeCheck(sourceTable);
            RemoveIndex(index);
        }

        private void RemoveIndex(int index) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            ((DataTableMapping) items[index]).Parent = null;
            items.RemoveAt(index);
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.Remove"]/*' />
        public void Remove(object value) {
            ValidateType(value);
            int index = IndexOf((DataTableMapping) value);
            if (-1 != index) {
                RemoveIndex(index);
            }
            else {
                throw ADP.CollectionRemoveInvalidObject(ItemType, this);
            }
        }

        private void Replace(int index, DataTableMapping newValue) {
            Validate(index, newValue);
            ((DataTableMapping) items[index]).Parent = null;
            newValue.Parent = this;
            items[index] = newValue;
        }

        private void ValidateType(object value) {
            if (null == value) {
                throw ADP.TablesAddNullAttempt("value");
            }
            else if (!ItemType.IsInstanceOfType(value)) {
                throw ADP.NotADataTableMapping(value);
            }
        }

        private void Validate(int index, DataTableMapping value) {
            if (null == value) {
                throw ADP.TablesAddNullAttempt("value");
            }
            if (null != value.Parent) {
                if (this != value.Parent) {
                    throw ADP.TablesIsNotParent(value.SourceTable);
                }
                else if (index != IndexOf(value)) {
                    throw ADP.TablesIsParent(value.SourceTable);
                }
            }
            String name = value.SourceTable;
            if (ADP.IsEmpty(name)) {
                index = 1;
                do {
                    name = ADP.SourceTable + index.ToString();
                    index++;
                } while (-1 != IndexOf(name));
                value.SourceTable = name;
            }
            else {
                ValidateSourceTable(index, name);
            }
        }

        internal void ValidateSourceTable(int index, string value) {
            int pindex = IndexOf(value);
            if ((-1 != pindex) && (index != pindex)) { // must be non-null and unique
                throw ADP.TablesUniqueSourceTable(value);
            }
        }

        /// <include file='doc\DataTableMappingCollection.uex' path='docs/doc[@for="DataTableMappingCollection.GetTableMappingBySchemaAction"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        static public DataTableMapping GetTableMappingBySchemaAction(DataTableMappingCollection tableMappings, string sourceTable, string dataSetTable, MissingMappingAction mappingAction) {
            if (null != tableMappings) {
                int index = tableMappings.IndexOf(sourceTable);
                if (-1 != index) {
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceWarning) {
                        Debug.WriteLine("mapping match on SourceTable \"" + sourceTable + "\"");
                    }
#endif
                    return (DataTableMapping) tableMappings.items[index];
                }
            }
            if (ADP.IsEmpty(sourceTable)) {
                throw ADP.InvalidSourceTable("sourceTable");
            }
            switch (mappingAction) {
                case MissingMappingAction.Passthrough:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceInfo) {
                        Debug.WriteLine("mapping passthrough of SourceTable \"" + sourceTable + "\" -> \"" + dataSetTable + "\"");
                    }
#endif
                    return new DataTableMapping(sourceTable, dataSetTable);

                case MissingMappingAction.Ignore:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceWarning) {
                        Debug.WriteLine("mapping filter of SourceTable \"" + sourceTable + "\"");
                    }
#endif
                    return null;

                case MissingMappingAction.Error:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceError) {
                        Debug.WriteLine("mapping error on SourceTable \"" + sourceTable + "\"");
                    }
#endif
                    throw ADP.MissingTableMapping(sourceTable);

                default:
                    throw ADP.InvalidMappingAction((int)mappingAction);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datetimestorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateTimeStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class DateTimeStorage : DataStorage {

        private static readonly DateTime defaultValue = DateTime.MinValue;
        static private readonly Object defaultValueAsObject = defaultValue;

        private DateTime[] values;

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.DateTimeStorage"]/*' />
        /// <internalonly/>
        public DateTimeStorage()
        : base(typeof(DateTime)) {
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Min:
                        DateTime min = DateTime.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=(DateTime.Compare(values[record],min) < 0) ? values[record] : min;
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        DateTime max = DateTime.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=(DateTime.Compare(values[record],max) >= 0) ? values[record] : max;
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        int count = 0;
                        for (int i = 0; i < records.Length; i++) {
                            if (!IsNull(records[i]))
                                count++;
                        }
                        return count;
                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(DateTime));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            DateTime valueNo1 = values[recordNo1];
            DateTime valueNo2 = values[recordNo2];

            if (valueNo1 == DateTimeStorage.defaultValue && valueNo2 == DateTimeStorage.defaultValue) 
                return CompareBits(recordNo1, recordNo2);
            if (valueNo1 == DateTimeStorage.defaultValue && base.IsNull(recordNo1))
                return -1;
            if (valueNo2 == DateTimeStorage.defaultValue && base.IsNull(recordNo2))
                return 1;

            return DateTime.Compare(valueNo1, valueNo2);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            DateTime valueNo1 = values[recordNo];

            if (valueNo1 == defaultValue || value == null || value == DBNull.Value) {
                Object obj;
                if (valueNo1 == defaultValue)
                    obj = GetBits(recordNo);
                else
                    obj = valueNo1;
                    
                if (obj == value)
                    return 0;
                if (obj == null)
                    return -1;
                if (value == null)
                    return 1;
                if (obj == DBNull.Value)
                    return -1;
                if (value == DBNull.Value)
                    return 1;
            }

            DateTime valueNo2 = (DateTime)value;
            return DateTime.Compare(valueNo1, valueNo2);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            DateTime value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.IsNull"]/*' />
        /// <internalonly/>
        override public bool IsNull(int record) {
            DateTime value = values[record];
            if (value != defaultValue) {
                return false;
            }
            return base.IsNull(record);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (value == null || value == DBNull.Value) {
                SetBits(record, value);
                values[record] = DateTimeStorage.defaultValue;
            }
            else {
                DateTime val = Convert.ToDateTime(value);
                values[record] = val;
                if (val == DateTimeStorage.defaultValue)
                    SetBits(record, value);
            }
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            DateTime[] newValues = new DateTime[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToDateTime(s);
        }

        /// <include file='doc\DateTimeStorage.uex' path='docs/doc[@for="DateTimeStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((DateTime)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datacolumnmappingconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnMappingConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.ComponentModel.Design.Serialization;
    using System.ComponentModel;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\DataColumnMappingConverter.uex' path='docs/doc[@for="DataColumnMappingConverter"]/*' />
    /// <internalonly/>
    sealed internal class DataColumnMappingConverter : ExpandableObjectConverter {

        /// <include file='doc\DataColumnMappingConverter.uex' path='docs/doc[@for="DataColumnMappingConverter.CanConvertTo"]/*' />
        /// <internalonly/>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\DataColumnMappingConverter.uex' path='docs/doc[@for="DataColumnMappingConverter.ConvertTo"]/*' />
        /// <internalonly/>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw ADP.ArgumentNull("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is DataColumnMapping) {
                DataColumnMapping d = (DataColumnMapping)value;
                ConstructorInfo ctor = typeof(DataColumnMapping).GetConstructor(new Type[] {
                    typeof(string), typeof(string)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {
                        d.SourceColumn,
                        d.DataSetColumn});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datatablemappingconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTableMappingConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\DataTableMappingConverter.uex' path='docs/doc[@for="DataTableMappingConverter"]/*' />
    /// <internalonly/>
    sealed internal class DataTableMappingConverter : ExpandableObjectConverter {

        /// <include file='doc\DataTableMappingConverter.uex' path='docs/doc[@for="DataTableMappingConverter.CanConvertTo"]/*' />
        /// <internalonly/>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\DataTableMappingConverter.uex' path='docs/doc[@for="DataTableMappingConverter.ConvertTo"]/*' />
        /// <internalonly/>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw ADP.ArgumentNull("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is DataTableMapping) {
                DataTableMapping d = (DataTableMapping)value;
                ConstructorInfo ctor = typeof(DataTableMapping).GetConstructor(new Type[] {
                    typeof(string), typeof(string), typeof(DataColumnMapping[])});
                if (ctor != null) {
                
                    DataColumnMapping[] columnMappings = new DataColumnMapping[d.ColumnMappings.Count];
                    d.ColumnMappings.CopyTo(columnMappings, 0);
                
                    return new InstanceDescriptor(ctor, new object[] {
                        d.SourceTable, d.DataSetTable, columnMappings});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\datatablemapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTableMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping"]/*' />
    [
    TypeConverterAttribute(typeof(DataTableMappingConverter))
    ]
    sealed public class DataTableMapping : MarshalByRefObject, ITableMapping, ICloneable {
        private DataTableMappingCollection parent;
        private DataColumnMappingCollection columnMappings;
        private string dataSetTableName;
        private string sourceTableName;

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.DataTableMapping"]/*' />
        public DataTableMapping() {
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.DataTableMapping1"]/*' />
        public DataTableMapping(string sourceTable, string dataSetTable) {
            SourceTable = sourceTable;
            DataSetTable = dataSetTable;
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.DataTableMapping2"]/*' />
        public DataTableMapping(string sourceTable, string dataSetTable, DataColumnMapping[] columnMappings) {
            SourceTable = sourceTable;
            DataSetTable = dataSetTable;
            if ((null != columnMappings) && (0 < columnMappings.Length)) {
                ColumnMappings.AddRange(columnMappings);
            }
        }

        // explict ITableMapping implementation
        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.ITableMapping.ColumnMappings"]/*' />
        /// <internalonly/>
        IColumnMappingCollection ITableMapping.ColumnMappings {
            get { return ColumnMappings;}
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.ColumnMappings"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataSysDescription(Res.DataTableMapping_ColumnMappings)
        ]
        public DataColumnMappingCollection ColumnMappings {
            get {
                if (null == this.columnMappings) {
                    this.columnMappings = new DataColumnMappingCollection();
                }
                return columnMappings;
            }
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.DataSetTable"]/*' />
        [
        DefaultValue(""),
        DataSysDescription(Res.DataTableMapping_DataSetTable)
        ]
        public string DataSetTable {
            get {
                return ((null != dataSetTableName) ? dataSetTableName : String.Empty);
            }
            set {
                dataSetTableName = value;
            }
        }

        internal DataTableMappingCollection Parent {
            get {
                return parent;
            }
            set {
                parent = value;
            }
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.SourceTable"]/*' />
        [
        DefaultValue(""),
        DataSysDescription(Res.DataTableMapping_SourceTable)
        ]
        public string SourceTable {
            get {
                return ((null != sourceTableName) ? sourceTableName : String.Empty);
            }
            set {
                if ((null != Parent) && (0 != ADP.SrcCompare(sourceTableName, value))) {
                    Parent.ValidateSourceTable(-1, value);
                }
                sourceTableName = value;
            }
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            DataTableMapping clone = new DataTableMapping(); // MDAC 81448
            clone.SourceTable = SourceTable;
            clone.DataSetTable = DataSetTable;

            if ((null != this.columnMappings) && (0 < ColumnMappings.Count)) {
                DataColumnMappingCollection parameters = clone.ColumnMappings;
                foreach(ICloneable parameter in ColumnMappings) {
                    parameters.Add(parameter.Clone());
                }
            }
            return clone;
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.GetColumnMappingBySchemaAction"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        public DataColumnMapping GetColumnMappingBySchemaAction(string sourceColumn, MissingMappingAction mappingAction) {
            return DataColumnMappingCollection.GetColumnMappingBySchemaAction(this.columnMappings, sourceColumn, mappingAction);
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.GetDataTableBySchemaAction"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        public DataTable GetDataTableBySchemaAction(DataSet dataSet, MissingSchemaAction schemaAction) {
            if (null == dataSet) {
                throw ADP.NullDataSet("dataSet");
            }
            string dataSetTable = DataSetTable;

            if (ADP.IsEmpty(dataSetTable)) {
#if DEBUG
                if (AdapterSwitches.DataSchema.TraceWarning) {
                    Debug.WriteLine("explicit filtering of SourceTable \"" + SourceTable + "\"");
                }
#endif
                return null;
            }
            DataTableCollection tables = dataSet.Tables;
            int index = tables.IndexOf(dataSetTable);
            if ((0 <= index) && (index < tables.Count)) {
#if DEBUG
                if (AdapterSwitches.DataSchema.TraceInfo) {
                    Debug.WriteLine("schema match on DataTable \"" + dataSetTable);
                }
#endif
                return tables[index];
            }
            switch (schemaAction) {
                case MissingSchemaAction.Add:
                case MissingSchemaAction.AddWithKey:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceInfo) {
                        Debug.WriteLine("schema add of DataTable \"" + dataSetTable + "\"");
                    }
#endif
                    return new DataTable(dataSetTable);

                case MissingSchemaAction.Ignore:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceWarning) {
                        Debug.WriteLine("schema filter of DataTable \"" + dataSetTable + "\"");
                    }
#endif
                    return null;

                case MissingSchemaAction.Error:
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceError) {
                        Debug.WriteLine("schema error on DataTable \"" + dataSetTable + "\"");
                    }
#endif
                    throw ADP.MissingTableSchema(dataSetTable, SourceTable);
            }
            throw ADP.InvalidSchemaAction((int) schemaAction);
        }

        /// <include file='doc\DataTableMapping.uex' path='docs/doc[@for="DataTableMapping.ToString"]/*' />
        public override String ToString() {
            return SourceTable;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbdataadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DbDataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.ComponentModel;
    using System.Collections;
    using System.Data;
    using System.Diagnostics;

    /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter"]/*' />
    abstract public class DbDataAdapter : DataAdapter, ICloneable/*, IDbDataAdapter*/ { // MDAC 69629

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.DefaultSourceTableName"]/*' />
        public const string DefaultSourceTableName = "Table";

        static private readonly object EventFillError = new object();

        // using a field to track instead of Component.Events because just checking
        // for a handler causes the EventHandlerList creation that we can otherwise avoid
        private bool hasFillErrorHandler;

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.DbDataAdapter"]/*' />
        protected DbDataAdapter() : base() {
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.DbDataAdapter1"]/*' />
        protected DbDataAdapter(DbDataAdapter adapter) : base(adapter) { // MDAC 81448
            IDbDataAdapter pthis = (IDbDataAdapter) this;
            pthis.SelectCommand = CloneCommand(adapter.SelectCommand);
            pthis.InsertCommand = CloneCommand(adapter.InsertCommand);
            pthis.UpdateCommand = CloneCommand(adapter.UpdateCommand);
            pthis.DeleteCommand = CloneCommand(adapter.DeleteCommand);
        }

        private IDbCommand DeleteCommand {
            get { return ((IDbDataAdapter) this).DeleteCommand; }
        }

        private IDbCommand InsertCommand {
            get { return ((IDbDataAdapter) this).InsertCommand; }
        }

        private IDbCommand SelectCommand {
            get { return ((IDbDataAdapter) this).SelectCommand; }
        }

        private IDbCommand UpdateCommand {
            get { return ((IDbDataAdapter) this).UpdateCommand; }
        }

        private System.Data.MissingMappingAction UpdateMappingAction {
            get {
                if (System.Data.MissingMappingAction.Passthrough == MissingMappingAction) {
                    return System.Data.MissingMappingAction.Passthrough;
                }
                return System.Data.MissingMappingAction.Error;
            }
        }

        private System.Data.MissingSchemaAction UpdateSchemaAction {
            get {
                System.Data.MissingSchemaAction action = MissingSchemaAction;
                if ((System.Data.MissingSchemaAction.Add == action) || (System.Data.MissingSchemaAction.AddWithKey == action)) {
                    return System.Data.MissingSchemaAction.Ignore;
                }
                return System.Data.MissingSchemaAction.Error;
            }
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.FillError"]/*' />
        [
        DataCategory(Res.DataCategory_Fill),
        DataSysDescription(Res.DbDataAdapter_FillError)
        ]
        public event FillErrorEventHandler FillError {
            add {
                hasFillErrorHandler = true;
                Events.AddHandler(EventFillError, value);
            }
            remove {
                Events.RemoveHandler(EventFillError, value);
            }
        }

        /* // MDAC 69489
        private IDbCommand cmdSelect;
        private IDbCommand cmdInsert;
        private IDbCommand cmdUpdate;
        private IDbCommand cmdDelete;
        IDbCommand IDbDataAdapter.DeleteCommand {
            get {
                return VerifyIDbCommand(cmdDelete, StatementType.Delete, false);
            }
            set {
                cmdDelete = VerifyIDbCommand(value, StatementType.Delete, true);
            }
        }
        IDbCommand IDbDataAdapter.InsertCommand {
            get {
                return VerifyIDbCommand(cmdInsert, StatementType.Insert, false);
            }
            set {
                cmdInsert = VerifyIDbCommand(value, StatementType.Insert, true);
            }
        }
        IDbCommand IDbDataAdapter.SelectCommand {
            get {
                return VerifyIDbCommand(cmdSelect, StatementType.Select, false);
            }
            set {
                cmdSelect = VerifyIDbCommand(value, StatementType.Select, true);
            }
        }
        IDbCommand IDbDataAdapter.UpdateCommand {
            get {
                return VerifyIDbCommand(cmdUpdate, StatementType.Update, false);
            }
            set {
                cmdUpdate = VerifyIDbCommand(value, StatementType.Update, true);
            }
        }
        virtual protected IDbCommand VerifyIDbCommand(IDbCommand command, StatementType statementType, bool getset) {
            return command;
        }
        */

        [ Obsolete("use 'protected DbDataAdapter(DbDataAdapter)' ctor") ] // MDAC 81448
        object ICloneable.Clone() { // MDAC 69629
            IDbDataAdapter pthis = (IDbDataAdapter) this;
            IDbDataAdapter clone = (IDbDataAdapter) CloneInternals();
            clone.SelectCommand = CloneCommand(pthis.SelectCommand);
            clone.InsertCommand = CloneCommand(pthis.InsertCommand);
            clone.UpdateCommand = CloneCommand(pthis.UpdateCommand);
            clone.DeleteCommand = CloneCommand(pthis.DeleteCommand);
            return clone;
        }

        private IDbCommand CloneCommand(IDbCommand command) {
            return (IDbCommand) ((command is ICloneable) ? ((ICloneable) command).Clone() : null);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.CreateRowUpdatedEvent"]/*' />
        abstract protected RowUpdatedEventArgs CreateRowUpdatedEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.CreateRowUpdatingEvent"]/*' />
        abstract protected RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 69629
            if (disposing) { // release mananged objects
                IDbDataAdapter pthis = (IDbDataAdapter) this;
                pthis.SelectCommand = null;
                pthis.InsertCommand = null;
                pthis.UpdateCommand = null;
                pthis.DeleteCommand = null;
            }
            // release unmanaged objects

            base.Dispose(disposing); // notify base classes
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.FillSchema"]/*' />
        public DataTable FillSchema(DataTable dataTable, SchemaType schemaType) {
            return FillSchema(dataTable, schemaType, SelectCommand, CommandBehavior.Default); // MDAC 67666
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.FillSchema1"]/*' />
        override public DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType) {
            IDbCommand command = SelectCommand;
            if (DesignMode && ((null == command) || (null == command.Connection) || ADP.IsEmpty(command.CommandText))) {
                return new DataTable[0]; // design-time support
            }
            return FillSchema(dataSet, schemaType, command, DbDataAdapter.DefaultSourceTableName, 0);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.FillSchema2"]/*' />
        public DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, string srcTable) {
            return FillSchema(dataSet, schemaType, SelectCommand, srcTable, 0);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.FillSchema3"]/*' />
        virtual protected DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, IDbCommand command, string srcTable, CommandBehavior behavior) {
            if (null == dataSet) {
                throw ADP.FillSchemaRequires("dataSet");
            }
            if ((SchemaType.Source != schemaType) && (SchemaType.Mapped != schemaType)) {
                throw ADP.InvalidSchemaType((int) schemaType);
            }
            if (ADP.IsEmpty(srcTable)) {
                throw ADP.FillSchemaRequiresSourceTableName("srcTable");
            }
            if (null == command) {
                throw ADP.MissingSelectCommand(ADP.FillSchema);
            }
            return FillSchemaFromCommand((object) dataSet, schemaType, command, srcTable, behavior);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.FillSchema4"]/*' />
        virtual protected DataTable FillSchema(DataTable dataTable, SchemaType schemaType, IDbCommand command, CommandBehavior behavior) {
            if (null == dataTable) {
                throw ADP.FillSchemaRequires("dataTable");
            }
            if ((SchemaType.Source != schemaType) && (SchemaType.Mapped != schemaType)) {
                throw ADP.InvalidSchemaType((int) schemaType);
            }
            if (null == command) {
                throw ADP.MissingSelectCommand(ADP.FillSchema);
            }
            string srcTableName = dataTable.TableName;
            int index = IndexOfDataSetTable(srcTableName);
            if (-1 != index) {
                srcTableName = TableMappings[index].SourceTable;
            }
            DataTable[] tables = FillSchemaFromCommand((object) dataTable, schemaType, command, srcTableName, behavior | CommandBehavior.SingleResult);
            if (0 < tables.Length) {
                return tables[0];
            }
            return null;
        }

        private DataTable[] FillSchemaFromCommand(Object data, SchemaType schemaType, IDbCommand command, string srcTable, CommandBehavior behavior) {
            IDbConnection activeConnection = DbDataAdapter.GetConnection(command, ADP.FillSchema);
            ConnectionState originalState = ConnectionState.Open;

            DataTable[] dataTables = new DataTable[0];

            try { // try-filter-finally so and catch-throw
                try {
                    DbDataAdapter.QuietOpen(activeConnection, out originalState);
                    using(IDataReader dataReader = command.ExecuteReader(behavior | CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo)) {

                        if (null != dataReader) {
                            int schemaCount = 0;
                            DataTable dataTable;
                            SchemaMapping mapping;
                            do {
                                if (0 >= dataReader.FieldCount) {
                                    continue;
                                }
                                try {
                                    string tmp = null;
                                    mapping = new SchemaMapping(this, dataReader, true);
                                    if (data is DataTable) {
                                        mapping.DataTable = (DataTable) data;
                                    }
                                    else {
                                        Debug.Assert(data is DataSet, "data is not DataSet");
                                        mapping.DataSet = (DataSet) data;
                                        tmp = DbDataAdapter.GetSourceTableName(srcTable, schemaCount);
                                    }
                                    mapping.SetupSchema(schemaType, tmp, false, null, null);

                                    dataTable = mapping.DataTable;
                                    if (null != dataTable) {
                                        dataTables = DbDataAdapter.AddDataTableToArray(dataTables, dataTable);
                                    }
                                }
                                finally { // schemaCount
                                    schemaCount++; // don't increment if no SchemaTable ( a non-row returning result )
                                }
                            } while (dataReader.NextResult());
                        }
                    }
                }
                finally { // Close
                    DbDataAdapter.QuietClose(activeConnection, originalState);
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return dataTables;
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill"]/*' />
        public int Fill(DataTable dataTable) {
            if (null == dataTable) {
                throw ADP.FillRequires("dataTable");
            }
            IDbCommand command = SelectCommand;
            if (null == command) {
                throw ADP.MissingSelectCommand(ADP.Fill);
            }

            string srcTableName = dataTable.TableName;
            int index = IndexOfDataSetTable(srcTableName);
            if (-1 != index) {
                srcTableName = TableMappings[index].SourceTable;
            }
            return Fill(dataTable, command, CommandBehavior.SingleResult);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill1"]/*' />
        override public int Fill(DataSet dataSet) {
            return Fill(dataSet, 0, 0, DbDataAdapter.DefaultSourceTableName, SelectCommand, 0);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill2"]/*' />
        public int Fill(DataSet dataSet, string srcTable) {
            return Fill(dataSet, 0, 0, srcTable, SelectCommand, 0);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill3"]/*' />
        public int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable) {
            return Fill(dataSet, startRecord, maxRecords, srcTable, SelectCommand, 0);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill4"]/*' />
        virtual protected int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable, IDbCommand command, CommandBehavior behavior) {
            if (null == dataSet) {
                throw ADP.FillRequires("dataSet");
            }
            if (null == command) {
                throw ADP.MissingSelectCommand(ADP.Fill);
            }
            if (startRecord < 0) {
                throw ADP.InvalidStartRecord("startRecord", startRecord);
            }
            if (maxRecords < 0) {
                throw ADP.InvalidMaxRecords("maxRecords", maxRecords);
            }
            if (ADP.IsEmpty(srcTable)) {
                throw ADP.FillRequiresSourceTableName("srcTable");
            }
            return FillFromCommand((object)dataSet, startRecord, maxRecords, srcTable, command, behavior);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill6"]/*' />
        virtual protected int Fill(DataTable dataTable, IDbCommand command, CommandBehavior behavior) {
            if (null == dataTable) {
                throw ADP.FillRequires("dataTable");
            }
            if (null == command) {
                throw ADP.MissingSelectCommand(ADP.Fill);
            }
            return FillFromCommand((object)dataTable, 0, 0, null, command, behavior);
        }

        private int FillFromCommand(object data, int startRecord, int maxRecords, string srcTable, IDbCommand command, CommandBehavior behavior) {
            IDbConnection activeConnection = DbDataAdapter.GetConnection(command, ADP.Fill);
            ConnectionState originalState = ConnectionState.Open;

            // the default is MissingSchemaAction.Add, the user must explicitly
            // set MisingSchemaAction.AddWithKey to get key information back in the dataset
            if (Data.MissingSchemaAction.AddWithKey == MissingSchemaAction) {
                behavior |= CommandBehavior.KeyInfo;
            }

            int rowsAddedToDataSet = 0;
            try { // try-filter-finally so and catch-throw
                try {
                    DbDataAdapter.QuietOpen(activeConnection, out originalState);

                    using(IDataReader dataReader = command.ExecuteReader(behavior | CommandBehavior.SequentialAccess)) {
                        if (data is DataTable) { // delegate to next set of protected Fill methods
                            rowsAddedToDataSet = Fill((DataTable) data, dataReader);
                        }
                        else {
                            rowsAddedToDataSet = Fill((DataSet)data, srcTable, dataReader, startRecord, maxRecords);
                        }
                    }
                }
                finally { // QuietClose
                    DbDataAdapter.QuietClose(activeConnection, originalState);
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return rowsAddedToDataSet;
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill5"]/*' />
        virtual protected int Fill(DataSet dataSet, string srcTable, IDataReader dataReader, int startRecord, int maxRecords) {
            if (null == dataSet) {
                throw ADP.FillRequires("dataSet");
            }
            if (ADP.IsEmpty(srcTable)) {
                throw ADP.FillRequiresSourceTableName("srcTable");
            }
            if (null == dataReader) {
                throw ADP.FillRequires("dataReader");
            }
            if (startRecord < 0) {
                throw ADP.InvalidStartRecord("startRecord", startRecord);
            }
            if (maxRecords < 0) {
                throw ADP.InvalidMaxRecords("maxRecords", maxRecords);
            }
            if (dataReader.IsClosed) {
                return 0;
            }
            return FillFromReader((object)dataSet, srcTable, dataReader, startRecord, maxRecords, null, null);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Fill7"]/*' />
        virtual protected int Fill(DataTable dataTable, IDataReader dataReader) {
            if (null == dataTable) {
                throw ADP.FillRequires("dataTable");
            }
            if (null == dataReader) {
                throw ADP.FillRequires("dataReader");
            }
            if (dataReader.IsClosed || (dataReader.FieldCount <= 0)) {
                return 0;
            }
            return FillFromReader((object)dataTable, null, dataReader, 0, 0, null, null);
        }

        private void FillErrorHandler(Exception e, DataTable dataTable, object[] dataValues) {
            FillErrorEventArgs fillErrorEvent = new FillErrorEventArgs(dataTable, dataValues);
            fillErrorEvent.Errors = ADP.TraceException(e);
            OnFillError(fillErrorEvent);

            if (!fillErrorEvent.Continue) {
                if (null != fillErrorEvent.Errors) {
                    throw fillErrorEvent.Errors;
                }
                throw e;
            }
        }

        internal int FillFromReader(object data, string srcTable, IDataReader dataReader, int startRecord, int maxRecords, DataColumn parentChapterColumn, object parentChapterValue) {
            int rowsAddedToDataSet = 0;
            int schemaCount = 0;
            do {
                if (0 >= dataReader.FieldCount) {
                    continue; // loop to next result
                }

                SchemaMapping mapping = FillSchemaMappingTry(data, srcTable, dataReader, schemaCount, parentChapterColumn, parentChapterValue);
                schemaCount++;

                if (null == mapping) {
                    continue; // loop to next result
                }
                if (null == mapping.DataValues) {
                    continue; // loop to next result
                }
                if (null == mapping.DataTable) {
                    continue; // loop to next result
                }
                try { // try-filter-finally so and catch-throw
                    mapping.DataTable.BeginLoadData();
                    try {
                        // startRecord and maxRecords only apply to the first resultset
                        if ((1 == schemaCount) && ((0 < startRecord) || (0 < maxRecords))) {
                            rowsAddedToDataSet = FillLoadDataRowChunk(mapping, startRecord, maxRecords);
                        }
                        else {
                            int count = FillLoadDataRow(mapping);
                            if (1 == schemaCount) { // MDAC 71347
                                rowsAddedToDataSet = count;
                            }
                        }
                    }
                    finally { // EndLoadData
                        mapping.DataTable.EndLoadData();
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            } while (FillNextResult(dataReader));

            return rowsAddedToDataSet;
        }

        private int FillLoadDataRowChunk(SchemaMapping mapping, int startRecord, int maxRecords) {
            IDataReader dataReader = mapping.DataReader;

            while (0 < startRecord) {
                if (!dataReader.Read()) {
                    // there are no more rows on first resultset
                    // by continuing the do/while loop jumps to next result
                    return 0;
                }
                --startRecord;
            }

            int rowsAddedToDataSet = 0;
            if (0 < maxRecords) {
                bool acceptChanges = AcceptChangesDuringFill;

                while ((rowsAddedToDataSet < maxRecords) && dataReader.Read()) {
                    try {
                        mapping.LoadDataRow(hasFillErrorHandler, acceptChanges);
                        rowsAddedToDataSet++;
                    }
                    catch(Exception e) {
                        FillErrorHandler(e, mapping.DataTable, mapping.DataValues);
                    }
                }

                // skip remaining rows of the first resultset
                // by continuing the do/while loop jumps to next result
            
            } // maxRecords processing
            else {
                rowsAddedToDataSet = FillLoadDataRow(mapping);
            }
            return rowsAddedToDataSet;
        }

        private int FillLoadDataRow(SchemaMapping mapping) {
            int rowsAddedToDataSet = 0;

            bool acceptChanges = AcceptChangesDuringFill;
            IDataReader dataReader = mapping.DataReader;
            if (hasFillErrorHandler) {
                while (dataReader.Read()) { // read remaining rows of first and subsequent resultset
                    try {
                        mapping.LoadDataRow(true, acceptChanges);
                        rowsAddedToDataSet++;
                    }
                    catch(Exception e) {
                        FillErrorHandler(e, mapping.DataTable, mapping.DataValues);
                        continue;
                    }
                }
            }
            else {
                while (dataReader.Read()) { // read remaining rows of first and subsequent resultset
                    mapping.LoadDataRow(false, acceptChanges);
                    rowsAddedToDataSet++;
                }
            }
            return rowsAddedToDataSet;
        }

        private bool FillNextResult(IDataReader dataReader) {
            bool result = true;
            if (hasFillErrorHandler) {
                try {
                    result = dataReader.NextResult();
                }
                catch(Exception e) {
                    FillErrorHandler(e, null, null);
                }
            }
            else {
                result = dataReader.NextResult();
            }
            return result;
        }

        private SchemaMapping FillSchemaMapping(object data, string srcTable, IDataReader dataReader, int schemaCount, DataColumn parentChapterColumn, object parentChapterValue) {
            SchemaMapping mapping = new SchemaMapping(this, dataReader, (Data.MissingSchemaAction.AddWithKey == MissingSchemaAction));
            string tmp = null;

            if (data is DataTable) {
                mapping.DataTable = (DataTable)data;
            }
            else {
                Debug.Assert(data is DataSet, "data is not DataSet");

                mapping.DataSet = (DataSet) data;
                tmp = DbDataAdapter.GetSourceTableName(srcTable, schemaCount);
            }
            mapping.SetupSchema(SchemaType.Mapped, tmp, true, parentChapterColumn, parentChapterValue);
            return mapping;
        }

        private SchemaMapping FillSchemaMappingTry(object data, string srcTable, IDataReader dataReader, int schemaCount, DataColumn parentChapterColumn, object parentChapterValue) {
            SchemaMapping mapping = null;
            if (hasFillErrorHandler) {
                try {
                    mapping = FillSchemaMapping(data, srcTable, dataReader, schemaCount, parentChapterColumn, parentChapterValue);
                }
                catch(Exception e) {
                    FillErrorHandler(e, null, null);
                    //mapping = null;
                }
            }
            else {
                mapping = FillSchemaMapping(data, srcTable, dataReader, schemaCount, parentChapterColumn, parentChapterValue);
            }
            return mapping;
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.GetFillParameters"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        override public IDataParameter[] GetFillParameters() {
            IDataParameter[] value = null;
            IDbCommand select = SelectCommand;
            if (null != select) {
                IDataParameterCollection parameters = select.Parameters;
                if (null != parameters) {
                    value = new IDataParameter[parameters.Count];
                    parameters.CopyTo(value, 0);
                }
            }
            if (null == value) {
                value = new IDataParameter[0];
            }
            return value;
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.OnFillError"]/*' />
        virtual protected void OnFillError(FillErrorEventArgs value) {
            FillErrorEventHandler handler = (FillErrorEventHandler) Events[EventFillError];
            if (null != handler) {
                handler(this, value);
            }
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.OnRowUpdated"]/*' />
        abstract protected void OnRowUpdated(RowUpdatedEventArgs value);

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.OnRowUpdating"]/*' />
        abstract protected void OnRowUpdating(RowUpdatingEventArgs value);

        private void ParameterInput(IDataParameterCollection parameters, StatementType typeIndex, DataRow row, DataTableMapping mappings) {
            Data.MissingMappingAction missingMapping = UpdateMappingAction;
            Data.MissingSchemaAction missingSchema = UpdateSchemaAction;

            int count = parameters.Count;
            for (int i = 0; i < count; ++i) {
                IDataParameter parameter = (IDataParameter) parameters[i];
                if ((null != parameter) && (0 != (ParameterDirection.Input & parameter.Direction))) {

                    string columnName = parameter.SourceColumn;
                    if (!ADP.IsEmpty(columnName)) {

                        DataColumnMapping columnMapping = mappings.GetColumnMappingBySchemaAction(columnName, missingMapping);
                        if (null != columnMapping) {

                            DataColumn dataColumn = columnMapping.GetDataColumnBySchemaAction(row.Table, null, missingSchema);
                            if (null != dataColumn) {

                                DataRowVersion version = DbDataAdapter.GetParameterSourceVersion(typeIndex, parameter);
                                parameter.Value = row[dataColumn, version];
                            }
                            else {
                                // UNDONE: we shouldn't be replacing a user's value?
                                parameter.Value = null;
                            }
                        }
                        else {
                            // UNDONE: Debug.Assert(false, "Ignore mapped to Error by UpdateMappingAction");
                            parameter.Value = null;
                        }
                    }
#if DEBUG
                    if (AdapterSwitches.DataValue.TraceVerbose) {
                        ADP.TraceValue("adapter input parameter <" + parameter.ParameterName + "> ", parameter.Value);
                    }
#endif
                }
            }
        }

        private void ParameterOutput(IDataParameterCollection parameters, StatementType typeIndex, DataRow row, DataTableMapping mappings) {
            Data.MissingMappingAction missingMapping = UpdateMappingAction;
            Data.MissingSchemaAction missingSchema = UpdateSchemaAction;

            int count = parameters.Count;
            for (int i = 0; i < count; ++i) {
                IDataParameter parameter = (IDataParameter) parameters[i];
                if ((null != parameter) && (0 != (ParameterDirection.Output & parameter.Direction))) {

                    string columnName = parameter.SourceColumn;
                    if (!ADP.IsEmpty(columnName)) {

                        DataColumnMapping columnMapping = mappings.GetColumnMappingBySchemaAction(columnName, missingMapping);
                        if (null != columnMapping) {

                            DataColumn dataColumn = columnMapping.GetDataColumnBySchemaAction(row.Table, null, missingSchema);
                            if (null != dataColumn) {

                                if (dataColumn.ReadOnly) {
                                    dataColumn.ReadOnly = false;
                                    try { // try-filter-finally so and catch-throw
                                        try {
                                            row[dataColumn] = parameter.Value;
                                        }
                                        finally { // ReadOnly
                                            dataColumn.ReadOnly = true;
                                        }
                                    }
                                    catch { // MDAC 80973
                                        throw;
                                    }
                                }
                                else {
                                    row[dataColumn] = parameter.Value;
                                }
                            }
                        }
                    }
#if DEBUG
                    if (AdapterSwitches.DataValue.TraceVerbose) {
                        ADP.TraceValue("adapter output parameter <" + parameter.ParameterName + "> ", parameter.Value);
                    }
#endif
                }
            }
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Update"]/*' />
        override public int Update(DataSet dataSet) {
            //if (!TableMappings.Contains(DbDataAdapter.DefaultSourceTableName)) { // MDAC 59268
            //    throw ADP.UpdateRequiresSourceTable(DbDataAdapter.DefaultSourceTableName);
            //}
            return Update(dataSet, DbDataAdapter.DefaultSourceTableName);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Update1"]/*' />
        public int Update(DataRow[] dataRows) {
            if (null == dataRows) {
                throw ADP.ArgumentNull("dataRows");
            }
            if (0 == dataRows.Length) {
                return 0;
            }
            if (null == dataRows[0]) {
                throw ADP.UpdateNullRow(0);
            }
            if (null == dataRows[0].Table) {
                throw ADP.UpdateNullRowTable();
            }

            DataTable dataTable = dataRows[0].Table;
            DataSet dataSet = dataTable.DataSet;
            for (int i = 1; i < dataRows.Length; ++i) {
                if (null == dataRows[i]) {
                    throw ADP.UpdateNullRow(i);
                }
                if (dataTable != dataRows[i].Table) {
                    throw ADP.UpdateMismatchRowTable(i);
                }
            }

            DataTableMapping tableMapping = null;
            int index = IndexOfDataSetTable(dataTable.TableName);
            if (-1 != index) {
                tableMapping = TableMappings[index];
            }
            if (null == tableMapping) {
                if (System.Data.MissingMappingAction.Error == MissingMappingAction) {
                    throw ADP.MissingTableMappingDestination(dataTable.TableName);
                }
                tableMapping = new DataTableMapping(dataTable.TableName, dataTable.TableName);
            }
            return Update(dataRows, tableMapping);
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Update2"]/*' />
        public int Update(DataTable dataTable) {
            if (null == dataTable) {
                throw ADP.UpdateRequiresDataTable("dataTable");
            }

            DataTableMapping tableMapping = null;
            int index = IndexOfDataSetTable(dataTable.TableName);
            if (-1 != index) {
                tableMapping = TableMappings[index];
            }
            if (null == tableMapping) {
                if (System.Data.MissingMappingAction.Error == MissingMappingAction) {
                    throw ADP.MissingTableMappingDestination(dataTable.TableName);
                }
                tableMapping = new DataTableMapping(DbDataAdapter.DefaultSourceTableName, dataTable.TableName);
            }

            int rowsAffected = 0;
            const DataViewRowState rowStates = DataViewRowState.Added | DataViewRowState.Deleted | DataViewRowState.ModifiedCurrent;
            DataRow[] dataRows = ADP.SelectRows(dataTable, rowStates);

            if ((null != dataRows) && (0 < dataRows.Length)) {
                rowsAffected = Update(dataRows, tableMapping);
            }
            return rowsAffected;
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Update3"]/*' />
        public int Update(DataSet dataSet, string srcTable) {
            if (null == dataSet) {
                throw ADP.UpdateRequiresNonNullDataSet("dataSet");
            }
            if (ADP.IsEmpty(srcTable)) {
                throw ADP.UpdateRequiresSourceTableName("srcTable");
            }
#if DEBUG
            if (AdapterSwitches.DataTrace.TraceVerbose) {
                ADP.TraceDataSet("Update <" + srcTable + ">", dataSet);
            }
#endif

            int rowsAffected = 0;

            System.Data.MissingMappingAction missingMapping = UpdateMappingAction;
            DataTableMapping tableMapping = GetTableMappingBySchemaAction(srcTable, srcTable, UpdateMappingAction);
            Debug.Assert(null != tableMapping, "null TableMapping when MissingMappingAction.Error");

            // the ad-hoc scenario of no dataTable just returns
            // ad-hoc scenario is defined as MissingSchemaAction.Add or MissingSchemaAction.Ignore
            System.Data.MissingSchemaAction schemaAction = UpdateSchemaAction;
            DataTable dataTable = tableMapping.GetDataTableBySchemaAction(dataSet, schemaAction);
            if (null != dataTable) {
                const DataViewRowState rowStates = DataViewRowState.Added | DataViewRowState.Deleted | DataViewRowState.ModifiedCurrent;
                DataRow[] dataRows = ADP.SelectRows(dataTable, rowStates);

                if ((null != dataRows) && (0 < dataRows.Length)) {
                    rowsAffected = Update(dataRows, tableMapping);
                }
            }
            else if (null == tableMapping.Parent) {
                //throw error since the user didn't explicitly map this tableName to Ignore.
                throw ADP.UpdateRequiresSourceTable(srcTable); // MDAC 72681
            }
            return rowsAffected;
        }

        /// <include file='doc\DbDataAdapter.uex' path='docs/doc[@for="DbDataAdapter.Update4"]/*' />
        virtual protected int Update(DataRow[] dataRows, DataTableMapping tableMapping) {
            Debug.Assert((null != dataRows) && (0 < dataRows.Length), "Update: bad dataRows");
            Debug.Assert(null != tableMapping, "Update: bad DataTableMapping");

            // If records were affected, increment row count by one - that is number of rows affected in dataset.
            int cumulativeRecordsAffected = 0;

            IDbConnection[] connections = new IDbConnection[4];
            ConnectionState[] connectionStates = new ConnectionState[4]; // closed by default (== 0)

            // UNDONE: wasNullCommand is not used correctly
            bool wasNullCommand = false; // MDAC 58710
            IDbCommand tmpcmd = SelectCommand;
            if (null != tmpcmd) {
                connections[0] = tmpcmd.Connection;
                if (null != connections[0]) {
                    connectionStates[0] = connections[0].State;
                }
            }

            // the outer try/finally is for closing any connections we may open
            try {
                try {
                    // for each row which is either insert, update, or delete
                    int length = dataRows.Length;
                    for (int i = 0; i < length; ++i) {
                        DataRow dataRow = dataRows[i];
                        if (null == dataRow) {
                            continue;
                        }

                        StatementType commandIndex;
                        IDbCommand dataCommand;
                        string commandType; // used as event.CommandType and as the suffix for ADP_UpReqCommand error string

                        DataRowState rowstate = dataRow.RowState;
                        switch (rowstate) {
                        case DataRowState.Detached:
                        case DataRowState.Unchanged:
                            continue; // foreach DataRow

                        case DataRowState.Added:
                            commandIndex = StatementType.Insert;
                            dataCommand = InsertCommand;
                            commandType = ADP.Insert;
                            break;
                        case DataRowState.Deleted:
                            commandIndex = StatementType.Delete;
                            dataCommand = DeleteCommand;
                            commandType = ADP.Delete;
                            break;
                        case DataRowState.Modified:
                            commandIndex = StatementType.Update;
                            dataCommand = UpdateCommand;
                            commandType = ADP.Update;
                            break;
                        default:
                            // $CONSIDER - would we rather just ignore this row
                            throw ADP.UpdateUnknownRowState((int) rowstate); // out of Update
                        }

                        // setup the event to be raised
                        RowUpdatingEventArgs rowUpdatingEvent = CreateRowUpdatingEvent(dataRow, dataCommand, commandIndex, tableMapping);

                        // this try/catch for any exceptions during the parameter initialization
                        try {
                            dataRow.RowError = null; // MDAC 67185
                            if (null != dataCommand) {
                                // prepare the parameters for the user who then can modify them during OnRowUpdating
                                ParameterInput(dataCommand.Parameters, commandIndex, dataRow, tableMapping);
                            }
                        }
                        catch (Exception e) {
                            ADP.TraceException(e);

                            rowUpdatingEvent.Errors = e;
                            rowUpdatingEvent.Status = UpdateStatus.ErrorsOccurred;
                        }

                        OnRowUpdating(rowUpdatingEvent); // user may throw out of Update

                        // handle the status from RowUpdating event
                        switch (rowUpdatingEvent.Status) {
                        case UpdateStatus.Continue:
                            break;

                        case UpdateStatus.ErrorsOccurred: // user didn't handle the error
                            if (null == rowUpdatingEvent.Errors) {
                                rowUpdatingEvent.Errors = ADP.RowUpdatingErrors();
                            }
                            dataRow.RowError += rowUpdatingEvent.Errors.Message; // MDAC 65808
                            if (ContinueUpdateOnError) { // MDAC 66900
                                continue; // foreach DataRow
                            }
                            throw rowUpdatingEvent.Errors; // out of Update

                        case UpdateStatus.SkipCurrentRow: // cancel the row, continue the method
                            if (DataRowState.Unchanged == dataRow.RowState) { // MDAC 66286
                                cumulativeRecordsAffected++;
                            }
                            continue; // foreach DataRow

                        case UpdateStatus.SkipAllRemainingRows: // cancel the Update method
                            if (DataRowState.Unchanged == dataRow.RowState) { // MDAC 66286
                                cumulativeRecordsAffected++;
                            }
                            return cumulativeRecordsAffected; // out of Update

                        default:
                            Debug.Assert(false, "invalid RowUpdating status " + ((int) rowUpdatingEvent.Status).ToString());
                            throw ADP.InvalidUpdateStatus((int) rowUpdatingEvent.Status);  // out of Update
                        }

                        // use event.command, not event.Command which clones the command and always !=
                        if (dataCommand != rowUpdatingEvent.Command) {
                            dataCommand = rowUpdatingEvent.Command;
                            commandType = ADP.Clone;
                        }

                        // can't use commandType - need to use original command type
                        RowUpdatedEventArgs rowUpdatedEvent = CreateRowUpdatedEvent(dataRow, dataCommand, rowUpdatingEvent.StatementType, tableMapping);
                        rowUpdatingEvent = null;

                        // this try/catch for any exceptions during the execution, population, output parameters
                        try {
                            if (null == dataCommand) {
                                throw ADP.UpdateRequiresCommand(commandType); // for OnRowUpdated
                            }
                            IDbConnection activeConnection = DbDataAdapter.GetConnection(dataCommand, commandType);
                            Debug.Assert(null != activeConnection, "unexpected null connection");

                            if (activeConnection != connections[(int) commandIndex]) {
                                // if the user has changed the connection on the command object
                                // and we had opened that connection, close that connection
                                DbDataAdapter.QuietClose(connections[(int) commandIndex], connectionStates[(int) commandIndex]);

                                connections[(int) commandIndex] = activeConnection;
                                connectionStates[(int) commandIndex] = ConnectionState.Closed; // required, open may throw

                                if (wasNullCommand && (connections[0] == activeConnection)) {
                                    ConnectionState originalState;
                                    DbDataAdapter.QuietOpen(activeConnection, out originalState);
                                    connectionStates[(int) commandIndex] = connections[0].State;
                                }
                                else {
                                    DbDataAdapter.QuietOpen(activeConnection, out connectionStates[(int) commandIndex]);
                                }
                            }
                            UpdateRow(rowUpdatedEvent, commandType);
                        }
                        catch (Exception e) { // try/catch for RowUpdatedEventArgs
                            ADP.TraceException(e);

                            rowUpdatedEvent.Errors = e;
                            rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;
                        }

                        OnRowUpdated(rowUpdatedEvent); // user may throw out of Update

                        switch (rowUpdatedEvent.Status) {
                        case UpdateStatus.Continue:
                            // 1. We delay accepting the changes until after the RowUpdatedEventArgs so the user
                            // has a chance to call RejectChanges for any given reason
                            // 2. If the DataSource return 0 records affected, its an indication that
                            // the command didn't take so we don't want to automatically AcceptChanges.
                            // With 'set nocount on' the count will be -1, accept changes in that case too.
                            // 3.  Don't accept changes if no rows were affected, the user needs to know
                            // that there is a concurrency violation
                            if (0 != rowUpdatedEvent.RecordsAffected) {
                                // Only accept changes if the row is not already accepted, ie detached.
                                switch(dataRow.RowState) {
                                case DataRowState.Detached:
                                case DataRowState.Unchanged:
                                    break;
                                case DataRowState.Added:
                                case DataRowState.Deleted:
                                case DataRowState.Modified:
                                    dataRow.AcceptChanges();
                                    break;
                                }

                                // If records were affected, increment row count by one - that is
                                // number of rows affected in dataset.
                                cumulativeRecordsAffected++;
                            }
                            break;

                        case UpdateStatus.ErrorsOccurred:
                            if (null == rowUpdatedEvent.Errors) {
                                rowUpdatedEvent.Errors = ADP.RowUpdatedErrors();
                            }
                            dataRow.RowError += rowUpdatedEvent.Errors.Message; // MDAC 65808
                            if (ContinueUpdateOnError) { // MDAC 66900
                                continue; // foreach DataRow
                            }
                            throw rowUpdatedEvent.Errors; // out of Update

                        case UpdateStatus.SkipCurrentRow:
                            if (DataRowState.Unchanged == dataRow.RowState) { // MDAC 66286
                                cumulativeRecordsAffected++;
                            }
                            continue; // foreach DataRow without accepting changes on this row

                        case UpdateStatus.SkipAllRemainingRows: // cancel the Update method
                            // the user will need to manually accept the row changes
                            // RowUpdatedEventArgs.Row.AcceptChanges()
                            if (DataRowState.Unchanged == dataRow.RowState) { // MDAC 66286
                                cumulativeRecordsAffected++;
                            }
                            return cumulativeRecordsAffected; // out of Update

                        default:
                            Debug.Assert(false, "invalid RowUpdated status " + ((int) rowUpdatedEvent.Status).ToString());
                            throw ADP.InvalidUpdateStatus((int) rowUpdatedEvent.Status);

                        } // switch RowUpdatedEventArgs.Status
                    } // foreach DataRow
                }
                finally { // try/finally for connection cleanup
                    for (int i = 0; i < 4; i++) {
                        DbDataAdapter.QuietClose(connections[i], connectionStates[i]);
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return cumulativeRecordsAffected;
        }

        private void UpdateRow(RowUpdatedEventArgs rowUpdatedEvent, string commandType) {
            IDbCommand dataCommand = rowUpdatedEvent.Command;
            StatementType commandIndex = rowUpdatedEvent.StatementType;
            if (null == dataCommand) {
                throw ADP.UpdateRequiresCommand(commandType); // for OnRowUpdated
            }
            IDbConnection activeConnection = dataCommand.Connection;

            ConnectionState state = activeConnection.State;
            if (ConnectionState.Open != state) {
                throw ADP.OpenConnectionRequired(commandType, state);
            }

            bool insertAcceptChanges = true;
            UpdateRowSource updatedRowSource = dataCommand.UpdatedRowSource;
            try { // try-filter-finally so and catch-throw
                using(IDataReader dataReader = dataCommand.ExecuteReader(CommandBehavior.SequentialAccess)) {
                    try {
                        // we only care about the first row of the first result
                        if ((null != dataReader) && (StatementType.Delete != commandIndex) && (0 != (UpdateRowSource.FirstReturnedRecord & updatedRowSource))) {
                            bool getData = false;
                            do {
                                // advance to the first row returning result set
                                // determined by actually having columns in the result set
                                if (0 < dataReader.FieldCount) {
                                    getData = true;
                                    break;
                                }
                            } while (dataReader.NextResult());

                            if (getData && (0 != dataReader.RecordsAffected)) { // MDAC 71174
                                SchemaMapping mapping = new SchemaMapping(this, dataReader, false);
                                mapping.DataTable = rowUpdatedEvent.Row.Table; // set DataTable, not DataSet which implies chapter support
                                mapping.SetupSchema(SchemaType.Mapped, rowUpdatedEvent.TableMapping.SourceTable, true, null, null);

                                if ((null != mapping.DataTable) && (null != mapping.DataValues)) {
                                    if (dataReader.Read()) {
                                        if ((StatementType.Insert == commandIndex)/* && insertAcceptChanges*/) { // MDAC 64199
                                            rowUpdatedEvent.Row.AcceptChanges();
                                            insertAcceptChanges = false;
                                        }
                                        mapping.ApplyToDataRow(rowUpdatedEvent.Row);
                                    }
                                }
                            }
                        }
                    }
                    finally { // Close & RecordsAffected
                        if (null != dataReader) {
                            // using Close which can optimize its { while(dataReader.NextResult()); } loop
                            dataReader.Close();

                            // RecordsAffected is available after Close, but don't trust it after Dispose
                            rowUpdatedEvent.recordsAffected = dataReader.RecordsAffected;
                        }
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }

            // map the parameter results to the dataSet
            if ((StatementType.Delete != commandIndex) && (0 != (UpdateRowSource.OutputParameters & updatedRowSource) && (0 != rowUpdatedEvent.recordsAffected))) { // MDAC 71174
                if ((StatementType.Insert == commandIndex) && insertAcceptChanges) { // MDAC 64199
                    rowUpdatedEvent.Row.AcceptChanges();
                    //insertAcceptChanges = false;
                }
                ParameterOutput(dataCommand.Parameters, commandIndex, rowUpdatedEvent.Row, rowUpdatedEvent.TableMapping);
            }

            // Only error if RecordsAffect == 0, not -1.  A value of -1 means no count was received from server,
            // do not error in that situation (means 'set nocount on' was executed on server).
            if ((UpdateStatus.Continue == rowUpdatedEvent.Status) && (rowUpdatedEvent.RecordsAffected == 0)
                && ((StatementType.Delete == commandIndex) || (StatementType.Update == commandIndex))) {
                // bug50526, an exception if no records affected and attempted an Update/Delete
                Debug.Assert(null == rowUpdatedEvent.Errors, "Continue - but contains an exception");
                rowUpdatedEvent.Errors = ADP.UpdateConcurrencyViolation(rowUpdatedEvent.StatementType, rowUpdatedEvent.Row); // MDAC 55735
                rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;
            }
        }

        // used by FillSchema which returns an array of datatables added to the
        // dataset
        static private DataTable[] AddDataTableToArray(DataTable[] tables, DataTable newTable) {
            Debug.Assert(null != tables, "AddDataTableToArray: null tables");

            int length = tables.Length;
            for (int i = 0; i < length; ++i) { // search for duplicates
                if (tables[i] ==  newTable) {
                    return tables; // duplicate found
                }
            }
            DataTable[] newTables = new DataTable[length+1]; // add unique data table
            for (int i = 0; i < length; ++i) {
                newTables[i] = tables[i];
            }
            newTables[length] = newTable;
            return newTables;
        }

        static private IDbConnection GetConnection(IDbCommand command, string method) {
            Debug.Assert(null != command, "GetConnection: null command");
            IDbConnection connection = command.Connection;
            if ((null == connection) && (null != method)) {
                throw ADP.ConnectionRequired(method);
            }
            return connection;
        }

        // dynamically generate source table names
        static internal string GetSourceTableName(string srcTable, int index) {
            //if ((null != srcTable) && (0 <= index) && (index < srcTable.Length)) {
            if (0 == index) {
                return srcTable; //[index];
            }
            return srcTable + index.ToString();
        }

        static private DataRowVersion GetParameterSourceVersion(StatementType typeIndex, IDataParameter parameter) {
            switch (typeIndex) {
            case StatementType.Insert: return DataRowVersion.Current;  // ignores parameter.SourceVersion
            case StatementType.Update: return parameter.SourceVersion;
            case StatementType.Delete: return DataRowVersion.Original; // ignores parameter.SourceVersion
            default:
                Debug.Assert(false, "Invalid updateType: " + typeIndex.ToString());
                return DataRowVersion.Proposed; // something that shouldn't work
            }
        }

        static private void QuietClose(IDbConnection connection, ConnectionState originalState) {
            if ((null != connection) && (ConnectionState.Closed == originalState)) {
                // we don't have to check the current connection state because
                // it is supposed to be safe to call Close multiple times
                connection.Close();
            }
        }

        // QuietOpen needs to appear in the try {} finally { QuietClose } block
        // otherwise a possibility exists that an exception may be thrown, i.e. ThreadAbortException
        // where we would Open the connection and not close it
        static private void QuietOpen(IDbConnection connection, out ConnectionState originalState) {
            Debug.Assert(null != connection, "QuiteClose: null connection");

            originalState = connection.State;
            if (ConnectionState.Closed == originalState) {
                connection.Open();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbdatarecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="dbdatarecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.IO;
    using System.Threading;

    /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord"]/*' />
    public class DbDataRecord : IDataRecord, ICustomTypeDescriptor {
        internal SchemaInfo[] _schemaInfo;
        internal object[] _values;
        private PropertyDescriptorCollection _propertyDescriptors;
        private FieldNameLookup _fieldNameLookup; // MDAC 69015
        
        // copy all runtime data information
        internal DbDataRecord(SchemaInfo[] schemaInfo, object[] values, PropertyDescriptorCollection descriptors, FieldNameLookup fieldNameLookup) {
            Debug.Assert(null != schemaInfo, "invalid attempt to instantiate DbDataRecord with null schema information");
            Debug.Assert(null != values, "invalid attempt to instantiate DbDataRecord with null value[]");
            _schemaInfo = schemaInfo;
            _values = values;
            _propertyDescriptors = descriptors;
            _fieldNameLookup = fieldNameLookup;
        }
        
        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.FieldCount"]/*' />
        public int FieldCount {   
            get {
                return _schemaInfo.Length;
            }               
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetValues"]/*' />
        public int GetValues(object[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }

            int copyLen = (values.Length < _schemaInfo.Length) ? values.Length : _schemaInfo.Length;
            for (int i = 0; i < copyLen; i++) {                
                values[i] = _values[i];
            }                
            return copyLen;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetName"]/*' />
        public string GetName(int i) {
            return _schemaInfo[i].name;
        }


        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetValue"]/*' />
        public object GetValue(int i) {
            return _values[i];
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetDataTypeName"]/*' />
        public string GetDataTypeName(int i) {
            return _schemaInfo[i].typeName;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetFieldType"]/*' />
        public Type GetFieldType(int i) {
            return _schemaInfo[i].type;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetOrdinal"]/*' />
        public int GetOrdinal(string name) { // MDAC 69015
            return _fieldNameLookup.GetOrdinal(name); // MDAC 71470
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.this"]/*' />
        public object this[int i] {
            get {
                return GetValue(i);
            }
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.this1"]/*' />
        public object this[string name] {
            get {
                return GetValue(GetOrdinal(name));              
            }
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetBoolean"]/*' />
        public bool GetBoolean(int i) {
            return((bool) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetByte"]/*' />
        public byte GetByte(int i) {
            return((byte) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetBytes"]/*' />
        public long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length) {
            int cbytes = 0;
            int ndataIndex;

            byte[] data = (byte[])_values[i];
            
            cbytes = data.Length;

            // since arrays can't handle 64 bit values and this interface doesn't 
            // allow chunked access to data, a dataIndex outside the rang of Int32
            // is invalid
            if (dataIndex > Int32.MaxValue) {
            	throw ADP.InvalidSourceBufferIndex(cbytes, dataIndex);
            }

            ndataIndex = (int)dataIndex;

            // if no buffer is passed in, return the number of characters we have
            if (null == buffer)
                return cbytes;

            try {
                if (ndataIndex < cbytes) {
                    // help the user out in the case where there's less data than requested
                    if ((ndataIndex + length) > cbytes)
                        cbytes = cbytes - ndataIndex;
                    else
                        cbytes = length;
                }

				// until arrays are 64 bit, we have to do these casts
                Array.Copy(data, ndataIndex, buffer, bufferIndex, (int)cbytes);
            }
            catch (Exception e) {
                cbytes = data.Length;
            
                if (length < 0)
                    throw ADP.InvalidDataLength(length);

                // if bad buffer index, throw
                if (bufferIndex < 0 || bufferIndex >= buffer.Length)
                    throw ADP.InvalidDestinationBufferIndex(length, bufferIndex);

                // if bad data index, throw 
                if (dataIndex < 0 || dataIndex >= cbytes)
                    throw ADP.InvalidSourceBufferIndex(length, dataIndex);

                // if there is not enough room in the buffer for data
                if (cbytes + bufferIndex > buffer.Length)
                    throw ADP.InvalidBufferSizeOrIndex(cbytes, bufferIndex);

                throw e;
            }    

            return cbytes;        
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetChar"]/*' />
        public char GetChar(int i) {
            string s;

            s = (string)_values[i];

            // UNDONE:  I thought that String had a Char property on it like: s.Char[0]?
            char[] c = s.ToCharArray();
            return c[0];
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetChars"]/*' />
        public long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length) {
            int cchars = 0;
            string s;
            int ndataIndex;

            // if the object doesn't contain a char[] then the user will get an exception
            s = (string)_values[i];

            char[] data = s.ToCharArray();

            cchars = data.Length;

            // since arrays can't handle 64 bit values and this interface doesn't 
            // allow chunked access to data, a dataIndex outside the rang of Int32
            // is invalid
            if (dataIndex > Int32.MaxValue) {
            	throw ADP.InvalidSourceBufferIndex(cchars, dataIndex);
            }

            ndataIndex = (int)dataIndex;
            

            // if no buffer is passed in, return the number of characters we have
            if (null == buffer)
                return cchars;

            try {
                if (ndataIndex < cchars) {
                    // help the user out in the case where there's less data than requested
                    if ((ndataIndex + length) > cchars)
                        cchars = cchars - ndataIndex;
                    else
                        cchars = length;
                }

                Array.Copy(data, ndataIndex, buffer, bufferIndex, cchars);
            }
            catch (Exception e) {
                cchars = data.Length;
    
                if (length < 0)
                   throw ADP.InvalidDataLength(length);
    
                // if bad buffer index, throw
                if (bufferIndex < 0 || bufferIndex >= buffer.Length)
                    throw ADP.InvalidDestinationBufferIndex(buffer.Length, bufferIndex);

                // if bad data index, throw 
                if (ndataIndex < 0 || ndataIndex >= cchars)
                    throw ADP.InvalidSourceBufferIndex(cchars, dataIndex);

                // if there is not enough room in the buffer for data
                if (cchars + bufferIndex > buffer.Length)
                    throw ADP.InvalidBufferSizeOrIndex(cchars, bufferIndex);

                throw e;
            }
            
            return cchars;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetGuid"]/*' />
        public Guid GetGuid(int i) {
            return ((Guid)_values[i]);
        }
        

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetInt16"]/*' />
        public Int16 GetInt16(int i) {
            return((Int16) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetInt32"]/*' />
        public Int32 GetInt32(int i) {
            return((Int32) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetInt64"]/*' />
        public Int64 GetInt64(int i) {
            return((Int64) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetFloat"]/*' />
        public float GetFloat(int i) {
            return((float) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetDouble"]/*' />
        public double GetDouble(int i) {
            return((double) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetString"]/*' />
        public string GetString(int i) {
            return((string) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetDecimal"]/*' />
        public Decimal GetDecimal(int i) {
            return((Decimal) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetDateTime"]/*' />
        public DateTime GetDateTime(int i) {
            return((DateTime) _values[i]);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.GetData"]/*' />
        public IDataReader GetData(int i) {
            throw ADP.NotSupported();
        }
        
        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.IsDBNull"]/*' />
        public bool IsDBNull(int i) {
            object o = _values[i];
            return (null == o || Convert.IsDBNull(o));
        }

        //
        // ICustomTypeDescriptor
        //

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetAttributes"]/*' />
        /// <internalonly/>
        AttributeCollection ICustomTypeDescriptor.GetAttributes() {
            return new AttributeCollection(null);

        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetClassName"]/*' />
        /// <internalonly/>
        string ICustomTypeDescriptor.GetClassName() {
            return null;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetComponentName"]/*' />
        /// <internalonly/>
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetConverter"]/*' />
        /// <internalonly/>
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetDefaultEvent"]/*' />
        /// <internalonly/>
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return null;
        }


        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetDefaultProperty"]/*' />
        /// <internalonly/>
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {
            return null;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetEditor"]/*' />
        /// <internalonly/>
        object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            return null;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetEvents"]/*' />
        /// <internalonly/>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return new EventDescriptorCollection(null);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetEvents1"]/*' />
        /// <internalonly/>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
            return new EventDescriptorCollection(null);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetProperties"]/*' />
        /// <internalonly/>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() {
            return((ICustomTypeDescriptor)this).GetProperties(null);
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetProperties1"]/*' />
        /// <internalonly/>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
            if(_propertyDescriptors == null) {
                _propertyDescriptors = new PropertyDescriptorCollection(null);
            }
            return _propertyDescriptors;
        }

        /// <include file='doc\dbdatarecord.uex' path='docs/doc[@for="DbDataRecord.ICustomTypeDescriptor.GetPropertyOwner"]/*' />
        /// <internalonly/>
        object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }
    }
    
    // this doesn't change per record, only alloc once
    internal class SchemaInfo {
        internal string name;
        internal string typeName;
        internal Type type;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbschemarow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSchemaRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Diagnostics;

    /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow"]/*' />
    /// <devdoc>
    /// </devdoc>
    sealed internal class DBSchemaRow {
        DBSchemaTable schemaTable;
        DataRow dataRow;

        static internal DBSchemaRow[] GetSortedSchemaRows(DataTable dataTable) { // MDAC 60609
            DataColumn sortindex = new DataColumn("SchemaMapping Unsorted Index", typeof(Int32)); // MDAC 67050
            dataTable.Columns.Add(sortindex);
            int count = dataTable.Rows.Count;
            for (int i = 0; i < count; ++i) {
                dataTable.Rows[i][sortindex] = i;
            };
            DBSchemaTable schemaTable = new DBSchemaTable(dataTable);

            const DataViewRowState rowStates = DataViewRowState.Unchanged | DataViewRowState.Added | DataViewRowState.ModifiedCurrent;
            DataRow[] dataRows = dataTable.Select(null, "ColumnOrdinal ASC", rowStates);
            Debug.Assert(null != dataRows, "GetSchemaRows: unexpected null dataRows");

            DBSchemaRow[] schemaRows = new DBSchemaRow[dataRows.Length];

            for (int i = 0; i < dataRows.Length; ++i) {
                schemaRows[i] = new DBSchemaRow(schemaTable, dataRows[i]);
            }
            return schemaRows;
        }
        
        /*static internal DBSchemaRow[] GetSchemaRows(DataTable dataTable) {
            DBSchemaTable schemaTable = new DBSchemaTable(dataTable);

            const DataViewRowState rowStates = DataViewRowState.Unchanged | DataViewRowState.Added | DataViewRowState.ModifiedCurrent;
            DataRow[] dataRows = ADP.SelectRows(dataTable, rowStates);
            Debug.Assert(null != dataRows, "GetSchemaRows: unexpected null dataRows");

            DBSchemaRow[] schemaRows = new DBSchemaRow[dataRows.Length];

            for (int i = 0; i < dataRows.Length; ++i) {
                schemaRows[i] = new DBSchemaRow(schemaTable, dataRows[i]);
            }
            return schemaRows;
        }*/

        internal DBSchemaRow(DBSchemaTable schemaTable, DataRow dataRow) {
            this.schemaTable = schemaTable;
            this.dataRow = dataRow;
        }

        internal DataRow DataRow {
            get {
                return dataRow;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.ColumnName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string ColumnName {
            get {
                Debug.Assert(null != schemaTable.ColumnName, "no column ColumnName");
                object value = dataRow[schemaTable.ColumnName, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToString(value);
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.ColumnName, "missing column ColumnName");
                dataRow[schemaTable.ColumnName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Ordinal"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int32 Ordinal {
            /*get {
                Debug.Assert(null != schemaTable.Ordinal, "no column Ordinal");
                return Convert.ToInt32(dataRow[schemaTable.Ordinal, DataRowVersion.Default]);
            }*/
            set {
                Debug.Assert(null != schemaTable.Ordinal, "missing column Ordinal");
                dataRow[schemaTable.Ordinal] = value;
            }

        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Size"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int32 Size {
            get {
                Debug.Assert(null != schemaTable.Size, "no column Size");
                object value = dataRow[schemaTable.Size, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToInt32(value);
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.Size, "missing column Size");
                dataRow[schemaTable.Size] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Precision"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int16 Precision {
            get {
                Debug.Assert(null != schemaTable.Precision, "no column Precision");
                object value = dataRow[schemaTable.Precision, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToInt16(value);
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.Precision, "missing column Precision");
                dataRow[schemaTable.Precision] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Scale"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int16 Scale {
            get {
                Debug.Assert(null != schemaTable.Scale, "no column Scale");
                object value = dataRow[schemaTable.Scale, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToInt16(value);
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.Scale, "missing column Scale");
                dataRow[schemaTable.Scale] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseColumnName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseColumnName {
            get {
                if (null != schemaTable.BaseColumnName) {
                    object value = dataRow[schemaTable.BaseColumnName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseColumnName, "missing column BaseColumnName");
                dataRow[schemaTable.BaseColumnName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseServerName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseServerName {
            get {
                if (null != schemaTable.BaseServerName) {
                    object value = dataRow[schemaTable.BaseServerName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseServerName, "missing column BaseServerName");
                dataRow[schemaTable.BaseServerName] = value;
            }
        }
        
    
        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseCatalogName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseCatalogName {
            get {
                if (null != schemaTable.BaseCatalogName) {
                    object value = dataRow[schemaTable.BaseCatalogName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseCatalogName, "missing column BaseCatalogName");
                dataRow[schemaTable.BaseCatalogName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseSchemaName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseSchemaName {
            get {
                if (null != schemaTable.BaseSchemaName) {
                    object value = dataRow[schemaTable.BaseSchemaName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseSchemaName, "missing column BaseSchemaName");
                dataRow[schemaTable.BaseSchemaName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseTableName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseTableName {
            get {
                if (null != schemaTable.BaseTableName) {
                    object value = dataRow[schemaTable.BaseTableName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseTableName, "missing column BaseTableName");
                dataRow[schemaTable.BaseTableName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.IsAutoIncrement"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal bool IsAutoIncrement {
            get {
                if (null != schemaTable.IsAutoIncrement) {
                    object value = dataRow[schemaTable.IsAutoIncrement, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsAutoIncrement, "missing column IsAutoIncrement");
                dataRow[schemaTable.IsAutoIncrement] = (bool)value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.IsUnique"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal bool IsUnique {
            get {
                if (null != schemaTable.IsUnique) {
                    object value = dataRow[schemaTable.IsUnique, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsUnique, "missing column IsUnique");
                dataRow[schemaTable.IsUnique] = (bool)value;
            }
        }

        internal bool IsRowVersion {
            get {
                if (null != schemaTable.IsRowVersion) {
                    object value = dataRow[schemaTable.IsRowVersion, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsRowVersion, "missing column IsRowVersion");
                dataRow[schemaTable.IsRowVersion] = value;
            }
        }
        
        internal bool IsKey {
            get {
                if (null != schemaTable.IsKey) {
                    object value = dataRow[schemaTable.IsKey, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsKey, "missing column IsKey");
                dataRow[schemaTable.IsKey] = value;
            }
        }

        // consider:  just do comparison directly -> (object)(baseColumnName) == (object)(columnName)
        internal bool IsAliased {
            /*get {
                if (null != schemaTable.IsAliased) { // MDAC 62336
                    object value = dataRow[schemaTable.IsAliased, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }*/
            set {
                Debug.Assert(null != schemaTable.IsAliased, "missing column IsAliased");
                dataRow[schemaTable.IsAliased] = value;
            }
        }

        internal bool IsExpression {
            get {
                if (null != schemaTable.IsExpression) { // MDAC 62336
                    object value = dataRow[schemaTable.IsExpression, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsExpression, "missing column IsExpression");
                dataRow[schemaTable.IsExpression] = value;
            }
        }

        internal bool IsIdentity {
            /*get {
                if (null != schemaTable.IsIdentity) { // MDAC 62336
                    object value = dataRow[schemaTable.IsIdentity, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }*/
            set {
                Debug.Assert(null != schemaTable.IsIdentity, "missing column IsIdentity");
                dataRow[schemaTable.IsIdentity] = value;
            }
        }

        internal bool IsHidden {
            get {
                if (null != schemaTable.IsHidden) { // MDAC 62336
                    object value = dataRow[schemaTable.IsHidden, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsHidden, "missing column IsHidden");
                dataRow[schemaTable.IsHidden] = value;
            }
        }

        internal bool IsLong {
            get {
                if (null != schemaTable.IsLong) { // MDAC 62336
                    object value = dataRow[schemaTable.IsLong, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsLong, "missing column IsHidden");
                dataRow[schemaTable.IsLong] = value;
            }
        }

        internal bool IsReadOnly {
            get {
                if (null != schemaTable.IsReadOnly) { // MDAC 62336
                    object value = dataRow[schemaTable.IsReadOnly, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsReadOnly, "missing column IsReadOnly");
                dataRow[schemaTable.IsReadOnly] = value;
            }
        }

        internal System.Type DataType {
            get {
                if (null != schemaTable.DataType) {
                    object value = dataRow[schemaTable.DataType, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return(System.Type) value;
                    }
                }
                Debug.Assert(false, "missing value DataType");
                return null;
            }
            set {
                Debug.Assert(null != schemaTable.DataType, "missing column DataType");
                dataRow[schemaTable.DataType] = value;
            }
        }

        internal bool AllowDBNull {
            get {
                if (null != schemaTable.AllowDBNull) {
                    object value = dataRow[schemaTable.AllowDBNull, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return true;
            }
            set {
                Debug.Assert(null != schemaTable.AllowDBNull, "missing column MaybeNull");
                dataRow[schemaTable.AllowDBNull] = value;
            }
        }
        
        internal Int32 ProviderType {
            get {
                if (null != schemaTable.ProviderType) {
                    object value = dataRow[schemaTable.ProviderType, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToInt32(value);
                    }
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.ProviderType, "missing column ProviderType");
                dataRow[schemaTable.ProviderType] = value;
            }
        }

        internal Int32 UnsortedIndex {
            get {
                return (Int32) dataRow[schemaTable.UnsortedIndex, DataRowVersion.Default];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\codegen\datacache.cs ===
//------------------------------------------------------------------------------
// <copyright file="datacache.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.ComponentModel;
    using System.Reflection;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\datacache.uex' path='docs/doc[@for="TypedDataSetGenerator"]/*' />
    public class TypedDataSetGenerator {
        private bool            useExtendedNaming;
        private ICodeGenerator  codeGen;
        private ArrayList       errorList;
        private Hashtable	lookupIdentifiers;

        /// <include file='doc\datacache.uex' path='docs/doc[@for="TypedDataSetGenerator.Generate"]/*' />
        public static void Generate(DataSet dataSet, CodeNamespace codeNamespace, ICodeGenerator codeGen) {
            new TypedDataSetGenerator().GenerateCode(dataSet, codeNamespace, codeGen);
            CodeGenerator.ValidateIdentifiers(codeNamespace);
        }

        // given a variable name, this method will check to see if the 
        // name is a valid identifier name. if this is not the case, then
        // at the moment will replace all the blank space with underscores.
        /// <include file='doc\datacache.uex' path='docs/doc[@for="TypedDataSetGenerator.GenerateIdName"]/*' />
        public static string GenerateIdName(string name, ICodeGenerator codeGen) {
            if (codeGen.IsValidIdentifier(name)) {
                return name;
            }

            string ret = name.Replace(' ', '_');
            if (! codeGen.IsValidIdentifier(ret)) {
                ret = "_" + ret;
                UnicodeCategory unc;
                for (int i = 1; i < ret.Length; i++) {
                    unc = Char.GetUnicodeCategory(ret[i]);
                    if (
                        UnicodeCategory.UppercaseLetter      != unc &&  
                        UnicodeCategory.LowercaseLetter      != unc &&  
                        UnicodeCategory.TitlecaseLetter      != unc &&
                        UnicodeCategory.ModifierLetter       != unc &&
                        UnicodeCategory.OtherLetter          != unc &&
                        UnicodeCategory.LetterNumber         != unc &&
                        UnicodeCategory.NonSpacingMark       != unc &&
                        UnicodeCategory.SpacingCombiningMark != unc &&
                        UnicodeCategory.DecimalDigitNumber   != unc &&
                        UnicodeCategory.ConnectorPunctuation != unc 
                    ) {
                        ret = ret.Replace(ret[i], '_');
                    } // if
                } // for
            }

            return ret;
        }

        // -------------------- Implementation --------------------------

        private void GenerateCode(DataSet dataSet, CodeNamespace codeNamespace, ICodeGenerator codeGen) {
            this.useExtendedNaming = false;
            this.errorList         = new ArrayList();
            this.codeGen           = codeGen;

            codeNamespace.Imports.Add(new CodeNamespaceImport("System"     ));
            codeNamespace.Imports.Add(new CodeNamespaceImport("System.Data"));
            codeNamespace.Imports.Add(new CodeNamespaceImport("System.Xml"));
            codeNamespace.Imports.Add(new CodeNamespaceImport("System.Runtime.Serialization"));

            CodeTypeDeclaration dataSetClass = CreateTypedDataSet(dataSet); {
                foreach(DataTable table in dataSet.Tables) {
                    dataSetClass.Members.Add(CreateTypedRowEventHandler(table));
                }
                foreach(DataTable table in dataSet.Tables) {
                    dataSetClass.Members.Add(CreateTypedTable(   table));
                    dataSetClass.Members.Add(CreateTypedRow(     table));
                    dataSetClass.Members.Add(CreateTypedRowEvent(table));
                }            
            
                if (errorList.Count > 0) {
                    throw new TypedDataSetGeneratorException(errorList);
                }
            }
            codeNamespace.Types.Add(dataSetClass);
        }

        private void InitLookupIdentifiers() {
            lookupIdentifiers = new Hashtable();

            PropertyInfo[] props = typeof(DataRow).GetProperties();
            foreach(PropertyInfo p in props) {
                lookupIdentifiers[p.Name] = '_' + p.Name;
            }
        }

        private string FixIdName(string inVarName) {
            if (lookupIdentifiers == null) {
                InitLookupIdentifiers();
            }
            string newName = (string)lookupIdentifiers[inVarName];
            if (newName == null) {
                newName = GenerateIdName(inVarName, this.codeGen);
                while (lookupIdentifiers.ContainsValue(newName)) {
                    newName = '_' + newName;
                }
                lookupIdentifiers[inVarName] = newName;
                if (! this.codeGen.IsValidIdentifier(newName)){
                    errorList.Add(Res.GetString(Res.CodeGen_InvalidIdentifier, newName));
                }
            }
            return newName;
        }

        private static bool isEmpty(string s) {
            return s == null || s == string.Empty;
        }

        // Name of a class for typed row
        private string RowClassName(DataTable table) {
            string className = (string) table.ExtendedProperties["typedName"];
            if(isEmpty(className)) {
                className = FixIdName(table.TableName) + "Row";
            }
            return className;
        }

        // Name of a class for typed row inherit from
        private string RowBaseClassName(DataTable table) {
            if(useExtendedNaming) {
                string className = (string) table.ExtendedProperties["typedBaseClass"];
                if(isEmpty(className)) {
                    className = (string) table.DataSet.ExtendedProperties["typedBaseClass"];
                    if(isEmpty(className)) {
                        className = "DataRow";
                    }
                }
                return className;
            }else {
                return "DataRow";
            }
        }

        // Name of a class for typed row
        private string RowConcreteClassName(DataTable table) {
            if(useExtendedNaming) {
                string className = (string) table.ExtendedProperties["typedConcreteClass"];
                if(isEmpty(className)) {
                    className = RowClassName(table);
                }
                return className;
            }else {
                return RowClassName(table);
            }
        }

        // Name of a class for typed table
        private string TableClassName(DataTable table) {
            string className = (string)table.ExtendedProperties["typedPlural"];
            if(isEmpty(className)) {
                className = (string)table.ExtendedProperties["typedName"];
                if(isEmpty(className)) {
                    className = FixIdName(table.TableName);
                }
            }
            return className + "DataTable";
        }

        // Name of the property of typed dataset wich returns typed table:
        private string TablePropertyName(DataTable table) {
            string typedName = (string)table.ExtendedProperties["typedPlural"];
            if(isEmpty(typedName)) {
                typedName = (string)table.ExtendedProperties["typedName"];
                if(isEmpty(typedName)) {
                    typedName = FixIdName(table.TableName);
                }
                else
                    typedName = typedName + "Table";
            }
            return typedName;
        }

        // Name of the filed of typed dataset wich holds typed table
        private string TableFieldName(DataTable table) {
            return "table" + TablePropertyName(table);
        }

        private string RowColumnPropertyName(DataColumn column) {
                string typedName = (string) column.ExtendedProperties["typedName"];
                if(isEmpty(typedName)) {
                    typedName = FixIdName(column.ColumnName);
                }
                return typedName;
        }

        private string TableColumnFieldName(DataColumn column) {
            return "column" + RowColumnPropertyName(column);
        }

        private string TableColumnPropertyName(DataColumn column) {
            return RowColumnPropertyName(column) + "Column";
        }

        private static int TablesConnectedness(DataTable parentTable, DataTable childTable) {
            int connectedness = 0;
            DataRelationCollection relations = childTable.ParentRelations;
            for (int i = 0; i < relations.Count; i++) {
                if (relations[i].ParentTable == parentTable) {
                    connectedness ++;
                }
            }
            return connectedness;
        }

        private string ChildPropertyName(DataRelation relation) {
            string typedName = (string) relation.ExtendedProperties["typedChildren"];
            if(isEmpty(typedName)) {
                string arrayName = (string)relation.ChildTable.ExtendedProperties["typedPlural"];
                if(isEmpty(arrayName)) {
                    arrayName = (string)relation.ChildTable.ExtendedProperties["typedName"];
                    if(isEmpty(arrayName)) {
                        typedName = "Get" + relation.ChildTable.TableName + "Rows";
                        if(1 < TablesConnectedness(relation.ParentTable, relation.ChildTable)) {
                            typedName +="By" + relation.RelationName;
                        }
                        return FixIdName(typedName);
                    }
                    arrayName += "Rows";
                }
                typedName = "Get" + arrayName;
            }
            return typedName;
        }

        private string ParentPropertyName(DataRelation relation) {
            string typedName = null;
            typedName = (string) relation.ExtendedProperties["typedParent"];
            if(isEmpty(typedName)) {
                typedName = RowClassName(relation.ParentTable);
                if(                                                // Complex case: 
                    relation.ChildTable == relation.ParentTable || //   Self join
                    relation.ChildColumns.Length != 1              //   Multycolumn key
                ) {
                    typedName += "Parent";
                }
                if(1 < TablesConnectedness(relation.ParentTable, relation.ChildTable)) {
                    typedName +="By" + FixIdName(relation.RelationName);
                }
            }
            return typedName;
        }

        private string RelationFieldName(DataRelation relation) {
            return FixIdName("relation" + relation.RelationName);
        }
        
        private string GetTypeName(Type t) {
            return t.FullName;
        }

        private bool ChildRelationFollowable(DataRelation relation) {
            if (relation != null) {
                if (relation.ChildTable == relation.ParentTable) {
                    if (relation.ChildTable.Columns.Count == 1) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        private static CodeMemberMethod CreateOnRowEventMethod(string eventName, string rowClassName) {
            //\\ protected override void OnRow<eventName>(DataRowChangeEventArgs e) {
            //\\     base.OnRow<eventName>(e);
            //\\     if (((this.<RowClassName><eventName>) != (null))) {
            //\\         this.<RowClassName><eventName>(this, new <RowClassName><eventName>Event(((<eventName>)(e.Row)), e.Action));
            //\\     }
            //\\ }
            CodeMemberMethod onRowEvent = MethodDecl("System.Void", "OnRow" + eventName, MemberAttributes.Family | MemberAttributes.Override); {
                onRowEvent.Parameters.Add(ParameterDecl("DataRowChangeEventArgs", "e"));
                onRowEvent.Statements.Add(MethodCall(Base(), "OnRow" + eventName, Argument("e")));
                onRowEvent.Statements.Add(If(IdNotEQ(Event(rowClassName + eventName), Primitive(null)),
                    Stm(DelegateCall(Event(rowClassName + eventName), 
                        New(rowClassName + "ChangeEvent", new CodeExpression[] { Cast(rowClassName, Property(Argument("e"), "Row")), Property(Argument("e"), "Action")})
                    ))
                ));
            }
            return onRowEvent;
        }// CreateOnRowEventMethod

        private CodeTypeDeclaration CreateTypedTable(DataTable table) {
            string stRowClassName = RowClassName(table);
            string stTblClassName = TableClassName(table);
            string stRowConcreateClassName = RowConcreteClassName(table);

            CodeTypeDeclaration dataTableClass = new CodeTypeDeclaration(stTblClassName);
            dataTableClass.BaseTypes.Add("DataTable");
            dataTableClass.BaseTypes.Add("System.Collections.IEnumerable");
            //dataTableClass.Attributes |= TypeAttributes.NestedPrivate;

            dataTableClass.CustomAttributes.Add(AttributeDecl("System.Diagnostics.DebuggerStepThrough"));

            for (int i = 0; i < table.Columns.Count; i++) {
                //\\ DataColumn column<ColumnName>;
                dataTableClass.Members.Add(FieldDecl("DataColumn", TableColumnFieldName(table.Columns[i])));
            }              

            dataTableClass.Members.Add(EventDecl(stRowClassName + "ChangeEventHandler", stRowClassName + "Changed" ));
            dataTableClass.Members.Add(EventDecl(stRowClassName + "ChangeEventHandler", stRowClassName + "Changing"));
            dataTableClass.Members.Add(EventDecl(stRowClassName + "ChangeEventHandler", stRowClassName + "Deleted" ));
            dataTableClass.Members.Add(EventDecl(stRowClassName + "ChangeEventHandler", stRowClassName + "Deleting"));

            //\\ internal <TableName>DataTableClass() : base("<TableName>") {
            //\\     this.InitClass();
            //\\ }
            CodeConstructor constructor = new CodeConstructor(); {
                constructor.Attributes = MemberAttributes.Assembly | MemberAttributes.Final;
                constructor.BaseConstructorArgs.Add(Str(table.TableName));
                constructor.Statements.Add(MethodCall(This(), "InitClass"));
            }
            dataTableClass.Members.Add(constructor);

            //\\ internal <TableName>DataTableClass(DataTable table) : base(table.TableName) { // haroona : Assuming incoming table always associated with DataSet
            //\\ if (table.CaseSensitive != table.DataSet.CaseSensitive)
            //\\    this.CaseSensitive = table.CaseSensitive;
            //\\ if (table.Locale.ToString() != table.DataSet.Locale.ToString())
            //\\    this.Locale = table.Locale;
            //\\ if (table.Namespace != table.DataSet.Namespace)
            //\\    this.Namespace = table.Namespace;
            //\\ this.Prefix = table.Prefix;
            //\\ this.MinimumCapacity = table.MinimumCapacity;
            //\\ this.DisplayExpression = table.DisplayExpression;
            //\\ }
                            constructor = new CodeConstructor(); {
                constructor.Attributes = MemberAttributes.Assembly | MemberAttributes.Final;
                constructor.Parameters.Add(ParameterDecl("DataTable", "table"));
                constructor.BaseConstructorArgs.Add(Property(Argument("table"),"TableName"));
                constructor.Statements.Add(
                    If(IdNotEQ(Property(Argument("table"),"CaseSensitive"),Property(Property(Argument("table"),"DataSet"),"CaseSensitive")),
                        Assign(Property(This(),"CaseSensitive"),Property(Argument("table"),"CaseSensitive"))
                    )
                );
                constructor.Statements.Add(
                    If(IdNotEQ(MethodCall(Property(Argument("table"),"Locale"),"ToString"),MethodCall(Property(Property(Argument("table"),"DataSet"),"Locale"),"ToString")),
                        Assign(Property(This(),"Locale"),Property(Argument("table"),"Locale"))
                    )
                );
                constructor.Statements.Add(
                    If(IdNotEQ(Property(Argument("table"),"Namespace"),Property(Property(Argument("table"),"DataSet"),"Namespace")),
                        Assign(Property(This(),"Namespace"),Property(Argument("table"),"Namespace"))
                    )
                );
                constructor.Statements.Add(Assign(Property(This(), "Prefix"), Property(Argument("table"),"Prefix")));
                constructor.Statements.Add(Assign(Property(This(), "MinimumCapacity"), Property(Argument("table"),"MinimumCapacity")));
                constructor.Statements.Add(Assign(Property(This(), "DisplayExpression"), Property(Argument("table"),"DisplayExpression")));
            }
            dataTableClass.Members.Add(constructor);

            //\\ public int Count {
            //\\     get { return this.Rows.Count; }
            //\\ }
            CodeMemberProperty countProp = PropertyDecl("System.Int32", "Count", MemberAttributes.Public | MemberAttributes.Final); {
                countProp.CustomAttributes.Add(AttributeDecl("System.ComponentModel.Browsable", Primitive(false)));
                countProp.GetStatements.Add(Return(Property(Property(This(), "Rows"), "Count")));
            }
            dataTableClass.Members.Add(countProp);

            for (int i = 0; i < table.Columns.Count; i++) {
                //\\ internal DataColumn NAMEColumn {
                //\\     get { return this.columnNAME; }
                //\\ }
                DataColumn column = table.Columns[i];
                CodeMemberProperty colProp = PropertyDecl("DataColumn", TableColumnPropertyName(column), MemberAttributes.Assembly | MemberAttributes.Final); {
                    colProp.GetStatements.Add(Return(Field(This(), TableColumnFieldName(column))));
                }
                dataTableClass.Members.Add(colProp);
            }

            //\\ public <RowClassName> this[int index] {
            //\\     return (<RowClassName>) this.Rows[index];
            //\\ }
            CodeMemberProperty thisIndex = PropertyDecl(stRowConcreateClassName, "Item", MemberAttributes.Public | MemberAttributes.Final); {
                thisIndex.Parameters.Add(ParameterDecl("System.Int32", "index"));
                thisIndex.GetStatements.Add(Return(Cast(stRowConcreateClassName, Indexer(Property(This(), "Rows"), Argument("index")))));
            }
            dataTableClass.Members.Add(thisIndex);

            //\\ public void Add<RowClassName>(<RowClassName>  row) {
            //\\     this.Rows.Add(row);
            //\\ }
            CodeMemberMethod addMethod = MethodDecl("System.Void", "Add" + stRowClassName, MemberAttributes.Public | MemberAttributes.Final); {
                addMethod.Parameters.Add(ParameterDecl(stRowConcreateClassName, "row"));
                addMethod.Statements.Add(MethodCall(Property(This(), "Rows"), "Add", Argument("row")));
            }
            dataTableClass.Members.Add(addMethod);

            //\\ public <RowClassName> Add<RowClassName>(<ColType> <ColName>[, <ColType> <ColName> ...]) {
            //\\     <RowClassName> row;
            //\\     row = ((COMPUTERRow)(this.NewRow()));
            //\\     row.ItemArray = new Object[] {NAME, VERSION, null};
            //\\     this.Rows.Add(row);
            //\\     return row;
            //\\ }
            ArrayList parameterColumnList = new ArrayList();
            for (int i = 0; i < table.Columns.Count; i++) {
                if (!table.Columns[i].AutoIncrement) {
                    parameterColumnList.Add(table.Columns[i]);
                }
            }

            CodeMemberMethod addByColName = MethodDecl(stRowConcreateClassName, "Add" + stRowClassName, MemberAttributes.Public | MemberAttributes.Final); {
                DataColumn[] index = new DataColumn[parameterColumnList.Count];
                parameterColumnList.CopyTo(index, 0);
                for (int i = 0; i < index.Length; i++) {
                    Type DataType = index[i].DataType;
                    DataRelation relation = index[i].FindParentRelation();
                    if (ChildRelationFollowable(relation)) {
                        string ParentTypedRowName = RowClassName(relation.ParentTable);
                        string argumentName = FixIdName("parent" + ParentTypedRowName + "By" + relation.RelationName);
                        addByColName.Parameters.Add(ParameterDecl(ParentTypedRowName, argumentName));
                    }
                    else {
                        addByColName.Parameters.Add(ParameterDecl(GetTypeName(DataType), RowColumnPropertyName(index[i])));
                    }
                }
                addByColName.Statements.Add(VariableDecl(stRowConcreateClassName, "row" + stRowClassName, Cast(stRowConcreateClassName, MethodCall(This(), "NewRow"))));
                CodeExpression varRow = Variable("row" + stRowClassName);

                CodeAssignStatement assignStmt = new CodeAssignStatement(); {
                    assignStmt.Left = Property(varRow, "ItemArray");
                    CodeArrayCreateExpression newArray = new CodeArrayCreateExpression();
                    newArray.CreateType = Type(typeof(object));
                    
                    index = new DataColumn[table.Columns.Count];
                    table.Columns.CopyTo(index, 0);
                    
                    for (int i = 0; i < index.Length; i++) {
                        if (index[i].AutoIncrement) {
                            newArray.Initializers.Add(Primitive(null));
                        }else {
                            DataRelation relation = index[i].FindParentRelation();
                            if (ChildRelationFollowable(relation)) {
                                string ParentTypedRowName = RowClassName(relation.ParentTable);
                                string argumentName = FixIdName("parent" + ParentTypedRowName + "By" + relation.RelationName);
                                newArray.Initializers.Add(Indexer(Argument(argumentName), Primitive(relation.ParentColumns[0].Ordinal)));
                            }
                            else {
                                newArray.Initializers.Add(Argument(RowColumnPropertyName(index[i])));
                            }
                        }
                    }

                    assignStmt.Right = newArray;
                }
                addByColName.Statements.Add(assignStmt);

                addByColName.Statements.Add(MethodCall(Property(This(), "Rows"), "Add", varRow));
                addByColName.Statements.Add(Return(varRow));
            }
            dataTableClass.Members.Add(addByColName);

            for (int j = 0; j < table.Constraints.Count; j++) {
                if (!(table.Constraints[j] is UniqueConstraint)) {
                    continue;
                }

                if (!(((UniqueConstraint)(table.Constraints[j])).IsPrimaryKey)) {
                    continue;
                }

                DataColumn[] index = ((UniqueConstraint)table.Constraints[j]).Columns;
                string FindByName = "FindBy";
                bool AllHidden = true;
                for (int i = 0; i < index.Length; i++) {                    
                    FindByName += RowColumnPropertyName(index[i]);
                    if(index[i].ColumnMapping != MappingType.Hidden) {
                        AllHidden = false;
                    }
                }

                if(AllHidden) {
                    continue; // We are not generating FindBy* methods for hidden columns
                }

                //\\ public <RowClassName> FindBy<ColName>[...](<ColType> <ColName>[, ...]) {
                //\\    return (<RowClassName>)(this.Rows.Find(new Object[] {<ColName>[, ...]}));
                //\\ }
                CodeMemberMethod findBy = MethodDecl(stRowClassName, FixIdName(FindByName), MemberAttributes.Public | MemberAttributes.Final); {
                    for (int i = 0; i < index.Length; i++) {
                        findBy.Parameters.Add(ParameterDecl(GetTypeName(index[i].DataType), RowColumnPropertyName(index[i])));
                    }

                    CodeArrayCreateExpression arrayCreate = new CodeArrayCreateExpression(typeof(object), index.Length);
                    for (int i = 0; i < index.Length; i++) {
                        arrayCreate.Initializers.Add(Argument(RowColumnPropertyName(index[i])));
                    }
                    findBy.Statements.Add(Return(Cast(stRowClassName, MethodCall(Property(This(), "Rows"), "Find", arrayCreate))));
                }
                dataTableClass.Members.Add(findBy);
            }

            //\\ public System.Collections.IEnumerator GetEnumerator() {
            //\\     return this.GetEnumerator();
            //\\ }
            CodeMemberMethod getEnumerator = MethodDecl("System.Collections.IEnumerator", "GetEnumerator", MemberAttributes.Public | MemberAttributes.Final); {
                getEnumerator.ImplementationTypes.Add(Type("System.Collections.IEnumerable"));
                getEnumerator.Statements.Add(Return(MethodCall(Property(This(), "Rows"), "GetEnumerator")));
            }
            dataTableClass.Members.Add(getEnumerator);

            //\\ public override DataTable Clone() {
            //\\     <TableClassName> cln = (<TableClassName)base.Clone();
            //\\     cln.InitVars();
            //\\     return cln;
            //\\ }
            CodeMemberMethod clone = MethodDecl("DataTable", "Clone", MemberAttributes.Public | MemberAttributes.Override); {
                clone.Statements.Add(VariableDecl(stTblClassName, "cln", Cast(stTblClassName, MethodCall(Base(), "Clone", new CodeExpression[] {}))));
                clone.Statements.Add(MethodCall(Variable("cln"), "InitVars", new CodeExpression [] {}));
                clone.Statements.Add(Return(Variable("cln")));
            }
            dataTableClass.Members.Add(clone);

            //\\ protected override DataTable CreateInstance() {
            //\\     return new <TableClassName>()
            //\\ }
            CodeMemberMethod createInstance = MethodDecl("DataTable", "CreateInstance", MemberAttributes.Family | MemberAttributes.Override); {
	         createInstance.Statements.Add(Return(New(stTblClassName, new CodeExpression[] {}))); 
	     }
            dataTableClass.Members.Add(createInstance);

            //\\ private void InitClass() ...
            CodeMemberMethod tableInitClass = MethodDecl("System.Void", "InitClass", MemberAttributes.Private); {

            //\\ public void InitVars() ...
            CodeMemberMethod tableInitVars = MethodDecl("System.Void", "InitVars", MemberAttributes.Assembly | MemberAttributes.Final); {

                for (int i = 0; i < table.Columns.Count; i++) {
                    DataColumn column = table.Columns[i];
                    string ColumnName = TableColumnFieldName(column);
                    //\\ this.column<ColumnName>
                    CodeExpression codeField = Field(This(), ColumnName);

                    //\\ this.column<ColumnName> = new DataColumn("<ColumnName>", typeof(<ColumnType>), "", MappingType.Hidden);
                    tableInitClass.Statements.Add(Assign(codeField, 
                        New("DataColumn", 
                            new CodeExpression[] {
                                Str(column.ColumnName),
                                TypeOf(GetTypeName(column.DataType)),
                                Primitive(null),
                                Field(TypeExpr(typeof(MappingType)), 
                                    (column.ColumnMapping == MappingType.SimpleContent) ? "SimpleContent"      :
                                    (column.ColumnMapping == MappingType.Attribute    ) ? "Attribute" :
                                    (column.ColumnMapping == MappingType.Hidden       ) ? "Hidden"    :
                                    /*defult*/                                            "Element" 
                                )
                            }
                        )
                    ));
                    //\\ this.Columns.Add(this.column<ColumnName>);
                    tableInitClass.Statements.Add(MethodCall(Property(This(), "Columns"), "Add", Field(This(), ColumnName)));
                }

                for (int i = 0; i < table.Constraints.Count; i++) {
                    if (!(table.Constraints[i] is UniqueConstraint)) {
                        continue;
                    }
                    //\\ this.Constraints.Add = new UniqueConstraint(<constraintName>, new DataColumn[] {this.column<ColumnName> [, ...]});
                    UniqueConstraint uc = (UniqueConstraint)(table.Constraints[i]);
                    DataColumn[] columns = uc.Columns;
                    CodeExpression[] createArgs = new CodeExpression[columns.Length]; {
                        for (int j = 0; j < columns.Length; j++) {
                            createArgs[j] = Field(This(), TableColumnFieldName(columns[j]));
                        }
                    }
                    tableInitClass.Statements.Add(MethodCall(Property(This(), "Constraints"), "Add",
                        New("UniqueConstraint", 
                        new CodeExpression[] {
                                                Str(uc.ConstraintName),
                                                new CodeArrayCreateExpression("DataColumn", createArgs),
                                                Primitive(uc.IsPrimaryKey)
                                             }
                        )
                    ));
                }

                for (int i = 0; i < table.Columns.Count; i++) {
                    DataColumn column = table.Columns[i];
                    string ColumnName = TableColumnFieldName(column);
                    //\\ this.column<ColumnName>
                    CodeExpression codeField = Field(This(), ColumnName);

                    //\\ this.column<ColumnName> = this.Columns["<ColumnName>"];
                    tableInitVars.Statements.Add(Assign(codeField, Indexer(Property(This(),"Columns"),Str(column.ColumnName))));

                    if (column.AutoIncrement) {
                        //\\ this.column<ColumnName>.AutoIncrement = true;
                        tableInitClass.Statements.Add(Assign(Property(codeField, "AutoIncrement"), Primitive(true)));
                    }
                    if (column.AutoIncrementSeed != 0) {
                        //\\ this.column<ColumnName>.AutoIncrementSeed = <column.AutoIncrementSeed>;
                        tableInitClass.Statements.Add(Assign(Property(codeField, "AutoIncrementSeed"), Primitive(column.AutoIncrementSeed)));
                    }
                    if (column.AutoIncrementStep != 1) {
                        //\\ this.column<ColumnName>.AutoIncrementStep = <column.AutoIncrementStep>;
                        tableInitClass.Statements.Add(Assign(Property(codeField, "AutoIncrementStep"), Primitive(column.AutoIncrementStep)));
                    }
                    if (!column.AllowDBNull) {
                        //\\ this.column<ColumnName>.AllowDBNull = false;
                        tableInitClass.Statements.Add(Assign(Property(codeField, "AllowDBNull"), Primitive(false)));
                    }
                    if (column.ReadOnly) {
                        //\\ this.column<ColumnName>.ReadOnly = true;
                        tableInitClass.Statements.Add(Assign(Property(codeField, "ReadOnly"), Primitive(true)));
                    }
                    if (column.Unique) {
                        //\\ this.column<ColumnName>.Unique = true;
                        tableInitClass.Statements.Add(Assign(Property(codeField, "Unique"), Primitive(true)));
                    }
                    if (column.Prefix != "") {
                        //\\ this.column<ColumnName>.Prefix = "<column.Prefix>";
                        tableInitClass.Statements.Add(Assign(Property(codeField, "Prefix"), Str(column.Prefix)));
                    }
                    if (column._columnUri != null) {
                        //\\ this.column<ColumnName>.Namespace = "<column.Namespace>";
                        tableInitClass.Statements.Add(Assign(Property(codeField, "Namespace"), Str(column.Namespace)));
                    }
                    if (column.Caption != column.ColumnName) {
                        //\\ this.column<ColumnName>.Caption = "<column.Caption>";
                        tableInitClass.Statements.Add(Assign(Property(codeField, "Caption"), Str(column.Caption)));
                    }
                    if (column.DefaultValue != DBNull.Value) {
                        //\\ this.column<ColumnName>.DefaultValue = "<column.DefaultValue>";
                        tableInitClass.Statements.Add(Assign(Property(codeField, "DefaultValue"), Primitive(column.DefaultValue)));
                    }
                    if (column.MaxLength != -1) {
                        //\\ this.column<ColumnName>.MaxLength = "<column.MaxLength>";
                        tableInitClass.Statements.Add(Assign(Property(codeField, "MaxLength"), Primitive(column.MaxLength)));
                    }
                }

                if (!table.caseSensitiveAmbient) {
                    //\\ this.CaseSensitive = <CaseSensitive>;
                    tableInitClass.Statements.Add(Assign(Property(This(), "CaseSensitive"), Primitive(table.CaseSensitive)));
                }
                if (table.culture != null) {
                    //\\ this.Locale = new System.Globalization.CultureInfo("<Locale>");
                    tableInitClass.Statements.Add(Assign(Property(This(), "Locale"), New("System.Globalization.CultureInfo",new CodeExpression[] {Str(table.Locale.ToString())})));
                }
                if (table.Prefix != "") {
                    //\\ this.Prefix = "<Prefix>";
                    tableInitClass.Statements.Add(Assign(Property(This(), "Prefix"), Str(table.Prefix)));
                }
                if (table.tableNamespace != null) {
                    //\\ this.Namespace = <Namespace>;
                    tableInitClass.Statements.Add(Assign(Property(This(), "Namespace"), Str(table.Namespace)));
                }

                if (table.MinimumCapacity != 50) {
                    //\\ this.MinimumCapacity = <MinimumCapacity>;
                    tableInitClass.Statements.Add(Assign(Property(This(), "MinimumCapacity"), Primitive(table.MinimumCapacity)));
                }
                if (table.displayExpression != null) {
                    //\\ this.DisplayExpression = "<DisplayExpression>";
                    tableInitClass.Statements.Add(Assign(Property(This(), "DisplayExpression"), Str(table.DisplayExpression)));
                }
            }
            dataTableClass.Members.Add(tableInitVars);
            }
            dataTableClass.Members.Add(tableInitClass);

            //\\ public <RowClassName> New<RowClassName>() {
            //\\     return (<RowClassName>) NewRow();
            //\\ }
            CodeMemberMethod newTableRow = MethodDecl(stRowConcreateClassName, "New" + stRowClassName, MemberAttributes.Public | MemberAttributes.Final); {
                newTableRow.Statements.Add(Return(Cast(stRowConcreateClassName, MethodCall(This(), "NewRow"))));
            }
            dataTableClass.Members.Add(newTableRow);

            //\\ protected override DataRow NewRowFromBuilder(DataRowBuilder builder) {
            //\\     return new<RowClassName>(builder);
            //\\ }
            CodeMemberMethod newRowFromBuilder = MethodDecl("DataRow", "NewRowFromBuilder", MemberAttributes.Family | MemberAttributes.Override); {
                newRowFromBuilder.Parameters.Add(ParameterDecl("DataRowBuilder", "builder"));
                newRowFromBuilder.Statements.Add(Return(New(stRowConcreateClassName, new CodeExpression[] {Argument("builder")})));
            }
            dataTableClass.Members.Add(newRowFromBuilder);

            //\\ protected override System.Type GetRowType() {
            //\\     return typeof(<RowConcreateClassName>);
            //\\ }        
            CodeMemberMethod getRowType = MethodDecl("System.Type", "GetRowType", MemberAttributes.Family | MemberAttributes.Override); {
                getRowType.Statements.Add(Return(TypeOf(stRowConcreateClassName)));
            }
            dataTableClass.Members.Add(getRowType);

            dataTableClass.Members.Add(CreateOnRowEventMethod("Changed" , stRowClassName));
            dataTableClass.Members.Add(CreateOnRowEventMethod("Changing", stRowClassName));
            dataTableClass.Members.Add(CreateOnRowEventMethod("Deleted" , stRowClassName));
            dataTableClass.Members.Add(CreateOnRowEventMethod("Deleting", stRowClassName));

            //\\ public void Remove<RowClassName>(<RowClassName> row) {
            //\\     this.Rows.Remove(row);
            //\\ }
            CodeMemberMethod removeMethod = MethodDecl("System.Void", "Remove" + stRowClassName, MemberAttributes.Public | MemberAttributes.Final); {
                removeMethod.Parameters.Add(ParameterDecl(stRowConcreateClassName, "row"));
                removeMethod.Statements.Add(MethodCall(Property(This(), "Rows"), "Remove", Argument("row")));
            }
            dataTableClass.Members.Add(removeMethod);

            return dataTableClass;
        }// CreateTypedTable

        private CodeTypeDeclaration CreateTypedRow(DataTable table) {
            string stRowClassName = RowClassName(  table);
            string stTblClassName = TableClassName(table);
            string stTblFieldName = TableFieldName(table);
            bool   storageInitialized = false;

            CodeTypeDeclaration rowClass = new CodeTypeDeclaration();
            rowClass.Name = stRowClassName;
            rowClass.BaseTypes.Add(RowBaseClassName(table));

            rowClass.CustomAttributes.Add(AttributeDecl("System.Diagnostics.DebuggerStepThrough"));

            //\\ <TableClassName> table<TableFieldName>;
            rowClass.Members.Add(FieldDecl(stTblClassName, stTblFieldName));

            CodeConstructor constructor = new CodeConstructor(); {
                constructor.Attributes = MemberAttributes.Assembly | MemberAttributes.Final;
                constructor.Parameters.Add(ParameterDecl("DataRowBuilder", "rb"));
                constructor.BaseConstructorArgs.Add(Argument("rb"));
                constructor.Statements.Add(Assign(Field(This(), stTblFieldName), Cast(stTblClassName, Property(This(),"Table"))));
            }
            rowClass.Members.Add(constructor);

            foreach(DataColumn col in table.Columns) {
                if(col.ColumnMapping != MappingType.Hidden) {
                    Type DataType = col.DataType;
                    string rowColumnName   = RowColumnPropertyName(  col);
                    string tableColumnName = TableColumnPropertyName(col);
                    //\\ public <ColumnType> <ColumnName> {
                    //\\     get {
                    //\\         try{
                    //\\             return ((<ColumnType>)(this[this.table<TableName>.<ColumnName>Column]));
                    //\\         }catch(InvalidCastException e) {
                    //\\             throw new StrongTypingException("StrongTyping_CananotAccessDBNull", e);
                    //\\         }
                    //\\     }
                    //\\or 
                    //\\     get {
                    //\\         if(Is<ColumnName>Null()){
                    //\\             return (<nullValue>);
                    //\\         }else {
                    //\\             return ((<ColumnType>)(this[this.table<TableName>.<ColumnName>Column]));
                    //\\         }
                    //\\     }
                    //\\or 
                    //\\     get {
                    //\\         if(Is<ColumnName>Null()){
                    //\\             return <ColumnName>_nullValue;
                    //\\         }else {
                    //\\             return ((<ColumnType>)(this[this.table<TableName>.<ColumnName>Column]));
                    //\\         }
                    //\\     }
                    //\\
                    //\\     set {this[this.table<TableName>.<ColumnName>Column] = value;}
                    //\\ }
                    //\\
                    //\\if required: 
                    //\\ private static <ColumnType> <ColumnName>_nullValue = ...;
		            CodeMemberProperty rowProp = PropertyDecl(GetTypeName(DataType), rowColumnName, MemberAttributes.Public | MemberAttributes.Final); {
                        CodeStatement getStmnt = Return(Cast(GetTypeName(DataType), Indexer(This(), Property(Field(This(), stTblFieldName), tableColumnName))));
                        if(col.AllowDBNull) {
                            string nullValue = (string) col.ExtendedProperties["nullValue"];
                            if(nullValue == null || nullValue == "_throw") {
                                getStmnt = Try(getStmnt, 
                                    Catch("InvalidCastException", "e", Throw("StrongTypingException", "StrongTyping_CananotAccessDBNull", "e"))
                                );
                            }else {
                                CodeExpression nullValueFieldInit = null; // in some cases we generate it
                                CodeExpression nullValueExpr;
                                if(nullValue == "_null") {
                                    if(col.DataType.IsSubclassOf(typeof(System.ValueType))) {
                                        errorList.Add(Res.GetString(Res.CodeGen_TypeCantBeNull, col.ColumnName, col.DataType.Name));
                                        continue; // with next column.
                                    }
                                    nullValueExpr = Primitive(null);
                                }else if(nullValue == "_empty") {
                                    if(col.DataType == typeof(string)) {
                                        nullValueExpr = Property(TypeExpr(col.DataType), "Empty");
                                    }else {
                                        nullValueExpr = Field(TypeExpr(stRowClassName), rowColumnName + "_nullValue");
                                        //\\ private static <ColumnType> <ColumnName>_nullValue = new <ColumnType>();
                                        /* check that object can be constructed with parameterless constructor */ {
                                            ConstructorInfo ctor = col.DataType.GetConstructor(new Type[] {typeof(string)});
                                            if(ctor == null) {
                                                errorList.Add(Res.GetString(Res.CodeGen_NoCtor0, col.ColumnName, col.DataType.Name));
                                                continue; // with next column.
                                            }
                                            ctor.Invoke(new Object[] {}); // can throw here.
                                        }
                                        nullValueFieldInit = New(col.DataType.FullName, new CodeExpression[] {});
                                    }
                                }else {
                                    if(! storageInitialized) {                                    
                                        table.NewRow(); // by this we force DataTable create DataStorage for each column in a table.
                                        storageInitialized = true;
                                    }
                                    object nullValueObj = col.ConvertXmlToObject(nullValue); // the exception will be throw if nullValue can't be conwerted to col.DataType
                                    if(
                                        col.DataType == typeof(char)   || col.DataType == typeof(string) ||
                                        col.DataType == typeof(decimal)|| col.DataType == typeof(bool)   ||
                                        col.DataType == typeof(Single) || col.DataType == typeof(double) ||
                                        col.DataType == typeof(SByte)  || col.DataType == typeof(Byte)   || 
                                        col.DataType == typeof(Int16)  || col.DataType == typeof(UInt16) || 
                                        col.DataType == typeof(Int32)  || col.DataType == typeof(UInt32) || 
                                        col.DataType == typeof(Int64)  || col.DataType == typeof(UInt64)    
                                    ) { // types can be presented by literal. Realy this is language dependent :-(                                        
                                        nullValueExpr = Primitive(nullValueObj);
                                    }else {
                                        nullValueExpr = Field(TypeExpr(stRowClassName), rowColumnName + "_nullValue");
                                        //\\ private static <ColumnType> <ColumnName>_nullValue = new <ColumnType>("<nullValue>");
                                        if(col.DataType == typeof(Byte[])) {
                                            nullValueFieldInit = MethodCall(TypeExpr(typeof(System.Convert)), "FromBase64String", Primitive(nullValue));
                                        }else if(col.DataType == typeof(DateTime) || col.DataType == typeof(TimeSpan)) {
                                            nullValueFieldInit = MethodCall(TypeExpr(col.DataType), "Parse", Primitive(nullValueObj.ToString()));
                                        }else /*object*/ {
                                            /* check that type can be constructed from this string */ {
                                                ConstructorInfo ctor = col.DataType.GetConstructor(new Type[] {typeof(string)});
                                                if(ctor == null) {
                                                    errorList.Add(Res.GetString(Res.CodeGen_NoCtor1, col.ColumnName, col.DataType.Name));
                                                    continue; // with next column.
                                                }
                                                ctor.Invoke(new Object[] {nullValue}); // can throw here.
                                            }
                                            nullValueFieldInit = New(col.DataType.FullName, new CodeExpression[] {Primitive(nullValue)});
                                        }
                                    }
                                }
                                getStmnt = If(MethodCall(This(), "Is" + rowColumnName + "Null"), 
                                    new CodeStatement[] {Return(nullValueExpr)},
                                    new CodeStatement[] {getStmnt}
                                );
                                if(nullValueFieldInit != null) {
                                    CodeMemberField nullValueField = FieldDecl(col.DataType.FullName, rowColumnName + "_nullValue"); {
                                        nullValueField.Attributes     = MemberAttributes.Static | MemberAttributes.Private;
                                        nullValueField.InitExpression = nullValueFieldInit;
                                    }
                                    rowClass.Members.Add(nullValueField);
                                }
                            }
                        }
                        rowProp.GetStatements.Add(getStmnt);
                        rowProp.SetStatements.Add(Assign(Indexer(This(), Property(Field(This(), stTblFieldName), tableColumnName)), Value()));
                    }
                    rowClass.Members.Add(rowProp);

                    if (col.AllowDBNull) {
                        //\\ public bool Is<ColumnName>Null() {
                        //\\     return this.IsNull(this.table<TableName>.<ColumnName>Column);
                        //\\ }
                        CodeMemberMethod isNull = MethodDecl("System.Boolean", "Is" + rowColumnName + "Null", MemberAttributes.Public | MemberAttributes.Final); {
                            isNull.Statements.Add(Return(MethodCall(This(), "IsNull", Property(Field(This(), stTblFieldName), tableColumnName))));
                        }
                        rowClass.Members.Add(isNull);

                        //\\ public void Set<ColumnName>Null() {
                        //\\     this[this.table<TableName>.<ColumnName>Column] = DBNull.Value;
                        //\\ }
                        CodeMemberMethod setNull = MethodDecl("System.Void", "Set" + rowColumnName + "Null", MemberAttributes.Public | MemberAttributes.Final); {
                            setNull.Statements.Add(Assign(Indexer(This(), Property(Field(This(), stTblFieldName), tableColumnName)), Field(TypeExpr(typeof(Convert)), "DBNull")));
                        }
                        rowClass.Members.Add(setNull);
                    }
                }
            }

            DataRelationCollection ChildRelations = table.ChildRelations;
            for (int i = 0; i < ChildRelations.Count; i++) {
                //\\ public <rowConcreateClassName>[] Get<ChildTableName>Rows() {
                //\\     return (<rowConcreateClassName>[]) this.GetChildRows(this.Table.ChildRelations["<RelationName>"]); 
                //\\  }
                DataRelation relation = ChildRelations[i];
                string rowConcreateClassName = RowConcreteClassName(relation.ChildTable);

                CodeMemberMethod childArray = Method(Type(rowConcreateClassName, 1), ChildPropertyName(relation), MemberAttributes.Public | MemberAttributes.Final); {
                    childArray.Statements.Add(Return(Cast(Type(rowConcreateClassName, 1), MethodCall(This(), "GetChildRows", Indexer(Property(Property(This(), "Table"), "ChildRelations"), Str(relation.RelationName))))));
                }
                rowClass.Members.Add(childArray);
            }

            DataRelationCollection ParentRelations = table.ParentRelations;
            for (int i = 0; i < ParentRelations.Count; i++) {
                //\\ public <ParentRowClassName> <ParentRowClassName>Parent {
                //\\     get {
                //\\         return ((<ParentRowClassName>)(this.GetParentRow(this.Table.ParentRelations["<RelationName>"])));
                //\\     }
                //\\     set {
                //\\         this.SetParentRow(value, this.Table.ParentRelations["<RelationName>"]);
                //\\     }
                //\\ }
                DataRelation relation = ParentRelations[i];
                string ParentTypedRowName = RowClassName(relation.ParentTable);

                CodeMemberProperty anotherProp = PropertyDecl(ParentTypedRowName, ParentPropertyName(relation), MemberAttributes.Public | MemberAttributes.Final); {
                    anotherProp.GetStatements.Add(Return(Cast(ParentTypedRowName, MethodCall(This(), "GetParentRow", Indexer(Property(Property(This(), "Table"), "ParentRelations"), Str(relation.RelationName))))));
                    anotherProp.SetStatements.Add(MethodCall(This(), "SetParentRow", new CodeExpression[] {Value(), Indexer(Property(Property(This(), "Table"), "ParentRelations"), Str(relation.RelationName))}));
                }
                rowClass.Members.Add(anotherProp);
            }
            return rowClass;
        }// CreateTypedRow

        private CodeTypeDeclaration CreateTypedRowEvent(DataTable table) {
            string stRowClassName = RowClassName(  table);
            string stTblClassName = TableClassName(table);
            string stRowConcreateClassName = RowConcreteClassName(table);

            CodeTypeDeclaration rowClass = new CodeTypeDeclaration();
            rowClass.Name = stRowClassName + "ChangeEvent";
            rowClass.BaseTypes.Add("EventArgs");

            rowClass.CustomAttributes.Add(AttributeDecl("System.Diagnostics.DebuggerStepThrough"));

            //\\ private <RowConcreteClassName> eventRow;
            rowClass.Members.Add(FieldDecl(stRowConcreateClassName, "eventRow"));
            //\\ private DataRowAction eventAction;
            rowClass.Members.Add(FieldDecl("DataRowAction", "eventAction"));

            //\\ public <RowClassName>ChangeEvent(RowClassName row, DataRowAction action) {
            //\\     this.eventRow    = row;
            //\\     this.eventAction = action;
            //\\ }
            CodeConstructor constructor = new CodeConstructor(); {
                constructor.Attributes = MemberAttributes.Public | MemberAttributes.Final;
                constructor.Parameters.Add(ParameterDecl(stRowConcreateClassName, "row"   ));
                constructor.Parameters.Add(ParameterDecl("DataRowAction"        , "action"));
                constructor.Statements.Add(Assign(Field(This(), "eventRow"   ), Argument("row"   )));
                constructor.Statements.Add(Assign(Field(This(), "eventAction"), Argument("action")));
            }
            rowClass.Members.Add(constructor);

            //\\ public <RowClassName> COMPUTERRow {
            //\\     get { return this.eventRow; }
            //\\ }
            CodeMemberProperty rowProp = PropertyDecl(stRowConcreateClassName, "Row", MemberAttributes.Public | MemberAttributes.Final); {
                rowProp.GetStatements.Add(Return(Field(This(), "eventRow")));
            }
            rowClass.Members.Add(rowProp);

            //\\ public DataRowAction Action {
            //\\     get { return this.eventAction; }
            //\\ }
            rowProp = PropertyDecl("DataRowAction", "Action", MemberAttributes.Public | MemberAttributes.Final); {
                rowProp.GetStatements.Add(Return(Field(This(), "eventAction")));
            }
            rowClass.Members.Add(rowProp);
            return rowClass;
        }// CreateTypedRowEvent

        private CodeTypeDelegate CreateTypedRowEventHandler(DataTable table) {
            string stRowClassName = RowClassName(table);
            //\\ public delegate void <RowClassName>ChangeEventHandler(object sender, <RowClassName>ChangeEvent e);
            CodeTypeDelegate delegateClass = new CodeTypeDelegate(stRowClassName + "ChangeEventHandler"); {
                delegateClass.TypeAttributes |= TypeAttributes.Public;
                delegateClass.Parameters.Add(ParameterDecl(typeof(object), "sender"));            
                delegateClass.Parameters.Add(ParameterDecl(stRowClassName + "ChangeEvent", "e"));
            }
            return delegateClass;
        }// CreateTypedRowEventHandler

        private CodeTypeDeclaration CreateTypedDataSet(DataSet dataSet) {
            string stDataSetClassName = FixIdName(dataSet.DataSetName);
            CodeTypeDeclaration dataSetClass = new CodeTypeDeclaration(stDataSetClassName);
            dataSetClass.BaseTypes.Add("DataSet");
            dataSetClass.CustomAttributes.Add(AttributeDecl("Serializable"));
            dataSetClass.CustomAttributes.Add(AttributeDecl("System.ComponentModel.DesignerCategoryAttribute", Str("code")));
            dataSetClass.CustomAttributes.Add(AttributeDecl("System.Diagnostics.DebuggerStepThrough"));
            dataSetClass.CustomAttributes.Add(AttributeDecl("System.ComponentModel.ToolboxItem", Primitive(true)));

            for (int i = 0; i < dataSet.Tables.Count; i++) {
                dataSetClass.Members.Add(FieldDecl(TableClassName(dataSet.Tables[i]), TableFieldName(dataSet.Tables[i])));
            }

            for (int i = 0; i < dataSet.Relations.Count; i++) {
                //\\ DataRelation relation<RelationName>;
                dataSetClass.Members.Add(FieldDecl("DataRelation", RelationFieldName(dataSet.Relations[i])));
            }

            CodeConstructor constructor = new CodeConstructor(); {
                constructor.Attributes = MemberAttributes.Public;
                constructor.Statements.Add(MethodCall(This(), "InitClass"));
                constructor.Statements.Add(VariableDecl(typeof(CollectionChangeEventHandler),"schemaChangedHandler",
                                           new CodeDelegateCreateExpression(Type(typeof(CollectionChangeEventHandler)),This(),"SchemaChanged")));
                constructor.Statements.Add(new System.CodeDom.CodeAttachEventStatement(new CodeEventReferenceExpression(Property(This(),"Tables"),"CollectionChanged"),Variable("schemaChangedHandler")));
                constructor.Statements.Add(new System.CodeDom.CodeAttachEventStatement(new CodeEventReferenceExpression(Property(This(),"Relations"),"CollectionChanged"),Variable("schemaChangedHandler")));
            }
            dataSetClass.Members.Add(constructor);

                            constructor = new CodeConstructor(); {
                constructor.Attributes = MemberAttributes.Family;
                constructor.Parameters.Add(ParameterDecl("SerializationInfo", "info"   ));
                constructor.Parameters.Add(ParameterDecl("StreamingContext" , "context"));
                constructor.Statements.Add(
                    VariableDecl("System.String", "strSchema",
                    Cast("System.String", MethodCall(Argument("info"), "GetValue", new CodeExpression[] {Str("XmlSchema"),TypeOf("System.String")})))
                );

                ArrayList schemaBody = new ArrayList();
                schemaBody.Add(VariableDecl("DataSet","ds",New("DataSet",new CodeExpression[] {})));
                schemaBody.Add(Stm(MethodCall(Variable("ds"),"ReadXmlSchema",new CodeExpression[] {New("XmlTextReader",new CodeExpression[] {New("System.IO.StringReader",new CodeExpression[] {Variable("strSchema")})})})));
                for (int i = 0; i < dataSet.Tables.Count; i++) {
                    //\\ this.Tables.Add(new <TableClassName>("<TableName>"));
                    schemaBody.Add(
                        If(IdNotEQ(Indexer(Property(Variable("ds"),"Tables"),Str(dataSet.Tables[i].TableName)),Primitive(null)),
                            Stm(MethodCall(Property(This(), "Tables"), "Add", New(TableClassName(dataSet.Tables[i]), new CodeExpression[] {Indexer(Property(Variable("ds"),"Tables"),Str(dataSet.Tables[i].TableName))})))
                        )
                    );
                }
                schemaBody.Add(Assign(Property(This(), "DataSetName"), Property(Variable("ds"),"DataSetName")));
                schemaBody.Add(Assign(Property(This(), "Prefix"), Property(Variable("ds"),"Prefix")));
                schemaBody.Add(Assign(Property(This(), "Namespace"), Property(Variable("ds"),"Namespace")));
                schemaBody.Add(Assign(Property(This(), "Locale"), Property(Variable("ds"),"Locale")));
                schemaBody.Add(Assign(Property(This(), "CaseSensitive"), Property(Variable("ds"),"CaseSensitive")));
                schemaBody.Add(Assign(Property(This(), "EnforceConstraints"), Property(Variable("ds"),"EnforceConstraints")));
                schemaBody.Add(Stm(MethodCall(This(),"Merge",new CodeExpression[] {Variable("ds"),Primitive(false),Field(TypeExpr(typeof(MissingSchemaAction)),"Add")})));
                schemaBody.Add(Stm(MethodCall(This(),"InitVars")));
                CodeStatement[] schemaBodyArray = new CodeStatement[schemaBody.Count];
                schemaBody.CopyTo(schemaBodyArray);
                constructor.Statements.Add(
                    If(IdNotEQ(Variable("strSchema"),Primitive(null)),
                        schemaBodyArray,
                        new CodeStatement[] {
                            Stm(MethodCall(This(), "InitClass"))
                        }
                    )
                );
                constructor.Statements.Add(MethodCall(This(), "GetSerializationData", new CodeExpression [] { Argument("info"), Argument("context") }));
                constructor.Statements.Add(VariableDecl(typeof(CollectionChangeEventHandler),"schemaChangedHandler",
                                           new CodeDelegateCreateExpression(Type(typeof(CollectionChangeEventHandler)),This(),"SchemaChanged")));
                constructor.Statements.Add(new System.CodeDom.CodeAttachEventStatement(new CodeEventReferenceExpression(Property(This(),"Tables"),"CollectionChanged"),Variable("schemaChangedHandler")));
                constructor.Statements.Add(new System.CodeDom.CodeAttachEventStatement(new CodeEventReferenceExpression(Property(This(),"Relations"),"CollectionChanged"),Variable("schemaChangedHandler")));            
            }
            dataSetClass.Members.Add(constructor);

            //\\ public override DataSet Clone() {
            //\\     <DataSetClassName> cln = (<DataSetClassName)base.Clone();
            //\\     cln.InitVars();
            //\\     return cln;
            //\\ }
            CodeMemberMethod clone = MethodDecl("DataSet", "Clone", MemberAttributes.Public | MemberAttributes.Override); {
                clone.Statements.Add(VariableDecl(stDataSetClassName, "cln", Cast(stDataSetClassName, MethodCall(Base(), "Clone", new CodeExpression[] {}))));
                clone.Statements.Add(MethodCall(Variable("cln"), "InitVars", new CodeExpression [] {}));
                clone.Statements.Add(Return(Variable("cln")));
            }
            dataSetClass.Members.Add(clone);

            //\\ private void InitClass() 
            CodeMemberMethod initClassMethod = MethodDecl("System.Void", "InitClass", MemberAttributes.Private); {

            //\\ public void InitVars() 
            CodeMemberMethod initVarsMethod = MethodDecl("System.Void", "InitVars", MemberAttributes.Assembly | MemberAttributes.Final); {

                //\\ this.DataSetName = "<dataSet.DataSetName>"
                initClassMethod.Statements.Add(Assign(Property(This(), "DataSetName"), Str(dataSet.DataSetName)));
                //\\ this.Prefix   = "<dataSet.Prefix>"
                initClassMethod.Statements.Add(Assign(Property(This(), "Prefix"), Str(dataSet.Prefix)));
                //\\ this.Namespace   = "<dataSet.Namespace>"
                initClassMethod.Statements.Add(Assign(Property(This(), "Namespace"), Str(dataSet.Namespace)));
                //\\ this.Locale = new System.Globalization.CultureInfo("dataSet.<Locale>");
                initClassMethod.Statements.Add(Assign(Property(This(), "Locale"), New("System.Globalization.CultureInfo",new CodeExpression[] {Str(dataSet.Locale.ToString())})));
                //\\ this.CaseSensitive = <dataSet.CaseSensitive>;
                initClassMethod.Statements.Add(Assign(Property(This(), "CaseSensitive"), Primitive(dataSet.CaseSensitive)));
                //\\ this.EnforceConstraints = <dataSet.EnforceConstraints>;
                initClassMethod.Statements.Add(Assign(Property(This(), "EnforceConstraints"), Primitive(dataSet.EnforceConstraints)));

                for (int i = 0; i < dataSet.Tables.Count; i++) {
                    CodeExpression fieldTable = Field(This(), TableFieldName(dataSet.Tables[i]));
                    //\\ table<TableFieldName> = new <TableClassName>("<TableName>");
                    initClassMethod.Statements.Add(Assign(fieldTable, New(TableClassName(dataSet.Tables[i]), new CodeExpression[] {})));
                    //\\ this.Tables.Add(this.table<TableFieldName>);
                    initClassMethod.Statements.Add(MethodCall(Property(This(), "Tables"), "Add", fieldTable));

                    //\\ this.table<TableFieldName> = (<TableClassName>)this.Tables["<TableName>"];
                    //\\ if (this.table<TableFieldName> != null)
                    //\\    this.table<TableFieldName>.InitVars();
                    initVarsMethod.Statements.Add(Assign(fieldTable, Cast(TableClassName(dataSet.Tables[i]), Indexer(Property(This(),"Tables"),Str(dataSet.Tables[i].TableName)))));
                    initVarsMethod.Statements.Add(
                        If(IdNotEQ(fieldTable,Primitive(null)),
                            Stm(MethodCall(fieldTable,"InitVars"))
                        )
                    );
                }


            //\\ protected override bool ShouldSerializeTables() {
            //\\     return false;
            //\\ }
            CodeMemberMethod shouldSerializeTables = MethodDecl("System.Boolean", "ShouldSerializeTables", MemberAttributes.Family | MemberAttributes.Override); {
                shouldSerializeTables.Statements.Add(Return(Primitive(false)));
            }
            dataSetClass.Members.Add(shouldSerializeTables);

            //\\ protected override bool ShouldSerializableRelations() {
            //\\     return false;
            //\\ }
            CodeMemberMethod shouldSerializeRelations = MethodDecl("System.Boolean", "ShouldSerializeRelations", MemberAttributes.Family | MemberAttributes.Override); {
                shouldSerializeRelations.Statements.Add(Return(Primitive(false)));
            }
            dataSetClass.Members.Add(shouldSerializeRelations);



            //\\ protected override void ReadXmlSerializable(XmlReader reader) {
            //\\     ReadXml(reader, XmlReadMode.IgnoreSchema);
            //\\ }
            CodeMemberMethod readXmlSerializable = MethodDecl("System.Void", "ReadXmlSerializable", MemberAttributes.Family | MemberAttributes.Override); {
                readXmlSerializable.Parameters.Add(ParameterDecl("XmlReader", "reader"));
                readXmlSerializable.Statements.Add(MethodCall(This(), "Reset", new CodeExpression [] {}));
                readXmlSerializable.Statements.Add(VariableDecl("DataSet","ds",New("DataSet",new CodeExpression[] {})));
                readXmlSerializable.Statements.Add(MethodCall(Variable("ds"), "ReadXml", new CodeExpression [] { Argument("reader") }));
//                readXmlSerializable.Statements.Add(MethodCall(Variable("ds"), "ReadXmlSchema", new CodeExpression [] { Argument("reader") }));
                for (int i = 0; i < dataSet.Tables.Count; i++) {
                    //\\ this.Tables.Add(new <TableClassName>("<TableName>"));
                    readXmlSerializable.Statements.Add(
                        If(IdNotEQ(Indexer(Property(Variable("ds"),"Tables"),Str(dataSet.Tables[i].TableName)),Primitive(null)),
                            Stm(MethodCall(Property(This(), "Tables"), "Add", New(TableClassName(dataSet.Tables[i]), new CodeExpression[] {Indexer(Property(Variable("ds"),"Tables"),Str(dataSet.Tables[i].TableName))})))
                        )
                    );
                }
                readXmlSerializable.Statements.Add(Assign(Property(This(), "DataSetName"), Property(Variable("ds"),"DataSetName")));
                readXmlSerializable.Statements.Add(Assign(Property(This(), "Prefix"), Property(Variable("ds"),"Prefix")));
                readXmlSerializable.Statements.Add(Assign(Property(This(), "Namespace"), Property(Variable("ds"),"Namespace")));
                readXmlSerializable.Statements.Add(Assign(Property(This(), "Locale"), Property(Variable("ds"),"Locale")));
                readXmlSerializable.Statements.Add(Assign(Property(This(), "CaseSensitive"), Property(Variable("ds"),"CaseSensitive")));
                readXmlSerializable.Statements.Add(Assign(Property(This(), "EnforceConstraints"), Property(Variable("ds"),"EnforceConstraints")));
                readXmlSerializable.Statements.Add(MethodCall(This(),"Merge",new CodeExpression[] {Variable("ds"),Primitive(false),Field(TypeExpr(typeof(MissingSchemaAction)),"Add")}));
                readXmlSerializable.Statements.Add(MethodCall(This(),"InitVars"));
//                readXmlSerializable.Statements.Add(MethodCall(This(), "ReadXml", new CodeExpression [] { Argument("reader"), Argument("XmlReadMode.IgnoreSchema") }));
            }
            dataSetClass.Members.Add(readXmlSerializable);

            //\\ protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
            //\\     System.IO.MemoryStream stream = new System.IO.MemoryStream();
            //\\     WriteXmlSchema(new XmlTextWriter(stream, null ));
            //\\     stream.Position = 0;
            //\\     return System.Xml.Schema.XmlSchema.Read(new XmlTextReader(stream));
            //\\ }
            CodeMemberMethod getSchemaSerializable = MethodDecl("System.Xml.Schema.XmlSchema", "GetSchemaSerializable", MemberAttributes.Family | MemberAttributes.Override); {
                getSchemaSerializable.Statements.Add(VariableDecl("System.IO.MemoryStream", "stream", New("System.IO.MemoryStream",new CodeExpression[] {})));
                getSchemaSerializable.Statements.Add(MethodCall(This(), "WriteXmlSchema", New("XmlTextWriter",new CodeExpression[] {Argument("stream"),Primitive(null)})));
                getSchemaSerializable.Statements.Add(Assign(Property(Argument("stream"),"Position"),Primitive(0)));
                getSchemaSerializable.Statements.Add(Return(MethodCall(TypeExpr("System.Xml.Schema.XmlSchema"),"Read",new CodeExpression[] {New("XmlTextReader",new CodeExpression[] {Argument("stream")}), Primitive(null)})));
            }
            dataSetClass.Members.Add(getSchemaSerializable);

                /*----------- Add Constraints to the Tables -------------------------*/
                CodeExpression varFkc = null;
                foreach(DataTable table in dataSet.Tables) {
                    foreach(Constraint constraint in table.Constraints) {
                        if (constraint is ForeignKeyConstraint) {
                            // We only initialize the foreign key constraints here.
                            //\\ ForeignKeyConstraint fkc;
                            //\\ fkc = new ForeignKeyConstraint("<ConstrainName>", 
                            //\\     new DataColumn[] {this.table<TableClassName>.<ColumnName>Column}, // parent columns
                            //\\     new DataColumn[] {this.table<TableClassName>.<ColumnName>Column}  // child columns
                            //\\ ));
                            //\\ this.table<TableClassName>.Constraints.Add(fkc);
                            //\\ fkc.AcceptRejectRule = constraint.AcceptRejectRule;
                            //\\ fkc.DeleteRule = constraint.DeleteRule;
                            //\\ fkc.UpdateRule = constraint.UpdateRule;

                            ForeignKeyConstraint fkc = (ForeignKeyConstraint) constraint;

                            CodeArrayCreateExpression childrenColumns = new CodeArrayCreateExpression("DataColumn", 0); {
                                foreach(DataColumn c in fkc.Columns) {
                                    childrenColumns.Initializers.Add(Property(Field(This(), TableFieldName(c.Table)), TableColumnPropertyName(c)));
                                }
                            }

                            CodeArrayCreateExpression parentColumns = new CodeArrayCreateExpression("DataColumn", 0); {
                                foreach(DataColumn c in fkc.RelatedColumns) {
                                    parentColumns.Initializers.Add(Property(Field(This(), TableFieldName(c.Table)), TableColumnPropertyName(c)));
                                }
                            }

                            if (varFkc == null) {
                                initClassMethod.Statements.Add(VariableDecl("ForeignKeyConstraint","fkc"));
                                varFkc = Variable("fkc");
                            }

                            initClassMethod.Statements.Add(Assign(
                                varFkc,
                                New("ForeignKeyConstraint", new CodeExpression[]{Str(fkc.ConstraintName), parentColumns, childrenColumns})
                            ));
                            initClassMethod.Statements.Add(MethodCall(
                                Property(Field(This(), TableFieldName(table)), "Constraints"), 
                                "Add", 
                                varFkc
                            ));

                            string acceptRejectRule = fkc.AcceptRejectRule.ToString();
                            string deleteRule = fkc.DeleteRule.ToString();
                            string updateRule = fkc.UpdateRule.ToString();
                            initClassMethod.Statements.Add(Assign(Property(varFkc,"AcceptRejectRule"),Field(TypeExpr(fkc.AcceptRejectRule.GetType()), acceptRejectRule)));
                            initClassMethod.Statements.Add(Assign(Property(varFkc,"DeleteRule"),Field(TypeExpr(fkc.DeleteRule.GetType()), deleteRule)));
                            initClassMethod.Statements.Add(Assign(Property(varFkc,"UpdateRule"),Field(TypeExpr(fkc.UpdateRule.GetType()), updateRule)));
                        }
                    }                
                }

                /*----------- Add Relations to the Dataset -------------------------*/
                foreach(DataRelation relation in dataSet.Relations) {                    
                    //\\ this.relation<RelationName>= new DataRelation("<RelationName>", 
                    //\\     new DataColumn[] {this.table<TableClassName>.<ColumnName>Column}, // parent columns
                    //\\     new DataColumn[] {this.table<TableClassName>.<ColumnName>Column}, // child columns
                    //\\     false                                                             // createConstraints 
                    //\\ ));
                    CodeArrayCreateExpression parentColCreate =  new CodeArrayCreateExpression("DataColumn", 0); {
                        string parentTableField = TableFieldName(relation.ParentTable);
                        foreach(DataColumn column in relation.ParentColumns) {
                            parentColCreate.Initializers.Add(Property(Field(This(), parentTableField), TableColumnPropertyName(column)));
                        }
                    }

                    CodeArrayCreateExpression childColCreate =  new CodeArrayCreateExpression("DataColumn", 0); {
                        string childTableField = TableFieldName(relation.ChildTable);
                        foreach(DataColumn column in relation.ChildColumns) {
                            childColCreate.Initializers.Add(Property(Field(This(), childTableField), TableColumnPropertyName(column)));
                        }
                    }
    
                    initClassMethod.Statements.Add(Assign(
                        Field(This(), RelationFieldName(relation)),
                        New("DataRelation", new CodeExpression[] {Str(relation.RelationName), parentColCreate, childColCreate,Primitive(false)})
                    ));

                    if (relation.Nested) {
                        //\\ this.relation<RelationName>.Nested = true;
                        initClassMethod.Statements.Add(Assign(Property(Field(This(), RelationFieldName(relation)), "Nested"), Primitive(true)));
                    }
                    //\\ this.Relations.Add(this.relation<RelationName>);
                    initClassMethod.Statements.Add(MethodCall(Property(This(), "Relations"), "Add", Field(This(), RelationFieldName(relation))));

                    //\\ this.relation<RelationName> = this.Relations["<RelationName>"];
                    initVarsMethod.Statements.Add(Assign(Field(This(), RelationFieldName(relation)), Indexer(Property(This(),"Relations"),Str(relation.RelationName))));
                }
            dataSetClass.Members.Add(initVarsMethod);
            }
            dataSetClass.Members.Add(initClassMethod);
            }

            for (int i = 0; i < dataSet.Tables.Count; i++) {
                string TableProperty = TablePropertyName(dataSet.Tables[i]);
                CodeMemberProperty prop = PropertyDecl(TableClassName(dataSet.Tables[i]), TableProperty, MemberAttributes.Public | MemberAttributes.Final); {
                    prop.CustomAttributes.Add(AttributeDecl("System.ComponentModel.Browsable",
                        Primitive(false)
                    ));
                    prop.CustomAttributes.Add(AttributeDecl("System.ComponentModel.DesignerSerializationVisibilityAttribute", 
                        Field(TypeExpr(typeof(DesignerSerializationVisibility)), "Content")
                    ));
                    prop.GetStatements.Add(Return(Field(This(), TableFieldName(dataSet.Tables[i]))));
                }
                dataSetClass.Members.Add(prop);

                CodeMemberMethod shouldSerializeTableProperty = MethodDecl("System.Boolean", "ShouldSerialize"+TableProperty, MemberAttributes.Private); {
                    shouldSerializeTableProperty.Statements.Add(Return(Primitive(false)));
                }
                dataSetClass.Members.Add(shouldSerializeTableProperty);
            }

            CodeMemberMethod schemaChanged = MethodDecl("System.Void", "SchemaChanged", MemberAttributes.Private); {
                schemaChanged.Parameters.Add(ParameterDecl(typeof(object), "sender"));            
                schemaChanged.Parameters.Add(ParameterDecl(typeof(CollectionChangeEventArgs), "e"));
                schemaChanged.Statements.Add(
                    If(EQ(Property(Argument("e"),"Action"),Field(TypeExpr(typeof(CollectionChangeAction)),"Remove")),
                        Stm(MethodCall(This(),"InitVars"))
                    )
                );
            }
            dataSetClass.Members.Add(schemaChanged);

            bool bInitExpressions = false;
            //\\  private void initExpressionMethod() {
            //\\  this.table_<TableName>.<ColumnProperty>.Expression = "<ColumnExpression>";
            //\\  }
            CodeMemberMethod initExpressionMethod = MethodDecl("System.Void", "InitExpressions", MemberAttributes.Private); {
                foreach(DataTable table in dataSet.Tables) {
                   for (int i = 0; i < table.Columns.Count; i++) {
                      DataColumn column = table.Columns[i];
                      CodeExpression codeField = Property(Field(This(), TableFieldName(table)), TableColumnPropertyName(column));
                      if (column.Expression.Length > 0) {
                         bInitExpressions = true;
                         initExpressionMethod.Statements.Add(Assign(Property(codeField, "Expression"), Str(column.Expression)));
                      }
                   }
                }
            }

            if (bInitExpressions) {
                dataSetClass.Members.Add(initExpressionMethod);
                initClassMethod.Statements.Add(MethodCall(This(), "InitExpressions"));
            }

            return dataSetClass;
        }// CreateTypedDataSet

        // CodeGen Helper functions :
        // -------------------- Expressions: ----------------------------
        //\\ this
        private static CodeExpression     This() { return new CodeThisReferenceExpression();}
        //\\ base
        private static CodeExpression     Base() { return new CodeBaseReferenceExpression();}
        //\\ value
        private static CodeExpression     Value() { return new CodePropertySetValueReferenceExpression();}
        //\\ <type>
        private static CodeTypeReference  Type(string type) { return new CodeTypeReference(type); }   
        private static CodeTypeReference  Type(Type type) { return new CodeTypeReference(type); }
        //\\ <type>[<rank>]
        private static CodeTypeReference  Type(string type, Int32 rank) { return new CodeTypeReference(type, rank); }   
        //\\ <type>
        private static CodeTypeReferenceExpression TypeExpr(Type   type) { return new CodeTypeReferenceExpression(type); }   
        private static CodeTypeReferenceExpression TypeExpr(string type) { return new CodeTypeReferenceExpression(type); }   
        //\\ ((<type>)<expr>)
        private static CodeExpression     Cast(string type           , CodeExpression expr) { return new CodeCastExpression(type, expr); }   
        private static CodeExpression     Cast(CodeTypeReference type, CodeExpression expr) { return new CodeCastExpression(type, expr); }   
        //\\ typeof(<type>)
        private static CodeExpression     TypeOf(string type) { return new CodeTypeOfExpression(type); }   
        //\\ <exp>.field
        private static CodeExpression     Field(CodeExpression exp, string field) { return new CodeFieldReferenceExpression(exp, field);}
        //\\ <exp>.property
        private static CodeExpression     Property(CodeExpression exp, string property) { return new CodePropertyReferenceExpression(exp, property);}
        //\\ argument
        private static CodeExpression     Argument(string argument) { return new CodeArgumentReferenceExpression(argument);}
        //\\ variable
        private static CodeExpression     Variable(string variable) { return new CodeVariableReferenceExpression(variable);}
        //\\ this.eventName
        private static CodeExpression     Event(string eventName) { return new CodeEventReferenceExpression(This(), eventName);}
        //\\ new <type>(<parameters>)
        private static CodeExpression     New(string type, CodeExpression[] parameters) { return new CodeObjectCreateExpression(type, parameters);}
        //\\ <primitive>
        private static CodeExpression     Primitive(object primitive) { return new CodePrimitiveExpression(primitive);}
        //\\ "<str>"
        private static CodeExpression     Str(string str) { return Primitive(str);}
        //\\ <targetObject>.<methodName>(<parameters>)
        private static CodeExpression     MethodCall(CodeExpression targetObject, String methodName, CodeExpression[] parameters) {
            return new CodeMethodInvokeExpression(targetObject, methodName, parameters);
        }
        //\\ <targetObject>.<methodName>()
        private static CodeExpression     MethodCall(CodeExpression targetObject, String methodName) {
            return new CodeMethodInvokeExpression(targetObject, methodName);
        }
        //\\ <targetObject>.<methodName>(par)
        private static CodeExpression     MethodCall(CodeExpression targetObject, String methodName, CodeExpression par) {
            return new CodeMethodInvokeExpression(targetObject, methodName, new CodeExpression[] {par});
        }
        //\\ <targetObject>(par)
        private static CodeExpression     DelegateCall(CodeExpression targetObject, CodeExpression par) {
            return new CodeDelegateInvokeExpression(targetObject, new CodeExpression[] {This(), par});
        }
        //\\ <targetObject>[indices]()
        private static CodeExpression     Indexer(CodeExpression targetObject, CodeExpression indices) {return new CodeIndexerExpression(targetObject, indices);}

        // -------------------- Binary Operators: ----------------------------
        private static CodeBinaryOperatorExpression      BinOperator(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right) {
            return new CodeBinaryOperatorExpression(left, op, right);
        }
        //\\ (left) != (right)
        private static CodeBinaryOperatorExpression      IdNotEQ(CodeExpression left, CodeExpression right) {return BinOperator(left, CodeBinaryOperatorType.IdentityInequality, right);}
        //\\ (left) == (right)
        private static CodeBinaryOperatorExpression      EQ(     CodeExpression left, CodeExpression right) {return BinOperator(left, CodeBinaryOperatorType.ValueEquality, right);}
        //\\ (left) || (right)
        private static CodeBinaryOperatorExpression      Or(     CodeExpression left, CodeExpression right) {return BinOperator(left, CodeBinaryOperatorType.BooleanOr    , right);}
        //\\ (left) < (right)
        private static CodeBinaryOperatorExpression      Less(   CodeExpression left, CodeExpression right) {return BinOperator(left, CodeBinaryOperatorType.LessThan     , right);}
        //\\ (left) + (right)
        private static CodeBinaryOperatorExpression      Add(    CodeExpression left, CodeExpression right) {return BinOperator(left, CodeBinaryOperatorType.Add          , right);}

        // -------------------- Statments: ----------------------------
        //\\ <expr>;
        private static CodeStatement      Stm(CodeExpression expr) { return new CodeExpressionStatement(expr);}
        //\\ return(<expr>);
        private static CodeStatement      Return(CodeExpression expr) { return new CodeMethodReturnStatement(expr);}
        //\\ left = right;
        private static CodeStatement      Assign(CodeExpression left, CodeExpression right) { return new CodeAssignStatement(left, right);}
        //\\ // comment
        private static CodeStatement      Comment(string comment) { return new CodeCommentStatement(comment);}
        //\\ throw new <exception>(<arg>)
        private static CodeStatement      Throw(string exception, string arg) { 
            return new CodeThrowExceptionStatement(New(exception, new CodeExpression[] {Str(Res.GetString(arg))}));
        }
        //\\ throw new <exception>(<arg>, <inner>)
        private static CodeStatement      Throw(string exception, string arg, string inner) { 
            return new CodeThrowExceptionStatement(New(exception, new CodeExpression[] {Str(Res.GetString(arg)), Variable(inner)}));
        }

        // -------------------- If: ----------------------------
        private static CodeStatement If(CodeExpression cond, CodeStatement[] trueStms, CodeStatement[] falseStms) {
            return new CodeConditionStatement(cond, trueStms, falseStms);
        }
        private static CodeStatement If(   CodeExpression cond, CodeStatement[] trueStms ) {return new CodeConditionStatement(cond, trueStms);}
        private static CodeStatement IfNot(CodeExpression cond, CodeStatement[] falseStms) {return new CodeConditionStatement(cond, new CodeStatement[] {}, falseStms);}
        private static CodeStatement If(   CodeExpression cond, CodeStatement   trueStm  ) {return If(   cond, new CodeStatement[] {trueStm });}
        private static CodeStatement IfNot(CodeExpression cond, CodeStatement   falseStm ) {return IfNot(cond, new CodeStatement[] {falseStm});}
        // -------------------- Declarations: ----------------------------
        private static CodeMemberField  FieldDecl(String type, String name) {return new CodeMemberField(type, name);}
        private static CodeMemberMethod Method(CodeTypeReference type, String name, MemberAttributes attributes) {
            CodeMemberMethod method = new CodeMemberMethod(); {
                method.ReturnType = type;
                method.Name       = name;
                method.Attributes = attributes;
            }
            return method;
        }
        private static CodeMemberMethod   MethodDecl(String type, String name, MemberAttributes attributes) {return Method(Type(type), name, attributes);}
        private static CodeMemberProperty PropertyDecl(String type, String name, MemberAttributes attributes) {
            CodeMemberProperty property = new CodeMemberProperty(); {
                property.Type       = Type(type);
                property.Name       = name;
                property.Attributes = attributes;
            }
            return property;
        }
        private static CodeStatement   VariableDecl(String type, String name) { return new CodeVariableDeclarationStatement(type, name); }
        private static CodeStatement   VariableDecl(String type, String name, CodeExpression initExpr) { return new CodeVariableDeclarationStatement(type, name, initExpr); }
        private static CodeStatement   VariableDecl(Type type, String name, CodeExpression initExpr) { return new CodeVariableDeclarationStatement(type, name, initExpr); }
        private static CodeMemberEvent EventDecl(String type, String name)  {
            CodeMemberEvent anEvent = new CodeMemberEvent(); {
                anEvent.Name       = name;
                anEvent.Type       = Type(type);
                anEvent.Attributes = MemberAttributes.Public | MemberAttributes.Final;
            }
            return anEvent;
        }
        private static CodeParameterDeclarationExpression     ParameterDecl(string type, string name) { return new CodeParameterDeclarationExpression(type, name);}
        private static CodeParameterDeclarationExpression     ParameterDecl(Type type, string name) { return new CodeParameterDeclarationExpression(type, name);}
        private static CodeAttributeDeclaration               AttributeDecl(string name) {
            return new CodeAttributeDeclaration(name);
        }
        private static CodeAttributeDeclaration               AttributeDecl(string name, CodeExpression value) {
            return new CodeAttributeDeclaration(name, new CodeAttributeArgument[] { new CodeAttributeArgument(value) });
        }
		// -------------------- Try/Catch ---------------------------
		//\\ try {<tryStmnt>} <catchClause>
		private static CodeStatement      Try(CodeStatement tryStmnt, CodeCatchClause catchClause) {
			return new CodeTryCatchFinallyStatement(
				new CodeStatement[] {tryStmnt}, 
				new CodeCatchClause[] {catchClause}
			);
		}
		//\\ catch(<type> <name>) {<catchStmnt>}
		private static CodeCatchClause Catch(string type, string name, CodeStatement catchStmnt) {
            CodeCatchClause ccc = new CodeCatchClause();
            ccc.CatchExceptionType = Type(type);
            ccc.LocalName = name;
            ccc.Statements.Add(catchStmnt);
            return ccc;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbdatapermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBDataPermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System.Diagnostics;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermissionAttribute"]/*' />
    [Serializable(), AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )]
    abstract public class DBDataPermissionAttribute : CodeAccessSecurityAttribute {
        private bool _allowBlankPassword;// = false;
        private string _connectionString;// = ADP.StrEmpty;
        private string _restrictions;// = ADP.StrEmpty;
        private KeyRestrictionBehavior _behavior;// = KeyRestrictionBehavior.AllowOnly;

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermissionAttribute.DBDataPermissionAttribute"]/*' />
        protected DBDataPermissionAttribute(SecurityAction action) : base(action) {
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermissionAttribute.AllowBlankPassword"]/*' />
        public bool AllowBlankPassword {
            get {
                return _allowBlankPassword;
            }
            set {
                _allowBlankPassword = value;
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermissionAttribute.ConnectionString"]/*' />
        public string ConnectionString {
            get {
                string value = _connectionString;
                return (null != value) ? value : ADP.StrEmpty;
            }
            set {
                _connectionString = value;
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermissionAttribute.KeyRestrictionBehavior"]/*' />
        public KeyRestrictionBehavior KeyRestrictionBehavior { // default AllowOnly
            get {
                return _behavior;
            }
            set {
                switch(value) {
                case KeyRestrictionBehavior.PreventUsage:
                case KeyRestrictionBehavior.AllowOnly:
                    _behavior = value;
                    break;
                default:
                    throw ADP.Argument("value");
                }
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermissionAttribute.KeyRestrictions"]/*' />
        public string KeyRestrictions {
            get {
                string value = _restrictions;
                return (null != value) ? value : ADP.StrEmpty;
            }
            set {
                _restrictions = value;
            }
        }

        internal bool ShouldSerializeConnectionString() { // MDAC 86773
            return (null != _connectionString);
        }

        internal bool ShouldSerializeKeyRestrictions() { // MDAC 86773
            return (null != _restrictions);
        }
    }
}

namespace System.Data { // MDAC 83087

    /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="KeyRestrictionBehavior"]/*' />
    public enum KeyRestrictionBehavior {

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="KeyRestrictionBehavior.AllowOnly"]/*' />
        AllowOnly = 0,

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="KeyRestrictionBehavior.PreventUsage"]/*' />
        PreventUsage = 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbconnectionstring.cs ===
//------------------------------------------------------------------------------
//  <copyright company='Microsoft Corporation'>
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
//  </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using Microsoft.Win32;

    internal enum UdlSupport {
        LoadFromFile,
        UdlAsKeyword,
        ThrowIfFound
    }

    [Serializable] // MDAC 83147
    internal class DBConnectionString {

#if ORACLECLIENT
        static internal IComparer   invariantComparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);
#else
        static internal IComparer   invariantComparer = InvariantComparer.Default;
#endif

        // connection string common keywords
        sealed private class KEY {
            internal const string Extended_Properties      = "extended properties";
            internal const string File_Name                = "file name";
            internal const string Integrated_Security      = "integrated security";
            internal const string Password                 = "password";
            internal const string Persist_Security_Info    = "persist security info";
            internal const string User_ID                  = "user id";
        };

        // known connection string common synonyms
        sealed private class SYNONYM {
            internal const string Pwd                   = "pwd";
            internal const string UID                   = "uid";
        };

        // registry key and dword value entry for udl pooling
        sealed private class UDL {
            internal const string Header   = "\xfeff[oledb]\r\n; Everything after this line is an OLE DB initstring\r\n";
            internal const string Location = "SOFTWARE\\Microsoft\\DataAccess";
            internal const string Pooling  = "Udl Pooling";

            static internal volatile bool    _PoolSizeInit; // UNDONE MDAC 75795: must be volatile, double locking problem
            static internal int              _PoolSize;
            static internal Hashtable        _Pool;
        }

#if DEBUG
        private static BooleanSwitch    _TraceParse;
#endif

        readonly private string         _encryptedUsersConnectionString;
        readonly private NameValuePair  _keychain;
        readonly private bool           _hasPassword;

        readonly private string         _encryptedActualConnectionString; // if != _connectionString the UDL was used
        readonly private Hashtable      _parsetable;            // should be immutable

        readonly private string[]       _restrictionValues;
        readonly private string         _restrictions;          // = ADP.StrEmpty;

        readonly private KeyRestrictionBehavior _behavior;      // = KeyRestrictionBehavior.AllowOnly

#if USECRYPTO
        private bool _isEncrypted; // MDAC 83212
#endif
        private string _displayString;

        // called by derived classes that may cache based on encryptedConnectionString and we only want to encrypt once
#if USECRYPTO
        protected DBConnectionString(string connectionString, string encryptedConnectionString, UdlSupport checkForUdl) {
#else
        protected DBConnectionString(string connectionString, UdlSupport checkForUdl) {
#endif
            _parsetable = new Hashtable();
            if (!ADP.IsEmpty(connectionString)) {
#if USECRYPTO
                if (ADP.IsEmpty(encryptedConnectionString)) {
                    encryptedConnectionString = Crypto.EncryptString(connectionString);
                }
                _encryptedUsersConnectionString = encryptedConnectionString;

                _encryptedActualConnectionString = ParseConnectionString(connectionString, encryptedConnectionString, checkForUdl, ref _keychain);
#else
                _encryptedUsersConnectionString = connectionString;
                char[] actual = ParseInternal(connectionString.ToCharArray(), checkForUdl, ref _keychain);
                _encryptedActualConnectionString = new String(actual);
#endif
            }
#if DEBUG
            _parsetable = ADP.ProtectHashtable(_parsetable);
#endif
#if USECRYPTO
            if (!_isEncrypted || ((connectionString as object) != (encryptedConnectionString as object))
                || !(_parsetable.ContainsKey(KEY.Password) || _parsetable.ContainsKey(SYNONYM.Pwd))) {
                _isEncrypted = false;
                _encryptedUsersConnectionString = connectionString;
            }
#endif
            if (null != _keychain) {
                _encryptedActualConnectionString = ValidateParse();
                _hasPassword = (_parsetable.ContainsKey(KEY.Password) || _parsetable.ContainsKey(SYNONYM.Pwd));
            }
        }

        // only called by DBDataPermission.Add
#if USECRYPTO
        internal DBConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior) : this(connectionString, null, UdlSupport.UdlAsKeyword) {
#else
        internal DBConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior, UdlSupport checkForUdl) : this(connectionString, checkForUdl) {
#endif
            if (!ADP.IsEmpty(restrictions)) {
                _restrictionValues = ParseRestrictions(restrictions, checkForUdl);
                _restrictions = restrictions;
            }
            _behavior = behavior;
        }

        protected internal DBConnectionString(DBConnectionString constr, bool withoutSensitiveOptions) { // Clone, DBDataPermission
            _encryptedUsersConnectionString  = constr._encryptedUsersConnectionString;
            _keychain                        = constr._keychain;
            _hasPassword                     = constr._hasPassword;

            _encryptedActualConnectionString = constr._encryptedActualConnectionString;
            _parsetable                      = constr._parsetable;

            _restrictionValues               = constr._restrictionValues;
            _restrictions                    = constr._restrictions;
            _behavior                        = constr._behavior;

            _displayString                   = constr._displayString;
#if USECRYPTO
            _isEncrypted                     = constr._isEncrypted;
#endif
            if (withoutSensitiveOptions && (null != _keychain) && !ContainsPersistablePassword()) { // MDAC 83180
                if (null == _displayString) {
                    _encryptedUsersConnectionString = _displayString = constr.GetConnectionString(true);
#if USECRYPTO
                    _isEncrypted = false; // MDAC 84193
#endif
                }
                _encryptedActualConnectionString = null;
                _parsetable = (Hashtable) _parsetable.Clone();
                _parsetable.Remove(KEY.Password);
                _parsetable.Remove(SYNONYM.Pwd);
#if DEBUG
                _parsetable = ADP.ProtectHashtable(_parsetable);
#endif
                NameValuePair tail = null;
                for(NameValuePair current = _keychain; null != current; current = current.Next) {
                    if ((KEY.Password != current.Name) && (SYNONYM.Pwd != current.Name)) {
                        if (null != tail) {
                            tail = tail.Next = current.Clone();
                        }
                        else {
                            _keychain = tail = current.Clone();
                        }
                    }
                }
            }
        }

        // only called by MergeIntersect which will pass restrictionValues we can trust that won't be mutated
        private DBConnectionString(DBConnectionString constr, string[] restrictionValues, KeyRestrictionBehavior behavior, bool hasPassword) : this(constr, false) {
            _restrictionValues = restrictionValues;
            _restrictions = null;
            _behavior = behavior;
            _hasPassword = hasPassword;
        }

        internal KeyRestrictionBehavior Behavior {
            get { return _behavior; }
        }        

        internal string GetConnectionString(bool hidePasswordPwd) {
            string value = null;
            if (hidePasswordPwd) {
                hidePasswordPwd = !ContainsPersistablePassword();
                if (hidePasswordPwd && (null != _displayString)) {
                    return _displayString;
                }
            }
            if (null != _encryptedUsersConnectionString) {
#if USECRYPTO
                try {
                    byte[] plainBytes = null;
                    GCHandle plainHandle = GCHandle.Alloc(null, GCHandleType.Normal);
                    try {
                        if (_isEncrypted) {
                            plainBytes = Crypto.DecryptString(_encryptedUsersConnectionString);
                        }
                        else {
                            plainBytes = new byte[ADP.CharSize * _encryptedUsersConnectionString.Length];
                            System.Text.Encoding.Unicode.GetBytes(_encryptedUsersConnectionString, 0, _encryptedUsersConnectionString.Length, plainBytes, 0);
                        }
                        plainHandle = GCHandle.Alloc(plainBytes, GCHandleType.Pinned);
                        if ((null != plainBytes) && (0 < plainBytes.Length)) {
                            if (hidePasswordPwd) {
                                char[] plainText = new char[plainBytes.Length / ADP.CharSize];
                                GCHandle textHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
                                try {
                                    Buffer.BlockCopy(plainBytes, 0, plainText, 0, plainBytes.Length);
                                    _displayString = value = RemovePasswordPwd(plainText);
                                }
                                finally {
                                    Array.Clear(plainText, 0, plainText.Length);
                                    if (textHandle.IsAllocated) {
                                        textHandle.Free();
                                    }
                                }
                            }
                            else {
                                value = System.Text.Encoding.Unicode.GetString(plainBytes, 0, plainBytes.Length);
                            }
                        }
                    }
                    finally {
                        if (null != plainBytes) {
                            Array.Clear(plainBytes, 0, plainBytes.Length);
                        }
                        if (plainHandle.IsAllocated) {
                            plainHandle.Free();
                        }
                    }
                }
                catch {
                    throw;
                }
#else
                if (hidePasswordPwd) {
                    _displayString = value = RemovePasswordPwd(_encryptedUsersConnectionString.ToCharArray());
                }
                else value = _encryptedUsersConnectionString;
#endif
            }
            return ((null != value) ? value : ADP.StrEmpty);
        }

        internal string EncryptedActualConnectionString { // may return null
            get { return _encryptedActualConnectionString; }
        }
#if USECRYPTO
        internal bool IsEncrypted {
            get { return _isEncrypted; }
        }
#endif
        internal NameValuePair KeyChain {
            get { return _keychain; }
        }

#if MDAC80721
        protected virtual bool EmbeddedExtendedProperties {
            get { return false; }
        }
#endif

        internal string Restrictions {
            get {
                string restrictions = _restrictions;
                if (null == restrictions) {
                    string[] restrictionValues = _restrictionValues;
                    if ((null != restrictionValues) && (0 < restrictionValues.Length)) {
                        StringBuilder builder = new StringBuilder();
                        for(int i = 0; i < restrictionValues.Length; ++i) {
                            builder.Append(restrictionValues[i]);
                            builder.Append("=;");
                        }
                        restrictions = builder.ToString();
                    }
                }
                return ((null != restrictions) ? restrictions: ADP.StrEmpty);
            }
        }

        internal string this[string keyword] {
            get { return (string)_parsetable[keyword]; }
        }
#if DEBUG
        static private BooleanSwitch TraceParseConnectionString {
            get {
                BooleanSwitch traceparse = _TraceParse;
                if (null == traceparse) {
                    traceparse = new BooleanSwitch("Data.ConnectionStringParse", "Enable tracing of connection string key/value pairs.");
                    _TraceParse = traceparse;
                }
                return traceparse;
            }
        }
#endif
        static internal int UdlPoolSize { // MDAC 69925
            get {
                int poolsize = UDL._PoolSize;
                if (!UDL._PoolSizeInit) {
                    object value = ADP.LocalMachineRegistryValue(UDL.Location, UDL.Pooling);
                    if (value is Int32) {
                        poolsize = (int) value;
                        poolsize = ((0 < poolsize) ? poolsize : 0);
                        UDL._PoolSize = poolsize;
                    }
                    UDL._PoolSizeInit = true;
                }
                return poolsize;
            }
        }

        static internal void CacheAdd(string encrypted, DBConnectionString value, ref Hashtable providerCache) {
            ADP.CheckArgumentNull(value, "value");
            ADP.CheckArgumentLength(value._encryptedUsersConnectionString, "connectionString");

            if (null == encrypted) {
                encrypted = value._encryptedUsersConnectionString;
            }

            // multiple threads could have parsed the same connection string at the same time
            // it doesn't really matter because they all should have resulted in the same value
            try {
                Hashtable hash = providerCache;
                if ((null == hash) || (250 <= hash.Count)) {
                    lock(typeof(DBConnectionString)) {
                        // flush the ConnectionString cache when it reaches a certain size
                        // this avoid accumlating parsed strings in a uncontrolled fashion
                        hash = new Hashtable();
                        hash[encrypted] = value;
                        providerCache = hash;
                    }
                }
                else {
                    lock(hash.SyncRoot) { // MDAC 74006
                        hash[encrypted] = value;
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        static internal DBConnectionString CacheQuery(string encryptedConnectionString, Hashtable providerCache) {
            Debug.Assert(!ADP.IsEmpty(encryptedConnectionString), "empty string");
            if ((null != providerCache) && providerCache.ContainsKey(encryptedConnectionString)) {
                return (providerCache[encryptedConnectionString] as DBConnectionString);
            }
            return null;
        }

        internal bool CheckConvertToBoolean(string keyname, bool defaultvalue) {
            object value;
            if (!_parsetable.ContainsKey(keyname) || (null == (value = _parsetable[keyname]))) {
                return defaultvalue;
            }
            if (value is String) {
                return CheckConvertToBooleanInternal(keyname, (string) value);
            }
            else {
                Debug.Assert(value is bool, keyname);
                return (bool) value;
            }
        }

        private bool CheckConvertToBooleanInternal(string keyname, string svalue) {
            if (CompareInsensitiveInvariant(svalue, "true") || CompareInsensitiveInvariant(svalue, "yes"))
                return true;
            else if (CompareInsensitiveInvariant(svalue, "false") || CompareInsensitiveInvariant(svalue, "no"))
                return false;
            else {
                string tmp = svalue.Trim();  // Remove leading & trailing white space.
                if (CompareInsensitiveInvariant(tmp, "true") || CompareInsensitiveInvariant(tmp, "yes"))
                    return true;
                else if (CompareInsensitiveInvariant(tmp, "false") || CompareInsensitiveInvariant(tmp, "no"))
                    return false;
                else {
#if DEBUG
                    if (TraceParseConnectionString.Enabled) {
                        Debug.WriteLine("ConvertToBoolean <" + svalue + ">");
                    }
#endif
                    throw ADP.InvalidConnectionOptionValue(keyname);
                }
            }
        }

        // same as CheckConvertBoolean, but with SSPI thrown in as valid yes
        internal bool CheckConvertIntegratedSecurity() {
            object value;
            if (!_parsetable.ContainsKey(KEY.Integrated_Security) || (null == (value = _parsetable[KEY.Integrated_Security]))) {
                return false;
            }
            if (value is String) {
                string svalue = (string) value;

                if (CompareInsensitiveInvariant(svalue, "sspi") || CompareInsensitiveInvariant(svalue, "true") || CompareInsensitiveInvariant(svalue, "yes"))
                    return true;
                else if (CompareInsensitiveInvariant(svalue, "false") || CompareInsensitiveInvariant(svalue, "no"))
                    return false;
                else {
                    string tmp = svalue.Trim();  // Remove leading & trailing white space.
                    if (CompareInsensitiveInvariant(tmp, "sspi") || CompareInsensitiveInvariant(tmp, "true") || CompareInsensitiveInvariant(tmp, "yes"))
                        return true;
                    else if (CompareInsensitiveInvariant(tmp, "false") || CompareInsensitiveInvariant(tmp, "no"))
                        return false;
                    else {
#if DEBUG
                        if (TraceParseConnectionString.Enabled) {
                            Debug.WriteLine("ConvertIntegratedSecurity <" + svalue + ">");
                        }
#endif
                        throw ADP.InvalidConnectionOptionValue(KEY.Integrated_Security);
                    }
                }
            }
            else {
                Debug.Assert(value is bool, KEY.Integrated_Security);
                return (bool) value;
            }
        }

        internal int CheckConvertToInt32(string keyname, int defaultvalue) {
            object value;
            if (!_parsetable.ContainsKey(keyname) || (null == (value = _parsetable[keyname]))) {
                return defaultvalue;
            }
            if (value is String) {
                try {
                    return Convert.ToInt32((string)value);
                }
                catch(Exception e) {
#if DEBUG
                    if (TraceParseConnectionString.Enabled) {
                        Debug.WriteLine("ConvertToInt32 <" + (string)value + ">");
                    }
#endif
                    throw ADP.InvalidConnectionOptionValue(keyname, e);
                }
            }
            else {
                Debug.Assert(value is Int32, keyname);
                return (int) value;
            }
        }

        internal string CheckConvertToString(string keyname, string defaultValue) {
            string value = null;
            if (_parsetable.ContainsKey(keyname)) {
                value = (string)_parsetable[keyname];
            }
            return ((null != value) ? value : defaultValue);
        }

        static private bool CompareInsensitiveInvariant(string strvalue, string strconst) {
            return (0 == CultureInfo.InvariantCulture.CompareInfo.Compare(strvalue, strconst, CompareOptions.IgnoreCase));
        }

        virtual internal bool Contains(string keyword) {
            return _parsetable.ContainsKey(keyword);
        }

#if DEBUG
        [System.Diagnostics.Conditional("DEBUG")]
        internal void DebugTraceConnectionString(char[] connectionString) {
            try {
                string reducedConnectionString = RemovePasswordPwd(connectionString); // don't trace passwords ever!
                Debug.WriteLine("<" + reducedConnectionString + ">");
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void DebugTraceKeyValuePair(string keyname, string keyvalue) {
            try {
                Debug.Assert(keyname == keyname.ToLower(CultureInfo.InvariantCulture), "keyname == keyname.ToLower");
                keyname = KeywordLookup(keyname);
                if (!IsSensitiveOption(keyname)) { // don't trace passwords ever!
                    if (null != keyvalue) {
#if MDAC80721
                        if (EmbeddedExtendedProperties && (KEY.Extended_Properties == keyname)) {
                            Debug.Write("\t<" + keyname + ">=");
                            DebugTraceConnectionString(keyvalue.ToCharArray());
                        }
                        else {
#endif
                            Debug.WriteLine("\t<" + keyname + ">=<" + keyvalue + ">;");
#if MDAC80721
                        }
#endif
                    }
                    else {
                        Debug.WriteLine("\t<" + keyname + ">=;");
                    }
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
        }
#endif

        static private string GetKey(char[] valuebuf, int bufPosition) {
            bufPosition = TrimWhiteSpace(valuebuf, bufPosition);

            string key = System.Text.Encoding.Unicode.GetString(System.Text.Encoding.Unicode.GetBytes(valuebuf, 0, bufPosition));
            key = key.ToLower(CultureInfo.InvariantCulture);

            return key;
        }

        static private Exception ConnectionStringSyntax(int index, char[] connectionString) {
#if DEBUG
            if (TraceParseConnectionString.Enabled) {
                foreach(byte v in System.Text.Encoding.Unicode.GetBytes(connectionString)) {
                    Debug.Write(String.Format("{0,2:X},", v));
                }
                Debug.WriteLine("");
            }
#endif
            return ADP.ConnectionStringSyntax(index);
        }

        // transistion states used for parsing
        private enum PARSERSTATE {
            NothingYet=1,   //start point
            Key,
            KeyEqual,
            KeyEnd,
            UnquotedValue,
            DoubleQuoteValue,
            DoubleQuoteValueQuote,
            DoubleQuoteValueEnd,
            SingleQuoteValue,
            SingleQuoteValueQuote,
            SingleQuoteValueEnd,
            NullTermination,
        };

        /*
            Here is the RegEx pattern we used to use:

                private const string ConnectionStringPattern =      // available via DBConnectionString.ConnectionStringRegEx.ToString();
                     "(?<pair>"                                     // for easy key-value pair identification and removal
                    + "[\\s;]*"                                     // leading and in-between-pair whitespace/semicolons
                    + "(?<key>([^=\\s]|\\s+[^=\\s]|\\s+==|==)+)"    // allow any visible character for key except '=' which must be quoted as '=='
                    +    "\\s*=(?!=)\\s*"                           // the equal sign divides the key and value parts
                    + "(?<value>("
                    +    "(" + "\"" + "([^\"]|\"\")*" + "\"" + ")"  // double quoted string, inside " must be quoted as ""
                    +    "|"
                    +    "(" + "'" + "([^']|'')*" + "'" + ")"       // single quoted string, inside ' must be quoted as '
                    +    "|"
                    +    "(" + "(?![\"'])"                          // treated as error if start/stop with ' or "
                    +               "([^\\s;]|\\s+[^\\s;])*"        // allow everything else, using ; as stop
                             + "(?<![\"'])" + ")"                   // treated as error if start/stop with ' or "
                    +  "))"
                    +")*"
                    +"[\\s;\u0000]*"                                // trailing whitespace/semicolons and embedded nulls from DataSourceLocator
                ;
        */
        static private int GetKeyValuePair (char[] connectionString, int currentPosition, out string key, char[] valuebuf, out int vallength, out bool isempty) {
            PARSERSTATE     parserState = PARSERSTATE.NothingYet;
            int             bufPosition = 0;
            int startposition = currentPosition;

            key = null;
            vallength = -1;
            isempty = false;

            char currentChar = '\0';
            for (; currentPosition < connectionString.Length; ++currentPosition) {
                currentChar = connectionString[currentPosition];

                switch(parserState) {
                case PARSERSTATE.NothingYet:
                    if (';' == currentChar || Char.IsWhiteSpace(currentChar)) {
                        continue;
                    }
                    startposition = currentPosition;
                    if ('\0' == currentChar)            { parserState = PARSERSTATE.NullTermination; continue; } // MDAC 83540
                    if (Char.IsControl(currentChar))    { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    parserState = PARSERSTATE.Key;
                    bufPosition = 0;
                    break;

                case PARSERSTATE.Key:
                    if ('=' == currentChar)             { parserState = PARSERSTATE.KeyEqual;       continue; }
                    if (Char.IsWhiteSpace(currentChar)) { break; }
                    if (Char.IsControl(currentChar))    { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    break;

                case PARSERSTATE.KeyEqual:
                    if ('=' == currentChar)             { parserState = PARSERSTATE.Key;            break; }
                    key = GetKey(valuebuf, bufPosition);
                    bufPosition = 0;
                    parserState = PARSERSTATE.KeyEnd;
                    goto case PARSERSTATE.KeyEnd;

                case PARSERSTATE.KeyEnd:
                    if (Char.IsWhiteSpace(currentChar)) { continue; }
                    if ('\''== currentChar)             { parserState = PARSERSTATE.SingleQuoteValue; continue; }
                    if ('"'  == currentChar)            { parserState = PARSERSTATE.DoubleQuoteValue; continue; }
                    if (';' == currentChar)             { goto Done; }
                    if ('\0' == currentChar)            { goto Done; }
                    if (Char.IsControl(currentChar))    { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    parserState = PARSERSTATE.UnquotedValue;
                    break;

                case PARSERSTATE.UnquotedValue:
                    if (Char.IsWhiteSpace(currentChar)) { break; }
                    if (Char.IsControl(currentChar) || ';' == currentChar) {
                        goto Done;
                    }
                    break;

                case PARSERSTATE.DoubleQuoteValue:
                    if ('"' == currentChar)             { parserState = PARSERSTATE.DoubleQuoteValueQuote;   continue; }
                    if ('\0' == currentChar)            { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    break;

                case PARSERSTATE.DoubleQuoteValueQuote:
                    if ('"' == currentChar)             { parserState = PARSERSTATE.DoubleQuoteValue;      continue; }
                    parserState = PARSERSTATE.DoubleQuoteValueEnd;
                    goto case PARSERSTATE.DoubleQuoteValueEnd;

                case PARSERSTATE.DoubleQuoteValueEnd:
                    if (Char.IsWhiteSpace(currentChar)) { continue; }
                    if (';' == currentChar)             { goto Done; }
                    if ('\0' == currentChar)            { parserState = PARSERSTATE.NullTermination; continue; } // MDAC 83540
                    throw ConnectionStringSyntax(currentPosition, connectionString);  // unbalanced double quote

                case PARSERSTATE.SingleQuoteValue:
                    if ('\''== currentChar)             { parserState = PARSERSTATE.SingleQuoteValueQuote;   continue; }
                    if ('\0' == currentChar)            { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    break;

                case PARSERSTATE.SingleQuoteValueQuote:
                    if ('\''== currentChar)             { parserState = PARSERSTATE.SingleQuoteValue;      continue; }
                    parserState = PARSERSTATE.SingleQuoteValueEnd;
                    goto case PARSERSTATE.SingleQuoteValueEnd;

                case PARSERSTATE.SingleQuoteValueEnd:
                    if (Char.IsWhiteSpace(currentChar)) { continue; }
                    if (';' == currentChar)             { goto Done; }
                    if ('\0' == currentChar)            { parserState = PARSERSTATE.NullTermination; continue; } // MDAC 83540
                    throw ConnectionStringSyntax(currentPosition, connectionString);  // unbalanced single quote

                case PARSERSTATE.NullTermination:
                    if ('\0' == currentChar) { continue; }
                    if (Char.IsWhiteSpace(currentChar)) { continue; } // MDAC 83540
                    throw ConnectionStringSyntax(startposition, connectionString);

                default:
                    Debug.Assert (false, "no state defined!!!!we should never be here!!!");
                    break;
                }

                valuebuf[bufPosition++] = currentChar;
            }

            if (PARSERSTATE.KeyEqual == parserState) {
                key = GetKey(valuebuf, bufPosition);
                bufPosition = 0;
            }
            if (PARSERSTATE.Key == parserState
                || PARSERSTATE.DoubleQuoteValue == parserState
                || PARSERSTATE.SingleQuoteValue == parserState) {
                throw ConnectionStringSyntax(startposition, connectionString);    // keyword not found/unbalanced double/single quote
            }
            Done:
                if (PARSERSTATE.UnquotedValue == parserState) {
                    bufPosition = TrimWhiteSpace(valuebuf, bufPosition);
                    if (('\'' == valuebuf[bufPosition-1]) || ('"' == valuebuf[bufPosition-1])) {
                        throw ConnectionStringSyntax(currentPosition-1, connectionString);    // unquoted value must not end in quote
                    }
                }
                else if ((PARSERSTATE.KeyEqual != parserState) && (PARSERSTATE.KeyEnd != parserState)) { // MDAC 83525
                    isempty = (0 == bufPosition); // MDAC 83525
                }

            if ((';' == currentChar) && (currentPosition < connectionString.Length)) {
                currentPosition++;
            }

            vallength = bufPosition;

            return currentPosition;
        }

        static private string GetSensitiveValue (char[] valuebuf, int valstart, int vallength, bool isempty) {
            string result = ((isempty) ? ADP.StrEmpty : null);

            if (0 < vallength) {
#if USECRYPTO
                result = Crypto.EncryptFromBlock(valuebuf, valstart, vallength);
#else
                result = new string(valuebuf, valstart, vallength);
#endif
            }
#if USECRYPTO
            Array.Clear(valuebuf, valstart, vallength); // valuebuf should be pinned
#endif
            return result;
        }

        static private string GetValue(char[] valuebuf, int valstart, int vallength, bool isempty) {
            string result = ((isempty) ? ADP.StrEmpty : null);

            if (0 < vallength)
                result = new string(valuebuf, valstart, vallength);

            return result;
        }

        internal bool HasBlankPassword() {
            bool blankPassword = false;
            bool checkuserid = true;
            if (_parsetable.ContainsKey(KEY.Password)) {
                blankPassword = ADP.IsEmpty((string)_parsetable[KEY.Password]);
                checkuserid = false;
            }
            if (_parsetable.ContainsKey(SYNONYM.Pwd)) {
                blankPassword |= ADP.IsEmpty((string)_parsetable[SYNONYM.Pwd]); // MDAC 83097
                checkuserid = false;
            }
            if (checkuserid) {
                blankPassword = ((_parsetable.ContainsKey(KEY.User_ID) && !ADP.IsEmpty((string)_parsetable[KEY.User_ID]))
                    || (_parsetable.ContainsKey(SYNONYM.UID) && !ADP.IsEmpty((string)_parsetable[SYNONYM.UID])));
            }
            return blankPassword;
        }

        internal bool IsEmpty() {
            return (null == _keychain);
        }

        virtual protected bool IsSensitiveOption(string keyname) {
            return ((KEY.Password == keyname) || (SYNONYM.Pwd == keyname));
        }

        virtual protected string KeywordLookup(string keyname) {
            return keyname;
        }

        private bool IsRestrictedKeyword(string key) {
            // restricted if not found
            return ((null == _restrictionValues) || (0 > Array.BinarySearch(_restrictionValues, key, invariantComparer)));
        }

        internal bool IsSubsetOf(DBConnectionString entry) {
            Hashtable parsetable = entry._parsetable;
            switch(_behavior) {
            case KeyRestrictionBehavior.AllowOnly:
                // every key must either be in the resticted connection string or in the allowed keywords
                foreach(string key in parsetable.Keys) {
                   if (!_parsetable.ContainsKey(key) && IsRestrictedKeyword(key)) {
#if DATAPERMIT
                        Debug.WriteLine("DBDataPermission failed AllowOnly");
#endif
                        return false;
                    }
                }
                // if a password was present then the restricted connection string must either have had a password or allow it
                if (entry._hasPassword && !_hasPassword && IsRestrictedKeyword(KEY.Password) && IsRestrictedKeyword(SYNONYM.Pwd)) {
#if DATAPERMIT
                        Debug.WriteLine("DBDataPermission failed AllowOnly for password");
#endif
                        return false;
                }
                break;
            case KeyRestrictionBehavior.PreventUsage:
                // every key can not be in the restricted keywords (even if in the restricted connection string)
                if (null != _restrictionValues) {
                    foreach(string restriction in _restrictionValues) {
                        if (parsetable.ContainsKey(restriction)) {
#if DATAPERMIT
                            Debug.WriteLine("DBDataPermission failed PreventUsage");
#endif
                            return false;
                        }
                        if (entry._hasPassword && ((KEY.Password == restriction) || (SYNONYM.Pwd == restriction))) {
#if DATAPERMIT
                            Debug.WriteLine("DBDataPermission failed PreventUsage for password");
#endif
                            return false;
                        }
                    }
                }
                break;
            default:
                Debug.Assert(false, "invalid KeyRestrictionBehavior");
                throw ADP.InvalidCast();
            }
            return true;
        }

        static private char[] LoadStringFromStorage(string udlfilename) { // UNDONE: MDAC 82612
            string udlFullPath = udlfilename;
            if (!ADP.IsEmpty(udlFullPath)) { // fail via new FileStream vs. GetFullPath
                udlFullPath = ADP.GetFullPath(udlFullPath); // MDAC 82833
            }
            return LoadStringFromCacheStorage(udlFullPath);
        }

        static private char[] LoadStringFromCacheStorage(string udlfilename) { // UNDONE: MDAC 82612
            char[] plainText = null;
            Hashtable udlcache = UDL._Pool;

            if ((null != udlcache) && udlcache.ContainsKey(udlfilename)) {
                string encrypted = (string)udlcache[udlfilename];
#if USECRYPTO
                byte[] plainBytes = new Byte[ADP.CharSize*encrypted.Length];
                GCHandle handle = GCHandle.Alloc(plainBytes, GCHandleType.Pinned);
                try {
                    int count = Crypto.DecryptToBlock(encrypted, plainBytes, 0, plainBytes.Length);
                    plainText = new Char[count/ADP.CharSize]; // UNDONE: creating unpinned buffer
                    /*GCHandle lostHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);*/
                    Buffer.BlockCopy(plainBytes, 0, plainText, 0, count);
                }
                finally {
                    Array.Clear(plainBytes, 0, plainBytes.Length);
                    if (handle.IsAllocated) {
                        handle.Free();
                    }
                }
#else
                plainText = encrypted.ToCharArray();
#endif
            }
            else {
                plainText = LoadStringFromFileStorage(udlfilename);
                if (null != plainText) {
#if USECRYPTO
                    GCHandle plainHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
#endif
                    Debug.Assert(!ADP.IsEmpty(udlfilename), "empty filename didn't fail");

                    if (0 < UdlPoolSize) {
#if USECRYPTO
                        string encrypted = Crypto.EncryptFromBlock(plainText, 0, plainText.Length);
#else
                        string encrypted = new String(plainText);
#endif
                        Debug.Assert(udlfilename == ADP.GetFullPath(udlfilename), "only cache full path filenames"); // MDAC 82833

                        if (null == udlcache) {
                            udlcache = new Hashtable();
                            udlcache[udlfilename] = encrypted;

                            lock(typeof(DBConnectionString)) {
                                if (null == UDL._Pool) {
                                    UDL._Pool = udlcache;
                                    udlcache = null;
                                }
                            }
                        }
                        if (null != udlcache) {
                            lock(udlcache.SyncRoot) {
                                udlcache[udlfilename] = encrypted;
                            }
                        }
                    }
#if USECRYPTO
                    plainHandle.Free();
#endif
                }
            }
            return plainText;
        }

        static private char[] LoadStringFromFileStorage(string udlfilename) { // UNDONE: MDAC 82612
            // Microsoft Data Link File Format
            // The first two lines of a .udl file must have exactly the following contents in order to work properly:
            //  [oledb]
            //  ; Everything after this line is an OLE DB initstring
            //
            char[] plainText = null;
            Exception failure = null;
            try {
                int hdrlength = ADP.CharSize*UDL.Header.Length;
                using(FileStream fstream = new FileStream(udlfilename, FileMode.Open, FileAccess.Read, FileShare.Read)) {
                    long length = fstream.Length;
                    if (length < hdrlength || (0 != length%ADP.CharSize)) {
                        failure = ADP.InvalidUDL();
                    }
                    else {
                        byte[] bytes = new Byte[hdrlength];
                        int count = fstream.Read(bytes, 0, bytes.Length);
                        if (count < hdrlength) {
                            failure = ADP.InvalidUDL();
                        }
                        else if (System.Text.Encoding.Unicode.GetString(bytes, 0, hdrlength) != UDL.Header) {
                            failure = ADP.InvalidUDL();
                        }
                        else { // please verify header before allocating memory block for connection string
                            bytes = new Byte[length - hdrlength];
#if USECRYPTO
                            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
                            try {
#endif
                                count = fstream.Read(bytes, 0, bytes.Length);
                                plainText = new Char[count/ADP.CharSize]; // UNDONE: creating unpinned buffer
                                /*GCHandle lostHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);*/
                                Buffer.BlockCopy(bytes, 0, plainText, 0, count);
#if USECRYPTO
                            }
                            finally {
                                Array.Clear(bytes, 0, bytes.Length);
                                if (handle.IsAllocated) {
                                    handle.Free();
                                }
                            }
#endif
                        }
                    }
                }
            }
            catch(Exception e) {
                throw ADP.UdlFileError(e);
            }
            if (null != failure) {
                throw failure;
            }
            return plainText;
        }

        internal DBConnectionString MergeIntersect(DBConnectionString entry) { // modify this _restrictionValues with intersect of entry
            KeyRestrictionBehavior behavior = _behavior;
            string[] restrictionValues = null;

            if (null == entry) {
                //Debug.WriteLine("0 entry AllowNothing");
                behavior = KeyRestrictionBehavior.AllowOnly;
            }
            else if (this._behavior != entry._behavior) { // subset of the AllowOnly array
                if (KeyRestrictionBehavior.AllowOnly == entry._behavior) { // this PreventUsage and entry AllowOnly
                    if (!ADP.IsEmpty(_restrictionValues)) {
                        if (!ADP.IsEmpty(entry._restrictionValues)) {
                            //Debug.WriteLine("1 this PreventUsage with restrictions and entry AllowOnly with restrictions");
                            restrictionValues = NewRestrictionAllowOnly(entry._restrictionValues, _restrictionValues);
                        }
                        else {
                            //Debug.WriteLine("2 this PreventUsage with restrictions and entry AllowOnly with no restrictions");
                        }
                    }
                    else {
                        //Debug.WriteLine("3/4 this PreventUsage with no restrictions and entry AllowOnly");
                        restrictionValues = entry._restrictionValues;
                    }
                }
                else if (!ADP.IsEmpty(_restrictionValues)) { // this AllowOnly and entry PreventUsage
                    if (!ADP.IsEmpty(entry._restrictionValues)) {
                        //Debug.WriteLine("5 this AllowOnly with restrictions and entry PreventUsage with restrictions");
                        restrictionValues = NewRestrictionAllowOnly(_restrictionValues, entry._restrictionValues);
                    }
                    else {
                        //Debug.WriteLine("6 this AllowOnly and entry PreventUsage with no restrictions");
                        restrictionValues = _restrictionValues;
                    }
                }
                else {
                    //Debug.WriteLine("7/8 this AllowOnly with no restrictions and entry PreventUsage");
                }
                behavior = KeyRestrictionBehavior.AllowOnly;
            }
            else if (KeyRestrictionBehavior.PreventUsage == this._behavior) { // both PreventUsage
                if (ADP.IsEmpty(_restrictionValues)) {
                    //Debug.WriteLine("9/10 both PreventUsage and this with no restrictions");
                    restrictionValues = entry._restrictionValues;
                }
                else if (ADP.IsEmpty(entry._restrictionValues)) {
                    //Debug.WriteLine("11 both PreventUsage and entry with no restrictions");
                    restrictionValues = _restrictionValues;
                }
                else {
                    //Debug.WriteLine("12 both PreventUsage with restrictions");
                    restrictionValues = NoDuplicateUnion(_restrictionValues, entry._restrictionValues);
                }
            }
            else if (!ADP.IsEmpty(_restrictionValues) && !ADP.IsEmpty(entry._restrictionValues)) { // both AllowOnly with restrictions
                if (this._restrictionValues.Length <= entry._restrictionValues.Length) {
                    //Debug.WriteLine("13a this AllowOnly with restrictions and entry AllowOnly with restrictions");
                    restrictionValues = NewRestrictionIntersect(_restrictionValues, entry._restrictionValues);
                }
                else {
                    //Debug.WriteLine("13b this AllowOnly with restrictions and entry AllowOnly with restrictions");
                    restrictionValues = NewRestrictionIntersect(entry._restrictionValues, _restrictionValues);
                }
            }
            else { // both AllowOnly
                //Debug.WriteLine("14/15/16 this AllowOnly and entry AllowOnly but no restrictions");
            }
            return new DBConnectionString(this, restrictionValues, behavior, (this._hasPassword && ((null != entry) && entry._hasPassword)));
        }


        static private string[] NewRestrictionAllowOnly(string[] allowonly, string[] preventusage) {
            ArrayList newlist = null;
            for (int i = 0; i < allowonly.Length; ++i) {
                if (0 > Array.BinarySearch(preventusage, allowonly[i], invariantComparer)) {
                    if (null == newlist) {
                        newlist = new ArrayList();
                    }
                    newlist.Add(allowonly[i]);
                }
            }
            if (null != newlist) {
                return (string[])newlist.ToArray(typeof(String));
            }
            return null;
        }

        static private string[] NewRestrictionIntersect(string[] a, string[] b) {
            ArrayList newlist = null;
            for (int i = 0; i < a.Length; ++i) {
                if (0 <= Array.BinarySearch(b, a[i], invariantComparer)) {
                    if (null == newlist) {
                        newlist = new ArrayList();
                    }
                    newlist.Add(a[i]);
                }
            }
            if (newlist != null) {
                return (string[])newlist.ToArray(typeof(String));
            }
            return null;
        }

        static private string[] NoDuplicateUnion(string[] a, string[] b) {
            int length = a.Length;
            int count = b.Length;
            int index = 0;

            for(int i = 0; i < length; ++i) { // find duplicates
                if (0 > Array.BinarySearch(b, a[i], invariantComparer)) {
                    a[i] = null;
                    --count;
                }
            }
            string[] restrictionValues = new string[length + count];
            for(int i = 0; i < length; ++i) { // copy from this except duplicates (now as null)
                string restriction = a[i];
                if (null != restriction) {
                    restrictionValues[index++] = restriction;
                }
            }
            length = b.Length;
            for (int i = 0; i < length; ++i, index++) { // copy from entry
                restrictionValues[index] = b[i];
            }
            Array.Sort(restrictionValues, invariantComparer);
            return restrictionValues;
        }

#if USECRYPTO
        private string ParseConnectionString(string connectionString, string encryptedConnectionString, UdlSupport checkForUdl, ref NameValuePair keychain) {
            string encryptedActualConnectionString = encryptedConnectionString;
            try {
                char[] plainText = new char[connectionString.Length];
                GCHandle plainHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
                try {
                    connectionString.CopyTo(0, plainText, 0, plainText.Length);
                    char[] resultText = ParseInternal(plainText, checkForUdl, ref keychain);
                    if ((plainText as object) != (resultText as object)) {
                        GCHandle resultHandle = GCHandle.Alloc(resultText, GCHandleType.Pinned);
                        try {
                            encryptedActualConnectionString = Crypto.EncryptFromBlock(resultText, 0, resultText.Length);
                        }
                        finally {
                            Array.Clear(resultText, 0, resultText.Length);
                            if(resultHandle.IsAllocated) {
                                resultHandle.Free();
                            }
                            resultText = null;
                        }
                    }
                }
                finally {
                    Array.Clear(plainText, 0, plainText.Length);
                    if(plainHandle.IsAllocated) {
                        plainHandle.Free();
                    }
                    plainText = null;
                }
            }
            catch {
                throw;
            }
            return encryptedActualConnectionString;
        }
#endif

        private char[] ParseInternal(char[] connectionString, UdlSupport checkForUdl, ref NameValuePair keychain) { // UNDONE: MDAC 82612
            Debug.Assert(null != connectionString, "null connectionstring");
#if DEBUG
            if (TraceParseConnectionString.Enabled) {
                DebugTraceConnectionString(connectionString);
            }
#endif
            bool    isempty;
            int     startPosition;
            int     nextStartPosition = 0;
            int     endPosition = connectionString.Length;
            string  keyname;
            char[]  valueBuffer = new char[connectionString.Length];
            int     valueLength;
            string  udlFileName = null;
            int     udlInsertPosition = 0;
#if USECRYPTO
            GCHandle actualHandle = GCHandle.Alloc(null, GCHandleType.Normal);
#endif
            char[]  actualConnectionString = null;
            int     actualConnectionStringLength = 0;

            char[]  result = connectionString;

            NameValuePair localKeychain = null;

#if USECRYPTO
            GCHandle valueHandle = GCHandle.Alloc(valueBuffer, GCHandleType.Pinned);
            try {
#endif
                while (nextStartPosition < endPosition) {
                    startPosition    = nextStartPosition;
                    nextStartPosition = GetKeyValuePair(connectionString, startPosition, out keyname, valueBuffer, out valueLength, out isempty);

                    if (!ADP.IsEmpty(keyname)) {
                        string keyvalue = null;
#if DEBUG
                        if (TraceParseConnectionString.Enabled) {
                            DebugTraceKeyValuePair(keyname, System.Text.Encoding.Unicode.GetString(System.Text.Encoding.Unicode.GetBytes(valueBuffer, 0, valueLength)));
                        }
#endif
                        if (KEY.File_Name == keyname) {
                            keyvalue = GetValue(valueBuffer, 0, valueLength, isempty); // MDAC 83987, 83543
                            switch (checkForUdl) {
                            case UdlSupport.LoadFromFile:
                                udlFileName = keyvalue;

                                int pairLength = nextStartPosition-startPosition;

                                if (null == actualConnectionString) {
                                    actualConnectionStringLength = connectionString.Length;
                                    actualConnectionString       = new char[actualConnectionStringLength];
#if USECRYPTO
                                    actualHandle = GCHandle.Alloc(actualConnectionString, GCHandleType.Pinned);
#endif
                                    ADP.CopyChars(connectionString, 0, actualConnectionString, 0, startPosition);
                                }
                                udlInsertPosition = startPosition - (connectionString.Length - actualConnectionStringLength);
                                ADP.CopyChars(connectionString, nextStartPosition, actualConnectionString, udlInsertPosition, connectionString.Length-nextStartPosition);

                                actualConnectionStringLength -= pairLength;
#if USECRYPTO
                                Array.Clear(actualConnectionString, actualConnectionStringLength, pairLength);   // don't leave sensitive stuff in memory.
#endif
                                break;

                            case UdlSupport.UdlAsKeyword:
                                break;

                            case UdlSupport.ThrowIfFound:
                            default:
                                throw ADP.KeywordNotSupported(keyname);
                            }
                        }
                        else  {
                            string realkeyname = KeywordLookup(keyname);
                            if (ADP.IsEmpty(realkeyname)) {
                                throw ADP.KeywordNotSupported(keyname);
                            }
                            keyname = realkeyname;

                            if (IsSensitiveOption(keyname)) {
                                keyvalue = GetSensitiveValue(valueBuffer, 0, valueLength, isempty);
#if USECRYPTO
                                _isEncrypted = true;
#endif
                            }
                            else {
                                keyvalue = GetValue(valueBuffer, 0, valueLength, isempty);
                            }
                        }
                        _parsetable[keyname] = keyvalue; // last key-value pair wins

                        if(null != localKeychain) {
                            localKeychain = localKeychain.Next = new NameValuePair(keyname, keyvalue);
                        }
                        else if (null == keychain) { // first time only - don't contain modified chain from UDL file
                            keychain = localKeychain = new NameValuePair(keyname, keyvalue);
                        }
                        
                    }
                }

                if (null != actualConnectionString) {
                    if (UdlSupport.LoadFromFile == checkForUdl && (null != udlFileName)) { // UDL file support
                        char[] udlConnectionString = udlConnectionString = LoadStringFromStorage(udlFileName);
                        if ((null != udlConnectionString) && (0 < udlConnectionString.Length)) {
#if USECRYPTO
                            GCHandle udlHandle = GCHandle.Alloc(udlConnectionString, GCHandleType.Pinned);
                            try {
#endif
                                int newLength = actualConnectionStringLength + udlConnectionString.Length;

                                result = new char[newLength]; // UNDONE: creating unpinned buffer
                                /*GCHandle lostHandle = GCHandle.Alloc(result, GCHandleType.Pinned);*/

                                ADP.CopyChars(actualConnectionString, 0,    result, 0,                  udlInsertPosition);
                                ADP.CopyChars(udlConnectionString,    0,    result, udlInsertPosition,  udlConnectionString.Length);
                                ADP.CopyChars(actualConnectionString, udlInsertPosition,
                                    result, udlConnectionString.Length + udlInsertPosition,
                                    actualConnectionStringLength - udlInsertPosition);

                                // recursively parse the new connection string (but only allow one
                                // level of recursion by specifying checkForUdl=false)
                                result = ParseInternal(result, UdlSupport.UdlAsKeyword, ref keychain);
#if USECRYPTO
                            }
                            finally {
                                Array.Clear(udlConnectionString, 0, udlConnectionString.Length);
                                if (udlHandle.IsAllocated) {
                                    udlHandle.Free();
                                }
                                udlConnectionString = null;
                            }
#endif
                        }
                    }
                    else {
                        result = actualConnectionString;
                    }
#if USECRYPTO
                    if (result != actualConnectionString) {
                        Array.Clear(actualConnectionString, 0, actualConnectionString.Length);
                    }
                    if (actualHandle.IsAllocated) {
                        actualHandle.Free();
                    }
                    actualConnectionString = null;
#endif
                }
#if USECRYPTO
            }
            catch {
                Array.Clear(valueBuffer, 0, valueBuffer.Length);
                if (valueHandle.IsAllocated) {
                    valueHandle.Free();
                }
                if (null != actualConnectionString) {
                    Array.Clear(actualConnectionString, 0, actualConnectionString.Length);
                    if (actualHandle.IsAllocated) {
                        actualHandle.Free();
                    }
                }
                throw;
            }
            // valueBuffer is cleared by GetSensitiveOption in normal scenario
            if (valueHandle.IsAllocated) {
                valueHandle.Free();
            }
#endif
            return result;
        }

        private string[] ParseRestrictions(string restrictions, UdlSupport checkForUdl) {
            ADP.CheckArgumentNull(restrictions, "restrictions");

            bool    isempty;
            int     startPosition;
            int     nextStartPosition = 0;
            int     endPosition = restrictions.Length;
            string  keyname;
            char[]  valueBuffer = new char[restrictions.Length];        // TODO: determine if there sensitive data here we need to clear?
            int     valueLength;

            char[]  restrictionString = restrictions.ToCharArray();

            ArrayList restrictionValues = new ArrayList();

            while (nextStartPosition < endPosition) {
                startPosition    = nextStartPosition;
                nextStartPosition = GetKeyValuePair(restrictionString, startPosition, out keyname, valueBuffer, out valueLength, out isempty);
                if (!ADP.IsEmpty(keyname)) {
                    if (KEY.File_Name == keyname) {
                        switch (checkForUdl) {
                        case UdlSupport.LoadFromFile:
                        case UdlSupport.UdlAsKeyword:
                            break;
                        case UdlSupport.ThrowIfFound:
                        default:
                            throw ADP.KeywordNotSupported(keyname);
                        }
                    }
                    string realkeyname = KeywordLookup(keyname); // MDAC 85144
                    if (ADP.IsEmpty(realkeyname)) {
                        throw ADP.KeywordNotSupported(keyname);
                    }
                    restrictionValues.Add(realkeyname);
                }
            }
            return RemoveDuplicates((string[])restrictionValues.ToArray(typeof(string)));
        }

        static internal string[] RemoveDuplicates(string[] restrictions) {
            int count = restrictions.Length;
            if (0 < count) {
                Array.Sort((String[]) restrictions, invariantComparer);

                for (int i = 1; i < restrictions.Length; ++i) {
                    string prev = restrictions[i-1];
                    if ((0 == prev.Length) || (prev == restrictions[i])) {
                        restrictions[i-1] = null;
                        count--;
                    }
                }
                if (0 == restrictions[restrictions.Length-1].Length) {
                    restrictions[restrictions.Length-1] = null;
                    count--;
                }
                if (count != restrictions.Length) {
                    string[] tmp = new String[count];
                    count = 0;
                    for (int i = 0; i < restrictions.Length; ++i) {
                        if (null != restrictions[i]) {
                            tmp[count++] = restrictions[i];
                        }
                    }
                    return tmp;
                }
            }
            return restrictions;
        }

#if MDAC80721
        static internal int AppendKeyValuePair(char[] builder, int index, string keyname, string value) { // MDAC 80721
            ADP.CheckArgumentNull(builder, "builder");
            ADP.CheckArgumentLength(keyname, "keyname");

            if ((0 < index) && (';' != builder[index-1])) {
                builder[index++] = ';';
            }

            char c;
            int length = keyname.Length;
            for (int i = 0; i < length; ++i) { // <key=word>=<value> -> <key==word>=<value>
                builder[index++] = c = keyname[i];
                if ('=' == c) { builder[index++] = c; }
            }
            builder[index++] = '=';

            if (null != value) { // else <keyword>=;
                bool doubleQuote = (-1 != value.IndexOf('\"'));
                bool singleQuote = (-1 != value.IndexOf('\''));
                bool semiColon   = (-1 != value.IndexOf(';'));
                length = value.Length;

                if (doubleQuote) {
                    if (singleQuote) { // <va'l"ue> -> <"va'l""ue">
                        builder[index++] = '\"';
                        for (int i = 0; i < length; ++i) {
                            builder[index++] = c = keyname[i];
                            if ('\"' == c) { builder[index++] = c; }
                        }
                        builder[index++] = '\"';
                    }
                    else { // <val"ue> -> <'val"ue'>
                        builder[index++] = '\'';
                        value.CopyTo(0, builder, index, value.Length);
                        index += value.Length;
                        builder[index++] = '\'';
                    }
                }
                else if (singleQuote || semiColon || (0 == value.Length) || ((0 < value.Length) && ('=' == value[0]))) {
                    // <val'ue> -> <"val'ue"> || <val;ue> -> <"val;ue"> || <> -> <""> || <=value> -> <"=value">
                    builder[index++] = '\"';
                    value.CopyTo(0, builder, index, value.Length);
                    index += value.Length;
                    builder[index++] = '\"';
                }
                else {
                    value.CopyTo(0, builder, index, value.Length);
                    index += value.Length;
                }
            }
            builder[index++] = ';';
            return index;
        }
#endif

        // doesn't valid connection string syntax
        // remove generic keyvalue pairs from a connection string
        internal string RemoveKeyValuePairs(char[] connectionString, string[] keyNames) {
            ADP.CheckArgumentNull(connectionString, "connectionString");
            ADP.CheckArgumentLength(keyNames, "keyNames");

            bool    isempty;
            int     startPosition;
            int     nextStartPosition = 0;
            int     endPosition = connectionString.Length;
            string  keyname;
            int     valueLength;

            char[]  actualConnectionString = null;
            int     outputPosition = 0;

            char[]  valueBuffer = new char[connectionString.Length];
#if USECRYPTO
            GCHandle valueHandle = GCHandle.Alloc(valueBuffer, GCHandleType.Pinned);
            try {
#endif
                while (nextStartPosition < endPosition) {
                    startPosition    = nextStartPosition;
                    nextStartPosition = GetKeyValuePair(connectionString, startPosition, out keyname, valueBuffer, out valueLength, out isempty);
                    if (!ADP.IsEmpty(keyname)) {
                        bool found = false;
#if DEBUG
                        if (TraceParseConnectionString.Enabled) {
                            DebugTraceKeyValuePair(keyname, System.Text.Encoding.Unicode.GetString(System.Text.Encoding.Unicode.GetBytes(valueBuffer, 0, valueLength)));
                        }
#endif
                        int length = keyNames.Length;
                        for (int i = 0; !found && i < length; i++) {
                            found = (keyNames[i] == keyname);
                        }
                        if(!found) {
                            if (null == actualConnectionString) {
                                actualConnectionString = new char[connectionString.Length];
                            }
                            int pairLength = nextStartPosition-startPosition;
#if MDAC80721
                            if (EmbeddedExtendedProperties && !isempty && (KEY.Extended_Properties == keyname)) { // MDAC 80721
                                char[] tmp = new char[valueLength];
#if USECRYPTO
                                GCHandle tmpHandle = GCHandle.Alloc(tmp, GCHandleType.Pinned);
#endif
                                try { // if 'Extended Properties' is an embedded connection string, remove the keynames from that embedded string
                                    ADP.CopyChars(valueBuffer, 0, tmp, 0, valueLength);
                                    string reducedExtendedProperties = RemoveKeyValuePairs(tmp, keyNames);
                                    outputPosition = AppendKeyValuePair(actualConnectionString, outputPosition, keyname, reducedExtendedProperties);
                                }
                                catch(Exception e) { // extended properties is not an embedded connection string
                                    ADP.TraceException(e);
                                    ADP.CopyChars(connectionString, startPosition, actualConnectionString, outputPosition, pairLength);
                                    outputPosition += pairLength;
                                }
#if USECRYPTO
                                finally {
                                    Array.Clear(tmp, 0, tmp.Length);
                                    if (tmpHandle.IsAllocated) {
                                        tmpHandle.Free();
                                    }
                                }
#endif
                            }
                            else { // copy normal keyvalue pairs to new connection string
#endif
                                ADP.CopyChars(connectionString, startPosition, actualConnectionString, outputPosition, pairLength);
                                outputPosition += pairLength;
#if MDAC80721
                            }
#endif
                        }
                        else {
#if USECRYPTO
                            Array.Clear(valueBuffer, 0, valueLength);
#endif
                            for (; nextStartPosition < connectionString.Length; ++nextStartPosition) {
                                char currentChar = connectionString[nextStartPosition];
                                if (Char.IsWhiteSpace(currentChar) || ';' == currentChar) {
                                    continue;
                                }
                                break;
                            }
                        }
                    }
                }
#if USECRYPTO
            }
            catch {
                Array.Clear(valueBuffer, 0, valueBuffer.Length);
                if (valueHandle.IsAllocated) {
                    valueHandle.Free();
                }
                throw;
            }
#endif
            return GetValue(actualConnectionString, 0, outputPosition, (null == actualConnectionString));
        }

        // remove Password and Pwd keyvalue pairs from a connection string
        internal string RemovePasswordPwd(char[] connectionString) {
            if (null != connectionString) {
                return RemoveKeyValuePairs(connectionString, new string[] { KEY.Password, SYNONYM.Pwd });
            }
            return null;
        }

        internal bool ShouldCache() {
            bool flag = true;
            if (_parsetable.ContainsKey(KEY.File_Name)) {
                string filename = (string)_parsetable[KEY.File_Name];
                Hashtable udlcache = UDL._Pool; // only caches full path filenames
                flag = (ADP.IsEmpty(filename) || ((null != udlcache) && udlcache.ContainsKey(filename))); // MDAC 83987, 83543
            }
            return flag;
        }

        internal bool ContainsPersistablePassword() {
            bool contains = (_parsetable.ContainsKey(KEY.Password) || _parsetable.ContainsKey(SYNONYM.Pwd));
            if (contains) {
                return CheckConvertToBoolean(KEY.Persist_Security_Info, false);
            }
            return true; // no password means persistable password so we don't have to munge
        }

        static private int TrimWhiteSpace(char[] valuebuf, int bufPosition) {
            // remove trailing whitespace from the buffer
            while ((0 < bufPosition) && Char.IsWhiteSpace(valuebuf[bufPosition-1])) {
                bufPosition--;
            }
            return bufPosition;
        }

        virtual protected string ValidateParse() {
            return EncryptedActualConnectionString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbdatapermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBDataPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

//#define DATAPERMIT

namespace System.Data.Common {

    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission"]/*' />
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, ControlEvidence=true, ControlPolicy=true)]
    [Serializable] abstract public class DBDataPermission :  CodeAccessPermission, IUnrestrictedPermission {

        private bool _isUnrestricted;// = false;
        private bool _allowBlankPassword;// = false;
        private NameValuePermission _keyvaluetree = NameValuePermission.Default;
        private /*DBConnectionString[]*/ArrayList _keyvalues; // = null;

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.DBDataPermission"]/*' />
        protected DBDataPermission() {
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.DBDataPermission1"]/*' />
        protected DBDataPermission(PermissionState state) {
            if (state == PermissionState.Unrestricted) {
                _isUnrestricted = true;
            }
            else if (state == PermissionState.None) {
                _isUnrestricted = false;
            }
            else {
                throw ADP.Argument("state");
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.DBDataPermission2"]/*' />
        public DBDataPermission(PermissionState state, bool allowBlankPassword) : this(state) { // MDAC 84281
            _allowBlankPassword = allowBlankPassword;
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.DBDataPermission3"]/*' />
        protected DBDataPermission(DBDataPermission permission) { // for Copy
            if (null == permission) {
                throw ADP.ArgumentNull("permissionAttribute");
            }
            CopyFrom(permission);
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.DBDataPermission4"]/*' />
        protected DBDataPermission(DBDataPermissionAttribute permissionAttribute) { // for CreatePermission
            if (null == permissionAttribute) {
                throw ADP.ArgumentNull("permissionAttribute");
            }
            _isUnrestricted = permissionAttribute.Unrestricted;
            if (!_isUnrestricted) {
                _allowBlankPassword = permissionAttribute.AllowBlankPassword;
                if (permissionAttribute.ShouldSerializeConnectionString() || permissionAttribute.ShouldSerializeKeyRestrictions()) { // MDAC 86773
                    Add(permissionAttribute.ConnectionString, permissionAttribute.KeyRestrictions, permissionAttribute.KeyRestrictionBehavior);
                }
            }
        }

        // how connectionString security is used
        // parsetable (all string) is shared with connection
        internal DBDataPermission(DBConnectionString constr) {
            if (null != constr) {
                _allowBlankPassword = constr.HasBlankPassword(); // MDAC 84563
                if (constr.GetType() != typeof(DBConnectionString)) {
                    // everything the DBDataPermission references must be Serializable
                    // DBConnectionString is Serializable, its derived classes may not be
                    constr = new DBConnectionString(constr, true); // MDAC 83180
                }
                AddEntry(constr);
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.AllowBlankPassword"]/*' />
        public bool AllowBlankPassword {
            get {
                return _allowBlankPassword;
            }
            set { // MDAC 61263
                _allowBlankPassword = value;
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.AddWithAllow"]/*' />
        virtual public void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior) {
            switch(behavior) {
            case KeyRestrictionBehavior.PreventUsage:
            case KeyRestrictionBehavior.AllowOnly:
                break;
            default:
                throw ADP.Argument("value");
            }
            DBConnectionString entry = new DBConnectionString(connectionString, restrictions, behavior, UdlSupport.UdlAsKeyword);
            AddPermissionEntry(entry);
        }

        internal void AddPermissionEntry(DBConnectionString entry) {
            if (null == entry) {
                throw ADP.ArgumentNull("entry");
            }
            if (!entry.ContainsPersistablePassword() || (entry.GetType() != typeof(DBConnectionString))) {
                entry = new DBConnectionString(entry, true);
            }
            AddEntry(entry);
            _isUnrestricted = false; // MDAC 84639
        }

        private void AddEntry(DBConnectionString entry) {
            Debug.Assert(entry.GetType() == typeof(DBConnectionString), "not a DBConnectionString");
            try {
                lock(this) { // single writer, multiple readers
                    if (null == _keyvaluetree) {
                        _keyvaluetree = new NameValuePermission();
                    }
                    if (null == _keyvalues) {
                        _keyvalues = new ArrayList();
                    }
                    NameValuePermission.AddEntry(_keyvaluetree, _keyvalues, entry);
#if DATAPERMIT
                        if (null != _keyvaluetree) {
                            _keyvaluetree.DebugDump("-");
                        }
#endif
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.Clear"]/*' />
        protected void Clear() { // MDAC 83105
            try {
                lock(this) {
                    _keyvaluetree = null;
                    _keyvalues = null;
                }
            }
            catch {
                throw;
            }
        }

        // IPermission interface methods
        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.Copy"]/*' />
        override public IPermission Copy() {
            DBDataPermission copy = CreateInstance();
            copy.CopyFrom(this);
            return copy;
        }

        private void CopyFrom(DBDataPermission permission) {
            _isUnrestricted = permission.IsUnrestricted();
            if (!_isUnrestricted) {
                _allowBlankPassword = permission.AllowBlankPassword;

                try {
                    lock(permission) { // single writer, multiple reader
                        if (null != permission._keyvalues) {
                            _keyvalues = (ArrayList) permission._keyvalues.Clone();

                            if (null != permission._keyvaluetree) {
                                _keyvaluetree = permission._keyvaluetree.Copy();
                            }
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.CreateInstance"]/*' />
        // [ Obsolete("use DBDataPermission(DBDataPermission) ctor") ]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name="FullTrust")] // MDAC 82936
        virtual protected DBDataPermission CreateInstance() {
            // derived class should override with a different implementation avoiding reflection to allow semi-trusted scenarios
            return (DBDataPermission) Activator.CreateInstance(this.GetType());
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.Intersect"]/*' />
        override public IPermission Intersect(IPermission target) { // used during Deny actions
            if (null == target) {
                return null;
            }
            if (target.GetType() != this.GetType()) {
                throw ADP.Argument("target");
            }
            if (IsUnrestricted()) { // MDAC 84803
                return Copy();
            }
            DBDataPermission newPermission = (DBDataPermission) target.Copy();
            if (!newPermission.IsUnrestricted()) {                
                newPermission._allowBlankPassword &= AllowBlankPassword;

                if ((null != _keyvalues) && (null != newPermission._keyvalues)) {
                    newPermission._keyvalues.Clear();

                    newPermission._keyvaluetree.Intersect(newPermission._keyvalues, _keyvaluetree);
                }
                else {
                    // either target.Add or this.Add have not been called
                    // return a non-null object so IsSubset calls will fail
                    newPermission._keyvalues = null;
                    newPermission._keyvaluetree = null;
                }
                if (newPermission.IsEmpty()) { // MDAC 86773
                    newPermission = null;
                }
            }
            return newPermission;
        }

        private bool IsEmpty() { // MDAC 84804
            bool flag = (!IsUnrestricted() && !AllowBlankPassword && ((null == _keyvalues) || (0 == _keyvalues.Count)));
            return flag;
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.IsSubsetOf"]/*' />
        override public bool IsSubsetOf(IPermission target) {
            if (null == target) {
                return IsEmpty();
            }
            if (target.GetType() != this.GetType()) {
                throw ADP.WrongType(this.GetType());
            }
            DBDataPermission superset = (target as DBDataPermission);
#if DATAPERMIT
            if (null != superset._keyvalues) {
                Debug.WriteLine("+ " + (superset._keyvalues[0] as DBConnectionString).ConnectionString);
            } else Debug.WriteLine("+ <>");
            if (null != _keyvalues) {
                Debug.WriteLine("- " + (_keyvalues[0] as DBConnectionString).ConnectionString);
            } else Debug.WriteLine("- <>");
#endif
            bool subset = superset.IsUnrestricted();
            if (!subset) {
                subset = (!IsUnrestricted()
                        && (!AllowBlankPassword || superset.AllowBlankPassword)
                        && ((null == _keyvalues) || (null != superset._keyvaluetree)));

                if (subset && (null != _keyvalues)) {
                    foreach(DBConnectionString kventry in _keyvalues) {
                        if(!superset._keyvaluetree.CheckValueForKeyPermit(kventry)) {
                            subset = false;
                            break;
                        }
                    }
                }
            }
            return subset;
        }

        // IUnrestrictedPermission interface methods
        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted() {
            return _isUnrestricted;
        }

        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.Union"]/*' />
        override public IPermission Union(IPermission target) {
            if (null == target) {
                return this.Copy();
            }
            if (target.GetType() != this.GetType()) {
                throw ADP.Argument("target");
            }
            if (IsUnrestricted()) { // MDAC 84803
                return this.Copy();
            }
            DBDataPermission newPermission = (DBDataPermission) target.Copy();
            if (!newPermission.IsUnrestricted()) {
                newPermission._allowBlankPassword |= AllowBlankPassword;

                if (null != _keyvalues) {
                    foreach(DBConnectionString entry in _keyvalues) {
                        newPermission.AddEntry(entry);
                    }
                }
            }
            return newPermission;
        }

        // <IPermission class="...Permission" version="1" AllowBlankPassword=false>
        //     <add ConnectionString="provider=x;data source=y;" KeyRestrictions="address=;server=" KeyRestrictionBehavior=PreventUsage/>
        // </IPermission>
        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.FromXml"]/*' />
        override public void FromXml(SecurityElement securityElement) {
            // code derived from CodeAccessPermission.ValidateElement
            if (null == securityElement) {
                throw ADP.ArgumentNull("securityElement");
            }
            string tag = securityElement.Tag;
            if (!tag.Equals(XmlStr._Permission) && !tag.Equals(XmlStr._IPermission)) {
                // TODO: do we need to check this?
                //String className = el.Attribute( XmlStr._class );
                //return className == null || !className.Equals( ip.GetType().AssemblyQualifiedName );
                throw ADP.NotAPermissionElement();
            }
            String version = securityElement.Attribute(XmlStr._Version);
            if ((null != version) && !version.Equals(XmlStr._VersionNumber)) {
                throw ADP.InvalidXMLBadVersion();
            }

            string unrestrictedValue = securityElement.Attribute(XmlStr._Unrestricted);
            _isUnrestricted = (null != unrestrictedValue) && Boolean.Parse(unrestrictedValue);

            Clear(); // MDAC 83105
            if (!_isUnrestricted) {
                string allowNull = securityElement.Attribute(XmlStr._AllowBlankPassword);
                _allowBlankPassword = (null != allowNull) && Boolean.Parse(allowNull);

                ArrayList children = securityElement.Children;
                if (null != children) {
                    foreach(SecurityElement keyElement in children) {
                        if (keyElement.Tag.Equals(XmlStr._add)) {
                            string constr = keyElement.Attribute(XmlStr._ConnectionString);
                            string restrt = keyElement.Attribute(XmlStr._KeyRestrictions);
                            string behavr = keyElement.Attribute(XmlStr._KeyRestrictionBehavior);

                            if (null == constr) { constr = ADP.StrEmpty; }
                            if (null == restrt) { restrt = ADP.StrEmpty; }

                            KeyRestrictionBehavior behavior = KeyRestrictionBehavior.AllowOnly;
                            if (null != behavr) {
                                behavior = (KeyRestrictionBehavior) Enum.Parse(typeof(KeyRestrictionBehavior), behavr, true);
                            }
                            Add(constr, restrt, behavior);
                        }
                    }
                }
            }
            else {
                _allowBlankPassword = false;
            }
        }

        // <IPermission class="...Permission" version="1" AllowBlankPassword=false>
        //     <add ConnectionString="provider=x;data source=y;" KeyRestrictions="address=;server=" KeyRestrictionBehavior=PreventUsage/>
        // </IPermission>
        /// <include file='doc\DBDataPermission.uex' path='docs/doc[@for="DBDataPermission.ToXml"]/*' />
        override public SecurityElement ToXml() {
            Type type = this.GetType();
            SecurityElement root = new SecurityElement(XmlStr._IPermission);
            root.AddAttribute(XmlStr._class, type.FullName + ", " + type.Module.Assembly.FullName.Replace('\"', '\''));
            root.AddAttribute(XmlStr._Version, XmlStr._VersionNumber);

            if (IsUnrestricted()) {
                root.AddAttribute(XmlStr._Unrestricted, XmlStr._true);
            }
            else {
                root.AddAttribute(XmlStr._AllowBlankPassword, _allowBlankPassword.ToString());

                if (null != _keyvalues) {
                    foreach(DBConnectionString value in _keyvalues) {
                        SecurityElement valueElement = new SecurityElement(XmlStr._add);
                        string tmp;

                        tmp = value.GetConnectionString(true);
                        if (!ADP.IsEmpty(tmp)) {
                            valueElement.AddAttribute(XmlStr._ConnectionString, tmp);
                        }
                        tmp = value.Restrictions;
                        if (null == tmp) { tmp = ADP.StrEmpty; }
                        valueElement.AddAttribute(XmlStr._KeyRestrictions, tmp);

                        tmp = value.Behavior.ToString("G");
                        valueElement.AddAttribute(XmlStr._KeyRestrictionBehavior, tmp);
                        root.AddChild(valueElement);
                    }
                }
            }
            return root;
        }

        private class XmlStr {
            internal const string _class = "class";
            internal const string _IPermission = "IPermission";
            internal const string _Permission = "Permission";
            internal const string _Unrestricted = "Unrestricted";
            internal const string _AllowBlankPassword = "AllowBlankPassword";
            internal const string _true = "true";
            internal const string _Version = "version";
            internal const string _VersionNumber = "1";

            internal const string _add = "add";

            internal const string _ConnectionString = "ConnectionString";
            internal const string _KeyRestrictions = "KeyRestrictions";
            internal const string _KeyRestrictionBehavior = "KeyRestrictionBehavior";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbschematable.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSchemaTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Data;
    using System.Diagnostics;

    sealed internal class DBSchemaTable {

        private enum ColumnEnum {
            ColumnName,
            ColumnOrdinal,
            ColumnSize,
            NumericPrecision,
            NumericScale,
            BaseServerName,
            BaseCatalogName,
            BaseColumnName,
            BaseSchemaName,
            BaseTableName,
            IsAutoIncrement,
            IsUnique,
            IsKey,
            IsRowVersion,
            DataType,
            AllowDBNull,
            ProviderType,
            IsAliased,
            IsExpression,
            IsIdentity,
            IsHidden,
            IsLong,
            IsReadOnly,
            SchemaMappingUnsortedIndex,
        }

        static readonly private string[] DBCOLUMN_NAME = new string[] {
            "ColumnName",
            "ColumnOrdinal",
            "ColumnSize",
            "NumericPrecision",
            "NumericScale",
            "BaseServerName",
            "BaseCatalogName",
            "BaseColumnName",
            "BaseSchemaName",
            "BaseTableName",
            "IsAutoIncrement",
            "IsUnique",
            "IsKey",
            "IsRowVersion",
            "DataType",
            "AllowDBNull",
            "ProviderType",
            "IsAliased",
            "IsExpression",
            "IsIdentity",
            "IsHidden",
            "IsLong",
            "IsReadOnly",
            "SchemaMapping Unsorted Index",
        };

        internal DataTable dataTable;
        private DataColumnCollection columns;
        private DataColumn[] columnCache = new DataColumn[DBCOLUMN_NAME.Length];

        internal DBSchemaTable(DataTable dataTable) {
            this.dataTable = dataTable;
            this.columns = dataTable.Columns;
        }

        internal DataColumn ColumnName      { get { return CachedDataColumn(ColumnEnum.ColumnName);}}
        internal DataColumn Ordinal         { get { return CachedDataColumn(ColumnEnum.ColumnOrdinal);}}
        internal DataColumn Size            { get { return CachedDataColumn(ColumnEnum.ColumnSize);}}
        internal DataColumn Precision       { get { return CachedDataColumn(ColumnEnum.NumericPrecision);}}
        internal DataColumn Scale           { get { return CachedDataColumn(ColumnEnum.NumericScale);}}
        internal DataColumn BaseServerName  { get { return CachedDataColumn(ColumnEnum.BaseServerName);}}
        internal DataColumn BaseColumnName  { get { return CachedDataColumn(ColumnEnum.BaseColumnName);}}
        internal DataColumn BaseTableName   { get { return CachedDataColumn(ColumnEnum.BaseTableName);}}
        internal DataColumn BaseCatalogName { get { return CachedDataColumn(ColumnEnum.BaseCatalogName);}}
        internal DataColumn BaseSchemaName  { get { return CachedDataColumn(ColumnEnum.BaseSchemaName);}}
        internal DataColumn IsAutoIncrement { get { return CachedDataColumn(ColumnEnum.IsAutoIncrement);}}
        internal DataColumn IsUnique        { get { return CachedDataColumn(ColumnEnum.IsUnique);}}
        internal DataColumn IsKey           { get { return CachedDataColumn(ColumnEnum.IsKey);}}
        internal DataColumn IsRowVersion    { get { return CachedDataColumn(ColumnEnum.IsRowVersion);}}

        internal DataColumn DataType        { get { return CachedDataColumn(ColumnEnum.DataType);}}
        internal DataColumn AllowDBNull     { get { return CachedDataColumn(ColumnEnum.AllowDBNull);}}
        internal DataColumn ProviderType    { get { return CachedDataColumn(ColumnEnum.ProviderType);}}
        internal DataColumn IsAliased       { get { return CachedDataColumn(ColumnEnum.IsAliased);}}
        internal DataColumn IsExpression    { get { return CachedDataColumn(ColumnEnum.IsExpression);}}
        internal DataColumn IsIdentity      { get { return CachedDataColumn(ColumnEnum.IsIdentity);}}
        internal DataColumn IsHidden        { get { return CachedDataColumn(ColumnEnum.IsHidden);}}
        internal DataColumn IsLong          { get { return CachedDataColumn(ColumnEnum.IsLong);}}
        internal DataColumn IsReadOnly      { get { return CachedDataColumn(ColumnEnum.IsReadOnly);}}

        internal DataColumn UnsortedIndex   { get { return CachedDataColumn(ColumnEnum.SchemaMappingUnsortedIndex);}}

        internal void AddRow(DBSchemaRow dataRow) {
            dataTable.Rows.Add(dataRow.DataRow);
            dataRow.DataRow.AcceptChanges();
        }

        private DataColumn CachedDataColumn(ColumnEnum column) {
            if (null == columnCache[(int) column]) {
                int index = columns.IndexOf(DBCOLUMN_NAME[(int) column]);
                if (-1 != index) {
                    columnCache[(int) column] = columns[index];
                }
            }
            return columnCache[(int) column];
        }

        internal DBSchemaRow NewRow() {
            return new DBSchemaRow(this, dataTable.NewRow());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\dbenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="dbenumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Data;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\dbenumerator.uex' path='docs/doc[@for="DbEnumerator"]/*' />
    public class DbEnumerator : IEnumerator {
        internal IDataReader _reader;
        internal IDataRecord _current;
        internal SchemaInfo[] _schemaInfo; // shared schema info among all the data records
        internal PropertyDescriptorCollection _descriptors; // cached property descriptors
        private FieldNameLookup _fieldNameLookup; // MDAC 69015
        private bool closeReader;

        // users must get enumerators off of the datareader interfaces
        /// <include file='doc\dbenumerator.uex' path='docs/doc[@for="DbEnumerator.DbEnumerator"]/*' />
        public DbEnumerator(IDataReader reader) {
            if (null == reader) {
                throw ADP.ArgumentNull("reader");
            }
            _reader = reader;
        }

        /// <include file='doc\dbenumerator.uex' path='docs/doc[@for="DbEnumerator.DbEnumerator1"]/*' />
        public DbEnumerator(IDataReader reader, bool closeReader) { // MDAC 68670
            if (null == reader) {
                throw ADP.ArgumentNull("reader");
            }
            _reader = reader;
            this.closeReader = closeReader;
        }


        /// <include file='doc\dbenumerator.uex' path='docs/doc[@for="DbEnumerator.Current"]/*' />
        public object Current {
            get {
                return _current;
            }                
        }

/*
        virtual internal IDataRecord NewRecord(SchemaInfo[] si, object[] values, PropertyDescriptorCollection descriptors) {
            return new DbDataRecord(si, values, descriptors);
        }

        virtual internal void GetValues(object[] values) {
            _reader.GetValues(values);
        }
*/        
        
        /// <include file='doc\dbenumerator.uex' path='docs/doc[@for="DbEnumerator.MoveNext"]/*' />
        public bool MoveNext() {
        
            if (null == _schemaInfo) {
                  BuildSchemaInfo();
            }
            
            Debug.Assert(null != _schemaInfo && null != _descriptors, "unable to build schema information!");
            _current = null;

            if (_reader.Read()) {
                // setup our current record
                object[] values = new object[_schemaInfo.Length];
                _reader.GetValues(values); // this.GetValues()
                _current = new DbDataRecord(_schemaInfo, values, _descriptors, _fieldNameLookup); // this.NewRecord()
                return true;
            }
            if (closeReader) {
                _reader.Close();
            }
            return false;
        }

        /// <include file='doc\dbenumerator.uex' path='docs/doc[@for="DbEnumerator.Reset"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Never) ] // MDAC 69508
        public void Reset() {
            throw ADP.NotSupported();
        }

        private void BuildSchemaInfo() {
            int count = _reader.FieldCount;
            string[] fieldnames = new string[count];
            for (int i = 0; i < count; ++i) {
                fieldnames[i] = _reader.GetName(i);
            }
            ADP.BuildSchemaTableInfoTableNames(fieldnames); // MDAC 71401

            SchemaInfo[] si = new SchemaInfo[count];
            PropertyDescriptor[] props = new PropertyDescriptor[_reader.FieldCount];
            for (int i = 0; i < si.Length; i++) {
                SchemaInfo s = new SchemaInfo();
                s.name = _reader.GetName(i);
                s.type = _reader.GetFieldType(i);
                s.typeName = _reader.GetDataTypeName(i);
                props[i] = new DbColumnDescriptor(i, fieldnames[i], s.type);
                si[i] = s;
            }

            _schemaInfo = si;
            _fieldNameLookup = new FieldNameLookup(_reader, -1); // MDAC 71470
            _descriptors = new PropertyDescriptorCollection(props);
        }

        private class DbColumnDescriptor : PropertyDescriptor {
            int _ordinal;
            Type _type;
        
            internal DbColumnDescriptor(int ordinal, string name, Type type) 
                : base(name, null) {
                _ordinal = ordinal;
                _type = type;
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.ComponentType"]/*' />
            public override Type ComponentType {
                get {
                    return typeof(IDataRecord);
                }
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.IsReadOnly"]/*' />
            public override bool IsReadOnly {
                get {
                    return true;
                }
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.PropertyType"]/*' />
            public override Type PropertyType {
                get {
                    return _type;
                }
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.CanResetValue"]/*' />
            public override bool CanResetValue(object component) {
                return false;
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.GetValue"]/*' />
            public override object GetValue(object component) {
                return ((IDataRecord)component)[_ordinal];
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.ResetValue"]/*' />
            public override void ResetValue(object component) {
                throw ADP.NotSupported();
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.SetValue"]/*' />
            public override void SetValue(object component, object value) {
                throw ADP.NotSupported();
            }

            /// <include file='doc\dbcolumndescriptor.uex' path='docs/doc[@for="DbColumnDescriptor.ShouldSerializeValue"]/*' />
            public override bool ShouldSerializeValue(object component) {
                return false;
            }
        }   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\decimalstorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DecimalStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class DecimalStorage : DataStorage {

        private static readonly Decimal defaultValue = Decimal.Zero;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Decimal[] values;

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.DecimalStorage"]/*' />
        /// <internalonly/>
        public DecimalStorage()
        : base(typeof(Decimal)) {
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Decimal sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Decimal meanSum = (Decimal)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Decimal)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Decimal mean;
                            checked {mean = (meanSum /(Decimal) meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        Decimal min = Decimal.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Decimal max = Decimal.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Decimal));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Decimal valueNo1 = values[recordNo1];
            Decimal valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Decimal valueNo1 = values[recordNo];
            Decimal valueNo2 = Convert.ToDecimal(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Decimal value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = DecimalStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToDecimal(value);
            }
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            Decimal[] newValues = new Decimal[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToDecimal(s);
        }

        /// <include file='doc\DecimalStorage.uex' path='docs/doc[@for="DecimalStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Decimal)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\int16storage.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int16Storage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class Int16Storage : DataStorage {

        private const Int16 defaultValue = 0;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Int16[] values;

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.Int16Storage"]/*' />
        /// <internalonly/>
        public Int16Storage()
        : base(typeof(Int16)) {
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Int64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Int64 meanSum = (Int64)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Int64)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Int16 mean;
                            checked {mean = (Int16)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;


                    case AggregateType.Min:
                        Int16 min = Int16.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Int16 max = Int16.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        count = 0;
                        for (int i = 0; i < records.Length; i++) {
                            if (!IsNull(records[i]))
                                count++;
                        }
                        return count;
                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Int16));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Int16 valueNo1 = values[recordNo1];
            Int16 valueNo2 = values[recordNo2];

            if (valueNo1 == Int16Storage.defaultValue && valueNo2 == Int16Storage.defaultValue) 
                return CompareBits(recordNo1, recordNo2);
            if (valueNo1 == Int16Storage.defaultValue && base.IsNull(recordNo1))
                return -1;
            if (valueNo2 == Int16Storage.defaultValue && base.IsNull(recordNo2))
                return 1;
                
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            Int16 valueNo1 = values[recordNo];

            if (valueNo1 == Int16Storage.defaultValue || value == null || value == DBNull.Value) {
                Object obj;
                if (valueNo1 == defaultValue)
                    obj = GetBits(recordNo);
                else
                    obj = valueNo1;
                    
                if (obj == value)
                    return 0;
                if (obj == null)
                    return -1;
                if (value == null)
                    return 1;
                if (obj == DBNull.Value)
                    return -1;
                if (value == DBNull.Value)
                    return 1;
            }

            Int16 valueNo2 = Convert.ToInt16(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Int16 value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.IsNull"]/*' />
        /// <internalonly/>
        override public bool IsNull(int record) {
            Int16 value = values[record];
            if (value != defaultValue) {
                return false;
            }
            return base.IsNull(record);
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (value == null || value == DBNull.Value) {
                SetBits(record, value);
                values[record] = Int16Storage.defaultValue;
            }
            else {
                Int16 val = Convert.ToInt16(value);
                values[record] = val;
                if (val == Int16Storage.defaultValue)
                    SetBits(record, value);
            }
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            Int16[] newValues = new Int16[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToInt16(s);
        }

        /// <include file='doc\Int16Storage.uex' path='docs/doc[@for="Int16Storage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {            
            return XmlConvert.ToString((Int16) value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\fieldnamelookup.cs ===
//------------------------------------------------------------------------------
// <copyright file="FieldNameLookup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.Text;

    sealed internal class FieldNameLookup { // MDAC 69015, 71470
        
        // hashtable stores the index into the _fieldNames, match via case-sensitive
        private Hashtable _fieldNameLookup;

        // original names for linear searches when exact matches fail
        private string[] _fieldNames;

        // if _defaultLCID is -1 then _compareInfo is initialized with CurrentCulture CompareInfo
        // otherwise it is specified by the server? for the correct compare info
        private CompareInfo _compareInfo;
        private int _defaultLCID;

        /*internal FieldNameLookup(string[] fieldNames, int defaultLCID) {
            _fieldNames = fieldNames;
            _defaultLCID = defaultLCID;
        }*/

        internal FieldNameLookup(IDataReader reader, int defaultLCID) {

            int length = reader.FieldCount;
            string[] fieldNames = new string[length];
            for (int i = 0; i < length; ++i) {
                fieldNames[i] = reader.GetName(i);
                Debug.Assert(null != fieldNames[i], "MDAC 66681");
            }
            _fieldNames = fieldNames;
            _defaultLCID = defaultLCID;
        }

        /*internal string this[int ordinal] {
            get {
                return _fieldNames[ordinal];
            }
        }*/

        internal int GetOrdinal(string fieldName) {
            if (null == fieldName) {
                throw ADP.ArgumentNull("fieldName");
            }
            int index = IndexOf(fieldName);
            if (-1 == index) {
                throw ADP.IndexOutOfRange(fieldName);
            }
            return index;
        }

        internal int IndexOfName(string fieldName) {
            if (null == _fieldNameLookup) {
                GenerateLookup();
            }
            // via case sensitive search, first match with lowest ordinal matches
            if (_fieldNameLookup.Contains(fieldName)) {
                return (int)_fieldNameLookup[fieldName];
            }
            return -1;
        }

        internal int IndexOf(string fieldName) {
            if (null == _fieldNameLookup) {
                GenerateLookup();
            }
            int index;

            // via case sensitive search, first match with lowest ordinal matches
            if (_fieldNameLookup.Contains(fieldName)) {
                index = (int)_fieldNameLookup[fieldName];
            }
            else {
                // via case insensitive search, first match with lowest ordinal matches
                index = LinearIndexOf(fieldName, CompareOptions.IgnoreCase);
                if (-1 == index) {
                    // do the slow search now (kana, width insensitive comparison)
                    index = LinearIndexOf(fieldName, ADP.compareOptions);
                }
            }
            return index;
        }

        private int LinearIndexOf(string fieldName, CompareOptions compareOptions) {
            CompareInfo compareInfo = _compareInfo;
            if (null == compareInfo) {
                if (-1 != _defaultLCID) {
                    compareInfo = CompareInfo.GetCompareInfo(_defaultLCID);
                }
                if (null == compareInfo) {
                    compareInfo = CultureInfo.CurrentCulture.CompareInfo;
                }
                _compareInfo = compareInfo;
            }
            int length = _fieldNames.Length;
            for (int i = 0; i < length; ++i) {
                if (0 == compareInfo.Compare(fieldName, _fieldNames[i], compareOptions)) {
                    _fieldNameLookup[fieldName] = i; // add an exact match for the future
                    return i;
                }
            }
            return -1;
        }

        // RTM common code for generating Hashtable from array of column names
        private void GenerateLookup() {
            int length = _fieldNames.Length;
            Hashtable hash = new Hashtable(length);

            // via case sensitive search, first match with lowest ordinal matches
            for (int i = length-1; 0 <= i; --i) {
                string fieldName = _fieldNames[i];
                hash[fieldName] = i;
            }
            _fieldNameLookup = hash;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\doublestorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DoubleStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class DoubleStorage : DataStorage {

        private const Double defaultValue = 0.0d;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Double[] values;

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.DoubleStorage"]/*' />
        /// <internalonly/>
        public DoubleStorage()
        : base(typeof(Double)) {
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Double sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Double meanSum = (Double)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Double)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Double mean;
                            checked {mean = (Double)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        Double min = Double.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Double max = Double.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Double));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Double valueNo1 = values[recordNo1];
            Double valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Double valueNo1 = values[recordNo];
            Double valueNo2 = Convert.ToDouble(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Double value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = DoubleStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToDouble(value);
            }
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            Double[] newValues = new Double[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToDouble(s);
        }

        /// <include file='doc\DoubleStorage.uex' path='docs/doc[@for="DoubleStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {            
            return XmlConvert.ToString((Double) value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\externdll.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExternDll.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {

    internal class ExternDll {

        public const string DbNetLib = "dbnetlib.dll";
        public const string Kernel32 = "kernel32.dll";
        public const string Odbc32 = "odbc32.dll";
        public const string Oleaut32 = "oleaut32.dll";
        public const string Ole32 = "ole32.dll";
        public const string Advapi32 = "advapi32.dll";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\int32storage.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int32Storage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class Int32Storage : DataStorage {

        private const Int32 defaultValue = 0; // Convert.ToInt32(null)
        static private readonly Object defaultValueAsObject = defaultValue;

        private Int32[] values;

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.Int32Storage"]/*' />
        /// <internalonly/>
        public Int32Storage()
        : base(typeof(Int32)) {
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.DefaultValue"]/*' />
        /// <internalonly/>
        override public Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Int64 sum = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Int64 meanSum = 0;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Int64)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Int32 mean;
                            checked {mean = (Int32)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = 0;
                        double prec = 0;
                        double dsum = 0;
                        double sqrsum = 0;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        Int32 min = Int32.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Int32 max = Int32.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        count = 0;
                        for (int i = 0; i < records.Length; i++) {
                            if (!IsNull(records[i]))
                                count++;
                        }
                        return count;
                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Int32));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Int32 valueNo1 = values[recordNo1];
            Int32 valueNo2 = values[recordNo2];

            if (valueNo1 == Int32Storage.defaultValue && valueNo2 == Int32Storage.defaultValue) 
                return CompareBits(recordNo1, recordNo2);
            if (valueNo1 == Int32Storage.defaultValue && base.IsNull(recordNo1))
                return -1;
            if (valueNo2 == Int32Storage.defaultValue && base.IsNull(recordNo2))
                return 1;
            
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            Int32 valueNo1 = values[recordNo];

            if (valueNo1 == Int32Storage.defaultValue || value == null || value == DBNull.Value) {
                Object obj;
                if (valueNo1 == defaultValue)
                    obj = GetBits(recordNo);
                else
                    obj = valueNo1;
                    
                if (obj == value)
                    return 0;
                if (obj == null)
                    return -1;
                if (value == null)
                    return 1;
                if (obj == DBNull.Value)
                    return -1;
                if (value == DBNull.Value)
                    return 1;
            }

            Int32 valueNo2 = Convert.ToInt32(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Int32 value = values[record];
            if (value != Int32Storage.defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.IsNull"]/*' />
        /// <internalonly/>
        override public bool IsNull(int record) {
            Int32 value = values[record];
            if (value != Int32Storage.defaultValue) {
                return false;
            }
            return base.IsNull(record);
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (value == null || value == DBNull.Value) {
                SetBits(record, value);
                values[record] = Int32Storage.defaultValue;
            }
            else {
                Int32 val = Convert.ToInt32(value);
                values[record] = val;
                if (val == Int32Storage.defaultValue)
                    SetBits(record, value);
            }
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            Int32[] newValues = new Int32[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToInt32(s);
        }

        /// <include file='doc\Int32Storage.uex' path='docs/doc[@for="Int32Storage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Int32)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;

namespace System.Data.Common {

    sealed internal class NativeMethods {

        [
        Guid("0C733A5E-2A1C-11CE-ADE5-00AA0044773D"),
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
        ComImport()
        ]
        internal interface ITransactionJoin {
            [PreserveSig]
            int GetOptionsObject(/*deleted parameter signature*/);

            void JoinTransaction(
                [In, MarshalAs(UnmanagedType.Interface)] object punkTransactionCoord,
                [In] Int32 isoLevel,
                [In] Int32 isoFlags,
                [In] IntPtr pOtherOptions);
        }

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        static internal extern int GetCurrentProcessId();

        // $UNDONE: whats the impact of ExactSpelling, SqlConnection used false, SqlDebugging used true
        //[DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        //static internal extern IntPtr MapViewOfFile(IntPtr hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, int dwNumberOfBytesToMap);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        static internal extern IntPtr MapViewOfFile(IntPtr hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, int dwNumberOfBytesToMap);

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        static internal extern IntPtr OpenFileMappingA(int dwDesiredAccess, bool bInheritHandle, [MarshalAs(UnmanagedType.LPStr)] string lpName);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        static internal extern IntPtr CreateFileMappingA(IntPtr hFile, IntPtr pAttr, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, [MarshalAs(UnmanagedType.LPStr)] string lpName);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        static internal extern bool UnmapViewOfFile(IntPtr lpBaseAddress);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool CloseHandle(IntPtr handle);
        
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=false)]
        static internal extern uint GetLastError();

         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool  AllocateAndInitializeSid(
                      IntPtr pIdentifierAuthority, // authority
                      byte nSubAuthorityCount,                        // count of subauthorities
                      int dwSubAuthority0,                          // subauthority 0
                      int dwSubAuthority1,                          // subauthority 1
                      int dwSubAuthority2,                          // subauthority 2
                      int dwSubAuthority3,                          // subauthority 3
                      int dwSubAuthority4,                          // subauthority 4
                      int dwSubAuthority5,                          // subauthority 5
                      int dwSubAuthority6,                          // subauthority 6
                      int dwSubAuthority7,                          // subauthority 7
                      ref IntPtr  pSid );                                   // SID

                      
         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern int GetLengthSid(
                    IntPtr pSid);   // SID to query

         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool InitializeAcl(
                    IntPtr pAcl,            // ACL
                    int nAclLength,     // size of ACL
                    int dwAclRevision );  // revision level of ACL

         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool AddAccessDeniedAce(
                    IntPtr pAcl,            // access control list
                    int dwAceRevision,  // ACL revision level
                    int AccessMask,     // access mask
                    IntPtr pSid  );           // security identifier

         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool AddAccessAllowedAce(
                    IntPtr pAcl,            // access control list
                    int dwAceRevision,  // ACL revision level
                    uint AccessMask,     // access mask
                    IntPtr pSid  );           // security identifier
                    
         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool InitializeSecurityDescriptor(
                    IntPtr pSecurityDescriptor, // SD
                    int dwRevision );                         // revision level
         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        static internal extern bool SetSecurityDescriptorDacl(
                    IntPtr pSecurityDescriptor, // SD
                    bool bDaclPresent,                        // DACL presence
                    IntPtr pDacl,                               // DACL
                    bool bDaclDefaulted);                       // default DACL

         [DllImport(ExternDll.Advapi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
         static internal extern void FreeSid(
                    IntPtr pSid);   // SID to free


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\namevaluepair.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValuePair.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    [Serializable] // MDAC 83147
    sealed internal class NameValuePair {
        readonly private string _name;
        readonly private string _value;
        private NameValuePair _next;

        public NameValuePair(string name, string value) {
            if (ADP.IsEmpty(name)) {
                throw ADP.Argument("name");
            }
            _name = name;
            _value = value;
        }

        public NameValuePair(string name, string value, NameValuePair next) : this(name, value) {
            _next = next;
        }

        public string Name {
            get {
                return _name;
            }
        }
        public string Value {
            get {
                return _value;
            }
        }
        public NameValuePair Next {
            get {
                return _next;
            }
            set {
                if (null == _next) { _next = value; }
                else { throw new InvalidOperationException(); }
            }
        }

        public NameValuePair Clone() {
            return new NameValuePair(_name, _value);
        }

        /*public NameValuePair Find(string name) {
            for(NameValuePair pair = this; pair != null; pair = pair.Next) {
                if (pair._name == name) {
                    return pair;
                }
            }
            return null;
        }*/

        /*override public string ToString() {
            return ADP.StrEmpty;
        }*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\int64storage.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int64Storage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class Int64Storage : DataStorage {

        private const Int64 defaultValue = 0;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Int64[] values;

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.Int64Storage"]/*' />
        /// <internalonly/>
        public Int64Storage()
        : base(typeof(Int64)) {
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Int64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Decimal meanSum = (Decimal)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Decimal)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Int64 mean;
                            checked {mean = (Int64)(Decimal)(meanSum / (Decimal) meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        Int64 min = Int64.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Int64 max = Int64.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Int64));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Int64 valueNo1 = values[recordNo1];
            Int64 valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Int64 valueNo1 = values[recordNo];
            Int64 valueNo2 = Convert.ToInt64(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Int64 value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = Int64Storage.defaultValue;
            }
            else {
                values[record] = Convert.ToInt64(value);
            }
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            Int64[] newValues = new Int64[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToInt64(s);
        }

        /// <include file='doc\Int64Storage.uex' path='docs/doc[@for="Int64Storage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Int64)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\interlockedstack.cs ===
//------------------------------------------------------------------------------
// <copyright file="PoolStacks.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Threading;

    internal class InterlockedStack {
        private readonly Stack myStack = new Stack();
        
        internal InterlockedStack() {
        }
        
        internal void Push(Object o) {
            Debug.Assert(o != null, "Trying to push null on stack!");
        
            lock(myStack.SyncRoot) {
                myStack.Push(o);
            }
        }
        
        internal Object Pop() {
            lock(myStack.SyncRoot) {
                if (myStack.Count > 0) {
                    return myStack.Pop();
                }
                else {
                    return null;
                }
            }   
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\rowupdatedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="RowUpdatedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Data;

    /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs"]/*' />
    abstract public class RowUpdatedEventArgs : System.EventArgs {
        private IDbCommand command;
        private StatementType statementType;
        private DataTableMapping tableMapping;
        private Exception errors;

        private DataRow dataRow;
        private UpdateStatus status; // UpdateStatus.Continue; /*0*/
        internal int recordsAffected;

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.RowUpdatedEventArgs"]/*' />
        protected RowUpdatedEventArgs(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            this.dataRow = dataRow;
            this.command = command;
            this.statementType = statementType;
            this.tableMapping = tableMapping;
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.Command"]/*' />
        public IDbCommand Command {
            get {
                return command;
            }
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.StatementType"]/*' />
        public StatementType StatementType {
            get {
                return this.statementType;
            }
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.Errors"]/*' />
        public Exception Errors {
            get {
                return errors;
            }
            set {
                errors = value;
            }
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.RecordsAffected"]/*' />
        public int RecordsAffected {
            get {
                return this.recordsAffected;
            }
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.Row"]/*' />
        public DataRow Row {
            get {
                return this.dataRow;
            }
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.Status"]/*' />
        public UpdateStatus Status {
            get {
                return status;
            }
            set {
                switch(value) {
                case UpdateStatus.Continue:
                case UpdateStatus.ErrorsOccurred:
                case UpdateStatus.SkipCurrentRow:
                case UpdateStatus.SkipAllRemainingRows:
                    this.status = value;
                    break;
                default:
                    throw ADP.InvalidUpdateStatus((int) value);
                }
            }
        }

        /// <include file='doc\RowUpdatedEvent.uex' path='docs/doc[@for="RowUpdatedEventArgs.TableMapping"]/*' />
        public DataTableMapping TableMapping {
            get {
                return this.tableMapping;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\namevaluepermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValuePermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;

    [Serializable] // MDAC 83147
    sealed internal class NameValuePermission : IComparable {
        // reused as both key and value nodes
        // key nodes link to value nodes
        // value nodes link to key nodes
        private string _value;

        // value node with (null != _restrictions) are allowed to match connection strings
        private DBConnectionString _entry;

        private NameValuePermission[] _tree; // with branches

        static internal readonly NameValuePermission Default = null;// = new NameValuePermission(String.Empty, new string[] { "File Name" }, KeyRestrictionBehavior.AllowOnly);

        internal NameValuePermission() { // root node
        }

        private NameValuePermission(string keyword) {
            _value = keyword;
       }

        private NameValuePermission(string value, DBConnectionString entry) {
            _value = value;
            _entry = entry;
        }

        private NameValuePermission(NameValuePermission permit) { // deep-copy
            _value = permit._value;
            _entry = permit._entry;
            _tree = permit._tree;
            if (null != _tree) {
                NameValuePermission[] tree = (_tree.Clone() as NameValuePermission[]);
                int length = tree.Length;
                for(int i = 0; i < length; ++i) {
                    tree[i] = tree[i].Copy(); // deep copy
                }
                _tree = tree;
            }
        }

        int IComparable.CompareTo(object a) {
            return InvariantComparer.Default.Compare(_value, (a as NameValuePermission)._value);
        }

        static internal void AddEntry(NameValuePermission kvtree, ArrayList entries, DBConnectionString entry) {
            Debug.Assert(null != entry, "null DBConnectionString");

            if (null != entry.KeyChain) {
                for(NameValuePair keychain = entry.KeyChain; null != keychain; keychain = keychain.Next) {
                    NameValuePermission kv;

                    kv = kvtree.CheckKeyForValue(keychain.Name);
                    if (null == kv) {
                        kv = new NameValuePermission(keychain.Name);
                        kvtree.Add(kv); // add directly into live tree
                    }
                    kvtree = kv;

                    kv = kvtree.CheckKeyForValue(keychain.Value);
                    if (null == kv) {
                        DBConnectionString insertValue = ((null != keychain.Next) ? null : entry);
                        kv = new NameValuePermission(keychain.Value, insertValue);
                        kvtree.Add(kv); // add directly into live tree
                        if (null != insertValue) {
                            entries.Add(insertValue);
                        }
                    }
                    else if (null == keychain.Next) { // shorter chain potential
                        if (null != kv._entry) {
                            entries.Remove(kv._entry);
                            kv._entry = kv._entry.MergeIntersect(entry); // union new restrictions into existing tree
                        }
                        else {
                            kv._entry = entry;
                        }
                        entries.Add(kv._entry);
                    }
                    kvtree = kv;
                }
            }
            else { // global restrictions, MDAC 84443
                DBConnectionString kentry = kvtree._entry;
                if (null != kentry) {
                    entries.Remove(kentry);
                    kvtree._entry = kentry.MergeIntersect(entry);
                }
                else {
                    kvtree._entry = entry;
                }
                entries.Add(kvtree._entry);
            }
        }

        internal void Intersect(ArrayList entries, NameValuePermission target) {
            if (null == target) {
                _tree = null;
                _entry = null;
            }
            else {
                if (null != _entry) {
                    entries.Remove(_entry);
                    _entry = _entry.MergeIntersect(target._entry);
                    entries.Add(_entry);
                }
                else if (null != target._entry) {
                    _entry = target._entry.MergeIntersect(null);
                    entries.Add(_entry);
                }

                if (null != _tree) {
                    int count = _tree.Length;
                    for(int i = 0; i < _tree.Length; ++i) {
                        NameValuePermission kvtree = target.CheckKeyForValue(_tree[i]._value);
                        if (null != kvtree) { // does target tree contain our value
                            _tree[i].Intersect(entries, kvtree);
                        }
                        else {
                            _tree[i] = null;
                            --count;
                        }
                    }
                    if (0 == count) {
                        _tree = null;
                    }
                    else if (count < _tree.Length) {
                        NameValuePermission[] kvtree = new NameValuePermission[count];
                        for (int i = 0, j = 0; i < _tree.Length; ++i) {
                            if(null != _tree[i]) {
                                kvtree[j++] = _tree[i];
                            }
                        }
                    }
                }
            }
        }

        private void Add(NameValuePermission permit) {
            NameValuePermission[] tree = _tree;
            int length = ((null != tree) ? tree.Length : 0);
            NameValuePermission[] newtree = new NameValuePermission[1+length];
            for(int i = 0; i < length; ++i) {
                newtree[i] = tree[i];
            }
            newtree[length] = permit;
            Array.Sort(newtree);
            _tree = newtree;
        }

#if DATAPERMIT
        internal void DebugDump(string depth) {
            Debug.WriteLine(depth + "<" + _value + ">");
            if (null != _tree) {
                for(int i = 0; i < _tree.Length; ++i) {
                    _tree[i].DebugDump(depth+"-");
                }
            }
        }
#endif

        internal bool CheckValueForKeyPermit(DBConnectionString parsetable) {
            if (null == parsetable) {
                return false;
            }

            bool hasMatch = false;
            NameValuePermission[] keytree = _tree; // _tree won't mutate but Add will replace it
            if (null != keytree) {
                hasMatch = parsetable.IsEmpty(); // MDAC 86773

                // which key do we follow the key-value chain on
                for (int i = 0; i < keytree.Length; ++i) {
                    NameValuePermission permitKey = keytree[i];
                    string keyword = permitKey._value;
#if DATAPERMIT
                    Debug.WriteLine("DBDataPermission keyword: <" + keyword + ">");
#endif
#if DEBUG
                    Debug.Assert(null == permitKey._entry, "key member has no restrictions");
#endif
                    if (parsetable.Contains(keyword)) {
                        string valueInQuestion = (string) parsetable[keyword];

                        // keyword is restricted to certain values
                        NameValuePermission permitValue = permitKey.CheckKeyForValue(valueInQuestion);
                        if (null != permitValue) {
                            //value does match - continue the chain down that branch
                            if (permitValue.CheckValueForKeyPermit(parsetable)) {
                                hasMatch = true;
                            }
                            else {
#if DATAPERMIT
                                Debug.WriteLine("DBDataPermission failed branch checking");
#endif
                                return false;
                            }
                        }
                        else { // value doesn't match to expected values - fail here
#if DATAPERMIT
                            Debug.WriteLine("DBDataPermission failed to match expected value");
#endif
                            return false;
                        }
                    }
                    // else try next keyword
                }
                // partial chain match, either leaf-node by shorter chain or fail mid-chain if (null == _restrictions)
            }
#if DATAPERMIT
            else {
                Debug.WriteLine("leaf node");
            }
#endif
            DBConnectionString entry = _entry;
            if (null != entry) {
                return entry.IsSubsetOf(parsetable);
            }
#if DATAPERMIT
            Debug.WriteLine("DBDataPermission failed on non-terminal node");
#endif
            return hasMatch; // mid-chain failure
        }

        private NameValuePermission CheckKeyForValue(string keyInQuestion) {
            NameValuePermission[] valuetree = _tree; // _tree won't mutate but Add will replace it
            if (null != valuetree) {
                for (int i = 0; i < valuetree.Length; ++i) {
                    NameValuePermission permitValue = valuetree[i];
#if DATAPERMIT
                    Debug.WriteLine("DBDataPermission value: <" + permitValue._value  + ">");
#endif
                    if (0 == ADP.DstCompare(keyInQuestion, permitValue._value)) {
                        return permitValue;
                    }
                }
            }            
            return null;
        }

        internal NameValuePermission Copy() {
            return new NameValuePermission(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\objectstorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Reflection;

    /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage"]/*' />
    /// <internalonly/>
    [Serializable]
        internal class ObjectStorage : DataStorage {

        static private readonly Object defaultValue = null;

        private enum Families { DATETIME, NUMBER, STRING, BOOLEAN };

        private object[] values;

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.ObjectStorage"]/*' />
        /// <internalonly/>
        public ObjectStorage(Type type) : base(type) {
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValue;
            }
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            int bitCheck = CompareBits(recordNo1, recordNo2);
            if (0 != bitCheck)
                return bitCheck;

            object valueNo1 = values[recordNo1];
            object valueNo2 = values[recordNo2];

            if (valueNo1 == valueNo2) {
                return 0;
            }
            if (valueNo1 is IComparable) {
                try{
                    return ((IComparable) valueNo1).CompareTo(valueNo2);
                } catch (Exception) {
                }
            }

            return CompareWithFamilies(valueNo1, valueNo2);
        }

        /// <include file='doc\DataStorage.uex' path='docs/doc[@for="DataStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo1, Object value) {
            object valueNo1 = Get(recordNo1);

            if (valueNo1 is IComparable) {
                if (value.GetType() == valueNo1.GetType())
                    return((IComparable) valueNo1).CompareTo(value);
            }

            if (valueNo1 == value)
                return 0;

            if (valueNo1 == null)
                return -1;

            if (value == null)
                return 1;

            if (valueNo1 == DBNull.Value)
                return -1;

            if (value == DBNull.Value)
                return 1;
                
            return CompareWithFamilies(valueNo1, value);
        }

        private int CompareWithFamilies(Object valueNo1, Object valueNo2) {
            Families Family1 = GetFamily(valueNo1.GetType());
            Families Family2 = GetFamily(valueNo2.GetType());
            if (Family1 < Family2)
                return -1;
            else
                if (Family1 > Family2)
                    return 1;
            else {
                switch (Family1) {
                    case Families.BOOLEAN : 
                        valueNo1 = Convert.ToBoolean(valueNo1);
                        valueNo2 = Convert.ToBoolean(valueNo2);
                        break;
                    case Families.DATETIME: 
                        valueNo1 = Convert.ToDateTime(valueNo1);
                        valueNo2 = Convert.ToDateTime(valueNo1);
                        break;
                    case Families.NUMBER : 
                        valueNo1 = Convert.ToDouble(valueNo1);
                        valueNo2 = Convert.ToDouble(valueNo2);
                        break;
                    default : 
                        valueNo1 = valueNo1.ToString();
                        valueNo2 = valueNo2.ToString();
                        break;
                }
                return ((IComparable) valueNo1).CompareTo(valueNo2);
            }
        }
        
        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int recordNo) {
            Object value = values[recordNo];
            if (defaultValue != value) {
                return value;
            }
            return GetBits(recordNo);
        }

        private Families GetFamily(Type dataType) {
            switch (Type.GetTypeCode(dataType)) {
                case TypeCode.Boolean:   return Families.BOOLEAN;
                case TypeCode.Char:      return Families.STRING;
                case TypeCode.SByte:     return Families.STRING;
                case TypeCode.Byte:      return Families.STRING;
                case TypeCode.Int16:     return Families.NUMBER;
                case TypeCode.UInt16:    return Families.NUMBER;
                case TypeCode.Int32:     return Families.NUMBER;
                case TypeCode.UInt32:    return Families.NUMBER;
                case TypeCode.Int64:     return Families.NUMBER;
                case TypeCode.UInt64:    return Families.NUMBER;
                case TypeCode.Single:    return Families.NUMBER;
                case TypeCode.Double:    return Families.NUMBER;
                case TypeCode.Decimal:   return Families.NUMBER;
                case TypeCode.DateTime:  return Families.DATETIME;
                case TypeCode.String:    return Families.STRING;
                default:                 
                    if (typeof(TimeSpan) == dataType) {
                         return Families.DATETIME;
                     } else {
                         return Families.STRING;
                     }
            }
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int recordNo, Object value) {
            if (SetBits(recordNo, value)) {
                values[recordNo] = ObjectStorage.defaultValue;
            } else {
                values[recordNo] = value;
            }
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            object[] newValues = new object[capacity];
            if (values != null) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            Type type = DataType; // real type of objects in this column
            if (type == typeof(byte[])) {
                return Convert.FromBase64String(s);
            }else {
                ConstructorInfo ctor = type.GetConstructor(new Type[] {typeof(string)});
                if (ctor != null) {
                    return ctor.Invoke(new Object[] { s });
                }else {
                    return s;
                }
            }
        }

        /// <include file='doc\ObjectStorage.uex' path='docs/doc[@for="ObjectStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            if (DataType == typeof(byte[])) {
                return Convert.ToBase64String((byte[])value);
            }else {
                return value.ToString();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\rowupdatingevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="RowUpdatingEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;
    using System.Data;

    /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides the data for the row updating event of a managed provider.
    ///    </para>
    /// </devdoc>
    abstract public class RowUpdatingEventArgs : System.EventArgs {
        private IDbCommand command;
        private StatementType statementType;
        private DataTableMapping tableMapping;
        private Exception errors;

        private DataRow dataRow;
        private UpdateStatus status; // UpdateStatus.Continue; /*0*/

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.RowUpdatingEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.Common.RowUpdatingEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        protected RowUpdatingEventArgs(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            this.dataRow = dataRow;
            this.command = command;
            this.statementType = statementType;
            this.tableMapping = tableMapping;
        }

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.Command"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the <see cref='System.Data.IDbCommand'/> to <see cref='System.Data.Common.DbDataAdapter.Update'/> . This property
        ///       is read-only.
        ///    </para>
        /// </devdoc>
        public IDbCommand Command {
            get {
                return this.command;
            }
            set {
                this.command = value;
            }
        }

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.StatementType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the type of SQL command to execute. This
        ///       property is read-only.
        ///    </para>
        /// </devdoc>
        public StatementType StatementType {
            get {
                return this.statementType;
            }
        }

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.Errors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the errors thrown by the managed provider when
        ///       the <see cref='System.Data.Common.RowUpdatedEventArgs.Command'/>
        ///       executes.
        ///    </para>
        /// </devdoc>
        public Exception Errors {
            get {
                return this.errors;
            }
            set {
                this.errors = value;
            }
        }

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.Row"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the <see cref='System.Data.DataRow'/> to send through an <see cref='System.Data.Common.DbDataAdapter.Update'/>. This property is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public DataRow Row {
            get {
                return this.dataRow;
            }
        }

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.Status"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the <see cref='System.Data.UpdateStatus'/> of the <see cref='System.Data.Common.RowUpdatedEventArgs.Command'/>.
        ///    </para>
        /// </devdoc>
        public UpdateStatus Status {
            get {
                return this.status;
            }
            set {
                switch(value) {
                case UpdateStatus.Continue:
                case UpdateStatus.ErrorsOccurred:
                case UpdateStatus.SkipCurrentRow:
                case UpdateStatus.SkipAllRemainingRows:
                    this.status = value;
                    break;
                default:
                    throw ADP.InvalidUpdateStatus((int) value);
                }
            }
        }

        /// <include file='doc\RowUpdatingEvent.uex' path='docs/doc[@for="RowUpdatingEventArgs.TableMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataTableMapping TableMapping {
            get {
                return this.tableMapping;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\sbytestorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="SByteStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage"]/*' />
    /// <internalonly/>
    [
    Serializable,
    CLSCompliantAttribute(false)
    ]
    internal class SByteStorage : DataStorage {

        private const SByte defaultValue = 0;
        static private readonly Object defaultValueAsObject = defaultValue;

        private SByte[] values;

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.SByteStorage"]/*' />
        /// <internalonly/>
        public SByteStorage()
        : base(typeof(SByte)) {
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Int64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Int64 meanSum = (Int64)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Int64)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            SByte mean;
                            checked {mean = (SByte)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        SByte min = SByte.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        SByte max = SByte.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(SByte));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            SByte valueNo1 = values[recordNo1];
            SByte valueNo2 = values[recordNo2];

            if (valueNo1.Equals(defaultValue) || valueNo2.Equals(defaultValue)) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return valueNo1.CompareTo(valueNo2);
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            SByte valueNo1 = values[recordNo];
            SByte valueNo2 = Convert.ToSByte(value);
            return valueNo1.CompareTo(valueNo2);
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            SByte value = values[record];
            if (!value.Equals(defaultValue)) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = SByteStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToSByte(value);
            }
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            SByte[] newValues = new SByte[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToSByte(s);
        }

        /// <include file='doc\SByteStorage.uex' path='docs/doc[@for="SByteStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((SByte)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\singlestorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="SingleStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class SingleStorage : DataStorage {

        private const Single defaultValue = 0.0f;
        static private readonly Object defaultValueAsObject = defaultValue;

        private Single[] values;

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.SingleStorage"]/*' />
        /// <internalonly/>
        public SingleStorage()
        : base(typeof(Single)) {
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        Single sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Double meanSum = (Double)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Double)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            Single mean;
                            checked {mean = (Single)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;


                    case AggregateType.Min:
                        Single min = Single.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        Single max = Single.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(Single));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            Single valueNo1 = values[recordNo1];
            Single valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            Single valueNo1 = values[recordNo];
            Single valueNo2 = Convert.ToSingle(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            Single value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = SingleStorage.defaultValue;
            }
            else {
                values[record] = Convert.ToSingle(value);
            }
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            Single[] newValues = new Single[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToSingle(s);
        }

        /// <include file='doc\SingleStorage.uex' path='docs/doc[@for="SingleStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((Single)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\timespanstorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimeSpanStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage"]/*' />
    /// <internalonly/>
    [Serializable]
    internal class TimeSpanStorage : DataStorage {

        private static readonly TimeSpan defaultValue = TimeSpan.Zero;
        static private readonly Object defaultValueAsObject = defaultValue;

        private TimeSpan[] values;

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.TimeSpanStorage"]/*' />
        /// <internalonly/>
        public TimeSpanStorage()
        : base(typeof(TimeSpan)) {
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Min:
                        TimeSpan min = TimeSpan.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=(TimeSpan.Compare(values[record],min) < 0) ? values[record] : min;
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        TimeSpan max = TimeSpan.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=(TimeSpan.Compare(values[record],max) >= 0) ? values[record] : max;
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(TimeSpan));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            TimeSpan valueNo1 = values[recordNo1];
            TimeSpan valueNo2 = values[recordNo2];

            if (valueNo1 == defaultValue || valueNo2 == defaultValue) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return TimeSpan.Compare(valueNo1, valueNo2);
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            TimeSpan valueNo1 = values[recordNo];
            TimeSpan valueNo2 = (TimeSpan)value;
            return TimeSpan.Compare(valueNo1, valueNo2);
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            TimeSpan value = values[record];
            if (value != defaultValue) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = TimeSpanStorage.defaultValue;
            }
            else {
                values[record] = (TimeSpan) value;
            }
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            TimeSpan[] newValues = new TimeSpan[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToTimeSpan(s);
        }

        /// <include file='doc\TimeSpanStorage.uex' path='docs/doc[@for="TimeSpanStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((TimeSpan)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\schemamapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System.Collections;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;

    sealed internal class SchemaMapping {

        // DataColumns match in length and name order as the DataReader, no chapters
        private const int MapExactMatch = 0;

        // DataColumns has different length, but correct name order as the DataReader, no chapters
        private const int MapDifferentSize = 1;

        // DataColumns may have different length, but a differant name ordering as the DataReader, no chapters
        private const int MapReorderedValues = 2;
        
        // DataColumns may have different length, but correct name order as the DataReader, with chapters
        private const int MapChapters = 3;

        // DataColumns may have different length, but a differant name ordering as the DataReader, with chapters
        private const int MapChaptersReordered = 4;

        private DataSet dataSet; // the current dataset, may be null if we are only filling a DataTable
        private DataTable dataTable; // the current DataTable, should never be null

        private DbDataAdapter adapter;
        private IDataReader dataReader;
        private DataTable schemaTable;  // will be null if Fill without schema
        private DataTableMapping tableMapping;

        // unique (generated) names based from DataReader.GetName(i)
        private string[] fieldNames;

        private object[] _readerDataValues;
        private object[] _mappedDataValues; // array passed to dataRow.AddUpdate(), if needed

        private int[] _indexMap;     // index map that maps dataValues -> _mappedDataValues, if needed
        private bool[] _chapterMap;  // which DataReader indexes have chapters

        private int mappedMode; // modes as described as above
        private int _mappedLength;

        internal SchemaMapping(DbDataAdapter adapter, IDataReader dataReader, bool keyInfo) {
            Debug.Assert(null != adapter, "adapter");
            Debug.Assert(null != dataReader, "dataReader");
            Debug.Assert(0 < dataReader.FieldCount, "FieldCount");

            this.adapter = adapter;
            this.dataReader = dataReader;
            if (keyInfo) {
                this.schemaTable = dataReader.GetSchemaTable();
            }
        }

        internal IDataReader DataReader {
            get {
                Debug.Assert(null != dataReader, "DataReader");
                return this.dataReader;
            }
        }

        internal DataSet DataSet {
            /*get {
                return this.dataSet;
            }*/
            set { // setting DataSet implies chapters are supported
                Debug.Assert(null != value, "DataSet");
                this.dataSet = value;
            }
        }

        internal DataTable DataTable {
            get {
                return this.dataTable;
            }
            set { // setting only DataTable, not DataSet implies chapters are not supported
                Debug.Assert(null != value, "DataTable");
                this.dataTable = value;
            }
        }

        internal object[] DataValues {
            get {
                return _readerDataValues;
            }
        }

        internal void ApplyToDataRow(DataRow dataRow) {

            DataColumnCollection columns = dataRow.Table.Columns;

            dataReader.GetValues(_readerDataValues);
            object[] mapped = GetMappedValues();

            int length = mapped.Length;

            bool[] readOnly = new bool[length];
            for (int i = 0; i < length; ++i) {
                readOnly[i] = columns[i].ReadOnly;
            }
            
            try { // try-filter-finally so and catch-throw
                try {
                    try {
                        // allow all columns to be written to
                        for (int i = 0; i < length; ++i) {
                            columns[i].ReadOnly = false;
                        }
                        
                        for(int i = 0; i < length; ++i) {
                            if (null != mapped[i]) { // MDAC 72659
                                dataRow[i] = mapped[i];
                            }
                        }
                    }
                    finally { // ReadOnly
                        // reset readonly flag on all columns
                        for (int i = 0; i < length; ++i) {
                            columns[i].ReadOnly = readOnly[i];
                        }
                    }
                }
                finally { // FreeDataRowChapters
                    if (null != _chapterMap) {
                        FreeDataRowChapters();
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        private void MappedChapterIndex() { // mode 4
            int length = _mappedLength;

            for (int i = 0; i < length; i++) {
                int k = _indexMap[i];
                if (0 <= k) {
                    _mappedDataValues[k] = _readerDataValues[i]; // from reader to dataset
                    if (_chapterMap[i]) {
                        _mappedDataValues[k] = null; // InvalidCast from DataReader to AutoIncrement DataColumn
                    }
                }
            }
        }

        private void MappedChapter() { // mode 3
            int length = _mappedLength;

            for (int i = 0; i < length; i++) {
                _mappedDataValues[i] = _readerDataValues[i]; // from reader to dataset
                if (_chapterMap[i]) {
                    _mappedDataValues[i] = null; // InvalidCast from DataReader to AutoIncrement DataColumn
                }
            }
        }

        private void MappedIndex() { // mode 2
            Debug.Assert(_mappedLength == _indexMap.Length, "incorrect precomputed length");

            int length = _mappedLength;
            for (int i = 0; i < length; i++) {
                int k = _indexMap[i];
                if (0 <= k) {
                    _mappedDataValues[k] = _readerDataValues[i]; // from reader to dataset
                }
            }
        }

        private void MappedValues() { // mode 1
            Debug.Assert(_mappedLength == Math.Min(_readerDataValues.Length, _mappedDataValues.Length), "incorrect precomputed length");

            int length = _mappedLength;
            for (int i = 0; i < length; ++i) {
                _mappedDataValues[i] = _readerDataValues[i]; // from reader to dataset
            };
        }

        private object[] GetMappedValues() { // mode 0
            switch(this.mappedMode) {
            default:
            case MapExactMatch:
                Debug.Assert(0 == this.mappedMode, "incorrect mappedMode");
                Debug.Assert((null == _chapterMap) && (null == _indexMap) && (null == _mappedDataValues), "incorrect MappedValues");
                return _readerDataValues;  // from reader to dataset
            case MapDifferentSize:
                Debug.Assert((null == _chapterMap) && (null == _indexMap) && (null != _mappedDataValues), "incorrect MappedValues");
                MappedValues();
                break;
            case MapReorderedValues:
                Debug.Assert((null == _chapterMap) && (null != _indexMap) && (null != _mappedDataValues), "incorrect MappedValues");
                MappedIndex();
                break;
            case MapChapters:
                Debug.Assert((null != _chapterMap) && (null == _indexMap) && (null != _mappedDataValues), "incorrect MappedValues");
                MappedChapter();
                break;
            case MapChaptersReordered:
                Debug.Assert((null != _chapterMap) && (null != _indexMap) && (null != _mappedDataValues), "incorrect MappedValues");
                MappedChapterIndex();
                break;
            }
            return _mappedDataValues;
        }

        internal void LoadDataRow(bool clearDataValues, bool acceptChanges) {
            if (clearDataValues) { // for FillErrorEvent to ensure no values leftover from previous row
                int length = _readerDataValues.Length;
                for (int i = 0; i < length; ++i) {
                    _readerDataValues[i] = null;
                }
            }

            dataReader.GetValues(_readerDataValues);
            object[] mapped = GetMappedValues();
            DataRow dataRow = this.dataTable.LoadDataRow(mapped, acceptChanges);

            if (null != _chapterMap) {
                if (null != this.dataSet) {
                    LoadDataRowChapters(dataRow); // MDAC 70772
                }
                else {
                    FreeDataRowChapters(); // MDAC 71900
                }
            }
        }

        private void FreeDataRowChapters() {
            int rowLength = _chapterMap.Length;
            for(int i = 0; i < rowLength; ++i) {
                if (_chapterMap[i]) {
                    object readerValue = _readerDataValues[i];
                    if (readerValue is IDisposable) {
                        ((IDisposable) readerValue).Dispose();
                    }
                }
            }
        }

        internal int LoadDataRowChapters(DataRow dataRow) {
            int datarowadded = 0;

            int rowLength = _chapterMap.Length;
            for(int i = 0; i < rowLength; ++i) {
                if (_chapterMap[i]) {
                    object readerValue = _readerDataValues[i];
                    if ((null != readerValue) && !Convert.IsDBNull(readerValue)) { // MDAC 70441
                        IDataReader nestedReader = (IDataReader) readerValue;

                        if (!nestedReader.IsClosed) {
                            Debug.Assert(null != this.dataSet, "if chapters, then Fill(DataSet,...) not Fill(DataTable,...)");

                            object parentChapterValue;
                            DataColumn parentChapterColumn;
                            if (null == _indexMap) {
                                parentChapterColumn = dataTable.Columns[i];
                                parentChapterValue = dataRow[parentChapterColumn];
                            }
                            else {
                                parentChapterColumn = dataTable.Columns[_indexMap[i]];
                                parentChapterValue = dataRow[parentChapterColumn];
                            }

                            // correct on Fill, not FillFromReader
                            string chapterTableName = tableMapping.SourceTable + this.fieldNames[i]; // MDAC 70908
                            datarowadded += adapter.FillFromReader(this.dataSet, chapterTableName, nestedReader, 0, 0, parentChapterColumn, parentChapterValue);

                            nestedReader.Dispose();
                        }
                    }
                }
            }
            return datarowadded;
        }

        internal void SetupSchema(SchemaType schemaType, string sourceTableName, bool gettingData, DataColumn parentChapterColumn, object parentChapterValue) {
#if DEBUG
            Debug.Assert(null != this.dataSet || null != this.dataTable, "SetupSchema - null dataSet");
            Debug.Assert(SchemaType.Mapped == schemaType || SchemaType.Source == schemaType, "SetupSchema - invalid schemaType");
#endif
            MissingMappingAction mappingAction;
            MissingSchemaAction schemaAction;
            
            if (SchemaType.Mapped == schemaType) {
                mappingAction = this.adapter.MissingMappingAction;
                schemaAction = this.adapter.MissingSchemaAction;
                if (!ADP.IsEmpty(sourceTableName)) { // MDAC 66034
                    tableMapping = this.adapter.GetTableMappingBySchemaAction(sourceTableName, sourceTableName, mappingAction);
                }
                else if (null != this.dataTable) {
                    int index = this.adapter.IndexOfDataSetTable(this.dataTable.TableName);
                    if (-1 != index) {
                        tableMapping = this.adapter.TableMappings[index];
                    }
                    else {
                        switch (mappingAction) {
                        case MissingMappingAction.Passthrough:
                            tableMapping = new DataTableMapping(this.dataTable.TableName, this.dataTable.TableName);
                            break;
                        case MissingMappingAction.Ignore:
                            tableMapping = null;
                            break;
                        case MissingMappingAction.Error:
                            throw ADP.MissingTableMappingDestination(this.dataTable.TableName);
                        default:
                            throw ADP.InvalidMappingAction((int)mappingAction);
                        }
                    }
                }
            }
            else if (SchemaType.Source == schemaType) {
                mappingAction = System.Data.MissingMappingAction.Passthrough;
                schemaAction = Data.MissingSchemaAction.Add;
                if (!ADP.IsEmpty(sourceTableName)) { // MDAC 66034
                    tableMapping = DataTableMappingCollection.GetTableMappingBySchemaAction(null, sourceTableName, sourceTableName, mappingAction);
                }
                else if (null != this.dataTable) {
                    int index = this.adapter.IndexOfDataSetTable(this.dataTable.TableName); // MDAC 66034
                    if (-1 != index) {
                        tableMapping = this.adapter.TableMappings[index];
                    }
                    else {
                        tableMapping = new DataTableMapping(this.dataTable.TableName, this.dataTable.TableName);
                    }
                }
            }
            else {
                throw ADP.InvalidSchemaType((int) schemaType);
            }
            if (null == tableMapping) {
                return;
            }
            if (null == this.dataTable) {
                this.dataTable = tableMapping.GetDataTableBySchemaAction(this.dataSet, schemaAction);
                if (null == this.dataTable) {
                    return; // null means ignore (mapped to nothing)
                }
            }

            if (null == this.schemaTable) {
                SetupSchemaWithoutKeyInfo(mappingAction, schemaAction, gettingData, parentChapterColumn, parentChapterValue);
            }
            else {
                SetupSchemaWithKeyInfo(mappingAction, schemaAction, gettingData, parentChapterColumn, parentChapterValue);
            }
        }

        private int[] CreateIndexMap(int count, int index) {
            int[] values = new int[count];
            for (int i = 0; i < index; ++i) {
                values[i] = i;
            }
            return values;
        }

        private void GenerateFieldNames(int count) {
            this.fieldNames = new string[count];
            for(int i = 0; i < count; ++i) {
                fieldNames[i] = this.dataReader.GetName(i);
            }
            ADP.BuildSchemaTableInfoTableNames(fieldNames);
        }

        private void SetupSchemaWithoutKeyInfo(MissingMappingAction mappingAction, MissingSchemaAction schemaAction, bool gettingData, DataColumn parentChapterColumn, object chapterValue) {
            int[] columnIndexMap = null;
            bool[] chapterIndexMap = null;

            int mappingCount = 0;
            int count = this.dataReader.FieldCount;
            GenerateFieldNames(count);

            DataColumnCollection columnCollection = null;
            for (int i = 0; i < count; ++i) {
                DataColumnMapping columnMapping = tableMapping.GetColumnMappingBySchemaAction(fieldNames[i], mappingAction);
                if (null == columnMapping) {
                    if (null == columnIndexMap) {
                        columnIndexMap = CreateIndexMap(count, i);
                    }
                    columnIndexMap[i] = -1;
                    continue; // null means ignore (mapped to nothing)
                }

                bool ischapter = false;
                Type fieldType = this.dataReader.GetFieldType(i);
                if (typeof(IDataReader).IsAssignableFrom(fieldType)) {
                    if (null == chapterIndexMap) {
                        chapterIndexMap = new bool[count];
                    }
                    chapterIndexMap[i] = ischapter = true;

                    fieldType = typeof(Int32);
                }

                DataColumn dataColumn = columnMapping.GetDataColumnBySchemaAction(this.dataTable, fieldType, schemaAction);
                if (null == dataColumn) {
                    if (null == columnIndexMap) {
                        columnIndexMap = CreateIndexMap(count, i);
                    }
                    columnIndexMap[i] = -1;
                    continue; // null means ignore (mapped to nothing)
                }

                if (null == dataColumn.Table) {
                    if (ischapter) {
                        dataColumn.AllowDBNull = false;
                        dataColumn.AutoIncrement = true;
                        dataColumn.ReadOnly = true;
                    }
                    if (null == columnCollection) {
                        columnCollection = dataTable.Columns;
                    }
                    columnCollection.Add(dataColumn);
                }
                else if (ischapter && !dataColumn.AutoIncrement) {
                    throw ADP.FillChapterAutoIncrement();
                }

                if (null != columnIndexMap) {
                    columnIndexMap[i] = dataColumn.Ordinal;
                }
                else if (i != dataColumn.Ordinal) {
                    columnIndexMap = CreateIndexMap(count, i);
                    columnIndexMap[i] = dataColumn.Ordinal;
                }
                mappingCount++;
            }

            bool addDataRelation = false;
            DataColumn chapterColumn = null;
            if (null != chapterValue) { // add the extra column in the child table
                DataColumnMapping columnMapping = tableMapping.GetColumnMappingBySchemaAction(tableMapping.SourceTable, mappingAction);
                if (null != columnMapping) {

                    Type fieldType = chapterValue.GetType();
                    chapterColumn = columnMapping.GetDataColumnBySchemaAction(this.dataTable, fieldType, schemaAction);
                    if (null != chapterColumn) {

                        if (null == chapterColumn.Table) {
                            if (null == columnCollection) {
                                columnCollection = dataTable.Columns;
                            }
                            columnCollection.Add(chapterColumn);
                            addDataRelation = (null != parentChapterColumn);
                        }
                        mappingCount++;
                    }
                }
            }

            object[] dataValues = null;
            if (0 < mappingCount) {
                if ((null != this.dataSet) && (null == this.dataTable.DataSet)) {
                    // Allowed to throw exception if DataTable is from wrong DataSet
                    this.dataSet.Tables.Add(this.dataTable);
                }
                if (gettingData) {
                    if (null == columnCollection) {
                        columnCollection = dataTable.Columns;
                    }
                    _indexMap = columnIndexMap;
                    _chapterMap = chapterIndexMap;
                    dataValues = SetupMapping(count, columnCollection, chapterColumn, chapterValue);
                }
#if DEBUG
                else { this.mappedMode = -1; }
#endif
            }
            else {
                this.dataTable = null;
            }

            if (addDataRelation) {
                AddRelation(parentChapterColumn, chapterColumn);
            }
            _readerDataValues = dataValues;
        }


        private DataColumn[] ResizeColumnArray(DataColumn[] rgcol, int len) {
            Debug.Assert(rgcol != null, "invalid call to ResizeArray");
            Debug.Assert(len <= rgcol.Length, "invalid len passed to ResizeArray");
            DataColumn[] tmp = new DataColumn[len];
            Array.Copy(rgcol, tmp, len);
            return tmp;
        }

        private void SetupSchemaWithKeyInfo(MissingMappingAction mappingAction, MissingSchemaAction schemaAction, bool gettingData, DataColumn parentChapterColumn, object chapterValue) {
#if DEBUG
            Debug.Assert(null != schemaTable, "null schematable");
            if (AdapterSwitches.DataSchema.TraceVerbose) {
                ADP.TraceDataTable("SetupSchema", schemaTable);
            }
#endif
            DBSchemaRow[] schemaRows = DBSchemaRow.GetSortedSchemaRows(schemaTable); // MDAC 60609
            Debug.Assert(null != schemaRows, "SchemaSetup - null DBSchemaRow[]");

            int count = schemaRows.Length;
            if (0 == count) {
                this.dataTable = null;
                return;
            }

            bool addPrimaryKeys = (0 == this.dataTable.PrimaryKey.Length); // MDAC 67033
            DataColumn[] keys = null;
            int keyCount = 0;
            bool isPrimary = true; // assume key info (if any) is about a primary key

            int[] columnIndexMap = null;
            bool[] chapterIndexMap = null;

            int mappingCount = 0;
            GenerateFieldNames(count);

            DataColumnCollection columnCollection = null;
            for(int sortedIndex = 0; sortedIndex < count; ++sortedIndex) {
                DBSchemaRow schemaRow = schemaRows[sortedIndex];

                int unsortedIndex = schemaRow.UnsortedIndex; // MDAC 67050

                DataColumnMapping columnMapping = null;
                Type fieldType = schemaRow.DataType;
                DataColumn dataColumn = null;

                if (!schemaRow.IsHidden ) {
                    columnMapping = tableMapping.GetColumnMappingBySchemaAction(fieldNames[sortedIndex], mappingAction);
                }

                bool ischapter = false;
                if ((null != columnMapping) && typeof(IDataReader).IsAssignableFrom(fieldType)) {
                    if (null == chapterIndexMap) {
                        chapterIndexMap = new bool[count];
                    }
                    chapterIndexMap[unsortedIndex] = ischapter = true;

                    fieldType = typeof(Int32);
                }

                if (columnMapping != null) {
                    dataColumn = columnMapping.GetDataColumnBySchemaAction(this.dataTable, fieldType, schemaAction);
                }

                if (null == dataColumn) {
                    if (null == columnIndexMap) {
                        columnIndexMap = CreateIndexMap(count, unsortedIndex);
                    }
                    columnIndexMap[unsortedIndex] = -1;

                    // if the column is not mapped and it is a key, then don't add any key information
                    if (schemaRow.IsKey) {
#if DEBUG
                        if (AdapterSwitches.DataSchema.TraceVerbose) {
                            Debug.WriteLine("SetupSchema: partial primary key detected");
                        }
#endif
                        addPrimaryKeys = false; // don't add any future keys now
                        keys = null; // get rid of any keys we've seen
                    }
                    continue; // null means ignore (mapped to nothing)
                }

                if (ischapter) {
                    if (null == dataColumn.Table) {
                        dataColumn.AllowDBNull = false;
                        dataColumn.AutoIncrement = true;
                        dataColumn.ReadOnly = true;
                    }
                    else if (!dataColumn.AutoIncrement) {
                        throw ADP.FillChapterAutoIncrement();
                    }
                }
                else {// MDAC 67033
                    if (schemaRow.IsAutoIncrement && IsAutoIncrementType(fieldType)) {
                        // CONSIDER: use T-SQL "IDENT_INCR('table_or_view')" and "IDENT_SEED('table_or_view')"
                        //           functions to obtain the actual increment and seed values
                        dataColumn.AutoIncrement = true;

                        if (!schemaRow.AllowDBNull) { // MDAC 71060
                            dataColumn.AllowDBNull = false;
                        }
                    }

                    // setup maxLength, only for string columns since this is all the DataSet supports
                    if (fieldType == typeof(string)) {
                        //@devnote:  schemaRow.Size is count of characters for string columns, count of bytes otherwise
                        dataColumn.MaxLength = schemaRow.Size;
                    }

                    if (schemaRow.IsReadOnly) {
                        dataColumn.ReadOnly = true;
                    }
                    if (!schemaRow.AllowDBNull && (!schemaRow.IsReadOnly || schemaRow.IsKey)) { // MDAC 71060, 72252
                        dataColumn.AllowDBNull = false;
                    }

                    if (schemaRow.IsUnique && !schemaRow.IsKey && !fieldType.IsArray) {
                        // note, arrays are not comparable so only mark non-arrays as unique, ie timestamp columns
                        // are unique, but not comparable
                        dataColumn.Unique = true;

                        if (!schemaRow.AllowDBNull) { // MDAC 71060
                            dataColumn.AllowDBNull = false;
                        }
                    }
                }
                if (null == dataColumn.Table) {
                    if (null == columnCollection) {
                        columnCollection = dataTable.Columns;
                    }
                    columnCollection.Add(dataColumn);
                }

                // The server sends us one key per table according to these rules.
                //
                // 1. If the table has a primary key, the server sends us this key.
                // 2. If the table has a primary key and a unique key, it sends us the primary key
                // 3. if the table has no primary key but has a unique key, it sends us the unique key
                //
                // In case 3, we will promote a unique key to a primary key IFF all the columns that compose
                // that key are not nullable since no columns in a primary key can be null.  If one or more
                // of the keys is nullable, then we will add a unique constraint.
                //
                if (addPrimaryKeys && schemaRow.IsKey) { // MDAC 67033
                    if (keys == null) {
                        keys = new DataColumn[count];
                    }
                    keys[keyCount++] = dataColumn;
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceVerbose) {
                        Debug.WriteLine("SetupSchema: building list of " + ((isPrimary) ? "PrimaryKey" : "UniqueConstraint"));
                    }
#endif
                    // see case 3 above, we do want dataColumn.AllowDBNull not schemaRow.AllowDBNull
                    // otherwise adding PrimaryKey will change AllowDBNull to false
                    if (isPrimary && dataColumn.AllowDBNull) { // MDAC 72241 
#if DEBUG
                        if (AdapterSwitches.DataSchema.TraceVerbose) {
                            Debug.WriteLine("SetupSchema: changing PrimaryKey into UniqueContraint");
                        }
#endif
                        isPrimary = false;
                    }
                }

                if (null != columnIndexMap) {
                    columnIndexMap[unsortedIndex] = dataColumn.Ordinal;
                }
                else if (unsortedIndex != dataColumn.Ordinal) {
                    columnIndexMap = CreateIndexMap(count, unsortedIndex);
                    columnIndexMap[unsortedIndex] = dataColumn.Ordinal;
                }
                mappingCount++;
            }

            bool addDataRelation = false;
            DataColumn chapterColumn = null;
            if (null != chapterValue) { // add the extra column in the child table
                DataColumnMapping columnMapping = tableMapping.GetColumnMappingBySchemaAction(tableMapping.SourceTable, mappingAction);
                if (null != columnMapping) {

                    Type fieldType = chapterValue.GetType();
                    chapterColumn = columnMapping.GetDataColumnBySchemaAction(this.dataTable, fieldType, schemaAction);
                    if (null != chapterColumn) {

                        if (null == chapterColumn.Table) {

                            chapterColumn.ReadOnly = true; // MDAC 71878
                            chapterColumn.AllowDBNull = false;

                            if (null == columnCollection) {
                                columnCollection = dataTable.Columns;
                            }
                            columnCollection.Add(chapterColumn);
                            addDataRelation = (null != parentChapterColumn);
                        }
                        mappingCount++;
                    }
                }
            }

            object[] dataValues = null;
            if (0 < mappingCount) {
                if ((null != this.dataSet) && null == this.dataTable.DataSet) {
                    this.dataSet.Tables.Add(this.dataTable);
                }
                // setup the key
                if (addPrimaryKeys && (null != keys)) { // MDAC 67033
                    if (keyCount < keys.Length) {
                        keys = ResizeColumnArray(keys, keyCount);
                    }

                    // MDAC 66188
                    if (isPrimary) {
#if DEBUG
                        if (AdapterSwitches.DataSchema.TraceVerbose) {
                            Debug.WriteLine("SetupSchema: set_PrimaryKey");
                        }
#endif
                        this.dataTable.PrimaryKey = keys;
                    }
                    else {
                        UniqueConstraint unique = new UniqueConstraint("", keys);
                        ConstraintCollection constraints = this.dataTable.Constraints;
                        int constraintCount = constraints.Count;
                        for (int i = 0; i < constraintCount; ++i) {
                            if (unique.Equals(constraints[i])) {
#if DEBUG
                                if (AdapterSwitches.DataSchema.TraceVerbose) {
                                    Debug.WriteLine("SetupSchema: duplicate Contraint detected");
                                }
#endif
                                unique = null;
                                break;
                            }
                        }
                        if (null != unique) {
#if DEBUG
                            if (AdapterSwitches.DataSchema.TraceVerbose) {
                                Debug.WriteLine("SetupSchema: adding new UniqueConstraint");
                            }
#endif
                            constraints.Add(unique);
                        }
                    }
                }
                if (gettingData) {
                    if (null == columnCollection) {
                        columnCollection = dataTable.Columns;
                    }
                    _indexMap = columnIndexMap;
                    _chapterMap = chapterIndexMap;
                    dataValues = SetupMapping(count, columnCollection, chapterColumn, chapterValue);
                }
#if DEBUG
                else { this.mappedMode = -1; }
#endif
            }
            else {
                this.dataTable = null;
            }
            if (addDataRelation) {
                AddRelation(parentChapterColumn, chapterColumn);
            }
            _readerDataValues = dataValues;
        }

        private void AddRelation(DataColumn parentChapterColumn, DataColumn chapterColumn) { // MDAC 71613
            if (null != this.dataSet) {
                string name = /*parentChapterColumn.ColumnName + "_" +*/ chapterColumn.ColumnName; // MDAC 72815

                DataRelation relation = new DataRelation(name, new DataColumn[] { parentChapterColumn }, new DataColumn[] { chapterColumn }, false); // MDAC 71878

                int index = 1;
                string tmp = name;
                DataRelationCollection relations = this.dataSet.Relations;
                while (-1 != relations.IndexOf(tmp)) {
                    tmp = name + index;
                    index++;
                }
                relation.RelationName = tmp;
                relations.Add(relation);
            }
        }

        private object[] SetupMapping(int count, DataColumnCollection columnCollection, DataColumn chapterColumn, object chapterValue) {
            object[] dataValues = new object[count];

            if (null == _indexMap) {
                int mappingCount = columnCollection.Count;
                bool hasChapters = (null != _chapterMap);
                if ((count != mappingCount) || hasChapters) {
                    _mappedDataValues = new object[mappingCount];
                    if (hasChapters) {

                        this.mappedMode = MapChapters;
                        _mappedLength = count;
                    }
                    else {
                        this.mappedMode = MapDifferentSize;
                        _mappedLength = Math.Min(count, mappingCount);
                    }
                }
                else { this.mappedMode = MapExactMatch; /* _mappedLength doesn't matter */ }
            }
            else {
                _mappedDataValues = new object[columnCollection.Count];
                this.mappedMode = ((null == _chapterMap) ? MapReorderedValues : MapChaptersReordered);
                _mappedLength = count;
            }
            if (null != chapterColumn) { // value from parent tracked into child table
                _mappedDataValues[chapterColumn.Ordinal] = chapterValue;
            }
            return dataValues;
        }

        static private bool IsAutoIncrementType(Type dataType) {
            return((dataType == typeof(Int32)) || (dataType == typeof(Int64)) || (dataType == typeof(Int16)) || (dataType == typeof(Decimal)));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using System.Security;

namespace System.Data.Common {

    [SuppressUnmanagedCodeSecurityAttribute()]
    sealed internal class SafeNativeMethods {

        static internal void ClearErrorInfo() { // MDAC 68199
            UnsafeNativeMethods.SetErrorInfo(0, IntPtr.Zero);
        }

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        static internal extern void OutputDebugString(String message);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        static internal extern void VariantClear(IntPtr pObject);

        [DllImport(ExternDll.Kernel32, PreserveSig=true)]
        static internal extern void ZeroMemory(IntPtr dest, int length);

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr CreateEvent(IntPtr a, int b, int c, IntPtr d);

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr CreateSemaphore(IntPtr a, int b, int c, IntPtr d);

        [DllImport(ExternDll.Kernel32)]
        static internal extern int SetEvent(IntPtr handle);

        [DllImport(ExternDll.Kernel32)]
        static internal extern int ReleaseSemaphore(IntPtr hSem, int releaseCount, int pPrevCount);

        // note: Internaly there is no difference between InterlockedCompareExchange and InterlockedCompareExchangePointer.
        // InterlockeCompareExchangePointer is not even exported (it just wraps to InterlockedCompareExchange). Therefore the
        // signature below (all IntPtr) is ok.


#if HANDLEPROFILING
        [DllImport(ExternDll.Kernel32)]
        static internal extern bool QueryPerformanceCounter(
            out Int64 lpPerformanceCount   // counter value
            );
#endif

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr InterlockedCompareExchange(
            IntPtr Destination,     // destination address
            IntPtr Exchange,        // exchange value 
            IntPtr Comperand        // value to compare
            );

        [DllImport(ExternDll.Kernel32)]
        static internal extern int InterlockedDecrement(
            IntPtr lpAddend   // variable address
            );

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr InterlockedExchange(
            IntPtr Destination,     // destination address
            IntPtr Exchange         // exchange value 
            );

        [DllImport(ExternDll.Kernel32)]
        static internal extern int InterlockedIncrement(
            IntPtr lpAddend   // variable to increment
            );

        [DllImport(ExternDll.Kernel32)]
        static internal extern int ResetEvent(IntPtr handle);

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr GetCurrentThread();

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr GetCurrentProcess();

        [DllImport(ExternDll.Kernel32)]
        [return:MarshalAs(UnmanagedType.Bool)]
        static internal extern bool CloseHandle(IntPtr handle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\uint32storage.cs ===
//------------------------------------------------------------------------------
// <copyright file="UInt32Storage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage"]/*' />
    /// <internalonly/>
    [
    Serializable,
    CLSCompliantAttribute(false)
    ]
    internal class UInt32Storage : DataStorage {

        private static readonly UInt32 defaultValue = UInt32.MinValue;
        static private readonly Object defaultValueAsObject = defaultValue;

        private UInt32[] values;

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.UInt32Storage"]/*' />
        /// <internalonly/>
        public UInt32Storage()
        : base(typeof(UInt32)) {
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        UInt64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += (UInt64) values[record];}
                            hasData = true;
                        }
                        if (hasData) { 
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Int64 meanSum = (Int64)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Int64)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            UInt32 mean;
                            checked {mean = (UInt32)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        UInt32 min = UInt32.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        UInt32 max = UInt32.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        count = 0;
                        for (int i = 0; i < records.Length; i++) {
                            if (!IsNull(records[i]))
                                count++;
                        }
                        return count;
                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(UInt32));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            UInt32 valueNo1 = values[recordNo1];
            UInt32 valueNo2 = values[recordNo2];

            if (valueNo1 == UInt32Storage.defaultValue && valueNo2 == UInt32Storage.defaultValue) 
                return CompareBits(recordNo1, recordNo2);
            if (valueNo1 == UInt32Storage.defaultValue && base.IsNull(recordNo1))
                return -1;
            if (valueNo2 == UInt32Storage.defaultValue && base.IsNull(recordNo2))
                return 1;
            
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            UInt32 valueNo1 = values[recordNo];

            if (valueNo1 == UInt32Storage.defaultValue || value == null || value == DBNull.Value) {
                Object obj;
                if (valueNo1 == defaultValue)
                    obj = GetBits(recordNo);
                else
                    obj = valueNo1;
                    
                if (obj == value)
                    return 0;
                if (obj == null)
                    return -1;
                if (value == null)
                    return 1;
                if (obj == DBNull.Value)
                    return -1;
                if (value == DBNull.Value)
                    return 1;
            }

            UInt32 valueNo2 = Convert.ToUInt32(value);
            return valueNo1.CompareTo(valueNo2);
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            UInt32 value = values[record];
            if (!value.Equals(defaultValue)) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.IsNull"]/*' />
        /// <internalonly/>
        override public bool IsNull(int record) {
            UInt32 value = values[record];
            if (value != defaultValue) {
                return false;
            }
            return base.IsNull(record);
        }
        
        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (value == null || value == DBNull.Value) {
                SetBits(record, value);
                values[record] = UInt32Storage.defaultValue;
            }
            else {
                UInt32 val = Convert.ToUInt32(value);
                values[record] = val;
                if (val == UInt32Storage.defaultValue)
                    SetBits(record, value);
            }
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            UInt32[] newValues = new UInt32[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToUInt32(s);
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((UInt32)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\stringstorage.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Diagnostics;
    using System.Globalization;
    
   /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage"]/*' />
    /// <internalonly/>
    // The string storage does not use BitArrays in DataStorage
    [Serializable]
    internal class StringStorage : DataStorage {

        // This string should not be used in any places in the same assembly
        static private readonly String DBNullObject = "DBNullONsN";

        private String[] values;

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.StringStorage"]/*' />
        /// <internalonly/>
        public StringStorage() : base(typeof(String)) {}

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return String.Empty;
            }
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] recordNos, AggregateType kind) {
            int i;
            switch (kind) {
                case AggregateType.Min:
                    int min = -1;
                    for (i = 0; i < recordNos.Length; i++) {
                        if (IsNull(recordNos[i]))
                            continue;
                        min = recordNos[i];
                        break;
                    }
                    if (min >= 0) {
                        for (i = i+1; i < recordNos.Length; i++) {
                            if (IsNull(recordNos[i]))
                                continue;
                            if (Compare(min, recordNos[i]) > 0) {
                                min = recordNos[i];
                            }
                        }
                        return Get(min);
                    }
                    return DBNull.Value;

                case AggregateType.Max:
                    int max = -1;
                    for (i = 0; i < recordNos.Length; i++) {
                        if (IsNull(recordNos[i]))
                            continue;
                        max = recordNos[i];
                        break;
                    }
                    if (max >= 0) {
                        for (i = i+1; i < recordNos.Length; i++) {
                            if (Compare(max, recordNos[i]) < 0) {
                                max = recordNos[i];
                            }
                        }
                        return Get(max);
                    }
                    return DBNull.Value;

                case AggregateType.Count:
                    int count = 0;
                    for (i = 0; i < recordNos.Length; i++) {
                        Object value = values[recordNos[i]];
                        if (value != null && value != (Object)DBNullObject)
                            count++;
                    }
                    return count;
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            string valueNo1 = values[recordNo1];
            string valueNo2 = values[recordNo2];

            if ((Object)valueNo1 == (Object)valueNo2)
                return 0;
                
            if (valueNo1 == null)
                return -1;
            if (valueNo2 == null)
                return 1;

            if ((object)valueNo1 == (Object)DBNullObject)
                return -1;
            if ((object)valueNo2 == (Object)DBNullObject)
                return 1;

            return Compare(valueNo1, valueNo2);
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.Compare1"]/*' />
        /// <internalonly/>
        public int Compare(string s1, string s2) {
            return Table.Compare(s1, s2, CompareOptions.None);
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            Debug.Assert(recordNo != -1, "Invalid (-1) parameter: 'recordNo'");
            string valueNo1 = values[recordNo];

            if ((Object)valueNo1 == value)
                return 0;
                
            if (valueNo1 == null)
                return -1;
            if (value == null)
                return 1;

            if ((Object)valueNo1 == value)
                return 0;
                
            if (valueNo1 == null)
                return -1;
            if (value == null)
                return 1;

            if ((object)valueNo1 == (Object)DBNullObject) {
                if (value == DBNull.Value)
                    return 0;
                else
                    return -1;
            }
            if (value == (Object)DBNullObject || value == DBNull.Value)
                return 1;
                
            return Compare(valueNo1, Convert.ToString(value));
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int recordNo) {
            String value = values[recordNo];
            if ((Object)value == (Object)DBNullObject)
                return DBNull.Value;
            else
                return value;
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.IsNull"]/*' />
        /// <internalonly/>
        override public bool IsNull(int record) {
            String value = values[record];
            if (value == null || (Object) value == (Object)DBNullObject)
                return true;
            else
                return false;
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (value == DBNull.Value) {
                values[record] = DBNullObject;
            }
            else {
//                string input = value.ToString();
//                if (0 == input.Length) {
//                    input = StringStorage.defaultValue;
//                }
//                values[recordNo] = input;  
                if (value == null)
                    values[record] = null;
                else {
                    values[record] = value.ToString();
                    Debug.Assert(value != (Object)StringStorage.DBNullObject);
                }
            }
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            string[] newValues = new string[capacity];
            if (values != null) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            // StringStorage does not use bit arrays
            // base.SetCapacity(capacity);
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return s;
        }

        /// <include file='doc\StringStorage.uex' path='docs/doc[@for="StringStorage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {            
            return (string)value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\uint64storage.cs ===
//------------------------------------------------------------------------------
// <copyright file="UInt64Storage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage"]/*' />
    /// <internalonly/>
    [
    Serializable,
    CLSCompliantAttribute(false)
    ]
    internal class UInt64Storage : DataStorage {

        private static readonly UInt64 defaultValue = UInt64.MinValue;
        static private readonly Object defaultValueAsObject = defaultValue;

        private UInt64[] values;

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.UInt64Storage"]/*' />
        /// <internalonly/>
        public UInt64Storage()
        : base(typeof(UInt64)) {
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        UInt64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Decimal meanSum = (Decimal)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Decimal)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            UInt64 mean;
                            checked {mean = (UInt64)(Decimal)(meanSum / (Decimal)meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        UInt64 min = UInt64.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        UInt64 max = UInt64.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        return base.Aggregate(records, kind);

                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(UInt64));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            UInt64 valueNo1 = values[recordNo1];
            UInt64 valueNo2 = values[recordNo2];

            if (valueNo1.Equals(defaultValue) || valueNo2.Equals(defaultValue)) {
                int bitCheck = CompareBits(recordNo1, recordNo2);
                if (0 != bitCheck)
                    return bitCheck;
            }
            return valueNo1.CompareTo(valueNo2);
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            bool recordNull = IsNull(recordNo);

            if (recordNull && value == DBNull.Value)
                return 0;
            if (recordNull)
                return -1;
            if (value == DBNull.Value)
                return 1;

            UInt64 valueNo1 = values[recordNo];
            UInt64 valueNo2 = Convert.ToUInt64(value);
            return valueNo1.CompareTo(valueNo2);
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            UInt64 value = values[record];
            if (!value.Equals(defaultValue)) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (SetBits(record, value)) {
                values[record] = UInt64Storage.defaultValue;
            }
            else {
                values[record] = Convert.ToUInt64(value);
            }
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            UInt64[] newValues = new UInt64[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\UInt64Storage.uex' path='docs/doc[@for="UInt64Storage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToUInt64(s);
        }

        /// <include file='doc\UInt32Storage.uex' path='docs/doc[@for="UInt32Storage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((UInt64)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\uint16storage.cs ===
//------------------------------------------------------------------------------
// <copyright file="UInt16Storage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Common {
    using System;
    using System.Xml;

    /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage"]/*' />
    /// <internalonly/>
    [
    Serializable,
    CLSCompliantAttribute(false)
    ]
    internal class UInt16Storage : DataStorage {

        private static readonly UInt16 defaultValue = UInt16.MinValue;
        static private readonly Object defaultValueAsObject = defaultValue;

        private UInt16[] values;

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.UInt16Storage"]/*' />
        /// <internalonly/>
        public UInt16Storage()
        : base(typeof(UInt16)) {
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.DefaultValue"]/*' />
        /// <internalonly/>
        public override Object DefaultValue {
            get {
                return defaultValueAsObject;
            }
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.Aggregate"]/*' />
        /// <internalonly/>
        override public Object Aggregate(int[] records, AggregateType kind) {
            bool hasData = false;
            try {
                switch (kind) {
                    case AggregateType.Sum:
                        UInt64 sum = defaultValue;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { sum += values[record];}
                            hasData = true;
                        }
                        if (hasData) {
                            return sum;
                        }
                        return DBNull.Value;

                    case AggregateType.Mean:
                        Int64 meanSum = (Int64)defaultValue;
                        int meanCount = 0;
                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            checked { meanSum += (Int64)values[record];}
                            meanCount++;
                            hasData = true;
                        }
                        if (hasData) {
                            UInt16 mean;
                            checked {mean = (UInt16)(meanSum / meanCount);}
                            return mean;
                        }
                        return DBNull.Value;

                    case AggregateType.Var:
                    case AggregateType.StDev:
                        int count = 0;
                        double var = (double)defaultValue;
                        double prec = (double)defaultValue;
                        double dsum = (double)defaultValue;
                        double sqrsum = (double)defaultValue;

                        foreach (int record in records) {
                            if (IsNull(record))
                                continue;
                            dsum += (double)values[record];
                            sqrsum += (double)values[record]*(double)values[record];
                            count++;
                        }

                        if (count > 1) {
                            var = ((double)count * sqrsum - (dsum * dsum));
                            prec = var / (dsum * dsum);
                            
                            // we are dealing with the risk of a cancellation error
                            // double is guaranteed only for 15 digits so a difference 
                            // with a result less than 1e-15 should be considered as zero

                            if ((prec < 1e-15) || (var <0))
                                var = 0;
                            else
                                var = var / (count * (count -1));
                            
                            if (kind == AggregateType.StDev) {
                                return Math.Sqrt(var);
                            }
                            return var;
                        }
                        return DBNull.Value;

                    case AggregateType.Min:
                        UInt16 min = UInt16.MaxValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            min=Math.Min(values[record], min);
                            hasData = true;
                        }
                        if (hasData) {
                            return min;
                        }
                        return DBNull.Value;

                    case AggregateType.Max:
                        UInt16 max = UInt16.MinValue;
                        for (int i = 0; i < records.Length; i++) {
                            int record = records[i];
                            if (IsNull(record))
                                continue;
                            max=Math.Max(values[record], max);
                            hasData = true;
                        }
                        if (hasData) {
                            return max;
                        }
                        return DBNull.Value;

                    case AggregateType.First:
                        if (records.Length > 0) {
                            return values[records[0]];
                        }
                        return null;

                    case AggregateType.Count:
                        count = 0;
                        for (int i = 0; i < records.Length; i++) {
                            if (!IsNull(records[i]))
                                count++;
                        }
                        return count;
                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(typeof(UInt16));
            }
            throw ExceptionBuilder.AggregateException(kind.ToString(), DataType);
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.Compare"]/*' />
        /// <internalonly/>
        override public int Compare(int recordNo1, int recordNo2) {
            UInt16 valueNo1 = values[recordNo1];
            UInt16 valueNo2 = values[recordNo2];

            if (valueNo1 == UInt16Storage.defaultValue && valueNo2 == UInt16Storage.defaultValue) 
                return CompareBits(recordNo1, recordNo2);
            if (valueNo1 == UInt16Storage.defaultValue && base.IsNull(recordNo1))
                return -1;
            if (valueNo2 == UInt16Storage.defaultValue && base.IsNull(recordNo2))
                return 1;
            
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.CompareToValue"]/*' />
        /// <internalonly/>
        override public int CompareToValue(int recordNo, Object value) {
            UInt16 valueNo1 = values[recordNo];

            if (valueNo1 == UInt16Storage.defaultValue || value == null || value == DBNull.Value) {
                Object obj;
                if (valueNo1 == defaultValue)
                    obj = GetBits(recordNo);
                else
                    obj = valueNo1;
                    
                if (obj == value)
                    return 0;
                if (obj == null)
                    return -1;
                if (value == null)
                    return 1;
                if (obj == DBNull.Value)
                    return -1;
                if (value == DBNull.Value)
                    return 1;
            }

            UInt16 valueNo2 = Convert.ToUInt16(value);
            return(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1));
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.Copy"]/*' />
        /// <internalonly/>
        override public void Copy(int recordNo1, int recordNo2) {
            CopyBits(recordNo1, recordNo2);
            values[recordNo2] = values[recordNo1];
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.Get"]/*' />
        /// <internalonly/>
        override public Object Get(int record) {
            UInt16 value = values[record];
            if (!value.Equals(defaultValue)) {
                return value;
            }
            return GetBits(record);
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.IsNull"]/*' />
        /// <internalonly/>
        override public bool IsNull(int record) {
            UInt16 value = values[record];
            if (value != defaultValue) {
                return false;
            }
            return base.IsNull(record);
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.Set"]/*' />
        /// <internalonly/>
        override public void Set(int record, Object value) {
            if (value == null || value == DBNull.Value) {
                SetBits(record, value);
                values[record] = UInt16Storage.defaultValue;
            }
            else {
                UInt16 val = Convert.ToUInt16(value);
                values[record] = val;
                if (val == UInt16Storage.defaultValue)
                    SetBits(record, value);
            }
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.SetCapacity"]/*' />
        /// <internalonly/>
        override public void SetCapacity(int capacity) {
            UInt16[] newValues = new UInt16[capacity];
            if (null != values) {
                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));
            }
            values = newValues;
            base.SetCapacity(capacity);
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.ConvertXmlToObject"]/*' />
        /// <internalonly/>
        override public object ConvertXmlToObject(string s) {
            return XmlConvert.ToUInt16(s);
        }

        /// <include file='doc\UInt16Storage.uex' path='docs/doc[@for="UInt16Storage.ConvertObjectToXml"]/*' />
        /// <internalonly/>
        override public string ConvertObjectToXml(object value) {
            return XmlConvert.ToString((UInt16)value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.EnterpriseServices;
using System.Runtime.InteropServices;
using System.Security;

namespace System.Data.Common {

    [SuppressUnmanagedCodeSecurityAttribute()]
    sealed internal class UnsafeNativeMethods {

        [SuppressUnmanagedCodeSecurityAttribute()]
        sealed internal class Odbc32 {

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLAllocHandle(
                                                        /*SQLSMALLINT*/Int16 HandleType,
                                                        /*SQLHANDLE*/HandleRef InputHandle,
                                                        /*SQLHANDLE* */out IntPtr OutputHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLAllocHandle(
                                                        /*SQLSMALLINT*/Int16 HandleType,
                                                        /*SQLHANDLE*/HandleRef InputHandle,
                                                        /*SQLHANDLE* */IntPtr OutputHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLCancel(
                                                        /*SQLHSTMT*/HandleRef StatementHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLCloseCursor(
                /*SQLHSTMT*/HandleRef StatementHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLSetEnvAttr(
                                                        /*SQLHENV*/HandleRef EnvironmentHandle,
                                                        /*SQLINTEGER*/Int32 Attribute,
                                                        /*SQLPOINTER*/HandleRef Value,
                                                        /*SQLINTEGER*/Int32 StringLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLSetConnectAttrW(
                                                        /*SQLHBDC*/HandleRef ConnectionHandle,
                                                        /*SQLINTEGER*/Int32 Attribute,
                                                        /*SQLPOINTER*/HandleRef Value,
                                                        /*SQLINTEGER*/Int32 StringLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetConnectAttrW(
                                                        /*SQLHBDC*/HandleRef ConnectionHandle,
                                                        /*SQLINTEGER*/Int32 Attribute,
                                                        /*SQLPOINTER*/HandleRef Value,
                                                        /*SQLINTEGER*/Int32 BufferLength,
                                                        /*SQLINTEGER*/out Int32 StringLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetInfoW(
                                                        /*SQLHBDC*/HandleRef hdbc,
                                                        /*SQLUSMALLINT*/Int16 fInfoType,
                                                        /*SQLPOINTER*/HandleRef rgbInfoValue,
                                                        /*SQLSMALLINT*/Int16 cbInfoValueMax,
                                                        /*SQLSMALLINT* */out Int16 pcbInfoValue);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetInfoW(
                                                        /*SQLHBDC*/HandleRef hdbc,
                                                        /*SQLUSMALLINT*/Int16 fInfoType,
                                                        /*SQLPOINTER*/HandleRef rgbInfoValue,
                                                        /*SQLSMALLINT*/Int16 cbInfoValueMax,
                                                        /*SQLSMALLINT* */Int32 pcbInfoValue);

//
//            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
//            static internal extern /*SQLRETURN*/short SQLGetTypeInfoW(
//                                                        /*SQLHSTMT*/HandleRef StatementHandle,
//                                                        /*SQLSMALLINT*/Int16 TargetType);
//
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLDriverConnectW(
                                                            /*SQLHDBC*/HandleRef hdbc,
                                                            /*SQLHWND*/IntPtr hwnd,
#if USECRYPTO
                                                            [In, MarshalAs(UnmanagedType.LPArray)] /*SQLCHAR*/byte[] connectionstring,
#else
                                                            [In, MarshalAs(UnmanagedType.LPWStr)] /*SQLCHAR*/string connectionstring,
#endif
                                                            /*SQLSMALLINT*/Int16            cbConnectionstring,
                                                            /*SQLCHAR*/IntPtr               connectionstringout,
                                                            /*SQLSMALLINT*/Int16            cbConnectionstringoutMax,
                                                            /*SQLSMALLINT*/out Int16        cbConnectionstringout,
                                                            /*SQLUSMALLINT*/Int16           fDriverCompletion);
//
//            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
//            static internal extern /*SQLRETURN*/short SQLFreeEnv(/*SQLHENV*/HandleRef EnvironmentHandle);
//
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLDisconnect(/*SQLHDBC*/HandleRef ConnectionHandle);

//            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
//            static internal extern /*SQLRETURN*/short SQLFreeConnect(/*SQLHDBC*/HandleRef ConnectionHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLExecDirectW(
                                                            /*SQLHSTMT*/HandleRef  StatementHandle,
                                                            [In, MarshalAs(UnmanagedType.LPWStr)]
                                                            /*SQLCHAR*/string   StatementText,
                                                            /*SQLINTEGER*/Int32 TextLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLPrepareW(
                                                            /*SQLHSTMT*/HandleRef  StatementHandle,
                                                            [In, MarshalAs(UnmanagedType.LPWStr)]
                                                            /*SQLCHAR*/string   StatementText,
                                                            /*SQLINTEGER*/Int32 TextLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLExecute(
                                                            /*SQLHSTMT*/HandleRef  StatementHandle);
            
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLFreeStmt(
                                                            /*SQLHSTMT*/HandleRef  StatementHandle,
                                                            /*SQLUSMALLINT*/Int16 Option);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLFreeHandle(
                                                            /*SQLSMALLINT*/Int16    HandleType,
                                                            /*SQLHSTMT*/HandleRef      StatementHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLNumResultCols(
                                                            /*SQLHSTMT*/HandleRef  StatementHandle,
                                                            /*SQLSMALLINT*/out Int16 ColumnCount);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLRowCount(
                                                            /*SQLHSTMT*/HandleRef  StatementHandle,
                                                            /*SQLSMALLINT*/out Int16 RowCount);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetData(
                                                                /*SQLHSTMT*/HandleRef StatementHandle,
                                                               /*SQLUSMALLINT*/Int16 ColumnNumber,
                                                               /*SQLSMALLINT*/Int16 TargetType,
                                                               /*SQLPOINTER*/HandleRef TargetValue,
                                                               /*SQLLEN*/IntPtr BufferLength,
                                                               /*SQLLEN* */out IntPtr StrLen_or_Ind);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLBindParameter(
                                                               /*SQLHSTMT*/HandleRef StatementHandle,
                                                               /*SQLUSMALLINT*/Int16 ParameterNumber,
                                                               /*SQLSMALLINT*/Int16 ParamDirection,
                                                               /*SQLSMALLINT*/Int16 SQLCType,
                                                               /*SQLSMALLINT*/Int16 SQLType,
                                                               /*SQLULEN*/IntPtr    cbColDef,
                                                               /*SQLSMALLINT*/IntPtr ibScale,
                                                               /*SQLPOINTER*/HandleRef rgbValue,
                                                               /*SQLLEN*/IntPtr BufferLength,
                                                               /*SQLLEN* */IntPtr StrLen_or_Ind);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLBindCol(
                                                                /*SQLHSTMT*/HandleRef StatementHandle,
                                                               /*SQLUSMALLINT*/Int16 ColumnNumber,
                                                               /*SQLSMALLINT*/Int16 TargetType,
                                                               /*SQLPOINTER*/HandleRef TargetValue,
                                                               /*SQLLEN*/IntPtr BufferLength,
                                                               /*SQLLEN* */out IntPtr StrLen_or_Ind);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLFetch(/*SQLHSTMT*/HandleRef StatementHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLColAttributeW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                   /*SQLUSMALLINT*/Int16 ColumnNumber,
                                                                   /*SQLUSMALLINT*/Int16 FieldIdentifier,
                                                                   /*SQLPOINTER*/HandleRef CharacterAttribute,
                                                                   /*SQLSMALLINT*/Int16 BufferLength,
                                                                   /*SQLSMALLINT* */out Int16 StringLength,
                                                                   /*SQLPOINTER*/out Int32 NumericAttribute);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLColAttributesW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                   /*SQLUSMALLINT*/Int16 ColumnNumber,
                                                                   /*SQLUSMALLINT*/Int16 FieldIdentifier,
                                                                   /*SQLPOINTER*/HandleRef CharacterAttribute,
                                                                   /*SQLSMALLINT*/Int16 BufferLength,
                                                                   /*SQLSMALLINT* */out Int16 StringLength,
                                                                   /*SQLPOINTER*/out Int32 NumericAttribute);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLSetDescFieldW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                   /*SQLUSMALLINT*/Int16 ColumnNumber,
                                                                   /*SQLUSMALLINT*/Int16 FieldIdentifier,
                                                                   /*SQLPOINTER*/HandleRef CharacterAttribute,
                                                                   /*SQLSMALLINT*/Int16 BufferLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetDescFieldW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                   /*SQLUSMALLINT*/Int16 RecNumber,
                                                                   /*SQLUSMALLINT*/Int16 FieldIdentifier,
                                                                   /*SQLPOINTER*/HandleRef ValuePointer,
                                                                   /*SQLSMALLINT*/Int16 BufferLength,
                                                                   /*SQLINTEGER* */out Int32 StringLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLSetStmtAttrW(
                                                                   /*SQLHSTMT*/HandleRef          StatementHandle,
                                                                   /*SQLINTEGER*/Int32      Attribute,
                                                                   /*SQLPOINTER*/IntPtr     Value,
                                                                   /*SQLINTEGER*/Int32      StringLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetStmtAttrW(
                                                                   /*SQLHSTMT*/HandleRef          StatementHandle,
                                                                   /*SQLINTEGER*/Int32      Attribute,
                                                                   /*SQLPOINTER*/HandleRef     Value,
                                                                   /*SQLINTEGER*/Int32      BufferLength,
                                                                   /*SQLINTEGER*/out Int32  StringLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLMoreResults(/*SQLHSTMT*/HandleRef  StatementHandle);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLGetDiagRecW(
                                                                /*SQLSMALLINT*/Int16 HandleType,
                                                                /*SQLHANDLE*/HandleRef Handle,
                                                                /*SQLSMALLINT*/Int16 RecNumber,
                                                                /*SQLCHAR* */HandleRef szState,
                                                                /*SQLINTEGER* */out Int32 NativeError,
                                                                /*SQLCHAR* */HandleRef MessageText,
                                                                /*SQLSMALLINT*/Int16 BufferLength,
                                                                /*SQLSMALLINT* */out Int16 TextLength);

            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLEndTran(
                                                                /*SQLSMALLINT*/Int16 HandleType,
                                                                /*SQLHANDLE*/HandleRef Handle,
                                                                /*SQLSMALLINT*/Int16 CompletionType);
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLPrimaryKeysW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string CatalogName,
                                                                   /*SQLSMALLINT*/Int16 NameLen1,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */ string SchemaName,
                                                                   /*SQLSMALLINT*/Int16 NameLen2,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string TableName,
                                                                   /*SQLSMALLINT*/Int16 NameLen3);
            
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLProcedureColumnsW (
                /*SQLHSTMT*/HandleRef StatementHandle,
                [In, MarshalAs(UnmanagedType.LPWStr)] /*SQLCHAR* */ string CatalogName,
                /*SQLSMALLINT*/Int16 NameLen1,
                [In, MarshalAs(UnmanagedType.LPWStr)] /*SQLCHAR* */ string SchemaName,
                /*SQLSMALLINT*/Int16 NameLen2,
                [In, MarshalAs(UnmanagedType.LPWStr)] /*SQLCHAR* */ string ProcName,
                /*SQLSMALLINT*/Int16 NameLen3,
                [In, MarshalAs(UnmanagedType.LPWStr)] /*SQLCHAR* */ string ColumnName,
                /*SQLSMALLINT*/Int16 NameLen4);
            
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLStatisticsW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string CatalogName,
                                                                   /*SQLSMALLINT*/Int16 NameLen1,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string SchemaName,
                                                                   /*SQLSMALLINT*/Int16 NameLen2,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string TableName,
                                                                   /*SQLSMALLINT*/Int16 NameLen3,
                                                                   /*SQLUSMALLINT*/Int16 Unique,
                                                                   /*SQLUSMALLINT*/Int16 Reserved);
            
            [DllImport(ExternDll.Odbc32, CallingConvention=CallingConvention.Cdecl)]
            static internal extern /*SQLRETURN*/short SQLSpecialColumnsW (
                                                                   /*SQLHSTMT*/HandleRef StatementHandle,
                                                                   /*SQLSMALLINT*/Int16 IdentifierType,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string CatalogName,
                                                                   /*SQLSMALLINT*/Int16 NameLen1,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string SchemaName,
                                                                   /*SQLSMALLINT*/Int16 NameLen2,
                                                                     [In, MarshalAs(UnmanagedType.LPWStr)]
                                                                   /*SQLCHAR* */string TableName,
                                                                   /*SQLSMALLINT*/Int16 NameLen3,
                                                                   /*SQLSMALLINT*/Int16 Scope,
                                                                   /*SQLPOINTER*/ Int16 Nullable);
        }

        //--------------------------------
        // OleDb bucket
        //--------------------------------

        [DllImport(ExternDll.Ole32, CharSet=CharSet.Unicode, PreserveSig=false)]
        static internal extern IntPtr CoCreateInstance(
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid rclsid,
            IntPtr pUnkOuter,
            int dwClsContext,
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid riid);

        [DllImport(ExternDll.Oleaut32, CharSet=CharSet.Unicode, PreserveSig=true)]
        static internal extern int GetErrorInfo(Int32 dwReserved, [Out, MarshalAs(UnmanagedType.Interface)] out IErrorInfo ppIErrorInfo);

        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Unicode, PreserveSig=true)]
        static internal extern int GetUserDefaultLCID();        

        // only using this to clear existing error info with null
        [DllImport(ExternDll.Oleaut32, CharSet=CharSet.Unicode, PreserveSig=false)]
        static internal extern void SetErrorInfo(Int32 dwReserved, IntPtr pIErrorInfo);

        [ComImport, Guid("00000567-0000-0010-8000-00AA006D2EA4"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ADORecordConstruction {

            [PreserveSig]
            int get_Row (
                    [Out, MarshalAs(UnmanagedType.Interface)]
                    out object ppRow);

            //[PreserveSig]
            //int put_Row (
            //        [In, MarshalAs(UnmanagedType.Interface)]
            //        object pRow);

            //[PreserveSig]
            //int put_ParentRow (
            //        [In, MarshalAs(UnmanagedType.Interface)]
            //        object pRow);
        }

        [ComImport, Guid("00000283-0000-0010-8000-00AA006D2EA4"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ADORecordsetConstruction {

            [PreserveSig]
            int get_Rowset (
                    [Out, MarshalAs(UnmanagedType.Interface)]
                    out object ppRowset);

            [PreserveSig]
            int put_Rowset (
                    [In, MarshalAs(UnmanagedType.Interface)]
                    object pRowset);

            [PreserveSig]
            int get_Chapter (
                    [Out]
                    out IntPtr lChapter);

            //[[PreserveSig]
            //iint put_Chapter (
            //         [In]
            //         IntPtr pcRefCount);

            //[[PreserveSig]
            //iint get_RowPosition (
            //         [Out, MarshalAs(UnmanagedType.Interface)]
            //         out object ppRowPos);

            //[[PreserveSig]
            //iint put_RowPosition (
            //         [In, MarshalAs(UnmanagedType.Interface)]
            //         object pRowPos);
        }

        [ComImport, Guid("0C733A8C-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IAccessor {

            [PreserveSig]
            int AddRefAccessor(/*deleted parameters signature*/);

            [PreserveSig]
            int CreateAccessor(
                [In] 
                 int dwAccessorFlags,
                [In] 
                 int cBindings,
                [In, MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Struct)] 
                 tagDBBINDING[] rgBindings,
                [In] 
                 int cbRowSize,
                [Out] 
                  out IntPtr phAccessor,
                [In, Out, MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.I4)] 
                  DBBindStatus[] rgStatus);

            [PreserveSig]
            int GetBindings(/*deleted parameters signature*/);

            [PreserveSig]
            int ReleaseAccessor(
                [In] 
                 IntPtr hAccessor,
                [Out] 
                  out int pcRefCount);
        }

        [ComImport, Guid("0C733A93-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IChapteredRowset {

            [PreserveSig]
            int AddRefChapter(
                             [In] IntPtr hChapter,
                             [Out] out int pcRefCount);

            [PreserveSig]
            int ReleaseChapter(
                              [In] IntPtr hChapter,
                              [Out] out int pcRefCount);
        }

        [ComImport, Guid("0C733A11-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IColumnsInfo {

            [PreserveSig]
            int GetColumnInfo(
                             [Out] 
                             out int pcColumns,
                             [Out] 
                             out IntPtr prgInfo,
                             [Out] 
                             out IntPtr ppStringsBuffer);

            //[PreserveSig]
            //int MapColumnIDs(/* deleted parameters*/);
        }

        [ComImport, Guid("0C733A10-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IColumnsRowset {

            [PreserveSig]
            int GetAvailableColumns(
                                   [Out] 
                                   out IntPtr pcOptColumns,
                                   [Out] 
                                   out IntPtr prgOptColumns);

            [PreserveSig]
            int GetColumnsRowset(
                                [In] 
                                IntPtr pUnkOuter,
                                [In] 
                                IntPtr cOptColumns,
                                [In] 
                                IntPtr rgOptColumns,
                                [In, MarshalAs(UnmanagedType.LPStruct)]
                                Guid riid,
                                [In] 
                                int cPropertySets,
                                [In]
                                IntPtr rgPropertySets,
                                [Out, MarshalAs(UnmanagedType.Interface)] 
                                out IRowset ppColRowset);
        }


        [ComImport, Guid("0C733A26-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ICommandPrepare {

            [PreserveSig]
            int Prepare(
                       [In] 
                       int cExpectedRuns);

            //[PreserveSig]
            //int Unprepare();
        }

        [ComImport, Guid("0C733A79-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ICommandProperties {

            [PreserveSig]
            int GetProperties(
                             [In]
                             int cPropertyIDSets,
                             [In]
                             HandleRef rgPropertyIDSets,
                             [Out]
                             out int pcPropertySets,
                             [Out]
                             out IntPtr prgPropertySets);

            [PreserveSig]
            int SetProperties(
                             [In] 
                             int cPropertySets,
                             [In]
                             HandleRef rgPropertySets);
        }

        [ComImport, Guid("0C733A27-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ICommandText {

            [PreserveSig]
            int Cancel();

            [PreserveSig]
            int Execute(
                       [In] 
                       IntPtr pUnkOuter,
                       [In, MarshalAs(UnmanagedType.LPStruct)]
                       Guid riid,
                       [In] 
                       tagDBPARAMS pDBParams,
                       [Out]
                       out int pcRowsAffected,
                       [Out, MarshalAs(UnmanagedType.Interface)]
                       out object ppRowset);

            [PreserveSig]
            int GetDBSession(/*deleted parameter signature*/);

            [PreserveSig]
            int GetCommandText(/*deleted parameter signature*/);

            [PreserveSig]
            int SetCommandText(
                              [In, MarshalAs(UnmanagedType.LPStruct)]
                              Guid rguidDialect,
                              [In, MarshalAs(UnmanagedType.LPWStr)] 
                              string pwszCommand);
        }

        [ComImport, Guid("0C733A64-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ICommandWithParameters {

            [PreserveSig]
            int GetParameterInfo(/*
                                [Out]
                                out IntPtr pcParams,
                                [Out]
                                out IntPtr prgParamInfo,
                                [Out]
                                out IntPtr ppNamesBuffer*/);

            [PreserveSig]
            int MapParameterNames(/*deleted parameter signature*/);

            [PreserveSig]
            int SetParameterInfo(
                                [In] 
                                IntPtr cParams,
                                [In, MarshalAs(UnmanagedType.LPArray)]
                                int[] rgParamOrdinals, // UNDONE: IntPtr[]
                                [In, MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Struct)]
                                tagDBPARAMBINDINFO[] rgParamBindInfo);
        }

        [ComImport, Guid("2206CCB1-19C1-11D1-89E0-00C04FD7A829"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDataInitialize {

            [PreserveSig]
            int GetDataSource(
                             [In]
                             IntPtr pUnkOuter,
                             [In]
                             int dwClsCtx,
#if USECRYPTO
                             [In, MarshalAs(UnmanagedType.LPArray)] byte[] pwszInitializationString,
#else
                             [In, MarshalAs(UnmanagedType.LPWStr)] string pwszInitializationString,
#endif
                             [In, MarshalAs(UnmanagedType.LPStruct)]
                             Guid riid,
                             [Out, MarshalAs(UnmanagedType.Interface)]
                             out IDBInitialize ppDataSource);

            //[PreserveSig]
            //int GetInitializationString(/*
            //                           [In, MarshalAs(UnmanagedType.Interface)] 
            //                           IDBInitialize pDataSource,
            //                           [In] 
            //                           byte fIncludePassword,
            //                           [Out, MarshalAs(UnmanagedType.LPWStr)] 
            //                          out string pstr*/);

            //[PreserveSig]
            //int CreateDBInstance(/*
            //                    [In] 
            //                    ref Guid clsidProvider,
            //                    [In] 
            //                    IntPtr pUnkOuter,
            //                    [In] 
            //                    int dwClsCtx,
            //                    [In, MarshalAs(UnmanagedType.LPWStr)] 
            //                    string pwszReserved,
            //                    [In] 
            //                    ref Guid riid,
            //                    [Out, MarshalAs(UnmanagedType.Interface)] 
            //                    out IDBInitialize ppDataSource*/);

            //[PreserveSig]
            //int CreateDBInstanceEx(/*deleted parameter signature*/);

            //[PreserveSig]
            //int LoadStringFromStorage(
            //                         [In, MarshalAs(UnmanagedType.LPWStr)] 
            //                         string pwszFileName,
            //                         [Out, MarshalAs(UnmanagedType.LPWStr)] 
            //                         out string ppwszInitializationString);

            //[PreserveSig]
            //int WriteStringToStorage(/*deleted parameter signature*/);
        }

        [ComImport, Guid("0C733A1D-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDBCreateCommand {

            [PreserveSig]
            int CreateCommand(
                             [In] 
                             IntPtr pUnkOuter,
                             [In, MarshalAs(UnmanagedType.LPStruct)]
                             Guid riid,
                             [Out, MarshalAs(UnmanagedType.Interface)]
                             out ICommandText ppCommand);
        }

        [ComImport, Guid("0C733A5D-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDBCreateSession {

            [PreserveSig]
            int CreateSession(
                             [In] 
                             IntPtr pUnkOuter,
                             [In, MarshalAs(UnmanagedType.LPStruct)]
                             Guid riid,
                             [Out, MarshalAs(UnmanagedType.Interface)] 
                             out ISessionProperties ppDBSession);
        }

        [ComImport, Guid("0C733A89-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDBInfo {

            [PreserveSig]
            int GetKeywords([Out, MarshalAs(UnmanagedType.LPWStr)] out string ppwszKeywords);

            [PreserveSig]
            int GetLiteralInfo(
                              [In] 
                              int cLiterals,
                              [In, MarshalAs(UnmanagedType.LPArray)] 
                              int[] rgLiterals,
                              [Out] 
                              out int pcLiteralInfo,
                              [Out] 
                              out IntPtr prgLiteralInfo,
                              [Out] 
                              out IntPtr ppCharBuffer);
        }

        [ComImport, Guid("0C733A8B-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDBInitialize {

            [PreserveSig]
            int Initialize();

            [PreserveSig]
            int Uninitialize();
        }

        [ComImport, Guid("0C733A8A-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDBProperties {

            [PreserveSig]
            int GetProperties(
                             [In]
                             int cPropertyIDSets,
                             [In]
                             HandleRef rgPropertyIDSets,
                             [Out]
                             out int pcPropertySets,
                             [Out]
                             out IntPtr prgPropertySets);

            [PreserveSig]
            int GetPropertyInfo(
                               [In]
                               int cPropertyIDSets,
                               [In]
                               IntPtr rgPropertyIDSets,
                               [Out]
                               out int pcPropertySets,
                               [Out]
                               out IntPtr prgPropertyInfoSets,
                               [Out]
                               out IntPtr ppDescBuffer);

            [PreserveSig]
            int SetProperties(
                             [In] 
                             int cPropertySets,
                             [In]
                             HandleRef rgPropertySets);
        }

        [ComImport, Guid("0C733A7B-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IDBSchemaRowset {

            [PreserveSig]
            int GetRowset(
                         [In]
                         IntPtr pUnkOuter,
                         [In, MarshalAs(UnmanagedType.LPStruct)]
                         Guid rguidSchema,
                         [In]
                         int cRestrictions,
                         [In, MarshalAs(UnmanagedType.LPArray)]
                         object[] rgRestrictions,
                         [In, MarshalAs(UnmanagedType.LPStruct)]
                         Guid riid,
                         [In]
                         int cPropertySets,
                         [In]
                         IntPtr rgPropertySets,
                         [Out, MarshalAs(UnmanagedType.Interface)]
                         out IRowset ppRowset);

            [PreserveSig]
            int GetSchemas(
                          [Out]
                          out int pcSchemas,
                          [Out]
                          out IntPtr rguidSchema,
                          [Out]
                          out IntPtr prgRestrictionSupport);
        }

        [ComImport, Guid("1CF2B120-547D-101B-8E65-08002B2BD119"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IErrorInfo {

            [PreserveSig]
            int GetGUID(/*deleted parameter signature*/);

            [PreserveSig]
            int GetSource(
                         [Out, MarshalAs(UnmanagedType.BStr)]
                         out String pBstrSource);

            [PreserveSig]
            int GetDescription(
                              [Out, MarshalAs(UnmanagedType.BStr)]
                              out String pBstrDescription);

            //[PreserveSig]
            //int GetHelpFile(/*deleted parameter signature*/);

            //[PreserveSig]
            //int GetHelpContext(/*deleted parameter signature*/);
        }

        [ComImport, Guid("0C733A67-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IErrorRecords {

            [PreserveSig]
            int AddErrorRecord(/*deleted parameter signature*/);

            [PreserveSig]
            int GetBasicErrorInfo(/*deleted parameter signature*/);

            [PreserveSig]
            int GetCustomErrorObject(
                                    [In]
                                    int ulRecordNum,
                                    [In, MarshalAs(UnmanagedType.LPStruct)]
                                    Guid riid,
                                    [Out, MarshalAs(UnmanagedType.Interface)]
                                    out ISQLErrorInfo ppObject);

            [PreserveSig]
            int GetErrorInfo(
                            [In]
                            int ulRecordNum,
                            [In]
                            int lcid,
                            [Out, MarshalAs(UnmanagedType.Interface)]
                            out IErrorInfo ppErrorInfo);

            [PreserveSig]
            int GetErrorParameters(/*deleted parameter signature*/);

            [PreserveSig]
            int GetRecordCount(
                              [Out]
                              out int pcRecords);
        }

        [ComImport, Guid("0C733A90-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IMultipleResults {

            [PreserveSig]
            int GetResult(
                         [In] 
                         IntPtr pUnkOuter,
                         [In] 
                         int reserved,
                         [In, MarshalAs(UnmanagedType.LPStruct)]
                         Guid riid,
                         [Out]
                         out int pcRowsAffected,
                         [Out, MarshalAs(UnmanagedType.Interface)] 
                         out object ppRowset);
        }

        [ComImport, Guid("0C733A69-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IOpenRowset {

            [PreserveSig]
            int OpenRowset(
                    [In]
                    IntPtr pUnkOuter,
                    [In]
                    tagDBID pTableID,
                    [In]
                    IntPtr pIndexID,
                    [In, MarshalAs(UnmanagedType.LPStruct)]
                    Guid riid,
                    [In]
                    int cPropertySets,
                    [In]
                    HandleRef rgPropertySets,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                    out object ppRowset);
        }

        /*[ComImport(), Guid("0000010C-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IPersist {

            void GetClassID(
                           [Out] 
                           out Guid classID);
        }*/

        [Guid("0C733AB4-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        [ComImport()]
        internal interface IRow {

            [PreserveSig]
            int GetColumns(
                    [In]
                    IntPtr cColumns,
                    [In, Out, MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Struct)] 
                    tagDBCOLUMNACCESS[] rgColumns);
        
            [PreserveSig]
            int GetSourceRowset(/*
                    [In, MarshalAs(UnmanagedType.LPStruct)]
                    Guid riid,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                    out object ppRowset,
                    [Out]
                    out IntPtr phRow*/);

            [PreserveSig]
            int Open(
                    [In]
                    IntPtr pUnkOuter,
                    [In, MarshalAs(UnmanagedType.LPStruct)]
                    tagDBID pColumnID,
                    [In, MarshalAs(UnmanagedType.LPStruct)]
                    Guid rguidColumnType,
                    [In]
                    Int32 dwBindFlags,
                    [In, MarshalAs(UnmanagedType.LPStruct)]
                    Guid riid,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                    out object ppUnk);
        }

        [Guid("0C733A7C-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        [ComImport()]
        internal interface IRowset {

            [PreserveSig]
            int AddRefRows(/*deleted parameter signature*/);

            [PreserveSig]
            int GetData(
                       [In] 
                       IntPtr hRow,
                       [In] 
                       IntPtr hAccessor,
                       [In] 
                       HandleRef pData);

            [PreserveSig]
            int GetNextRows(
                           [In] 
                           IntPtr hChapter,
                           [In] 
                           int lRowsOffset,
                           [In] 
                           int cRows,
                           [Out] 
                           out int pcRowsObtained,
                           [In]//, Out, MarshalAs(UnmanagedType.LPArray)] 
                           ref IntPtr pprghRows); // UNDONE: ref IntPtr[]


            [PreserveSig]
            int ReleaseRows(
                           [In] 
                           int cRows,
                           [In/*, MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.SysInt)*/] 
                           IntPtr/*[]*/ rghRows,
                           [In]//, MarshalAs(UnmanagedType.LPArray)] 
                           IntPtr/*int[]*/ rgRowOptions,
                           [In]//, Out, MarshalAs(UnmanagedType.LPArray)] 
                           IntPtr/*int[]*/ rgRefCounts,
                           [In]//, Out, MarshalAs(UnmanagedType.LPArray)] 
                           IntPtr/*int[]*/ rgRowStatus);

            //[PreserveSig]
            //int RestartPosition(/* deleted parameters */);
        }

        [Guid("0C733A55-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        [ComImport()]
        internal interface IRowsetInfo {

            [PreserveSig]
            int GetProperties(
                             [In]
                             int cPropertyIDSets,
                             [In]
                             HandleRef rgPropertyIDSets,
                             [Out]
                             out int pcPropertySets,
                             [Out]
                             out IntPtr prgPropertySets);

            [PreserveSig]
            int GetReferencedRowset(
                           [In] 
                           IntPtr iOrdinal,
                           [In, MarshalAs(UnmanagedType.LPStruct)]
                           Guid riid,
                           [Out, MarshalAs(UnmanagedType.Interface)] 
                           out IRowset ppRowset);

            //[PreserveSig]
            //int GetSpecification(/*deleted parameter signature*/);
        }

        [Guid("0C733A85-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        [ComImport()]
        internal interface ISessionProperties {

            //[PreserveSig]
            //int GetProperties(/*deleted parameter signature*/);

            //[PreserveSig]
            //int SetProperties(/*deleted parameter signature*/);
        }


        [Guid("0C733A74-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        [ComImport()]
        internal interface ISQLErrorInfo {

            [PreserveSig]
            int GetSQLInfo(
                          [Out, MarshalAs(UnmanagedType.BStr)]
                          out String pbstrSQLState,
                          [Out]
                          out int plNativeError);
        }

        [Guid("0C733A5F-2A1C-11CE-ADE5-00AA0044773D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [SuppressUnmanagedCodeSecurityAttribute()]
        [ComImport()]
        internal interface ITransactionLocal {

            [PreserveSig]
            int Commit(
                      [In] 
                      int fRetaining,
                      [In] 
                      int grfTC,
                      [In] 
                      int grfRM);

            [PreserveSig]
            int Abort(
                     [In]
                     int pboidReason,
                     [In] 
                     int fRetaining,
                     [In] 
                     int fAsync);

            [PreserveSig]
            int GetTransactionInfo(/*deleted parameter signature*/);

            [PreserveSig]
            int GetOptionsObject(/*deleted parameter signature*/);

            [PreserveSig]
            int StartTransaction(
                                [In] 
                                int isoLevel,
                                [In] 
                                int isoFlags,
                                [In, MarshalAs(UnmanagedType.Interface)]
                                object pOtherOptions,
                                [Out] 
                                out int pulTransactionLevel);
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        internal struct tagDBBINDING {

            public IntPtr iOrdinal;
            public IntPtr obValue;
            public IntPtr obLength;
            public IntPtr obStatus;

            public IntPtr pTypeInfo;
            public IntPtr pObject;
            public IntPtr pBindExt;

            public Int32 dwPart;
            public Int32 dwMemOwner;
            public Int32 eParamIO;

            public IntPtr cbMaxLen;

            public Int32 dwFlags;
            public Int16 wType;
            public byte  bPrecision;
            public byte  bScale;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        internal struct tagDBCOLUMNACCESS {
        
            public IntPtr pData;

            // tagDBID
            public Guid uGuid;
            public Int32 eKind;
            public IntPtr ulPropid; // string ptr or int union

            public IntPtr cbDataLen;

            public Int32 dwStatus;

            public IntPtr cbMaxLen;

            public IntPtr dwReserved;

            public Int16 wType;

            public Byte bPrecision;

            public Byte bScale;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBCOLUMNINFO {

            [MarshalAs(UnmanagedType.LPWStr)]
            public String pwszName = null;

            //[MarshalAs(UnmanagedType.Interface)]
            public IntPtr pTypeInfo = (IntPtr) 0;

            public IntPtr iOrdinal = (IntPtr) 0;

            public Int32 dwFlags = 0;

            public IntPtr ulColumnSize = (IntPtr) 0;

            public Int16 wType = 0;

            public Byte bPrecision = 0;

            public Byte bScale = 0;

            // tagDBID
            public Guid uGuid;
            public Int32 eKind;
            public IntPtr ulPropid;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBID {

            public Guid uGuid;
            public Int32 eKind;
            public IntPtr ulPropid;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBLITERALINFO {

            [MarshalAs(UnmanagedType.LPWStr)]
            public String pwszLiteralValue = null;

            [MarshalAs(UnmanagedType.LPWStr)]
            public String pwszInvalidChars = null;

            [MarshalAs(UnmanagedType.LPWStr)]
            public String pwszInvalidStartingChars = null;

            public Int32 it;

            public Int32 fSupported;

            public Int32 cchMaxLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        internal struct tagDBPARAMBINDINFO {
            public IntPtr pwszDataSourceType;
            public IntPtr pwszName;
            public IntPtr ulParamSize;
            public Int32 dwFlags;
            public Byte bPrecision;
            public Byte bScale;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBPARAMS {
            public IntPtr pData;
            public Int32 cParamSets;
            public IntPtr hAccessor;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBPROP {

            public Int32 dwPropertyID;
            public Int32 dwOptions;
            public Int32 dwStatus;

            // tagDBID
            public Guid uGuid;
            public Int32 eKind;
            public IntPtr ulPropid; // string ptr or int union

            // Variant
            public Int64 vValuePart1;
            public Int64 vValuePart2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBPROPIDSET {

            public IntPtr rgPropertyIDs;

            public Int32 cPropertyIDs;

            public Guid guidPropertySet;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBPROPSET {
            public IntPtr rgProperties;
            public Int32 cProperties;
            public Guid guidPropertySet;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        internal sealed class tagDBPROPINFOSET {
            public IntPtr rgPropertyInfos;
            public Int32 cPropertyInfos;
            public Guid guidPropertySet;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class tagDBPROPINFO {
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pwszDescription;

            public Int32 dwPropertyID;
            public Int32 dwFlags;

            public Int16 vtType;

            //[MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.U1, SizeConst=16)]
            //public byte[] vValues;
            public Int64 vValue1;
            public Int64 vValue2;
        }

        internal enum DBBindStatus {
            OK = 0,
            BADORDINAL = 1,
            UNSUPPORTEDCONVERSION = 2,
            BADBINDINFO = 3,
            BADSTORAGEFLAGS = 4,
            NOINTERFACE = 5,
            MULTIPLESTORAGE = 6
        }

        [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
        sealed internal class OptionStruct {
            public int iSize; // size of struct
            public bool fEncrypt; // bool for encrypt
            public int iRequest; // int to denote what type of request this is
            public uint dwPacketSize;
        }

        [SuppressUnmanagedCodeSecurityAttribute()]
        sealed internal class Dbnetlib {
            // General Dbnetlib functions

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern Int32 ConnectionCheckForData(HandleRef pConnectionObject, out IntPtr bytesAvail, out IntPtr errno);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern Int32 ConnectionClose(HandleRef pConnectionObject, out IntPtr errno);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool ConnectionError(HandleRef pConnectionObject, out IntPtr netErr, out IntPtr netMsg, out IntPtr dberr);

            [CLSCompliantAttribute(false), DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern UInt16 ConnectionObjectSize();

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true)]
            static internal extern Int32 ConnectionOpen(HandleRef pConnectionObject, [MarshalAs(UnmanagedType.LPStr)] string networkname, out IntPtr errno);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool ConnectionOption(HandleRef pConnectionObject, OptionStruct optionStruct);

            [CLSCompliantAttribute(false), DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern UInt16 ConnectionRead(HandleRef pConnectionObject, byte[] buffer, UInt16 readmin, UInt16 readmax, UInt16 timeout, out IntPtr errno);

            [CLSCompliantAttribute(false), DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern UInt16 ConnectionWrite(HandleRef pConnectionObject, byte[] buffer, UInt16 writecount, out IntPtr errno);

            [CLSCompliantAttribute(false), DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern UInt16 ConnectionWriteOOB(HandleRef pConnectionObject, byte[] buffer, UInt16 writecount, out IntPtr errno);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern UIntPtr ConnectionSqlVer(HandleRef pConnectionObject);

            // functions used for SSPI security...

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            static internal extern void ConnectionGetSvrUser(HandleRef pConnectionObject, HandleRef pServerUserName);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool InitSSPIPackage(out UInt32 maxLength);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool TermSSPIPackage();

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool GenClientContext(HandleRef pConnectionObject, byte[] inBuff, UInt32 inBuffLength, byte[] outBuff, ref UInt32 outBuffLen, [MarshalAs(UnmanagedType.Bool)] out bool fDone, HandleRef pServerUserName);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool InitSession(HandleRef pConnectionObject);

            [DllImport(ExternDll.DbNetLib, CallingConvention=CallingConvention.Cdecl)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool TermSession(HandleRef pConnectionObject);
        }

        // 
        // Interfaces for distributed transaction enlistment.
        //
        [
        ComImport(),
        Guid("0141fda5-8fc0-11ce-bd18-204c4f4f5020"),
        InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliantAttribute(false),
        ]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ITransactionExport {
            [CLSCompliantAttribute(false)] void Export ([MarshalAs(UnmanagedType.Interface), In] ITransaction transaction, 
                [In, Out] ref UInt32 transactionCookie);
            [CLSCompliantAttribute(false)] void GetTransactionCookie ([MarshalAs(UnmanagedType.Interface), In] ITransaction transaction, 
                [In] UInt32 transactionCookieLength,
                [MarshalAs(UnmanagedType.LPArray), Out] byte[] transactionCookie,
                [In, Out] ref UInt32 pTransactionCookieLength);
            [CLSCompliantAttribute(false)] void RemoteGetTransactionCookie ([MarshalAs(UnmanagedType.Interface), In] ITransaction transaction, 
                [In, Out] ref UInt32 transactionCookieLength,
                [In] UInt32 pTransactionCookieLength,
                [In, Out] [MarshalAs(UnmanagedType.LPArray)] byte[] transactionCookie);
        }

        [
        ComImport,
        Guid("E1CF9B53-8745-11ce-A9BA-00AA006C3706"),
        InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliantAttribute(false), 
        ]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ITransactionExportFactory {
            void GetRemoteClassId ([Out] Guid clsid);
            [CLSCompliantAttribute(false)] void Create ([In] UInt32 DTCLength, 
                [MarshalAs(UnmanagedType.LPArray), In] byte[] DTCAddr, 
                [MarshalAs(UnmanagedType.Interface), In, Out] ref ITransactionExport export);
        }

        [
        ComImport,
        Guid("c23cc370-87ef-11ce-8081-0080c758527e"),
        InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
        ]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface IGetDispenser {
            void GetDispenser ([In, MarshalAs(UnmanagedType.LPStruct)] Guid iid,
                [MarshalAs(UnmanagedType.Interface), In, Out] ref object Object);
        }

        [
        ComImport,
        Guid("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD"),
        InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
        ]
        [SuppressUnmanagedCodeSecurityAttribute()]
        internal interface ITransactionOutcomeEvents {
            void Committed([MarshalAs(UnmanagedType.Bool)] bool fRetaining,
                           IntPtr pNewUOW,
                           Int32 hResult);
            void Aborted(IntPtr pBoidReason,
                         [MarshalAs(UnmanagedType.Bool)] bool fRetaining,
                         IntPtr pNewUOW,
                         Int32 hResult);
            void HeuristicDecision(UInt32 decision,
                                   IntPtr pBoidReason,
                                   Int32 hResult);
            void Indoubt();
        }

        [SuppressUnmanagedCodeSecurityAttribute()]
        sealed internal class Advapi32 {
            [DllImport("Advapi32.dll")]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool OpenThreadToken(IntPtr threadHandle, UInt32 desiredAccess, 
                                                        [MarshalAs(UnmanagedType.Bool), In] bool openAsSelf, out IntPtr tokenHandle);

            [DllImport("Advapi32.dll")]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool OpenProcessToken(IntPtr processHandle, UInt32 desiredAccess, out IntPtr tokenHandle); 

            [DllImport("Advapi32.dll", SetLastError=true)]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool GetTokenInformation(IntPtr tokenHandle, Int32 token_class,
                            IntPtr tokenStruct, Int32 tokenInformationLength, ref Int32 tokenString);

            [DllImport("Advapi32.dll")]
            [return:MarshalAs(UnmanagedType.Bool)]
            static internal extern bool EqualSid(IntPtr sid1, IntPtr sid2);
        }

        /*
        typedef struct _TOKEN_USER {
          SID_AND_ATTRIBUTES User;
        } TOKEN_USER, *PTOKEN_USER;
        typedef struct _SID_AND_ATTRIBUTES {
          PSID Sid;
          DWORD Attributes;
        } SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;
        typedef struct  SID;

        BOOL EqualSid(
          PSID pSid1, 
          PSID pSid2
        );

        BOOL GetTokenInformation(
          [in]  HANDLE TokenHandle, 
          [in]  TOKEN_INFORMATION_CLASS TokenInformationClass, 
          [out] LPVOID TokenInformation, 
          [in]  DWORD TokenInformationLength, 
          [out] PDWORD ReturnLength
        );

        typedef enum _TOKEN_INFORMATION_CLASS {
            TokenUser = 1,
            ...
        }

        Value Meaning 
        NULL The function returns the required buffer size. No data is stored in the buffer. 

        TokenUser The buffer receives a TOKEN_USER structure containing the token's user account. 

        } TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

        typedef void *HANDLE;

        TokenHandle 
        [in] Handle to an access token from which information is retrieved. If TokenInformationClass specifies TokenSource, the handle must have TOKEN_QUERY_SOURCE access. For all other TokenInformationClass values, the handle must have TOKEN_QUERY access. 
        TokenInformationClass 
        [in] Specifies a value from the TOKEN_INFORMATION_CLASS enumerated type to identify the type of information the function retrieves. 
        TokenInformation 
        [out] Pointer to a buffer the function fills with the requested information. The structure put into this buffer depends upon the type of information specified by the TokenInformationClass parameter, as shown in the following table. 
        TokenInformationLength 
        [in] Specifies the size, in bytes, of the buffer pointed to by the TokenInformation parameter. If TokenInformation is NULL, this parameter must be zero. 
        ReturnLength 
        [out] Pointer to a variable that receives the number of bytes needed for the buffer pointed to by the TokenInformation parameter. If this value is larger than the value specified in the TokenInformationLength parameter, the function fails and stores no data in the buffer. 
        If the value of the TokenInformationClass parameter is TokenDefaultDacl and the token has no default DACL, the function sets the variable pointed to by ReturnLength to sizeof(TOKEN_DEFAULT_DACL) and sets the DefaultDacl member of the TOKEN_DEFAULT_DACL structure to NULL.

        Return Values
        If the function succeeds, the return value is nonzero.

        If the function fails, the return value is zero. To get extended error information, call GetLastError.
        */
        /*
        XACTUOW is defined as a BOID, and a BOID is defined as:
        typedef struct BOID
        {
        byte rgb[ 16 ];
        } 	BOID;

        However, doc's for Committed and Aborted say its null.  For Heuristic the BOID 
        contains why the transaction was Heuristically decided, which we do not care about.

        We do not care about the arguments to Committed, Aborted, or HeuristicDecision.
        The outcome of the transaction can be in-doubt if the connection between the MSDTC proxy 
        and the MSDTC TM was broken after the proxy asked the transaction manager to commit or 
        abort a transaction but before the transaction manager's response to the commit or abort 
        was received by the proxy. Note: Receiving this method call is not the same as the state 
        of the transaction being in-doubt.

        MIDL_INTERFACE("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD")
        ITransactionOutcomeEvents : public IUnknown
        {
        public:
            virtual HRESULT STDMETHODCALLTYPE Committed( 
                [in] BOOL fRetaining,
                [unique][in] XACTUOW *pNewUOW,
                [in] HRESULT hr) = 0;
            
            virtual HRESULT STDMETHODCALLTYPE Aborted( 
                [unique][in] BOID *pboidReason,
                [in] BOOL fRetaining,
                [unique][in] XACTUOW *pNewUOW,
                [in] HRESULT hr) = 0;
            
            virtual HRESULT STDMETHODCALLTYPE HeuristicDecision( 
                [in] DWORD dwDecision,
                [unique][in] BOID *pboidReason,
                [in] HRESULT hr) = 0;
            
            virtual HRESULT STDMETHODCALLTYPE Indoubt( void) = 0;            
        };
        */
        /*
        [object,uuid(0141fda5-8fc0-11ce-bd18-204c4f4f5020),pointer_default(unique)]
        interface ITransactionExport : IUnknown {
            HRESULT Export
            (
                [In]  IUnknown* punkTransaction,
                [Out] ULONG*    pcbTransactionCookie
            );
            [local]
            HRESULT GetTransactionCookie
            (
                [In] IUnknown* punkTransaction,
                [In] ULONG cbTransactionCookie,
                [Out, size_is(cbTransactionCookie)] byte* rgbTransactionCookie,
                [Out] ULONG* pcbUsed
            );
            [call_as(GetTransactionCookie)]
            HRESULT RemoteGetTransactionCookie
            (
                [In]  IUnknown* punkTransaction,
                [Out] ULONG*    pcbUsed,
                [In]  ULONG     cbTransactionCookie,
                [Out, size_is(cbTransactionCookie), length_is(*pcbUsed)] byte* rgbTransactionCookie
            );
        }
        */
        /*
        [object,uuid(E1CF9B53-8745-11ce-A9BA-00AA006C3706),pointer_default(unique)]
        interface ITransactionExportFactory : IUnknown {
            HRESULT GetRemoteClassId
            (
                [In, Out] CLSID* pclsid
            );
            HRESULT Create
            (
                [In] ULONG cbWhereabouts,
                [In, size_is(cbWhereabouts)] byte* rgbWhereabouts,
                [In, Out] ITransactionExport** ppExport
            );
        }
        */
        /*
        [   uuid(c23cc370-87ef-11ce-8081-0080c758527e),
        object, pointer_default(unique)
        ]
        interface IGetDispenser : IUnknown {
            HRESULT GetDispenser
            (
                [In]              REFIID                 iid, 
                [Out,iid_is(iid)] void**                 ppvObject
            );
        };
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\binarynode.cs ===
//------------------------------------------------------------------------------
// <copyright file="BinaryNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;

    internal class BinaryNode : ExpressionNode {
        internal DataTable table;    // need for locale info
        internal int op;

        internal ExpressionNode left;
        internal ExpressionNode right;

        internal BinaryNode(int op, ExpressionNode left, ExpressionNode right) {
            this.op = op;
            this.left = left;
            this.right = right;
        }

        internal override void Bind(DataTable table, ArrayList list) {
            left.Bind(table, list);
            right.Bind(table, list);
            this.table = table;
        }

        internal override object Eval() {
            return Eval(null, DataRowVersion.Default);
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            return EvalBinaryOp(op, left, right, row, version, null);
        }

        internal override object Eval(int[] recordNos) {
            return EvalBinaryOp(op, left, right, null, DataRowVersion.Default, recordNos);
        }

        internal override bool IsConstant() {
            // CONSIDER: for string operations we depend on the local info
            return(left.IsConstant() && right.IsConstant());
        }

        internal override bool IsTableConstant() {
            return(left.IsTableConstant() && right.IsTableConstant());
        }
        internal override bool HasLocalAggregate() {
            return(left.HasLocalAggregate() || right.HasLocalAggregate());
        }

        internal override bool DependsOn(DataColumn column) {
            if (left.DependsOn(column))
                return true;
            return right.DependsOn(column);
        }

        internal override ExpressionNode Optimize() {
            left = left.Optimize();

            if (op == Operators.Is) {
                // only 'Is Null' or 'Is Not Null' are valid 
                if (right is UnaryNode) {
                    UnaryNode un = (UnaryNode)right;
                    if (un.op != Operators.Not) {
                        throw ExprException.InvalidIsSyntax();
                    }
                    op = Operators.IsNot;
                    right = un.right;
                }
                if (right is ZeroOpNode) {
                    if (((ZeroOpNode)right).op != Operators.Null) {
                        throw ExprException.InvalidIsSyntax();
                    }
                }
                else {
                    throw ExprException.InvalidIsSyntax();
                }
            }
            else {
                right = right.Optimize();
            }

#if DEBUG
            if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("Optimizing " + this.ToString());
#endif

            if (this.IsConstant()) {

                object val = this.Eval();
#if DEBUG
                if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("the node value is " + val.ToString());
#endif

                if (val == DBNull.Value) {
                    return new ZeroOpNode(Operators.Null);
                }

                if (val is bool) {
                    if ((bool)val)
                        return new ZeroOpNode(Operators.True);
                    else
                        return new ZeroOpNode(Operators.False);
                }
#if DEBUG
                if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine(val.GetType().ToString());
#endif
                return new ConstNode(ValueType.Object, val, false);
            }
            else
                return this;
        }

        public override string ToString() {
            string str = left.ToString() + " " + Operators.ToString(op) + " " + right.ToString();
            return str;
        }

        internal void SetTypeMismatchError(int op, Type left, Type right) {
            throw ExprException.TypeMismatchInBinop(op, left, right);
        }

        private static object Eval(ExpressionNode expr, DataRow row, DataRowVersion version, int[] recordNos) {
            if (recordNos == null) {
                return expr.Eval(row, version);
            }
            else {
                return expr.Eval(recordNos);
            }
        }

        internal long Compare(object vLeft, object vRight, Type type, int op) {
            //Debug.WriteLine("Compare '" + vLeft.ToString() + "' to '" + vRight.ToString() + "' , type " + type.ToString());
            long result = 0;
            bool typeMismatch = false;

            try {
                if (type == typeof(UInt64)) {
                    Decimal dec = Convert.ToDecimal(vLeft) - Convert.ToDecimal(vRight);
                    if (dec == 0)
                        result = 0;
                    else if (dec > 0)
                        result = 1;
                    else result = -1;
                }
                else if (type == typeof(char)) {
                    result = Convert.ToInt32(vLeft) - Convert.ToInt32(Convert.ToChar(vRight));
                }
                else if (ExpressionNode.IsInteger(type)) {
                    Int64 a = Convert.ToInt64(vLeft);
                    Int64 b = Convert.ToInt64(vRight);
                    checked {result = a - b;}
                }
                else if (type == typeof(Decimal)) {
                    Decimal a = Convert.ToDecimal(vLeft);
                    Decimal b = Convert.ToDecimal(vRight);
                    result = Decimal.Compare(a, b);
                }
                else if (type == typeof(double)) {
                    Double a = Convert.ToDouble(vLeft);
                    Double b = Convert.ToDouble(vRight);
                    double d;
                    checked {d = a - b;}
                    if (d == 0)
                        result = 0;
                    else if (d > 0)
                        result = 1;
                    else result = -1;
                }
                else if (type == typeof(Single)) {
                    Single a = Convert.ToSingle(vLeft);
                    Single b = Convert.ToSingle(vRight);
                    Single d;
                    checked {d = a - b;}
                    if (d == 0)
                        result = 0;
                    else if (d > 0)
                        result = 1;
                    else result = -1;
                }
                else if (type == typeof(DateTime)) {
                    //Debug.WriteLine("Compare '" + vLeft.ToString() + "' to '" + vRight.ToString() + "'");
                    result = DateTime.Compare(Convert.ToDateTime(vLeft), Convert.ToDateTime(vRight));
                    //Debug.WriteLine("result = " + result.ToString());
                }
                else if (type == typeof(string)) {
                    //Debug.WriteLine("Compare '" + vLeft.ToString() + "' to '" + vRight.ToString() + "'");
                    result = table.Compare(Convert.ToString(vLeft), Convert.ToString(vRight), CompareOptions.None);
                    //Debug.WriteLine("result = " + result.ToString());
                }
                else if (type == typeof(Guid)) {
                    //Debug.WriteLine("Compare '" + vLeft.ToString() + "' to '" + vRight.ToString() + "'");
                    result =((Guid)vLeft).CompareTo((Guid) vRight);
                    //Debug.WriteLine("result = " + result.ToString());
                }
                else if (type == typeof(bool)) {
                    if (op == Operators.EqualTo || op == Operators.NotEqual) {
                        object bLeft = DataExpression.ToBoolean(vLeft);
                        object bRight = DataExpression.ToBoolean(vRight);
                        result = Convert.ToInt32(bLeft) - Convert.ToInt32(bRight);
                    }
                    else {
                        typeMismatch = true;                        
                    }
                }
                else {
                    typeMismatch = true;
                }
            }
            catch {
                SetTypeMismatchError(op, vLeft.GetType(), vRight.GetType());
            }

            if (typeMismatch) {
                SetTypeMismatchError(op, vLeft.GetType(), vRight.GetType());
            }

            return result;
        }

        private object EvalBinaryOp(int op, ExpressionNode left, ExpressionNode right, DataRow row, DataRowVersion version, int[] recordNos) {
            object vLeft;
            object vRight;
            bool isLConst, isRConst;
            Type result;

            /*
            special case for OR and AND operators: we don't want to evaluate
            both right and left operands, because we can shortcut :
                for OR  operator If one of the operands is true the result is true
                for AND operator If one of rhe operands is flase the result is false
            CONSIDER : in the shortcut case do we want to type-check the other operand?
            */

            if (op != Operators.Or && op != Operators.And && op != Operators.In && op != Operators.Is && op != Operators.IsNot) {
                vLeft  = BinaryNode.Eval(left, row, version, recordNos);
                vRight = BinaryNode.Eval(right, row, version, recordNos);
                isLConst = (left is ConstNode);
                isRConst = (right is ConstNode);

                //    special case of handling NULLS, currently only OR operator can work with NULLS
                if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                    return DBNull.Value;

                result = ResultType(vLeft.GetType(), vRight.GetType(), isLConst, isRConst, op);

                if (result == null)
                    SetTypeMismatchError(op, vLeft.GetType(), vRight.GetType());

#if DEBUG
                if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("Result of the operator: " + result.Name);
#endif
            }
            else {
                vLeft = vRight = DBNull.Value;
                result = null;
            }

            object value = DBNull.Value;
            bool typeMismatch = false;

            try {
                switch (op) {
                    case Operators.Plus:
                        if (result == typeof(Byte)) {
                            value = Convert.ToByte(Convert.ToByte(vLeft) + Convert.ToByte(vRight));
                        }
                        else if (result == typeof(SByte)) {
                            value = Convert.ToSByte(Convert.ToSByte(vLeft) + Convert.ToSByte(vRight));
                        }
                        else if (result == typeof(Int16)) {
                            value = Convert.ToInt16(Convert.ToInt16(vLeft) + Convert.ToInt16(vRight));
                        }
                        else if (result == typeof(UInt16)) {
                            value = Convert.ToUInt16(Convert.ToUInt16(vLeft) + Convert.ToUInt16(vRight));
                        }
                        else if (result == typeof(Int32)) {
                            Int32 a = Convert.ToInt32(vLeft);
                            Int32 b = Convert.ToInt32(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(UInt32)) {
                            UInt32 a = Convert.ToUInt32(vLeft);
                            UInt32 b = Convert.ToUInt32(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(UInt64)) {
                            UInt64 a = Convert.ToUInt64(vLeft);
                            UInt64 b = Convert.ToUInt64(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(Int64)) {
                            Int64 a = Convert.ToInt64(vLeft);
                            Int64 b = Convert.ToInt64(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(Decimal)) {
                            Decimal a = Convert.ToDecimal(vLeft);
                            Decimal b = Convert.ToDecimal(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(Single)) {
                            Single a = Convert.ToSingle(vLeft);
                            Single b = Convert.ToSingle(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(double)) {
                            Double a = Convert.ToDouble(vLeft);
                            Double b = Convert.ToDouble(vRight);
                            checked {value = a + b;}
                        }
                        else if (result == typeof(string) || result == typeof(char)) {
                            value = Convert.ToString(vLeft) + Convert.ToString(vRight);
                        }
                        else if (result == typeof(DateTime)) {
                            // one of the operands should be a DateTime, and an other a TimeSpan

                            if (vLeft is TimeSpan && vRight is DateTime) {
                                value = (DateTime)vRight + (TimeSpan)vLeft;
                            }
                            else if (vLeft is DateTime && vRight is TimeSpan) {
                                value = (DateTime)vLeft + (TimeSpan)vRight;
                            }
                            else {
                                typeMismatch = true;
                            }
                        }
                        else if (result == typeof(TimeSpan)) {
                            value = (TimeSpan)vLeft + (TimeSpan)vRight;
                        }
                        else {
                            typeMismatch = true;
                        }
                        break;

                    case Operators.Minus:
                        if (result == typeof(Byte)) {
                            value = Convert.ToByte(Convert.ToByte(vLeft) - Convert.ToByte(vRight));
                        }
                        else if (result == typeof(SByte)) {
                            value = Convert.ToSByte(Convert.ToSByte(vLeft) - Convert.ToSByte(vRight));
                        }
                        else if (result == typeof(Int16)) {
                            value = Convert.ToInt16(Convert.ToInt16(vLeft) - Convert.ToInt16(vRight));
                        }
                        else if (result == typeof(UInt16)) {
                            value = Convert.ToUInt16(Convert.ToUInt16(vLeft) - Convert.ToUInt16(vRight));
                        }
                        else if (result == typeof(Int32)) {
                            Int32 a = Convert.ToInt32(vLeft);
                            Int32 b = Convert.ToInt32(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(UInt32)) {
                            UInt32 a = Convert.ToUInt32(vLeft);
                            UInt32 b = Convert.ToUInt32(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(Int64)) {
                            Int64 a = Convert.ToInt64(vLeft);
                            Int64 b = Convert.ToInt64(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(UInt64)) {
                            UInt64 a = Convert.ToUInt64(vLeft);
                            UInt64 b = Convert.ToUInt64(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(Decimal)) {
                            Decimal a = Convert.ToDecimal(vLeft);
                            Decimal b = Convert.ToDecimal(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(Single)) {
                            Single a = Convert.ToSingle(vLeft);
                            Single b = Convert.ToSingle(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(double)) {
                            Double a = Convert.ToDouble(vLeft);
                            Double b = Convert.ToDouble(vRight);
                            checked {value = a - b;}
                        }
                        else if (result == typeof(DateTime)) {
                            value = (DateTime)vLeft - (TimeSpan)vRight;
                        }
                        else if (result == typeof(TimeSpan)) {
                            if (vLeft is DateTime) {
                                value = (DateTime)vLeft - (DateTime)vRight;
                            }
                            else
                                value = (TimeSpan)vLeft - (TimeSpan)vRight;
                        }
                        else {
                            typeMismatch = true;
                        }
                        break;

                    case Operators.Multiply:
                        if (result == typeof(Byte)) {
                            value = Convert.ToByte(Convert.ToByte(vLeft) * Convert.ToByte(vRight));
                        }
                        else if (result == typeof(SByte)) {
                            value = Convert.ToSByte(Convert.ToSByte(vLeft) * Convert.ToSByte(vRight));
                        }
                        else if (result == typeof(Int16)) {
                            value = Convert.ToInt16(Convert.ToInt16(vLeft) * Convert.ToInt16(vRight));
                        }
                        else if (result == typeof(UInt16)) {
                            value = Convert.ToUInt16(Convert.ToUInt16(vLeft) * Convert.ToUInt16(vRight));
                        }
                        else if (result == typeof(Int32)) {
                            Int32 a = Convert.ToInt32(vLeft);
                            Int32 b = Convert.ToInt32(vRight);
                            checked {value = a * b;}
                        }
                        else if (result == typeof(UInt32)) {
                            UInt32 a = Convert.ToUInt32(vLeft);
                            UInt32 b = Convert.ToUInt32(vRight);
                            checked {value = a * b;}
                        }
                        else if (result == typeof(Int64)) {
                            Int64 a = Convert.ToInt64(vLeft);
                            Int64 b = Convert.ToInt64(vRight);
                            checked {value = a * b;}
                        }
                        else if (result == typeof(UInt64)) {
                            UInt64 a = Convert.ToUInt64(vLeft);
                            UInt64 b = Convert.ToUInt64(vRight);
                            checked {value = a * b;}
                        }
                        else if (result == typeof(Decimal)) {
                            Decimal a = Convert.ToDecimal(vLeft);
                            Decimal b = Convert.ToDecimal(vRight);
                            checked {value = a * b;}
                        }
                        else if (result == typeof(Single)) {
                            Single a = Convert.ToSingle(vLeft);
                            Single b = Convert.ToSingle(vRight);
                            checked {value = a * b;}
                        }
                        else if (result == typeof(double)) {
                            Double a = Convert.ToDouble(vLeft);
                            Double b = Convert.ToDouble(vRight);
                            checked {value = a * b;}
                        }
                        else {
                            typeMismatch = true;
                        }
                        break;

                    case Operators.Divide:
                        if (result == typeof(Byte)) {
                            value = Convert.ToByte(Convert.ToByte(vLeft) / Convert.ToByte(vRight));
                        }
                        else if (result == typeof(SByte)) {
                            value = Convert.ToSByte(Convert.ToSByte(vLeft) / Convert.ToSByte(vRight));
                        }
                        else if (result == typeof(Int16)) {
                            value = Convert.ToInt16(Convert.ToInt16(vLeft) / Convert.ToInt16(vRight));
                        }
                        else if (result == typeof(UInt16)) {
                            value = Convert.ToUInt16(Convert.ToUInt16(vLeft) / Convert.ToUInt16(vRight));
                        }
                        else if (result == typeof(Int32)) {
                            Int32 a = Convert.ToInt32(vLeft);
                            Int32 b = Convert.ToInt32(vRight);
                            checked {value = a / b;}
                        }
                        else if (result == typeof(UInt32)) {
                            UInt32 a = Convert.ToUInt32(vLeft);
                            UInt32 b = Convert.ToUInt32(vRight);
                            checked {value = a / b;}
                        }
                        else if (result == typeof(UInt64)) {
                            UInt64 a = Convert.ToUInt64(vLeft);
                            UInt64 b = Convert.ToUInt64(vRight);
                            checked {value = a / b;}
                        }
                        else if (result == typeof(Int64)) {
                            Int64 a = Convert.ToInt64(vLeft);
                            Int64 b = Convert.ToInt64(vRight);
                            checked {value = a / b;}
                        }
                        else if (result == typeof(Decimal)) {
                            Decimal a = Convert.ToDecimal(vLeft);
                            Decimal b = Convert.ToDecimal(vRight);
                            checked {value = a / b;}
                        }
                        else if (result == typeof(Single)) {
                            Single a = Convert.ToSingle(vLeft);
                            Single b = Convert.ToSingle(vRight);
                            checked {value = a / b;}
                        }
                        else if (result == typeof(double)) {
                            Double a = Convert.ToDouble(vLeft);
                            Double b = Convert.ToDouble(vRight);
                            checked {value = a / b;}
                        }
                        else {
                            typeMismatch = true;
                        }
                        break;

                    case Operators.EqualTo:
                        if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                            return DBNull.Value;
                        return(0 == Compare (vLeft, vRight, result, Operators.EqualTo));

                    case Operators.GreaterThen:
                        if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                            return DBNull.Value;
                        return(0 < Compare (vLeft, vRight, result, op));

                    case Operators.LessThen:
                        if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                            return DBNull.Value;
                        return(0 > Compare (vLeft, vRight, result, op));

                    case Operators.GreaterOrEqual:
                        if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                            return DBNull.Value;
                        return(0 <= Compare (vLeft, vRight, result, op));

                    case Operators.LessOrEqual:
                        if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                            return DBNull.Value;
                        return(0 >= Compare (vLeft, vRight, result, op));

                    case Operators.NotEqual:
                        if ((vLeft == DBNull.Value) || (vRight == DBNull.Value))
                            return DBNull.Value;
                        return(0 != Compare (vLeft, vRight, result, op));

                    case Operators.Is:
                        vLeft  = BinaryNode.Eval(left, row, version, recordNos);
                        if (vLeft == DBNull.Value) {
                            return true;
                        }
                        return false;

                    case Operators.IsNot:
                        vLeft  = BinaryNode.Eval(left, row, version, recordNos);
                        if (vLeft == DBNull.Value) {
                            return false;
                        }
                        return true;

                    case Operators.And:
                        /*
                        special case evaluating of the AND operator: we don't want to evaluate
                        both right and left operands, because we can shortcut :
                            If one of the operands is flase the result is false
                        CONSIDER : in the shortcut case do we want to type-check the other operand?
                        */

                        vLeft  = BinaryNode.Eval(left, row, version, recordNos);

                        if (vLeft == DBNull.Value)
                            return DBNull.Value;

                        if (!(vLeft is bool)) {
                            vRight = BinaryNode.Eval(right, row, version, recordNos);
                            typeMismatch = true;
                            break;
                        }

                        if ((bool)vLeft == false) {
                            value = false;
                            break;
                        }

                        vRight = BinaryNode.Eval(right, row, version, recordNos);

                        if (vRight == DBNull.Value)
                            return DBNull.Value;

                        if (!(vRight is bool)) {
                            typeMismatch = true;
                            break;
                        }

                        value = (bool)vRight;
                        break;

                    case Operators.Or:
                        /*
                        special case evaluating the OR operator: we don't want to evaluate
                        both right and left operands, because we can shortcut :
                            If one of the operands is true the result is true
                        CONSIDER : in the shortcut case do we want to type-check the other operand?
                        */
                        vLeft = BinaryNode.Eval(left, row, version, recordNos);
                        if (vLeft != DBNull.Value) {
                            if (!(vLeft is bool)) {
                                vRight = BinaryNode.Eval(right, row, version, recordNos);
                                typeMismatch = true;
                                break;
                            }

                            if ((bool)vLeft == true) {
                                value = true;
                                break;
                            }
                        }

                        vRight = BinaryNode.Eval(right, row, version, recordNos);
                        if (vRight == DBNull.Value)
                            return vLeft;

                        if (vLeft == DBNull.Value)
                            return vRight;

                        if (!(vRight is bool)) {
                            typeMismatch = true;
                            break;
                        }

                        value = (bool)vRight;
                        break;

                    case Operators.Modulo:
                        if (ExpressionNode.IsInteger(result)) {
                            if (result == typeof(UInt64)) {
                                value = Convert.ToUInt64(vLeft) % Convert.ToUInt64(vRight);
                            }
                            else {
                                value = Convert.ToInt64(vLeft) % Convert.ToInt64(vRight);
                                value = Convert.ChangeType(value, result);
                            }
                        }
                        else {
                            typeMismatch = true;
                        }
                        break;

                    case Operators.In:
                        /*
                        special case evaluating of the IN operator: the right have to be IN function node
                        */

#if DEBUG
                        if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("Evaluating IN operator..");
#endif

                        if (!(right is FunctionNode)) {
                            // this is more like an Assert: should never happens, so we do not care about "nice" Exseptions
                            throw ExprException.InWithoutParentheses();
                        }

                        vLeft = BinaryNode.Eval(left, row, version, recordNos);

                        if (vLeft == DBNull.Value)
                            return DBNull.Value;

                        /* validate IN parameters : must all be constant expressions */

                        value = false;

                        FunctionNode into = (FunctionNode)right;

                        for (int i = 0; i < into.argumentCount; i++) {
                            vRight = into.arguments[i].Eval();

#if DEBUG
                            if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("Evaluate IN parameter " + into.arguments[i].ToString() + " = " + vRight.ToString());
#endif

                            if (vRight == DBNull.Value)
                                continue;
                            Debug.Assert((vLeft != DBNull.Value) && (vRight != DBNull.Value), "Imposible..");

                            result = vLeft.GetType();

                            if (0 == Compare (vLeft, vRight, result, Operators.EqualTo)) {
                                value = true;
                                break;
                            }
                        }
                        break;

                    default:
#if DEBUG
                        if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("NYI : " + Operators.ToString(op));
#endif
                        throw ExprException.UnsupportedOperator(op);
                }
            }
            catch (OverflowException) {
                throw ExprException.Overflow(result);
            }
            if (typeMismatch) {
                SetTypeMismatchError(op, vLeft.GetType(), vRight.GetType());
            }

            return value;
        }

        // Data type precedence rules specify which data type is converted to the other. 
        // The data type with the lower precedence is converted to the data type with the higher precedence. 
        // If the conversion is not a supported implicit conversion, an error is returned. 
        // When both operand expressions have the same data type, the result of the operation has that data type.
        // This is the precedence order for the DataSet numeric data types: 

        private enum DataTypePrecedence {
            DateTime = 14, // (highest)
            TimeSpan = 13,
            Double = 12,
            Single = 11,
            Decimal = 10,
            UInt64 = 8,
            Int64 = 7,
            UInt32 = 6,
            Int32 = 5,
            UInt16 = 4,
            Int16 = 3,
            Byte = 2,
            SByte = 1,

            Error = 0,


            Boolean = -5,
            String = -6,
            Char = -7, 
        }

        private DataTypePrecedence GetPrecedence(Type dataType) {
            switch (Type.GetTypeCode(dataType)) {
                case TypeCode.Object:
                    if (dataType == typeof(TimeSpan))
                        return DataTypePrecedence.TimeSpan;

                    return DataTypePrecedence.Error;

                case TypeCode.SByte:     return DataTypePrecedence.SByte;
                case TypeCode.Byte:      return DataTypePrecedence.Byte;
                case TypeCode.Int16:     return DataTypePrecedence.Int16;
                case TypeCode.UInt16:    return DataTypePrecedence.UInt16;
                case TypeCode.Int32:     return DataTypePrecedence.Int32;
                case TypeCode.UInt32:    return DataTypePrecedence.UInt32;
                case TypeCode.Int64:     return DataTypePrecedence.Int64;
                case TypeCode.UInt64:    return DataTypePrecedence.UInt64;
                case TypeCode.Single:    return DataTypePrecedence.Single;
                case TypeCode.Double:    return DataTypePrecedence.Double;
                case TypeCode.Decimal:   return DataTypePrecedence.Decimal;

                case TypeCode.Boolean:   return DataTypePrecedence.Boolean;
                case TypeCode.String:    return DataTypePrecedence.String;
                case TypeCode.Char:      return DataTypePrecedence.Char;

                case TypeCode.DateTime:  return DataTypePrecedence.DateTime;
            }

            return DataTypePrecedence.Error;
        }

        private static Type GetType(DataTypePrecedence code) {
            switch (code) {
                case DataTypePrecedence.Error:      return null;
                case DataTypePrecedence.SByte:      return typeof(SByte);
                case DataTypePrecedence.Byte:       return typeof(Byte);
                case DataTypePrecedence.Int16:      return typeof(Int16);
                case DataTypePrecedence.UInt16:     return typeof(UInt16);
                case DataTypePrecedence.Int32:      return typeof(Int32);
                case DataTypePrecedence.UInt32:     return typeof(UInt32);
                case DataTypePrecedence.Int64:      return typeof(Int64);
                case DataTypePrecedence.UInt64:     return typeof(UInt64);
                case DataTypePrecedence.Decimal:    return typeof(Decimal);
                case DataTypePrecedence.Single:     return typeof(Single);
                case DataTypePrecedence.Double:     return typeof(Double);

                case DataTypePrecedence.Boolean:    return typeof(Boolean);
                case DataTypePrecedence.String:     return typeof(String);
                case DataTypePrecedence.Char:       return typeof(Char);

                case DataTypePrecedence.DateTime:   return typeof(DateTime);
                case DataTypePrecedence.TimeSpan:   return typeof(TimeSpan);
            }

            Debug.Assert(false, "Invalid (unmapped) precedence " + code.ToString());
            return null;
        }

        private bool IsMixed(Type left, Type right) {
            return ((IsSigned(left) && IsUnsigned(right)) ||
                    (IsUnsigned(left) && IsSigned(right)));
        }

        internal Type ResultType(Type left, Type right, bool lc, bool rc, int op) {
            if ((left == typeof(System.Guid)) && (right == typeof(System.Guid)) && Operators.IsRelational(op))
                return left;

            if ((left == typeof(System.String)) && (right == typeof(System.Guid)) && Operators.IsRelational(op))
                return left;

            if ((left == typeof(System.Guid)) && (right == typeof(System.String)) && Operators.IsRelational(op))
                return right;
            
            int leftPrecedence = (int)GetPrecedence(left);

            if (leftPrecedence == (int)DataTypePrecedence.Error) {
                return null;
            }
            int rightPrecedence = (int)GetPrecedence(right);

            if (rightPrecedence == (int)DataTypePrecedence.Error) {
                return null;
            }

            if (Operators.IsLogical(op))
                if (left == typeof(Boolean) && right == typeof(Boolean))
                    return typeof(Boolean);
                else
                    return null;

            if ((op == Operators.Plus) && ((left == typeof(String)) || (right == typeof(String))))
                return typeof(string);

            DataTypePrecedence higherPrec = (DataTypePrecedence)Math.Max(leftPrecedence, rightPrecedence);

            
            Type result = GetType(higherPrec);

            if (Operators.IsArithmetical(op)) {
                if (result != typeof(string) && result != typeof(char)) {
                    if (!IsNumeric(left))
                        return null;
                    if (!IsNumeric(right))
                        return null;
                }
            }

            // if the operation is a division the result should be at least a double

            if ((op == Operators.Divide) && IsInteger(result)) {
                return typeof(double);
            }

            if (IsMixed(left, right)) {
                // we are dealing with one signed and one unsigned type so
                // try to see if one of them is a ConstNode
                if (lc && (!rc)) {
                    return right;
                }
                else if ((!lc) && rc) {
                    return left;
                }

                if (IsUnsigned(result)) {
                    if (higherPrec < DataTypePrecedence.UInt64)
                        // left and right are mixed integers but with the same length
                        // so promote to the next signed type
                        result = GetType(higherPrec+1);
                    else
                        throw ExprException.AmbiguousBinop(op, left, right);
                }
               
            }

            return result;
        }
    }

    internal class LikeNode : BinaryNode {
        // like kinds
        internal const int match_left = 1;      // <STR>*
        internal const int match_right = 2;     // *<STR>
        internal const int match_middle = 3;    // *<STR>*
        internal const int match_exact  = 4;    // <STR>
        internal const int match_all  = 5;      // *

        int kind;
        string pattern = null;

        internal LikeNode(int op, ExpressionNode left, ExpressionNode right)
        : base (op, left, right) {
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            object vRight;
            // UNDONE: Aggregate
            object vLeft = left.Eval(row, version);
            string substring;

            if (vLeft == DBNull.Value)
                return DBNull.Value;

            if (pattern == null) {
                vRight = right.Eval(row, version);

                if (!(vRight is string)) {
                    SetTypeMismatchError(op, vLeft.GetType(), vRight.GetType());
                }

                // need to convert like pattern to a string

                // Parce the original pattern, and get the constant part of it..
                substring = AnalizePattern((string)vRight);

                if (right.IsConstant())
                    pattern = substring;
            }
            else {
                substring = pattern;
            }

            if (!(vLeft is string)) {
                SetTypeMismatchError(op, vLeft.GetType(), typeof(string));
            }

            // WhiteSpace Chars Include : 0x9, 0xA, 0xB, 0xC, 0xD, 0x20, 0xA0, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x200B, 0x3000, and 0xFEFF.
            char[] trimChars = new char[2] {(char)0x20, (char)0x3000};
            string s1 = ((string)vLeft).TrimEnd(trimChars);

            CompareOptions flags = table.compareFlags;
            switch (kind) {
                case match_all:
                    return true;
                case match_exact:
                    return(0 == table.Compare(s1, substring, flags));
                case match_middle:
                    return(0 <= table.Locale.CompareInfo.IndexOf(s1, substring, flags));
                case match_left:
                    return(0 == table.Locale.CompareInfo.IndexOf(s1, substring, flags));
                case match_right:
                    string s2 = substring.TrimEnd(trimChars);
                    return table.Locale.CompareInfo.IsSuffix(s1, s2, flags);
                default:
                    Debug.Assert(false, "Unexpected LIKE kind");
                    return DBNull.Value;
            }            
        }

        internal string AnalizePattern(string pat) {
#if DEBUG
            if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("Like pattern " + pat);
#endif

            int length = pat.Length;
            char[] patchars = new char[length+1];
            pat.CopyTo(0, patchars, 0, length);
            patchars[length] = (char)0;
            string substring = null;

            char[] constchars = new char[length+1];
            int newLength = 0;

            int stars = 0;

            int i = 0;

            while (i < length) {

                if (patchars[i] == '*' || patchars[i] == '%') {

                    // replace conseq. * or % with one..
                    while ((patchars[i] == '*' || patchars[i] == '%') && i < length)
                        i++;

                    // we allowing only *str* pattern
                    if ((i < length && newLength > 0) || stars >= 2) {
                        // we have a star inside string constant..
                        throw ExprException.InvalidPattern(pat);
                    }
                    stars++;

                }
                else if (patchars[i] == '[') {
                    i++;
                    if (i >= length) {
                        throw ExprException.InvalidPattern(pat);
                    }
                    constchars[newLength++] = patchars[i++];

                    if (i >= length) {
                        throw ExprException.InvalidPattern(pat);
                    }

                    if (patchars[i] != ']') {
                        throw ExprException.InvalidPattern(pat);
                    }
                    i++;
                }
                else {
                    constchars[newLength++] = patchars[i];
                    i++;
                }
            }

            substring = new string(constchars, 0, newLength);

#if DEBUG
            if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("new Like pattern " + substring);
#endif

            if (stars == 0) {
                kind = match_exact;
            }
            else {
                if (newLength > 0) {
                    if (patchars[0] == '*' || patchars[0] == '%') {
#if DEBUG
                        if (CompModSwitches.BinaryNode.TraceVerbose) Debug.WriteLine("looking for a substring " + substring);
#endif

                        if (patchars[length-1] == '*' || patchars[length-1] == '%') {
                            kind = match_middle;
                        }
                        else {
                            kind = match_right;
                        }
                    }
                    else {
                        Debug.Assert(patchars[length-1] == '*' || patchars[length-1] == '%', "Invalid LIKE pattern formed.. ");
                        kind = match_left;
                    }
                }
                else {
                    kind = match_all;
                }
            }
            return substring;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\common\weakreferencecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="WeakReferenceCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Common {

    using System;

    abstract class WeakReferenceCollection {
        private WeakReference[] _items;

        internal WeakReferenceCollection(object value) {
            _items = new WeakReference[5];
            _items[0] = new WeakReference(value);
        }

        internal int Add(object value) {
            int length = _items.Length;
            for (int i = 0; i < length; ++i) {
                WeakReference weak = _items[i];
                if (null == weak) {
                    _items[i] = new WeakReference(value);
                    return i;
                }
                else if (!weak.IsAlive) {
                    weak.Target = value;
                    return i;
                }
            }
            int newlength = ((5 == length) ? 15 : (length + 15));
            WeakReference[] items = new WeakReference[newlength];
            for (int i = 0; i < length; ++i) {
                items[i] = _items[i];
            }
            items[length] = new WeakReference(value);
            _items = items;
            return length;
        }

        internal void Clear() {
            int length = _items.Length;
            for (int i = 0; i < length; ++i) {
                WeakReference weak = _items[i];
                if (null != weak) {
                    weak.Target = null;
                }
                else break;
            }
        }

        abstract protected bool CloseItem(object value, bool flag);

        internal void Close(bool flag) {
            int length = _items.Length;
            for (int index = 0; index < length; ++index) {
                WeakReference weak = _items[index];
                if (null != weak) {
                    object value = weak.Target;
                    if ((null != value) && weak.IsAlive) {
                        if (CloseItem(value, flag)) {
                            weak.Target = null;
                        }
                    }
                }
                else break;
            }
        }

        abstract protected bool RecoverItem(object value);

        internal bool Recover(object exceptValue) {
            int length = _items.Length;
            for (int index = 0; index < length; ++index) {
                WeakReference weak = _items[index];
                if (null != weak) {
                    object value = weak.Target;
                    if ((value != exceptValue) && weak.IsAlive) {
                        if (!RecoverItem(value)) {
                            return false;
                        }
                    }
                }
                else break;
            }
            return true;
        }


        internal void Remove(object value) {
            int length = _items.Length;
            for (int index = 0; index < length; ++index) {
                WeakReference weak = _items[index];
                if (null != weak) {
                    if (value == weak.Target) {
                        weak.Target = null;
                        break;
                    }
                }
                else break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\aggregatenode.cs ===
//------------------------------------------------------------------------------
// <copyright file="AggregateNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;

    internal enum Aggregate {
        None = FunctionId.none,
        Sum = FunctionId.Sum,
        Avg = FunctionId.Avg,
        Min = FunctionId.Min,
        Max = FunctionId.Max,
        Count = FunctionId.Count,
        StDev = FunctionId.StDev,   // Statistical standard deviation
        Var = FunctionId.Var,       // Statistical variance
    }

    internal class AggregateNode : ExpressionNode {
        AggregateType type;
        Aggregate aggregate;
        bool local;     // set to true if the aggregate calculated localy (for the current table)

        string relationName;
        string columnName;

        DataTable table;
        // CONSIDER PERF: keep the objetcs, not names.
        // ? try to drop a column
        DataColumn column;
        DataRelation relation;

#if DEBUG
        //static AggregateNode() {
            //UNDONE : Debug.DefineSwitch("AggregateNode", "Expression language, AggregateNode");
        //}
#endif

        internal AggregateNode(FunctionId aggregateType, string columnName) :
        this(aggregateType, columnName, true, null) {
        }

        internal AggregateNode(FunctionId aggregateType, string columnName, string relationName) :
        this(aggregateType, columnName, false, relationName) {
        }

        internal AggregateNode(FunctionId aggregateType, string columnName, bool local, string relationName) {
            Debug.Assert(columnName != null, "Invalid parameter columnName (null).");
#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("Creating the aggregate node");
#endif
            this.aggregate = (Aggregate)(int)aggregateType;

            if (aggregateType == FunctionId.Sum)
                this.type = AggregateType.Sum;
            else if (aggregateType == FunctionId.Avg)
                this.type = AggregateType.Mean;
            else if (aggregateType == FunctionId.Min)
                this.type = AggregateType.Min;
            else if (aggregateType == FunctionId.Max)
                this.type = AggregateType.Max;
            else if (aggregateType == FunctionId.Count)
                this.type = AggregateType.Count;
            else if (aggregateType == FunctionId.Var)
                this.type = AggregateType.Var;
            else if (aggregateType == FunctionId.StDev)
                this.type = AggregateType.StDev;
            else {
                throw ExprException.UndefinedFunction(Function.FunctionName[(Int32)aggregateType]);
            }

            this.local = local;
            this.relationName = relationName;
            this.columnName = columnName;
        }

        internal override void Bind(DataTable table, ArrayList list) {
#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("Binding Aggregate expression " + this.ToString());
#endif
            if (table == null)
                throw ExprException.AggregateUnbound(this.ToString());

#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("in table " + table.TableName);
#endif
            if (local) {
                relation = null;
            }
            else {
                DataRelationCollection relations;
                relations = table.ChildRelations;

                if (relationName == null) {
                    // must have one and only one relation

                    if (relations.Count > 1) {
                        throw ExprException.UnresolvedRelation(table.TableName, this.ToString());
                    }
                    if (relations.Count == 1) {
                        relation = relations[0];
                    }
                    else {
                        throw ExprException.AggregateUnbound(this.ToString());
                    }
                }
                else {
                    relation = relations[relationName];
                }
                Debug.Assert(relation != null, String.Format(Res.GetString(Res.Expr_AggregateUnbound), this.ToString()));
            }

            DataTable childTable = (relation == null) ? table : relation.ChildTable;
            this.table = childTable;

            this.column = childTable.Columns[columnName];

            if (column == null)
                throw ExprException.UnboundName(columnName);

            // add column to the dependency list, do not add duplicate columns

            Debug.Assert(column != null, "Failed to bind column " + columnName);

            int i;
            for (i = 0; i < list.Count; i++) {
                // walk the list, check if the current column already on the list
                DataColumn dataColumn = (DataColumn)list[i];
                if (column == dataColumn) {
                    break;
                }
            }
            if (i >= list.Count) {
                list.Add(column);
            }

            //UNDONE : Debug.WriteLineIf("AggregateNode", this.ToString() + " bound");
        }

        internal override object Eval() {
            return Eval(null, DataRowVersion.Default);
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("Eval " + this.ToString() + ", version " + version.ToString());
#endif
            if (table == null)
                throw ExprException.AggregateUnbound(this.ToString());

            DataRow[] rows;

            if (local) {
                rows = new DataRow[table.Rows.Count];
                table.Rows.CopyTo(rows, 0);
            }
            else {
                if (row == null) {
                    throw ExprException.EvalNoContext();
                }
                if (relation == null) {
                    throw ExprException.AggregateUnbound(this.ToString());
                }
                rows = row.GetChildRows(relation, version);
            }
#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("Eval " + this.ToString() + ", # of Rows: " + rows.Length.ToString());
#endif

            int[] records;

            if (version == DataRowVersion.Proposed) {
                version = DataRowVersion.Default;
            }

            records = new int[rows.Length];
            for (int i = 0; i < rows.Length; i++) {
                records[i] = rows[i].GetRecordFromVersion(version);
            }
            return column.GetAggregateValue(records, type);
        }

        // Helper for the DataTable.Compute method
        internal override object Eval(int[] records) {
#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("Eval " + this.ToString());
#endif
            if (table == null)
                throw ExprException.AggregateUnbound(this.ToString());
            if (!local) {
                throw ExprException.ComputeNotAggregate(this.ToString());
            }
            return column.GetAggregateValue(records, type);
        }

        public override string ToString() {

            string expr = NameOf(aggregate) + "(";

            if (local) {
                expr += "[" + columnName + "])";
            }
            else {
                expr += "child";

                if (relationName != null) {
                    expr += "([" + relationName + "])";
                }
                expr += ".[" + columnName + "])";
            }

            return expr;
        }

        internal override bool IsConstant() {
            return false;
        }

        internal override bool IsTableConstant() {
            return local;
        }

        internal override bool HasLocalAggregate() {
            return local;
        }

        internal override bool DependsOn(DataColumn column) {
            if (this.column == column) {
                return true;
            }
            if (this.column.Computed) {
                return this.column.DataExpression.DependsOn(column);
            }
            return false;
        }

        internal override ExpressionNode Optimize() {
#if DEBUG
            if (CompModSwitches.AggregateNode.TraceVerbose) Debug.WriteLine("Aggregate: Optimize " + this.ToString());
#endif
            return this;
        }

        string NameOf(Aggregate aggregate) {
            switch (aggregate) {
                case Aggregate.Sum:
                    return "Sum";
                case Aggregate.Avg:
                    return "Avg";
                case Aggregate.Min:
                    return "Min";
                case Aggregate.Max:
                    return "Max";
                case Aggregate.Count:
                    return "Count";
                case Aggregate.StDev:
                    return "StDev";
                case Aggregate.Var:
                    return "Var";
                case Aggregate.None:
                default:
                    Debug.Assert(false, "Undefined aggregate function " + aggregate.ToString());
                    return "Empty";

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\datafilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;

    /// <include file='doc\DataFilter.uex' path='docs/doc[@for="DataFilter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class DataFilter : DataExpression, IFilter {

        /// <include file='doc\DataFilter.uex' path='docs/doc[@for="DataFilter.DataFilter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataFilter() {
        }

        /// <include file='doc\DataFilter.uex' path='docs/doc[@for="DataFilter.DataFilter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataFilter(string expression, DataTable table)
        : base(expression, table) {
        }

        /// <include file='doc\DataFilter.uex' path='docs/doc[@for="DataFilter.Invoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool Invoke() {
            throw ExprException.InvokeArgument();
        }

        /// <include file='doc\DataFilter.uex' path='docs/doc[@for="DataFilter.Invoke1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool Invoke(DataRow row) {
            return Invoke(row, DataRowVersion.Default);
        }

        /// <include file='doc\DataFilter.uex' path='docs/doc[@for="DataFilter.Invoke2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool Invoke(DataRow row, DataRowVersion version) {
            if (expr == null)
                return true;

            if (row == null) {
                throw ExprException.InvokeArgument();
            }
            object val = expr.Eval(row, version);
            bool result;
            try {
                result = ToBoolean(val);
            }
            catch (Exception) {
                throw ExprException.FilterConvertion(Expression);
            }
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\expressionnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExpressionNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;

    internal abstract class ExpressionNode {
        internal abstract void Bind(DataTable table, ArrayList list);
        internal abstract object Eval();
        internal abstract object Eval(DataRow row, DataRowVersion version);
        internal abstract object Eval(int[] recordNos);
        internal abstract bool IsConstant();
        internal abstract bool IsTableConstant();
        internal abstract bool HasLocalAggregate();
        internal abstract ExpressionNode Optimize();
        internal virtual bool DependsOn(DataColumn column) {
            return false;
        }

        internal static bool IsInteger(Type type) {
            return(type == typeof(Int16) ||
                   type == typeof(Int32) ||
                   type == typeof(Int64) ||
                   type == typeof(UInt16) ||
                   type == typeof(UInt32) ||
                   type == typeof(UInt64) ||
                   type == typeof(SByte)  ||
                   type == typeof(Byte));

        }

        internal static bool IsSigned(Type type) {
            return(type == typeof(Int16) ||
                   type == typeof(Int32) ||
                   type == typeof(Int64) ||
                   type == typeof(SByte) ||
                   IsFloat(type));
        }

        internal static bool IsUnsigned(Type type) {
            return(type == typeof(UInt16) ||
                   type == typeof(UInt32) ||
                   type == typeof(UInt64) ||
                   type == typeof(Byte));
        }

        internal static bool IsNumeric(Type type) {
            return(IsFloat(type) ||
                   IsInteger(type));
        }
        internal static bool IsFloat(Type type) {
            return(type == typeof(Single) ||
                   type == typeof(double) ||
                   type == typeof(Decimal));
        }

        internal static ValueType TypeOf(Type datatype) {
            if (datatype == typeof(System.DBNull))
                return ValueType.Null;
            if (datatype == typeof(Byte))
                return ValueType.Numeric;
            if (datatype == typeof(Int16))
                return ValueType.Numeric;
            if (datatype == typeof(Int32))
                return ValueType.Numeric;
            if (datatype == typeof(Int64))
                return ValueType.Numeric;
            if (datatype == typeof(Decimal))
                return ValueType.Decimal;
            if (datatype == typeof(double))
                return ValueType.Float;
            if (datatype == typeof(bool))
                return ValueType.Bool;
            if (datatype == typeof(string))
                return ValueType.Str;
            else
                return ValueType.Object;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\expressionparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExpressionParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Globalization;
    
    internal enum ValueType {
        Unknown = -1,
        Null = 0,
        Bool = 1,
        Numeric = 2,
        Str = 3,
        Float = 4,
        Decimal = 5,
        Object = 6,
        Date = 7,
    }
    /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="Nodes"]/*' />
    /// <devdoc>
    ///     ExpressionParser: expression node types
    /// </devdoc>
    enum Nodes {
        Noop = 0,
        Unop = 1,       /* Unary operator */
        UnopSpec = 2,   /* Special unop: IFF does not eval args */
        Binop = 3,      /* Binary operator */
        BinopSpec = 4,  /* Special binop: BETWEEN, IN does not eval args */
        Zop = 5,        /* "0-ary operator" - intrinsic constant. */
        Call = 6,       /* Function call or rhs of IN or IFF */
        Const = 7,      /* Constant value */
        Name = 8,       /* Identifier */
        Paren = 9,      /* Parentheses */
        Conv = 10,      /* Type conversion */
    }

    internal class ExpressionParser {
        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.Empty"]/*' />
        /// <devdoc>
        ///     Operand situations for parser
        /// </devdoc>
        private const int    Empty = 0;  /* There was no previous operand */
        private const int    Scalar = 1; /* The previous operand was a constant or id */
        private const int    Expr = 2;   /* The previous operand was a complex expression */

        private static readonly ReservedWords[] reservedwords = new ReservedWords[] {
            new ReservedWords("And", Tokens.BinaryOp, Operators.And),
            new ReservedWords("False", Tokens.ZeroOp, Operators.False),
            new ReservedWords("In", Tokens.BinaryOp, Operators.In),
            new ReservedWords("Is", Tokens.BinaryOp, Operators.Is),
            new ReservedWords("Like", Tokens.BinaryOp, Operators.Like),
            new ReservedWords("Not", Tokens.UnaryOp, Operators.Not),
            new ReservedWords("Null", Tokens.ZeroOp, Operators.Null),
            new ReservedWords("Or", Tokens.BinaryOp, Operators.Or),
            new ReservedWords("True", Tokens.ZeroOp, Operators.True),
            new ReservedWords("Child", Tokens.Child, Operators.Noop),
            new ReservedWords("Parent", Tokens.Parent, Operators.Noop),
            /*
            the following operators are not implemented in the current version of the
            Expression language, but we need to add them to the Reserved words list
            to prevent future compatibility problems.
            */
            new ReservedWords("Between", Tokens.BinaryOp, Operators.Between),
        };

        /* the following is the Scanner local configuration, Default settings is US
         * CONSIDER: should we read the user (or system) local settings?
         * CONSIDER: make this configurable by the user, and system locale for the string compare
         */
        private char Escape = '\\';
        private char DecimalSeparator = '.';
        //not used: private char ThousandSeparator = ',';
        private char ListSeparator = ',';
        //not used: private char DateSeparator = '/';
        private char ExponentL = 'e';
        private char ExponentU = 'E';

        internal char[] text;
        internal int pos = 0;
        internal int start = 0;
        internal Tokens token;
        internal int op = Operators.Noop;

        internal OperatorInfo[] ops =  new OperatorInfo[MaxPredicates];
        internal int topOperator = 0;
        internal int topNode = 0;

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.MaxPredicates"]/*' />
        /// <devdoc>
        ///     UNDONE: we should be more flexible: the following consts should be config..
        /// </devdoc>
        private const int MaxPredicates = 100;
        internal ExpressionNode[] NodeStack = new ExpressionNode[MaxPredicates];

        internal int prevOperand;

        internal ExpressionNode expression = null;

        internal ExpressionParser() {
        }

        internal void LoadExpression(string data) {
            int length;

            if (data == null) {
                length = 0;
                this.text = new char[length+1];
            }
            else {
                length = data.Length;
                this.text = new char[length+1];
                data.CopyTo(0, this.text, 0, length);
            }

            this.text[length] = '\0';

            if (expression != null) {
                // free all nodes
                expression = null;
            }
        }

        internal virtual void StartScan() {
            op = Operators.Noop;
            pos = 0;
            start = 0;

            topOperator = 0;
            ops[topOperator++] = new OperatorInfo(Nodes.Noop, Operators.Noop, Operators.priStart);
        }

        // CONSIDER: configure the scanner : local info

        internal ExpressionNode Parse() {
            // free all nodes
            expression = null;

            StartScan();

            int cParens = 0;
            OperatorInfo opInfo;

            while (token != Tokens.EOS) {
                loop:
                Scan();

                switch (token) {
                    case Tokens.EOS:
#if DEBUG
                        if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("EOS, Collect all nodes");
#endif
                        // End of string: must be operand; force out expression;
                        // check for bomb; check nothing left on stack.

                        if (prevOperand == Empty) {
                            if (topNode == 0) {
                                // we have an empty expression
                                break;
                            }
                            // set error missing operator
                            // read the last operator info
                            opInfo = ops[topOperator - 1];

                            throw ExprException.MissingOperand(opInfo);
                        }
                        // collect all nodes
                        BuildExpression(Operators.priLow);
                        if (topOperator != 1) {
                            throw ExprException.MissingRightParen();
                        }
#if DEBUG
                        if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Done.." + NodeStack[0].ToString());
#endif
                        break;

                    case Tokens.Name:
                    case Tokens.Parent:
                    case Tokens.Numeric:
                    case Tokens.Decimal:
                    case Tokens.Float:
                    case Tokens.StringConst:
                    case Tokens.Date:
                        ExpressionNode node = null;
                        string str = null;

                        /* Constants and identifiers: create leaf node */

                        if (prevOperand != Empty) {
                            // set error missing operator
                            throw ExprException.MissingOperator(new string(text, start, pos - start));
                        }

                        if (topOperator > 0) {
                            // special check for IN without parentheses

                            opInfo = ops[topOperator-1];

                            if (opInfo.type == Nodes.Binop && opInfo.op == Operators.In && token != Tokens.Parent) {
                                throw ExprException.InWithoutParentheses();
                            }
                        }

                        prevOperand = Scalar;

                        switch (token) {
                            case Tokens.Parent:
                                string relname;
                                string colname;

                                // parsing Parent[(relation_name)].column_name)
                                try {
                                    // expecting an '(' or '.'
                                    Scan();
                                    if (token == Tokens.LeftParen) {
                                        //read the relation name
                                        ScanToken(Tokens.Name);
                                        relname = NameNode.ParseName(text, start, pos);
                                        ScanToken(Tokens.RightParen);
                                        ScanToken(Tokens.Dot);
                                    }
                                    else {
                                        relname = null;
                                        CheckToken(Tokens.Dot);
                                    }
                                }
                                catch {
                                    throw ExprException.LookupArgument();
                                }

                                ScanToken(Tokens.Name);
                                colname = NameNode.ParseName(text, start, pos);

                                opInfo = ops[topOperator - 1];
                                node = new LookupNode(colname, relname);

                                break;

                            case Tokens.Name:
                                /* Qualify name now for nice error checking */

                                opInfo = ops[topOperator - 1];

                                /* Create tree element -                */
                                // CONSIDER: Check for reserved proc names here
                                node = new NameNode(text, start, pos);

                                break;

                            case Tokens.Numeric:
                                str = new string(text, start, pos - start);
                                node = new ConstNode(ValueType.Numeric, str);
                                break;
                            case Tokens.Decimal:
                                str = new string(text, start, pos - start);
                                node = new ConstNode(ValueType.Decimal, str);
                                break;
                            case Tokens.Float:
                                str = new string(text, start, pos - start);
                                node = new ConstNode(ValueType.Float, str);
                                break;
                            case Tokens.StringConst:
                                Debug.Assert(text[start] == '\'' && text[pos-1] == '\'', String.Format("The expression contains an invalid string constant: {0}", new string(text, start, pos - start - 1)));
                                Debug.Assert(pos - start > 1, String.Format("The expression contains an invalid string constant: {0}", new string(text, start, pos - start - 1)));
                                // Store string without quotes..
                                str = new string(text, start+1, pos - start-2);
                                node = new ConstNode(ValueType.Str, str);
                                break;
                            case Tokens.Date:
                                Debug.Assert(text[start] == '#' && text[pos-1] == '#', String.Format("The expression contains invalid date constant '{0}'.", new string(text, start, pos - start)));
                                Debug.Assert(pos - start > 2, String.Format("The expression contains invalid date constant '{0}'.", new string(text, start, pos - start)));
                                // Store date without delimiters(#s)..
                                str = new string(text, start+1, pos - start-2);
                                node = new ConstNode(ValueType.Date, str);
                                break;
                            default:
                                Debug.Assert(false, "unhandled token");
				break;
                        }

                        NodePush(node);
                        goto loop;

                    case Tokens.LeftParen:
                        cParens++;
                        if (prevOperand == Empty) {
                            // Check for ( following IN/IFF. if not, we have a normal (.
                            // Peek: take a look at the operators stack

                            Debug.Assert(topOperator > 0, "Empty operator stack!!");
                            opInfo = ops[topOperator - 1];

                            if (opInfo.type == Nodes.Binop && opInfo.op == Operators.In) {
                                /* IN - handle as procedure call */

                                node = new FunctionNode("In");
                                NodePush(node);
                                /* Push operator decriptor */
                                ops[topOperator++] = new OperatorInfo(Nodes.Call, Operators.Noop, Operators.priParen);
                            }
                            else {  /* Normal ( */
                                /* Push operator decriptor */
                                ops[topOperator++] = new OperatorInfo(Nodes.Paren, Operators.Noop, Operators.priParen);
                            }
                        }
                        else {
                            // This is a procedure call or () qualification
                            // Force out any dot qualifiers; check for bomb

                            BuildExpression(Operators.priProc);
                            prevOperand = Empty;
                            ExpressionNode nodebefore = NodePeek();

#if DEBUG
                            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("the last node is " + (nodebefore == null ? "null" : nodebefore.ToString()));
#endif

                            if (nodebefore == null || nodebefore.GetType() != typeof(NameNode)) {
                                // this is more like an assert, so we not care about "nice" exception text..
                                //UNDONE: more info  (.. left paren) after " + nodebefore.ToString());
                                throw ExprException.SyntaxError();
                            }

                            /* Get the proc name */
                            NameNode name = (NameNode)NodePop();

                            // Make sure that we can bind the name as a Function
                            // then get the argument count and types, and parse arguments..

                            node = new FunctionNode(name.name);

                            // check to see if this is an aggregate function
                            Aggregate agg = (Aggregate)(int)((FunctionNode)node).Aggregate;
                            if (agg != Aggregate.None) {
                                node = ParseAggregateArgument((FunctionId)(int)agg);
                                NodePush(node);
                                prevOperand = Expr;
                                goto loop;
                            }

                            NodePush(node);
                            ops[topOperator++] = new OperatorInfo(Nodes.Call, Operators.Noop, Operators.priParen);
                        }
                        goto loop;

                    case Tokens.RightParen:
                        {
                            /* Right parentheses: Build expression if we have an operand. */
                            if (prevOperand != Empty) {
                                BuildExpression(Operators.priLow);
                            }

                            /* We must have Tokens.LeftParen on stack. If no operand, must be procedure call. */
                            if (topOperator <= 1) {
                                // set error, syntax: too many right parens..
                                throw ExprException.TooManyRightParentheses();
                            }

                            Debug.Assert(topOperator > 1, "melformed operator stack.");
                            topOperator--;
                            opInfo = ops[topOperator];

                            if (prevOperand == Empty && opInfo.type != Nodes.Call) {
                                // set error, syntax: missing operand.
                                throw ExprException.MissingOperand(opInfo);
                            }

                            Debug.Assert(opInfo.priority == Operators.priParen, "melformed operator stack.");

                            if (opInfo.type == Nodes.Call) {
                                /* add argument to the function call. */

#if DEBUG
                                if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("We have a function call on the stack..");
#endif

                                if (prevOperand != Empty) {
                                    // read last function argument
                                    ExpressionNode argument = NodePop();

                                    /* Get the procedure name and append argument */
                                    Debug.Assert(topNode > 0 && NodePeek().GetType() == typeof(FunctionNode), "The function node should be created on '('");

                                    FunctionNode func = (FunctionNode)NodePop();
                                    func.AddArgument(argument);
                                    func.Check();
                                    NodePush(func);
#if DEBUG
                                    if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("done with the argument");
#endif
                                }
                            }
                            else {
                                /* Normal parentheses: create tree node */
                                // Construct & Put the Nodes.Paren node on node stack
                                node = NodePop();
                                node = new UnaryNode(Operators.Noop, node);
                                NodePush(node);
                            }

                            prevOperand = Expr;
                            cParens--;
                            goto loop;
                        }
                    case Tokens.ListSeparator:
                        {
                            /* Comma encountered: Must be operand; force out subexpression */

                            if (prevOperand == Empty) {
                                throw ExprException.MissingOperandBefore(",");
                            }

                            /* We are be in a procedure call */

                            /* build next argument */
                            BuildExpression(Operators.priLow);

                            opInfo = ops[topOperator - 1];

                            if (opInfo.type != Nodes.Call)
                                //UNDONE: more info
                                throw ExprException.SyntaxError();

                            ExpressionNode argument2 = NodePop();

                            /* Get the procedure name */

                            FunctionNode func = (FunctionNode)NodePop();

                            func.AddArgument(argument2);

                            NodePush(func);

                            prevOperand = Empty;

#if DEBUG
                            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("done with the argument");
#endif
                            goto loop;
                        }
                    case Tokens.BinaryOp:
                        if (prevOperand == Empty) {
                            /* Check for unary plus/minus */
                            if (op == Operators.Plus) {
                                op = Operators.UnaryPlus;
                                // fall through to UnaryOperator;
                            }
                            else if (op  == Operators.Minus) {
                                /* Unary minus */
                                op = Operators.Negative;
                                // fall through to UnaryOperator;
                            }
                            else {
                                // Error missing operand:
                                throw ExprException.MissingOperandBefore(Operators.ToString(op));
                            }
                        }
                        else {
                            prevOperand = Empty;

                            /* CNSIDER: If we are going to support BETWEEN Translate AND to special BetweenAnd if it is. */

                            /* Force out to appropriate precedence; push operator. */

                            BuildExpression(Operators.Priority(op));

                            // PushOperator descriptor
                            ops[topOperator++] = new OperatorInfo(Nodes.Binop, op, Operators.Priority(op));
                            goto loop;
                        }
                        goto
                    case Tokens.UnaryOp; // fall through to UnaryOperator;

                    case Tokens.UnaryOp:
                        /* Must be no operand. Push it. */
                        ops[topOperator++] = new OperatorInfo(Nodes.Unop, op, Operators.Priority(op));
                        goto loop;

                    case Tokens.ZeroOp:
                        // check the we have operator on the stack
                        if (prevOperand != Empty) {
                            // set error missing operator
                            throw ExprException.MissingOperator(new string(text, start, pos - start));
                        }

                        // PushOperator descriptor
                        ops[topOperator++] = new OperatorInfo(Nodes.Zop, op, Operators.priMax);
                        prevOperand = Expr;
                        goto loop;

                    case Tokens.Dot:
                        //if there is a name on the stack append it.
                        ExpressionNode before = NodePeek();

                        if (before != null && before.GetType() == typeof(NameNode)) {
                            Scan();

                            if (token == Tokens.Name) {
                                NameNode nameBefore = (NameNode)NodePop();
                                //Debug.WriteLine("Before name '" + nameBefore.name + "'");
                                string newName = nameBefore.name + "." + NameNode.ParseName(text, start, pos);
                                //Debug.WriteLine("Create new NameNode " + newName);
                                NodePush(new NameNode(newName));
                                goto loop;
                            }
                        }
                        // fall through to default
                        goto default;
                    default:
                        throw ExprException.UnknownToken(new string(text, start, pos - start), start+1);
                }
            }
            goto end_loop;
            end_loop:
            Debug.Assert(topNode == 1 || topNode == 0, "Invalid Node Stack");
            expression = NodeStack[0];

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine((expression == null) ? "<empty expression>" : expression.ToString());
#endif

            return expression;
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.ParseAggregateArgument"]/*' />
        /// <devdoc>
        ///     parse the argument to an Aggregate function.
        ///     the syntax is
        ///          Func(child[(relation_name)].column_name)
        ///     When the function is called we have already parsed the Aggregate name, and open paren
        /// </devdoc>
        private ExpressionNode ParseAggregateArgument(FunctionId aggregate) {
            Debug.Assert(token == Tokens.LeftParen, "ParseAggregateArgument(): Invalid argument, token <> '('");

            bool child;
            string relname;
            string colname;

            Scan();

            try {
                if (token != Tokens.Child) {
                    if (token != Tokens.Name)
                        throw ExprException.AggregateArgument();

                    colname = NameNode.ParseName(text, start, pos);
                    ScanToken(Tokens.RightParen);
                    return new AggregateNode(aggregate, colname);
                }

                child = (token == Tokens.Child);
                prevOperand = Scalar;

                // expecting an '(' or '.'
                Scan();

                if (token == Tokens.LeftParen) {
                    //read the relation name
                    ScanToken(Tokens.Name);
                    relname = NameNode.ParseName(text, start, pos);
                    ScanToken(Tokens.RightParen);
                    ScanToken(Tokens.Dot);
                }
                else {
                    relname = null;
                    CheckToken(Tokens.Dot);
                }

                ScanToken(Tokens.Name);
                colname = NameNode.ParseName(text, start, pos);
                ScanToken(Tokens.RightParen);
            }
            catch {
                throw ExprException.AggregateArgument();
            }
            return new AggregateNode(aggregate, colname, !child, relname);
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.NodePop"]/*' />
        /// <devdoc>
        ///     NodePop - Pop an operand node from the node stack.
        /// </devdoc>
        private ExpressionNode NodePop() {

            Debug.Assert(topNode > 0, "NodePop(): Corrupted node stack");

            ExpressionNode node = NodeStack[--topNode];

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Pop node " + node.ToString() + " , node in the stack " + topNode.ToString());
#endif

            return node;
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.NodePeek"]/*' />
        /// <devdoc>
        ///     NodePeek - Peek at the top node.
        /// </devdoc>
        private ExpressionNode NodePeek() {
            if (topNode <= 0)
                return null;

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("PeekNode = " + NodeStack[topNode-1].ToString());
#endif
            return NodeStack[topNode-1];
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.NodePush"]/*' />
        /// <devdoc>
        ///     Push an operand node onto the node stack
        /// </devdoc>
        private void NodePush(ExpressionNode node) {

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("NodePush = " + node.ToString());
#endif

            if (topNode >= MaxPredicates-2) {
                throw ExprException.ExpressionTooComplex();
            }
            NodeStack[topNode++] = node;
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.BuildExpression"]/*' />
        /// <devdoc>
        ///     Builds expression tree for higher-precedence operator to be used as left
        ///     operand of current operator. May cause errors - always do ErrorCheck() upin return.
        /// </devdoc>

        private void BuildExpression(int pri) {
            ExpressionNode expr = null;

            Debug.Assert(pri > Operators.priStart && pri <= Operators.priMax, "Invalid priority value");

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Build exression, priority " + pri.ToString());
#endif

            /* For all operators of higher or same precedence (we are always
            left-associative) */
            while (true) {
                loop:
                Debug.Assert(topOperator > 0, "Empty operator stack!!");
                OperatorInfo opInfo = ops[topOperator - 1];

#if DEBUG
                if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("      Top operator, priority " + opInfo.priority.ToString());
#endif
                if (opInfo.priority < pri)
                    goto end_loop;

                Debug.Assert(opInfo.priority >= pri, "Invalid prioriry value");
                topOperator--;

#if DEBUG
                if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("          Porcessing operator of the type " + ((int)opInfo.type).ToString());
#endif
                ExpressionNode nodeLeft;
                ExpressionNode nodeRight;
                switch (opInfo.type) {
                    case Nodes.Binop: {
                            // get right, left operands. Bind them.

                            nodeRight = NodePop();
                            nodeLeft = NodePop();

                            /* This is the place to do type and other checks */

                            switch (opInfo.op) {
                                case Operators.Between:
                                case Operators.BetweenAnd:
                                case Operators.BitwiseAnd:
                                case Operators.BitwiseOr:
                                case Operators.BitwiseXor:
                                    throw ExprException.UnsupportedOperator(opInfo.op);

                                case Operators.Is: // UNDONE: enable me after PDC
                                case Operators.Or:
                                case Operators.And:
                                case Operators.EqualTo:
                                case Operators.NotEqual:
                                case Operators.Like:
                                case Operators.LessThen:
                                case Operators.LessOrEqual:
                                case Operators.GreaterThen:
                                case Operators.GreaterOrEqual:
                                case Operators.In:
                                    break;

                                default:
                                    Debug.Assert(opInfo.op == Operators.Plus ||
                                                 opInfo.op == Operators.Minus ||
                                                 opInfo.op == Operators.Multiply ||
                                                 opInfo.op == Operators.Divide ||
                                                 opInfo.op == Operators.Modulo,
                                                 "Invalud Binary operation");

                                    break;
                            }
                            Debug.Assert(nodeLeft != null, "Invalid left operand");
                            Debug.Assert(nodeRight != null, "Invalid right operand");

                            if (opInfo.op == Operators.Like) {
                                expr = new LikeNode(opInfo.op, nodeLeft, nodeRight);
                            }
                            else {
                                expr = new BinaryNode(opInfo.op, nodeLeft, nodeRight);
                            }

                            break;
                        }
                    case Nodes.Unop:
                        /* Unary operator: Pop and bind right op. */
                        nodeLeft = null;
                        nodeRight = NodePop();
#if DEBUG
                        if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Unary operator on " + nodeRight.ToString());
#endif

                        /* Check for special cases */
                        switch (opInfo.op) {
                            
                            case Operators.Not:
                                break;

                            case Operators.BitwiseNot:
                                throw ExprException.UnsupportedOperator(opInfo.op);

                            case Operators.Negative:
                                break;
                        }

                        Debug.Assert(nodeLeft == null, "Invalid left operand");
                        Debug.Assert(nodeRight != null, "Invalid right operand");

                        expr = new UnaryNode(opInfo.op, nodeRight);
                        break;

                    case Nodes.Zop:
                        /* Intrinsic constant: just create node. */
                        expr = new ZeroOpNode(opInfo.op);
                        break;

                    default:
                        Debug.Assert(false, "Unhandled operator type");
                        goto end_loop;
                }
                Debug.Assert(expr != null, "Failed to create expression");

                NodePush(expr);
                // countinue while loop;
            }
            end_loop:
            ;
        }


        internal void CheckToken(Tokens token) {
            if (this.token != token) {
                throw ExprException.UnknownToken(TokenToString(token), TokenToString(this.token), pos);
            }
        }

        internal string GetTokenString() {
            return new string(text, start, pos - start);
        }

        internal Tokens Scan() {
            char ch;
            char[] text = this.text;

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Start scan at position " + pos.ToString());
#endif

            token = Tokens.None;

            while (true) {
                loop:
                start = pos;
                op = Operators.Noop;
                ch = text[pos++];
                switch (ch) {
                    case (char)0:
                        token = Tokens.EOS;
                        goto end_loop;

                    case ' ':
                    case '\t':
                    case '\n':
                    case '\r':
                        ScanWhite();
                        goto loop;

                    case '(':
                        token = Tokens.LeftParen;
                        goto end_loop;

                    case ')':
                        token = Tokens.RightParen;
                        goto end_loop;

                    case '#':
                        ScanDate();
                        CheckToken(Tokens.Date);
                        goto end_loop;

                    case '\'':
                        ScanString('\'');
                        CheckToken(Tokens.StringConst);
                        goto end_loop;

                    case '=':
                        token = Tokens.BinaryOp;
                        op = Operators.EqualTo;
                        goto end_loop;

                    case '>':
                        token = Tokens.BinaryOp;
                        ScanWhite();
                        if (text[pos] == '=') {
                            pos++;
                            op = Operators.GreaterOrEqual;
                        }
                        else
                            op = Operators.GreaterThen;
                        goto end_loop;
                    case '<':
                        token = Tokens.BinaryOp;
                        ScanWhite();
                        if (text[pos] == '=') {
                            pos++;
                            op = Operators.LessOrEqual;
                        }
                        else if (text[pos] == '>') {
                            pos++;
                            op = Operators.NotEqual;
                        }
                        else
                            op = Operators.LessThen;
                        goto end_loop;

                    case '+':
                        token = Tokens.BinaryOp;
                        op = Operators.Plus;
                        goto end_loop;

                    case '-':
                        token = Tokens.BinaryOp;
                        op = Operators.Minus;
                        goto end_loop;

                    case '*':
                        token = Tokens.BinaryOp;
                        op = Operators.Multiply;
                        goto end_loop;

                    case '/':
                        token = Tokens.BinaryOp;
                        op = Operators.Divide;
                        goto end_loop;

                    case '%':
                        token = Tokens.BinaryOp;
                        op = Operators.Modulo;
                        goto end_loop;

                        /* Beginning of bitwise operators */
                    case '&':
                        token = Tokens.BinaryOp;
                        op = Operators.BitwiseAnd;
                        goto end_loop;

                    case '|':
                        token = Tokens.BinaryOp;
                        op = Operators.BitwiseOr;
                        goto end_loop;
                    case '^':
                        token = Tokens.BinaryOp;
                        op = Operators.BitwiseXor;
                        goto end_loop;
                    case '~':
                        token = Tokens.BinaryOp;
                        op = Operators.BitwiseNot;
                        goto end_loop;

                        /* we have bracketed identifier */
                    case '[':
                        // BUG: special case
                        ScanName(']', Escape, "]\\");
                        CheckToken(Tokens.Name);
                        goto end_loop;

                    case '`':
                        ScanName('`', '`', "`");
                        CheckToken(Tokens.Name);
                        goto end_loop;

                    default:
#if DEBUG
                        if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Scanning : " + ch.ToString());
#endif
                        /* Check for list separator */

                        if (ch == ListSeparator) {
                            token = Tokens.ListSeparator;
                            goto end_loop;
                        }

                        if (ch == '.') {
                            if (prevOperand == Empty) {
                                ScanNumeric();
                            }
                            else {
                                token = Tokens.Dot;
                            }
                            goto end_loop;
                        }

                        /* Check for binary constant */
                        if (ch == '0' && (text[pos] == 'x' || text[pos] == 'X')) {
                            ScanBinaryConstant();
                            token = Tokens.BinaryConst;
                            goto end_loop;
                        }

                        /* Check for number: digit is always good; . or - only if osNil. */
                        if ('0' == ch ||
                            '1' == ch ||
                            '2' == ch ||
                            '3' == ch ||
                            '4' == ch ||
                            '5' == ch ||
                            '6' == ch ||
                            '7' == ch ||
                            '8' == ch ||
                            '9' == ch) {
                            ScanNumeric();
                            goto end_loop;
                        }

                        /* Check for reserved word */
                        ScanReserved();
                        if (token != Tokens.None) {
                            goto end_loop;
                        }

                        /* Alpha means identifier */

                        if (IsAlphaNumeric(ch)) {
                            ScanName();
                            if (token != Tokens.None) {
                                CheckToken(Tokens.Name);
                                goto end_loop;
                            }
                        }

                        /* Don't understand that banter at all. */
                        token = Tokens.Unknown;
#if DEBUG
                        if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Unknown " + TokenToString(token) + ",  current position = " + pos.ToString());
#endif
                        throw ExprException.UnknownToken(new string(text, start, pos - start), start+1);
                }
            }
            end_loop:
#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Scan Returns " + TokenToString(token) + ",  current position = " + pos.ToString());
#endif
            return token;
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.ScanNumeric"]/*' />
        /// <devdoc>
        ///     ScanNumeric - parse number.
        ///
        ///     In format: [digit|.]*{[e|E]{[+|-]}{digit*}}
        ///
        ///     Further checking is done by constant parser.
        ///
        /// </devdoc>
        private void ScanNumeric() {
            char[] text = this.text;
            bool fDot = false;
            bool fSientific = false;

#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Scan Tokens.Numeric");
#endif

            Debug.Assert(pos != 0, "We have at least one digit in the buffer, ScanNumeric(), pos = " + pos.ToString());
            Debug.Assert(IsDigit(text[pos-1]), "We have at least one digit in the buffer, ScanNumeric(), not a digit: " + text[pos].ToString());

            while (IsDigit(text[pos])) {
                pos++;
            }

            if (text[pos] == DecimalSeparator) {
                fDot = true;
                pos++;
            }

            while (IsDigit(text[pos])) {
                pos++;
            }

            if (text[pos] == ExponentL || text[pos] == ExponentU) {
                fSientific = true;
                pos++;

                if (text[pos] == '-' || text[pos] == '+') {
                    pos++;
                }
                while (IsDigit(text[pos])) {
                    pos++;
                }
            }
            if (fSientific)
                token = Tokens.Float;
            else if (fDot)
                token = Tokens.Decimal;
            else
                token = Tokens.Numeric;
        }
        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.ScanName"]/*' />
        /// <devdoc>
        ///     Just a string of alphanumeric characters.
        /// </devdoc>
        private void ScanName() {
            char[] text = this.text;

            while (IsAlphaNumeric(text[pos]))
                pos++;

            token = Tokens.Name;
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.ScanName1"]/*' />
        /// <devdoc>
        ///      recognize bracketed identifiers.
        ///      Special case: we are using '\' character to escape '[' and ']' only, so '\' by itself  is not an escape
        /// </devdoc>
        private void ScanName(char chEnd, char esc, string charsToEscape) {
            char[] text = this.text;

            Debug.Assert(chEnd != '\0', "Invalid bracket value");
            Debug.Assert(esc != '\0', "Invalid escape value");
            do {
                if (text[pos] == esc) {
                    if (pos+1 < text.Length && charsToEscape.IndexOf(text[pos+1]) >= 0) {
                        pos++;
                    }
                }
                pos++;
            }while (pos < text.Length && text[pos] != chEnd);

            if (pos >= text.Length) {
                throw ExprException.InvalidNameBracketing(new string(text, start, (pos - 1) - start));
            }

            Debug.Assert(text[pos] == chEnd, "Invalid bracket value");

            pos++;

            token = Tokens.Name;
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.ScanDate"]/*' />
        /// <devdoc>
        ///     Just read the string between '#' signs, and parse it later
        /// </devdoc>
        private void ScanDate() {
            char[] text = this.text;

            do pos++; while (pos < text.Length && text[pos] != '#');

            if (pos >= text.Length || text[pos]!= '#') {
                // Bad date constant
                if (pos >= text.Length)
                    throw ExprException.InvalidDate(new string(text, start, (pos - 1) - start));
                else
                    throw ExprException.InvalidDate(new string(text, start, pos - start));
            }
            else {
                token = Tokens.Date;
            }
            pos++;
        }

        private void ScanBinaryConstant() {
            char[] text = this.text;
        }

        private void ScanReserved() {
            char[] text = this.text;

            if (IsAlpha(text[pos])) {
                this.ScanName();

                Debug.Assert(token == Tokens.Name, "Exprecing an identifier.");
                Debug.Assert(pos > start, "Exprecing an identifier.");

                string name = new string(text, start, pos - start);
                Debug.Assert(name != null, "Make sure the arguments for Compare method are OK");

                for (int i = 0; i < reservedwords.Length; i++) {
                    Debug.Assert(reservedwords[i].word != null, "Make sure the arguments for Compare method are OK");

                    if (String.Compare(reservedwords[i].word, name, true, CultureInfo.InvariantCulture) == 0) {

                        // we found the reserved word..
#if DEBUG
                        if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Reserved word " + name.ToString());
#endif

                        token = reservedwords[i].token;
                        op = reservedwords[i].op;
                        break;
                    }

                    if (token == Tokens.None) {
                        token = Tokens.Name;
                    }
                }
            }
        }

        private void ScanString(char escape) {
            char[] text = this.text;

            while (pos < text.Length) {
                char ch = text[pos++];

                if (ch == escape && pos < text.Length && text[pos] == escape) {
                    pos++;
                }
                else if (ch == escape)
                    break;
            }

            if (pos >= text.Length) {
                throw ExprException.InvalidString(new string(text, start, (pos - 1) - start));
            }

            token = Tokens.StringConst;
        }

        // scan the next token, and error if it doesn't match the requested token
        internal void ScanToken(Tokens token) {
            Scan();
            CheckToken(token);
        }

        private void ScanWhite() {
            char[] text = this.text;

            while (pos < text.Length && IsWhiteSpace(text[pos])) {
                pos++;
            }
        }

        // We define our own functions instead of using the COM+ ones because the definitions
        // of these things is specified by the language, and does not agree with what COM+
        // implements.


        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.IsWhiteSpace"]/*' />
        /// <devdoc>
        ///     is the character a white space character?
        ///     Consider using CharacterInfo().IsWhiteSpace(ch) (System.Globalization)
        /// </devdoc>

        protected bool IsWhiteSpace(char ch) {
            return ch <=32 && ch != '\0';
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.IsAlphaNumeric"]/*' />
        /// <devdoc>
        ///     is the character an alphanumeric?
        /// </devdoc>
        protected bool IsAlphaNumeric(char ch) {
            //single comparison
            switch (ch) {
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '_':
                case '$':
                    return true;
                default:
                    if (ch > 0x7f)
                        return true;

                    return false;
            }
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.IsHexChar"]/*' />
        /// <devdoc>
        ///     is the character an hex value
        /// </devdoc>
        protected bool IsHexChar(char ch) {
            //single comparison
            switch (ch) {
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    return true;
                default:
                    return false;
            }
        }

        protected bool IsDigit(char ch) {
            //single comparison
            switch (ch) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    return true;
                default:
                    return false;
            }
        }

        /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="ExpressionParser.IsAlpha"]/*' />
        /// <devdoc>
        ///     is the character an alpha?
        /// </devdoc>
        protected bool IsAlpha(char ch) {
            //single comparison
            switch (ch) {
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '_':
                    return true;
                default:
                    return false;
            }
        }

        private static string[] tokens = null;

        private static string TokenToString(Tokens token) {
#if DEBUG
            if (CompModSwitches.ExprParser.TraceVerbose) Debug.WriteLine("Convert token " + ((int)token).ToString());
#endif

            if (tokens == null) {
                tokens = new string[] {
                    "None",
                    "Name",
                    "Numeric",
                    "Float",
                    "Decimal",
                    "BinaryConst",
                    "StringConst",
                    "Date",
                    "ListSeparator",
                    "(",
                    ")",
                    "ZeroOp",
                    "UnaryOp",
                    "BinaryOp",
                    "Child",
                    "Parent",
                    "Dot",
                    "Unknown",
                    "EOS",
                };
            }

            if ((int)token > tokens.Length)
                return "Unknown token "+ ((int)token).ToString();
            else
                return "token " + ((int)token).ToString() + " (" + tokens[(int)token] + ")";
        }
    }

    /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="Tokens"]/*' />
    /// <devdoc>
    ///     Tokens
    /// </devdoc>
    enum Tokens {
        None            = 0,
        Name            = 1, /* Identifier */
        Numeric         = 2,
        Decimal         = 3,
        Float           = 4,
        BinaryConst     = 5, /* Binary Constant e.g. 0x12ef */
        StringConst     = 6,
        Date            = 7,
        ListSeparator   = 8, /* List Tokens.ListSeparator/Comma */
        LeftParen       = 9, /* '('; */
        RightParen      = 10, /* ')'; */
        ZeroOp          = 11, /* 0-array operator like "NULL" */
        UnaryOp         = 12,
        BinaryOp        = 13,
        Child           = 14,
        Parent          = 15,
        Dot             = 16,
        Unknown         = 17, /* do not understend the token */
        EOS             = 18, /* End of string */
    }

    /// <include file='doc\ExpressionParser.uex' path='docs/doc[@for="OperatorInfo"]/*' />
    /// <devdoc>
    ///     Operator stack element
    /// </devdoc>
    internal class OperatorInfo {
        internal Nodes type = (Nodes)0;
        internal int op = 0;
        internal int priority = 0;

        internal OperatorInfo(Nodes type, int op, int pri) {
            this.type = type;
            this.op = op;
            this.priority = pri;
        }
    }

    internal sealed class ReservedWords {
        internal readonly string word;      // the word
        internal readonly Tokens token;
        internal readonly int op;

        internal ReservedWords() : this(null, (Tokens)0, 0) {
        }

        internal ReservedWords(string word, Tokens token, int op) {
            this.word = word;
            this.token =token;
            this.op = op;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\constnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConstNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    internal class ConstNode : ExpressionNode {
        internal object val;

        internal ConstNode(ValueType type, object constant) : this(type, constant, true) {
        }

        internal ConstNode(ValueType type, object constant, bool fParseQuotes) {
#if DEBUG
            if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Create const node = " + constant.ToString());
#endif
 
            switch (type) {
                case ValueType.Null:
                    this.val = DBNull.Value;
                    break;

                case ValueType.Numeric:
                    // What is the smallest numeric ?
                    try {
                        int value = Convert.ToInt32(constant);
                        this.val = value;
                    }
                    catch (Exception) {
#if DEBUG
                        if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Failure to convert to Int32");
#endif
                        try {
                            Int64 value = Convert.ToInt64(constant);
                            this.val = value;
                        }
                        catch (Exception) {
#if DEBUG
                            if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Failure to convert to Decimal, store as double");
#endif
                            try {
                                double value = Convert.ToDouble(constant, NumberFormatInfo.InvariantInfo);
                                this.val = value;
                            }
                            catch (Exception) {
#if DEBUG
                                if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Failure to convert to double, store as object");
#endif
                                // store as is (string)
                                this.val = constant;
                            }
                        }
                    }

#if DEBUG
                    if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Created numeric constant of " + this.val.GetType().ToString());
#endif

                    break;
                case ValueType.Decimal:
                    try {
                        Decimal value = Convert.ToDecimal(constant, NumberFormatInfo.InvariantInfo);
                        this.val = value;
                    }
                    catch (Exception) {
#if DEBUG
                        if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Failure to convert to Decimal, store as double");
#endif
                        try {
                            double value = Convert.ToDouble(constant, NumberFormatInfo.InvariantInfo);
                            this.val = value;
                        }
                        catch (Exception) {
#if DEBUG
                            if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("Failure to convert to double, store as object");
#endif
                            // store as is (string)
                            this.val = constant;
                        }
                    }
                    break;
                case ValueType.Float:
                    this.val = Convert.ToDouble(constant, NumberFormatInfo.InvariantInfo);
                    break;

                case ValueType.Bool:
                    this.val = Convert.ToBoolean(constant);
                    break;

                case ValueType.Str:
                    if (fParseQuotes) {
                        // replace '' with one '
                        char[] echo = ((string)constant).ToCharArray();
                        int posEcho = 0;

                        for (int i = 0; i < echo.Length; i++) {
                            if (echo[i] ==  '\'') {
                                i++;
                            }
                            echo[posEcho] = echo[i];
                            posEcho++;
                        }

                        constant = new string(echo, 0, posEcho);
                    }
                    this.val = (string)constant;
                    break;

                case ValueType.Date:
                    this.val = DateTime.Parse((string)constant,CultureInfo.InvariantCulture);
                    break;

                case ValueType.Object:
                    this.val = constant;
                    break;

                default:
                    //Debug.Assert(false, "NYI");
                    // this id more like an assert: never should happens, so we do not care about "nice" Exception here
                    throw ExprException.NYI("ValueType = " + ((int)type).ToString());
            }
        }

        internal override void Bind(DataTable table, ArrayList list) {
        }

        internal override object Eval() {
            return val;
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            return Eval();
        }

        internal override object Eval(int[] recordNos) {
            return Eval();
        }

        internal override bool IsConstant() {
            return true;
        }

        internal override bool IsTableConstant() {
            return true;
        }

        internal override bool HasLocalAggregate() {
            return false;
        }

        internal override ExpressionNode Optimize() {
            return this;
        }

        public override string ToString() {
#if DEBUG
            if (CompModSwitches.ConstNode.TraceVerbose) Debug.WriteLine("CONST == " + val.ToString());
#endif

            if (val == DBNull.Value)
                return "Null";
            else if (null == val)
                return "Empty";
            else if (val is string)
                return "'" + val.ToString() + "'";
            else return val.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\lookupnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="LookupNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
    using System.Collections;
    using System.Diagnostics;

    internal class LookupNode : ExpressionNode {
        string relationName;    // can be null
        string columnName;

        // CONSIDER: DROP table..
        DataTable table;
        // CONSIDER PERF: keep the objetcs, not names.
        // ? try to drop a column, relation
        DataColumn column;
        DataRelation relation;

        internal LookupNode(string columnName) :
        this(columnName, null) {
        }

        internal LookupNode(string columnName, string relationName) {
#if DEBUG
            if (CompModSwitches.LookupNode.TraceVerbose) Debug.WriteLine("Creating the lookup node");
#endif
            this.relationName = relationName;
            this.columnName = columnName;
        }

        internal override void Bind(DataTable table, ArrayList list) {
#if DEBUG
            if (CompModSwitches.LookupNode.TraceVerbose) Debug.WriteLine("Binding lookup column " + this.ToString());
#endif

            if (table == null)
                throw ExprException.ExpressionUnbound(this.ToString());

            // First find parent table

            DataRelationCollection relations;
            relations = table.ParentRelations;

            if (relationName == null) {
                // must have one and only one relation

                if (relations.Count > 1) {
                    throw ExprException.UnresolvedRelation(table.TableName, this.ToString());
                }
                relation = relations[0];
            }
            else {
                relation = relations[relationName];
            }

            Debug.Assert(relation != null, "The relation should be resolved (bound) at this point.");

            this.table = relation.ParentTable;

            Debug.Assert(relation != null, "Invalid relation: no parent table.");
            Debug.Assert(columnName != null, "All Lookup expressions have columnName set.");

            this.column = this.table.Columns[columnName];

            if (column == null)
                throw ExprException.UnboundName(columnName);

            // add column to the dependency list

            Debug.Assert(column != null, "Failed to bind column " + columnName);

            int i;
            for (i = 0; i < list.Count; i++) {
                // walk the list, check if the current column already on the list
                DataColumn dataColumn = (DataColumn)list[i];
                if (column == dataColumn) {
#if DEBUG
                    if (CompModSwitches.LookupNode.TraceVerbose) Debug.WriteLine("the column found in the dependency list");
#endif
                    break;
                }
            }
            if (i >= list.Count) {
#if DEBUG
                if (CompModSwitches.LookupNode.TraceVerbose) Debug.WriteLine("Adding column to our dependency list: " + column.ColumnName);
#endif
                list.Add(column);
            }
        }

        internal override object Eval() {
            throw ExprException.EvalNoContext();
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
#if DEBUG
            if (CompModSwitches.LookupNode.TraceVerbose) Debug.WriteLine("Eval " + this.ToString());
#endif

            if (table == null || column == null || relation == null)
                throw ExprException.ExpressionUnbound(this.ToString());

            DataRow parent = row.GetParentRow(relation, version);
            if (parent == null)
                return DBNull.Value;

            return parent[column, parent.HasVersion(version) ? version : DataRowVersion.Current]; // haroona : Bug 76154
        }

        internal override object Eval(int[] recordNos) {
            throw ExprException.ComputeNotAggregate(this.ToString());
        }

        public override string ToString() {
            string lookup = "parent";

            if (relationName != null) {
                lookup += "([" + relationName + "])";
            }
            lookup += ".[" + columnName + "]";

            return lookup;
        }

        internal override bool IsConstant() {
            return false;
        }

        internal override bool IsTableConstant() {
            return false;
        }

        internal override bool HasLocalAggregate() {
            return false;
        }

        internal override bool DependsOn(DataColumn column) {
            if (this.column == column) {
                return true;
            }
            return false;
        }

        internal override ExpressionNode Optimize() {
#if DEBUG
            if (CompModSwitches.LookupNode.TraceVerbose) Debug.WriteLine("Aggregate: Optimize");
#endif
            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\namenode.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
    using System.Collections;
    using System.Diagnostics;

    internal class NameNode : ExpressionNode {
        internal char open = '\0';
        internal char close = '\0';
        internal string name;
        internal bool found;
        internal bool type = false;
        internal DataTable table;
        internal DataColumn column;

        internal NameNode(char[] text, int start, int pos) {
            this.name = ParseName(text, start, pos);
        }

        internal NameNode(string name) {
            this.name = name;
        }

        internal override void Bind(DataTable table, ArrayList list) {

            if (table == null)
                throw ExprException.UnboundName(name);

            try {
                this.column = table.Columns[name];
                this.table = table;
            }
            catch (Exception) {
#if DEBUG
                if (CompModSwitches.NameNode.TraceVerbose) Debug.WriteLine("Can not find column " + name);
#endif

                found = false;

                throw ExprException.UnboundName(name);
            }

            if (column == null)
                throw ExprException.UnboundName(name);

#if DEBUG
            if (CompModSwitches.NameNode.TraceVerbose) Debug.WriteLine("Binding name node " + name);
#endif
            name = column.ColumnName;
            found = true;

            // add column to the dependency list, do not add duplicate columns
            Debug.Assert(column != null, "Failed to bind column " + name);

            int i;
            for (i = 0; i < list.Count; i++) {
                // walk the list, check if the current column already on the list
                DataColumn dataColumn = (DataColumn)list[i];
                if (column == dataColumn) {
#if DEBUG
                    if (CompModSwitches.NameNode.TraceVerbose) Debug.WriteLine("the column found in the dependency list");
#endif
                    break;
                }
            }
            if (i >= list.Count) {
#if DEBUG
                if (CompModSwitches.NameNode.TraceVerbose) Debug.WriteLine("Adding column to our dependency list: " + column.ColumnName);
#endif
                list.Add(column);
            }
        }

        internal override object Eval() {
            // can not eval column without ROW value;
            throw ExprException.EvalNoContext();
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            if (!found) {
#if DEBUG
                if (CompModSwitches.NameNode.TraceVerbose) Debug.WriteLine("Can not find column " + name);
#endif
                throw ExprException.UnboundName(name);
            }

            if (row == null) {
                if(IsTableConstant()) // this column is TableConstant Aggregate Function
                    return column.DataExpression.Evaluate();
                else {
#if DEBUG
                    if (CompModSwitches.NameNode.TraceVerbose) Debug.WriteLine("Can not eval column without a row.." + name);
#endif
                    throw ExprException.UnboundName(name);
                }
            }

            return column[row.GetRecordFromVersion(version)];
        }

        internal override object Eval(int[] records) {
            throw ExprException.ComputeNotAggregate(this.ToString());
        }

        public override string ToString() {
            if (open != '\0') {
                Debug.Assert(close != '\0', "Invalid bracketed column name");
                return(open.ToString() + name + close.ToString());
            }
            else
                return "[" + name + "]";
        }

        internal override bool IsConstant() {
            return false;
        }

        internal override bool IsTableConstant() {
            if (column != null && column.Computed) {
                return this.column.DataExpression.IsTableAggregate();
            }
            return false;
        }

        internal override bool HasLocalAggregate() {
            if (column != null && column.Computed) {
                return this.column.DataExpression.HasLocalAggregate();
            }
            return false;
        }

        internal override bool DependsOn(DataColumn column) {
            if (this.column == column)
                return true;

            if (this.column.Computed) {
                return this.column.DataExpression.DependsOn(column);
            }

            return false;
        }

        internal override ExpressionNode Optimize() {
            return this;
        }

        /// <include file='doc\NameNode.uex' path='docs/doc[@for="NameNode.ParseName"]/*' />
        /// <devdoc>
        ///     Parses given name and checks it validity
        /// </devdoc>
        internal static string ParseName(char[] text, int start, int pos) {
            char esc = '\0';
            string charsToEscape = "";
            int saveStart = start;
            int savePos = pos;

            if (text[start] == '`') {
                Debug.Assert(text[pos-1] == '`', "Invalid identifyer bracketing, pos = " + pos.ToString() + ", end = " + text[pos-1].ToString());
                start++;
                pos--;
                esc = '\\';
                charsToEscape = "`";
            }
            else if (text[start] == '[') {
                Debug.Assert(text[pos-1] == ']', "Invalid identifyer bracketing of name " + new string(text, start, pos-start) + " pos = " + pos.ToString() + ", end = " + text[pos-1].ToString());
                start++;
                pos--;
                esc = '\\';
                charsToEscape = "]\\";
            }

            if (esc != '\0') {
                // scan the name in search for the ESC
                int posEcho = start;

                for (int i = start; i < pos; i++) {
                    if (text[i] == esc) {
                        if (i+1 < pos && charsToEscape.IndexOf(text[i+1]) >= 0) {
                            i++;
                        }
                    }
                    text[posEcho] = text[i];
                    posEcho++;
                }
                pos = posEcho;
            }

            if (pos == start)
                throw ExprException.InvalidName(new string(text, saveStart, savePos - saveStart));

            return new string(text, start, pos - start);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\dataexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression"]/*' />
    [Serializable]
    internal class DataExpression {
        internal string originalExpression = null;  // original, unoptimized string
        private string optimizedExpression = null; // string after optimization

        internal bool parsed = false;
        internal bool bound = false;
        internal ExpressionNode expr = null;
        internal DataTable table = null;
        internal Type type = null;  // This set if the expression is part of ExpressionCoulmn
        internal DataColumn[] dependency = new DataColumn[0];

        internal virtual void CheckExpression(string expression) {
            ExpressionParser parser = new ExpressionParser();
            parser.LoadExpression(expression);
            expr = null;
            parsed = false;
            bound = false;

            originalExpression = expression;
            optimizedExpression = null;

            if (expression != null) {
                expr = parser.Parse();
                parsed = true;
                bound = false;
            }
            if (expr != null) {
                this.Bind(table);
            }
        }

        internal static bool IsUnknown(object value) {
            if (value == DBNull.Value)
                return true;
            if (null == value)
                return true;
            return false;
        }

        internal static bool ToBoolean(object value) {
            return ToBoolean(value, true);
        }

        internal static bool ToBoolean(object value, bool strict) {
            if (IsUnknown(value))
                return false;
            if (value is bool)
                return(bool)value;
            if (value is string) {
                try {
                    return Boolean.Parse((string)value);
                }
                catch (Exception) {
                    // CONSIDER: keep the original exception, add it to the error text
                    throw ExprException.DatavalueConvertion(value, typeof(bool));
                }
            }
            if (!strict) {
                // convert whole numeric values to boolean:
                if (ExpressionNode.IsInteger(value.GetType())) {
                    return(Int64)value != 0;
                }
            }

            throw ExprException.DatavalueConvertion(value, typeof(bool));
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.DataExpression"]/*' />
        public DataExpression() {
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.DataExpression1"]/*' />
        public DataExpression(string expression, DataTable table) : this(expression, table, null) {
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.DataExpression2"]/*' />
        public DataExpression(string expression, DataTable table, Type type) {
            ExpressionParser parser = new ExpressionParser();
            parser.LoadExpression(expression);

            originalExpression = expression;
            optimizedExpression = null;
            expr = null;

            if (expression != null) {
                this.type = type;
                expr = parser.Parse();
                parsed = true;
                if (expr != null && table != null) {
                    this.Bind(table);
                }
                else {
                    bound = false;
                }
            }
        }

        private string OptimizedExpression {
            get {
                if (optimizedExpression == null && expr != null)
                    optimizedExpression = expr.ToString();

                return optimizedExpression;
            }
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.Expression"]/*' />
        [DefaultValue("")]
        public virtual string Expression {
            get {
                return (originalExpression != null ? originalExpression : ""); // CONSIDER: return optimized expression here (if bound)
            }
            set {
                if (originalExpression != value && OptimizedExpression != value) {
                    CheckExpression(value);
                }
            }
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.Bind"]/*' />
        public virtual void Bind(DataTable table) {
#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Bind current expression in the table " + (table != null ? table.TableName : "null"));
#endif
            this.table = table;

            if (table == null)
                return;

            if (expr != null) {
                Debug.Assert(parsed, "Invalid calling order: Bind() before Parse()");
                ArrayList list = new ArrayList();
                expr.Bind(table, list);
                expr = expr.Optimize();
                this.table = table;
                optimizedExpression = null;
                Debug.Assert(list != null, "Invlid dependency list");
                bound = true;
                dependency = new DataColumn[list.Count];
                list.CopyTo(dependency, 0);

#if DEBUG
                if (dependency == null) {
                    if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("no dependencies");
                }
                else {
                    if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("have dependencies: " + dependency.Length.ToString());
                    for (int i = 0; i < dependency.Length; i++) {
                        //UNDONE : Debug.WriteLineIf("DataExpression", dependency[i].ColumnName);
                    }
                }
#endif

            }
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.Evaluate"]/*' />
        public virtual object Evaluate() {
            return Evaluate((DataRow)null, DataRowVersion.Default);
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.Evaluate1"]/*' />
        public virtual object Evaluate(DataRow row, DataRowVersion version) {
            object result;

            if (!bound) {
                this.Bind(this.table);
            }
            if (expr != null) {
                result = expr.Eval(row, version);
                if (result != DBNull.Value) {
                    // we need to convert the return value to the column.Type;
                    try {
                        if (typeof(object) != this.type) {
                            result = Convert.ChangeType(result, this.type);
                        }
                    }
                    catch (Exception) {
                        // CONSIDER: keep the original exception, add it to the error text
                        // CONSIDER: Get the column name in the error to know which computation is failing.
                        throw ExprException.DatavalueConvertion(result, type);
                    }
                }
            }
            else {
                result = null;
            }
            return result;
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.Evaluate2"]/*' />
        public virtual object Evaluate(DataRow[] rows) {
            return Evaluate(rows, DataRowVersion.Default);
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.Evaluate3"]/*' />

        public virtual object Evaluate(DataRow[] rows, DataRowVersion version) {
            if (!bound) {
                this.Bind(this.table);
            }
            if (expr != null) {
                int[] records = new int[rows.Length];
                for (int i = 0; i < rows.Length; i++) {
                    records[i] = rows[i].GetRecordFromVersion(version);
                }
                return expr.Eval(records);
            }
            else {
                return DBNull.Value;
            }
        }

        /// <include file='doc\DataExpression.uex' path='docs/doc[@for="DataExpression.ToString"]/*' />
        public override string ToString() {
            if (expr != null) {
                return(this.expr.ToString());
            }
            else {
                return String.Empty;
            }
        }

        internal bool DependsOn(DataColumn column) {
            if (expr != null) {
                return expr.DependsOn(column);
            }
            else {
                return false;
            }
        }

        internal DataColumn[] GetDependency() {
            Debug.Assert(dependency != null, "GetDependencies: null, we should have created an empty list");
            return dependency;
        }

        internal bool IsTableAggregate() {
            if (expr != null)
                return expr.IsTableConstant();
            else
                return false;
        }

        internal bool HasLocalAggregate() {
            if (expr != null)
                return expr.HasLocalAggregate();
            else
                return false;
        }
    }

    internal class ColumnQueue {
        DataTable owner;

        internal DataColumn[] columns = new DataColumn[2];
        internal int columnCount = 0;

        internal ColumnQueue() {
        }

        internal ColumnQueue(DataTable table) : this(table, null) {
        }

        internal ColumnQueue(DataTable table, ColumnQueue old) {
            Debug.Assert(table != null, "ColumnQueue: Invalid parameter (table == null)");
            Debug.Assert(table.TableName != null, "ColumnQueue: Invalid parameter Where is the table name?");

#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Create ColumnQueue for table " + table.TableName);
#endif
            DataColumn[] allcolumns = new DataColumn[table.Columns.Count];
            table.Columns.CopyTo(allcolumns, 0);

            this.owner = table;

            InitQueue(this, allcolumns);

#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) {
                Debug.WriteLine("we have " + columnCount.ToString() + " column in the column queue");
            }
            //for (int i = 0; i < columnCount; i++) {
                //UNDONE : Debug.WriteLineIf("DataExpression", i.ToString() + ", " + columns[i].ColumnName);
            //}
#endif

            // scan the old evaluation queue for the external dependencies,
            // and add then at the end of the new evaluation queue.

            if (old != null && old.columnCount != 0) {
                for (int i = 0; i < old.columnCount; i++) {
                    if (old.columns[i] == null) {
                        break;
                    }
                    if (old.columns[i].Table != null && old.columns[i].Table != owner) {
                        AddColumn(old.columns[i]);
                    }
                }
            }
        }

        private static void InitQueue(ColumnQueue queue, DataColumn[] cols) {
#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("InitQueue");
            if (CompModSwitches.DataExpression.TraceVerbose) {
                Debug.WriteLine("Building columnQueue, current size is " + queue.columns.Length.ToString() + " next element " + queue.columnCount.ToString());
                Debug.WriteLine("Dependencies..");
            }
            //for (int i = 0; i < cols.Length; i++) {
                //UNDONE : Debug.WriteLineIf("DataExpression", cols[i].ColumnName);
            //}

#endif

            for (int i = 0; i < cols.Length; i++) {
                DataColumn column = cols[i];

                // for all Computed columns, get the list of the dependencies

                if (column.Computed) {
#if DEBUG
                    if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Looking at the expression column " + column.ColumnName + "=" + column.Expression);
#endif

                    DataColumn[] dependency = column.DataExpression.GetDependency();

                    int j;
                    // look through the expression dependencies in search of "foreign" columns

                    for (j = 0; j < dependency.Length; j++) {
                        if (dependency[j].Table != queue.owner) {
                            dependency[j].Table.Columns.ColumnQueue.AddColumn(column);
                        }
                    }

                    InitQueue(queue, dependency);

                    // add the current column to the queue, if its not there already

#if DEBUG
                    if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("InitQueue: Check if column [" + column.ColumnName + "] already in the list.");
#endif
                    for (j = 0; j < queue.columnCount; j++) {
                        if (queue.columns[j] == column) {
#if DEBUG
                            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Found column [" + column.ColumnName + "] in pos " + j.ToString());
#endif
                            break;
                        }
                    }
                    if (j >= queue.columnCount) {
#if DEBUG
                        if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Add column [" + column.ColumnName + "], columns = " + queue.columnCount.ToString());
#endif
                        queue.AddColumn(column);
#if DEBUG
                        if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("And now we have columns = " + queue.columnCount.ToString());
#endif
                    }
                }
#if DEBUG
                else if (CompModSwitches.DataExpression.TraceVerbose) {
                    Debug.WriteLine("not computed column " + column.ColumnName);
                }
#endif
            }
        }

        internal virtual void AddColumn(DataColumn column) {
            Debug.Assert(column != null, "Invalid parameter column (null)");
            Debug.Assert(column.Computed, "Invalid parameter column (not an expression)");

#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Add column [" + column.ColumnName + "], to table " + owner.TableName);
#endif

            if (columnCount == columns.Length) {
                DataColumn[] bigger = new DataColumn[columnCount * 2];
                Array.Copy(columns, 0, bigger, 0, columnCount);
                columns = bigger;
            }
            columns[columnCount++] = column;
        }

        internal virtual void Evaluate(DataRow row) {
            if (row.oldRecord != -1) {
                Evaluate(row, DataRowVersion.Original);
            }
            if (row.newRecord != -1) {
                Evaluate(row, DataRowVersion.Current);
            }
            if (row.tempRecord != -1) {
                Evaluate(row, DataRowVersion.Proposed);
            }
        }

        internal virtual void Evaluate(DataRow row, DataRowVersion version) {
#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Evaluate expression column Queue, version = " + version.ToString() + " for table " + owner.TableName);
#endif
            Debug.Assert(columns != null, "Invalid dependensy list");
            Debug.Assert(row != null, "Invalid argument to Evaluate, row");
            for (int i = 0; i < columnCount; i++) {
                DataColumn col = columns[i];
                Debug.Assert(col.Computed, "Only computed columns should be in the queue.");

#if DEBUG
                if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Evaluate column " + col.ColumnName + " = " + col.DataExpression.ToString());
#endif

                if (col.Table == null)
                    continue;

                if (col.Table != owner) {

                    // first if the column belongs to an other table we need to recalc it for each row in the foreing table

#if DEBUG
                    if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("the column belong to a different table %%%%%%%");
#endif
                    // we need to update all foreign table - NOPE, only those who are valid parents. ALTHOUGH we're skipping old parents right now... confirm.
                    DataRowVersion foreignVer = (version == DataRowVersion.Proposed) ? DataRowVersion.Default : version;

                    int parentRelationCount = owner.ParentRelations.Count;
                    for (int j = 0; j < parentRelationCount; j++) {
                        DataRelation relation = owner.ParentRelations[j];
                        if (relation.ParentTable != col.Table)
                            continue;
                        DataRow parentRow = row.GetParentRow(relation, version);
                        if (parentRow != null) {
                            col[parentRow.GetRecordFromVersion(foreignVer)] = col.DataExpression.Evaluate(parentRow, foreignVer);
                        }
                    }

                    int childRelationCount = owner.ChildRelations.Count;
                    for (int j = 0; j < childRelationCount; j++) {
                        DataRelation relation = owner.ChildRelations[j];
                        if (relation.ChildTable != col.Table)
                            continue;
                        DataRow[] childRows = row.GetChildRows(relation, version);
                        for (int k = 0; k < childRows.Length; k++) {
                            if (childRows[k] != null) {
                                col[childRows[k].GetRecordFromVersion(foreignVer)] = col.DataExpression.Evaluate(childRows[k], foreignVer);
                            }
                        }
                    }

                }
                else if (col.DataExpression.HasLocalAggregate()) {

                    // if column expression references a local Table aggregate we need to recalc it for the each row in the local table

                    DataRowVersion aggVersion  = (version == DataRowVersion.Proposed) ? DataRowVersion.Default : version;
#if DEBUG
                    if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("it has local aggregate.");
#endif
                    bool isConst = col.DataExpression.IsTableAggregate();
                    object val = null;

                    if (isConst) {
                        val = col.DataExpression.Evaluate(row, aggVersion);
                    }

                    DataRow[] rows = new DataRow[col.Table.Rows.Count];
                    col.Table.Rows.CopyTo(rows, 0);
                    
                    for (int j = 0; j < rows.Length; j++) {
                        if (!isConst) {
                            val = col.DataExpression.Evaluate(rows[j], aggVersion);
                        }
                        col[rows[j].GetRecordFromVersion(aggVersion)] = val;
                    }
                }
                else {
                    col[row.GetRecordFromVersion(version)] = col.DataExpression.Evaluate(row, version);
                }
            }
        }

        internal virtual void Clear() {
#if DEBUG
            if (CompModSwitches.DataExpression.TraceVerbose) Debug.WriteLine("Clear expression column Queue.");
#endif
            this.columns = new DataColumn[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\ifilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Data;
    using System.Diagnostics;

    /// <include file='doc\IFilter.uex' path='docs/doc[@for="IFilter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal interface IFilter {
        /// <include file='doc\IFilter.uex' path='docs/doc[@for="IFilter.Invoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool Invoke(DataRow row, DataRowVersion version);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\filterexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="FilterException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Runtime.Serialization;

    /// <include file='doc\FilterException.uex' path='docs/doc[@for="InvalidExpressionException"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class InvalidExpressionException : DataException {
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="InvalidExpressionException.InvalidExpressionException2"]/*' />
        protected InvalidExpressionException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }

        /// <include file='doc\FilterException.uex' path='docs/doc[@for="InvalidExpressionException.InvalidExpressionException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InvalidExpressionException() : base() {}
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="InvalidExpressionException.InvalidExpressionException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InvalidExpressionException(string s) : base(s) {}
    }

    /// <include file='doc\FilterException.uex' path='docs/doc[@for="EvaluateException"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class EvaluateException : InvalidExpressionException {
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="EvaluateException.EvaluateException2"]/*' />
        protected EvaluateException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="EvaluateException.EvaluateException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EvaluateException() : base() {}
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="EvaluateException.EvaluateException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EvaluateException(string s) : base(s) {}
    }

    /// <include file='doc\FilterException.uex' path='docs/doc[@for="SyntaxErrorException"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class SyntaxErrorException : InvalidExpressionException {
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="SyntaxErrorException.SyntaxErrorException2"]/*' />
        protected SyntaxErrorException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }

        /// <include file='doc\FilterException.uex' path='docs/doc[@for="SyntaxErrorException.SyntaxErrorException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SyntaxErrorException() : base() {}
        /// <include file='doc\FilterException.uex' path='docs/doc[@for="SyntaxErrorException.SyntaxErrorException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SyntaxErrorException(string s) : base(s) {}
    }

    internal class ExprException : ExceptionBuilder {
        static protected Exception _Overflow(string error) {
            return Trace(new OverflowException(error));
        }
        static protected Exception _Expr(string error) {
            return Trace(new InvalidExpressionException(error));
        }
        static protected Exception _Syntax(string error) {
            return Trace(new SyntaxErrorException(error));
        }
        static protected Exception _Eval(string error) {
            return Trace(new EvaluateException(error));
        }

        static public Exception InvokeArgument() {
            return _Argument(Res.GetString(Res.Expr_InvokeArgument));
        }

        static public Exception NYI(string moreinfo) {
            string err = Res.GetString(Res.Expr_NYI, moreinfo);
            Debug.Fail(err);
            return _Expr(err);
        }

        static public Exception MissingOperand(OperatorInfo before) {
            return _Syntax(Res.GetString(Res.Expr_MissingOperand, Operators.ToString(before.op)));
        }

        static public Exception MissingOperator(string token) {
            return _Syntax(Res.GetString(Res.Expr_MissingOperand, token));
        }

        static public Exception TypeMismatch(string expr) {
            return _Eval(Res.GetString(Res.Expr_TypeMismatch, expr));
        }

        static public Exception FunctionArgumentOutOfRange(string arg, string func) {
            return _ArgumentOutOfRange(arg, Res.GetString(Res.Expr_ArgumentOutofRange, func));
        }

        static public Exception ExpressionTooComplex() {
            return _Eval(Res.GetString(Res.Expr_ExpressionTooComplex));
        }

        static public Exception UnboundName(string name) {
            return _Eval(Res.GetString(Res.Expr_UnboundName, name));
        }

        static public Exception InvalidString(string str) {
            return _Syntax(Res.GetString(Res.Expr_InvalidString, str));
        }

        static public Exception UndefinedFunction(string name) {
            return _Eval(Res.GetString(Res.Expr_UndefinedFunction, name));
        }

        static public Exception SyntaxError() {
            return _Syntax(Res.GetString(Res.Expr_Syntax));
        }

        static public Exception FunctionArgumentCount(string name) {
            return _Eval(Res.GetString(Res.Expr_FunctionArgumentCount, name));
        }

        static public Exception MissingRightParen() {
            return _Syntax(Res.GetString(Res.Expr_MissingRightParen));
        }

        static public Exception UnknownToken(string token, int position) {
            return _Syntax(Res.GetString(Res.Expr_UnknownToken, token, position.ToString()));
        }

        static public Exception UnknownToken(string tokExpected, string tokCurr, int position) {
            return _Syntax(Res.GetString(Res.Expr_UnknownToken1, tokExpected, tokCurr, position.ToString()));
        }

        static public Exception DatatypeConvertion(Type type1, Type type2) {
            return _Eval(Res.GetString(Res.Expr_DatatypeConvertion, type1.ToString(), type2.ToString()));
        }

        static public Exception DatavalueConvertion(object value, Type type) {
            return _Eval(Res.GetString(Res.Expr_DatavalueConvertion, value.ToString(), type.ToString()));
        }

        static public Exception InvalidName(string name) {
            return _Syntax(Res.GetString(Res.Expr_InvalidName, name));
        }

        static public Exception InvalidDate(string date) {
            return _Syntax(Res.GetString(Res.Expr_InvalidDate, date));
        }

        static public Exception NonConstantArgument() {
            return _Eval(Res.GetString(Res.Expr_NonConstantArgument));
        }

        static public Exception InvalidPattern(string pat) {
            return _Eval(Res.GetString(Res.Expr_InvalidPattern, pat));
        }

        static public Exception InWithoutParentheses() {
            return _Syntax(Res.GetString(Res.Expr_InWithoutParentheses));
        }

        static public Exception InWithoutList() {
            return _Syntax(Res.GetString(Res.Expr_InWithoutList));
        }

        static public Exception InvalidIsSyntax() {
            return _Syntax(Res.GetString(Res.Expr_IsSyntax));
        }

        static public Exception Overflow(Type type) {
            return _Overflow(Res.GetString(Res.Expr_Overflow, type.Name));
        }

        static public Exception ArgumentType(string function, int arg, Type type) {
            return _Eval(Res.GetString(Res.Expr_ArgumentType, function, arg.ToString(), type.ToString()));
        }

        static public Exception ArgumentTypeInteger(string function, int arg) {
            return _Eval(Res.GetString(Res.Expr_ArgumentTypeInteger, function, arg.ToString()));
        }

        static public Exception TypeMismatchInBinop(int op, Type type1, Type type2) {
            return _Eval(Res.GetString(Res.Expr_TypeMismatchInBinop, Operators.ToString(op), type1.ToString(), type2.ToString()));
        }

        static public Exception AmbiguousBinop(int op, Type type1, Type type2) {
            return _Eval(Res.GetString(Res.Expr_AmbiguousBinop, Operators.ToString(op), type1.ToString(), type2.ToString()));
        }

        static public Exception UnsupportedOperator(int op) {
            return _Eval(Res.GetString(Res.Expr_UnsupportedOperator, Operators.ToString(op)));
        }

        static public Exception InvalidNameBracketing(string name) {
            return _Syntax(Res.GetString(Res.Expr_InvalidNameBracketing, name));
        }

        static public Exception MissingOperandBefore(string op) {
            return _Syntax(Res.GetString(Res.Expr_MissingOperandBefore, op));
        }

        static public Exception TooManyRightParentheses() {
            return _Syntax(Res.GetString(Res.Expr_TooManyRightParentheses));
        }

        static public Exception UnresolvedRelation(string name, string expr) {
            return _Eval(Res.GetString(Res.Expr_UnresolvedRelation, name, expr));
        }

        static public Exception AggregateArgument() {
            return _Syntax(Res.GetString(Res.Expr_AggregateArgument));
        }

        static public Exception AggregateUnbound(string expr) {
            return _Eval(Res.GetString(Res.Expr_AggregateUnbound, expr));
        }

        static public Exception EvalNoContext() {
            return _Eval(Res.GetString(Res.Expr_EvalNoContext));
        }

        static public Exception ExpressionUnbound(string expr) {
            return _Eval(Res.GetString(Res.Expr_ExpressionUnbound, expr));
        }

        static public Exception ComputeNotAggregate(string expr) {
            return _Eval(Res.GetString(Res.Expr_ComputeNotAggregate, expr));
        }

        static public Exception FilterConvertion(string expr) {
            return _Eval(Res.GetString(Res.Expr_FilterConvertion, expr));
        }

        static public Exception LookupArgument() {
            return _Syntax(Res.GetString(Res.Expr_LookupArgument));
        }

        static public Exception InvalidType(string typeName) {
            return _Eval(Res.GetString(Res.Expr_InvalidType, typeName));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\unarynode.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnaryNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.Diagnostics;

    internal class UnaryNode : ExpressionNode {
        internal int op;

        internal ExpressionNode right;

        internal UnaryNode(int op, ExpressionNode right) {
            this.op = op;
            this.right = right;
        }

        internal override void Bind(DataTable table, ArrayList list) {
            right.Bind(table, list);
        }

        internal override object Eval() {
            return Eval(null, DataRowVersion.Default);
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            return EvalUnaryOp(op, right.Eval(row, version));
        }

        internal override object Eval(int[] recordNos) {
            return right.Eval(recordNos);
        }

        private object EvalUnaryOp(int op, object vl) {
            object value = DBNull.Value;

            if (DataExpression.IsUnknown(vl))
                return DBNull.Value;

            switch (op) {
                case Operators.Noop:
                    return vl;
                case Operators.UnaryPlus:
                    if (ExpressionNode.IsNumeric(vl.GetType())) {
                        return vl;
                    }
                    throw ExprException.TypeMismatch(this.ToString());

                case Operators.Negative:
                    // the have to be better way for doing this..
                    if (ExpressionNode.IsNumeric(vl.GetType())) {
                        if (vl is byte)
                            value = -(Byte) vl;
                        else if (vl is Int16)
                            value = -(Int16) vl;
                        else if (vl is Int32)
                            value = -(Int32) vl;
                        else if (vl is Int64)
                            value = -(Int64) vl;
                        else if (vl is Single)
                            value = -(Single) vl;
                        else if (vl is Double)
                            value = -(Double) vl;
                        else if (vl is Decimal)
                            value = -(Decimal) vl;
                        else {
                            Debug.Assert(false, "Missing a type conversion " + vl.GetType().FullName);
                            value = DBNull.Value;
                        }
                        return value;
                    }

                    throw ExprException.TypeMismatch(this.ToString());

                case Operators.Not:
                    if (DataExpression.ToBoolean(vl) != false)
                        return false;
                    return true;

                default:
                    throw ExprException.UnsupportedOperator(op);
            }
        }

        public override string ToString() {
            string str = "(" + Operators.ToString(op) + " " + right.ToString() + ")";
            return str;
        }

        internal override bool IsConstant() {
            return(right.IsConstant());
        }

        internal override bool IsTableConstant() {
            return(right.IsTableConstant());
        }

        internal override bool HasLocalAggregate() {
            return(right.HasLocalAggregate());
        }

        internal override bool DependsOn(DataColumn column) {
            return(right.DependsOn(column));
        }


        internal override ExpressionNode Optimize() {
            right = right.Optimize();

            if (this.IsConstant()) {
                object val = this.Eval();

                return new ConstNode(ValueType.Object,  val, false);
            }
            else
                return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\operators.cs ===
//------------------------------------------------------------------------------
// <copyright file="Operators.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    internal sealed class Operators {
        internal const int Noop = 0;

        /* Unary operations */

        internal const int Negative = 1;
        internal const int UnaryPlus = 2;
        internal const int Not = 3;

        /* Binary operations */

        internal const int BetweenAnd = 4;

        internal const int In = 5;
        internal const int Between = 6;

        /* Beginning of Comparison (relationa) operators */
        internal const int EqualTo = 7;     // =
        internal const int GreaterThen = 8; // >
        internal const int LessThen = 9;        // <
        internal const int GreaterOrEqual = 10;// >=
        internal const int LessOrEqual = 11;    // <=
        internal const int NotEqual = 12;       // <>
        /* End of Comparison (relational) operators */

        internal const int Is = 13;
        internal const int Like = 14;

        /* Beginning of arithmetic operators */
        internal const int Plus = 15;           // +
        internal const int Minus = 16;          // -
        internal const int Multiply = 17;       // *
        internal const int Divide = 18;     // /
        //internal final static int IntegerDiv = 19;	// \
        internal const int Modulo = 20;     // %
        //internal final static int Exponent = 21;	// **
        /* End of arithmetic operators */

        /* Beginning of bitwise operators */
        internal const int BitwiseAnd = 22; // &
        internal const int BitwiseOr = 23;      // |
        internal const int BitwiseXor = 24; // ^
        internal const int BitwiseNot = 25; // ~
        /* End of bitwise operators */

        /* Beginning of logical operators */
        internal const int And = 26;        // AND
        internal const int Or = 27;     // OR
        // internal final static int Not is in the unary ops
        /* End of logical operators */

        /* Calls/multi-valued stuff */
        internal const int Proc = 28;
        internal const int Iff = 29;
        internal const int Qual = 30;
        internal const int Dot = 31;

        /* 0-ary "operators" */
        internal const int Null = 32;
        internal const int True = 33;
        internal const int False = 34;

        internal const int Date = 35;           // Date constant
        internal const int GenUniqueId = 36;    // Generate unique ID
        internal const int  GenGUID = 37;       // Generate GUID
        internal const int  GUID = 38;          // GUID constant

        internal const int IsNot = 39;

        internal static bool IsArithmetical(int op) {
            return(op == Plus || op == Minus || op == Multiply || op == Divide || op == Modulo);
        }
        internal static bool IsLogical(int op) {
            return(op == And || op == Or || op == Not || op == Is || op == IsNot);
        }
        internal static bool IsRelational(int op) {
            return((EqualTo <= op ) &&  (op <= NotEqual));
        }

        /// <include file='doc\Operators.uex' path='docs/doc[@for="Operators.priStart"]/*' />
        /// <devdoc>
        ///     Operator priorities
        /// </devdoc>
        internal const int priStart = 0;
        internal const int priSubstr = 1;
        internal const int priParen = 2;
        internal const int priLow = 3;
        internal const int priImp = 4;
        internal const int priEqv = 5;
        internal const int priXor = 6;
        internal const int priOr = 7;
        internal const int priAnd = 8;
        internal const int priNot = 9;
        internal const int priIs = 10;
        internal const int priBetweenInLike = 11;
        internal const int priBetweenAnd = 12;
        internal const int priRelOp = 13;
        internal const int priConcat = 14;
        internal const int priContains = 15;
        internal const int priPlusMinus = 16;
        internal const int priMod = 17;
        internal const int priIDiv = 18;
        internal const int priMulDiv = 19;
        internal const int priNeg = 20;
        internal const int priExp = 21;
        internal const int priProc = 22;
        internal const int priDot = 23;
        internal const int priMax = 24;

        /// <include file='doc\Operators.uex' path='docs/doc[@for="Operators.priority"]/*' />
        /// <devdoc>
        ///     Mapping from Operator to prioritys
        ///     
        ///     CONSIDER: fast, but hard to maitain
        /// </devdoc>

        private static readonly int[] priority = new int[] {
            priStart,  // Noop
            priNeg, priNeg, priNot, // Unary -, +, Not
            priBetweenAnd, priBetweenInLike, priBetweenInLike,
            priRelOp, priRelOp, priRelOp, priRelOp, priRelOp, priRelOp,
            priIs,
            priBetweenInLike,                       // Like

            priPlusMinus, priPlusMinus,             // +, -
            priMulDiv, priMulDiv, priIDiv, priMod,  // *, /, \, Mod
            priExp,                                 // **

            priAnd, priOr, priXor, priNot,
            priAnd, priOr,

            priParen, priProc, priDot, priDot,      // Proc, Iff, Qula, Dot..

            priMax, priMax, priMax, priMax, priMax, priMax, priMax,
            priMax, priMax, priMax, priMax,
            priMax,
        };

        internal static int Priority(int op) {
            if (op > priority.Length)
                return priMax;
            return priority[op];
        }

        /// <include file='doc\Operators.uex' path='docs/doc[@for="Operators.Looks"]/*' />
        /// <devdoc>
        ///     this is array used for error messages.
        /// </devdoc>
        static readonly string[] Looks = new string[] {
            "", //Noop = 0;

            /* Unary operations */

            "-",    //Negative = 1;
            "+",    //UnaryPlus = 2;
            "Not",  //Not = 3;

            /* Binary operations */

            "BetweenAnd",   //BetweenAnd = 4;

            "In",   //In = 5;
            "Between", //Between = 6;

            /* Beginning of Comparison (relationa) operators */
            "=",    //EqualTo = 7;		// =
            ">", //GreaterThen = 8;	// >
            "<",    //LessThen = 9;		// <
            ">=", //GreaterOrEqual = 10;// >=
            "<=",       //LessOrEqual = 11;	// <=
            "<>", //NotEqual = 12;		// <>
            /* End of Comparison (relational) operators */

            "Is",       //Is = 13;
            "Like", //Like = 14;

            /* Beginning of arithmetic operators */
            "+",    //Plus = 15;			// +
            "-", //Minus = 16;			// -
            "*", //Multiply = 17;		// *
            "/",    //Divide = 18;		// /
            "\\", //IntegerDiv = 19;	// \
            "Mod", //Modulo = 20;		// %
            "**", //Exponent = 21;	// **
            /* End of arithmetic operators */

            /* Beginning of bitwise operators */
            "&",    //BitwiseAnd = 22;	// &
            "|",    //BitwiseOr = 23;		// |
            "^",    //BitwiseXor = 24;	// ^
            "~",    //BitwiseNot = 25;	// ~
            /* End of bitwise operators */

            /* Beginning of logical operators */
            "And",  //And = 26;		// AND
            "Or",       //Or = 27;		// OR
            // Not is in the unary ops
            /* End of logical operators */

            /* Calls/multi-valued stuff */
            "Proc", //Proc = 28;
            "Iff",  //Iff = 29;
            ".",    //Qual = 30;
            ".",    //Dot = 31;

            /* 0-ary "operators" */
            "Null", //Null = 32;
            "True", //True = 33;
            "False", //False = 34;

            "Date", //Date = 35;			// Date constant
            "GenUniqueId()",    //GenUniqueId = 36;	// Generate unique ID
            "GenGuid()",    //GenGUID = 37;		// Generate GUID
            "Guid {..}",    //GUID = 38;			// GUID constant

            "Is Not",   //IsNot = 39;			// internal only
        };

        internal static string ToString(int op) {

            string st;

            if (op <= Looks.Length)
                st = Looks[op];
            else
                st = "Unknown op";

            return st;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbc32.cs ===
//------------------------------------------------------------------------------
// <copyright file="Odbc32.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Data.Odbc {

    using System;
    using System.Data;
    using System.Data.Common;
    using System.Globalization;
    using System.Runtime.InteropServices;

    // the HENVENVELOPE class contains the environment handle (henv) and a refcount to ensure the handle is not
    // released until all object created on top of this hanlde are released
    //
    sealed internal class HENVENVELOPE {
        internal const Int32 oRefcount = 0*8;           // offset to the refcount
        internal const Int32 oValue = 1*8;              // offset to the Value
        internal const Int32 Size = 2*8;                // size of the henv container
    }

    sealed internal class ODC : ADP {

        static private CultureInfo GetCultureInfo() {
           int lcid = System.Globalization.CultureInfo.CurrentCulture.LCID;
           return new CultureInfo(lcid); 
        }            
        
        static internal Exception UnknownSQLType(ODBC32.SQL_TYPE sqltype) {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_UnknownSQLType, sqltype.ToString()));
        }
        static internal Exception ConnectionStringTooLong() {
            return Argument(Res.GetString(GetCultureInfo(), Res.OdbcConnection_ConnectionStringTooLong,  ODBC32.MAX_CONNECTION_STRING_LENGTH));
        }

        static internal Exception UnknownURTType(Type type) {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_UnknownURTType));
        }
        static internal Exception InvalidHandle() {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_InvalidHandle));
        }
        static internal Exception UnsupportedCommandTypeTableDirect() {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_UnsupportedCommandTypeTableDirect));
        }
        static internal Exception NegativeArgument() {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_NegativeArgument));
        }
        static internal Exception CantSetPropertyOnOpenConnection() {
            return InvalidOperation(Res.GetString(GetCultureInfo(), Res.Odbc_CantSetPropertyOnOpenConnection));
        }
        static internal Exception UnsupportedIsolationLevel(IsolationLevel isolevel) {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_UnsupportedIsolationLevel, isolevel.ToString()));
        }
        static internal Exception CantEnableConnectionpooling(ODBC32.RETCODE retcode) {
            return DataProvider(Res.GetString(GetCultureInfo(), Res.Odbc_CantEnableConnectionpooling, retcode.ToString()));
        }
        static internal Exception CantAllocateEnvironmentHandle(ODBC32.RETCODE retcode) {
            return DataProvider(Res.GetString(GetCultureInfo(), Res.Odbc_CantAllocateEnvironmentHandle, retcode.ToString()));
        }
        static internal Exception UnsupportedIsolationLevel(ODBC32.SQL_ISOLATION isolevel) {
            return DataProvider(Res.GetString(GetCultureInfo(), Res.Odbc_UnsupportedIsolationLevel, isolevel.ToString()));
        }
        static internal Exception NotInTransaction() {
            return InvalidOperation(Res.GetString(GetCultureInfo(), Res.Odbc_NotInTransaction));
        }
        static internal Exception UnknownSQLCType(ODBC32.SQL_C sqlctype) {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_UnknownSQLCType, sqlctype.ToString()));
        }
        static internal Exception UnknownOdbcType(OdbcType odbctype) {
            return Argument(Res.GetString(GetCultureInfo(), Res.Odbc_UnknownOdbcType, ((int) odbctype).ToString()));
        }

        // used by OleDbConnection to create and verify OLE DB Services
        // note that it is easyer to conclude the mdac version from oledb32 than from odbc32 since the 
        // version number schema of oledb is more obvious than that from odbc
        //
        internal const string DataLinks_CLSID = "CLSID\\{2206CDB2-19C1-11D1-89E0-00C04FD7A829}\\InprocServer32";
        internal const string OLEDB_SERVICES = "OLEDB_SERVICES";

        internal const string Pwd = "pwd";


        static internal Exception MDACSecurityHive(Exception inner) {
            return Security(Res.GetString(GetCultureInfo(), Res.OleDb_MDACSecurityHive), inner);
        }
        static internal Exception MDACSecurityFile(Exception inner) {
            return Security(Res.GetString(GetCultureInfo(), Res.OleDb_MDACSecurityFile), inner);
        }
        static internal Exception MDACNotAvailable(Exception inner) {
            return DataProvider(Res.GetString(GetCultureInfo(), Res.OleDb_MDACNotAvailable), inner);
        }
        static internal Exception MDACWrongVersion(string currentVersion) {
            return DataProvider(Res.GetString(GetCultureInfo(), Res.OleDb_MDACWrongVersion, currentVersion));
        }

    }


    sealed internal class ODBC32 {

        public enum SQL_HANDLE {
            ENV                 = 1,
            DBC                 = 2,
            STMT                = 3,
            DESC                = 4,
        };

        public enum RETCODE {
            SUCCESS             = 0,
            SUCCESS_WITH_INFO   = 1,
            ERROR               = -1,
            INVALID_HANDLE      = -2,
            NO_DATA             = 100,
        };

        public enum SQL_CONVERT {
            BIGINT              = 53,
            BINARY              = 54,
            BIT                 = 55,
            CHAR                = 56,
            DATE                = 57,
            DECIMAL             = 58,
            DOUBLE              = 59,
            FLOAT               = 60,
            INTEGER             = 61,
            LONGVARCHAR         = 62,
            NUMERIC             = 63,
            REAL                = 64,
            SMALLINT            = 65,
            TIME                = 66,
            TIMESTAMP           = 67,
            TINYINT             = 68,
            VARBINARY           = 69,
            VARCHAR             = 70,
            LONGVARBINARY       = 71,
        };

        public enum SQL_CVT {
            CHAR                = 0x00000001,
            NUMERIC             = 0x00000002,
            DECIMAL             = 0x00000004,
            INTEGER             = 0x00000008,
            SMALLINT            = 0x00000010,
            FLOAT               = 0x00000020,
            REAL                = 0x00000040,
            DOUBLE              = 0x00000080,
            VARCHAR             = 0x00000100,
            LONGVARCHAR         = 0x00000200,
            BINARY              = 0x00000400,
            VARBINARY           = 0x00000800,
            BIT                 = 0x00001000,
            TINYINT             = 0x00002000,
            BIGINT              = 0x00004000,
            DATE                = 0x00008000,
            TIME                = 0x00010000,
            TIMESTAMP           = 0x00020000,
            LONGVARBINARY       = 0x00040000,
            INTERVAL_YEAR_MONTH = 0x00080000,
            INTERVAL_DAY_TIME   = 0x00100000,
            WCHAR               = 0x00200000,
            WLONGVARCHAR        = 0x00400000,
            WVARCHAR            = 0x00800000,
            GUID                = 0x01000000,
        };

        public enum STMT {
            CLOSE               =  0,
            DROP                =  1,
            UNBIND              =  2,
            RESET_PARAMS        =  3,
        };

        public enum SQL_MAX
        {
            NUMERIC_LEN     =   16,
        };

        public enum SQL_IS
        {
            POINTER         =   -4,
            INTEGER         =   -6,
            UINTEGER        =   -5,
            SMALLINT        =   -8,
        };


        //SQL Server specific defines
        public enum SQL_HC                          // from Odbcss.h
        {
            OFF                 = 0,                //  FOR BROWSE columns are hidden
            ON                  = 1,                //  FOR BROWSE columns are exposed
        }
        public enum SQL_SS
        {
            VARIANT             =   (-150),
        }
        public enum SQL_CA_SS                       // from Odbcss.h
        {
            BASE                =   1200,           // SQL_CA_SS_BASE 

            COLUMN_HIDDEN		=   BASE + 11,      //	Column is hidden (FOR BROWSE)
            COLUMN_KEY          =   BASE + 12,      //	Column is key column (FOR BROWSE)
            VARIANT_TYPE        =   BASE + 15,
            VARIANT_SQL_TYPE    =   BASE + 16,
            VARIANT_SERVER_TYPE =   BASE + 17,

        };
        public enum SQL_SOPT_SS                     // from Odbcss.h
        {
            BASE                =   1225,           // SQL_SOPT_SS_BASE
            HIDDEN_COLUMNS		=   BASE + 2,       // Expose FOR BROWSE hidden columns
            NOBROWSETABLE       =   BASE + 3,       // Set NOBROWSETABLE option
        };

        public enum SQL_TXN
        {
            COMMIT              =   0,      //Commit
            ROLLBACK            =   1,      //Abort
        }

        public enum SQL_ISOLATION
        {
            READ_UNCOMMITTED    =   0x00000001,
            READ_COMMITTED      =   0x00000002,
            REPEATABLE_READ     =   0x00000004,
            SERIALIZABLE        =   0x00000008,
        }

        public enum SQL_PARAM
        {
            TYPE_UNKNOWN        =   0,          // SQL_PARAM_TYPE_UNKNOWN
            INPUT               =   1,          // SQL_PARAM_INPUT
            INPUT_OUTPUT        =   2,          // SQL_PARAM_INPUT_OUTPUT
            RESULT_COL          =   3,          // SQL_RESULT_COL
            OUTPUT              =   4,          // SQL_PARAM_OUTPUT
            RETURN_VALUE        =   5,          // SQL_RETURN_VALUE
        }

        public enum SQL_DESC
        {
            COUNT                  = 1001,
            TYPE                   = 1002,
            LENGTH                 = 1003,
            OCTET_LENGTH_PTR       = 1004,
            PRECISION              = 1005,
            SCALE                  = 1006,
            DATETIME_INTERVAL_CODE = 1007,
            NULLABLE               = 1008,
            INDICATOR_PTR          = 1009,
            DATA_PTR               = 1010,
            NAME                   = 1011,
            UNNAMED                = 1012,
            OCTET_LENGTH           = 1013,
            ALLOC_TYPE             = 1099,
            CONCISE_TYPE           =  2,
            UNSIGNED               = 8,
            TYPE_NAME              = 14,
            UPDATABLE              = 10,
            AUTO_UNIQUE_VALUE       = 11,

            COLUMN_NAME             =  1,
            COLUMN_TABLE_NAME       = 15,
            COLUMN_OWNER_NAME       = 16,
            COLUMN_CATALOG_NAME     = 17,

            BASE_COLUMN_NAME        = 22,
            BASE_TABLE_NAME         = 23,
        };

        // ODBC version 2.0 style attributes
        public enum SQL_COLUMN
        {
            COUNT           = 0,
            NAME            = 1,
            TYPE             = 2,
            LENGTH          = 3,
            PRECISION       = 4,
            SCALE           = 5,
            DISPLAY_SIZE    = 6,
            NULLABLE        = 7,
            UNSIGNED        = 8,
            MONEY           = 9,
            UPDATABLE       = 10,
            AUTO_INCREMENT  = 11,
            CASE_SENSITIVE  = 12,
            SEARCHABLE     = 13,
            TYPE_NAME      = 14,
            TABLE_NAME     = 15,
            OWNER_NAME    = 16,
            QUALIFIER_NAME = 17,
            LABEL            = 18,
        }

        public enum SQL_UPDATABLE
        {
            READONLY                = 0,
            WRITE                   = 1,
            READWRITE_UNKNOWN       = 2,
        }

        // Uniqueness parameter in the SQLStatistics function
        public enum SQL_INDEX
        {
            UNIQUE      = 0,
            ALL          = 1,
        }

        // Reserved parameter in the SQLStatistics function
        public enum SQL_STATISTICS_RESERVED
        {
            QUICK      = 0,
            ENSURE    = 1,
        }

        // Identifier type parameter in the SQLSpecialColumns function
        public enum SQL_SPECIALCOLS
        {
            BEST_ROWID      = 1,
            ROWVER          = 2,
        }

        // Scope parameter in the SQLSpecialColumns function
        public enum SQL_SCOPE
        {
            CURROW          = 0,
            TRANSACTION      = 1,
            SESSION          = 2,
        }

        public enum SQL_NULLABILITY
        {
            NO_NULLS    = 0,
            NULLABLE    = 1,
            UNKNOWN     = 2,
        }

        public enum SQL_UNNAMED
        {
            NAMED    = 0,
            UNNAMED    = 1,
        }
        public enum HANDLER
        {
            IGNORE                  = 0x00000000,
            THROW                   = 0x00000001,
        }

        public const Int32 SIGNED_OFFSET   =    -20;
        public const Int32 UNSIGNED_OFFSET =    -22;

        //C Data Types - used when getting data (SQLGetData)
        public enum SQL_C
        {
            CHAR            =    1,                     //SQL_C_CHAR
            WCHAR           =   -8,                     //SQL_C_WCHAR
            SLONG           =    4 + SIGNED_OFFSET,     //SQL_C_LONG+SQL_SIGNED_OFFSET
//          ULONG           =    4 + UNSIGNED_OFFSET,   //SQL_C_LONG+SQL_UNSIGNED_OFFSET
            SSHORT          =    5 + SIGNED_OFFSET,     //SQL_C_SSHORT+SQL_SIGNED_OFFSET
//          USHORT          =    5 + UNSIGNED_OFFSET,   //SQL_C_USHORT+SQL_UNSIGNED_OFFSET
            REAL            =    7,                     //SQL_C_REAL
            DOUBLE          =    8,                     //SQL_C_DOUBLE
            BIT             =   -7,                     //SQL_C_BIT
//          STINYINT        =   -6 + SIGNED_OFFSET,     //SQL_C_STINYINT+SQL_SIGNED_OFFSET
            UTINYINT        =   -6 + UNSIGNED_OFFSET,   //SQL_C_UTINYINT+SQL_UNSIGNED_OFFSET
            SBIGINT         =   -5 + SIGNED_OFFSET,     //SQL_C_SBIGINT+SQL_SIGNED_OFFSET
//          UBIGINT         =   -5 + UNSIGNED_OFFSET,   //SQL_C_UBIGINT+SQL_UNSIGNED_OFFSET
            BINARY          =   -2,                     //SQL_C_BINARY
//          TIMESTAMP       =   11,                     //SQL_C_TIMESTAMP

            TYPE_DATE       =   91,                     //SQL_C_TYPE_DATE
            TYPE_TIME       =   92,                     //SQL_C_TYPE_TIME      
            TYPE_TIMESTAMP  =   93,                     //SQL_C_TYPE_TIMESTAMP 

            NUMERIC         =    2,                     //SQL_C_NUMERIC
            GUID            =   -11,                    //SQL_C_GUID
            DEFAULT         =   99,                     //SQL_C_DEFAULT
            ARD_TYPE        =   -99,                    //SQL_ARD_TYPE
        };

        //SQL Data Types - returned as column types (SQLColAttribute)
        public enum SQL_TYPE
        {
            CHAR            =   SQL_C.CHAR,             //SQL_CHAR
            VARCHAR         =   12,                     //SQL_VARCHAR
            LONGVARCHAR     =   -1,                     //SQL_LONGVARCHAR
            WCHAR           =   SQL_C.WCHAR,            //SQL_WCHAR
            WVARCHAR        =   -9,                     //SQL_WVARCHAR
            WLONGVARCHAR    =   -10,                    //SQL_WLONGVARCHAR
            DECIMAL         =   3,                      //SQL_DECIMAL
            NUMERIC         =   SQL_C.NUMERIC,          //SQL_NUMERIC
            SMALLINT        =   5,                      //SQL_SMALLINT
            INTEGER         =   4,                      //SQL_INTEGER
            REAL            =   SQL_C.REAL,             //SQL_REAL
            FLOAT           =   6,                      //SQL_FLOAT
            DOUBLE          =   SQL_C.DOUBLE,           //SQL_DOUBLE
            BIT             =   SQL_C.BIT,              //SQL_BIT
            TINYINT         =   -6,                     //SQL_TINYINT
            BIGINT          =   -5,                     //SQL_BIGINT
            BINARY          =   SQL_C.BINARY,           //SQL_BINARY
            VARBINARY       =   -3,                     //SQL_VARBINARY
            LONGVARBINARY   =   -4,                     //SQL_LONGVARBINARY
            
//          DATE            =   9,                      //SQL_DATE
            TYPE_DATE       =   SQL_C.TYPE_DATE,        //SQL_TYPE_DATE
            TYPE_TIME       =   SQL_C.TYPE_TIME,        //SQL_TYPE_TIME      
//          TIMESTAMP       =   SQL_C.TIMESTAMP,        //SQL_TIMESTAMP
            TYPE_TIMESTAMP  =   SQL_C.TYPE_TIMESTAMP,   //SQL_TYPE_TIMESTAMP


            GUID            =   SQL_C.GUID,             //SQL_GUID
        };

        public const Int32  SQL_HANDLE_NULL  = 0;
        public const Int32  SQL_NULL_DATA    = -1;
		public const Int32  SQL_DEFAULT_PARAM= -5;
//		public const Int32  SQL_IGNORE		 = -6;


        public const Int32  COLUMN_NAME = 4;
        public const Int32  COLUMN_TYPE = 5;
        public const Int32  DATA_TYPE = 6;
        public const Int32  COLUMN_SIZE = 8;
        public const Int32  DECIMAL_DIGITS = 10;
        public const Int32  NUM_PREC_RADIX = 11;

        public enum SQL_ATTR
        {
            APP_ROW_DESC        =   10010,              // (ODBC 3.0)
            APP_PARAM_DESC      =   10011,              // (ODBC 3.0)
            IMP_ROW_DESC        =   10012,              // (ODBC 3.0)
            IMP_PARAM_DESC      =   10013,              // (ODBC 3.0)
            METADATA_ID         =   10014,              // (ODBC 3.0)
            ODBC_VERSION        =   200,
            CONNECTION_POOLING  =   201,
            AUTOCOMMIT          =   102,
            TXN_ISOLATION       =   108,
            CURRENT_CATALOG     =   109,
            LOGIN_TIMEOUT       =   103,
            QUERY_TIMEOUT       =   0,                  // from sqlext.h
            CONNECTION_DEAD     =   1209,               // from sqlext.h
        };

        //SQLGetInfo
        public enum SQL_INFO
        {
            DATA_SOURCE_NAME    = 2,			                // SQL_DATA_SOURCE_NAME in sql.h
            SERVER_NAME         = 13,                           // SQL_SERVER_NAME in sql.h
            DRIVER_NAME         = 6,                            // SQL_DRIVER_NAME as defined in sqlext.h
            DRIVER_VER          = 7,                            // SQL_DRIVER_VER as defined in sqlext.h
            ODBC_VER            = 10,                           // SQL_ODBC_VER as defined in sqlext.h
            SEARCH_PATTERN_ESCAPE = 14,                         // SQL_SEARCH_PATTERN_ESCAPE from sql.h
            DBMS_VER            = 18,
            DBMS_NAME           = 17,                           // SQL_DBMS_NAME as defined in sqlext.h
            IDENTIFIER_QUOTE_CHAR = 29,                         // SQL_IDENTIFIER_QUOTE_CHAR from sql.h
            DRIVER_ODBC_VER     = 77,                           // SQL_DRIVER_ODBC_VER as defined in sqlext.h
        };

        public const Int32  SQL_OV_ODBC3            =  3;
        public const Int32  SQL_NTS                 = -3;       //flags for null-terminated string

        //Pooling
        public const Int32  SQL_CP_OFF              =  0;       //Connection Pooling disabled
        public const Int32  SQL_CP_ONE_PER_DRIVER   =  1;       //One pool per driver
        public const Int32  SQL_CP_ONE_PER_HENV     =  2;       //One pool per environment

        public const Int32  SQL_CD_TRUE             = 1;
        public const Int32  SQL_CD_FALSE            = 0;

        public const Int32 SQL_COPT_SS_ENLIST_IN_DTC = 1207;
        public const Int32 SQL_DTC_DONE = 0;
        public const Int32 SQL_IS_POINTER = -4;

        public enum SQL_DRIVER
        {
            NOPROMPT            = 0,
            COMPLETE            = 1,
            PROMPT              = 2,
            COMPLETE_REQUIRED   = 3,
        };

        // Connection string max length
        public const Int32 MAX_CONNECTION_STRING_LENGTH    = 1024;

        // Column set for SQLPrimaryKeys
        public enum SQL_PRIMARYKEYS
        {
            CATALOGNAME     = 1,
            SCHEMANAME      = 2,
            TABLENAME        = 3,
            COLUMNNAME      = 4,
            KEY_SEQ           = 5,
            PKNAME          = 6,
        };

        // Column set for SQLStatisticss
        public enum SQL_STATISTICS
        {
            CATALOGNAME     = 1,
            SCHEMANAME      = 2,
            TABLENAME        = 3,
            NONUNIQUE      = 4,
            INDEXQUALIFIER = 5,
            INDEXNAME      = 6,
            TYPE            = 7,
            ORDINAL_POSITION = 8,
            COLUMN_NAME     = 9,
            ASC_OR_DESC     = 10,
            CARDINALITY     = 11,
            PAGES           = 12,
            FILTER_CONDITION = 13,
        };

        // Column set for SQLSpecialColumns
        public enum SQL_SPECIALCOLUMNSET
        {
            SCOPE     = 1,
            COLUMN_NAME      = 2,
            DATA_TYPE        = 3,
            TYPE_NAME        = 4,
            COLUMN_SIZE      = 5,
            BUFFER_LENGTH   = 6,
            DECIMAL_DIGITS  = 7,
            PSEUDO_COLUMN  = 8,
        };

        // Helpers
        public static OdbcErrorCollection   GetDiagErrors(string source, HandleRef hrHandle, SQL_HANDLE hType, RETCODE retcode)
        {
            switch(retcode)
            {
                case RETCODE.SUCCESS:
                    return null;

                case RETCODE.INVALID_HANDLE:
                    throw ODC.InvalidHandle();

                default:
                {
                    Int32       NativeError;
                    Int16       iRec            = 0;
                    Int16       cchActual       = 0;

                    OdbcErrorCollection errors = new OdbcErrorCollection();
                    try {
                        using (CNativeBuffer message = new CNativeBuffer(1024)) {
                            using (CNativeBuffer state = new CNativeBuffer(12)) {
                                bool moreerrors = true;
                                while(moreerrors) {

                                    retcode = (RETCODE)UnsafeNativeMethods.Odbc32.SQLGetDiagRecW(
                                        (short)hType,
                                        hrHandle,
                                        ++iRec,    //Orindals are 1:base in odbc
                                        state,
                                        out NativeError,
                                        message,
                                        (short)(message.Length/2),     //cch
                                        out cchActual);                //cch

                                    //Note: SUCCESS_WITH_INFO from SQLGetDiagRec would be because
                                    //the buffer is not large enough for the error string.
                                    moreerrors = (retcode == RETCODE.SUCCESS || retcode == RETCODE.SUCCESS_WITH_INFO);
                                    if(moreerrors)
                                    {
                                        //Sets up the InnerException as well...
                                        errors.Add(new OdbcError(
                                                source,
                                                (string)message.MarshalToManaged(SQL_C.WCHAR, SQL_NTS),
                                                (string)state.MarshalToManaged(SQL_C.WCHAR, SQL_NTS),
                                                NativeError
                                            )
                                        );
                                    }
                                }
                            }
                        }
                    }
                    catch {
                        throw;
                    }
                    return errors;
                }
            }
        }
    }

    sealed internal class TypeMap { // MDAC 68988
//      private TypeMap                                           (OdbcType odbcType,         DbType dbType,                Type type,        ODBC32.SQL_TYPE sql_type,       ODBC32.SQL_C sql_c,          ODBC32.SQL_C param_sql_c,   int bsize, int csize, bool signType) 
//      ---------------                                            ------------------         --------------                ----------        -------------------------       -------------------          -------------------------   -----------------------
        static private  readonly TypeMap _BigInt     = new TypeMap(OdbcType.BigInt,           DbType.Int64,                 typeof(Int64),    ODBC32.SQL_TYPE.BIGINT,         ODBC32.SQL_C.SBIGINT,        ODBC32.SQL_C.SBIGINT,         8, 20, true);
        static private  readonly TypeMap _Binary     = new TypeMap(OdbcType.Binary,           DbType.Binary,                typeof(byte[]),   ODBC32.SQL_TYPE.BINARY,         ODBC32.SQL_C.BINARY,         ODBC32.SQL_C.BINARY,         -1, -1, false);
        static private  readonly TypeMap _Bit        = new TypeMap(OdbcType.Bit,              DbType.Boolean,               typeof(Boolean),  ODBC32.SQL_TYPE.BIT,            ODBC32.SQL_C.BIT,            ODBC32.SQL_C.BIT,             1,  1, false);
        static internal readonly TypeMap _Char       = new TypeMap(OdbcType.Char,             DbType.AnsiStringFixedLength, typeof(String),   ODBC32.SQL_TYPE.CHAR,           ODBC32.SQL_C.WCHAR,          ODBC32.SQL_C.CHAR,           -1, -1, false);
        static private  readonly TypeMap _DateTime   = new TypeMap(OdbcType.DateTime,         DbType.DateTime,              typeof(DateTime), ODBC32.SQL_TYPE.TYPE_TIMESTAMP, ODBC32.SQL_C.TYPE_TIMESTAMP, ODBC32.SQL_C.TYPE_TIMESTAMP, 16, 23, false);
        static private  readonly TypeMap _Date       = new TypeMap(OdbcType.Date,             DbType.Date,                  typeof(DateTime), ODBC32.SQL_TYPE.TYPE_DATE,      ODBC32.SQL_C.TYPE_DATE,      ODBC32.SQL_C.TYPE_DATE,       6, 10, false);
        static private  readonly TypeMap _Time       = new TypeMap(OdbcType.Time,             DbType.Time,                  typeof(TimeSpan), ODBC32.SQL_TYPE.TYPE_TIME,      ODBC32.SQL_C.TYPE_TIME,      ODBC32.SQL_C.TYPE_TIME,       6, 12, false);
        static private  readonly TypeMap _Decimal    = new TypeMap(OdbcType.Decimal,          DbType.Decimal,               typeof(Decimal),  ODBC32.SQL_TYPE.DECIMAL,        ODBC32.SQL_C.NUMERIC,        ODBC32.SQL_C.NUMERIC,        19, 28, false);
        static private  readonly TypeMap _Double     = new TypeMap(OdbcType.Double,           DbType.Double,                typeof(Double),   ODBC32.SQL_TYPE.DOUBLE,         ODBC32.SQL_C.DOUBLE,         ODBC32.SQL_C.DOUBLE,          8, 15, false);
        static internal readonly TypeMap _Image      = new TypeMap(OdbcType.Image,            DbType.Binary,                typeof(Byte[]),   ODBC32.SQL_TYPE.LONGVARBINARY,  ODBC32.SQL_C.BINARY,         ODBC32.SQL_C.BINARY,         -1, -1, false);
        static private  readonly TypeMap _Int        = new TypeMap(OdbcType.Int,              DbType.Int32,                 typeof(Int32),    ODBC32.SQL_TYPE.INTEGER,        ODBC32.SQL_C.SLONG,          ODBC32.SQL_C.SLONG,           4, 10, true);
        static private  readonly TypeMap _NChar      = new TypeMap(OdbcType.NChar,            DbType.StringFixedLength,     typeof(String),   ODBC32.SQL_TYPE.WCHAR,          ODBC32.SQL_C.WCHAR,          ODBC32.SQL_C.WCHAR,          -1, -1, false);
        static internal readonly TypeMap _NText      = new TypeMap(OdbcType.NText,            DbType.String,                typeof(String),   ODBC32.SQL_TYPE.WLONGVARCHAR,   ODBC32.SQL_C.WCHAR,          ODBC32.SQL_C.WCHAR,          -1, -1, false);
        static private  readonly TypeMap _Numeric    = new TypeMap(OdbcType.Numeric,          DbType.Decimal,               typeof(Decimal),  ODBC32.SQL_TYPE.NUMERIC,        ODBC32.SQL_C.NUMERIC,        ODBC32.SQL_C.NUMERIC,        19, 28, false);
        static internal readonly TypeMap _NVarChar   = new TypeMap(OdbcType.NVarChar,         DbType.String,                typeof(String),   ODBC32.SQL_TYPE.WVARCHAR,       ODBC32.SQL_C.WCHAR,          ODBC32.SQL_C.WCHAR,          -1, -1, false);
        static private  readonly TypeMap _Real       = new TypeMap(OdbcType.Real,             DbType.Single,                typeof(Single),   ODBC32.SQL_TYPE.REAL,           ODBC32.SQL_C.REAL,           ODBC32.SQL_C.REAL,            4,  7, false);
        static private  readonly TypeMap _UniqueId   = new TypeMap(OdbcType.UniqueIdentifier, DbType.Guid,                  typeof(Guid),     ODBC32.SQL_TYPE.GUID,           ODBC32.SQL_C.GUID,           ODBC32.SQL_C.GUID,           16, 36, false);
        static private  readonly TypeMap _SmallDT    = new TypeMap(OdbcType.SmallDateTime,    DbType.DateTime,              typeof(DateTime), ODBC32.SQL_TYPE.TYPE_TIMESTAMP, ODBC32.SQL_C.TYPE_TIMESTAMP, ODBC32.SQL_C.TYPE_TIMESTAMP, 16, 23, false);
        static private  readonly TypeMap _SmallInt   = new TypeMap(OdbcType.SmallInt,         DbType.Int16,                 typeof(Int16),    ODBC32.SQL_TYPE.SMALLINT,       ODBC32.SQL_C.SSHORT,         ODBC32.SQL_C.SSHORT,          2,  5, true);
        static internal readonly TypeMap _Text       = new TypeMap(OdbcType.Text,             DbType.AnsiString,            typeof(String),   ODBC32.SQL_TYPE.LONGVARCHAR,    ODBC32.SQL_C.WCHAR,          ODBC32.SQL_C.CHAR,           -1, -1, false);
        static private  readonly TypeMap _Timestamp  = new TypeMap(OdbcType.Timestamp,        DbType.Binary,                typeof(Byte[]),   ODBC32.SQL_TYPE.BINARY,         ODBC32.SQL_C.BINARY,         ODBC32.SQL_C.BINARY,         -1, -1, false);
        static private  readonly TypeMap _TinyInt    = new TypeMap(OdbcType.TinyInt,          DbType.Byte,                  typeof(Byte),     ODBC32.SQL_TYPE.TINYINT,        ODBC32.SQL_C.UTINYINT,       ODBC32.SQL_C.UTINYINT,        1,  3, true);
        static private  readonly TypeMap _VarBinary  = new TypeMap(OdbcType.VarBinary,        DbType.Binary,                typeof(Byte[]),   ODBC32.SQL_TYPE.VARBINARY,      ODBC32.SQL_C.BINARY,         ODBC32.SQL_C.BINARY,         -1, -1, false);
        static internal readonly TypeMap _VarChar    = new TypeMap(OdbcType.VarChar,          DbType.AnsiString,            typeof(String),   ODBC32.SQL_TYPE.VARCHAR,        ODBC32.SQL_C.WCHAR,          ODBC32.SQL_C.CHAR,           -1, -1, false);
        static private  readonly TypeMap _Variant    = new TypeMap(OdbcType.Binary,            DbType.Binary,                typeof(object), (ODBC32.SQL_TYPE)ODBC32.SQL_SS.VARIANT, ODBC32.SQL_C.BINARY,   ODBC32.SQL_C.BINARY,         -1, -1, false);

        internal readonly OdbcType _odbcType;
        internal readonly DbType   _dbType;
        internal readonly Type     _type;

        internal readonly ODBC32.SQL_TYPE _sql_type;
        internal readonly ODBC32.SQL_C    _sql_c;
        internal readonly ODBC32.SQL_C    _param_sql_c;
        

        internal readonly int _bufferSize;  // fixed length byte size to reserve for buffer
        internal readonly int _columnSize;  // column size passed to SQLBindParameter
        internal readonly bool _signType;   // this type may be has signature information

        private TypeMap(OdbcType odbcType, DbType dbType, Type type, ODBC32.SQL_TYPE sql_type, ODBC32.SQL_C sql_c, ODBC32.SQL_C param_sql_c, int bsize, int csize, bool signType) {
            _odbcType = odbcType;
            _dbType = dbType;
            _type = type;

            _sql_type = sql_type;
            _sql_c = sql_c;
            _param_sql_c = param_sql_c; // alternative sql_c type for parameters

            _bufferSize = bsize;
            _columnSize = csize;
            _signType = signType;
        }

        static internal TypeMap FromOdbcType(OdbcType odbcType) {
            switch(odbcType) {
            case OdbcType.BigInt: return _BigInt;
            case OdbcType.Binary: return _Binary;
            case OdbcType.Bit: return _Bit;
            case OdbcType.Char: return _Char;
            case OdbcType.DateTime: return _DateTime;
            case OdbcType.Date: return _Date;
            case OdbcType.Time: return _Time;
            case OdbcType.Double: return _Double;
            case OdbcType.Decimal: return _Decimal;
            case OdbcType.Image: return _Image;
            case OdbcType.Int: return _Int;
            case OdbcType.NChar: return _NChar;
            case OdbcType.NText: return _NText;
            case OdbcType.Numeric: return _Numeric;
            case OdbcType.NVarChar: return _NVarChar;
            case OdbcType.Real: return _Real;
            case OdbcType.UniqueIdentifier: return _UniqueId;
            case OdbcType.SmallDateTime: return _SmallDT;
            case OdbcType.SmallInt: return _SmallInt;
            case OdbcType.Text: return _Text;
            case OdbcType.Timestamp: return _Timestamp;
            case OdbcType.TinyInt: return _TinyInt;
            case OdbcType.VarBinary: return _VarBinary;
            case OdbcType.VarChar: return _VarChar;
            default: throw ODC.UnknownOdbcType(odbcType);
            }
        }

        static internal TypeMap FromDbType(DbType dbType) {
            switch(dbType) {
            case DbType.AnsiString: return _VarChar;
            case DbType.AnsiStringFixedLength: return _Char;
            case DbType.Binary:     return _VarBinary;
            case DbType.Byte:       return _TinyInt;
            case DbType.Boolean:    return _Bit;
            case DbType.Currency:   return _Decimal;
            case DbType.Date:       return _Date;
            case DbType.Time:       return _Time;
            case DbType.DateTime:   return _DateTime;
            case DbType.Decimal:    return _Decimal;
            case DbType.Double:     return _Double;
            case DbType.Guid:       return _UniqueId;
            case DbType.Int16:      return _SmallInt;
            case DbType.Int32:      return _Int;
            case DbType.Int64:      return _BigInt;
            case DbType.Single:     return _Real;
            case DbType.String:     return _NVarChar;
            case DbType.StringFixedLength: return _NChar;
            case DbType.Object:
            case DbType.SByte:
            case DbType.UInt16:
            case DbType.UInt32:
            case DbType.UInt64:
            case DbType.VarNumeric:
            default: throw ADP.DbTypeNotSupported(dbType, typeof(OdbcType));
            }
        }

        static internal TypeMap FromSystemType(Type dataType) {
            switch(Type.GetTypeCode(dataType)) {
            case TypeCode.Empty:     throw ADP.InvalidDataType(TypeCode.Empty);
            case TypeCode.Object:
                if (dataType == typeof(System.Byte[])) {
                    return _VarBinary;
                }
                else if (dataType == typeof(System.Guid)) {
                    return _UniqueId;
                }
                else if (dataType == typeof(System.TimeSpan)) {
                    return _Time;
                }
                throw ADP.UnknownDataType(dataType);

            case TypeCode.DBNull:    throw ADP.InvalidDataType(TypeCode.DBNull);
            case TypeCode.Boolean:   return _Bit;
            case TypeCode.Char:      return _Char;
            case TypeCode.SByte:     return _SmallInt;
            case TypeCode.Byte:      return _TinyInt;
            case TypeCode.Int16:     return _SmallInt;
            case TypeCode.UInt16:    return _Int;
            case TypeCode.Int32:     return _Int;
            case TypeCode.UInt32:    return _BigInt;
            case TypeCode.Int64:     return _BigInt;
            case TypeCode.UInt64:    return _Numeric;
            case TypeCode.Single:    return _Real;
            case TypeCode.Double:    return _Double;
            case TypeCode.Decimal:   return _Numeric;
            case TypeCode.DateTime:  return _DateTime;
            case TypeCode.String:    return _NVarChar;
            default:                 throw ADP.UnknownDataTypeCode(dataType, Type.GetTypeCode(dataType));
            }
        }

        static internal TypeMap FromSqlType(ODBC32.SQL_TYPE sqltype) {
            switch(sqltype) {
            case ODBC32.SQL_TYPE.CHAR: return _Char;
            case ODBC32.SQL_TYPE.VARCHAR: return _VarChar;
            case ODBC32.SQL_TYPE.LONGVARCHAR: return _Text;
            case ODBC32.SQL_TYPE.WCHAR: return _NChar;
            case ODBC32.SQL_TYPE.WVARCHAR: return _NVarChar;
            case ODBC32.SQL_TYPE.WLONGVARCHAR: return _NText;
            case ODBC32.SQL_TYPE.DECIMAL: return _Decimal;
            case ODBC32.SQL_TYPE.NUMERIC: return _Numeric;
            case ODBC32.SQL_TYPE.SMALLINT: return _SmallInt;
            case ODBC32.SQL_TYPE.INTEGER: return _Int;
            case ODBC32.SQL_TYPE.REAL: return _Real;
            case ODBC32.SQL_TYPE.FLOAT: return _Double;
            case ODBC32.SQL_TYPE.DOUBLE: return _Double;
            case ODBC32.SQL_TYPE.BIT: return _Bit;
            case ODBC32.SQL_TYPE.TINYINT: return _TinyInt;
            case ODBC32.SQL_TYPE.BIGINT: return _BigInt;
            case ODBC32.SQL_TYPE.BINARY: return _Binary;
            case ODBC32.SQL_TYPE.VARBINARY: return _VarBinary;
            case ODBC32.SQL_TYPE.LONGVARBINARY: return _Image;
            case ODBC32.SQL_TYPE.TYPE_DATE: return _Date;
            case ODBC32.SQL_TYPE.TYPE_TIME: return _Time;
            case ODBC32.SQL_TYPE.TYPE_TIMESTAMP: return _DateTime;
            case ODBC32.SQL_TYPE.GUID: return _UniqueId;
            case (ODBC32.SQL_TYPE)ODBC32.SQL_SS.VARIANT: return _Variant;
            default: throw ODC.UnknownSQLType(sqltype);
            }
        }

        // Upgrade integer datatypes to missinterpretaion of the highest bit
        // (e.g. 0xff could be 255 if unsigned but is -1 if signed)
        //
        static internal TypeMap UpgradeSignedType(TypeMap typeMap, bool unsigned) {
            // upgrade unsigned types to be able to hold data that has the highest bit set
            //
            if (unsigned == true) {
                switch (typeMap._dbType) {
                    case DbType.Int64:
                        return _Decimal;        // upgrade to ? bit
                    case DbType.Int32:
                        return _BigInt;         // upgrade to 64 bit
                    case DbType.Int16:
                        return _Int;            // upgrade to 32 bit
                    default:
                        return typeMap;
                } // end switch
            }
            else {
                switch (typeMap._dbType) {
                    case DbType.Byte:
                        return _SmallInt;       // upgrade to 16 bit
                    default:    
                        return typeMap;
                } // end switch
            }
        } // end UpgradeSignedType
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\dbdatarecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="DbDataRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;            //Component
using System.Data;

namespace System.Data.Odbc
{
    sealed internal class DbSchemaInfo
    {
        //Data
        public      string  _name;
        public      string  _typename;
        public      Type    _type;
        public      object  _dbtype;
        public      object  _scale;
        public      object  _precision;
    }

    // ---------------------------------------------------------------------------
    // Cache
    //
    //  This is a on-demand cache, only caching what the user requests.
    //  The reational is that for ForwardOnly access (the default and LCD of drivers)
    //  we cannot obtain the data more than once, and even GetData(0) (to determine is-null)
    //  still obtains data for fixed lenght types.

    //  So simple code like:
    //      if(!rReader.IsDBNull(i))
    //          rReader.GetInt32(i)
    //
    //  Would fail, unless we cache on the IsDBNull call, and return the cached
    //  item for GetInt32.  This actually improves perf anyway, (even if the driver could
    //  support it), since we are not making a seperate interop call...

    //  We do not cache all columns, so reading out of order is still not
    //
    // ---------------------------------------------------------------------------
    sealed internal class DbCache
    {
        //Data

        private   DbSchemaInfo[]    _schema;
        private   object[]          _values;
        private   OdbcDataReader    _record;
        internal  int               _count;
        internal  bool              _randomaccess = true;

        //Constructor
        public   DbCache(OdbcDataReader record, int count)
        {
            _count = count;
            _record = record;
            _randomaccess = ((record.commandBehavior & CommandBehavior.SequentialAccess) == 0);
            _values = new object[count];

        }

        //Accessor
        internal  object            this[int i]
        {
            get { return Values[i];     }
            set { Values[i] = value;    }
        }

        internal  object            AccessIndex(int i)
        {
            //Note: We could put this directly in this[i], instead of having an explicit overload.
            //However that means that EVERY access into the cache takes the hit of checking, so
            //something as simple as the following code would take two hits.  It's nice not to
            //have to take the hit when you know what your doing.
            //
            //  if(cache[i] == null)
            //      ....
            //  return cache[i];

            object[] values = this.Values;
            if(_randomaccess)
            {
                //Random
                //Means that the user can ask for the values int any order (ie: out of order).
                //  In order to acheive this on a forward only stream, we need to actually
                //  retreive all the value in between so they can go back to values they've skipped
                for(int c=0; c<i; c++)
                {
                    if(values[c] == null)
                        values[c] = _record.GetValue(c);
                }
            }

            return values[i];
        }

        internal object[] Values {
            get {
                return _values;
            }
        }

        internal  DbSchemaInfo      GetSchema(int i)
        {
            if(_schema == null)
                _schema = new DbSchemaInfo[Count];
            if(_schema[i] == null)
                _schema[i] = new DbSchemaInfo();
            return _schema[i];
        }

        internal int Count {
            get {
                return _count;
            }
        }

        internal void FlushValues() {
            //Set all objects to null (to explcitly release them)
            //Note: SchemaInfo remains the same for all rows - no need to reget those...
            int count = _values.Length;
            for (int i = 0; i < count; ++i) {
                _values[i] = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\zeroopnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ZeroOpNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.Diagnostics;

    internal class ZeroOpNode : ExpressionNode {
        internal int op;

        internal const int zop_True = 1;
        internal const int zop_False = 0;
        internal const int zop_Null = -1;


        internal ZeroOpNode(int op) {
            this.op = op;
            Debug.Assert(op == Operators.True || op == Operators.False || op == Operators.Null, "Invalid zero-op: " + op.ToString());
        }

        internal override void Bind(DataTable table, ArrayList list) {
        }

        internal override object Eval() {
            switch (op) {
                case Operators.True:
                    return true;
                case Operators.False:
                    return false;
                case Operators.Null:
                    return DBNull.Value;
                default:
                    Debug.Assert(op == Operators.True || op == Operators.False || op == Operators.Null, "Invalid zero-op: " + op.ToString());
                    return DBNull.Value;
            }
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            return Eval();
        }

        internal override object Eval(int[] recordNos) {
            return Eval();
        }

        internal override bool IsConstant() {
            return true;
        }

        internal override bool IsTableConstant() {
            return true;
        }

        internal override bool HasLocalAggregate() {
            return false;
        }

        internal override ExpressionNode Optimize() {
            return this;
        }

        public override string ToString() {
            return(Eval().ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbccategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Odbc {

    using System;
    using System.ComponentModel;   

    /// <include file='doc\OleDbCategoryAttribute.uex' path='docs/doc[@for="OdbcCategoryAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class OdbcCategoryAttribute : CategoryAttribute {

        /// <include file='doc\OdbcCategoryAttribute.uex' path='docs/doc[@for="OdbcCategoryAttribute.OdbcCategoryAttribute"]/*' />
        public OdbcCategoryAttribute(string category) : base(category) {
        }

        /// <include file='doc\OdbcCategoryAttribute.uex' path='docs/doc[@for="OdbcCategoryAttribute.GetLocalizedString"]/*' />
        override protected string GetLocalizedString(string value) {
            return Res.GetString(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbccommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;            //Component
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand"]/*' />
    [
    ToolboxItem(true),
    Designer("Microsoft.VSDesigner.Data.VS.OdbcCommandDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcCommand : Component, ICloneable, IDbCommand {

        private int                 commandTimeout = ADP.DefaultCommandTimeout;

        private bool                _canceling;                         // true if the command is canceling
        private bool                _isPrepared;                        // true if the command is prepared
        private bool                supportsCommandTimeout = true;

        private CommandType         commandType        = CommandType.Text;
        private string     _cmdText;

        private OdbcConnection      _connection;
        private OdbcTransaction     transaction;
        private UpdateRowSource     updatedRowSource    = UpdateRowSource.Both;

        private WeakReference weakDataReaderReference;

        internal CMDWrapper _cmdWrapper;                     //
        
        private IntPtr      _hdesc;                             // hDesc

        bool designTimeVisible;
        private OdbcParameterCollection    _parameterCollection;   // Parameter collection

        private ConnectionState cmdState;

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.OdbcCommand"]/*' />
        public OdbcCommand() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.OdbcCommand1"]/*' />
        public OdbcCommand(string cmdText) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.OdbcCommand2"]/*' />
        public OdbcCommand(string cmdText, OdbcConnection connection) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
            Connection  = connection;
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.OdbcCommand3"]/*' />
        public OdbcCommand(string cmdText, OdbcConnection connection, OdbcTransaction transaction) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
            Connection = connection;
            Transaction = transaction;
        }

        private void DisposeDeadDataReader() {
            if (ConnectionState.Fetching == cmdState) {
                if (null != this.weakDataReaderReference && !this.weakDataReaderReference.IsAlive) {
                    if (_cmdWrapper != null) {
                        if (_cmdWrapper._stmt != IntPtr.Zero) {
                            UnsafeNativeMethods.Odbc32.SQLFreeStmt(
                                _cmdWrapper, 
                                (short)ODBC32.STMT.CLOSE
                            );
                        }
                        if (_cmdWrapper._keyinfostmt != IntPtr.Zero) {
                            UnsafeNativeMethods.Odbc32.SQLFreeStmt(
                                _cmdWrapper.hKeyinfoStmt, 
                                (short)ODBC32.STMT.CLOSE
                            );
                        }
                    }
                    CloseFromDataReader();
                }
            }
        }

        private void DisposeDataReader() {
            if (null != this.weakDataReaderReference) {
                IDisposable reader = (IDisposable) this.weakDataReaderReference.Target;
                if ((null != reader) && this.weakDataReaderReference.IsAlive) {
                    ((IDisposable) reader).Dispose();
                }
                CloseFromDataReader();
            }
        }

        internal void DisconnectFromDataReaderAndConnection () {
                // get a reference to the datareader if it is alive
                OdbcDataReader liveReader = null;
                if (this.weakDataReaderReference != null){
                    OdbcDataReader reader;
                    reader = (OdbcDataReader)this.weakDataReaderReference.Target;
                    if (this.weakDataReaderReference.IsAlive) {
                        liveReader = reader;
                    }
                }

                // remove reference to this from the live datareader
                if (liveReader != null) {
                    liveReader.Command = null;
                }
                                
                this.transaction = null;

                if (null != _connection) {
                    _connection.RemoveCommand(this);
                    _connection = null;
                }

                // if the reader is dead we have to dismiss the statement
                if (liveReader == null){
                    if (_cmdWrapper != null) {
                        _cmdWrapper.Dispose(true);
                    }
                }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) {
                // release mananged objects
                this.DisconnectFromDataReaderAndConnection ();
                _parameterCollection = null;
            }
            _cmdWrapper = null;                         // let go of the CommandWrapper 
            _hdesc = IntPtr.Zero;
            _isPrepared = false;

            base.Dispose(disposing);    // notify base classes
        }

        internal bool Canceling {
            get {
                return _canceling;
            }
            set {
                _canceling = value;
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.CommandText"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(""),
        OdbcDescriptionAttribute(Res.DbCommand_CommandText),
        RefreshProperties(RefreshProperties.All), // MDAC 67707
	Editor("Microsoft.VSDesigner.Data.Odbc.Design.OdbcCommandTextEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public string CommandText {
            get {
                return ((null != _cmdText) ? _cmdText : String.Empty);
            }
            set {
                if (_cmdText != value) {
                    OnSchemaChanging(); // fire event before value is validated
                    _cmdText = value;
                    //OnSchemaChanged();
                }
            }
        }


        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.CommandTimeout"]/*' />
        [
        DefaultValue(ADP.DefaultCommandTimeout),
        OdbcDescriptionAttribute(Res.DbCommand_CommandTimeout)
        ]
        public int CommandTimeout {
            get {
                return this.commandTimeout;
            }
            set {
                if (value < 0) {
                    throw ADP.InvalidCommandTimeout(value);
                }
                this.commandTimeout = value;
            }
        }


        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.ResetCommandTimeout"]/*' />
        public void ResetCommandTimeout() {
            this.commandTimeout = ADP.DefaultCommandTimeout;
        }


        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.CommandType"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(System.Data.CommandType.Text),
        OdbcDescriptionAttribute(Res.DbCommand_CommandType),
        RefreshProperties(RefreshProperties.All)
        ]
        public CommandType CommandType {
            get {
                return this.commandType;
            }
            set  {
                if (commandType != value) {
                    OnSchemaChanging(); // fire event before value is validated
                    switch(value) { // @perfnote: Enum.IsDefined
                    case CommandType.Text:
                    case CommandType.StoredProcedure:
                        this.commandType = value;
                        break;
                    case CommandType.TableDirect:
                        throw ODC.UnsupportedCommandTypeTableDirect();
                    default:
                        throw ADP.InvalidCommandType(value);
                    }
                    //OnSchemaChanged();
                }
            }
        }


        // This will establish a relationship between the command and the connection
        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.Connection"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Behavior),
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.DbCommand_Connection),
        Editor("Microsoft.VSDesigner.Data.Design.DbConnectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OdbcConnection Connection {
            get {
                return _connection;
            }
            set {
                if (value != _connection) {
                    OnSchemaChanging(); // fire event before value is validated
                    this.DisconnectFromDataReaderAndConnection();
                    _connection = value;
                    this.supportsCommandTimeout = true;

                    if (null != _connection) {
                        _connection.AddCommand(this);
                    }
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.IDbCommand.Connection"]/*' />
        /// <internalonly/>
        IDbConnection IDbCommand.Connection {
            get {
                return Connection;
            }
            set {
                Connection = (OdbcConnection) value;
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.DesignTimeVisible"]/*' />
        [
        DefaultValue(true),
        DesignOnly(true),
        Browsable(false),
        ]
        public bool DesignTimeVisible {
            get {
                return !this.designTimeVisible;
            }
            set {
                this.designTimeVisible = !value;
                TypeDescriptor.Refresh(this); // VS7 208845
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.Parameters"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        OdbcDescriptionAttribute(Res.DbCommand_Parameters)
        ]
        public OdbcParameterCollection Parameters {
            get {
                if (null == _parameterCollection) {
                    _parameterCollection = new OdbcParameterCollection(this);
                }
                return _parameterCollection;
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.IDbCommand.Parameters"]/*' />
        /// <internalonly/>
        IDataParameterCollection IDbCommand.Parameters {
            get {
                return Parameters;
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.Transaction"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.DbCommand_Transaction)
        ]
        public OdbcTransaction Transaction {
            get {
                // if the transaction object has been zombied, just return null
                if ((null != this.transaction) && (null == this.transaction.Connection)) { // MDAC 87096
                    this.transaction = null;
                }
                return this.transaction;
            }
            set {
                if (this.transaction != value) {
                    OnSchemaChanging(); // fire event before value is validated
                    this.transaction = value;
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.IDbCommand.Transaction"]/*' />
        /// <internalonly/>
        IDbTransaction IDbCommand.Transaction {
            get {
                return Transaction;
            }
            set {
                Transaction = (OdbcTransaction) value;
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.UpdatedRowSource"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Behavior),
        DefaultValue(System.Data.UpdateRowSource.Both),
        OdbcDescriptionAttribute(Res.DbCommand_UpdatedRowSource)
        ]
        public UpdateRowSource UpdatedRowSource {
            get {
                return this.updatedRowSource;
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case UpdateRowSource.None:
                case UpdateRowSource.OutputParameters:
                case UpdateRowSource.FirstReturnedRecord:
                case UpdateRowSource.Both:
                    this.updatedRowSource = value;
                    break;
                default:
                    throw ADP.InvalidUpdateRowSource((int) value);
                }
            }
        }

        // Get the Descriptor Handle for the current statement
        //
        internal HandleRef GetDescriptorHandle() {
            if (_hdesc != IntPtr.Zero) {
                return new HandleRef (this, _hdesc);
            }
            Debug.Assert((_cmdWrapper != null), "Must have the wrapper object!");
            Debug.Assert((_cmdWrapper._stmt != IntPtr.Zero), "Must have statement handle when calling GetDescriptorHandle");
            Debug.Assert((_cmdWrapper._dataReaderBuf != null), "Must have dataReader buffer when calling GetDescriptorHandle");

            int cbActual = 0;   // Dummy value

            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetStmtAttrW(
                                _cmdWrapper,
                                (int) ODBC32.SQL_ATTR.APP_PARAM_DESC,
                                _cmdWrapper._dataReaderBuf,
                                IntPtr.Size,
                                out cbActual);

            
            if (ODBC32.RETCODE.SUCCESS != retcode)
            {
                _connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
            }
            _hdesc = Marshal.ReadIntPtr(_cmdWrapper._dataReaderBuf.Ptr, 0);
            return new HandleRef (this, _hdesc);
        }

        // GetStatementHandle
        // ------------------
        // Try to return a cached statement handle.
        // 
        // Creates a CmdWrapper object if necessary
        // If no handle is available a handle will be allocated.
        // Bindings will be unbound if a handle is cached and the bindings are invalid.
        //
        internal HandleRef GetStatementHandle () {
            ODBC32.RETCODE retcode;

            // update the command wrapper object, allocate buffer
            // create reader object
            //
            if (_cmdWrapper==null) {
                _cmdWrapper = new CMDWrapper();
            }
            _cmdWrapper._connection = _connection;
            _cmdWrapper._connectionId = _connection._dbcWrapper._instanceId;
            _cmdWrapper._cmdText = _cmdText;
            
            if (_cmdWrapper._dataReaderBuf == null) {
                _cmdWrapper._dataReaderBuf = new CNativeBuffer(4096);
            }

            // if there is already a statement handle we need to do some cleanup
            //
            if (_cmdWrapper._stmt != IntPtr.Zero) {                
                if ((null != _parameterCollection) && (0 < _parameterCollection.Count)) {
                    if (_parameterCollection.CollectionIsBound && _parameterCollection.BindingIsValid) {
                        retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLFreeStmt(
                            _cmdWrapper, 
                            (short)ODBC32.STMT.UNBIND
                        );
                        // UNBIND should never fail so we assert only
                        if (retcode != ODBC32.RETCODE.SUCCESS) {
                            Debug.Assert(false, "SQLFreeStmt(hstmt, (short)ODBC32.STMT.UNBIND) failed");
                        }
                        _parameterCollection.CollectionIsBound = false;
                    }
                }
            }
            else {
                _isPrepared = false;    // a new statement can't be prepare
                if (null != _parameterCollection){
                    _parameterCollection.CollectionIsBound = false;
                }
                _cmdWrapper.AllocateStatementHandle(ref _cmdWrapper._stmt);
            }
            return _cmdWrapper;
        }

        private HandleRef GetKeyInfoStatementHandle() {
            Debug.Assert ((_cmdWrapper!=null), "must have CmdWrapper object when calling GetKeyInfoStatementHandle()");

            IntPtr keyinfostmt = _cmdWrapper._keyinfostmt;
            if (keyinfostmt != IntPtr.Zero){
                // nothing to do
            }
            else {
                _cmdWrapper.AllocateStatementHandle(ref _cmdWrapper._keyinfostmt);
            }
            return _cmdWrapper.hKeyinfoStmt;
        }

        // OdbcCommand.Cancel()
        // 
        // In ODBC3.0 ... a call to SQLCancel when no processing is done has no effect at all
        // (ODBC Programmer's Reference ...)
        //

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.Cancel"]/*' />
        public void Cancel() {
			// see if we have a connection
            if (null == _connection) {
                throw ADP.ConnectionRequired(ADP.Cancel);
            }

            // must have an open and available connection
            if (ConnectionState.Open != _connection.State) {
                throw ADP.OpenConnectionRequired(ADP.Cancel, _connection.State);
            }

            _canceling = true;
    
            if (_cmdWrapper != null) {
                if (_cmdWrapper._stmt != IntPtr.Zero) {
                    // Cancel the statement
                    ODBC32.RETCODE retcode ;
                    retcode =(ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLCancel(
                        _cmdWrapper
                    );
    //                if (ODBC32.RETCODE.SUCCESS != retcode) {
    //                    connection.HandleError(_stmt, ODBC32.SQL_HANDLE.STMT, retcode);
    //                }
    //                DisposeDataReader();
                }
            }
        }


        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            OdbcCommand clone = new OdbcCommand();
            clone.CommandText = CommandText;
            clone.CommandTimeout = this.CommandTimeout;
            clone.CommandType = CommandType;
            clone.Connection = this.Connection;
            clone.Transaction = this.Transaction;
            clone.supportsCommandTimeout = this.supportsCommandTimeout;
            clone.UpdatedRowSource = UpdatedRowSource;

            if ((null != _parameterCollection) && (0 < Parameters.Count)) {
                OdbcParameterCollection parameters = clone.Parameters;
                foreach(ICloneable parameter in Parameters) {
                    parameters.Add(parameter.Clone());
                }
            }
            return clone;
        }

        internal bool RecoverFromConnection() {
            DisposeDeadDataReader();
            return (ConnectionState.Closed == cmdState);
        }

        internal void CloseFromConnection () {
            DisposeDataReader();
            if (_cmdWrapper!=null) {
                _cmdWrapper.Dispose(true);
            }
            _isPrepared = false;
            _hdesc = IntPtr.Zero;
            this.transaction = null;
        }

        internal void CloseFromDataReader() {
            this.weakDataReaderReference = null;
            if (ConnectionState.Fetching == cmdState) {
                _connection.SetStateFetchingFalse();
            }
            else {
                _connection.SetStateExecutingFalse();
            }
            this.cmdState = ConnectionState.Closed;
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.CreateParameter"]/*' />
        public OdbcParameter CreateParameter() {
            return new OdbcParameter();
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.IDbCommand.CreateParameter"]/*' />
        /// <internalonly/>
        IDbDataParameter IDbCommand.CreateParameter() { // MDAC 68310
            return CreateParameter();
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.ExecuteNonQuery"]/*' />
        public int ExecuteNonQuery() {
            OdbcConnection.OdbcPermission.Demand();

            try {
                using (IDataReader reader = ExecuteReaderObject(0, ADP.ExecuteNonQuery)) {
                        reader.Close();
                        return reader.RecordsAffected;
                }
            }
            catch {
                throw;
            }
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.ExecuteReader"]/*' />
        public OdbcDataReader ExecuteReader() {
            return ExecuteReader(0/*CommandBehavior*/);
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.IDbCommand.ExecuteReader"]/*' />
        /// <internalonly/>
        IDataReader IDbCommand.ExecuteReader() {
            return ExecuteReader();
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.ExecuteReader1"]/*' />
        public OdbcDataReader ExecuteReader(CommandBehavior behavior) {
            OdbcConnection.OdbcPermission.Demand();
            return ExecuteReaderObject(behavior, ADP.ExecuteReader);
        }

        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.IDbCommand.ExecuteReader1"]/*' />
        /// <internalonly/>
        IDataReader IDbCommand.ExecuteReader(CommandBehavior behavior) {
            return ExecuteReader(behavior);
        }

        private OdbcDataReader ExecuteReaderObject(CommandBehavior behavior, string method) { // MDAC 68324

            if ((_cmdText == null) || (_cmdText == "")) {
                throw (ADP.CommandTextRequired(method));
            }        

            OdbcDataReader localReader = null;
            try { // try-finally inside try-catch-throw
                try {
                    ValidateConnectionAndTransaction(method);
                    _canceling = false;

                    if (0 != (CommandBehavior.SingleRow & behavior)) {
                        // CommandBehavior.SingleRow implies CommandBehavior.SingleResult
                        behavior |= CommandBehavior.SingleResult;
                    }

                    IntPtr keyinfostmt = IntPtr.Zero;
                    ODBC32.RETCODE retcode;
                    
                    HandleRef stmt = GetStatementHandle();
                    
                    if ((behavior & CommandBehavior.KeyInfo) == CommandBehavior.KeyInfo) {
                        GetKeyInfoStatementHandle();
                    }

                    localReader = new OdbcDataReader(this, _cmdWrapper, behavior);

                    //Set command properties
                    //Not all drivers support timeout. So fail silently if error
                    if (supportsCommandTimeout) {
                        retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLSetStmtAttrW(
                            stmt, 
                            (Int32)ODBC32.SQL_ATTR.QUERY_TIMEOUT, 
                            (IntPtr)this.CommandTimeout, 
                            (Int32)ODBC32.SQL_IS.UINTEGER
                        );
                        if (ODBC32.RETCODE.SUCCESS != retcode)  {
                            supportsCommandTimeout = false;
                        }
                    }
    // todo: correct name is SQL_NB.ON/OFF for NOBROWSETABLE option (same values so not bug but should change name)
    //
    // todo: If we remember the state we can omit a lot of SQLSetStmtAttrW calls ...
    //
                    if (Connection.IsV3Driver) {
                        // Need to get the metadata information

                        //SQLServer actually requires browse info turned on ahead of time...
                        //Note: We ignore any failures, since this is SQLServer specific
                        //We won't specialcase for SQL Server but at least for non-V3 drivers 
                        if (localReader.IsBehavior(CommandBehavior.KeyInfo)) {
                            retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLSetStmtAttrW(
                                stmt, 
                                (Int32)ODBC32.SQL_SOPT_SS.NOBROWSETABLE, 
                                (IntPtr)ODBC32.SQL_HC.ON, 
                                (Int32)ODBC32.SQL_IS.INTEGER
                            );
                            retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLSetStmtAttrW(
                                stmt, 
                                (Int32)ODBC32.SQL_SOPT_SS.HIDDEN_COLUMNS, 
                                (IntPtr)ODBC32.SQL_HC.ON, 
                                (Int32)ODBC32.SQL_IS.INTEGER
                            );
                        }
                        else {
                            retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLSetStmtAttrW(
                                stmt, 
                                (Int32)ODBC32.SQL_SOPT_SS.NOBROWSETABLE, 
                                (IntPtr)ODBC32.SQL_HC.OFF, 
                                (Int32)ODBC32.SQL_IS.INTEGER
                            );
                            retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLSetStmtAttrW(
                                stmt, 
                                (Int32)ODBC32.SQL_SOPT_SS.HIDDEN_COLUMNS, 
                                (IntPtr)ODBC32.SQL_HC.OFF, 
                                (Int32)ODBC32.SQL_IS.INTEGER
                            );
                        }
                            
                    }
                    
                    if (localReader.IsBehavior(CommandBehavior.KeyInfo) ||
                       localReader.IsBehavior(CommandBehavior.SchemaOnly)) {
    #if DEBUG
                        if (AdapterSwitches.OleDbTrace.TraceInfo) {
                            ADP.DebugWriteLine("SQLPrepareW: " + CommandText);
                        }
    #endif
                        retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLPrepareW(
                            stmt, 
                            CommandText, 
                            ODBC32.SQL_NTS
                        );

                        if (ODBC32.RETCODE.SUCCESS != retcode) {
                            _connection.HandleError(stmt, ODBC32.SQL_HANDLE.STMT, retcode);
                        }
                    }

                        //Handle Parameters
                        //Note: We use the internal variable as to not instante a new object collection,
                        //for the the common case of using no parameters.
                        if ((null != _parameterCollection) && (0 < _parameterCollection.Count)) {

                            //Bind all the parameters to the statement
                            int count = _parameterCollection.Count;
                            _cmdWrapper.ReAllocParameterBuffers(count);

                            localReader.SetParameterBuffers(_cmdWrapper._parameterBuffer, _cmdWrapper._parameterintBuffer);

                            //Note: It's more efficent for this function to just tell the parameter which
                            //binding it is that for it to try and figure it out (IndexOf, etc).
                            for(int i = 0; i < count; ++i) {
                                _parameterCollection[i].Bind(_cmdWrapper, this, (short)(i+1), _cmdWrapper._parameterBuffer[i], _cmdWrapper._parameterintBuffer[i]);
                            }
                            _parameterCollection.CollectionIsBound = true;
                            _parameterCollection.BindingIsValid = true;
                        }
                    if (!localReader.IsBehavior(CommandBehavior.SchemaOnly)) {
                        if (localReader.IsBehavior(CommandBehavior.KeyInfo) || _isPrepared) {
                            //Already prepared, so use SQLExecute
                            retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLExecute(stmt);
                            // Build metadata here
                            // localReader.GetSchemaTable();
                        }
                        else {
    #if DEBUG
                            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                                ADP.DebugWriteLine("SQLExecDirectW: " + CommandText);
                            }
    #endif
                            //SQLExecDirect
                            retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLExecDirectW(
                                stmt,                           // SQLHSTMT     StatementHandle
                                CommandText,                    // SQLCHAR *     StatementText
                                ODBC32.SQL_NTS                  // SQLINTEGER     TextLength
                            );
                        }

                        //Note: Execute will return NO_DATA for Update/Delete non-row returning queries
                        if((ODBC32.RETCODE.SUCCESS != retcode) && (ODBC32.RETCODE.NO_DATA != retcode)) {
                            _connection.HandleError(stmt, ODBC32.SQL_HANDLE.STMT, retcode);
                        }
                    }
                    this.weakDataReaderReference = new WeakReference(localReader);
                    _connection.SetStateFetchingTrue();

                    // XXXCommand.Execute should position reader on first row returning result
                    // any exceptions in the initial non-row returning results should be thrown
                    // from from ExecuteXXX not the DataReader
                     if (!localReader.IsBehavior(CommandBehavior.SchemaOnly)) {
                        localReader.FirstResult();
                     }
                    cmdState = ConnectionState.Fetching;
                }
                finally {
                    if (ConnectionState.Fetching != cmdState) {
                        if (null != localReader) {
                            // clear bindings so we don't grab output parameters on a failed execute
                            int count = ((null !=  _parameterCollection) ? _parameterCollection.Count : 0);
                            for(int i = 0; i < count; ++i) {
                                _parameterCollection[i].ClearBinding();
                            }
                            ((IDisposable)localReader).Dispose();
                        }
                        if (ConnectionState.Closed != cmdState) {
                            cmdState = ConnectionState.Closed;
                            _connection.SetStateExecutingFalse();
                        }
                    }
                }
            }
            catch { // MDAC 81875
                throw;
            }
            GC.KeepAlive(localReader);
            GC.KeepAlive(this);
            return localReader;
        }


        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.ExecuteScalar"]/*' />
        public object ExecuteScalar() {
            OdbcConnection.OdbcPermission.Demand();

            object value = null;
            IDataReader reader = null;
            try { // try-finally inside try-catch-throw
                try {
                    reader = ExecuteReaderObject(0, ADP.ExecuteScalar);
                    if (reader.Read() && (0 < reader.FieldCount)) {
                        value = reader.GetValue(0);
                    }
                }
                finally {
                    if (null != reader) {
                        ((IDisposable) reader).Dispose();
                    }
                }
            }
            catch { // MDAC 81875
                throw;
            }
            return value;
        }

        //internal void OnSchemaChanged() {
        //}

        internal void OnSchemaChanging() { // MDAC 68318
            if (ConnectionState.Closed != cmdState) {
                DisposeDeadDataReader();

                if (ConnectionState.Closed != cmdState) {
                    throw ADP.CommandIsActive(this, cmdState);
                }
            }
        }


        // Prepare
        //
        // if the CommandType property is set to TableDirect Prepare does nothing. 
        // if the CommandType property is set to StoredProcedure Prepare should succeed but result
        // in a no-op
        //
        // throw InvalidOperationException 
        // if the connection is not set
        // if the connection is not open
        //
        /// <include file='doc\OdbcCommand.uex' path='docs/doc[@for="OdbcCommand.Prepare"]/*' />
        public void Prepare() {
            OdbcConnection.OdbcPermission.Demand();
            ODBC32.RETCODE retcode;

            if ((_connection == null) || (!_connection.IsOpen)) {
//todo: add meaningful test (needs to be ADP.sometext
                throw ADP.InvalidOperation("");
            }
            
            if (CommandType == CommandType.TableDirect) {
                return; // do nothing
            }

            HandleRef hstmt = GetStatementHandle();

            retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLPrepareW(
                hstmt, 
                CommandText, 
                ODBC32.SQL_NTS
            );

            if (ODBC32.RETCODE.SUCCESS != retcode) {
                _connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
            }
            _isPrepared = true;
        }




        private void ValidateConnectionAndTransaction(string method) {
            if (null == _connection) {
                throw ADP.ConnectionRequired(method);
            }
            this.transaction = _connection.SetStateExecuting(method, Transaction);
            cmdState = ConnectionState.Executing;
        }

    }

    sealed internal class CMDWrapper {
        internal string     _cmdText;

        internal IntPtr      _keyinfostmt;                       // hStmt for keyinfo
        internal IntPtr      _stmt;                              // hStmt

        internal IntPtr      _nativeParameterBuffer;             // Native memory for internal memory management
                                                                // (Performance optimization)

        internal CNativeBuffer   _dataReaderBuf;                 // Reusable DataReader buffer
        internal CNativeBuffer[] _parameterBuffer ;              // Reusable parameter buffers
        internal CNativeBuffer[] _parameterintBuffer ;           // Resuable parameter buffers

        internal IntPtr _pEnvEnvelope;                          // Item in the statment list.

        internal OdbcConnection             _connection;            // Connection
        internal long                       _connectionId;      // 

        internal CMDWrapper () {
        }

        internal HandleRef hKeyinfoStmt {
            get {
                return new HandleRef (this, _keyinfostmt);
            }
        }
        
        ~CMDWrapper () {
            Dispose(false);
        }

        internal void Dispose() {
            Dispose(true);
            GC.KeepAlive(this);
            GC.SuppressFinalize(this);
        }

        public static implicit operator HandleRef (CMDWrapper x) {
            return new HandleRef (x, x._stmt);
        }


        internal void AllocateStatementHandle (ref IntPtr hstmt) {
            Debug.Assert ((_connection != null), "Connection cannot be null at this time");

        // todo: consider doing this when the connection is set
            if (_pEnvEnvelope == IntPtr.Zero) _pEnvEnvelope = _connection._dbcWrapper._pEnvEnvelope;

            ODBC32.RETCODE retcode;
            retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLAllocHandle(
                (Int16) ODBC32.SQL_HANDLE.STMT, 
                _connection._dbcWrapper, 
                out hstmt
            );
            if (ODBC32.RETCODE.SUCCESS != retcode) {
                _connection.HandleError(_connection._dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
            }
        }

        internal void Dispose (bool disposing) {
            // Debug.WriteLine("Command: Enter DismissStatement");
            if (disposing) {
                if (_parameterBuffer != null) {
                    for (int i = 0; i < _parameterBuffer.Length; ++i) {
                        if (null != _parameterBuffer[i]) {
                            _parameterBuffer[i].Dispose();
                        }
                    }
                    _parameterBuffer = null;
                }
                if (_parameterintBuffer != null) {
                    for (int i = 0; i < _parameterintBuffer.Length; ++i) {
                        if (null != _parameterintBuffer[i]) {
                            _parameterintBuffer[i].Dispose();
                        }
                    }
                    _parameterintBuffer = null;
                }
                if (null != _dataReaderBuf) {
                    _dataReaderBuf.Dispose();
                    _dataReaderBuf = null;
                }
            }
            
            if (IntPtr.Zero != _nativeParameterBuffer) {
                Marshal.FreeCoTaskMem(_nativeParameterBuffer);
                _nativeParameterBuffer = IntPtr.Zero;
            }

//
// "DON'T EVER DO THAT" they've told us
//                
            // need to lock the dbc so that if we're disposed by the finalizer (garbage collection) and the 
            // connection is disposed by the user the dbc stays alive

            if (Interlocked.Exchange(ref _connection._dbcWrapper._dbc_lock, 1) == 1) {
                // nothing to do. The connection locked and is about to free the dbc
                // this will implicitly free the stmt for us
                _stmt = IntPtr.Zero;
                _keyinfostmt = IntPtr.Zero;
                return;
            }
            try {
                if (_stmt != IntPtr.Zero) {
                    if (_connection._dbcWrapper._instanceId == _connectionId) {
                        if (_stmt != IntPtr.Zero) {
                            UnsafeNativeMethods.Odbc32.SQLFreeHandle( 
                                (short)ODBC32.SQL_HANDLE.STMT, 
                                new HandleRef (this, _stmt)
                            );
                        }
                    }
                }

                if (_keyinfostmt != IntPtr.Zero) {
                    if (_connection._dbcWrapper._instanceId == _connectionId) {
                        if (_keyinfostmt != IntPtr.Zero) {
                            UnsafeNativeMethods.Odbc32.SQLFreeHandle( 
                                (short)ODBC32.SQL_HANDLE.STMT, 
                                new HandleRef (this, _keyinfostmt)
                            );
                        }
                    }            
                }
            }
            finally {
                _stmt = IntPtr.Zero;
                _keyinfostmt = IntPtr.Zero;
                Interlocked.Exchange(ref _connection._dbcWrapper._dbc_lock, 0);
            }
        }


        internal void ReAllocParameterBuffers(int count) {
            int oldcount = (_parameterBuffer == null) ? 0 : _parameterBuffer.Length;
            if (oldcount < count) {
                // create a new list with the required number of entries (but do not allocate buffers)
                //
                _parameterBuffer = new CNativeBuffer[count]; 
                _parameterintBuffer = new CNativeBuffer[count];

                // Resize previously allocated native memory or allocate new native memory
                //
                if (IntPtr.Zero != _nativeParameterBuffer) {
                    _nativeParameterBuffer = Marshal.ReAllocCoTaskMem(_nativeParameterBuffer, (520+24)*count);
                }
                else {
                    _nativeParameterBuffer = Marshal.AllocCoTaskMem((520+24)*count);
                }
                SafeNativeMethods.ZeroMemory(_nativeParameterBuffer, (520+24)*count);

                // Hand out small chunks of memory to all the parameter buffers
                //
                IntPtr pmem = _nativeParameterBuffer;
                for (int i = 0 ; i < count ; i++) {
                    _parameterintBuffer[i] = new CNativeBuffer(24, pmem);
                    pmem = ADP.IntPtrOffset (pmem, 24);
                    _parameterBuffer[i] = new CNativeBuffer(520, pmem);
                    pmem = ADP.IntPtrOffset (pmem, 520);
                }
                GC.KeepAlive(this);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\filter\functionnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="FunctionNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Globalization;
    
    internal class FunctionNode : ExpressionNode {
        internal string name;
        internal int info = -1;
        internal int argumentCount = 0;
        internal const int initialCapacity = 1;
        internal ExpressionNode[] arguments;

        private static readonly Function[] funcs = new Function[] {
            new Function("Abs", FunctionId.Abs, typeof(object), true, false, 1, typeof(object), null, null),
            new Function("IIf", FunctionId.Iif, typeof(object), false, false, 3, typeof(object), typeof(object), typeof(object)),
            new Function("In", FunctionId.In, typeof(bool), false, true, 1, null, null, null),
            new Function("IsNull", FunctionId.IsNull, typeof(object), false, false, 2, typeof(object), typeof(object), null),
            new Function("Len", FunctionId.Len, typeof(int), true, false, 1, typeof(string), null, null),
            new Function("Substring", FunctionId.Substring, typeof(string), true, false, 3, typeof(string), typeof(int), typeof(int)),
            new Function("Trim", FunctionId.Trim, typeof(string), true, false, 1, typeof(string), null, null),
            // convert
            new Function("Convert", FunctionId.Convert, typeof(object), false, true, 1, typeof(object), null, null),
            // store aggregates here
            new Function("Max", FunctionId.Max, typeof(object), false, false, 1, null, null, null),
            new Function("Min", FunctionId.Min, typeof(object), false, false, 1, null, null, null),
            new Function("Sum", FunctionId.Sum, typeof(object), false, false, 1, null, null, null),
            new Function("Count", FunctionId.Count, typeof(object), false, false, 1, null, null, null),
            new Function("Var", FunctionId.Var, typeof(object), false, false, 1, null, null, null),
            new Function("StDev", FunctionId.StDev, typeof(object), false, false, 1, null, null, null),
            new Function("Avg", FunctionId.Avg, typeof(object), false, false, 1, null, null, null),
        };

        internal FunctionNode(string name) {
            this.name = name;

#if DEBUG
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Create function node " + name);
#endif

            for (int i = 0; i < funcs.Length; i++) {
                if (String.Compare(funcs[i].name, name, true, CultureInfo.InvariantCulture) == 0) {
                    // we found the reserved word..
#if DEBUG
                    if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Reserved word " + name);
#endif
                    this.info = i;
                    break;
                }
            }
            if (this.info < 0) {
                throw ExprException.UndefinedFunction(this.name);
            }
        }

        internal virtual void AddArgument(ExpressionNode argument) {

#if DEBUG
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Add argument " + argument.ToString());
#endif
            Debug.Assert(info >= 0, String.Format(Res.GetString(Res.Expr_UndefinedFunction), this.name));

            if (!funcs[info].IsVariantArgumentList && argumentCount >= funcs[info].argumentCount)
                throw ExprException.FunctionArgumentCount(this.name);

            if (arguments == null) {
                arguments = new ExpressionNode[initialCapacity];
            }
            else if (argumentCount == arguments.Length) {
                ExpressionNode[] bigger = new ExpressionNode[argumentCount * 2];
                System.Array.Copy(arguments, 0, bigger, 0, argumentCount);
                arguments = bigger;
            }
            arguments[argumentCount++] = argument;

#if DEBUG
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Append argument " + argument.ToString() + " to function " + funcs[info].name);
#endif
        }

        internal override void Bind(DataTable table, ArrayList list) {
            this.Check();

            // special case for the Convert function bind only the first argument: 
            // the second argument should be a COM+ data Type stored as a name node, replace it with constant.
            if (funcs[info].id == FunctionId.Convert) {
                if (argumentCount != 2)
                    throw ExprException.FunctionArgumentCount(this.name);
                arguments[0].Bind(table, list);

                if (arguments[1].GetType() == typeof(NameNode)) {
                    NameNode type = (NameNode)arguments[1];
                    arguments[1] = new ConstNode(ValueType.Str, type.name);
                }
                arguments[1].Bind(table, list);
            }
            else {
                for (int i = 0; i < argumentCount; i++) {
                    arguments[i].Bind(table, list);
                }
            }
        }

        internal override object Eval() {
            return Eval((DataRow)null, DataRowVersion.Default);
        }

        internal override object Eval(DataRow row, DataRowVersion version) {
            Debug.Assert(info < funcs.Length && info >= 0, "Invalid function info.");

            object[] argumentValues = new object[this.argumentCount];

            Debug.Assert(this.argumentCount == funcs[info].argumentCount || funcs[info].IsVariantArgumentList, "Invalid argument argumentCount.");

            // special case of the Convert function
            if (funcs[info].id == FunctionId.Convert) {
                if (argumentCount != 2)
                    throw ExprException.FunctionArgumentCount(this.name);

                argumentValues[0] = this.arguments[0].Eval(row, version);
                argumentValues[1] = GetDataType(this.arguments[1]);
            }
            else {
                for (int i = 0; i < this.argumentCount; i++) {
                    argumentValues[i] = this.arguments[i].Eval(row, version);

                    if (funcs[info].IsValidateArguments) {
#if DEBUG
                        if (CompModSwitches.FunctionNode.TraceVerbose) {
                            Debug.WriteLine("Validate arguments for " + funcs[info].name);
                        }
#endif
                        if ((argumentValues[i] == DBNull.Value) || (typeof(object) == funcs[info].parameters[i])) {
#if DEBUG
                            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("argument " + (i+1).ToString() + " is empty");
#endif

                            // currently all supported functions with IsValidateArguments set to true
                            // NOTE: for IIF and ISNULL IsValidateArguments set to false
                            return DBNull.Value;
                        }

                        if (argumentValues[i].GetType() != funcs[info].parameters[i]) {
#if DEBUG
                            if (CompModSwitches.FunctionNode.TraceVerbose) {
                                Debug.WriteLine("change argumnet " + argumentValues[i].ToString() + " to " + funcs[info].parameters[i].ToString());
                            }
#endif
                            // We are allowing conversions in one very specific case: int, int64,...'nice' numeric to numeric..

                            if (funcs[info].parameters[i] == typeof(int) && ExpressionNode.IsInteger(argumentValues[i].GetType())) {
                                argumentValues[i] = Convert.ToInt32(argumentValues[i]);
                            }
                            else {
                                throw ExprException.ArgumentType(funcs[info].name, i+1, funcs[info].parameters[i]);
                            }
                        }
                    }
                }
            }
            return EvalFunction(funcs[info].id, argumentValues, row, version);
        }

        internal override object Eval(int[] recordNos) {
            throw ExprException.ComputeNotAggregate(this.ToString());
        }

        internal override bool IsConstant() {
            // Currently all function calls with const arguments return constant.
            // That could change in the future (if we implement Rand()...)
            // CONSIDER: We could be smarter for Iif.

            bool constant = true;

            for (int i = 0; i < this.argumentCount; i++) {
                constant = constant && this.arguments[i].IsConstant();
            }

            Debug.Assert(this.info > 0, "All function nodes should be bound at this point.");

            return(constant);
        }

        internal override bool IsTableConstant() {
            for (int i = 0; i < argumentCount; i++) {
                if (!arguments[i].IsTableConstant()) {
                    return false;
                }
            }
            return true;
        }

        internal override bool HasLocalAggregate() {
            for (int i = 0; i < argumentCount; i++) {
                if (arguments[i].HasLocalAggregate()) {
                    return true;
                }
            }
            return false;
        }

        internal override bool DependsOn(DataColumn column) {
            for (int i = 0; i < this.argumentCount; i++) {
                if (this.arguments[i].DependsOn(column))
                    return true;
            }
            return false;
        }

        internal override ExpressionNode Optimize() {
            for (int i = 0; i < this.argumentCount; i++) {
                this.arguments[i] = this.arguments[i].Optimize();
            }

            Debug.Assert(this.info > 0, "Optimizing unbound function ");

            if (funcs[this.info].id == FunctionId.In) {
                // we can not optimize the in node, just check that it has all constant arguments
                // CONSIDER : can not find better place for this.. check that the IN arguments are all constants

                if (!this.IsConstant()) {
                    throw ExprException.NonConstantArgument();
                }
            }
            else {
                if (this.IsConstant()) {
#if DEBUG
                    if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("CONSTANT function node " + this.ToString());
#endif
                    return new ConstNode(ValueType.Object, this.Eval(), false);
                }
#if DEBUG
                else {
                    if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Can not optimize the function call");
                }
#endif
            }
            return this;
        }

        private Type GetDataType(ExpressionNode node) {
            Type nodeType = node.GetType();
            string typeName = null;

            if (nodeType == typeof(NameNode)) {
                typeName = ((NameNode)node).name;
            }
            if (nodeType == typeof(ConstNode)) {
                typeName = ((ConstNode)node).val.ToString();
            }

            if (typeName == null) {
                throw ExprException.ArgumentType(funcs[info].name, 2, typeof(Type));
            }

            Type dataType = Type.GetType(typeName);

            if (dataType == null) {
                throw ExprException.InvalidType(typeName);
            }

            return dataType;
        }

        private object EvalFunction(FunctionId id, object[] argumentValues, DataRow row, DataRowVersion version) {

#if DEBUG
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("calculate " + this.ToString());
#endif

            switch (id) {
                case FunctionId.Abs:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());

                    if (ExpressionNode.IsInteger(argumentValues[0].GetType()))
                        return(Math.Abs((Int64)argumentValues[0]));
                    if (ExpressionNode.IsNumeric(argumentValues[0].GetType()))
                        return(Math.Abs((double)argumentValues[0]));

                    throw ExprException.ArgumentTypeInteger(funcs[info].name, 1);

                case FunctionId.cBool:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());

                    if (argumentValues[0] is bool)
                        return(bool)argumentValues[0];

                    if (argumentValues[0] is int)
                        return((int)argumentValues[0] != 0);

                    if (argumentValues[0] is double)
                        return((double)argumentValues[0] != 0.0);

                    if (argumentValues[0] is string)
                        return Boolean.Parse((string)argumentValues[0]);

                    throw ExprException.DatatypeConvertion(argumentValues[0].GetType(), typeof(bool));

                case FunctionId.cInt:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());
                    return Convert.ToInt32(argumentValues[0]);

                case FunctionId.cDate:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());
#if DEBUG
                    if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Convert " + Convert.ToString(argumentValues[0]) + " of " + argumentValues[0].GetType().Name + " to datetime");
#endif
                    return Convert.ToDateTime(argumentValues[0]);

                case FunctionId.cDbl:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());
                    return Convert.ToDouble(argumentValues[0]);

                case FunctionId.cStr:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());
                    return Convert.ToString(argumentValues[0]);

                case FunctionId.Charindex:
                    Debug.Assert(argumentCount == 2, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());

                    Debug.Assert(argumentValues[0] is string, "Invalid argument type for " + funcs[info].name);
                    Debug.Assert(argumentValues[1] is string, "Invalid argument type for " + funcs[info].name);

                    if ((argumentValues[0] == DBNull.Value) || (argumentValues[1] == DBNull.Value))
                        return DBNull.Value;

                    return((string)argumentValues[1]).IndexOf((string)argumentValues[0]);

                case FunctionId.Iif:
                    Debug.Assert(argumentCount == 3, "Invalid argument argumentCount: " + argumentCount.ToString());

                    object first = this.arguments[0].Eval(row, version);

                    if (DataExpression.ToBoolean(first) != false) {
                        return this.arguments[1].Eval(row, version);
                    }
                    else {
                        return this.arguments[2].Eval(row, version);
                    }

                case FunctionId.In:
                    // we never evaluate IN directly: IN as a binary operator, so evaluation of this should be in
                    // BinaryNode class
                    throw ExprException.NYI(funcs[info].name);

                case FunctionId.IsNull:
                    Debug.Assert(argumentCount == 2, "Invalid argument argumentCount: ");

                    if ((argumentValues[0]) == DBNull.Value)
                        return argumentValues[1];
                    else
                        return argumentValues[0];

                case FunctionId.Len:
                    Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());
                    Debug.Assert(argumentValues[0] is string, "Invalid argument type for " + funcs[info].name);

                    return((string)argumentValues[0]).Length;


                case FunctionId.Substring:
                    Debug.Assert(argumentCount == 3, "Invalid argument argumentCount: " + argumentCount.ToString());
                    Debug.Assert(argumentValues[0] is string, "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + funcs[info].name);
                    Debug.Assert(argumentValues[1] is int, "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + funcs[info].name);
                    Debug.Assert(argumentValues[2] is int, "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + funcs[info].name);

                    // work around the differences in COM+ and VBA implementation of the Substring function
                    // 1. The <index> Argument is 0-based in COM+, and 1-based in VBA
                    // 2. If the <Length> argument is longer then the string length COM+ throws an ArgumentException
                    //    but our users still want to get a result.

                    int start = (int)argumentValues[1] - 1;

                    int length = (int)argumentValues[2];

                    if (start < 0)
                        throw ExprException.FunctionArgumentOutOfRange("index", "Substring");

                    if (length < 0)
                        throw ExprException.FunctionArgumentOutOfRange("length", "Substring");

                    if (length == 0)
                        return "";

                    int src_length = ((string)argumentValues[0]).Length;

                    if (start > src_length) {
                        return DBNull.Value;
                    }

                    if (start + length > src_length) {
                        length = src_length - start;
                    }

                    return((string)argumentValues[0]).Substring(start, length);

                case FunctionId.Trim:
                    {
                        Debug.Assert(argumentCount == 1, "Invalid argument argumentCount for " + funcs[info].name + " : " + argumentCount.ToString());
                        Debug.Assert(argumentValues[0] is string, "Invalid argument type for " + funcs[info].name);

                        if (argumentValues[0] == DBNull.Value)
                            return DBNull.Value;

                        return(((string)argumentValues[0]).Trim());
                    }

                case FunctionId.Convert:
                    if (argumentCount != 2)
                        throw ExprException.FunctionArgumentCount(this.name);

                    if (argumentValues[0] == DBNull.Value) {
                        return DBNull.Value;
                    }

                    Type type = (Type)argumentValues[1]; 
                    Type _oType = argumentValues[0].GetType();

                    if (type != typeof(object)) {
						if ((type == typeof(Guid)) && (_oType == typeof(String)))
							return new Guid((string)argumentValues[0]);

                        if (ExpressionNode.IsFloat(_oType) && ExpressionNode.IsInteger(type))
                        {
                            if (_oType == typeof(Single)) {
                                return Convert.ChangeType((Single) Convert.ChangeType(argumentValues[0], typeof(Single)), type);
                            }
                            else if (_oType == typeof(double)) {
                                return Convert.ChangeType((double) Convert.ChangeType(argumentValues[0], typeof(double)), type);
                            }
                            else {
                                return Convert.ChangeType((decimal) Convert.ChangeType(argumentValues[0], typeof(decimal)), type);
                            }
                        }
                        return Convert.ChangeType(argumentValues[0], type);
                    }
                    return argumentValues[0];

                default:
                    throw ExprException.UndefinedFunction(funcs[info].name);
            }
        }

        public override string ToString() {
            string call = name + "("; // "Function node, info id = " + info + ", " + name + "(";

            for (int i = 0; i < argumentCount; i++) {
                call += arguments[i].ToString();
                if (i == (argumentCount - 1))
                    call += ")";
                else
                    call += ", ";
            }

            return call;
        }

        internal virtual FunctionId Aggregate {
            get {
                if (IsAggregate) {
                    return funcs[this.info].id;
                }
                return FunctionId.none;
            }
        }

        internal virtual bool IsAggregate {
            get {
                bool aggregate = (funcs[this.info].id == FunctionId.Sum) ||
                                 (funcs[this.info].id == FunctionId.Avg) ||
                                 (funcs[this.info].id == FunctionId.Min) ||
                                 (funcs[this.info].id == FunctionId.Max) ||
                                 (funcs[this.info].id == FunctionId.Count) ||
                                 (funcs[this.info].id == FunctionId.StDev) ||
                                 (funcs[this.info].id == FunctionId.Var);
                return aggregate;
            }
        }

        internal virtual void Check() {
#if DEBUG
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("Check function: " + this.name);
#endif
            Function f = funcs[info];
#if DEBUG
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine("id = " + ((int)f.id).ToString());
            if (CompModSwitches.FunctionNode.TraceVerbose) Debug.WriteLine(", arguments = " + this.argumentCount.ToString());
#endif

            if (this.info < 0)
                throw ExprException.UndefinedFunction(this.name);

            if (funcs[info].IsVariantArgumentList) {
                // for finctions with variabls argument list argumentCount is a minimal number of arguments
                if (argumentCount < funcs[info].argumentCount) {
                    // Special case for the IN operator
                    if (funcs[this.info].id == FunctionId.In)
                        throw ExprException.InWithoutList();

                    throw ExprException.FunctionArgumentCount(this.name);
                }

            }
            else {
                if (argumentCount != funcs[info].argumentCount)
                    throw ExprException.FunctionArgumentCount(this.name);
            }
        }
    }
    enum FunctionId {
        none = -1,
        Ascii = 0,
        Char = 1,
        Charindex = 2,
        Difference = 3,
        Len = 4,
        Lower = 5,
        LTrim = 6,
        Patindex = 7,
        Replicate = 8,
        Reverse = 9,
        Right = 10,
        RTrim = 11,
        Soundex = 12,
        Space = 13,
        Str = 14,
        Stuff = 15,
        Substring = 16,
        Upper = 17,
        IsNull = 18,
        Iif = 19,
        Convert = 20,
        cInt = 21,
        cBool = 22,
        cDate = 23,
        cDbl = 24,
        cStr = 25,
        Abs = 26,
        Acos = 27,
        In = 28,
        Trim = 29,
        Sum = 30,
        Avg = 31,
        Min = 32,
        Max = 33,
        Count = 34,
        StDev = 35,  // Statistical standard deviation
        Var = 37,    // Statistical variance
    }

    internal sealed class Function {
        internal readonly string name;
        internal readonly FunctionId id;
        internal readonly Type result;
        internal readonly bool IsValidateArguments;
        internal readonly bool IsVariantArgumentList;
        internal readonly int argumentCount;
        internal readonly Type[] parameters = new Type[] {null, null, null};

        internal Function() {
            this.name = null;
            this.id = FunctionId.none;
            this.result = null;
            this.IsValidateArguments = false;
            this.argumentCount = 0;
        }

        internal Function(string name, FunctionId id, Type result, bool IsValidateArguments,
                          bool IsVariantArgumentList, int argumentCount, Type a1, Type a2, Type a3) {
            this.name = name;
            this.id = id;
            this.result = result;
            this.IsValidateArguments = IsValidateArguments;
            this.IsVariantArgumentList = IsVariantArgumentList;
            this.argumentCount = argumentCount;

            if (a1 != null)
                parameters[0] = a1;
            if (a2 != null)
                parameters[1] = a2;
            if (a3 != null)
                parameters[2] = a3;
        }

        internal static string[] FunctionName = new string[] {
            "Unknown",
            "Ascii",
            "Char",
            "CharIndex",
            "Difference",
            "Len",
            "Lower",
            "LTrim",
            "Patindex",
            "Replicate",
            "Reverse",
            "Right",
            "RTrim",
            "Soundex",
            "Space",
            "Str",
            "Stuff",
            "Substring",
            "Upper",
            "IsNull",
            "Iif",
            "Convert",
            "cInt",
            "cBool",
            "cDate",
            "cDbl",
            "cStr",
            "Abs",
            "Acos",
            "In",
            "Trim",
            "Sum",
            "Avg",
            "Min",
            "Max",
            "Count",
            "StDev",
            "Var",
        };
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbccommandbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcCommandBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcCommandBuilder : Component {
        private CommandBuilder cmdBuilder;

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.OdbcCommandBuilder"]/*' />
        public OdbcCommandBuilder() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.OdbcCommandBuilder1"]/*' />
        public OdbcCommandBuilder(OdbcDataAdapter adapter) : base() {
            GC.SuppressFinalize(this);
            DataAdapter = adapter;
        }

        private CommandBuilder Builder {
            get {
                if (null == this.cmdBuilder) {
                    this.cmdBuilder = new CommandBuilder();
                }
                return this.cmdBuilder;
            }
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.DataAdapter"]/*' />
        [
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.OdbcCommandBuilder_DataAdapter)
        ]
        public OdbcDataAdapter DataAdapter {
            get {
                return (OdbcDataAdapter) Builder.DataAdapter;
            }
            set {
                Builder.DataAdapter = value;
            }
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.QuotePrefix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcCommandBuilder_QuotePrefix)
        ]
        public string QuotePrefix {
            get {
                return Builder.QuotePrefix;
            }
            set {
                Builder.QuotePrefix = value;
            }
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.QuoteSuffix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcCommandBuilder_QuoteSuffix)
        ]
        public string QuoteSuffix
        {
            get {
                return Builder.QuoteSuffix;
            }
            set {
                Builder.QuoteSuffix = value;
            }
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects
                if (null != this.cmdBuilder) {
                    this.cmdBuilder.Dispose();
                    this.cmdBuilder = null;
                }
            }
            // release unmanaged objects

            base.Dispose(disposing); // notify base classes
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.DeriveParameters"]/*' />
        static public void DeriveParameters(OdbcCommand command) { // MDAC 65927
            OdbcConnection.OdbcPermission.Demand();

            if (null == command) {
                throw ADP.ArgumentNull("command");
            }
            switch (command.CommandType) {
                case System.Data.CommandType.Text:
                    throw ADP.DeriveParametersNotSupported(command);
                case System.Data.CommandType.StoredProcedure:
                    break;
                case System.Data.CommandType.TableDirect:
                    // CommandType.TableDirect - do nothing, parameters are not supported
                    throw ADP.DeriveParametersNotSupported(command);
                default:
                    throw ADP.InvalidCommandType(command.CommandType);
            }
            if (ADP.IsEmpty(command.CommandText)) {
                throw ADP.CommandTextRequired(ADP.DeriveParameters);
            }
            OdbcConnection connection = command.Connection;
            if (null == connection) {
                throw ADP.ConnectionRequired(ADP.DeriveParameters);
            }
            ConnectionState state = connection.State;
            if (ConnectionState.Open != state) {
                throw ADP.OpenConnectionRequired(ADP.DeriveParameters, state);
            }
            OdbcParameter[] list = DeriveParametersFromStoredProcedure(connection, command);

            OdbcParameterCollection parameters = command.Parameters;
            parameters.Clear();

            int count = list.Length;
            if (0 < count) {
                for(int i = 0; i < list.Length; ++i) {
                    parameters.Add(list[i]);
                }
            }
        }


        // DeriveParametersFromStoredProcedure (
        //  OdbcConnection connection, 
        //  OdbcCommand command);
        // 
        // Uses SQLProcedureColumns to create an array of OdbcParameters
        //

        static private OdbcParameter[] DeriveParametersFromStoredProcedure(OdbcConnection connection, OdbcCommand command) {
            ArrayList rParams = new ArrayList();

            // following call ensures that the command has a statement handle allocated
            HandleRef hstmt = command.GetStatementHandle();         
            int cColsAffected;
            ODBC32.RETCODE retcode;
                
            retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLProcedureColumnsW(
                hstmt,
                null, 0,
                null, 0,
                command.CommandText, (Int16)ODBC32.SQL_NTS,
                null, 0);

            // Note: the driver does not return an error if the given stored procedure does not exist
            // therefore we cannot handle that case and just return not parameters.

            if (ODBC32.RETCODE.SUCCESS != retcode) {
                connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
            }

            OdbcDataReader reader = new OdbcDataReader(command, command._cmdWrapper, CommandBehavior.Default);

            reader.FirstResult();
            cColsAffected = reader.FieldCount;

            // go through the returned rows and filter out relevant parameter data
            //
            while (reader.Read()) {
                OdbcParameter parameter = new OdbcParameter();

                parameter.ParameterName = reader.GetString(ODBC32.COLUMN_NAME-1);
                switch ((ODBC32.SQL_PARAM)reader.GetInt16(ODBC32.COLUMN_TYPE-1)){
                    case ODBC32.SQL_PARAM.INPUT:
                        parameter.Direction = ParameterDirection.Input;
                        break;
                    case ODBC32.SQL_PARAM.OUTPUT:
                        parameter.Direction = ParameterDirection.Output;
                        break;
                    
                    case ODBC32.SQL_PARAM.INPUT_OUTPUT:
                        parameter.Direction = ParameterDirection.InputOutput;
                        break;
                    case ODBC32.SQL_PARAM.RETURN_VALUE:
                        parameter.Direction = ParameterDirection.ReturnValue;
                        break;
                    default:
                        Debug.Assert(false, "Unexpected Parametertype while DeriveParamters");
                        break;
                }
                parameter.OdbcType = TypeMap.FromSqlType((ODBC32.SQL_TYPE)reader.GetInt16(ODBC32.DATA_TYPE-1))._odbcType;
                parameter.Size = reader.GetInt32(ODBC32.COLUMN_SIZE-1);
                switch(parameter.OdbcType){
                    case OdbcType.Decimal:
                    case OdbcType.Numeric:
                        parameter.Scale = (Byte)reader.GetInt32(ODBC32.DECIMAL_DIGITS-1);
                        parameter.Precision = (Byte)reader.GetInt32(ODBC32.NUM_PREC_RADIX-1);
                    break;
                }
                rParams.Add (parameter);
            }

            retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLCloseCursor(hstmt);

            // Create a new Parameter array and copy over the ArrayList items
            //
            OdbcParameter[] pList = new OdbcParameter[rParams.Count];
            for (int i=0; i<rParams.Count; i++) {
                pList[i] = (OdbcParameter)rParams[i];
            }
            
            return pList;
        }
        

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.GetInsertCommand"]/*' />
        public OdbcCommand GetInsertCommand() {
            return (OdbcCommand) Builder.GetInsertCommand();
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.GetUpdateCommand"]/*' />
        public OdbcCommand GetUpdateCommand() {
            return (OdbcCommand) Builder.GetUpdateCommand();
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.GetDeleteCommand"]/*' />
        public OdbcCommand GetDeleteCommand() {
            return (OdbcCommand) Builder.GetDeleteCommand();
        }

        /// <include file='doc\OdbcCommandBuilder.uex' path='docs/doc[@for="OdbcCommandBuilder.RefreshSchema"]/*' />
        public void RefreshSchema()  {
            Builder.RefreshSchema();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcconnection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

// use sources file to #define HANDLEPROFILING

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection"]/*' />
    [
    DefaultEvent("InfoMessage")
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcConnection : Component, ICloneable, IDbConnection {

        static private PermissionSet _OdbcPermission;

        static internal PermissionSet OdbcPermission {
            get {
                PermissionSet permission = _OdbcPermission;
                if (null == permission) {
                    _OdbcPermission = permission = OdbcConnectionString.CreatePermission(null);
                }
                return permission;
            }
        }

        static OdbcGlobalEnv g_globalEnv = new OdbcGlobalEnv();
#if HANDLEPROFILING
        static Timestamps g_Timestamps = new Timestamps();
#endif

        private OdbcConnectionString _constr;
        private bool                 _hidePasswordPwd;

        private string cachedDriver;
        private string cachedDriverOdbcVersion;
        private int _driverOdbcMajorVersion;
        private int _driverOdbcMinorVersion;

        private ConnectionState state = ConnectionState.Closed;
        private int connectionTimeout = ADP.DefaultConnectionTimeout;

        // bitmasks for verified and supported SQLTypes. The pattern corresponds to the SQL_CTV_xxx flags
        internal int supportedSQLTypes = 0;
        internal int testedSQLTypes = 0;

        internal bool _connectionIsDead;

        private StateChangeEventHandler stateChangeEventHandler;
        private OdbcInfoMessageEventHandler infoMessageEventHandler;

        internal WeakReference weakTransaction;
        // private OdbcTransaction localTransaction;

        private WeakReference[] weakCommandCache;

        internal DBCWrapper _dbcWrapper = new DBCWrapper();

#if NEVEREVER
        static internal ItemPool _itemPool = new ItemPool();
#endif        
        private CNativeBuffer _buffer;
        private char _quoteChar;
        private char _escapeChar;

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.OdbcConnection"]/*' />
        //[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public OdbcConnection() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.OdbcConnection1"]/*' />
        //[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public OdbcConnection(string connectionString) : base() {
            GC.SuppressFinalize(this);
            ConnectionString = connectionString;
        }

        private OdbcConnection(OdbcConnection connection) : base() { // Clone
            GC.SuppressFinalize(this);
            _hidePasswordPwd = connection._hidePasswordPwd;
            _constr = connection._constr;
            connectionTimeout = connection.connectionTimeout;
            supportedSQLTypes = connection.supportedSQLTypes;
            testedSQLTypes = connection.testedSQLTypes;
            cachedDriver = connection.cachedDriver;
            cachedDriverOdbcVersion = connection.cachedDriverOdbcVersion;
            _driverOdbcMajorVersion = connection._driverOdbcMajorVersion;
            _driverOdbcMinorVersion = connection._driverOdbcMinorVersion;
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.ConnectionString"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(""),
        RecommendedAsConfigurable(true),
        RefreshProperties(RefreshProperties.All),
        OdbcDescriptionAttribute(Res.OdbcConnection_ConnectionString),
        Editor("Microsoft.VSDesigner.Data.Odbc.Design.OdbcConnectionStringEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public string ConnectionString {
            get {
                bool hidePasswordPwd = _hidePasswordPwd;
                OdbcConnectionString constr = _constr;
                return ((null != constr) ? constr.GetConnectionString(hidePasswordPwd) : ADP.StrEmpty);
            }
            set {
                if ((null != value) && (ODBC32.MAX_CONNECTION_STRING_LENGTH < value.Length)) { // MDAC 83536
                    throw ODC.ConnectionStringTooLong();
                }
                OdbcConnectionString constr = OdbcConnectionString.ParseString(value);

                ConnectionState currentState = State;
                if (ConnectionState.Closed != currentState) {
                    throw ADP.OpenConnectionPropertySet(ADP.ConnectionString, currentState);
                }
                _constr = constr;
                _hidePasswordPwd = false;

                // Have to reset these values
                this.supportedSQLTypes = 0;
                this.testedSQLTypes = 0;
                this.connectionTimeout = ADP.DefaultConnectionTimeout;
                this.cachedDriverOdbcVersion = null;
                this._quoteChar = '\0';
                this._escapeChar = '\0';
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.ConnectionTimeout"]/*' />
        [
        DefaultValue(ADP.DefaultConnectionTimeout),
//        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcConnection_ConnectionTimeout)
        ]
        public int ConnectionTimeout {
            get {
                return this.connectionTimeout;
            }
            set {
                if (value < 0)
                    throw ODC.NegativeArgument();
                if (IsOpen)
                    throw ODC.CantSetPropertyOnOpenConnection();
                this.connectionTimeout = value;
            }
        }

/*
// do we want that or not?

        public void ResetConnectionTimeout() {
            this.connectionTimeout = ADP.DefaultConnectionTimeout;
        }
*/
        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.Database"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcConnection_Database)
        ]
        public string Database {
            get {
                if(IsOpen)
                {
                    //Note: CURRENT_CATALOG may not be supported by the current driver.  In which
                    //case we ignore any error (without throwing), and just return string.empty.
                    //As we really don't want people to have to have try/catch around simple properties
                    if(-1 != GetConnectAttr(ODBC32.SQL_ATTR.CURRENT_CATALOG, ODBC32.HANDLER.IGNORE))
                        return (string)_buffer.MarshalToManaged(ODBC32.SQL_C.WCHAR, ODBC32.SQL_NTS);
                }

                //Database is not available before open, and its not worth parsing the
                //connection string over.
                return String.Empty;
            }
        }

    	/// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.DataSource"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcConnection_DataSource)
        ]
    	public string DataSource {
            get {
                if(IsOpen) {
                    // note: This will return an empty string if the driver keyword was used to connect
                    // see ODBC3.0 Programmers Reference, SQLGetInfo
                    //
                    int cbActual = GetInfo(ODBC32.SQL_INFO.SERVER_NAME);
                    return Marshal.PtrToStringUni(_buffer.Ptr, cbActual/2);
                }
                return String.Empty;
            }
       }

        internal bool IsOpen {
            get {
                return (ConnectionState.Open == (State & ConnectionState.Open));
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.ServerVersion"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcConnection_ServerVersion)
        ]
        public string ServerVersion {
            get {
                if(IsOpen) {
                    //SQLGetInfo - SQL_DBMS_VER
                    int cbActual = GetInfo(ODBC32.SQL_INFO.DBMS_VER);
                    return Marshal.PtrToStringUni(_buffer.Ptr, cbActual/2);
                }
                throw ADP.ClosedConnectionError();
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.DriverName"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.OdbcConnection_Driver)
        ]
        public string Driver {
            get {
                if(IsOpen && (null == this.cachedDriver)) {
                    int cbActual = GetInfo(ODBC32.SQL_INFO.DRIVER_NAME);
                    cachedDriver = Marshal.PtrToStringUni(_buffer.Ptr, cbActual/2);
                }
                return ((null != this.cachedDriver) ? this.cachedDriver : String.Empty);
            }
        }

        internal int OdbcMajorVersion {
            get {
                GetDriverOdbcVersion();
                return _driverOdbcMajorVersion;
            }
        }

        internal int OdbcMinorVersion {
            get {
                GetDriverOdbcVersion();
                return _driverOdbcMinorVersion;
            }
        }
        
        private void GetDriverOdbcVersion () {
            if(IsOpen && (null == this.cachedDriverOdbcVersion)) {
                try {
                    int cbActual = GetInfo(ODBC32.SQL_INFO.DRIVER_ODBC_VER);
                    cachedDriverOdbcVersion = Marshal.PtrToStringUni(_buffer.Ptr, cbActual/2);

                    _driverOdbcMajorVersion = int.Parse(cachedDriverOdbcVersion.Substring(0,2));
                    _driverOdbcMinorVersion = int.Parse(cachedDriverOdbcVersion.Substring(3,2));
                }
                catch (Exception e) {
                    cachedDriverOdbcVersion = "";
                    _driverOdbcMajorVersion = 1;
                    _driverOdbcMinorVersion = 0;
                    ADP.TraceException(e);
                }
            }
        }

        internal bool IsV3Driver {
            get {
                return (OdbcMajorVersion >= 3);
            }
        }
        
        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.State"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.DbConnection_State)
        ]
        public ConnectionState State {
            get {
                // always check if the connection is alive.
                // ConnectionIsAlive will close a dead connection
                ConnectionIsAlive(null); 
                return (ConnectionState.Open & state);
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.InfoMessage"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_InfoMessage),
        OdbcDescriptionAttribute(Res.DbConnection_InfoMessage)
        ]
        public event OdbcInfoMessageEventHandler InfoMessage {
            add {
                infoMessageEventHandler += value;
            }
            remove {
                infoMessageEventHandler -= value;
            }
        }

        internal bool IsAlive {
            get {
                return (!_connectionIsDead);
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.StateChange"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_StateChange),
        OdbcDescriptionAttribute(Res.DbConnection_StateChange)
        ]
        public event StateChangeEventHandler StateChange {
            add {
                stateChangeEventHandler += value;
            }
            remove {
                stateChangeEventHandler -= value;
            }
        }

        internal char QuoteChar {
            get {
                if ('\0' == _quoteChar) {
                    string quoteCharString;
                    Debug.Assert(IsOpen);   // this is an internal function, we can assert an open connection ...
                    int cbActual = GetInfo(ODBC32.SQL_INFO.IDENTIFIER_QUOTE_CHAR);
                    quoteCharString = Marshal.PtrToStringUni(_buffer.Ptr, cbActual/2);
                    Debug.Assert((quoteCharString.Length == 1), "Can't handle multichar quotes");
                    _quoteChar = quoteCharString[0];
                }
                return _quoteChar;
            }
        }    

        internal char EscapeChar {
            get {
                if ('\0' == _escapeChar) {
                    string escapeCharString;
                    Debug.Assert(IsOpen);   // this is an internal function, we can assert an open connection ...
                    int cbActual = GetInfo(ODBC32.SQL_INFO.SEARCH_PATTERN_ESCAPE);
                    escapeCharString = Marshal.PtrToStringUni(_buffer.Ptr, cbActual/2);
                    Debug.Assert((escapeCharString.Length == 1), "Can't handle multichar quotes");
                    _escapeChar = escapeCharString[0];
                }
                return _escapeChar;
            }
        }                    

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.BeginTransaction"]/*' />
        public OdbcTransaction BeginTransaction() {
            return BeginTransaction(IsolationLevel.ReadCommitted);
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.IDbConnection.BeginTransaction"]/*' />
        /// <internalonly/>
        IDbTransaction IDbConnection.BeginTransaction() {
            return BeginTransaction();
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.BeginTransaction1"]/*' />
        public OdbcTransaction BeginTransaction(IsolationLevel isolevel) {
            OdbcConnection.OdbcPermission.Demand(); // MDAC 81476
            return (OdbcTransaction)BeginTransactionObject(isolevel);
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.IDbConnection.BeginTransaction1"]/*' />
        /// <internalonly/>
        IDbTransaction IDbConnection.BeginTransaction(IsolationLevel isolevel) {
            return BeginTransaction(isolevel);
        }

        internal object BeginTransactionObject(IsolationLevel isolevel) {
            CheckState(ADP.BeginTransaction); // MDAC 68323

            if (this.weakTransaction != null && !this.weakTransaction.IsAlive) {
                RollbackDeadTransaction();
            }

            if ((null != this.weakTransaction) && this.weakTransaction.IsAlive) { // regression from Dispose/Finalize work
                throw ADP.ParallelTransactionsNotSupported(this);
            }

            //Use the default for unspecified.
            if(isolevel != IsolationLevel.Unspecified)
            {
                //Map to the odbc value
                ODBC32.SQL_ISOLATION sql_iso;
                switch(isolevel)
                {
                    case IsolationLevel.ReadUncommitted:
                        sql_iso = ODBC32.SQL_ISOLATION.READ_UNCOMMITTED;
                        break;
                    case IsolationLevel.ReadCommitted:
                        sql_iso = ODBC32.SQL_ISOLATION.READ_COMMITTED;
                        break;
                    case IsolationLevel.RepeatableRead:
                        sql_iso = ODBC32.SQL_ISOLATION.REPEATABLE_READ;
                        break;
                    case IsolationLevel.Serializable:
                        sql_iso = ODBC32.SQL_ISOLATION.SERIALIZABLE;
                        break;

                    case IsolationLevel.Chaos:
                    default:
                        throw ODC.UnsupportedIsolationLevel(isolevel);
                };

                //Set the isolation level (unless its unspecified)
                ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                            _dbcWrapper,
                            (Int32)ODBC32.SQL_ATTR.TXN_ISOLATION,
                            new HandleRef (null, (IntPtr)sql_iso),
                            (Int32)ODBC32.SQL_IS.INTEGER);
                //Note: The Driver can return success_with_info to indicate it "rolled" the
                //isolevel to the next higher value.  If this is the case, we need to requery
                //the value if th euser asks for it...
                //We also still propagate the info, since it could be other info as well...
                if(retcode == ODBC32.RETCODE.SUCCESS_WITH_INFO)
                    isolevel =  IsolationLevel.Unspecified;
                if(retcode != ODBC32.RETCODE.SUCCESS)
                    this.HandleError(_dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
            }

            //Start the transaction
            OdbcTransaction transaction = new OdbcTransaction(this, isolevel);
            transaction.BeginTransaction();
            _dbcWrapper._isInTransaction = true;
            this.weakTransaction = new WeakReference(transaction); // MDAC 69188
            return transaction;
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.ChangeDatabase"]/*' />
        public void ChangeDatabase(string value) {
            OdbcConnection.OdbcPermission.Demand(); // MDAC 80961

            CheckState(ADP.ChangeDatabase);

            if ((null == value) || (0 == value.Trim().Length)) { // MDAC 62679
                throw ADP.EmptyDatabaseName();
            }
            if (this.weakTransaction != null && !this.weakTransaction.IsAlive) {
                RollbackDeadTransaction();
            }

            //Marshal to the native buffer
            _buffer.MarshalToNative(value, ODBC32.SQL_C.WCHAR, 0);

            //Set the database
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                        _dbcWrapper,
                        (Int32)ODBC32.SQL_ATTR.CURRENT_CATALOG,
                        _buffer,
                        (Int32)value.Length*2);

            if(retcode != ODBC32.RETCODE.SUCCESS) {
                HandleError(_dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
            }
        }

        internal void CheckState(string method) {
            if (ConnectionState.Open != state) {
                throw ADP.OpenConnectionRequired(method, state); // MDAC 68323
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            return new OdbcConnection(this);
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.Close"]/*' />
        public void Close() {
            if (ConnectionState.Closed != this.state) {
                DisposeClose();
                OnStateChange(new StateChangeEventArgs(ConnectionState.Open, ConnectionState.Closed));
            }
        }

        internal void AddCommand(OdbcCommand value) {
            if (null == this.weakCommandCache) {
                this.weakCommandCache = new WeakReference[10];
                this.weakCommandCache[0] = new WeakReference(value);
            }
            else {
                int count = this.weakCommandCache.Length;
                for (int i = 0; i < count; ++i) {
                    WeakReference weak = this.weakCommandCache[i];
                    if (null == weak) {
                        this.weakCommandCache[i] = new WeakReference(value);
                        return;
                    }
                    else if (!weak.IsAlive) {
                        weak.Target = value;
                        return;
                    }
                }
                WeakReference[] tmp = new WeakReference[count + 10];
                for(int i = 0; i < count; ++i) {
                    tmp[i] = this.weakCommandCache[i];
                }
                tmp[count] = new WeakReference(value);
                this.weakCommandCache = tmp;
            }
        }

        internal void RemoveCommand(OdbcCommand value) {
            if (null != this.weakCommandCache) {
                int count = this.weakCommandCache.Length;
                for (int index = 0; index < count; ++index) {
                    WeakReference weak = this.weakCommandCache[index];
                    if (null != weak) {
                        if (value == (OdbcCommand) weak.Target) {
                            weak.Target = null;
                            break;
                        }
                    }
                    else break;
                }
            }
        }

        private void RollbackDeadTransaction() {
            Debug.Assert(this.weakTransaction != null, "Odbc.OdbcConnection:: RollbackDeadTransaction called when weakTransaction null");
            _dbcWrapper.RollbackDeadTransaction();
            weakTransaction = null;
        }

        private void CommandRecover() { // MDAC 69003
            if (null != this.weakCommandCache) {
                bool recovered = true;
                int length = this.weakCommandCache.Length;
                for (int i = 0; i < length; ++i) {
                    WeakReference weak = this.weakCommandCache[i];
                    if (null != weak) {
                        OdbcCommand command = (OdbcCommand) weak.Target;
                        if ((null != command) && weak.IsAlive) {
                            recovered = command.RecoverFromConnection();
                            if (!recovered) {
                                break;
                            }
                        }
                    }
                    else break;
                }
                if (recovered) {
                    this.state &= ConnectionState.Open;
                }
            }
        }

        private bool ConnectionIsAlive(Exception innerException) {
            ODBC32.RETCODE retcode;
            Int32 cbActual = 0;
            int isDead;
            if (
                !_connectionIsDead                         
                && (state != ConnectionState.Closed)         
                && (_dbcWrapper._dbc != IntPtr.Zero)
            ) {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetConnectAttrW(
                            _dbcWrapper,
                            (Int32)ODBC32.SQL_ATTR.CONNECTION_DEAD,
                            _buffer,
                            _buffer.Length,
                            out cbActual);
                if (retcode == ODBC32.RETCODE.SUCCESS || retcode == ODBC32.RETCODE.SUCCESS_WITH_INFO) {
                    isDead = Marshal.ReadInt32(_buffer.Ptr);
                    if (isDead == ODBC32.SQL_CD_TRUE) {
                        _connectionIsDead = true;
                        Close();
                        throw ADP.ConnectionIsDead(innerException);
                    }
                    else {
                        // Connectin is still alive
                        return true;
                    }
                }
                // bad state. We don't know why it failed. Could be the driver does not support that attribute
                // could be something else
                return true;
            }
            return false;
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.CreateCommand"]/*' />
        public OdbcCommand CreateCommand() {
            return  new OdbcCommand(String.Empty, this);
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.IDbConnection.CreateCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbConnection.CreateCommand() {
            return CreateCommand();
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.Dispose"]/*' />
        override protected void Dispose(bool disposing) {
            if (disposing) {
                _constr = null;
                Close();

                CNativeBuffer buffer = _buffer;
                if (null != buffer) {
                    buffer.Dispose();
                    _buffer = null;
                }
            }

            base.Dispose(disposing); // notify base classes 
        }


        // Called by Dispose(true) and Close()
        // Anything that needs to be cleaned up by both Close() and Dispose(TRUE)
        // but not Dispose(false) goes here.
        private void DisposeClose() {
            //Note: Dispose/Close is allowed to be called more than once, so we don't do any
            //checking to make sure its not already closed

            //If there is a pending transaction, automatically rollback.
            if (null != this.weakTransaction) {
                IDisposable transaction = (IDisposable) this.weakTransaction.Target;
                if ((null != transaction) && this.weakTransaction.IsAlive) {
                    // required to rollback any transactions on this connection
                    // before releasing the back to the odbc connection pool
                    transaction.Dispose();
                }
                else if (!this.weakTransaction.IsAlive) {
                    try {
                        RollbackDeadTransaction();
                    }
                    catch (Exception e) {
                        ADP.TraceException (e); // should not throw out of Close
                    }    
                }
            }

            // Close all commands
            if (null != this.weakCommandCache) {
                int length = this.weakCommandCache.Length;
                for (int i = 0; i < length; ++i) {
                    WeakReference weak = this.weakCommandCache[i];
                    if (null != weak) {
                        OdbcCommand command = (OdbcCommand) weak.Target;
                        if ((null != command) && weak.IsAlive) {
                            if (!this.IsAlive)
                                command.Canceling = true;
                            try {
                                command.CloseFromConnection();
                            }
                            catch (Exception e) {
                                ADP.TraceException (e); // should not throw out of Close
                            }    
                        }
                    }
                    else break;
                }
            }
            this.cachedDriver = null;

            _dbcWrapper.CloseAndRelease();
            state = ConnectionState.Closed;
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.EnlistDistributedTransaction"]/*' />
        public void EnlistDistributedTransaction(System.EnterpriseServices.ITransaction transaction) { // MDAC 78997
            OdbcConnection.OdbcPermission.Demand(); // MDAC 81476
            (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();

            ConnectionState currentState = State;
            if (ConnectionState.Open != currentState) {
                throw ADP.OpenConnectionPropertySet(ADP.ConnectionString, currentState);
            }
            if ((null != this.weakTransaction) && this.weakTransaction.IsAlive) {
                throw ADP.LocalTransactionPresent();
            }

            ODBC32.RETCODE retcode;
            if (null == transaction) {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                    _dbcWrapper,
                    ODBC32.SQL_COPT_SS_ENLIST_IN_DTC,
                    new HandleRef(null, (IntPtr) ODBC32.SQL_DTC_DONE),
                    1);
            }
            else {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                    _dbcWrapper,
                    ODBC32.SQL_COPT_SS_ENLIST_IN_DTC,
                    new HandleRef(transaction, Marshal.GetIUnknownForObject(transaction)),
                    1); //ODBC32.SQL_IS_POINTER);
            }

            if(retcode != ODBC32.RETCODE.SUCCESS) {
                HandleError(_dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
            }
        }
        
        internal int GetConnectAttr(ODBC32.SQL_ATTR attribute, ODBC32.HANDLER handler) {
            //SQLGetConnectAttr
            ODBC32.RETCODE retcode;
            Int32 cbActual = 0;
            if (_dbcWrapper._dbc != IntPtr.Zero) {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetConnectAttrW(
                            _dbcWrapper,
                            (Int32)attribute,
                            _buffer,
                            _buffer.Length,
                            out cbActual);
            }
            else 
                retcode = ODBC32.RETCODE.INVALID_HANDLE;

            if(retcode != ODBC32.RETCODE.SUCCESS)
            {
                if(handler == ODBC32.HANDLER.THROW)
                    this.HandleError(_dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
                return -1;
            }

            //Return the integer out of the buffer
            return Marshal.ReadInt32(_buffer.Ptr);
        }

        internal int GetInfo(ODBC32.SQL_INFO info) {
            //SQLGetInfo
            ODBC32.RETCODE retcode;
            IntPtr value    = IntPtr.Zero;
            Int16 cbActual  = 0;
            if (_dbcWrapper._dbc != IntPtr.Zero) {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetInfoW(
                            _dbcWrapper,
                            (short)info,
                            _buffer,
                            (short)_buffer.Length,
                            out cbActual);
            }
            else 
                retcode = ODBC32.RETCODE.INVALID_HANDLE;

            if(retcode != ODBC32.RETCODE.SUCCESS)
                this.HandleError(_dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
            return Math.Min(cbActual, _buffer.Length);   // security: avoid buffer overrun
        }

   	    // non-throwing HandleError
        internal Exception HandleErrorNoThrow(HandleRef hrHandle, ODBC32.SQL_HANDLE hType, ODBC32.RETCODE retcode) {
            switch(retcode) {
            case ODBC32.RETCODE.SUCCESS:
                break;

            case ODBC32.RETCODE.SUCCESS_WITH_INFO:
            {
                //Optimize to only create the event objects and obtain error info if
                //the user is really interested in retriveing the events...
                if(infoMessageEventHandler != null) {
                    OdbcErrorCollection errors = ODBC32.GetDiagErrors(null, hrHandle, hType, retcode);
                    errors.SetSource(this.Driver);
                    OnInfoMessage(new OdbcInfoMessageEventArgs(errors));
                }
                break;
            }

            case ODBC32.RETCODE.INVALID_HANDLE:
            	 return ODC.InvalidHandle();

            default:
                OdbcException e = new OdbcException(ODBC32.GetDiagErrors(null, hrHandle, hType, retcode), retcode);
                if (e != null) {
                    e.Errors.SetSource(this.Driver);
                }
                ConnectionIsAlive(e);        // this will close and throw if the connection is dead
            	return  (Exception)e;
            }

            return null;
        }

        internal void HandleError(HandleRef hrHandle, ODBC32.SQL_HANDLE hType, ODBC32.RETCODE retcode) {
            Exception e = HandleErrorNoThrow(hrHandle, hType, retcode);
            if (null != e)
           	    throw e;
        }

        private void OnInfoMessage(OdbcInfoMessageEventArgs args) {
            if (null != infoMessageEventHandler) {
                try {
                    infoMessageEventHandler(this, args);
                }
                catch (Exception e) {
                    ADP.TraceException(e);
                }
            }
        }

        private void OnStateChange(StateChangeEventArgs scevent) {
            if (null != stateChangeEventHandler) {
                stateChangeEventHandler(this, scevent);
            }
        }

        /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.Open"]/*' />
        public void Open() {
            OdbcConnectionString constr = _constr;
            OdbcConnectionString.Demand(constr);

            if (ConnectionState.Closed != State) {
                throw ADP.ConnectionAlreadyOpen(State);
            }
            if ((null == constr) || constr.IsEmpty()) {
                throw ADP.NoConnectionString();
            }
            if (null == _buffer) {
                _buffer = new CNativeBuffer(1024);
            }

            ODBC32.RETCODE retcode;

            if(_dbcWrapper._henv == IntPtr.Zero)
            {
                _dbcWrapper._pEnvEnvelope = g_globalEnv.GetGlobalEnv();
                _dbcWrapper._henv = Marshal.ReadIntPtr(_dbcWrapper._pEnvEnvelope, HENVENVELOPE.oValue);
            }

            //Allocate a connection handle
            if (_dbcWrapper._dbc == IntPtr.Zero) {
                retcode = _dbcWrapper.AllocateDbc(Interlocked.Increment(ref OdbcGlobalEnv._instanceId));
                if(retcode != ODBC32.RETCODE.SUCCESS)
                    this.HandleError(new HandleRef(this, _dbcWrapper._henv), ODBC32.SQL_HANDLE.ENV, retcode);
            }

            if (!IsOpen) {
                _connectionIsDead = false;

                //Set connection timeout (only before open).
                //Note: We use login timeout since its odbc 1.0 option, instead of using 
                //connectiontimeout (which affects other things besides just login) and its
                //a odbc 3.0 feature.  The ConnectionTimeout on the managed providers represents
                //the login timeout, nothing more.
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                        _dbcWrapper,
                        (Int32)ODBC32.SQL_ATTR.LOGIN_TIMEOUT,
                        new HandleRef (null, (IntPtr)this.connectionTimeout),
                        (Int32)ODBC32.SQL_IS.UINTEGER);

                // Connect to the driver.  (Using the connection string supplied)
                //Note: The driver doesn't filter out the password in the returned connection string
                //so their is no need for us to obtain the returned connection string
                Int16   cbActualSize = 0;
                // Prepare to handle a ThreadAbort Exception between SQLDriverConnectW and update of the state variables
                try { // try-finally inside try-catch-throw
                    try {
#if USECRYPTO
                        string encryptedSctualConnectionString = constr.EncryptedActualConnectionString;
                        byte[] actualConnectionString = new Byte[ADP.CharSize+ADP.CharSize*encryptedSctualConnectionString.Length];
                        GCHandle textHandle = GCHandle.Alloc(actualConnectionString, GCHandleType.Pinned);
                        try {
                            Crypto.DecryptToBlock(encryptedSctualConnectionString, actualConnectionString, 0, actualConnectionString.Length-ADP.CharSize);
                            Debug.Assert('\0' == actualConnectionString[actualConnectionString.Length-1], "missing null termination");
                            Debug.Assert('\0' == actualConnectionString[actualConnectionString.Length-2], "missing null termination");
#else
                            string actualConnectionString = constr.EncryptedActualConnectionString;
#endif
                            //Debug.WriteLine("SQLDriverConnectW:"+Marshal.PtrToStringUni(textHandle.AddrOfPinnedObject()));
                            retcode = (ODBC32.RETCODE)
                                UnsafeNativeMethods.Odbc32.SQLDriverConnectW(
                                            _dbcWrapper,
                                            IntPtr.Zero,
                                            actualConnectionString,
                                            ODBC32.SQL_NTS,
                                            IntPtr.Zero,
                                            0,
                                            out cbActualSize,
                                            (short)ODBC32.SQL_DRIVER.NOPROMPT);
#if USECRYPTO
                        }
                        finally {
                            Array.Clear(actualConnectionString, 0, actualConnectionString.Length);
                            if (textHandle.IsAllocated) {
                                textHandle.Free();
                            }
                            actualConnectionString = null;
                        }
#endif
                        if(retcode != ODBC32.RETCODE.SUCCESS) {
                        	  // get the error information before disposing the handle
                        	   Exception e = HandleErrorNoThrow(_dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);
                        	  
                            if (retcode != ODBC32.RETCODE.SUCCESS_WITH_INFO) {
                                DisposeClose();
                            }    
                            
                            if (null != e) {
                            	throw e;
                            }
                        }
                        _dbcWrapper._isOpen = true;

                        //Let's check the odbc driver version before we do anything else ...
                        //
                        GetDriverOdbcVersion();

                        //The connection is now truely open
                        _hidePasswordPwd = true;
                        state = ConnectionState.Open;
                    }
                    finally {
                        // Verify if we truly executed the above try block to the end ...
                        if (state != ConnectionState.Open) {
                            DisposeClose();
                        }
                    }
                }
                // To prevent filters from running before the finally block, it looks like only the nested scenario works
                catch { // MDAC 81875, // MDAC 80973
                    throw;
                }
            }

            //Events - Open
            if (IsOpen && (null != stateChangeEventHandler)) { // MDAC 82470
                OnStateChange(new StateChangeEventArgs(ConnectionState.Closed, ConnectionState.Open));
            }
        }

       /// <include file='doc\OdbcConnection.uex' path='docs/doc[@for="OdbcConnection.ReleaseObjectPool"]/*' />
        static public void ReleaseObjectPool() {
            g_globalEnv.ReleaseAll();
        }

        internal OdbcTransaction SetStateExecuting(string method, OdbcTransaction transaction) { // MDAC 69003
            if (null != weakTransaction) { // transaction may exist
                OdbcTransaction weak = (OdbcTransaction) weakTransaction.Target;
                if (transaction != weak) { // transaction doesn't exist
                    if (null == weak) { // transaction finalized check
                        RollbackDeadTransaction();
                    }
                    if (null == transaction) { // transaction exists
                        throw ADP.TransactionRequired();
                    }
                    if (null != transaction.connection) {
                        // transaction can't have come from this connection
                        throw ADP.TransactionConnectionMismatch();
                    }
                    // if transaction is zombied, we don't know the original connection
                    transaction = null; // MDAC 69264
                }
            }
            else if (null != transaction) { // no transaction started
                if (null != transaction.connection) {
                    // transaction can't have come from this connection
                    throw ADP.TransactionConnectionMismatch();
                }
                // if transaction is zombied, we don't know the original connection
                transaction = null; // MDAC 69264
            }
            if (ConnectionState.Open != state) {
                CommandRecover(); // recover for a potentially finalized reader

                if (ConnectionState.Open != state) {
                    if (0 != (ConnectionState.Fetching & state)) {
                        throw ADP.OpenReaderExists();
                    }
                    throw ADP.OpenConnectionRequired(method, state);
                }
            }
            state |= ConnectionState.Executing;
            return transaction;
        }

        internal void SetStateExecutingFalse() { // MDAC 69003
#if DEBUG
            switch(state) {
            case ConnectionState.Closed:
            case ConnectionState.Open:
            case ConnectionState.Open | ConnectionState.Executing:
            case ConnectionState.Open | ConnectionState.Fetching:
                break;
            default:
                Debug.Assert(false, "SetStateExecuting(false): " + state.ToString("G"));
                break;
            }
#endif
            this.state &= ~ConnectionState.Executing;
        }

        internal void SetStateFetchingTrue() { // MDAC 69003
#if DEBUG
            switch(state) {
            case ConnectionState.Open | ConnectionState.Executing:
                break;
            default:
                Debug.Assert(false, "SetStateFetching(true): " + state.ToString("G"));
                break;
            }
#endif
            this.state = ((state | ConnectionState.Fetching) & ~ConnectionState.Executing);
        }
        internal void SetStateFetchingFalse() { // MDAC 69003
#if DEBUG
            switch(state) {
            case ConnectionState.Closed:
            case ConnectionState.Open | ConnectionState.Fetching:
                break;
            case ConnectionState.Open:
            default:
                Debug.Assert(false, "SetStateFetching(false): " + state.ToString("G"));
                break;
            }
#endif
            state &= ~ConnectionState.Fetching;
        }

        // This adds a type to the list of types that are supported by the driver
        // (don't need to know that for all the types)
        //
        internal void SetSupportedType (ODBC32.SQL_TYPE sqltype) {
            ODBC32.SQL_CVT sqlcvt;

            switch (sqltype) {
                case ODBC32.SQL_TYPE.NUMERIC: {
                    sqlcvt = ODBC32.SQL_CVT.NUMERIC;
                    break;
                }
                case ODBC32.SQL_TYPE.WCHAR: {
                    sqlcvt = ODBC32.SQL_CVT.WCHAR;
                    break;
                }
                case ODBC32.SQL_TYPE.WVARCHAR: {
                    sqlcvt = ODBC32.SQL_CVT.WVARCHAR;
                    break;
                }
                case ODBC32.SQL_TYPE.WLONGVARCHAR: {
                    sqlcvt = ODBC32.SQL_CVT.WLONGVARCHAR;
                    break;
                }
                default:
                    return;
            }
            testedSQLTypes |= (int)sqlcvt;
            supportedSQLTypes |= (int)sqlcvt;
        }
        
        internal bool TestTypeSupport (ODBC32.SQL_TYPE sqltype){
            ODBC32.SQL_CONVERT sqlconvert;
            ODBC32.SQL_CVT sqlcvt;

            // we need to convert the sqltype to sqlconvert and sqlcvt first
            //
            switch (sqltype) {
                case ODBC32.SQL_TYPE.NUMERIC: {
                    sqlconvert = ODBC32.SQL_CONVERT.NUMERIC;
                    sqlcvt = ODBC32.SQL_CVT.NUMERIC;
                    break;
                }
                case ODBC32.SQL_TYPE.WCHAR: {
                    sqlconvert = ODBC32.SQL_CONVERT.CHAR;
                    sqlcvt = ODBC32.SQL_CVT.WCHAR;
                    break;
                }
                case ODBC32.SQL_TYPE.WVARCHAR: {
                    sqlconvert = ODBC32.SQL_CONVERT.VARCHAR;
                    sqlcvt = ODBC32.SQL_CVT.WVARCHAR;
                    break;
                }
                case ODBC32.SQL_TYPE.WLONGVARCHAR: {
                    sqlconvert = ODBC32.SQL_CONVERT.LONGVARCHAR;
                    sqlcvt = ODBC32.SQL_CVT.WLONGVARCHAR;
                    break;
                }
                default:
                    Debug.Assert(false, "Testing that sqltype is currently not supported");
                    return false;
            }

            // now we can check if we have already tested that type
            // if not we need to do so
            if (0 == (testedSQLTypes & (int)sqlcvt)) {
                int flags;

                UnsafeNativeMethods.Odbc32.SQLGetInfoW(
                    _dbcWrapper,                            // SQLHDBC          ConnectionHandle
                    (short)sqlconvert,                      // SQLUSMALLINT     InfoType
                    _buffer,                                // SQLPOINTER       InfoValuePtr
                    (short)_buffer.Length,                  // SQLSMALLINT      BufferLength
                    0);                                     // SQLSMALLINT *    StringLengthPtr

                flags = Marshal.ReadInt32(_buffer.Ptr);
                flags = flags & (int)sqlcvt;

                testedSQLTypes |= (int)sqlcvt;
                supportedSQLTypes |= flags;
            }

            // now check if the type is supported and return the result
            //
            return (0 != (supportedSQLTypes & (int)sqlcvt));
        }

        sealed private class OdbcGlobalEnv {
            static private IntPtr _pEnvEnvelope = IntPtr.Zero;
            static bool _mdacVersionOk = false;
            static internal long _instanceId = 0;

            ~OdbcGlobalEnv () {
               DBCWrapper.ReleaseEnvironment(ref _pEnvEnvelope);
            }
            
            // this method returns an envelope that contains the globale environment handle (henv) and
            // a refcount
            //
            internal IntPtr GetGlobalEnv() {
                int     errcd = 0;
                IntPtr  henv = IntPtr.Zero;
                ODBC32.RETCODE  retcode = ODBC32.RETCODE.SUCCESS;

                if (_pEnvEnvelope == IntPtr.Zero) {
                    try {
                        lock (this) {
                            if (_pEnvEnvelope == IntPtr.Zero) {
                                _pEnvEnvelope = Marshal.AllocCoTaskMem(HENVENVELOPE.Size);
                                SafeNativeMethods.ZeroMemory(_pEnvEnvelope, HENVENVELOPE.Size);
                            }
                        } // end lock
                    }
                    catch { // MDAC 80973
                        throw;
                    }
                }

                henv = Marshal.ReadIntPtr(_pEnvEnvelope, HENVENVELOPE.oValue); 
                if (henv == IntPtr.Zero) {
                    if (!_mdacVersionOk) {
                        // Test for mdac version >= 2.6
                        // Note that we check the oldbd version since it's versioning schema is more obvious
                        // than that of odbc
                        //
                        string filename = String.Empty;
                        try {
                            filename = (string)ADP.ClassesRootRegistryValue(ODC.DataLinks_CLSID, String.Empty);
                            Debug.Assert(!ADP.IsEmpty(filename), "created MDAC but can't find it");
                        }
                        catch (SecurityException e) {
                            ADP.TraceException(e);
                            throw ODC.MDACSecurityHive(e);
                        }

                        try {
                            FileVersionInfo versionInfo = ADP.GetVersionInfo(filename);
                            int major = versionInfo.FileMajorPart;
                            int minor = versionInfo.FileMinorPart;
                            int build = versionInfo.FileBuildPart;
                            // disallow any MDAC version before MDAC 2.6 rtm
                            // include MDAC 2.51 that ships with Win2k
                            if ((major < 2) || ((major == 2) && ((minor < 60) || ((minor == 60) && (build < 6526))))) { // MDAC 66628
                                throw ODC.MDACWrongVersion(versionInfo.FileVersion);
                            }
                            else {
                                _mdacVersionOk = true;
                            }
                        }
                        catch (SecurityException e) {
                            ADP.TraceException(e);
                            throw ODC.MDACSecurityFile(e);
                        }
                    }
                    try {
                        lock(this) {
                            if (henv == IntPtr.Zero) {
                                // mdac 81639
                                //
                                //Allocate an environment
                            
                                retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLAllocHandle(
                                    (short)ODBC32.SQL_HANDLE.ENV,
                                    new HandleRef(null, (IntPtr)ODBC32.SQL_HANDLE_NULL),
                                    out henv);
                                if((retcode != ODBC32.RETCODE.SUCCESS))
                                    errcd = 1;
                                else {
                                    //Set the expected driver manager version
                                    //
                                    retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLSetEnvAttr(
                                        new HandleRef(this, henv),    
                                        (Int32)ODBC32.SQL_ATTR.ODBC_VERSION,
                                        new HandleRef(null, (IntPtr)ODBC32.SQL_OV_ODBC3),
                                        (Int32)ODBC32.SQL_IS.INTEGER);
                                    
                                    //Turn on connection pooling
                                    //Note: the env handle controls pooling.  Only those connections created under that
                                    //handle are pooled.  So we have to keep it alive and not create a new environment
                                    //for   every connection.
                                    //
                                    retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLSetEnvAttr(
                                        new HandleRef(this, henv),
                                        (Int32)ODBC32.SQL_ATTR.CONNECTION_POOLING,
                                        new HandleRef(null, (IntPtr)ODBC32.SQL_CP_ONE_PER_HENV),
                                        (Int32)ODBC32.SQL_IS.INTEGER);

                                    if((retcode != ODBC32.RETCODE.SUCCESS) && 
                                        (retcode != ODBC32.RETCODE.SUCCESS_WITH_INFO))
                                        errcd = 2;
                                }
                                Marshal.WriteIntPtr(_pEnvEnvelope, HENVENVELOPE.oValue, henv);
                                SafeNativeMethods.InterlockedIncrement(ADP.IntPtrOffset(_pEnvEnvelope, HENVENVELOPE.oRefcount));
                                //
                                // mdac 81639
                            }
                        }
                    }
                    catch { // MDAC 80973
                        throw;
                    }
                }
                // Check for errors outside of lock block
                if (errcd == 1)
                    throw ODC.CantAllocateEnvironmentHandle(retcode);
                else if (errcd == 2)
                    throw ODC.CantEnableConnectionpooling(retcode);

                return _pEnvEnvelope;
            }

            internal void ReleaseAll() {
                IntPtr henv;

                if (_pEnvEnvelope == IntPtr.Zero) {
                    return;
                }

                henv = Marshal.ReadIntPtr(_pEnvEnvelope, HENVENVELOPE.oValue); 

                try {
                    lock(this) {
                        // check if envelope is in use (refcount)
                        // if not free handle and release memory
                        // always set pointer to envelope zero.
                        //
                        if (SafeNativeMethods.InterlockedDecrement(ADP.IntPtrOffset(_pEnvEnvelope, HENVENVELOPE.oRefcount)) == 0) {
                            UnsafeNativeMethods.Odbc32.SQLFreeHandle( 
                                (short)ODBC32.SQL_HANDLE.ENV, 
                                new HandleRef (this, henv)
                                );
                            Marshal.FreeCoTaskMem(_pEnvEnvelope);
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
                _pEnvEnvelope = IntPtr.Zero;
            }
        }
    }

    sealed internal class DBCWrapper {

        //ODBC Handles
        internal IntPtr _henv               = IntPtr.Zero;
        internal IntPtr _dbc                = IntPtr.Zero;

        internal bool   _isOpen             = false;
        internal bool   _isInTransaction    = false;

        internal IntPtr _pEnvEnvelope       = IntPtr.Zero;      // points to the envelope for environment handles in native memory

        internal long _instanceId;        // our "birth certificate" that the object created on top of us can use to prove parentship
        internal int    _dbc_lock = 0;
        
        internal DBCWrapper() {
        }

        ~DBCWrapper() {
            if (_isInTransaction){
                RollbackDeadTransaction();
            }
            CloseAndRelease();      
        }

        public static implicit operator HandleRef(DBCWrapper x) {
            return new HandleRef(x, x._dbc);
        }

        internal ODBC32.RETCODE AllocateDbc(long instanceId) {

            ODBC32.RETCODE retcode;

            // enumerate the connection handles that we return. That way each object created on top of 
            // the environment handle gets a unique Id.
            //
            _instanceId = instanceId;

            retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLAllocHandle(
                                (short)ODBC32.SQL_HANDLE.DBC,
                                new HandleRef (this, _henv),
                                out _dbc);
                    // Debug.WriteLine("Connection: Allocated HDBC = " + _dbcWrapper._dbc);
            if(retcode != ODBC32.RETCODE.SUCCESS)
                return retcode;

            SafeNativeMethods.InterlockedIncrement(ADP.IntPtrOffset(_pEnvEnvelope, HENVENVELOPE.oRefcount));
            return retcode;
        }

        internal void RollbackDeadTransaction() {
            //Abort the transaction
            ODBC32.RETCODE retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLEndTran(
                                                      (short)ODBC32.SQL_HANDLE.DBC,
                                                      this,
                                                      (Int16)ODBC32.SQL_TXN.ROLLBACK);
            Debug.Assert(retcode == ODBC32.RETCODE.SUCCESS, "Odbc call returned failure");
            // EAT ERROR
            //Turning off auto-commit - which will implictly start a transaction
            retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                                       this,
                                       (Int32)ODBC32.SQL_ATTR.AUTOCOMMIT,
                                       new HandleRef (null, (IntPtr)(1)),        //1:on, 0:off
                                       (Int32)ODBC32.SQL_IS.UINTEGER);
            Debug.Assert(retcode == ODBC32.RETCODE.SUCCESS, "Odbc call returned failure");
            // EAT ERROR
            _isInTransaction = false;
            GC.KeepAlive(this);
        }

        internal void CloseAndRelease () {
            // Debug.WriteLine("Connection: Enter CloseAndRelease");

            // Dereference the DbcEnvelope. If we had the last reference then we need to clean up the environment handle
            //
            int temp_dbc_lock;
            
            if (_dbc != IntPtr.Zero) {
                try {
                    do {    // wait if dbc is locked
                        temp_dbc_lock = Interlocked.Exchange(ref _dbc_lock, 1);
                        if (temp_dbc_lock != 0) {
                            Thread.Sleep(10);
                        }
                    }
                    while (temp_dbc_lock != 0);

                    IntPtr localdbc = _dbc;
                    _dbc = IntPtr.Zero;
                    if (_isOpen) {
                        UnsafeNativeMethods.Odbc32.SQLDisconnect(new HandleRef(null, localdbc));
                        _isOpen = false;
                    }
                    UnsafeNativeMethods.Odbc32.SQLFreeHandle( 
                        (short)ODBC32.SQL_HANDLE.DBC, 
                        new HandleRef (null, localdbc)
                    );
                }
                finally {
                    _instanceId = 0;    // I'm dead. If the object gets reused it will get a different Id
                    Interlocked.Exchange(ref _dbc_lock, 0);
                }
                ReleaseEnvironment(ref _pEnvEnvelope);
            }
            if (_pEnvEnvelope == IntPtr.Zero) {_henv = IntPtr.Zero;}

            // Debug.WriteLine("Connection: Exit CloseAndRelease");
        }

        internal static void ReleaseEnvironment(ref IntPtr _pEnvEnvelope) {
            // Dereference the EnvEnvelope. If we are the last ones we need to free henv and
            // deallocate the memory used to accomodate the envelope
            //
            if (_pEnvEnvelope != IntPtr.Zero) {
                if (SafeNativeMethods.InterlockedDecrement(ADP.IntPtrOffset(_pEnvEnvelope, HENVENVELOPE.oRefcount)) == 0) {
                    IntPtr henv = Marshal.ReadIntPtr(_pEnvEnvelope, HENVENVELOPE.oValue);
                    if (henv != IntPtr.Zero) {
                        UnsafeNativeMethods.Odbc32.SQLFreeHandle( 
                            (short)ODBC32.SQL_HANDLE.ENV, 
                            new HandleRef (null, henv)
                        );
                    }
                    Marshal.FreeCoTaskMem(_pEnvEnvelope);
                    _pEnvEnvelope = IntPtr.Zero;
                }
            }
        }
    }







/*
#if NEVEREVER

	sealed internal class ItemPool
	{
		static object[] itemArray = new object[64];
		static int itemArrayCount = 0;

		~ItemPool() 
		{
//			Console.WriteLine("Destruct ItemPool");
			for (int i=0; i<itemArray.Length; i++)
			{
				if (itemArray[i] != null) 
				{
					// Console.WriteLine("Destroying recycled item: " + (IntPtr)itemArray[i]);
					Marshal.FreeCoTaskMem((IntPtr)itemArray[i]);
					itemArray[i] = null;
				}
				else {
					// Console.WriteLine("Unused Slot in itemArray");
				}
			}
		}

		internal void LocalAlloc (ref object pItem) 
		{
	        // Console.WriteLine("LocalAlloc");
			Debug.Assert(pItem==null,"Parameter must be initially null");
			int nItems = itemArrayCount;

			for (int i=0; i<nItems; i++) 
			{
				// look for an occupied slot
				if (itemArray[i] != null) 
				{
					// try to get pItem out of the list
					pItem = Interlocked.Exchange(ref itemArray[i], null);
					if (pItem != null) 
					{
						// got the pItem out of a slot
						return;	
					}
				}
			};
//			Console.WriteLine("Create a new Item");
			pItem = (object)Marshal.AllocCoTaskMem(LLIST.listItemSize);
		}

		internal void LocalFree (ref object pItem) 
		{
            // Console.WriteLine("LocalFree");
			Debug.Assert(pItem != null, "Can't use Null value!");

            try { // try-finally inside try-catch-throw
    			try 
    			{
    				for (int i=0; i<itemArray.Length; i++)
    				{
    					if (itemArray[i] == null) 
    					{
    						// try to put value in list.
    						if (Interlocked.CompareExchange(ref itemArray[i], pItem, null) == null) 
    						{
    							// pItem is in free slot.
    							if (i>=itemArrayCount) itemArrayCount = i+1;
    							pItem = null;
    							return;
    						}
    					}
    				}
    			}
    			finally 
    			{
    				// Couldn't store the value, have to destroy it
    				if (pItem != null) 
    				{
    //					Console.WriteLine("Destroying unrecyclable item:" + pItem);
    					Marshal.FreeCoTaskMem((IntPtr)pItem);
    				}
    			}
            }
            catch { // MDAC 81875
                throw;
            }
		}
	}
    #endif
*/    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcdatareader.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcDataReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;              // StringBuilder

namespace System.Data.Odbc
{
    /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcDataReader : MarshalByRefObject, IDataReader, IDisposable, IEnumerable {

        private OdbcCommand command;
        internal CommandBehavior commandBehavior;

        private int recordAffected = -1;
        private FieldNameLookup _fieldNameLookup;

        private DbCache dataCache;
        private enum HasRowsStatus {
            DontKnow    = 0,
            HasRows     = 1,
            HasNoRows   = 2,
        }
        private HasRowsStatus _hasRows = HasRowsStatus.DontKnow;
        private bool _isClosed;
        private bool _isRead;
        private bool  _isRowReturningResult;
        private bool  _noMoreResults;
        private bool  _isDisposing;
        private bool  _skipReadOnce;
        private CNativeBuffer[] _parameterBuffer; // MDAC 68303
        private CNativeBuffer[] _parameterintbuffer;
        private CNativeBuffer _buffer;
        private long sequentialBytesRead;           // used to track position in field for sucessive reads
        private int sequentialOrdinal;
        private int _hiddenColumns;                 // number of hidden columns

        // the statement handle here is just a copy of the statement handle owned by the command
        // the DataReader must not free the statement handle. this is done by the command
        //

        private MetaData[] metadata;
        private DataTable schemaTable; // MDAC 68336
        private CMDWrapper _cmdWrapper;

        private bool _validResult;

        internal OdbcDataReader(OdbcCommand command, CMDWrapper cmdWrapper, CommandBehavior commandbehavior) : base() {
            this.command = command;

            Debug.Assert(this.command != null, "Command null on OdbcDataReader ctor");

            this.commandBehavior = commandbehavior;
            _cmdWrapper = cmdWrapper;
            this._buffer = _cmdWrapper._dataReaderBuf;
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.Finalize"]/*' />
        ~OdbcDataReader() {
           Dispose(false);
        }

        private OdbcConnection Connection {
            get {
                if (null != _cmdWrapper) {
                    return (OdbcConnection)_cmdWrapper._connection;
                }
                else {
                    return null;
                }
            }
        }

        internal OdbcCommand Command {
            get {
                return this.command;
            }
            set {
                this.command=value;
            }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.Depth"]/*' />
        public int Depth {
            get {
                if (IsClosed) { // MDAC 63669
                    throw ADP.DataReaderClosed("Depth");
                }
                return 0;
            }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.FieldCount"]/*' />
        public int FieldCount  {
            get {
                if (IsClosed) { // MDAC 63669
                    throw ADP.DataReaderClosed("FieldCount");
                }
                if (null == this.dataCache) {
                    Int16 cColsAffected;
                    ODBC32.RETCODE retcode = this.FieldCountNoThrow(out cColsAffected);
                    if(retcode != ODBC32.RETCODE.SUCCESS) {
                        Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
                        GC.KeepAlive(this);
                    }
                }
                return ((null != this.dataCache) ? this.dataCache._count : 0);
            }
        }

        // HasRows
        //
        // Use to detect wheter there are one ore more rows in the result without going through Read
        // May be called at any time
        // Basically it calls Read and sets a flag so that the actual Read call will be skipped once
        // 
        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.HasRows"]/*' />
        public bool HasRows {
            get {
                if (IsClosed) {
                    throw ADP.DataReaderClosed("HasRows");
                }
                if (_hasRows == HasRowsStatus.DontKnow){
                    Read();                     //
                    _skipReadOnce = true;       // need to skip Read once because we just did it
                }
                return (_hasRows == HasRowsStatus.HasRows);
            }
        }

        internal ODBC32.RETCODE FieldCountNoThrow(out Int16 cColsAffected) {
            if ((Command != null) && Command.Canceling) {
                cColsAffected = 0;
                return ODBC32.RETCODE.ERROR;
            }
            
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLNumResultCols(_cmdWrapper, out cColsAffected);
            if (retcode == ODBC32.RETCODE.SUCCESS) {
                _hiddenColumns = 0;
                if (IsBehavior(CommandBehavior.KeyInfo)) {
                    // we need to search for the first hidden column 
                    //
                    for (int i=0; i<cColsAffected; i++)
                    {
                        if (GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_CA_SS.COLUMN_HIDDEN, (ODBC32.SQL_COLUMN)(-1), ODBC32.HANDLER.IGNORE) == 1) {
                            _hiddenColumns = (int)cColsAffected-i;
                            cColsAffected = (Int16)i;
                            break;
                        }
                    }
                }
                this.dataCache = new DbCache(this, cColsAffected);
            }
            else {
                cColsAffected = 0;
            }
            GC.KeepAlive(this);
            return retcode;
        }

        internal bool IsBehavior(CommandBehavior behavior) {
            return (this.commandBehavior & behavior) == behavior;
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.IsClosed"]/*' />
        public bool IsClosed {
            get {
                return _isClosed;
            }
        }

        internal int CalculateRecordsAffected(){
            if (IntPtr.Zero != _cmdWrapper._stmt) {
                Int16 cRowsAffected = -1;
                ODBC32.RETCODE retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLRowCount(_cmdWrapper, out cRowsAffected);
                // Do not raise exception if SQLRowCount returns error, since this informatino may not always be
                //  available. This is OK.
                if (ODBC32.RETCODE.SUCCESS == retcode) {
                    if (0 <= cRowsAffected) {
                        if (-1 == this.recordAffected) {
                            this.recordAffected = cRowsAffected;
                        }
                        else  {
                            this.recordAffected += cRowsAffected;
                        }
                    }
                }
            }
            else {
                // leave the value as it is
            }
            GC.KeepAlive(this);
            return this.recordAffected;
        }


        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.RecordsAffected"]/*' />
        public int RecordsAffected {
            get {
                return this.recordAffected;
            }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.this"]/*' />
        public object this[int i] {
            get {
                return GetValue(i);
            }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.this1"]/*' />
        public object this[string value] {
            get {
                return GetValue(GetOrdinal(value));
            }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.Close"]/*' />
        public void Close() {
            Dispose(true);
            GC.KeepAlive(this);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            _isDisposing = true;
            Close();
            _isDisposing = false;
        }

        // All the stuff that needs to be cleand up by both Close() and Dispose(true)
        //  goes here.
        private void Dispose(bool disposing) {
            Exception error = null;

            if (disposing) {
                if (_cmdWrapper != null) {
                    if (IntPtr.Zero != _cmdWrapper._stmt) {
                        // disposing
                        // true to release both managed and unmanaged resources; false to release only unmanaged resources.
                        //
                        if ((command != null) && !command.Canceling) {
                            //Read any remaining results off the wire
                            //We have to do this otherwise some batch statements may not be executed until
                            //SQLMoreResults is called.  We want the user to be able to do ExecuteNonQuery
                            //or even ExecuteReader and close without having iterate to get params or batch.
                            while(this.NextResult());   //Intential empty loop
                            //Output Parameters
                            //Note: Output parameters are not guareenteed to be returned until all the data
                            //from any restssets are reaf, reason we do this after the above NextResult(s) call
                            if ((null != _parameterBuffer) && (0 < _parameterBuffer.Length)) {
                                OdbcParameterCollection parameters = Command.Parameters;
                                int count = parameters.Count;
                                for(int i=0; i<count; i++) {
                                    parameters[i].GetOutputValue(_cmdWrapper._stmt, _parameterBuffer[i], _parameterintbuffer[i]);
                                }
                            }
                            if (null != command) {
                                UnsafeNativeMethods.Odbc32.SQLFreeStmt(_cmdWrapper, (short)ODBC32.STMT.CLOSE);
                                command.CloseFromDataReader();
                            }
                        }
                    }

                    if (IntPtr.Zero != _cmdWrapper._keyinfostmt) {
                        //Close the statement
                        ODBC32.RETCODE retcode = (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLFreeStmt(_cmdWrapper.hKeyinfoStmt, (short)ODBC32.STMT.CLOSE);
                        try { // try-finally inside try-catch-throw
                            if (disposing && (ODBC32.RETCODE.SUCCESS != retcode)) {
                                Exception e = Connection.HandleErrorNoThrow(_cmdWrapper.hKeyinfoStmt, ODBC32.SQL_HANDLE.STMT, retcode);
                                ADP.TraceException(e);
                                if (null == error) {
                                    error = e;
                                }
                            }
                        }
                        catch (Exception e) { // MDAC 81875
                            ADP.TraceException(e);          // dispose never throws.
                        }
                    }
                }

                // if the command is still around we call CloseFromDataReader, 
                // otherwise we need to dismiss the statement handle ourselves
                //
                if (null != command) {
                    command.CloseFromDataReader();

                    if(IsBehavior(CommandBehavior.CloseConnection)) {
                        Debug.Assert(null != Connection, "null cmd connection");
                        command.Parameters.BindingIsValid = false;
                        Connection.Close();
                    }
                }
                else {
                    if (_cmdWrapper != null){
                        _cmdWrapper.Dispose(disposing);
                    }
                }
                    
                this.command = null;
                _isClosed=true;
                this.dataCache = null;
                this.metadata = null;
                this.schemaTable = null;
                _isRead = false;
                _hasRows = HasRowsStatus.DontKnow;
                _isRowReturningResult = false;
                _noMoreResults = true;
                _fieldNameLookup = null;

                if ((null != error) && !_isDisposing) {
                    throw error;
                }
                _cmdWrapper = null;
            }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetData"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Never) ] // MDAC 69508
        public IDataReader GetData(int i) {
            throw ADP.NotSupported();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetDataTypeName"]/*' />
        public String GetDataTypeName(int i) {
            if (null != this.dataCache) {
                DbSchemaInfo info = this.dataCache.GetSchema(i);
                if(info._typename == null) {
                    info._typename = GetColAttributeStr(i, ODBC32.SQL_DESC.TYPE_NAME, ODBC32.SQL_COLUMN.TYPE_NAME, ODBC32.HANDLER.THROW);
                }
                return info._typename;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return new DbEnumerator((IDataReader)this,  (0 != (CommandBehavior.CloseConnection & commandBehavior))); // MDAC 68670
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetFieldType"]/*' />
        public Type GetFieldType(int i) {
            if (null != this.dataCache) {
                DbSchemaInfo info = this.dataCache.GetSchema(i);
                if(info._type == null) {
                    info._type = GetSqlType(i)._type;
                }
                return info._type;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetName"]/*' />
        public String GetName(int i) {
            if (null != this.dataCache) {
                DbSchemaInfo info = this.dataCache.GetSchema(i);
                if(info._name == null) {
                    info._name = GetColAttributeStr(i, ODBC32.SQL_DESC.NAME, ODBC32.SQL_COLUMN.NAME, ODBC32.HANDLER.THROW);
                    if (null == info._name) { // MDAC 66681
                        info._name = "";
                    }
                }
                return info._name;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetOrdinal"]/*' />
        public int GetOrdinal(string value) {
            if (null == _fieldNameLookup) {
                if (null == this.dataCache) {
                    throw ADP.DataReaderNoData();
                }
                _fieldNameLookup = new FieldNameLookup(this, -1);
            }
            return _fieldNameLookup.GetOrdinal(value); // MDAC 71470
        }

        internal object GetValue(int i, TypeMap typemap) {
            switch(typemap._sql_type) {

                case ODBC32.SQL_TYPE.CHAR:
                case ODBC32.SQL_TYPE.VARCHAR:
                case ODBC32.SQL_TYPE.LONGVARCHAR:
                case ODBC32.SQL_TYPE.WCHAR:
                case ODBC32.SQL_TYPE.WVARCHAR:
                case ODBC32.SQL_TYPE.WLONGVARCHAR:
                    return internalGetString(i);

                case ODBC32.SQL_TYPE.DECIMAL:
                case ODBC32.SQL_TYPE.NUMERIC:
                    return   internalGetDecimal(i);

                case ODBC32.SQL_TYPE.SMALLINT:
                    return  internalGetInt16(i);

                case ODBC32.SQL_TYPE.INTEGER:
                    return internalGetInt32(i);

                case ODBC32.SQL_TYPE.REAL:
                    return  internalGetFloat(i);

                case ODBC32.SQL_TYPE.FLOAT:
                case ODBC32.SQL_TYPE.DOUBLE:
                    return  internalGetDouble(i);

                case ODBC32.SQL_TYPE.BIT:
                    return  internalGetBoolean(i);

                case ODBC32.SQL_TYPE.TINYINT:
                    return  internalGetByte(i);

                case ODBC32.SQL_TYPE.BIGINT:
                    return  internalGetInt64(i);

                case ODBC32.SQL_TYPE.BINARY:
                case ODBC32.SQL_TYPE.VARBINARY:
                case ODBC32.SQL_TYPE.LONGVARBINARY:
                    return  internalGetBytes(i);

                case ODBC32.SQL_TYPE.TYPE_DATE:
                    return  internalGetDate(i);
                    
                case ODBC32.SQL_TYPE.TYPE_TIME:
                    return  internalGetTime(i);
                    
//                  case ODBC32.SQL_TYPE.TIMESTAMP:
                case ODBC32.SQL_TYPE.TYPE_TIMESTAMP:
                    return  internalGetDateTime(i);

                case ODBC32.SQL_TYPE.GUID:
                    return  internalGetGuid(i);

                case (ODBC32.SQL_TYPE)ODBC32.SQL_SS.VARIANT:
                    //Note: SQL Variant is not an ODBC defined type.
                    //Instead of just binding it as a byte[], which is not very useful,
                    //we will actually code this specific for SQL Server.

                    //To obtain the sub-type, we need to first load the context (obtaining the length
                    //will work), and then query for a speicial SQLServer specific attribute.
					if (_isRead) {
						if(this.dataCache.AccessIndex(i) == null) {
							int length = GetFieldLength(i, ODBC32.SQL_C.BINARY);
							if(length < 0)
							{
								this.dataCache[i] = DBNull.Value;
							}
							else
							{
								//Delegate (for the sub type)
								ODBC32.SQL_TYPE subtype = (ODBC32.SQL_TYPE)GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_CA_SS.VARIANT_SQL_TYPE, (ODBC32.SQL_COLUMN)(-1), ODBC32.HANDLER.THROW);
								return  GetValue(i, TypeMap.FromSqlType(subtype));
							}
						}
						return this.dataCache[i];
					}
					throw ADP.DataReaderNoData();



                default:
                    //Unknown types are bound strictly as binary
                    return  internalGetBytes(i);
             }
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetValue"]/*' />
        public object GetValue(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    this.dataCache[i] = GetValue(i, GetSqlType(i));
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetValues"]/*' />
        public int GetValues(object[] values) {
            if (_isRead) {
                int copy = Math.Min(values.Length, FieldCount);
                for (int i = 0; i < copy; ++i) {
                    values[i] = GetValue(i);
                }
                return copy;
            }
            throw ADP.DataReaderNoData();
        }

        private TypeMap GetSqlType(int i) {
            //Note: Types are always returned (advertised) from ODBC as SQL_TYPEs, and
            //are always bound by the user as SQL_C types.
            TypeMap typeMap;
            DbSchemaInfo info = this.dataCache.GetSchema(i);
            if(info._dbtype == null) {
                info._dbtype = GetColAttribute(i, ODBC32.SQL_DESC.CONCISE_TYPE, ODBC32.SQL_COLUMN.TYPE,ODBC32.HANDLER.THROW);
                typeMap = TypeMap.FromSqlType((ODBC32.SQL_TYPE)info._dbtype);
                if (typeMap._signType == true) {
                    bool sign = (GetColAttribute(i, ODBC32.SQL_DESC.UNSIGNED, ODBC32.SQL_COLUMN.UNSIGNED, ODBC32.HANDLER.THROW) != 0);
                    typeMap = TypeMap.UpgradeSignedType(typeMap, sign);
                    info._dbtype = typeMap._sql_type;
                }
            }
            else {
                typeMap = TypeMap.FromSqlType((ODBC32.SQL_TYPE)info._dbtype);
            }
            Connection.SetSupportedType((ODBC32.SQL_TYPE)info._dbtype);
            return typeMap;
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.IsDBNull"]/*' />
        public bool IsDBNull(int i) {
            //  Note: ODBC SQLGetData doesn't allow retriving the column value twice.
            //  The reational is that for ForwardOnly access (the default and LCD of drivers)
            //  we cannot obtain the data more than once, and even GetData(0) (to determine is-null)
            //  still obtains data for fixed length types.

            //  So simple code like:
            //      if(!rReader.IsDBNull(i))
            //          rReader.GetInt32(i)
            //
            //  Would fail, unless we cache on the IsDBNull call, and return the cached
            //  item for GetInt32.  This actually improves perf anyway, (even if the driver could
            //  support it), since we are not making a seperate interop call...
            return Convert.IsDBNull(GetValue(i));
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetByte"]/*' />
        public Byte GetByte(int i) {
            return (Byte)internalGetByte(i);
        }

        private object internalGetByte(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.UTINYINT);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.ReadByte(_buffer.Ptr);
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetChar"]/*' />
        public Char GetChar(int i) {
            return (Char)internalGetChar(i);
        }
        private object internalGetChar(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.WCHAR);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.PtrToStructure(_buffer.Ptr, typeof(Char));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetInt16"]/*' />
        public Int16 GetInt16(int i) {
            return (Int16)internalGetInt16(i);
        }
        private object internalGetInt16(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.SSHORT);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.PtrToStructure(_buffer.Ptr, typeof(Int16));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetInt32"]/*' />
        public Int32 GetInt32(int i) {
            return (Int32)internalGetInt32(i);
       }
        private object internalGetInt32(int i){
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.SLONG);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.PtrToStructure(_buffer.Ptr, typeof(int));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetInt64"]/*' />
        public Int64 GetInt64(int i) {
            return (Int64)internalGetInt64(i);
        }
        // ---------------------------------------------------------------------------------------------- //
        // internal internalGetInt64
        // -------------------------
        // Get Value of type SQL_BIGINT
        // Since the driver refused to accept the type SQL_BIGINT we read that
        // as SQL_C_WCHAR and convert it back to the Int64 data type
        //
        private object internalGetInt64(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.WCHAR);
                    if (_validResult) {
                        this.dataCache[i] = Int64.Parse((string)_buffer.MarshalToManaged(ODBC32.SQL_C.WCHAR, -1));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetBoolean"]/*' />
        public bool GetBoolean(int i) {
            return (bool) internalGetBoolean(i);
        }
        private object internalGetBoolean(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.BIT);
                    if (_validResult) {
                        this.dataCache[i] = _buffer.MarshalToManaged(ODBC32.SQL_C.BIT, -1);
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetFloat"]/*' />
        public float GetFloat(int i) {
            return (float)internalGetFloat(i);
        }
        private object internalGetFloat(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.REAL);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.PtrToStructure(_buffer.Ptr, typeof(float));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetDate"]/*' />
        public DateTime GetDate(int i) {
            return (DateTime)internalGetDate(i);
        }

        private object internalGetDate(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.TYPE_DATE);
                    if (_validResult) {
                        this.dataCache[i] = _buffer.MarshalToManaged(ODBC32.SQL_C.TYPE_DATE, -1);
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetDateTime"]/*' />
        public DateTime GetDateTime(int i) {
            return (DateTime)internalGetDateTime(i);
        }

        private object internalGetDateTime(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.TYPE_TIMESTAMP);
                    if (_validResult) {
                        this.dataCache[i] = _buffer.MarshalToManaged(ODBC32.SQL_C.TYPE_TIMESTAMP, -1);
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetDecimal"]/*' />
        public decimal GetDecimal(int i) {
            return (decimal)internalGetDecimal(i);
        }

        // ---------------------------------------------------------------------------------------------- //
        // internal GetDecimal
        // -------------------
        // Get Value of type SQL_DECIMAL or SQL_NUMERIC
        // Due to provider incompatibilities with SQL_DECIMAL or SQL_NUMERIC types we always read the value 
        // as SQL_C_WCHAR and convert it back to the Decimal data type
        //
        private object internalGetDecimal(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.WCHAR);
                    if (_validResult) {
                        this.dataCache[i] = Decimal.Parse((string)_buffer.MarshalToManaged(ODBC32.SQL_C.WCHAR, -1), System.Globalization.CultureInfo.InvariantCulture);
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetDouble"]/*' />
        public double GetDouble(int i) {
            return (double)internalGetDouble(i);
        }
        private object internalGetDouble(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.DOUBLE);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.PtrToStructure(_buffer.Ptr, typeof(double));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetGuid"]/*' />
        public Guid GetGuid(int i) {
            return (Guid)internalGetGuid(i);
        }

        private object internalGetGuid(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.GUID);
                    if (_validResult) {
                        this.dataCache[i] = Marshal.PtrToStructure(_buffer.Ptr, typeof(Guid));
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetString"]/*' />
        public String GetString(int i) {
            return (String)internalGetString(i);
        }

        private object internalGetString(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    // Obtain _ALL_ the characters
                    // Note: We can bind directly as WCHAR in ODBC and the DM will convert to and from ANSI
                    // if not supported by the driver.
                    //

                    // Note: The driver always returns the raw length of the data, minus the terminator.
                    // This means that our buffer length always includes the terminator charactor, so
                    // when determining which characters to count, and if more data exists, it should not take
                    // the terminator into effect.
                    //
                    int cbMaxData = _buffer.Length-4;
                    string strdata = null;

                    // The first time GetData returns the true length (so we have to min it).  We also
                    // pass in the true length to the marshal function since there could be embedded nulls
                    //
                    int cbActual = GetData(i, ODBC32.SQL_C.WCHAR, _buffer.Length-2);
                    if (_validResult) {
                        if (cbActual <= cbMaxData) {
                            // all data read? good! Directly marshal to a string and we're done
                            //
                            strdata = Marshal.PtrToStringUni(_buffer.Ptr, Math.Min(cbActual, cbMaxData)/2);
                            this.dataCache[i] = strdata;
                        }
                        else {
                            // We need to chunk the data
                            //
                            Char[] rgChars = new Char[cbMaxData/2];                   // Char[] buffer for the junks
                            StringBuilder builder = new StringBuilder(cbActual/2);    // StringBuilder for the actual string
                            int cchJunk;
                            
                            do {
                                cchJunk = Math.Min(cbActual, cbMaxData)/2;
                                Marshal.Copy(_buffer.Ptr, rgChars, 0, cchJunk);
                                builder.Append(rgChars, 0, cchJunk);

                                if (cbActual > cbMaxData) {
                                    cbActual = GetData(i, ODBC32.SQL_C.WCHAR, _buffer.Length-2);
                                    Debug.Assert(_validResult, "internalGetString - unexpected invalid result inside if-block");
                                }
                                else {
                                    cbActual = 0;
                                }
                            } while (cbActual > 0);
                            
                            this.dataCache[i] =  builder.ToString();                               
                        }
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetTime"]/*' />
        public TimeSpan GetTime(int i) {
            return (TimeSpan)internalGetTime(i);
        }

        private object internalGetTime(int i) {
            if (_isRead) {
                if(this.dataCache.AccessIndex(i) == null) {
                    GetData(i, ODBC32.SQL_C.TYPE_TIME);
                    if (_validResult) {
                        this.dataCache[i] = _buffer.MarshalToManaged(ODBC32.SQL_C.TYPE_TIME, -1);
                    }
                }
                return this.dataCache[i];
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetBytes"]/*' />
        public long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length) {
            if (IsClosed) {
                throw ADP.DataReaderNoData();
            }
            if (!_isRead) {
                throw ADP.DataReaderNoData();
            }
            if (dataIndex > Int32.MaxValue) {
                throw ADP.InvalidSourceBufferIndex(0, dataIndex);
            }
            if (bufferIndex < 0) {
                throw ADP.Argument("bufferIndex");
            }
            if (length < 0) {
                throw ADP.Argument("length");
            }
            if (sequentialOrdinal != i) {               // next column?
                sequentialBytesRead = 0;                // reset so I can read from the beginning
                sequentialOrdinal = i;
            }

            Byte[] cachedObj = null;                 // The cached object (if there is one)
            int objlen = 0;                         // The length of the cached object

            cachedObj = (Byte[])this.dataCache[i];      // Get cached object

            if ((cachedObj == null) && (0 == (CommandBehavior.SequentialAccess & commandBehavior))){
                cachedObj = (Byte[])internalGetBytes(i);
            }
            

            if (cachedObj != null) {
                objlen = cachedObj.Length;    // Get it's length
            }

            // Per spec. the user can ask for the lenght of the field by passing in a null pointer for the buffer
            if (buffer == null) {
                if (cachedObj != null) {
                    return objlen;              // return the length if that's what we want
                }
                else {
                    return GetFieldLength(i, ODBC32.SQL_C.BINARY);  // Get len. of remaining data from provider
                }
            }
            if (length == 0) {
                return 0;   // Nothing to do ...
            }

            if (cachedObj != null) {
                int lengthFromDataIndex = objlen - (int)dataIndex;
                int lengthOfCopy = Math.Min(lengthFromDataIndex, length);

                if (lengthOfCopy <= 0) return 0;                    // MDAC Bug 73298

                Array.Copy(cachedObj, (int)dataIndex, buffer, bufferIndex, lengthOfCopy);
                return (lengthOfCopy);
            }

            //Note: This is the "users" chunking method.
            //We could make us of the above GetBytes(i) function (and vise-versa), but that would mean
            //we chunk under the covers into potentially smaller chunks than the users chunk.  It would
            //also mean the above function knows the length to allocate the buffer, which is an
            //expensive call.  Since the user has decided they want chunking and are capable of having
            //a pre-allocated chunk buffer (ie: its not huge) we should grow our internal buffer to
            //their size (is not already) and make these 1:1 calls to the driver

            // note that it is actually not possible to read with an offset (dataIndex)
            // therefore we need to read length+dataIndex chars

            // potential hazards:
            // no. 0: dataIndex < sequentialBytesRead  // Violates sequential access
            // no. 1: DataLength > buffer.Length   // need to increase buffersize (User buffer)
            // no. 2: DataLength > _buffer.Length   // need to decrease DataLength (internal buffer)
            // no. 3: DataLength > Fieldlength      // need to decrease DataLength
            // no. 4: dataIndex > DataLength        // return 0

            if (dataIndex < sequentialBytesRead) {          // hazard no. 0: Violates sequential access
                throw ADP.NonSeqByteAccess(                 //
                    dataIndex,                              //
                    sequentialBytesRead,                    //
                    "GetBytes"                              //
                );                                          //
            }                                               //    

            dataIndex -= sequentialBytesRead;               // Reduce by the number of chars already read
           
            int DataLength = Math.Min(length+(int)dataIndex, buffer.Length);    // hazard no. 1: Make shure we don't overflow the user provided buffer
            _buffer.EnsureAlloc(DataLength+2);                                  // Room for the null-terminator and unicode is two byte per char

            int cbMaxData       = Math.Min(DataLength, _buffer.Length-2);       // hazard no. 2: Make sure we never overflow our internal buffer.

            // GetData will return the actual number of bytes of data (cbTotal), which could be beyond
            // the total number of bytes requested.  GetChars only returns the number of bytes read into
            // the buffer.
            int cbTotal         = GetData(i, ODBC32.SQL_C.BINARY, cbMaxData);   // hazard no. 3: Decrease DataLength
            int cchRead         = Math.Min(cbTotal, cbMaxData);                 //

            sequentialBytesRead += (long)cchRead;                               // Update sequentialBytesRead

            if ((int)dataIndex >= cchRead) {                                    // hazard no. 4: Index outside field
                return 0;                                                       // return 0
            }
            
            length = Math.Min(length, cchRead-(int)dataIndex);                  // reduce length
            
            Marshal.Copy(ADP.IntPtrOffset(_buffer.Ptr, (int)dataIndex), buffer, bufferIndex, length);
            return length;
        }

        private object internalGetBytes(int i) {
            if(this.dataCache.AccessIndex(i) == null) {
                // Obtain _ALL_ the bytes...
                // The first time GetData returns the true length (so we have to min it).
                Byte[] rgBytes; 
                int cbBufferLen = _buffer.Length -4;
                int cbActual = GetData(i, ODBC32.SQL_C.BINARY, cbBufferLen);
                int cbOffset = 0;
                
                if (_validResult) {
                    rgBytes = new Byte[cbActual];
                    Marshal.Copy(_buffer.Ptr, rgBytes, cbOffset, Math.Min(cbActual, cbBufferLen));

                    // Chunking.  The data may be larger than our native buffer.  In which case instead of
                    // growing the buffer (out of control), we will read in chunks to reduce memory footprint size.
                    while(cbActual > cbBufferLen)
                    {
                        // The first time GetData returns the true length.  Then successive calls
                        // return the remaining data.
                        cbActual = GetData(i, ODBC32.SQL_C.BINARY, cbBufferLen);
                        Debug.Assert(_validResult, "internalGetBytes - unexpected invalid result inside if-block");

                        cbOffset += cbBufferLen;
                        Marshal.Copy(_buffer.Ptr, rgBytes, cbOffset, Math.Min(cbActual, cbBufferLen));
                    }
                    this.dataCache[i] = rgBytes;
                }
            }
            return this.dataCache[i];
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetChars"]/*' />
        public long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length) {
            if (IsClosed) {
                throw ADP.DataReaderNoData();
            }
            if (!_isRead) {
                throw ADP.DataReaderNoData();
            }
            if (dataIndex > Int32.MaxValue) {
                throw ADP.InvalidSourceBufferIndex(0, dataIndex);
            }
            if (bufferIndex < 0) {
                throw ADP.Argument("bufferIndex");
            }
            if (length < 0) {
                throw ADP.Argument("length");
            }
            if (sequentialOrdinal != i) {               // next column?
                sequentialBytesRead = 0;                // reset so I can read from the beginning
                sequentialOrdinal = i;
            }
            

            string cachedObj = null;                 // The cached object (if there is one)
            int objlen = 0;                         // The length of the cached object

            //
            cachedObj = (string)this.dataCache[i];      // Get cached object

            if ((cachedObj == null) && (0 == (CommandBehavior.SequentialAccess & commandBehavior))){
                cachedObj = (string)internalGetString(i);
            }
            
            if (cachedObj != null) {
                objlen = cachedObj.Length;    // Get it's length
            }

            // Per spec. the user can ask for the lenght of the field by passing in a null pointer for the buffer
            if (buffer == null) {
                if (cachedObj != null) {
                    return objlen;              // return the length if that's what we want
                }
                else {
                    return GetFieldLength(i, ODBC32.SQL_C.WCHAR);  // Get len. of remaining data from provider
                }
            }
            if (length == 0) {
                return 0;   // Nothing to do ...
            }

            if (cachedObj != null) {
                int lengthFromDataIndex = objlen - (int)dataIndex;
                int lengthOfCopy = Math.Min(lengthFromDataIndex, length);
                if (lengthOfCopy <= 0) return 0;

                cachedObj.CopyTo((int)dataIndex, buffer, bufferIndex, lengthOfCopy);
                return (lengthOfCopy);
            }

            //Note: This is the "users" chunking method.
            //We could make us of the above GetString(i) function (and vise-versa), but that would mean
            //we chunk under the covers into potentially smaller chunks than the users chunk.  It would
            //also mean the above function knows the length to allocate the buffer, which is an
            //expensive call.  Since the user has decided they want chunking and are capable of having
            //a pre-allocated chunk buffer (ie: its not huge) we should grow our internal buffer to
            //their size (is not already) and make these 1:1 calls to the driver

            // note that it is actually not possible to read with an offset (dataIndex)
            // therefore we need to read length+dataIndex chars

            // potential hazards:
            // no. 0: dataIndex < sequentialBytesRead  // Violates sequential access
            // no. 1: DataLength > buffer.Length   // need to increase buffersize (User provided buffer)
            // no. 2: DataLength > _buffer.Length   // need to decrease DataLength (internal buffer)
            // no. 3: DataLength > Fieldlength      // need to decrease DataLength
            // no. 4: dataIndex > DataLength        // return 0

            if (dataIndex*2 < sequentialBytesRead) {        // hazard no. 0: Violates sequential access
                throw ADP.NonSeqByteAccess(                 //
                    dataIndex,                              //
                    sequentialBytesRead,                    //
                    "GetChars"                              //
                );                                          //
            }                                               //    

            dataIndex -= sequentialBytesRead/2;             // Reduce by the number of chars already read
           
            int DataLength = Math.Min(length+(int)dataIndex, buffer.Length);  // hazard no. 1: Make shure we don't overflow the user provided buffer
            _buffer.EnsureAlloc((DataLength+2)*2);                              // Room for the null-terminator and unicode is two byte per char
                                                                                // and one for potential overrun through buggy ms-providers for 3rd party server

            int cbMaxData       = Math.Min((DataLength+1)*2, _buffer.Length-2);   // hazard no. 2: Make sure we never overflow our internal buffer.

            //GetData will return the actual number of bytes of data (cbTotal), which could be beyond
            //the total number of bytes requested.  GetChars only returns the number of bytes read into
            //the buffer.
            int cbTotal         = GetData(i, ODBC32.SQL_C.WCHAR, cbMaxData);    // hazard no. 3: Decrease DataLength
            int cchRead         = Math.Min(cbTotal, cbMaxData-1)/2;             //

            sequentialBytesRead += (long)cchRead*2;                             // Update sequentialBytesRead

            if ((int)dataIndex >= cchRead) {                                    // hazard no. 4: Index outside field
                return 0;                                                       // return 0
            }
            
            length = Math.Min(length, cchRead-(int)dataIndex);                  // reduce length
            
            Marshal.Copy(ADP.IntPtrOffset(_buffer.Ptr, (int)dataIndex*2), buffer, bufferIndex, length*2);
            return length;
        }


        // GetColAttribute
        // ---------------
        // [IN] iColumn   ColumnNumber
        // [IN] v3FieldId FieldIdentifier of the attribute for version3 drivers (>=3.0)
        // [IN] v2FieldId FieldIdentifier of the attribute for version2 drivers (<3.0)
        //
        // returns the value of the FieldIdentifier field of the column 
        // or -1 if the FieldIdentifier wasn't supported by the driver
        //
        private int GetColAttribute(int iColumn, ODBC32.SQL_DESC v3FieldId, ODBC32.SQL_COLUMN v2FieldId, ODBC32.HANDLER handler) {
            Int16   cchNameLength = 0;
            Int32   numericAttribute = 0;
            ODBC32.RETCODE retcode;

            // protect against dead connection, dead or canceling command.
            if ((Connection == null) || (Command == null) || Command.Canceling) {
                return -1;
            }
            
            if (this.command.Connection.IsV3Driver) {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLColAttributeW(
                        _cmdWrapper,
                        (short)(iColumn+1),    //Orindals are 1:base in odbc
                        (short)v3FieldId,
                        _buffer,
                        (short)_buffer.Length,
                        out cchNameLength,
                        out numericAttribute);
            }
            else if (v2FieldId != (ODBC32.SQL_COLUMN)(-1)) {
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLColAttributesW(
                        _cmdWrapper,
                        (short)(iColumn+1),    //Orindals are 1:base in odbc
                        (short)v2FieldId,
                        _buffer,
                        (short)_buffer.Length,
                        out cchNameLength,
                        out numericAttribute);
            }
            else {
                GC.KeepAlive(this);
                return 0;
            }
            if (retcode != ODBC32.RETCODE.SUCCESS)
            {
                if(handler == ODBC32.HANDLER.THROW) {
                    Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
                }
                return -1;
            }
            GC.KeepAlive(this);
            return numericAttribute;
        }

        // GetColAttributeStr
        // ---------------
        // [IN] iColumn   ColumnNumber
        // [IN] v3FieldId FieldIdentifier of the attribute for version3 drivers (>=3.0)
        // [IN] v2FieldId FieldIdentifier of the attribute for version2 drivers (<3.0)
        //
        // returns the stringvalue of the FieldIdentifier field of the column 
        // or null if the string returned was empty or if the FieldIdentifier wasn't supported by the driver
        //
        private String GetColAttributeStr(int i, ODBC32.SQL_DESC v3FieldId, ODBC32.SQL_COLUMN v2FieldId, ODBC32.HANDLER handler) {
            ODBC32.RETCODE retcode;
            Int16   cchNameLength = 0;
            Int32   numericAttribute = 0;
            Marshal.WriteInt16(_buffer.Ptr, 0);
            
            // protect against dead connection, dead or canceling command.
            if ((Connection == null) || (Command == null) || Command.Canceling) {
                return "";
            }
            
            if (this.command.Connection.IsV3Driver) {
                retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLColAttributeW(
                    _cmdWrapper,
                    (short)(i+1),               // Orindals are 1:base in odbc
                    (short)v3FieldId,
                    _buffer,
                    (short)_buffer.Length,
                    out cchNameLength,
                    out numericAttribute);
            }
            else if (v2FieldId != (ODBC32.SQL_COLUMN)(-1))
            {
                retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLColAttributesW(
                    _cmdWrapper,
                    (short)(i+1),           // Orindals are 1:base in odbc
                    (short)v2FieldId,
                    _buffer,
                    (short)_buffer.Length,
                    out cchNameLength,
                    out numericAttribute);
            }
            else {
                return null;
            }
            if((retcode != ODBC32.RETCODE.SUCCESS) || (cchNameLength == 0))
            {
                if(handler == ODBC32.HANDLER.THROW) {
                    Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
                }
                GC.KeepAlive(this);
                return null;
            }
            string retval = Marshal.PtrToStringUni(_buffer.Ptr, cchNameLength/2 /*cch*/);
            GC.KeepAlive(this);
            return retval;
        }

// todo: Another 3.0 only attribute that is guaranteed to fail on V2 driver.
// need to special case this for V2 drivers.
//
        private String GetDescFieldStr(int i, ODBC32.SQL_DESC attribute, ODBC32.HANDLER handler) {
            Int32   numericAttribute = 0;

            // protect against dead connection, dead or canceling command.
            if ((Connection == null) || (Command == null) || Command.Canceling) {
                return "";
            }
            
            IntPtr hdesc;       //Descriptor handle

            Marshal.WriteInt16(_buffer.Ptr, 0);

            // Need to set the APP_PARAM_DESC values here
            ODBC32.RETCODE rc = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLGetStmtAttrW(
                    _cmdWrapper,
                    (int) ODBC32.SQL_ATTR.APP_ROW_DESC,
                    _buffer,
                    IntPtr.Size,
                    out numericAttribute);
            if (ODBC32.RETCODE.SUCCESS != rc)
            {
                GC.KeepAlive(this);
                return null;
            }
            hdesc = Marshal.ReadIntPtr(_buffer.Ptr, 0);

            numericAttribute = 0;
            //SQLGetDescField
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLGetDescFieldW(
                    new HandleRef (this, hdesc),
                    (short)(i+1),    //Orindals are 1:base in odbc
                    (short)attribute,
                    _buffer,
                    (short)_buffer.Length,
                    out numericAttribute);

            //Since there are many attributes (column, statement, etc), that may or may not be
            //supported, we don't want to throw (which obtains all errorinfo, marshals strings,
            //builds exceptions, etc), in common cases, unless we absolutly need this info...
            if((retcode != ODBC32.RETCODE.SUCCESS) || (numericAttribute == 0))
            {
                if(handler == ODBC32.HANDLER.THROW) {
                    Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
                }
                GC.KeepAlive(this);
                return null;
            }

            string retval = Marshal.PtrToStringUni(_buffer.Ptr, numericAttribute/2 /*cch*/);
            GC.KeepAlive(this);
            return retval;
        }

/*
        private void                SetColAttribute(IntPtr desc, int i, ODBC32.SQL_DESC attribute, Int16 value, ODBC32.HANDLER handler)
        {
            //SQLColAttribute
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSetDescFieldW(desc,
                           (short)(i+1),    //Orindals are 1:base in odbc
                            (short)attribute,
                            (IntPtr)value,
                            (Int16)ODBC32.SQL_IS.SMALLINT);

            //Since their are many attributes (column, statement, etc), that may or may not be
            //supported, we don't want to throw (which obtains all errorinfo, marshals strings,
            //builds exceptions, etc), in common cases, unless we absolutly need this info...
            if(retcode != ODBC32.RETCODE.SUCCESS && handler == ODBC32.HANDLER.THROW)
                Connection.HandleError(desc, ODBC32.SQL_HANDLE.DESC, retcode);
        }
*/

        private Int32 GetStmtAttribute(ODBC32.SQL_ATTR attribute, ODBC32.HANDLER handler)
        {
            Int32 cbActual = 0;

            // protect against dead connection, dead or canceling command.
            if ((Connection == null) || (Command == null) || Command.Canceling) {
                return 0;
            }

            //SQLGetStmtAttr -- This code has to return string based attributes
            //      in _buffer. There is some code that depends on that
            IntPtr value = IntPtr.Zero;
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetStmtAttrW(_cmdWrapper,
                            (Int32)attribute,
                            _buffer,
                            _buffer.Length,
                            out cbActual);

            //Since there are many attributes (column, statement, etc), that may or may not be
            //supported, we don't want to throw (which obtains all errorinfo, marshals strings,
            //builds exceptions, etc), in common cases, unless we absolutly need this info...
            if(retcode != ODBC32.RETCODE.SUCCESS)
            {
                if(handler == ODBC32.HANDLER.THROW)
                    Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
                GC.KeepAlive(this);
                return -1;
            }
            GC.KeepAlive(this);
            return cbActual;
        }

        // GetFieldLength
        // This will return the correct number of items in the field.
        //
        private int GetFieldLength(int i, ODBC32.SQL_C sqlctype) {
            Debug.Assert(((sqlctype == ODBC32.SQL_C.BINARY)||(sqlctype == ODBC32.SQL_C.WCHAR)),
                "Illegal Type for GetFieldLength");
            
            if ((_cmdWrapper._stmt == IntPtr.Zero) || ((Command != null) && Command.Canceling))
                throw ADP.DataReaderNoData();

            IntPtr cbActual = IntPtr.Zero;
            int cb = 0;
            if (sqlctype== ODBC32.SQL_C.WCHAR) {
                cb = 2;
            }
            //SQLGetData
            Debug.Assert((_buffer.Length>=cb),"Unexpected size of _buffer");
            _buffer.EnsureAlloc(cb);
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetData(
                            _cmdWrapper,
                           (short)(i+1),    //Orindals are 1:base in odbc
                           (short)sqlctype,
                           _buffer,
                           (IntPtr)cb,
                           out cbActual);

            if(retcode != ODBC32.RETCODE.SUCCESS && retcode != ODBC32.RETCODE.SUCCESS_WITH_INFO
                && retcode != ODBC32.RETCODE.NO_DATA)
                Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);

            //SQL_NULL_DATA
            if(cbActual == (IntPtr)ODBC32.SQL_NULL_DATA) {
            }

            if (sqlctype== ODBC32.SQL_C.WCHAR) {
                GC.KeepAlive(this);
                return (int)cbActual/2;
            }
            GC.KeepAlive(this);
            return (int)cbActual;
        }


        private int GetData(int i, ODBC32.SQL_C sqlctype) {
            // Never call GetData with anything larger than _buffer.Length-2.
            // We keep reallocating native buffers and it kills performance!!!
            return GetData(i, sqlctype, _buffer.Length - 4);
        }

        private int GetData(int i, ODBC32.SQL_C sqlctype, int cb) {
            IntPtr cbActual = IntPtr.Zero;

            if ((_cmdWrapper._stmt == IntPtr.Zero) || ((Command != null) && Command.Canceling)){
                throw ADP.DataReaderNoData();
            }

            // Never call GetData with anything larger than _buffer.Length-2.
            // We keep reallocating native buffers and it kills performance!!!

            Debug.Assert(cb <= _buffer.Length-2, "GetData needs to Reallocate. Perf bug");

            //SQLGetData
            _buffer.EnsureAlloc(cb+2);
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLGetData(
                            _cmdWrapper,
                           (short)(i+1),    //Orindals are 1:base in odbc
                           (short)sqlctype,
                           _buffer,
                           (IntPtr)cb,
                           out cbActual);

            if(retcode != ODBC32.RETCODE.SUCCESS && retcode != ODBC32.RETCODE.SUCCESS_WITH_INFO)
                Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);

            //SQL_NULL_DATA
            if(cbActual == (IntPtr)ODBC32.SQL_NULL_DATA) {
                this.dataCache[i] = DBNull.Value;
                _validResult = false;
                GC.KeepAlive(this);
                return 0;
            }

            //Return the actual size (for chunking scenarios)
            _validResult = true;
            GC.KeepAlive(this);
            return (int)cbActual;
        }

        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.Read"]/*' />
        public bool Read() {
            ODBC32.RETCODE  retcode;

            if (IsClosed) {
                throw ADP.DataReaderClosed("Read");
            }

            if ((command != null) && command.Canceling) {
                _isRead = false;
                return false;
            }
            
            //SQLFetch is only valid to call for row returning queries
            //We get: [24000]Invalid cursor state.  So we could either check the count
            //ahead of time (which is cached), or check on error and compare error states.
            //Note: SQLFetch is also invalid to be called on a prepared (schemaonly) statement

            if (_noMoreResults || IsBehavior(CommandBehavior.SchemaOnly))
                return false;

            // the following condition is true if the previously executed statement caused an exception
            if (!_isRowReturningResult) return false;

            // HasRows needs to call into Read so we don't want to read on the actual Read call
            if (_skipReadOnce){
                _skipReadOnce = false;
                return _isRead;
            }
            
            //SqlFetch
            retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLFetch(_cmdWrapper);
            if (retcode == ODBC32.RETCODE.SUCCESS) {
                _hasRows = HasRowsStatus.HasRows;
                _isRead = true;
            }
            else if (retcode == ODBC32.RETCODE.NO_DATA) {
                _isRead = false;
                if (_hasRows == HasRowsStatus.DontKnow) {
                    _hasRows = HasRowsStatus.HasNoRows;
                }
            }
            else {
                Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
            }

            //Null out previous cached row values.
            this.dataCache.FlushValues();

            // if CommandBehavior == SingleRow we set _noMoreResults to true so that following reads will fail
            if (IsBehavior(CommandBehavior.SingleRow)) {
                _noMoreResults = true;
            }
            GC.KeepAlive(this);
            return _isRead;
        }

    // Called by odbccommand when executed for the first time
    internal void FirstResult() {
        Int16 cCols;
        ODBC32.RETCODE retcode = FieldCountNoThrow(out cCols);
        if ((retcode == ODBC32.RETCODE.SUCCESS) && (cCols == 0)) {
            NextResult();
        }
        else {
            this._isRowReturningResult = true;
        }
    }

    /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.NextResult"]/*' />
    public bool NextResult() {
        Int16 cColsAffected = 0;
        ODBC32.RETCODE retcode;

        if (IsClosed) {
            throw ADP.DataReaderClosed("NextResult");
        }
        if ((command != null) && command.Canceling) {
            return false;
        }

        if (_noMoreResults)
            return false;

        //Blow away the previous cache (since the next result set will have a different shape,
        //different schema data, and different data.
        _isRead = false;
        _hasRows = HasRowsStatus.DontKnow;
        _fieldNameLookup = null;
        this.metadata = null;
        this.schemaTable = null;

        //SqlMoreResults
        if (IsBehavior(CommandBehavior.SingleResult)) {
            //If we are only interested in the first result, just throw away the rest
            do {
                retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLMoreResults(_cmdWrapper);
            } while (retcode == ODBC32.RETCODE.SUCCESS);
        }
        else {
            do {
                if (!_isRowReturningResult) // Add the rowcount from previous results set
                    CalculateRecordsAffected();
                retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLMoreResults(_cmdWrapper);
                // If we got rows, we want to return
                if (retcode == ODBC32.RETCODE.SUCCESS) {
                    this.FieldCountNoThrow(out cColsAffected);
                }
                if (cColsAffected != 0)
                    _isRowReturningResult = true;
                else
                    _isRowReturningResult = false;
            } while ((retcode == ODBC32.RETCODE.SUCCESS) && (!_isRowReturningResult));
        }
        if(retcode == ODBC32.RETCODE.NO_DATA) {
            if (this.dataCache != null) {
                this.dataCache._count = 0;
            }
            _noMoreResults = true;
            GC.KeepAlive(this);
            return false;
        }

        // Don't throw if we are disposing
        if ((retcode != ODBC32.RETCODE.SUCCESS) && !_isDisposing) {
            Connection.HandleError(_cmdWrapper, ODBC32.SQL_HANDLE.STMT, retcode);
        }
        GC.KeepAlive(this);
        return ((retcode == ODBC32.RETCODE.SUCCESS) ? true : false);
    }

        internal string UnQuote (string str, char quotechar) {
            if (str != null) {
                if (str[0] == quotechar) {
                    Debug.Assert (str.Length > 1, "Illegal string, only one char that is a quote");
                    Debug.Assert (str[str.Length-1] == quotechar, "Missing quote at end of string that begins with quote");
                    if (str.Length > 1 && str[str.Length-1] == quotechar) {
                        str = str.Substring(1, str.Length-2);
                    }
                }
            }
            return str;
        }                        


        private void BuildMetaDataInfo()
        {
            int count = FieldCount;
            MetaData[] metaInfos = new MetaData[count];
            ArrayList   qrytables;
            bool needkeyinfo = IsBehavior(CommandBehavior.KeyInfo);
            bool isKeyColumn;
            bool isHidden;
            ODBC32.SQL_NULLABILITY nullable;

            if (needkeyinfo)
                qrytables = new ArrayList();
            else
                qrytables = null;


            // Find out all the metadata info, not all of this info will be available in all cases
            //
            for(int i=0; i<count; i++)
            {
                metaInfos[i] = new MetaData();
                metaInfos[i].ordinal = i;
                TypeMap typeMap;
                
                // for precision and scale we take the SQL_COLUMN_ attributes. 
                // Those attributes are supported by all provider versions.
                // for size we use the octet lenght. We can't use column length because there is an incompatibility with the jet driver.
                // furthermore size needs to be special cased for wchar types
                //
                typeMap = TypeMap.FromSqlType((ODBC32.SQL_TYPE) GetColAttribute(i, ODBC32.SQL_DESC.CONCISE_TYPE, ODBC32.SQL_COLUMN.TYPE, ODBC32.HANDLER.THROW));
                if (typeMap._signType == true) {
                    bool sign = (GetColAttribute(i, ODBC32.SQL_DESC.UNSIGNED, ODBC32.SQL_COLUMN.UNSIGNED, ODBC32.HANDLER.THROW) != 0);
                    // sign = true if the column is unsigned
                    typeMap = TypeMap.UpgradeSignedType(typeMap, sign);
                }

                metaInfos[i].typemap = typeMap;
                metaInfos[i].size = GetColAttribute(i, ODBC32.SQL_DESC.OCTET_LENGTH, ODBC32.SQL_COLUMN.LENGTH, ODBC32.HANDLER.IGNORE);

                // special case the 'n' types
                //
                switch(metaInfos[i].typemap._sql_type) {
                    case ODBC32.SQL_TYPE.WCHAR:
                    case ODBC32.SQL_TYPE.WLONGVARCHAR:
                    case ODBC32.SQL_TYPE.WVARCHAR:
                        metaInfos[i].size /= 2;
                        break;
                }
                
                metaInfos[i].precision = (byte) GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_COLUMN.PRECISION, ODBC32.SQL_COLUMN.PRECISION, ODBC32.HANDLER.IGNORE);
                metaInfos[i].scale = (byte) GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_COLUMN.SCALE, ODBC32.SQL_COLUMN.SCALE, ODBC32.HANDLER.IGNORE);

                metaInfos[i].isAutoIncrement = GetColAttribute(i, ODBC32.SQL_DESC.AUTO_UNIQUE_VALUE, ODBC32.SQL_COLUMN.AUTO_INCREMENT, ODBC32.HANDLER.IGNORE) == 1;
                metaInfos[i].isReadOnly = (GetColAttribute(i, ODBC32.SQL_DESC.UPDATABLE, ODBC32.SQL_COLUMN.UPDATABLE, ODBC32.HANDLER.IGNORE) == (Int32)ODBC32.SQL_UPDATABLE.READONLY);

                nullable = (ODBC32.SQL_NULLABILITY) GetColAttribute(i, ODBC32.SQL_DESC.NULLABLE, ODBC32.SQL_COLUMN.NULLABLE, ODBC32.HANDLER.IGNORE);
                metaInfos[i].isNullable = (nullable == ODBC32.SQL_NULLABILITY.NULLABLE);

                switch(metaInfos[i].typemap._sql_type) {
                    case ODBC32.SQL_TYPE.LONGVARCHAR:
                    case ODBC32.SQL_TYPE.WLONGVARCHAR:
                    case ODBC32.SQL_TYPE.LONGVARBINARY:
                        metaInfos[i].isLong = true;
                        break;
                    default:
                        metaInfos[i].isLong = false;
                        break;
                }
                if(IsBehavior(CommandBehavior.KeyInfo))
                {
                    // Note: Following two attributes are SQL Server specific (hence _SS in the name)
                    // 
                    isKeyColumn = GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_CA_SS.COLUMN_KEY, (ODBC32.SQL_COLUMN)(-1), ODBC32.HANDLER.IGNORE) == 1;
                    if (isKeyColumn) {
                        metaInfos[i].isKeyColumn = isKeyColumn;
                        metaInfos[i].isUnique = true;
                        needkeyinfo = false;
                    }
                    metaInfos[i].baseSchemaName = GetColAttributeStr(i, ODBC32.SQL_DESC.COLUMN_OWNER_NAME, ODBC32.SQL_COLUMN.OWNER_NAME, ODBC32.HANDLER.IGNORE);
                    metaInfos[i].baseCatalogName = GetColAttributeStr(i, ODBC32.SQL_DESC.COLUMN_CATALOG_NAME, (ODBC32.SQL_COLUMN)(-1), ODBC32.HANDLER.IGNORE);
                    metaInfos[i].baseTableName = GetColAttributeStr(i, ODBC32.SQL_DESC.BASE_TABLE_NAME, ODBC32.SQL_COLUMN.TABLE_NAME, ODBC32.HANDLER.IGNORE);
                    metaInfos[i].baseColumnName = GetColAttributeStr(i, ODBC32.SQL_DESC.BASE_COLUMN_NAME, ODBC32.SQL_COLUMN.NAME, ODBC32.HANDLER.IGNORE);
                    metaInfos[i].baseColumnName = metaInfos[i].baseColumnName;
                    
                    if ((metaInfos[i].baseTableName == null) ||(metaInfos[i].baseTableName.Length == 0))  {
                        // Driver didn't return the necessary information from GetColAttributeStr.
                        // Try GetDescField()
                        metaInfos[i].baseTableName = GetDescFieldStr(i, ODBC32.SQL_DESC.BASE_TABLE_NAME, ODBC32.HANDLER.IGNORE);
                    }
                    if ((metaInfos[i].baseColumnName == null) ||(metaInfos[i].baseColumnName.Length == 0))  {
                        // Driver didn't return the necessary information from GetColAttributeStr.
                        // Try GetDescField()
                        metaInfos[i].baseColumnName = GetDescFieldStr(i, ODBC32.SQL_DESC.BASE_COLUMN_NAME, ODBC32.HANDLER.IGNORE);
                    }
                    if ((metaInfos[i].baseTableName != null)  && !(qrytables.Contains(metaInfos[i].baseTableName))) {
                        qrytables.Add(metaInfos[i].baseTableName);
                    }
                }

                // If primary key or autoincrement, then must also be unique
                if (metaInfos[i].isKeyColumn || metaInfos[i].isAutoIncrement ) {
                    if (nullable == ODBC32.SQL_NULLABILITY.UNKNOWN)
                        metaInfos[i].isNullable = false;    // We can safely assume these are not nullable
                }
            }
            // now loop over the hidden columns (if any)
            //
            for (int i=count; i<count+_hiddenColumns; i++) {
                isKeyColumn = GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_CA_SS.COLUMN_KEY, (ODBC32.SQL_COLUMN)(-1), ODBC32.HANDLER.IGNORE) == 1;
                if (isKeyColumn) {
                    isHidden = GetColAttribute(i, (ODBC32.SQL_DESC)ODBC32.SQL_CA_SS.COLUMN_HIDDEN, (ODBC32.SQL_COLUMN)(-1), ODBC32.HANDLER.IGNORE) == 1;                        
                    if (isHidden) {
                        for (int j=0; j<count; j++) {
                            metaInfos[j].isKeyColumn = false;   // downgrade keycolumn
                            metaInfos[j].isUnique = false;      // downgrade uniquecolumn
                        }
                    }
                }
            }

            // Blow away the previous metadata
            this.metadata = metaInfos;

            // If key info is requested, then we have to make a few more calls to get the
            //  special columns. This may not succeed for all drivers, so ignore errors and
            // fill in as much as possible.
            if (IsBehavior(CommandBehavior.KeyInfo)) {
                if((qrytables != null) && (qrytables.Count > 0) ) {
                    System.Collections.IEnumerator  tablesEnum = qrytables.GetEnumerator();
                    QualifiedTableName qualifiedTableName = new QualifiedTableName();
                    while(tablesEnum.MoveNext()) {
                        // Find the primary keys, identity and autincrement columns
                       qualifiedTableName.Table = (string) tablesEnum.Current;
                       RetrieveKeyInfo(needkeyinfo, qualifiedTableName);
                    }
                }
                else {
                    // Some drivers ( < 3.x ?) do not provide base table information. In this case try to
                    // find it by parsing the statement
                    String      tabname;
                    tabname = GetTableNameFromCommandText();
                    QualifiedTableName qualifiedTableName = new QualifiedTableName(tabname);

                    if (!ADP.IsEmpty(tabname)) { // fxcop
                       SetBaseTableNames(qualifiedTableName);
                       RetrieveKeyInfo(needkeyinfo, qualifiedTableName );
                    }
                }
            }
        }

        private DataTable NewSchemaTable() {
            DataTable schematable = new DataTable("SchemaTable");
            schematable.MinimumCapacity = this.FieldCount;

            //Schema Columns
            DataColumnCollection columns    = schematable.Columns;
            columns.Add(new DataColumn("ColumnName",        typeof(System.String)));
            columns.Add(new DataColumn("ColumnOrdinal",     typeof(System.Int32))); // UInt32
            columns.Add(new DataColumn("ColumnSize",        typeof(System.Int32))); // UInt32
            columns.Add(new DataColumn("NumericPrecision",  typeof(System.Int16))); // UInt16
            columns.Add(new DataColumn("NumericScale",      typeof(System.Int16)));
            columns.Add(new DataColumn("DataType",          typeof(System.Object)));
            columns.Add(new DataColumn("ProviderType",        typeof(System.Int32)));
            columns.Add(new DataColumn("IsLong",            typeof(System.Boolean)));
            columns.Add(new DataColumn("AllowDBNull",       typeof(System.Boolean)));
            columns.Add(new DataColumn("IsReadOnly",        typeof(System.Boolean)));
            columns.Add(new DataColumn("IsRowVersion",      typeof(System.Boolean)));
            columns.Add(new DataColumn("IsUnique",          typeof(System.Boolean)));
            columns.Add(new DataColumn("IsKey",       typeof(System.Boolean)));
            columns.Add(new DataColumn("IsAutoIncrement",   typeof(System.Boolean)));
            columns.Add(new DataColumn("BaseSchemaName",    typeof(System.String)));
            columns.Add(new DataColumn("BaseCatalogName",   typeof(System.String)));
            columns.Add(new DataColumn("BaseTableName",     typeof(System.String)));
            columns.Add(new DataColumn("BaseColumnName",    typeof(System.String)));

            return schematable;
        }

        internal void SetParameterBuffers(CNativeBuffer[] parameterBuffer, CNativeBuffer[] parameterintbuffer) {
            _parameterBuffer = parameterBuffer;
            _parameterintbuffer = parameterintbuffer;
        }

#if INDEXINFO
        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetIndexTable"]/*' />
        public DataTable GetIndexTable() {
            // if we can't get index info, it's not catastrophic
            return null;
        }
#endif


        /// <include file='doc\OdbcDataReader.uex' path='docs/doc[@for="OdbcDataReader.GetSchemaTable"]/*' />

        // The default values are already defined in DBSchemaRows (see DBSchemaRows.cs) so there is no need to set any default value
        //

        public DataTable GetSchemaTable() {
            if (IsClosed) { // MDAC 68331
                throw ADP.DataReaderClosed("GetSchemaTable");           // can't use closed connection
            }
            if (_noMoreResults) {
                return null;                                            // no more results
            }
            if (null != this.schemaTable) {
                return this.schemaTable;                                // return cached schematable
            }
            
            //Delegate, to have the base class setup the structure
            DataTable schematable = NewSchemaTable();

            if (this.metadata == null) {
                BuildMetaDataInfo();
            }

            DataColumn columnName = schematable.Columns["ColumnName"];
            DataColumn columnOrdinal = schematable.Columns["ColumnOrdinal"];
            DataColumn columnSize = schematable.Columns["ColumnSize"];
            DataColumn numericPrecision = schematable.Columns["NumericPrecision"];
            DataColumn numericScale = schematable.Columns["NumericScale"];
            DataColumn dataType = schematable.Columns["DataType"];
            DataColumn providerType = schematable.Columns["ProviderType"];
            DataColumn isLong = schematable.Columns["IsLong"];
            DataColumn allowDBNull = schematable.Columns["AllowDBNull"];
            DataColumn isReadOnly = schematable.Columns["IsReadOnly"];
            DataColumn isRowVersion = schematable.Columns["IsRowVersion"];
            DataColumn isUnique = schematable.Columns["IsUnique"];
            DataColumn isKey = schematable.Columns["IsKey"];
            DataColumn isAutoIncrement = schematable.Columns["IsAutoIncrement"];
            DataColumn baseSchemaName = schematable.Columns["BaseSchemaName"];
            DataColumn baseCatalogName = schematable.Columns["BaseCatalogName"];
            DataColumn baseTableName = schematable.Columns["BaseTableName"];
            DataColumn baseColumnName = schematable.Columns["BaseColumnName"];


            //Populate the rows (1 row for each column)
            int count = FieldCount;
            for(int i=0; i<count; i++) {
                DataRow row = schematable.NewRow();

                row[columnName] = GetName(i);        //ColumnName
                row[columnOrdinal] = i;                 //ColumnOrdinal
                row[columnSize] = metadata[i].size;     // ColumnSize
                row[numericPrecision] = (Int16) metadata[i].precision;
                row[numericScale] = (Int16) metadata[i].scale;
                row[dataType] = metadata[i].typemap._type;          //DataType
                row[providerType] = metadata[i].typemap._odbcType;          // ProviderType
                row[isLong] = metadata[i].isLong;           // IsLong
                row[allowDBNull] = metadata[i].isNullable;       //AllowDBNull
                row[isReadOnly] = metadata[i].isReadOnly;      // IsReadOnly
                row[isRowVersion] = metadata[i].isRowVersion;    //IsRowVersion
                row[isUnique] = metadata[i].isUnique;        //IsUnique
                row[isKey] =  metadata[i].isKeyColumn;    // IsKey
                row[isAutoIncrement] = metadata[i].isAutoIncrement; //IsAutoIncrement

                //BaseSchemaName
                row[baseSchemaName] =  metadata[i].baseSchemaName;
                //BaseCatalogName
                row[baseCatalogName] = metadata[i].baseCatalogName;
                //BaseTableName
                row[baseTableName] = metadata[i].baseTableName ;
                //BaseColumnName
                row[baseColumnName] =  metadata[i].baseColumnName;

                schematable.Rows.Add(row);
                row.AcceptChanges();
            }
            this.schemaTable = schematable;
            return schematable;
        }

        internal void RetrieveKeyInfo(bool needkeyinfo, QualifiedTableName qualifiedTableName)
        {
            ODBC32.RETCODE retcode;
            string columnname;
            int         ordinal;
            int         keyColumns = 0;
            IntPtr cbActual = IntPtr.Zero;

            if (IsClosed || (_cmdWrapper == null) || (_cmdWrapper._keyinfostmt == IntPtr.Zero)) {
                return;     // Can't do anything without a second handle
            }

            Debug.Assert(_buffer.Length >= 256, "Native buffer to small (_buffer.Length < 256)");
            IntPtr  tmpbuf = _buffer.Ptr; // new CNativeBuffer(256);

            if (needkeyinfo) {
                // Get the primary keys
                retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLPrimaryKeysW(
                            _cmdWrapper.hKeyinfoStmt,               //
                            qualifiedTableName.Catalog, (Int16)(qualifiedTableName.Catalog==null?0:ODBC32.SQL_NTS),          // CatalogName
                            qualifiedTableName.Schema, (Int16) (qualifiedTableName.Schema==null?0:ODBC32.SQL_NTS),            // SchemaName
                            qualifiedTableName.Table, (Int16) (qualifiedTableName.Table==null?0:ODBC32.SQL_NTS)               // TableName
                        );
                if ((retcode == ODBC32.RETCODE.SUCCESS) || (retcode == ODBC32.RETCODE.SUCCESS_WITH_INFO))
                {
                    bool noUniqueKey = false;
                    // We are only interested in column name
                    Marshal.WriteInt16(tmpbuf, 0);
                    retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLBindCol(
                                   _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                                   (short)(ODBC32.SQL_PRIMARYKEYS.COLUMNNAME),    // Column Number
                                   (short)(ODBC32.SQL_C.WCHAR),
                                   _buffer,
                                   (IntPtr)256,
                                   out cbActual);
                    while ((retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLFetch(_cmdWrapper.hKeyinfoStmt))
                            == ODBC32.RETCODE.SUCCESS) {
                        columnname = Marshal.PtrToStringUni(tmpbuf, (int)cbActual/2/*cch*/);
                        ordinal = -1;
                        try {
                            ordinal = this.GetOrdinalFromBaseColName(columnname);
                        }
                        catch (Exception e) {
                            ADP.TraceException (e); // Never throw!
                            
                            // Ignore the ones not listed in the results set.
                            // Should we return an Error here because of incomplete key set?
                        }
                        if (ordinal != -1) {
                            keyColumns ++;
                            this.metadata[ordinal].isKeyColumn = true;
                            this.metadata[ordinal].isUnique = true;
                            this.metadata[ordinal].isNullable = false;
                            if (this.metadata[ordinal].baseTableName == null) {
                                this.metadata[ordinal].baseTableName = qualifiedTableName.Table;
                            }
                            if (this.metadata[ordinal].baseColumnName == null) {
                                this.metadata[ordinal].baseColumnName = columnname;
                            }
                        }
                        else {
                            noUniqueKey = true;
                            break;  // no need to go over the remaining columns anymore
                        }
                    }
// TODO!
// if it fails there is a partial primary key (e.g. A and C from ABC where A and B are prim.key and B is not in the set).
//
// There may be special cases like hidden column that is primary key 

// if we got keyinfo from the column we dont even get to here!
//
                    // reset isUnique flag if the key(s) are not unique
                    //
                    if (noUniqueKey) {
                        foreach (MetaData metadata in this.metadata) {
                            metadata.isKeyColumn = false;
                        }
                    }
                    
                    // Unbind the column
                    UnsafeNativeMethods.Odbc32.SQLBindCol(
                                   _cmdWrapper.hKeyinfoStmt,                        // SQLHSTMT     StatementHandle
                                   (short)(ODBC32.SQL_PRIMARYKEYS.COLUMNNAME),      // SQLUSMALLINT ColumnNumber
                                   (short)(ODBC32.SQL_C.WCHAR),                     // SQLSMALLINT  TargetType
                                   new HandleRef (null, IntPtr.Zero),               // SQLPOINTER   TargetValuePtr
                                   IntPtr.Zero,                                     // SQLINTEGER   BufferLength
                                   out cbActual);                                   // SQLLEN *     StrLen_or_Ind
                }
                if (keyColumns == 0)
                {
                    // SQLPrimaryKeys did not work. Have to use the slower SQLStatistics to obtain key information
                    UnsafeNativeMethods.Odbc32.SQLMoreResults(_cmdWrapper.hKeyinfoStmt);
                    RetrieveKeyInfoFromStatistics(qualifiedTableName.Table);
                }
                UnsafeNativeMethods.Odbc32.SQLMoreResults(_cmdWrapper.hKeyinfoStmt);
            } // End  if (needkeyinfo)

            // Get the special columns for version
            retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSpecialColumnsW(_cmdWrapper.hKeyinfoStmt,
                        (Int16)ODBC32.SQL_SPECIALCOLS.ROWVER, null, 0, null, 0,
                        qualifiedTableName.Table, (Int16) ODBC32.SQL_NTS,
                        (Int16) ODBC32.SQL_SCOPE.SESSION, (Int16) ODBC32.SQL_NULLABILITY.NO_NULLS );
            if ((retcode == ODBC32.RETCODE.SUCCESS) || (retcode == ODBC32.RETCODE.SUCCESS_WITH_INFO))
            {
                // We are only interested in column name
                cbActual = IntPtr.Zero;
                Marshal.WriteInt16(tmpbuf, 0);
                retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLBindCol(
                              _cmdWrapper.hKeyinfoStmt,            
                               (short)(ODBC32.SQL_SPECIALCOLUMNSET.COLUMN_NAME),
                               (short)(ODBC32.SQL_C.WCHAR),
                               _buffer,
                               (IntPtr)256,
                               out cbActual);
                while ((retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLFetch(_cmdWrapper.hKeyinfoStmt))
                        == ODBC32.RETCODE.SUCCESS) {
                    columnname = Marshal.PtrToStringUni(tmpbuf, (int)cbActual/2/*cch*/);
                    ordinal = -1;
                    try {
                         ordinal = this.GetOrdinalFromBaseColName(columnname);
                    }
                    catch (Exception e) {
                        ADP.TraceException (e); // Never throw!
                            
                            // Ignore the ones not listed in the results set.
                            // Should we return an Error here because of incomplete key set?
                    }
                    if (ordinal != -1) {
                        this.metadata[ordinal].isRowVersion = true;
                        if (this.metadata[ordinal].baseColumnName == null) {
                            this.metadata[ordinal].baseColumnName = columnname;
                        }
                    }
                }
                // Unbind the column
                UnsafeNativeMethods.Odbc32.SQLBindCol(
                               _cmdWrapper.hKeyinfoStmt,
                               (short)(ODBC32.SQL_SPECIALCOLUMNSET.COLUMN_NAME),
                               (short)(ODBC32.SQL_C.WCHAR),
                               new HandleRef (null, IntPtr.Zero), 
                               IntPtr.Zero, 
                               out cbActual);

                retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLMoreResults(_cmdWrapper.hKeyinfoStmt);
            }
            GC.KeepAlive(this);
            // tmpbuf.Dispose();
        }

        // Uses SQLStatistics to retrieve key information for a table
        internal void RetrieveKeyInfoFromStatistics(String tablename)
        {
            ODBC32.RETCODE retcode;
            String      columnname = String.Empty;
            String      indexname = String.Empty;
            String      currentindexname = String.Empty;
            int[]       indexcolumnordinals = new int[16];
            int[]        pkcolumnordinals = new int[16];
            int         npkcols = 0;
            int         ncols = 0;                  // No of cols in the index
            bool        partialcolumnset = false;
            int         ordinal;
            int         indexordinal;
            IntPtr cbIndexLen = IntPtr.Zero;
            IntPtr cbColnameLen = IntPtr.Zero;
            IntPtr cbActual = IntPtr.Zero;

            if (IsClosed) return;   // protect against dead connection
            
            // MDAC Bug 75928 - SQLStatisticsW damages the string passed in
            // To protect the tablename we need to pass in a copy of that string
            String tablename1 = String.Copy(tablename);

            // Select only unique indexes
            retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLStatisticsW(_cmdWrapper.hKeyinfoStmt,
                    null, 0, null, 0,
                    tablename1, (Int16) ODBC32.SQL_NTS,
                    (Int16) ODBC32.SQL_INDEX.UNIQUE,
                    (Int16) ODBC32.SQL_STATISTICS_RESERVED.ENSURE );
            if (retcode != ODBC32.RETCODE.SUCCESS) {
                // The failure could be due to a qualified table name (provider < 3.x ?).
                // If so, strip out the qualified portion and retry
                QualifiedTableName qualifiedTableName = new QualifiedTableName(tablename);
                if (qualifiedTableName.Table != null) {
                    retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLStatisticsW(_cmdWrapper.hKeyinfoStmt,
                        null, 0, null, 0,
                        qualifiedTableName.Table, (Int16) ODBC32.SQL_NTS,
                        (Int16) ODBC32.SQL_INDEX.UNIQUE,
                        (Int16) ODBC32.SQL_STATISTICS_RESERVED.ENSURE );
                }
                if (retcode != ODBC32.RETCODE.SUCCESS) {
                    // We give up at this point
                    GC.KeepAlive(this);
                    return ;
                }
            }

            Debug.Assert(_buffer.Length >= 516, "Native buffer to small (_buffer.Length < 516)");

            IntPtr colnamebuf = _buffer.Ptr;         // new CNativeBuffer(256);
            IntPtr indexbuf   = ADP.IntPtrOffset(_buffer.Ptr, 256);   // new CNativeBuffer(256);
            IntPtr ordinalbuf = ADP.IntPtrOffset(_buffer.Ptr, 512);   // new CNativeBuffer(4);

            //We are interested in index name, column name, and ordinal
            Marshal.WriteInt16(indexbuf, 0);
            retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLBindCol(
                        _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                        (short)(ODBC32.SQL_STATISTICS.INDEXNAME),
                        (short)(ODBC32.SQL_C.WCHAR),
                        new HandleRef (this, ADP.IntPtrOffset(_buffer.Ptr, 256)),
                        (IntPtr)256,
                        out cbIndexLen);
            retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLBindCol(
                        _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                        (short)(ODBC32.SQL_STATISTICS.ORDINAL_POSITION),
                        (short)(ODBC32.SQL_C.SSHORT),
                        new HandleRef (this, ADP.IntPtrOffset(_buffer.Ptr, 512)),
                        (IntPtr)4,
                        out cbActual);
            Marshal.WriteInt16(ordinalbuf, 0);
            retcode = (ODBC32.RETCODE)
                UnsafeNativeMethods.Odbc32.SQLBindCol(
                        _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                        (short)(ODBC32.SQL_STATISTICS.COLUMN_NAME),
                        (short)(ODBC32.SQL_C.WCHAR),
                        _buffer,
                        (IntPtr)256,
                        out cbColnameLen);
            // Find the best unique index on the table, use the ones whose columns are
            // completely covered by the query.s
            while ((retcode = (ODBC32.RETCODE)UnsafeNativeMethods.Odbc32.SQLFetch(_cmdWrapper.hKeyinfoStmt))
                == ODBC32.RETCODE.SUCCESS) {

                // If indexname is not returned, skip this row
                if (Marshal.ReadInt16(indexbuf) == 0)
                    continue;       // Not an index row, get next row.

                columnname = Marshal.PtrToStringUni(colnamebuf, (int)cbColnameLen/2/*cch*/);

                indexname = Marshal.PtrToStringUni(indexbuf, (int)cbIndexLen/2/*cch*/);
                ordinal = (int) Marshal.ReadInt16(ordinalbuf);
                if (SameIndexColumn(currentindexname, indexname, ordinal, ncols)) {
                    // We are still working on the same index
                    if (partialcolumnset)
                        continue;       // We don't have all the keys for this index, so we can't use it
                    ordinal = -1;
                    try {
                        ordinal = this.GetOrdinalFromBaseColName(columnname, tablename);
                    }
                    catch (Exception e) {
                        ADP.TraceException (e); // Never throw!
                    }
                    if (ordinal == -1) {
                         partialcolumnset = true;
                    }
                    else {
                        // Add the column to the index column set
                        if (ncols < 16)
                            indexcolumnordinals[ncols++] = ordinal;
                        else    // Can't deal with indexes > 16 columns
                            partialcolumnset = true;
                    }
                }
                else {
                    // We got a new index, save the previous index information
                    if (!partialcolumnset && (ncols != 0)) {
                        // Choose the unique index with least columns as primary key
                        if ((npkcols == 0) || (npkcols > ncols)){
                            npkcols = ncols;
                            for (int i = 0 ; i < ncols ; i++)
                                pkcolumnordinals[i] = indexcolumnordinals[i];
                        }
                    }
                    // Reset the parameters for a new index
                    ncols = 0;
                    currentindexname = indexname;
                    partialcolumnset = false;
                    // Add this column to index
                    ordinal = -1;
                    try {
                        ordinal = this.GetOrdinalFromBaseColName(columnname, tablename);
                    }
                    catch (Exception e) {
                        ADP.TraceException (e); // Never throw!
                    }
                    if (ordinal == -1) {
                         partialcolumnset = true;
                    }
                    else {
                        // Add the column to the index column set
                        indexcolumnordinals[ncols++] = ordinal;
                    }
                }
                // Go on to the next column
            }
            // Do we have an index?
            if (!partialcolumnset && (ncols != 0)) {
                // Choose the unique index with least columns as primary key
                if ((npkcols == 0) || (npkcols > ncols)){
                    npkcols = ncols;
                    for (int i = 0 ; i < ncols ; i++)
                        pkcolumnordinals[i] = indexcolumnordinals[i];
                }
            }
            // Mark the chosen index as primary key
            if (npkcols != 0) {
                for (int i = 0 ; i < npkcols ; i++) {
                    indexordinal = pkcolumnordinals[i];
                    this.metadata[indexordinal].isKeyColumn = true;
// should we set isNullable = false?
// This makes the QuikTest against Jet fail
//
// test test test - we don't know if this is nulalble or not so why do we want to set it to a value?
                    this.metadata[indexordinal].isNullable = false;
                    this.metadata[indexordinal].isUnique = true;
                    if (this.metadata[indexordinal].baseTableName == null) {
                        this.metadata[indexordinal].baseTableName = tablename;
                    }
                    if (this.metadata[indexordinal].baseColumnName == null) {
                        this.metadata[indexordinal].baseColumnName = columnname;
                    }
                }
            }
            // Unbind the columns
            UnsafeNativeMethods.Odbc32.SQLBindCol(
                   _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                   (short)(ODBC32.SQL_STATISTICS.INDEXNAME),
                   (short)(ODBC32.SQL_C.WCHAR),
                   new HandleRef (null, IntPtr.Zero), IntPtr.Zero, out cbActual);
            UnsafeNativeMethods.Odbc32.SQLBindCol(
                   _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                   (short)(ODBC32.SQL_STATISTICS.COLUMN_NAME),    // Column Number
                   (short)(ODBC32.SQL_C.WCHAR),
                   new HandleRef (null, IntPtr.Zero), IntPtr.Zero, out cbActual);
            UnsafeNativeMethods.Odbc32.SQLBindCol(
                   _cmdWrapper.hKeyinfoStmt,            // StatementHanle
                   (short)(ODBC32.SQL_STATISTICS.ORDINAL_POSITION),    // Column Number
                   (short)(ODBC32.SQL_C.SSHORT),
                   new HandleRef (null, IntPtr.Zero), IntPtr.Zero, out cbActual);

            GC.KeepAlive(this);
        }

        internal bool SameIndexColumn(String currentindexname, String indexname, int ordinal, int ncols)
        {
            if (currentindexname == String.Empty)
                return false;
            if ((currentindexname == indexname)  &&
                (ordinal == ncols+1))
                    return true;
            return false;
        }

        internal int GetOrdinalFromBaseColName(String columnname) {
            return GetOrdinalFromBaseColName(columnname, String.Empty);
        }

        internal int GetOrdinalFromBaseColName(String columnname, String tablename)
        {
            if (columnname == String.Empty) {
                return -1;
            }
            if (this.metadata != null) {
                int count = FieldCount;
                for (int i = 0 ; i < count ; i++) {
                    if ( (this.metadata[i].baseColumnName != null) &&
                        (columnname == this.metadata[i].baseColumnName)) {
                        if (tablename != String.Empty) {
                            if (tablename == this.metadata[i].baseTableName) {
                                return i;
                            } // end if
                        } // end if
                        else {
                            return i;
                        } // end else
                    }
                }
            }
            // We can't find it in base column names, try regular colnames
            return this.GetOrdinal(columnname);
        }

        // We try parsing the SQL statement to get the table name as a last resort when
        // the driver doesn't return this information back to us.
        internal string GetTableNameFromCommandText()
        {
            if (command == null){
                return null;
            }
            String tempstr = command.CommandText;
            if (ADP.IsEmpty(tempstr)) { // fxcop
                return null;
            }
            String tablename;
            CStringTokenizer tokenstmt = new CStringTokenizer(Connection.QuoteChar, Connection.EscapeChar);
            int     idx;
            tokenstmt.Statement = tempstr;

            if (tokenstmt.StartsWith("select", true) == true) {
              // select command, search for from clause
              idx = tokenstmt.FindTokenIndex("from", true);
            }
            else {
                if ((tokenstmt.StartsWith("insert", true) == true) ||
                    (tokenstmt.StartsWith("update", true) == true) ||
                    (tokenstmt.StartsWith("delete", true) == true) ) {
                    // Get the following word
                    idx = tokenstmt.CurrentPosition;
                }
                else
                    idx = -1;
            }
            if (idx == -1)
                return null;
            // The next token is the table name
            tablename = tokenstmt.NextToken();

            tempstr = tokenstmt.NextToken();
            if ((tempstr.Length > 0) && (tempstr[0] == ',')) {
                return null;        // Multiple tables
            }
            if ((tempstr.Length == 2) &&
                ((tempstr[0] == 'a') || (tempstr[0] == 'A')) &&
                ((tempstr[1] == 's') || (tempstr[1] == 'S'))) {
                // aliased table, skip the alias name
                tempstr = tokenstmt.NextToken();
                tempstr = tokenstmt.NextToken();
                if ((tempstr.Length > 0) && (tempstr[0] == ',')) {
                    return null;        // Multiple tables
                }
            }
            return tablename;
        }

        internal void SetBaseTableNames(QualifiedTableName qualifiedTableName)
        {
            int count = FieldCount;

            for(int i=0; i<count; i++)
            {
                if (metadata[i].baseTableName == null) {
                    metadata[i].baseTableName = UnQuote(qualifiedTableName.Table, Connection.QuoteChar);
                    metadata[i].baseSchemaName = UnQuote(qualifiedTableName.Schema, Connection.QuoteChar);
                    metadata[i].baseCatalogName = UnQuote(qualifiedTableName.Catalog, Connection.QuoteChar);
                }
            }
            return;
        }

        sealed internal class QualifiedTableName {
            private string _catalogName;
            private string _schemaName;
            private string _tableName;
            public string Catalog {
                get {
                    return _catalogName;
                }
            }
            public string Schema {
                get {
                    return _schemaName;
                }
            }
            public string Table {
                get {
                    return _tableName;
                }
                set {
                    _tableName = value;
                }
            }
            public QualifiedTableName () {
            }
            public QualifiedTableName (string qualifiedname) {
                string[] names = ADP.ParseProcedureName (qualifiedname);
                _catalogName = names[1];
                _schemaName = names[2];
                _tableName = names[3];
            }
        }

        sealed private class MetaData {

            internal int ordinal;
            internal TypeMap typemap;

            internal int size;
            internal byte precision;
            internal byte scale;

            internal bool isAutoIncrement;
            internal bool isUnique;
            internal bool isReadOnly;
            internal bool isNullable;
            internal bool isRowVersion;
            internal bool isLong;

            internal bool isKeyColumn;
            internal string baseSchemaName;
            internal string baseCatalogName;
            internal string baseTableName;
            internal string baseColumnName;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcdescription.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSysAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Odbc {

    using System;
    using System.ComponentModel;

    /// <include file='doc\OdbcDescriptionAttribute.uex' path='docs/doc[@for="OdbcDescriptionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All)]
    sealed internal class OdbcDescriptionAttribute : DescriptionAttribute {

        /// <include file='doc\OdbcDescriptionAttribute.uex' path='docs/doc[@for="OdbcDescriptionAttribute.OdbcDescriptionAttribute"]/*' />
        public OdbcDescriptionAttribute(string description) : base(description) {
            DescriptionValue = Res.GetString(base.Description);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcerror.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcError.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;

namespace System.Data.Odbc
{
    /// <include file='doc\OdbcError.uex' path='docs/doc[@for="OdbcError"]/*' />
    [Serializable]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcError {
        //Data
        internal string _message;
        internal string _state;
        internal int    _nativeerror;
        internal string _source;

        internal OdbcError(string source, string message, string state, int nativeerror) {
            _source = source;
            _message    = message;
            _state      = state;
            _nativeerror= nativeerror;
        }

        /// <include file='doc\OdbcError.uex' path='docs/doc[@for="OdbcError.Message"]/*' />
        public string Message {
            get {
                return ((null != _message) ? _message : String.Empty);
            }
        }

        /// <include file='doc\OdbcError.uex' path='docs/doc[@for="OdbcError.State"]/*' />
        public string SQLState {
            get {
                return _state;
            }
        }

        /// <include file='doc\OdbcError.uex' path='docs/doc[@for="OdbcError.NativeError"]/*' />
        public int NativeError {
            get {
                return _nativeerror;
            }
        }

        /// <include file='doc\OdbcError.uex' path='docs/doc[@for="OdbcError.Source"]/*' />
        public string Source {
            get {
                return ((null != _source) ? _source : String.Empty);
            }
        }

        internal void SetSource (string Source) {
            _source = Source;
        }
        
        /// <include file='doc\OdbcError.uex' path='docs/doc[@for="OdbcError.ToString"]/*' />
        override public string ToString() {
            return Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcdataadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcDataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Data;
using System.Data.Common;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter"]/*' />
    [
    DefaultEvent("RowUpdated"),
    ToolboxItem("Microsoft.VSDesigner.Data.VS.OdbcDataAdapterToolboxItem, " + AssemblyRef.MicrosoftVSDesigner),
    Designer("Microsoft.VSDesigner.Data.VS.OdbcDataAdapterDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcDataAdapter : DbDataAdapter, IDbDataAdapter, ICloneable {

        static private readonly object EventRowUpdated = new object(); 
        static private readonly object EventRowUpdating = new object(); 

        private OdbcCommand cmdSelect;
        private OdbcCommand cmdInsert;
        private OdbcCommand cmdUpdate;
        private OdbcCommand cmdDelete;
        private OdbcCommand internalCmdSelect;

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.OdbcDataAdapter"]/*' />
        public OdbcDataAdapter() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.OdbcDataAdapter1"]/*' />
        public OdbcDataAdapter(OdbcCommand selectCommand) : base() {
            GC.SuppressFinalize(this);
            SelectCommand = selectCommand;
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.OdbcDataAdapter2"]/*' />
        public OdbcDataAdapter(string selectCommandText, OdbcConnection selectConnection) {
            GC.SuppressFinalize(this);
            internalCmdSelect = SelectCommand = new OdbcCommand(selectCommandText, selectConnection);
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.OdbcDataAdapter3"]/*' />
        //[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public OdbcDataAdapter(string selectCommandText, string selectConnectionString) {
            GC.SuppressFinalize(this);
            internalCmdSelect = SelectCommand = new OdbcCommand(selectCommandText, new OdbcConnection(selectConnectionString));
        }

        private OdbcDataAdapter(OdbcDataAdapter adapter) : base(adapter) { // MDAC 81448
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.DeleteCommand"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Update),
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.DbDataAdapter_DeleteCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OdbcCommand DeleteCommand {
            get {
                return cmdDelete;
            }
            set {
                this.cmdDelete = value;
            }
        }
        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.IDbDataAdapter.DeleteCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.DeleteCommand {
            get {
                return cmdDelete;
            }
            set {
                DeleteCommand = (OdbcCommand)value;
            }
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.InsertCommand"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Update),
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.DbDataAdapter_InsertCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OdbcCommand InsertCommand {
            get {
                return cmdInsert;
            }
            set {
                this.cmdInsert = value;
            }
        }
        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.IDbDataAdapter.InsertCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.InsertCommand {
            get {
                return cmdInsert;
            }
            set {
                InsertCommand = (OdbcCommand)value;
            }
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.SelectCommand"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Fill),
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.DbDataAdapter_SelectCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OdbcCommand SelectCommand {
            get {
                return cmdSelect;
            }
            set {
                if (this.cmdSelect != value) {
                    this.cmdSelect = value;
                    ADP.SafeDispose(internalCmdSelect);
                    internalCmdSelect = null;
                }            
            }
        }
        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.IDbDataAdapter.SelectCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.SelectCommand {
            get {
                return cmdSelect;
            }
            set {
                SelectCommand = (OdbcCommand)value;
            }
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.UpdateCommand"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Update),
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.DbDataAdapter_UpdateCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OdbcCommand UpdateCommand {
            get {
                return cmdUpdate;
            }
            set {
                this.cmdUpdate = value;
            }
        }
        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.IDbDataAdapter.UpdateCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.UpdateCommand {
            get {
                return cmdUpdate;
            }
            set {
                UpdateCommand = (OdbcCommand)value;
            }
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.RowUpdated"]/*' />
        public event OdbcRowUpdatedEventHandler RowUpdated {
            add {
                Events.AddHandler(EventRowUpdated, value);
            }
            remove {
                Events.RemoveHandler(EventRowUpdated, value);
            }
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.RowUpdating"]/*' />
        public event OdbcRowUpdatingEventHandler RowUpdating {
            add {
                OdbcRowUpdatingEventHandler handler = (OdbcRowUpdatingEventHandler) Events[EventRowUpdating];

                // MDAC 58177, 64513
                // prevent someone from registering two different command builders on the adapter by
                // silently removing the old one
                if ((null != handler) && (value.Target is CommandBuilder)) {
                    OdbcRowUpdatingEventHandler d = (OdbcRowUpdatingEventHandler) CommandBuilder.FindBuilder(handler);
                    if (null != d) {
                        Events.RemoveHandler(EventRowUpdating, d);
                    }
                }
                Events.AddHandler(EventRowUpdating, value);
            }
            remove {
                Events.RemoveHandler(EventRowUpdating, value);
            }
        }

        object ICloneable.Clone() { // MDAC 81448
            return new OdbcDataAdapter(this);
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.Dispose"]/*' />
        override protected void Dispose(bool disposing) {
            if (disposing) {
                if (this.internalCmdSelect != null) {
                    internalCmdSelect.Dispose();
                    internalCmdSelect = null;
                }
            }
            base.Dispose(disposing); // notify base classes 
        }
        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.CreateRowUpdatedEvent"]/*' />
        override protected RowUpdatedEventArgs  CreateRowUpdatedEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            return new OdbcRowUpdatedEventArgs(dataRow, command, statementType, tableMapping);
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.CreateRowUpdatingEvent"]/*' />
        override protected RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            return new OdbcRowUpdatingEventArgs(dataRow, command, statementType, tableMapping);
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.OnRowUpdated"]/*' />
        override protected void OnRowUpdated(RowUpdatedEventArgs value) {
            OdbcRowUpdatedEventHandler handler = (OdbcRowUpdatedEventHandler) Events[EventRowUpdated];
            if ((null != handler) && (value is OdbcRowUpdatedEventArgs)) {
                handler(this, (OdbcRowUpdatedEventArgs) value);
            }
        }

        /// <include file='doc\OdbcDataAdapter.uex' path='docs/doc[@for="OdbcDataAdapter.OnRowUpdating"]/*' />
        override protected void OnRowUpdating(RowUpdatingEventArgs value) {
            OdbcRowUpdatingEventHandler handler = (OdbcRowUpdatingEventHandler) Events[EventRowUpdating];
            if ((null != handler) && (value is OdbcRowUpdatingEventArgs)) {
                handler(this, (OdbcRowUpdatingEventArgs) value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;    //Component
using System.Collections;       //ICollection
using System.Data;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcException.uex' path='docs/doc[@for="OdbcException"]/*' />
    [Serializable]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcException : SystemException {

        OdbcErrorCollection odbcErrors = new OdbcErrorCollection();
        ODBC32.RETCODE _retcode;

        internal OdbcException(OdbcErrorCollection errors, ODBC32.RETCODE retcode) {
            odbcErrors = errors;
            _retcode= retcode;
        }

        // runtime will call even if private...
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        private OdbcException(SerializationInfo si, StreamingContext sc) : base(si, sc) {
            _retcode = (ODBC32.RETCODE) si.GetValue("odbcRetcode", typeof(ODBC32.RETCODE));
            odbcErrors = (OdbcErrorCollection) si.GetValue("odbcErrors", typeof(OdbcErrorCollection));
        }

        /// <include file='doc\OdbcException.uex' path='docs/doc[@for="OdbcException.Errors"]/*' />
        public OdbcErrorCollection Errors {
            get {
                return odbcErrors;
            }
        }

        /// <include file='doc\OdbcException.uex' path='docs/doc[@for="OdbcException.Message"]/*' />
        override public string Message {
            get {
                int count = Errors.Count;
                if (0 < count) {
                    StringBuilder builder = new StringBuilder();
                    for (int i=0; i<count; i++) {
                        OdbcError error = odbcErrors[i];
                        if (i>0) { 
                            builder.Append("\r\n");
                        }
                        builder.Append(Res.GetString(Res.Odbc_ExceptionMessage, _retcode.ToString(), error.SQLState, error.Message)); // MDAC 68337
                    }
                    return builder.ToString();
                }
                return Res.GetString(Res.Odbc_ExceptionNoInfoMsg, _retcode.ToString()); // MDAC 68337
            }
        }

        /// <include file='doc\OdbcException.uex' path='docs/doc[@for="OdbcException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        override public void GetObjectData(SerializationInfo si, StreamingContext context) { // MDAC 72003
            if (null == si) {
                throw new ArgumentNullException("si");
            }
            si.AddValue("odbcRetcode", _retcode, typeof(ODBC32.RETCODE));
            si.AddValue("odbcErrors", odbcErrors, typeof(OdbcErrorCollection));
            base.GetObjectData(si, context);
        }

        // mdac bug 62559 - if we don't have it return nothing (empty string)
        /// <include file='doc\OdbcException.uex' path='docs/doc[@for="OdbcException.Source"]/*' />
        override public string Source {
            get {
                if (0 < Errors.Count) {
                    string source = Errors[0].Source;
                    return (String.Empty != source) ? source : ""; // base.Source;
                }
                return ""; // base.Source;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Globalization;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter"]/*' />
    [
    TypeConverterAttribute(typeof(OdbcParameterConverter))
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcParameter : MarshalByRefObject, IDbDataParameter, ICloneable {

        private ParameterDirection direction = ParameterDirection.Input;
        private string parameterName;
        private int size;
        private object _value;

        private string sourcecolumn;
        private DataRowVersion sourceversion  = DataRowVersion.Current;

        private Byte precision;
        private Byte scale;

        private bool isNullable;        
        private bool _userSpecifiedType;
        private bool _userSpecifiedScale;

        private  OdbcParameterCollection _parent;

        private ODBC32.SQL_PARAM   _sqldirection   = ODBC32.SQL_PARAM.INPUT;


        // _typemap     User explicit set type  or  default parameter type
        // _infertpe    _typemap if the user explicitly sets type
        //              otherwise it is infered from the value
        // _bindtype    The actual type used for binding. E.g. string substitutes numeric
        //
        // set_DbType:      _bindtype = _infertype = _typemap = TypeMap.FromDbType(value)
        // set_OdbcType:    _bindtype = _infertype = _typemap = TypeMap.FromOdbcType(value)
        //
        // GetParameterType:    If _typemap != _infertype AND value != 0
        //                      _bindtype = _infertype = TypeMap.FromSystemType(value.GetType());
        //                      otherwise
        //                      _bindtype = _infertype
        //
        // Bind:            Bind may change _bindtype if the type is not supported through the driver
        //
        
        private TypeMap _typemap;
        private TypeMap _bindtype;
        private TypeMap _originalbindtype;      // the original type in case we had to change the bindtype (e.g. decimal to string)

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcParameter"]/*' />
        public OdbcParameter() {
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcParameter1"]/*' />
        public OdbcParameter(string name, object value) {
            ParameterName  = name;
            Value          = value;
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcParameter2"]/*' />
        public OdbcParameter(string name, OdbcType type) {
            ParameterName  = name;
            OdbcType       = type;
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcParameter3"]/*' />
        public OdbcParameter(string name, OdbcType type, int size) {
            ParameterName  = name;
            OdbcType       = type;
            Size           = size;
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcParameter4"]/*' />
        public OdbcParameter(string name, OdbcType type, int size, string sourcecolumn) {
            ParameterName  = name;
            OdbcType       = type;
            Size           = size;
            SourceColumn   = sourcecolumn;
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcParameter5"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        public OdbcParameter(string parameterName,
                             OdbcType odbcType, int size,
                             ParameterDirection parameterDirection, Boolean isNullable,
                             Byte precision, Byte scale,
                             string srcColumn, DataRowVersion srcVersion,
                             object value) {
            this.ParameterName = parameterName;
            this.OdbcType = odbcType;
            this.Size = size;
            this.Direction = parameterDirection;
            this.IsNullable = isNullable;
            this.Precision = precision;
            this.Scale = scale;
            this.SourceColumn = srcColumn;
            this.SourceVersion = srcVersion;
            this.Value = value;
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.DbType"]/*' />
        [
        Browsable(false),
        OdbcCategoryAttribute(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OdbcDescriptionAttribute(Res.DataParameter_DbType)
        ]
        public System.Data.DbType DbType {
            get {
                if (_userSpecifiedType) {
                    return _typemap._dbType;
                }
                return TypeMap._NVarChar._dbType; // default type
            }
            set {
                if ((null == _typemap) || (_typemap._dbType != value)) {
                    OnSchemaChanging();
                    _typemap = TypeMap.FromDbType(value);
                    _userSpecifiedType = true;
                }
            }
        }


        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.Direction"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(ParameterDirection.Input),
        OdbcDescriptionAttribute(Res.DataParameter_Direction)
        ]
        public ParameterDirection Direction {
            get {
                return this.direction;
            }
            set {
                if (this.direction != value) {
                    OnSchemaChanging();

                    //We only take the hit to "convert" to and from sqldirection
                    //if the user changes the setting.  This way we don't convert in the common
                    //case - default value
                    switch(value) {
                    case ParameterDirection.Input:
                        _sqldirection = ODBC32.SQL_PARAM.INPUT;
                        break;
                    case ParameterDirection.Output:
                    case ParameterDirection.ReturnValue:
                        //ODBC doesn't seem to distinguish between output and return value
                        //as SQL_PARAM_RETURN_VALUE fails with "Invalid parameter type"
                        _sqldirection = ODBC32.SQL_PARAM.OUTPUT;
                        break;
                    case ParameterDirection.InputOutput:
                        _sqldirection = ODBC32.SQL_PARAM.INPUT_OUTPUT;
                        break;
                    default:
                        throw ADP.InvalidParameterDirection((int) value, ParameterName);
                    }
                    this.direction = value;
                }
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.IsNullable"]/*' />
        [
        Browsable(false), // MDAC 70780
        DefaultValue(false),
        DesignOnly(true),
        OdbcDescriptionAttribute(Res.DataParameter_IsNullable),
        EditorBrowsableAttribute(EditorBrowsableState.Advanced) // MDAC 69508
        ]
        public Boolean IsNullable {
            get {
                return this.isNullable;
            }
            set {
                this.isNullable = value;
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.OdbcType"]/*' />
        [
        DefaultValue(OdbcType.NChar),
        OdbcCategoryAttribute(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        OdbcDescriptionAttribute(Res.OdbcParameter_OdbcType)
        ]
        public OdbcType OdbcType {
            get {
                if (_userSpecifiedType) {
                    return _typemap._odbcType;
                }
                return TypeMap._NVarChar._odbcType; // default type
            }
            set {
                if ((null == _typemap) || (_typemap._odbcType != value)) {
                    OnSchemaChanging();

                    _typemap = TypeMap.FromOdbcType(value);
                    _userSpecifiedType = true;
                }
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.ParameterName"]/*' />
        [
        DefaultValue(""),
        OdbcDescriptionAttribute(Res.DataParameter_ParameterName)
        ]
        public String ParameterName {
            get {
                return ((null != this.parameterName) ? this.parameterName : String.Empty);
            }
            set {
                if (value != this.parameterName) {
                    OnSchemaChanging();  // fire event before value is validated
                    this.parameterName = value;
                    //OnSchemaChanged();
                }
            }
        }

        internal OdbcParameterCollection Parent {
            get {
                return _parent;
            }
            set {
                _parent = value;
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.Precision"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        OdbcDescriptionAttribute(Res.DbDataParameter_Precision)
        ]
        public Byte Precision {
            get {
                return this.precision;
            }
            set {
                if (this.precision != value) {
                    OnSchemaChanging();
                    if (this._parent != null) {
                        if (this.precision != value) {
                            this._parent.BindingIsValid = false;
                        }
                    }
                    this.precision = value;
                }
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.Scale"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        OdbcDescriptionAttribute(Res.DbDataParameter_Scale)
        ]
        public Byte Scale {
            get {
                return this.scale;
            }
            set {
                if (this.scale != value) {
                    OnSchemaChanging();
                    if (this._parent != null) {
                        if (this.scale != value) {
                            this._parent.BindingIsValid = false;
                        }
                    }
                    this.scale = value;
                    _userSpecifiedScale = true;
                }
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.Size"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(0),
        OdbcDescriptionAttribute(Res.DbDataParameter_Size)
        ]
        public int Size {
            get {
                return this.size;
            }
            set {
                if (this.size != value) {
                    OnSchemaChanging();
                    if (value < 0) {
                        throw ADP.InvalidSizeValue(value);
                    }
                    this.size = value;
                }
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.SourceColumn"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(""),
        OdbcDescriptionAttribute(Res.DataParameter_SourceColumn)
        ]
        public String SourceColumn {
            get {
                return ((null != this.sourcecolumn) ? this.sourcecolumn : String.Empty);
            }
            set {
                this.sourcecolumn = value;
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.SourceVersion"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(DataRowVersion.Current),
        OdbcDescriptionAttribute(Res.DataParameter_SourceVersion)
        ]
        public DataRowVersion SourceVersion  {
            get {
                return this.sourceversion;
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case DataRowVersion.Original:
                case DataRowVersion.Current:
                case DataRowVersion.Proposed:
                case DataRowVersion.Default:
                    this.sourceversion = value;
                    break;
                default:
                    throw ADP.InvalidDataRowVersion(ParameterName, (int) value);
                }
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.Value"]/*' />
        [
        OdbcCategoryAttribute(Res.DataCategory_Data),
        DefaultValue(null),
        OdbcDescriptionAttribute(Res.DataParameter_Value),
        TypeConverterAttribute(typeof(StringConverter))
        ]
        public object Value {
            get {
                return _value;
            }
            set {
                if (this._parent != null) {
                    if (this._value != value) {
                        if (_userSpecifiedType == false) {
                            this._parent.BindingIsValid = false;
                        }
                        
                            // _buffersize == -1    // so we know it's variable length
                            // size == 0            // so we know that the user didn't spedify a size

                        if ((_parent.BindingIsValid) && (_typemap._bufferSize == -1) 
                            && ((size == 0) || (size >= 0x3fffffff))) {
                            _parent.BindingIsValid = false;
                        }
                    }
                }
                _value = value;                
            }
        }

        // return the count of bytes for the data, used to allocate the buffer length
        private int GetColumnSize(object value) {
            int cch = _bindtype._columnSize;
            if (0 >= cch) {
                if (ODBC32.SQL_C.NUMERIC == _typemap._sql_c) {
                    cch = 259; // _bindtype would be VarChar ([0-9]?{255} + '-' + '.') * 2
                }
                else {
                    cch = Size;
                    if ((cch <= 0) || (0x3fffffff <= cch)) {
                        Debug.Assert((ODBC32.SQL_C.WCHAR == _bindtype._sql_c) || (ODBC32.SQL_C.BINARY == _bindtype._sql_c), "not wchar or binary");
                        if ((cch <= 0) && (0 != (ParameterDirection.Output & direction))) {
                            throw ADP.UninitializedParameterSize(Parent.IndexOf(this), ParameterName, _bindtype._type, cch);
                        }
                        if ((null == value) || Convert.IsDBNull(value)) {
                            cch = 0;
                        }
                        else if (value is String) {
                            cch = ((String)value).Length;
                            
                            if ((0 != (ParameterDirection.Output & direction)) && (0x3fffffff <= Size)) {
                                // restrict output parameters when user set Size to Int32.MaxValue
                                // to the greater of intput size or 8K
                                cch = Math.Max(cch, 4 * 1024); // MDAC 69224
                            }

            
                            // the following code causes failure against SQL 6.5
                            // ERROR [HY104] [Microsoft][ODBC SQL Server Driver]Invalid precision value
                            //
                            // the code causes failure if it is NOT there (remark added by mithomas)
                            // it causes failure with jet if it is there
                            //
                            // MDAC 76227: Code is required for japanese client/server tests.
                            // If this causes regressions with Jet please doc here including bug#. (mithomas)
                            //
                            if ((ODBC32.SQL_TYPE.CHAR == _bindtype._sql_type)
                                || (ODBC32.SQL_TYPE.VARCHAR == _bindtype._sql_type)
                                || (ODBC32.SQL_TYPE.LONGVARCHAR == _bindtype._sql_type)) {
                                cch = System.Text.Encoding.Default.GetMaxByteCount(cch);
                            }
                            
                        }
                        else if (value is byte[]) {
                            cch = ((byte[])value).Length;
                            
                            if ((0 != (ParameterDirection.Output & direction)) && (0x3fffffff <= Size)) {
                                // restrict output parameters when user set Size to Int32.MaxValue
                                // to the greater of intput size or 8K
                                cch = Math.Max(cch, 8 * 1024); // MDAC 69224
                            }
                        }
#if DEBUG
                        else { Debug.Assert(false, "not expecting this"); }
#endif
                        // Note: ColumnSize should never be 0,
                        // this represents the size of the column on the backend.
                        //
                        // without the following code causes failure
                        //ERROR [HY104] [Microsoft][ODBC Microsoft Access Driver]Invalid precision value
                        cch = Math.Max(2, cch);
                    }
                }
            }
            Debug.Assert((0 <= cch) && (cch < 0x3fffffff), "GetColumnSize: out of range");
            return cch;
        }



        // Return the count of bytes for the data
        // 
        private int GetValueSize(object value) {
            int cch = _bindtype._columnSize;
            if (0 >= cch) {
                if (value is String) {
                    cch = ((string)value).Length;
                    if ((Size>0) && (Size<cch) && (_bindtype == _originalbindtype)) {
                        cch = Size;
                    }
                    cch *= 2;
                }
                else if (value is byte[]) {
                    cch = ((byte[])value).Length;
                    if ((Size>0) && (Size<cch) && (_bindtype == _originalbindtype)) {
                        cch = Size;
                    }
                }
                else {
                    cch = 0;
                }
            }
            Debug.Assert((0 <= cch) && (cch < 0x3fffffff), "GetValueSize: out of range");
            return cch;
        }

        // return the count of bytes for the data, used for SQLBindParameter
        private int GetParameterSize(object value) {
            int ccb = _bindtype._bufferSize;
            if (0 >= ccb) {
                if (ODBC32.SQL_C.NUMERIC == _typemap._sql_c) {
                    ccb = 518; // _bindtype would be VarChar ([0-9]?{255} + '-' + '.') * 2
                }
                else {
                    ccb = Size;
                    if ((ccb <= 0) || (0x3fffffff <= ccb)) {
                        Debug.Assert((ODBC32.SQL_C.WCHAR == _bindtype._sql_c) || (ODBC32.SQL_C.BINARY == _bindtype._sql_c), "not wchar or binary");
                        if ((ccb <= 0) && (0 != (ParameterDirection.Output & direction))) {
                            throw ADP.UninitializedParameterSize(Parent.IndexOf(this), ParameterName, _bindtype._type, ccb);
                        }
                        if ((null == value) || Convert.IsDBNull(value)) {
                            if (_bindtype._sql_c == ODBC32.SQL_C.WCHAR) {
                                ccb = 2; // allow for null termination
                            }
                            else {
                                ccb = 0;
                            }
                        }
                        else if (value is String) {
                            ccb = (((String)value).Length * 2) + 2;
                        }
                        else if (value is byte[]) {
                            ccb = ((byte[])value).Length;
                        }
#if DEBUG
                        else { Debug.Assert(false, "not expecting this"); }
#endif
                        if ((0 != (ParameterDirection.Output & direction)) && (0x3fffffff <= Size)) {
                            // restrict output parameters when user set Size to Int32.MaxValue
                            // to the greater of intput size or 8K
                            ccb = Math.Max(ccb, 8 * 1024); // MDAC 69224
                        }
                    }
                    else if (ODBC32.SQL_C.WCHAR == _bindtype._sql_c) {
                        if ((value is String) && (ccb < ((String)value).Length) && (_bindtype == _originalbindtype)) {
                            // silently truncate ... MDAC 84408 ... do not truncate upgraded values ... MDAC 84706
							// throw ADP.TruncatedString(ccb, ((String)value).Length, (String)value);
							ccb = ((String)value).Length;
                        }
                        ccb = (ccb * 2) + 2; // allow for null termination
                    }
                    else if ((value is byte[]) && (ccb < ((byte[])value).Length) && (_bindtype == _originalbindtype)) {
                        // silently truncate ... MDAC 84408 ... do not truncate upgraded values ... MDAC 84706
                        // throw ADP.TruncatedBytes(ccb);
                        ccb = ((byte[])value).Length;
                    }
                }
            }
            Debug.Assert((0 <= ccb) && (ccb < 0x3fffffff), "GetParameterSize: out of range " + ccb);
            return ccb;
         }

         private byte GetParameterPrecision(object value) {
// MDAC Bug 75999 - Why do we EVER want to use a precision that is different from that value's precision?
//
            if (value is Decimal) {
                return 28;
                // return (byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10);
            }
            if (0 != this.precision) {
                return this.precision;
            }
            if ((null == value) || (value is Decimal) || Convert.IsDBNull(value)) { // MDAC 60882
                return 28;
            }
            return 0;
        }


        private byte GetParameterScale(object value) {
            byte s = scale;
            if (value is decimal) {
                s = (byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10);
            }
            // If a value is provided, use its' scale. Otherwise use stored scale
            // 
            if (_userSpecifiedScale && (this.scale < s)) {
                if (!((0 == this.scale) && (0 == this.precision))) {
                    s = this.scale;
                }
            }
            return s;
        }

        // returns the value
        // if the user specified a type it will try to convert the value to the specified type
        // 
        // in addition this will set this._bindtype
        //
        private object GetParameterValue() {
            object value = Value;
            if (_userSpecifiedType) {
                if ((null != value) && !Convert.IsDBNull(value)) {
                    Type vt = value.GetType();
                    if (!vt.IsArray && (vt != _typemap._type)) {
                        value = Convert.ChangeType(value, _typemap._type);
                    }
                }
            }
            else if (null == _typemap) {
                if ((null == value) || Convert.IsDBNull(value)) {
                    _typemap = TypeMap._NVarChar; // default type
                }
                else {
                    _typemap = TypeMap.FromSystemType(value.GetType());
                }
            }
            Debug.Assert(null != _typemap, "GetParameterValue: null _typemap");
            _originalbindtype = _bindtype = _typemap;
            return value;
        }

        //This is required for OdbcCommand.Clone to deep copy the parameters collection
        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            OdbcParameter clone = new OdbcParameter();
            clone.parameterName = parameterName;
            clone.direction     = direction;
            clone._sqldirection = _sqldirection;
            clone._typemap = _typemap;
            clone._userSpecifiedType = _userSpecifiedType;
            clone._userSpecifiedScale = _userSpecifiedScale;

            clone.sourcecolumn = sourcecolumn;
            clone.sourceversion = sourceversion;
            clone.precision = precision;
            clone.scale = scale;
            clone.size = size;

            clone.Value = Value;
            if(Value is ICloneable)
                clone.Value = ((ICloneable)Value).Clone();

            clone.isNullable = isNullable;
            return clone;
        }

        internal void ClearBinding() {
            if (!_userSpecifiedType) {
                _typemap = null;
            }
            _bindtype = null;
        }

        internal void Bind(HandleRef hstmt, OdbcCommand parent, short ordinal, CNativeBuffer buffer, CNativeBuffer intbuffer) {
            ODBC32.RETCODE retcode;
            int cbActual;
            ODBC32.SQL_C sql_c_type;
            
            object value = GetParameterValue();

            switch(Direction) {
            case ParameterDirection.Input:
                Marshal.WriteInt32(intbuffer.Ptr, 0);
                break;
            case ParameterDirection.Output:
            case ParameterDirection.ReturnValue:
                Marshal.WriteInt32(intbuffer.Ptr, ODBC32.SQL_NULL_DATA);
                break;
            case ParameterDirection.InputOutput:
                Marshal.WriteInt32(intbuffer.Ptr, 0);
                break;
            default:
                throw ADP.InvalidParameterDirection((int) value, ParameterName);
            }

            // before we can do anything we need to verify if there is support
            // for certain data types
            //
            switch(_bindtype._sql_type) {
                case ODBC32.SQL_TYPE.DECIMAL:
                case ODBC32.SQL_TYPE.NUMERIC:
                    Debug.Assert((null == value) || Convert.IsDBNull(value) || (value is Decimal), "value not decimal");
                    if ((_parent.Connection.OdbcMajorVersion < 3) || 
                   !((OdbcParameterCollection)_parent).Connection.TestTypeSupport (ODBC32.SQL_TYPE.NUMERIC)) {
                        // No support for NUMERIC
                        // Change the type
                        _bindtype = TypeMap._VarChar;
                        if ((null != value) && !Convert.IsDBNull(value)) {
                            value = ((Decimal)value).ToString();
                        }
                    }
                    break;
                case ODBC32.SQL_TYPE.BIGINT:
                    Debug.Assert((null == value) || Convert.IsDBNull(value) || (value is Int64), "value not Int64");
                    if (_parent.Connection.OdbcMajorVersion < 3){
                        // No support for BIGINT
                        // Change the type
                        _bindtype = TypeMap._VarChar;
                        if ((null != value) && !Convert.IsDBNull(value)) {
                            value = ((Int64)value).ToString();
                        }
                    }
                    break;
                case ODBC32.SQL_TYPE.WCHAR: // MDAC 68993
                case ODBC32.SQL_TYPE.WVARCHAR:
                case ODBC32.SQL_TYPE.WLONGVARCHAR:
                    Debug.Assert((null == value) || Convert.IsDBNull(value) || (value is String), "value not string");
                    if (!((OdbcParameterCollection)_parent).Connection.TestTypeSupport (_bindtype._sql_type)) {
                        // No support for WCHAR, WVARCHAR or WLONGVARCHAR
                        // Change the type
                        if (ODBC32.SQL_TYPE.WCHAR == _bindtype._sql_type) { _bindtype = TypeMap._Char; }
                        else if (ODBC32.SQL_TYPE.WVARCHAR == _bindtype._sql_type) { _bindtype = TypeMap._VarChar; }
                        else if (ODBC32.SQL_TYPE.WLONGVARCHAR == _bindtype._sql_type) { _bindtype = TypeMap._Text; }
                    }
                    break;
            } // end switch

            // WARNING: this is very UGLY code but an internal compilererror forces me to do so
            // (MDAC BUG 72163)
            //

            // Conversation from WCHAR to CHAR, VARCHAR or LONVARCHAR (AnsiString) is different for some providers
            // we need to chonvert WCHAR to CHAR and bind as sql_c_type = CHAR
            //
            sql_c_type = (_parent.Connection.OdbcMajorVersion >= 3) ? _bindtype._sql_c : _bindtype._param_sql_c;

            if ((_parent.Connection.OdbcMajorVersion < 3) && (_bindtype._param_sql_c == ODBC32.SQL_C.CHAR)) {
                if ((value is String) && (null != value) && !Convert.IsDBNull(value)) {
                   int lcid = System.Globalization.CultureInfo.CurrentCulture.LCID;
                    CultureInfo culInfo = new CultureInfo(lcid); 
                    Encoding cpe = System.Text.Encoding.GetEncoding(culInfo.TextInfo.ANSICodePage);
                    value = cpe.GetBytes(value.ToString());
                }
            }

            int cbParameterSize = GetParameterSize(value);      // count of bytes for the data, for SQLBindParameter
            int cbValueSize  = GetValueSize(value);             // count of bytes for the data
            int cchSize = GetColumnSize(value);                 // count of bytes for the data, used to allocate the buffer length

            // here we upgrade the datatypes if the given values size is bigger than the types columnsize 
            //

            switch(_bindtype._sql_type) {
                case ODBC32.SQL_TYPE.VARBINARY: // MDAC 74372
                    // Note: per definition DbType.Binary does not support more than 8000 bytes so we change the type for binding
                    if ((cbParameterSize > 8000))
                        { _bindtype = TypeMap._Image; } // will change to LONGVARBINARY
                    break;
                case ODBC32.SQL_TYPE.VARCHAR: // MDAC 74372
                    // Note: per definition DbType.Binary does not support more than 8000 bytes so we change the type for binding
                    if ((cbParameterSize > 8000))
                        { _bindtype = TypeMap._Text; }  // will change to LONGVARCHAR
                    break;
                case ODBC32.SQL_TYPE.WVARCHAR : // MDAC 75099
                    // Note: per definition DbType.Binary does not support more than 8000 bytes so we change the type for binding
                    if ((cbParameterSize > 4000))
                        { _bindtype = TypeMap._NText; }  // will change to WLONGVARCHAR 
                    break;
            } // end switch
            
            //Allocate a our buffer to hold the input/output data
            //Note: cbValueSize is used in the SetInputValue to indicate how many bytes of variable
            //length data (which doesn't include the null terminator as spec'd), however our raw
            //buffer needs extra room for this
            buffer.EnsureAlloc(cbParameterSize);

            byte precision = GetParameterPrecision(value);
            byte scale = GetParameterScale(value);

            // for the numeric datatype we need to do some special case handling ...
            //
            if (ODBC32.SQL_C.NUMERIC == sql_c_type) {

                // for input/output parameters we need to adjust the scale of the input value since the convert function in
                // sqlsrv32 takes this scale for the output parameter (possible bug in sqlsrv32?)
                //
                if ((ODBC32.SQL_PARAM.INPUT_OUTPUT == _sqldirection) && (value is Decimal)) {
                    if (scale < this.scale) {
                        while (scale < this.scale) {
                            value = ((decimal)value ) * 10;
                            scale++;
                        }
                    }
                }
                SetInputValue(cbValueSize, value, precision, buffer, intbuffer);

                // for output parameters we need to write precision and scale to the buffer since the convert function in 
                // sqlsrv32 expects these values there (possible bug in sqlsrv32?)
                //
                if (ODBC32.SQL_PARAM.INPUT != _sqldirection) {
                    Marshal.WriteByte(buffer.Ptr,   0, (byte)precision);
                    Marshal.WriteByte(buffer.Ptr,   1, (byte)scale);
                }
            }
            else {
                SetInputValue(cbValueSize, value, precision, buffer, intbuffer);
            }

            
            // Try to reuse existing bindings
            //

            if (_parent.BindingIsValid && _parent.CollectionIsBound) {
                return;
            }

            //SQLBindParameter
            retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLBindParameter(
                                    hstmt,                      // StatementHandle
                                    ordinal,                    // Parameter Number
                                    (short)this._sqldirection,  // InputOutputType
                                    (short)sql_c_type,          // ValueType
                                    (short)_bindtype._sql_type, // ParameterType
                                    (IntPtr)cchSize,            // ColumnSize
                                    (IntPtr)scale,              // DecimalDigits
                                    buffer,                     // ParameterValuePtr
                                    (IntPtr)buffer.Length,      // BufferLength
                                    intbuffer.Ptr);             // StrLen_or_IndPtr

            if (ODBC32.RETCODE.SUCCESS != retcode) {
                ((OdbcParameterCollection)_parent).Connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
            }

            if (ODBC32.SQL_C.NUMERIC == sql_c_type)
            {
                HandleRef hdesc = parent.GetDescriptorHandle();

                // Set descriptor Type
                //
                //SQLSetDescField(hdesc, i+1, SQL_DESC_TYPE, (void *)SQL_C_NUMERIC, 0);
                retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLSetDescFieldW(
                                hdesc, 
                                ordinal,
                                (short) ODBC32.SQL_DESC.TYPE,
                                new HandleRef (null, (IntPtr) ODBC32.SQL_C.NUMERIC),
                                0);
                if (ODBC32.RETCODE.SUCCESS != retcode)
                {
                    ((OdbcParameterCollection)_parent).Connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
                }


                // Set precision
                //
                cbActual= (int)precision;
                //SQLSetDescField(hdesc, i+1, SQL_DESC_PRECISION, (void *)precision, 0);
                retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLSetDescFieldW(
                                hdesc, 
                                ordinal,
                                (short) ODBC32.SQL_DESC.PRECISION,
                                new HandleRef (this, (IntPtr) cbActual),
                                0);
                if (ODBC32.RETCODE.SUCCESS != retcode)
                {
                    ((OdbcParameterCollection)_parent).Connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
                }


                // Set scale
                //
                // SQLSetDescField(hdesc, i+1, SQL_DESC_SCALE,  (void *)llen, 0);
                cbActual= (int)scale;
                retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLSetDescFieldW(
                                hdesc, ordinal,
                                (short) ODBC32.SQL_DESC.SCALE,
                                new HandleRef (this, (IntPtr) cbActual),
                                0);
                if (ODBC32.RETCODE.SUCCESS != retcode)
                {
                    ((OdbcParameterCollection)_parent).Connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
                }

                // Set data pointer
                //
                // SQLSetDescField(hdesc, i+1, SQL_DESC_DATA_PTR,  (void *)&numeric, 0);
                retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLSetDescFieldW(
                                hdesc, ordinal,
                                (short) ODBC32.SQL_DESC.DATA_PTR,
                                buffer,
                                0);
                if (ODBC32.RETCODE.SUCCESS != retcode)
                {
                    ((OdbcParameterCollection)_parent).Connection.HandleError(hstmt, ODBC32.SQL_HANDLE.STMT, retcode);
                }
                // Don't free handle descriptors. They are not allocated.
                // retcode =  (ODBC32.RETCODE) UnsafeNativeMethods.Odbc32.SQLFreeHandle( (short)ODBC32.SQL_HANDLE.DESC, hdesc);
            }
        }

        internal void GetOutputValue(IntPtr stmt, CNativeBuffer buffer, CNativeBuffer intbuffer) { //Handle any output params
            if ((null != _bindtype) && (ODBC32.SQL_PARAM.INPUT != _sqldirection)) {

               TypeMap typemap = _bindtype;
                _bindtype = null;

                ODBC32.SQL_C sql_c_type;
                sql_c_type = (_parent.Connection.OdbcMajorVersion >= 3) ? typemap._sql_c : typemap._param_sql_c;

                int cbActual = Marshal.ReadInt32(intbuffer.Ptr);
                if (ODBC32.SQL_NULL_DATA == cbActual) {
                    Value = DBNull.Value;
                }
                else if ((0 <= cbActual)  || (cbActual == ODBC32.SQL_NTS)){ // safeguard
                    Value = buffer.MarshalToManaged(sql_c_type, cbActual);

                if (sql_c_type == ODBC32.SQL_C.CHAR) {
                    if ((null != Value) && !Convert.IsDBNull(Value)) {
                        int lcid = System.Globalization.CultureInfo.CurrentCulture.LCID;
                        CultureInfo culInfo = new CultureInfo(lcid); 
                        Encoding cpe = System.Text.Encoding.GetEncoding(culInfo.TextInfo.ANSICodePage);
                        Value = cpe.GetString((Byte[])Value);
                    }
                }
                 
                    if ((typemap != _typemap) && (null != Value) && !Convert.IsDBNull(Value) && (Value.GetType() != _typemap._type)) {
                        Debug.Assert(ODBC32.SQL_C.NUMERIC == _typemap._sql_c, "unexpected");
                        Value = Decimal.Parse((string)Value, System.Globalization.CultureInfo.CurrentCulture);
                    }
                }
#if DEBUG
                if (AdapterSwitches.DataValue.TraceVerbose) {
                    Debug.WriteLine("Odbc OutputParam:" + _typemap._odbcType.ToString("G") + " " + typemap._odbcType.ToString("G") + " " + ADP.ValueToString(Value));
                }
#endif
            }
        }

        internal void OnSchemaChanging() {
            if (null != _parent) {
                _parent.OnSchemaChanging();
            }
        }

        internal void SetInputValue(int size, object value, byte precision, CNativeBuffer buffer, CNativeBuffer intbuffer) { //Handle any input params
#if DEBUG
            if (AdapterSwitches.DataValue.TraceVerbose) {
                Debug.WriteLine("SQLBindParameter:" + _typemap._odbcType.ToString("G") + " " + _bindtype._odbcType.ToString("G") +"("+size+")=" + ADP.ValueToString(value));
            }
#endif
            if((ODBC32.SQL_PARAM.INPUT ==_sqldirection) || (ODBC32.SQL_PARAM.INPUT_OUTPUT == _sqldirection)) {
                ODBC32.SQL_C sql_c_type;
                sql_c_type = (_parent.Connection.OdbcMajorVersion >= 3) ? _bindtype._sql_c : _bindtype._param_sql_c;
                                
                //Note: (lang) "null" means to use the servers default (not DBNull).
                //We probably should just not have bound this parameter, period, but that
                //would mess up the users question marks, etc...
                if((null == value)) {
                    Marshal.WriteInt32(intbuffer.Ptr, ODBC32.SQL_DEFAULT_PARAM);
                }
                else if(Convert.IsDBNull(value)) {
                    Marshal.WriteInt32(intbuffer.Ptr, ODBC32.SQL_NULL_DATA);
                }
                else {
                    // Clear previous NULL_DATA status
                    Marshal.WriteInt32(intbuffer.Ptr, 0);
                    switch(sql_c_type) {
                    case ODBC32.SQL_C.CHAR:
                    case ODBC32.SQL_C.WCHAR:
                    case ODBC32.SQL_C.BINARY:
                        //StrLen_or_IndPtr is ignored except for Character or Binary or data.
                        Marshal.WriteInt32(intbuffer.Ptr, size);
                        break;
                    }

                    //Place the input param value into the native buffer
                    buffer.MarshalToNative(value, sql_c_type, precision);
                }
            }
            else {
                // always set ouput only and return value parameter values to null when executing
                Value = null;

                //Always initialize the intbuffer (for output params).  Since we need to know
                //if/when the parameters are available for output. (ie: when is the buffer valid...)
                //if (_sqldirection != ODBC32.SQL_PARAM.INPUT)
                Marshal.WriteInt32(intbuffer.Ptr, ODBC32.SQL_NULL_DATA);
            }
        }

        /// <include file='doc\OdbcParameter.uex' path='docs/doc[@for="OdbcParameter.ToString"]/*' />
        override public string ToString() {
            return ParameterName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcparametercollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcParameterCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Odbc {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;

    /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection"]/*' />
    [
    Editor("Microsoft.VSDesigner.Data.Design.DBParametersEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
    ListBindable(false),
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcParameterCollection : MarshalByRefObject, IDataParameterCollection {
        private OdbcCommand parent;
        private ArrayList items; // delay creation until AddWithoutEvents, Insert, CopyTo, GetEnumerator
        private bool _collectionIsBound;          // The parameter collection has been sucessfuly bound
        private bool _bindingIsValid;   // The collection is bound and the bindings are valid
        
        internal bool CollectionIsBound {
            get { return _collectionIsBound; }
            set { _collectionIsBound = value; }
        }
        internal bool BindingIsValid {
            get { return _bindingIsValid; }
            set { _bindingIsValid = value; }
        }

        internal OdbcParameterCollection(OdbcCommand parent) {
            this.parent = parent;
        }

        // explicit ICollection implementation
        bool System.Collections.ICollection.IsSynchronized {
            get { return false;}
        }
        object System.Collections.ICollection.SyncRoot {
            get { return this;}
        }

        // explicit IList implementation
        bool System.Collections.IList.IsReadOnly {
            get { return false;}
        }
        bool System.Collections.IList.IsFixedSize {
            get { return false;}
        }
        object System.Collections.IList.this[int index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (OdbcParameter) value;
            }
        }

        // explicit IDataParameterCollection implementation
        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.IDataParameterCollection.this"]/*' />
        /// <internalonly/>
        object IDataParameterCollection.this[string index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (OdbcParameter) value;
            }
        }

        internal OdbcConnection Connection {
            get {
                return this.parent.Connection;
            }
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Count"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Count {
            get {
                return ((null != items) ? items.Count : 0);
            }
        }

        private Type ItemType {
            get { return typeof(OdbcParameter); }
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.this"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public OdbcParameter this[int index] {
            get {
                RangeCheck(index);
                return(OdbcParameter) items[index];
            }
            set {
                OnSchemaChanging();  // fire event before value is validated
                RangeCheck(index);
                Replace(index, value);
            }
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.this1"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public OdbcParameter this[string parameterName] {
            get {
                int index = RangeCheck(parameterName);
                return(OdbcParameter) items[index];
            }
            set {
                OnSchemaChanging();  // fire event before value is validated
                int index = RangeCheck(parameterName);
                Replace(index, value);
            }
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Add"]/*' />
        public int Add(object value) {
            ValidateType(value);
            Add((OdbcParameter) value);
            return Count-1; // appended index
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Add1"]/*' />
        public OdbcParameter Add(OdbcParameter value) { // MDAC 59206
            OnSchemaChanging();  // fire event before value is validated
            AddWithoutEvents(value);
            //OnSchemaChanged();
            return value;
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Add5"]/*' />
        public OdbcParameter Add(string parameterName, object value) { // MDAC 59206
            return Add(new OdbcParameter(parameterName, value));
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Add2"]/*' />
        public OdbcParameter Add(string parameterName, OdbcType odbcType) {
            return Add(new OdbcParameter(parameterName, odbcType));
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Add3"]/*' />
        public OdbcParameter Add(string parameterName, OdbcType odbcType, int size) {
            return Add(new OdbcParameter(parameterName, odbcType, size));
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Add4"]/*' />
        public OdbcParameter Add(string parameterName, OdbcType odbcType, int size, string sourceColumn) {
            return Add(new OdbcParameter(parameterName, odbcType, size, sourceColumn));
        }

        /*public void AddRange(SqlParameter[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            int length = values.Length;
            for (int i = 0; i < length; ++i) {
                ValidateType(values[i]);
            }
            for (int i = 0; i < length; ++i) {
                AddWithoutEvents(values[i]);
            }
        }*/

        private void AddWithoutEvents(OdbcParameter value) { // also called by OdbcCommand.ResetParameters
            Validate(-1, value);
            value.Parent = this;
            ArrayList().Add(value);
            BindingIsValid = false;
        }

        // implemented as a method, not as a property because the VS7 debugger 
        // object browser calls properties to display their value, and we want this delayed
        private ArrayList ArrayList() {
            if (null == this.items) {
                this.items = new ArrayList();
            }
            return this.items;
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Contains"]/*' />
        public bool Contains(string value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Contains1"]/*' />
        public bool Contains(object value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Clear"]/*' />
        public void Clear() {
            if (0 < Count) {
                OnSchemaChanging();  // fire event before value is validated
                ClearWithoutEvents();
                //OnSchemaChanged();
            }
        }

        private void ClearWithoutEvents() {
            if (null != items) {
                int count = items.Count;
                for(int i = 0; i < count; ++i) {
                    ((OdbcParameter) items[i]).Parent = null;
                }
                items.Clear();
                BindingIsValid = false;
            }
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            ArrayList().CopyTo(array, index);
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return ArrayList().GetEnumerator();
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.IndexOf"]/*' />
        public int IndexOf(string parameterName) {
            if (null != items) {
                int count = items.Count;
                for (int i = 0; i < count; ++i) {
                    if (0 == ADP.DstCompare(parameterName, ((OdbcParameter) items[i]).ParameterName)) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.IndexOf1"]/*' />
        public int IndexOf(object value) {
            if (null != value) {
                ValidateType(value);
                if (null != items) {
                    int count = items.Count;
                    for (int i = 0; i < count; ++i) {
                        if (value == items[i]) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Insert"]/*' />
        public void Insert(int index, Object value) {
            OnSchemaChanging();  // fire event before value is validated
            ValidateType(value);
            Validate(-1, (OdbcParameter) value);
            ((OdbcParameter) value).Parent = this;
            ArrayList().Insert(index, value);
            BindingIsValid = false;
            //OnSchemaChanged();
        }

        //internal void OnSchemaChanged() { // commented out because OdbcCommand does nothing
        //    if (null != this.parent) {
        //        this.parent.OnSchemaChangedInternal(this);
        //    }
        //}


        internal void OnSchemaChanging() { // also called by OdbcParameter.OnSchemaChanging
            if (null != this.parent) {
                this.parent.OnSchemaChanging();
            }
        }

        private void RangeCheck(int index) {
            if ((index < 0) || (Count <= index)) {
                throw ADP.ParametersMappingIndex(index, this);
            }
        }

        private int RangeCheck(string parameterName) {
            int index = IndexOf(parameterName);
            if (index < 0) {
                throw ADP.ParametersSourceIndex(parameterName, this, typeof(OdbcParameter));
            }
            return index;
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.RemoveAt"]/*' />
        public void RemoveAt(int index) {
            OnSchemaChanging(); // fire event before value is validated
            RangeCheck(index);
            RemoveIndex(index);
        }

        private void RemoveIndex(int index) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            ((OdbcParameter) items[index]).Parent = null;
            items.RemoveAt(index);
            BindingIsValid = false;
            //OnSchemaChanged();
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.RemoveAt1"]/*' />
        public void RemoveAt(string parameterName) {
            OnSchemaChanging(); // fire event before value is validated
            int index = RangeCheck(parameterName);
            RemoveIndex(index);
        }

        /// <include file='doc\OdbcParameterCollection.uex' path='docs/doc[@for="OdbcParameterCollection.Remove"]/*' />
        public void Remove(object value) {
            OnSchemaChanging(); // fire event before value is validated
            ValidateType(value);
            int index = IndexOf((OdbcParameter) value);
            if (-1 != index) {
                RemoveIndex(index);
            }
            else {
                throw ADP.CollectionRemoveInvalidObject(ItemType, this);
            }
        }

        private void Replace(int index, OdbcParameter newValue) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");            
            Validate(index, newValue);
            ((OdbcParameter) items[index]).Parent = null;
            newValue.Parent = this;
            items[index] = newValue;
            BindingIsValid = false;
            //OnSchemaChanged();
        }

        private void ValidateType(object value) {
            if (null == value) {
                throw ADP.ParameterNull("value", this, ItemType);
            }
            else if (!ItemType.IsInstanceOfType(value)) {
                throw ADP.InvalidParameterType(this, ItemType, value);
            }
        }

        private void Validate(int index, OdbcParameter value) {
            if (null == value) {
                throw ADP.ParameterNull("value", this, ItemType);
            }
            if (null != value.Parent) {
                if (this != value.Parent) {
                    throw ADP.ParametersIsNotParent(typeof(OdbcParameter), value.ParameterName, this);
                }
                else if (index != IndexOf(value)) {
                    throw ADP.ParametersIsParent(typeof(OdbcParameter), value.ParameterName, this);
                }
            }
            String name = value.ParameterName;
            if (ADP.IsEmpty(name)) { // generate a ParameterName
                index = 1;
                do {
                    name = ADP.Parameter + index.ToString();
                    index++;
                } while (-1 != IndexOf(name));
                value.ParameterName = name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcerrorcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcErrorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Odbc {

    using System;
    using System.Collections;
    using System.Data;

    /// <include file='doc\OdbcErrorCollection.uex' path='docs/doc[@for="OdbcErrorCollection"]/*' />
    [Serializable]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcErrorCollection : ICollection {
        private ArrayList _items = new ArrayList();

        internal OdbcErrorCollection() {
        }

        Object System.Collections.ICollection.SyncRoot {
            get { return this; }
        }

        bool System.Collections.ICollection.IsSynchronized {
            get { return false; }
        }

        /// <include file='doc\OdbcErrorCollection.uex' path='docs/doc[@for="OdbcErrorCollection.Count"]/*' />
        public int Count {
            get {
                return _items.Count;
            }
        }

        /// <include file='doc\OdbcErrorCollection.uex' path='docs/doc[@for="OdbcErrorCollection.this"]/*' />
        public OdbcError this[int i] {
            get {
                return (OdbcError)_items[i];
            }
        }

        internal void Add(OdbcError error) {
            _items.Add(error);
        }

        /// <include file='doc\OdbcErrorCollection.uex' path='docs/doc[@for="OdbcErrorCollection.CopyTo"]/*' />
        public void CopyTo (Array array, int i) {
            _items.CopyTo(array, i);
        }

        /// <include file='doc\OdbcErrorCollection.uex' path='docs/doc[@for="OdbcErrorCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return _items.GetEnumerator();
        }

        internal void SetSource (string Source) {
            foreach (object error in _items) {
                ((OdbcError)error).SetSource(Source);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcconnectionstring.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcConnectionString.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.Odbc {

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Security;
    using System.Security.Permissions;

    sealed internal class OdbcConnectionString : DBConnectionString {

        static private Hashtable _odbcParseCache;

        private readonly PermissionSet _permission;

        static internal OdbcConnectionString ParseString(string connectionString) {
            OdbcConnectionString constr = null;
            if (!ADP.IsEmpty(connectionString)) {

                constr = (DBConnectionString.CacheQuery(connectionString, _odbcParseCache) as OdbcConnectionString);
                if (null == constr) {
#if USECRYPTO
                    string encrypted = null/*Crypto.EncryptString(connectionString)*/;
                    string hashvalue = (null == encrypted) ? Crypto.ComputeHash(connectionString) : encrypted;
                    constr = (DBConnectionString.CacheQuery(hashvalue, _odbcParseCache) as OdbcConnectionString);
                    if (null == constr) {
                        constr = new OdbcConnectionString(connectionString, encrypted);
#else
                        constr = new OdbcConnectionString(connectionString);
#endif
                         if (constr.ShouldCache()) {
#if USECRYPTO
                            if (!constr.IsEncrypted) {
                                hashvalue = connectionString;
                            }
                            CacheAdd(hashvalue, constr, ref _odbcParseCache);
#else
                            CacheAdd(connectionString, constr, ref _odbcParseCache);
#endif
                         }
#if USECRYPTO
                    }
#endif
                }
            }
            return constr;
        }

#if USECRYPTO
        private OdbcConnectionString(string connectionString, string encrypted) : base(connectionString, encrypted, UdlSupport.ThrowIfFound) {
#else
        private OdbcConnectionString(string connectionString) : base(connectionString, UdlSupport.ThrowIfFound) {
#endif
            _permission = OdbcConnectionString.CreatePermission(this);
        }

        internal OdbcConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior) : base(connectionString, restrictions, behavior, UdlSupport.ThrowIfFound) {
        }

        static internal PermissionSet CreatePermission(OdbcConnectionString constr) {
            OdbcPermission p = new OdbcPermission(constr);
            if (null == constr) {
                p.Add("", "", KeyRestrictionBehavior.AllowOnly); // ExecuteOnly permission
            }
            PermissionSet permission;
            NamedPermissionSet fulltrust = new NamedPermissionSet("FullTrust"); // MDAC 83159
            fulltrust.Assert();
            try {
                permission = new PermissionSet(fulltrust);
                permission.AddPermission(p);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return permission;
        }

        static internal void Demand(OdbcConnectionString constr) {
            PermissionSet permission = ((null != constr) ? constr._permission : OdbcConnection.OdbcPermission);
            permission.Demand();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcparameterconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcParameterConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.Odbc {

    using System;
    using System.Data;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Data.Common;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\OdbcParameterConverter.uex' path='docs/doc[@for="OdbcParameterConverter"]/*' />
    /// <internalonly/>
    sealed internal class OdbcParameterConverter : ExpandableObjectConverter {

        /// <include file='doc\OdbcParameterConverter.uex' path='docs/doc[@for="OdbcParameterConverter.CanConvertTo"]/*' />
        /// <internalonly/>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\OdbcParameterConverter.uex' path='docs/doc[@for="OdbcParameterConverter.ConvertTo"]/*' />
        /// <internalonly/>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw ADP.ArgumentNull("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is OdbcParameter) {
                OdbcParameter p = (OdbcParameter)value;

                // MDAC 67321 - reducing parameter generated code
                int flags = 0; // if part of the collection - the parametername can't be empty

                if (OdbcType.NChar != p.OdbcType) {
                    flags |= 1;
                }
                if (0 != p.Size) {
                    flags |= 2;
                }
                if (!ADP.IsEmpty(p.SourceColumn)) {
                    flags |= 4;
                }
                if (null != p.Value) {
                    flags |= 8;
                }
                if ((ParameterDirection.Input != p.Direction) || p.IsNullable
                    || (0 != p.Precision) || (0 != p.Scale) || (DataRowVersion.Current != p.SourceVersion)) {
                    flags |= 16;
                }

                Type[] ctorParams;
                object[] ctorValues;
                switch(flags) {
                case  0: // ParameterName
                case  1: // SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(OdbcType) };
                    ctorValues = new object[] { p.ParameterName, p.OdbcType };
                    break;
                case  2: // Size
                case  3: // Size, SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(OdbcType), typeof(int) };
                    ctorValues = new object[] { p.ParameterName, p.OdbcType, p.Size };
                    break;
                case  4: // SourceColumn
                case  5: // SourceColumn, SqlDbType
                case  6: // SourceColumn, Size
                case  7: // SourceColumn, Size, SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(OdbcType), typeof(int), typeof(string) };
                    ctorValues = new object[] { p.ParameterName, p.OdbcType, p.Size, p.SourceColumn };
                    break;
                case  8: // Value
                    ctorParams = new Type[] { typeof(string), typeof(object) };
                    ctorValues = new object[] { p.ParameterName, p.Value };
                    break;
                default:
                    ctorParams = new Type[] {
                        typeof(string), typeof(OdbcType), typeof(int), typeof(ParameterDirection),
                        typeof(bool), typeof(byte), typeof(byte), typeof(string), 
                        typeof(DataRowVersion), typeof(object) };
                    ctorValues = new object[] {
                        p.ParameterName, p.OdbcType,  p.Size, p.Direction,
                        p.IsNullable, p.Precision, p.Scale, p.SourceColumn,
                        p.SourceVersion, p.Value };
                    break;
                }
                ConstructorInfo ctor = typeof(OdbcParameter).GetConstructor(ctorParams);
                if (null != ctor) {
                    return new InstanceDescriptor(ctor, ctorValues);
                }
            }            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcinfomessageevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcInfoMessageEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Text;

namespace System.Data.Odbc {

    /// <include file='doc\OdbcInfoMessageEvent.uex' path='docs/doc[@for="OdbcInfoMessageEventHandler"]/*' />
    public delegate void OdbcInfoMessageEventHandler(object sender, OdbcInfoMessageEventArgs e);

   
    /// <include file='doc\OdbcInfoMessageEvent.uex' path='docs/doc[@for="OdbcInfoMessageEventArgs"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcInfoMessageEventArgs : System.EventArgs {
        private OdbcErrorCollection _errors;

        internal OdbcInfoMessageEventArgs(OdbcErrorCollection errors) {
            _errors = errors;
        }

        /// <include file='doc\OdbcInfoMessageEvent.uex' path='docs/doc[@for="OdbcInfoMessageEventArgs.Errors"]/*' />
        public OdbcErrorCollection Errors {
            get { return _errors; }
        }

        /// <include file='doc\OdbcInfoMessageEvent.uex' path='docs/doc[@for="OdbcInfoMessageEventArgs.Message"]/*' />
        public string Message { // MDAC 84407
            get {
                StringBuilder builder = new StringBuilder();
                foreach(OdbcError error in Errors) {
                    if (0 < builder.Length) { builder.Append("\r\n"); }
                    builder.Append(error.Message);
                }
                return builder.ToString();
            }
        }

        /// <include file='doc\OdbcInfoMessageEvent.uex' path='docs/doc[@for="OdbcInfoMessageEventArgs.ToString"]/*' />
        public override string ToString() { // MDAC 84407
            return Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\dbbindings.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBBindings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Data;
    using System.Data.Common;
    using System.Runtime.InteropServices;
    using System.Text;

    /// <include file='doc\DBBindings.uex' path='docs/doc[@for="DBBindings"]/*' />
    sealed internal class DBBindings {
        private OleDbDataReader parent;
        private int bindingIndex;

        // reference to the OleDbParameterCollection to guard against when
        // OleDbCommand.Dispose had been called while the OleDbDataReader
        // owned the parameter bindings
        internal object collection;

        private int index;
        private int count;
        private int dataBufferSize;

        private UnsafeNativeMethods.tagDBBINDING[] dbbindings;
        private UnsafeNativeMethods.tagDBCOLUMNACCESS[] dbcolumns;

        private IntPtr dataHandle;
        private IntPtr[] valuePtrs;
        private DBBindingCleanup[] memoryHandler; // MDAC 67412

        private int[]  decimalBuffer;
        private short[] timeBuffer;

        private bool ifIRowsetElseIRow;

        internal DBBindings(OleDbDataReader parent, int bindingIndex, int count, bool ifIRowsetElseIRow) {
            this.parent = parent;
            this.bindingIndex = bindingIndex;

            this.count = count;
            this.dbbindings = new UnsafeNativeMethods.tagDBBINDING[count];
            this.dbcolumns = new UnsafeNativeMethods.tagDBCOLUMNACCESS[count];

            // arrange the databuffer to have
            // all DBSTATUS values (32bit per value)
            // all DBLENGTH values (32/64bit per value)
            // all data values listed after that (variable length)
            int statusOffset = 0;
            int lengthOffset = AlignDataSize(count * IntPtr.Size);
            for (int i = 0; i < count; ++i, lengthOffset += IntPtr.Size, statusOffset += /*sizeof(Int32)*/4) {
                this.dbbindings[i].obLength = new IntPtr(lengthOffset);
                this.dbbindings[i].obStatus = new IntPtr(statusOffset);
                this.dbcolumns[i].cbDataLen = IntPtr.Zero;
                this.dbcolumns[i].dwStatus = 0;
                this.dbcolumns[i].dwReserved = IntPtr.Zero;
            }
            this.dataBufferSize = AlignDataSize(lengthOffset);
            this.ifIRowsetElseIRow = ifIRowsetElseIRow;
        }

        ~DBBindings() {
            Dispose(false);
        }

        internal void Dispose() {
            Dispose(true);
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        // <fxcop ignore="MethodsInTypesWithIntPtrFieldAndFinalizeMethodRequireGCKeepAlive"/>
        private void Dispose(bool disposing) {
            // we have to touch the memory handler managed objects during finalization
            // otherwise their memory can't be reliably freed before the array is released
            if (null != memoryHandler) {
                for (int i = 0; i < count; ++i) {
                    if (null != memoryHandler[i]) {
                        memoryHandler[i].Dispose();
                    }
                }
                this.memoryHandler = null;
            }
            if (disposing) {
                this.parent = null;
                this.dbbindings = null;
                this.valuePtrs = null;
#if DEBUG
                ODB.TraceData_Free(this.dataHandle, "DBBindings");
#endif
            }
            if (IntPtr.Zero != this.dataHandle) {
                Marshal.FreeCoTaskMem(this.dataHandle);
                this.dataHandle = IntPtr.Zero;
            }
        }

        internal UnsafeNativeMethods.tagDBBINDING[] DBBinding {
            get {
                return this.dbbindings;
            }
        }

        internal UnsafeNativeMethods.tagDBCOLUMNACCESS[] DBColumnAccess {
            get {
                return this.dbcolumns;
            }
        }

        public static implicit operator HandleRef(DBBindings x) {
            Debug.Assert(IntPtr.Zero != x.dataHandle, "null DataBuffer");
            return new HandleRef(x, x.dataHandle);
        }

        internal IntPtr DataHandle {
            get {
                Debug.Assert(IntPtr.Zero != this.dataHandle, "null DataBuffer");
                return this.dataHandle;
            }
        }

        internal int Count {
            get {
                return this.count;
            }
        }
        internal int CurrentIndex {
            set {
                Debug.Assert(0 <= value &&  value < count, "bad binding index");
                index = value;
            }
        }
        internal int DataBufferSize {
            get {
                return this.dataBufferSize;
            }
        }
        internal void AllocData() {
            Debug.Assert(IntPtr.Zero == dataHandle, "memory already allocated");
            Debug.Assert(0 < dataBufferSize, "no memory to allocate");

            try {
                dataHandle = Marshal.AllocCoTaskMem(dataBufferSize);
                SafeNativeMethods.ZeroMemory(dataHandle, dataBufferSize);
            }
            catch(Exception e) {
                Marshal.FreeCoTaskMem(dataHandle); // FreeCoTaskMem protects itself from IntPtr.Zero
                dataHandle = IntPtr.Zero;
                throw e;
            }
#if DEBUG
            ODB.TraceData_Alloc(dataHandle, "DBBindings");
#endif
            this.valuePtrs = new IntPtr[count];

            if (4 == IntPtr.Size) {
                int ptr = dataHandle.ToInt32();
                for (int i = 0; i < count; ++i) {
                    this.valuePtrs[i] = new IntPtr(ptr + this.dbbindings[i].obValue.ToInt32());
                    this.dbcolumns[i].pData = this.valuePtrs[i];
                    if ((null != this.memoryHandler) && (null != this.memoryHandler[i])) {
                        this.memoryHandler[i].dataPtr = this.valuePtrs[i];
                    }
                }
            }
            else {
                Debug.Assert(8 == IntPtr.Size, "8 != IntPtr.Size"); // MDAC 73747
                long ptr = dataHandle.ToInt64();
                for (int i = 0; i < count; ++i) {
                    this.valuePtrs[i] = new IntPtr(ptr + this.dbbindings[i].obValue.ToInt64());
                    this.dbcolumns[i].pData = this.valuePtrs[i];
                    if ((null != this.memoryHandler) && (null != this.memoryHandler[i])) {
                        this.memoryHandler[i].dataPtr = this.valuePtrs[i];
                    }
                }
            }
            GC.KeepAlive(this);
        }

        // tagDBBINDING member access
        //
        internal int Ordinal { // iOrdinal
            get {
                return this.dbbindings[this.index].iOrdinal.ToInt32();
            }
            set {
                this.dbbindings[this.index].iOrdinal = new IntPtr(value);
            }
        }
#if DEBUG
        internal int ValueOffset { // obValue
            get {
                return this.dbbindings[this.index].obValue.ToInt32();
            }
        }
#endif
        internal int LengthOffset { // obLength
            get {
                return this.dbbindings[this.index].obLength.ToInt32();
            }
        }
        internal int StatusOffset { // obStatus
            get {
                return this.dbbindings[this.index].obStatus.ToInt32();
            }
        }
        internal int Part { // dwPart
#if DEBUG
            /*get {
                return this.dbbindings[this.index].dwPart;
            }*/
#endif
            set {
                this.dbbindings[this.index].dwPart = value;
            }
        }
        internal int ParamIO { // eParamIO
#if DEBUG
            /*get {
                return this.dbbindings[this.index].eParamIO;
            }*/
#endif
            set {
                this.dbbindings[this.index].eParamIO = value;
            }
        }
        internal int MaxLen { // cbMaxLen
            get {
                return (int) this.dbbindings[this.index].cbMaxLen;
            }
            set { // <fxcop ignore="MethodsInTypesWithIntPtrFieldAndFinalizeMethodRequireGCKeepAlive"/>
                Debug.Assert(0 <= value, "DBBindings: bad DataBufferSize");
                Debug.Assert(IntPtr.Zero == dataHandle, "DBBindings: dataBuffer already initialized");

                this.dbbindings[this.index].obValue = new IntPtr(this.dataBufferSize);

                this.dataBufferSize += AlignDataSize(value);

                IntPtr maxlen = new IntPtr(value);
                this.dbbindings[this.index].cbMaxLen = maxlen;
                this.dbcolumns[this.index].cbMaxLen = maxlen;
            }
        }
        internal int DbType { // wType
            get {
                return this.dbbindings[this.index].wType;
            }
            set {
                switch (value) {
                    case NativeDBType.DBDATE:
                    case NativeDBType.DBTIME:
                    case NativeDBType.DBTIMESTAMP:
                        if (null == this.timeBuffer) {
                            this.timeBuffer = new short[6];
                        }
                        break;
                    case NativeDBType.DECIMAL:
                    case NativeDBType.NUMERIC:
                        if (null == this.decimalBuffer) {
                            this.decimalBuffer = new int[4];
                        }
                        break;
                    case (NativeDBType.BYREF | NativeDBType.BYTES):
                    case (NativeDBType.BYREF | NativeDBType.WSTR):
                        if (null == this.memoryHandler) {
                            this.memoryHandler = new DBBindingCleanup[this.count];
                        }
                        this.memoryHandler[this.index] = new DBBindingCoTaskMem();
                        break;
                    case NativeDBType.VARIANT:
                        if (null == this.memoryHandler) {
                            this.memoryHandler = new DBBindingCleanup[this.count];
                        }
                        this.memoryHandler[this.index] = new DBBindingVARIANT();
                        break;
                    case NativeDBType.BSTR:
                        if (null == this.memoryHandler) {
                            this.memoryHandler = new DBBindingCleanup[this.count];
                        }
                        this.memoryHandler[this.index] = new DBBindingBSTR();
                        break;
#if DEBUG
                    case NativeDBType.STR:
                        Debug.Assert(false, "should have bound as WSTR");
                        break;
                    case (NativeDBType.BYREF | NativeDBType.STR):
                        Debug.Assert(false, "should have bound as BYREF|WSTR");
                        break;
#endif
                    default:
                        if (NativeDBType.IsByRef(value)) { // MDAC 83308
                            Debug.Assert(!NativeDBType.IsByRef(value), "BYREF should requires explict cleanup");
                            throw ODB.GVtUnknown(value);
                        }
                        break;
                }
                this.dbbindings[this.index].wType = (short) value;
                this.dbcolumns[this.index].wType = (short) value;
            }
        }
        internal byte Precision { // bPrecision
            get {
                return this.dbbindings[this.index].bPrecision;
            }
            set {
                this.dbbindings[this.index].bPrecision = value;
                this.dbcolumns[this.index].bPrecision = value;
            }
        }
        internal byte Scale { // bScale
#if DEBUG
            get {
                return this.dbbindings[this.index].bScale;
            }
#endif
            set {
                this.dbbindings[this.index].bScale = value;
                this.dbcolumns[this.index].bScale = value;
            }
        }
        internal void GuidKindName(Guid guid, int eKind, IntPtr propid) {
            this.dbcolumns[this.index].uGuid = guid;
            this.dbcolumns[this.index].eKind = eKind;
            this.dbcolumns[this.index].ulPropid = propid;
        }

        // Data access members
        //
        private int LengthValue {
            get {
                if (ifIRowsetElseIRow) {
                    return Marshal.ReadIntPtr(DataHandle, LengthOffset).ToInt32();
                }
                return this.dbcolumns[this.index].cbDataLen.ToInt32();
            }
            set {
                IntPtr length = new IntPtr(value);
                Marshal.WriteIntPtr(dataHandle, LengthOffset, length);
                this.dbcolumns[this.index].cbDataLen = length;
            }
        }
        internal DBStatus StatusValue {
            get {
                if (ifIRowsetElseIRow) {
                    return (DBStatus) Marshal.ReadInt32(DataHandle, StatusOffset);
                }
                return (DBStatus) this.dbcolumns[this.index].dwStatus;
            }
            set {
                Marshal.WriteInt32(DataHandle, StatusOffset, (Int32) value);
                this.dbcolumns[this.index].dwStatus = (int) value;
            }
        }

        private Exception CheckTypeValueStatusValue(Type expectedType) {
            if (DBStatus.S_OK == StatusValue) {
                return ODB.CantConvertValue(); // UNDONE: casting DbType to expectedType
            }
            switch (StatusValue) {
                case DBStatus.S_OK:
                    Debug.Assert(false, "CheckStatusValue: unhandled data with okay status");
                    break;

                case DBStatus.E_BADACCESSOR:
                    return ODB.BadAccessor();

                case DBStatus.E_CANTCONVERTVALUE:
                    return ODB.CantConvertValue(); // UNDONE: need original data type

                case DBStatus.S_ISNULL: // database null
                    return ODB.InvalidCast(); // UNDONE: NullValue exception

                case DBStatus.S_TRUNCATED:
                    Debug.Assert(false, "CheckStatusValue: unhandled data with truncated status");
                    break;

                case DBStatus.E_SIGNMISMATCH:
                    return ODB.SignMismatch(expectedType);

                case DBStatus.E_DATAOVERFLOW:
                    return ODB.DataOverflow(expectedType);

                case DBStatus.E_CANTCREATE:
                    return ODB.CantCreate(expectedType);

                case DBStatus.E_UNAVAILABLE:
                    return ODB.Unavailable(expectedType);

                default:
                    return ODB.UnexpectedStatusValue(StatusValue);
            }
            return ODB.CantConvertValue(); // UNDONE: casting DbType to expectedType
        }

        internal bool IsValueNull() {
            DBStatus value = StatusValue;
            return ((DBStatus.S_ISNULL == value) || (DBStatus.S_DEFAULT == value));
        }
        internal void SetValueDBNull() {
            LengthValue = 0;
            StatusValue = DBStatus.S_ISNULL;
            Marshal.WriteInt64(DataPtr, 0, 0L); // safe because AlignDataSize forces 8 byte blocks
        }
        internal void SetValueEmpty() {
            LengthValue = 0;
            StatusValue = DBStatus.S_DEFAULT;
            Marshal.WriteInt64(DataPtr, 0, 0L); // safe because AlignDataSize forces 8 byte blocks
        }
        internal void SetValueNull() {
            LengthValue = 0;
            StatusValue = DBStatus.S_OK;
            Marshal.WriteInt64(DataPtr, 0, 0L); // safe because AlignDataSize forces 8 byte blocks
        }
        private void SetValuePtrStrEmpty() { // MDAC 76518
            LengthValue = 0;
            StatusValue = DBStatus.S_OK;
            // just using empty string as the the empty byte[], native doesn't care
            ((DBBindingCoTaskMem) memoryHandler[this.index]).SetValue(String.Empty, 0);
        }
        internal Object Value {
            get {
                object value;
                switch(StatusValue) {
                case DBStatus.S_OK:
                    switch(DbType) {
                    case NativeDBType.EMPTY:
                        value = DBNull.Value;
                        break;
                    case NativeDBType.NULL:
                        value = DBNull.Value;
                        break;
                    case NativeDBType.I2:
                        value = Value_I2; // Int16
                        break;
                    case NativeDBType.I4:
                        value = Value_I4; // Int32
                        break;
                    case NativeDBType.R4:
                        value = Value_R4; // Single
                        break;
                    case NativeDBType.R8:
                        value = Value_R8; // Double
                        break;
                    case NativeDBType.CY:
                        value = Value_CY; // Decimal
                        break;
                    case NativeDBType.DATE:
                        value = Value_DATE; // DateTime
                        break;
                    case NativeDBType.BSTR:
                        value = Value_BSTR; // String
                        break;
                    case NativeDBType.IDISPATCH:
                        value = Value_IDISPATCH; // Object
                        break;
                    case NativeDBType.ERROR:
                        value = Value_ERROR;
                        break;
                    case NativeDBType.BOOL:
                        value = Value_BOOL; // Boolean
                        break;
                    case NativeDBType.VARIANT:
                        value = Value_VARIANT; // Object
                        break;
                    case NativeDBType.IUNKNOWN:
                        value = Value_IUNKNOWN; // Object
                        break;
                    case NativeDBType.DECIMAL:
                        value = Value_DECIMAL; // Decimal
                        break;
                    case NativeDBType.I1:
                        value = Convert.ToInt16(Value_I1); // SByte->Int16
                        break;
                    case NativeDBType.UI1:
                        value = Value_UI1; // Byte
                        break;
                    case NativeDBType.UI2:
                        value = Convert.ToInt32(Value_UI2); // UInt16->Int32
                        break;
                    case NativeDBType.UI4:
                        value = Convert.ToInt64(Value_UI4); // UInt32->Int64
                        break;
                    case NativeDBType.I8:
                        value = Value_I8; // Int64
                        break;
                    case NativeDBType.UI8:
                        value = Convert.ToDecimal(Value_UI8); // Decimal
                        break;
                    case NativeDBType.FILETIME:
                        value = Value_FILETIME; // DateTime
                        break;
                    case NativeDBType.GUID:
                        value = Value_GUID; // Guid
                        break;
                    case NativeDBType.BYTES:
                        value = Value_BYTES; // Byte[]
                        break;
#if DEBUG
                    case NativeDBType.STR:
                        Debug.Assert(false, "should have bound as WSTR");
                        goto default;
#endif
                    case NativeDBType.WSTR:
                        value = Value_WSTR; // String
                        break;
                    case NativeDBType.NUMERIC:
                        value = Value_NUMERIC; // Decimal
                        break;
#if DEBUG
                    case NativeDBType.UDT:
                        Debug.Assert(false, "UDT binding should not have been encountered");
                        goto default;
#endif
                    case NativeDBType.DBDATE:
                        value = Value_DBDATE; // DateTime
                        break;
                    case NativeDBType.DBTIME:
                        value = Value_DBTIME; // TimeSpan
                        break;
                    case NativeDBType.DBTIMESTAMP:
                        value = Value_DBTIMESTAMP; // DateTime
                        break;
                    case NativeDBType.PROPVARIANT:
                        value = Value_VARIANT; // Object
                        break;
                    case NativeDBType.HCHAPTER:
                        value = Value_HCHAPTER; // OleDbDataReader
                        break;
#if DEBUG
                    case NativeDBType.VARNUMERIC:
                        Debug.Assert(false, "should have bound as NUMERIC");
                        goto default;
#endif
                    case (NativeDBType.BYREF | NativeDBType.BYTES):
                        value = Value_ByRefBYTES;
                        break;
#if DEBUG
                    case (NativeDBType.BYREF | NativeDBType.STR):
                        Debug.Assert(false, "should have bound as BYREF|WSTR");
                        goto default;
#endif
                    case (NativeDBType.BYREF | NativeDBType.WSTR):
                        value = Value_ByRefWSTR;
                        break;
                    default:
                        throw ODB.GVtUnknown(DbType);
                    }
                    break;

                case DBStatus.S_TRUNCATED:
                    switch(DbType) {
                    case NativeDBType.BYTES:
                        value = Value_BYTES;
                        break;
#if DEBUG
                    case NativeDBType.STR:
                        Debug.Assert(false, "should have bound as WSTR");
                        goto default;
#endif
                    case NativeDBType.WSTR:
                        value = Value_WSTR;
                        break;
                    case (NativeDBType.BYREF | NativeDBType.BYTES):
                        value = Value_ByRefBYTES;
                        break;
#if DEBUG
                    case (NativeDBType.BYREF | NativeDBType.STR):
                        Debug.Assert(false, "should have bound as BYREF|WSTR");
                        goto default;
#endif
                    case (NativeDBType.BYREF | NativeDBType.WSTR):
                        value = Value_ByRefWSTR;
                        break;
                    default:
                        throw ODB.GVtUnknown(DbType);
                    }
                    break;

                case DBStatus.S_ISNULL:
                case DBStatus.S_DEFAULT:
                    value = DBNull.Value;
                    break;
                default:
                    throw CheckTypeValueStatusValue(NativeDBType.FromDBType(DbType, false, false).dataType); // MDAC 71644
                }
                GC.KeepAlive(this);
                return value;
            }
            set {
#if DEBUG
                if (AdapterSwitches.DataValue.TraceVerbose) {
                    Debug.WriteLine("DBBinding:" + DbType.ToString("G") + "=" + ADP.ValueToString(value));
                }
#endif
                if (null == value) {
                    SetValueEmpty();
                }
                else if (Convert.IsDBNull(value)) {
                    SetValueDBNull();
                }
                else switch (DbType) {
                    case NativeDBType.EMPTY:
                        SetValueEmpty();
                        break;

                    case NativeDBType.NULL: // language null - no representation, use DBNull
                        SetValueDBNull();
                        break;

                    case NativeDBType.I2:
                        Value_I2 = (Int16) value;
                        break;

                    case NativeDBType.I4:
                        Value_I4 = (Int32) value;
                        break;

                    case NativeDBType.R4:
                        Value_R4 = (Single) value;
                        break;

                    case NativeDBType.R8:
                        Value_R8 = (Double) value;
                        break;

                    case NativeDBType.CY:
                        Value_CY = (Decimal) value;
                        break;

                    case NativeDBType.DATE:
                        Value_DATE = (DateTime) value;
                        break;

                    case NativeDBType.BSTR:
                        Value_BSTR = (String) value;
                        break;

                    case NativeDBType.IDISPATCH:
                        Value_IDISPATCH = value;
                        break;

                    case NativeDBType.ERROR:
                        Value_ERROR = (Int32) value;
                        break;

                    case NativeDBType.BOOL:
                        Value_BOOL = (Boolean) value;
                        break;

                    case NativeDBType.VARIANT:
                        Value_VARIANT = value;
                        break;

                    case NativeDBType.IUNKNOWN:
                        Value_IUNKNOWN = value;
                        break;

                    case NativeDBType.DECIMAL:
                        Value_DECIMAL = (Decimal) value;
                        break;

                    case NativeDBType.I1:
                        if (value is Int16) { // MDAC 60430
                            Value_I1 = Convert.ToSByte((Int16)value);
                        }
                        else {
                            Value_I1 = (SByte) value;
                        }
                        break;

                    case NativeDBType.UI1:
                        Value_UI1 = (Byte) value;
                        break;

                    case NativeDBType.UI2:
                        if (value is Int32) {
                            Value_UI2 = Convert.ToUInt16((Int32)value);
                        }
                        else {
                            Value_UI2 = (UInt16) value;
                        }
                        break;

                    case NativeDBType.UI4:
                        if (value is Int64) {
                            Value_UI4 = Convert.ToUInt32((Int64)value);
                        }
                        else {
                            Value_UI4 = (UInt32) value;
                        }
                        break;

                    case NativeDBType.I8:
                        Value_I8 = (Int64) value;
                        break;

                    case NativeDBType.UI8:
                        if (value is Decimal) {
                            Value_UI8 = Convert.ToUInt64((Decimal)value);
                        }
                        else {
                            Value_UI8 = (UInt64) value;
                        }
                        break;

                    case NativeDBType.FILETIME:
                        Value_FILETIME = (DateTime) value;
                        break;

                    case NativeDBType.GUID:
                        Value_GUID = (Guid) value;
                        break;

                    case NativeDBType.BYTES:
                        Value_BYTES = (Byte[]) value;
                        break;
#if DEBUG
                    case NativeDBType.STR:
                        Debug.Assert(false, "Should have bound as WSTR");
                        goto default;
#endif
                    case NativeDBType.WSTR:
                        Value_WSTR = (String) value;
                        break;

                    case NativeDBType.NUMERIC:
                        Value_NUMERIC = (Decimal) value;
                        break;
#if DEBUG
                    case NativeDBType.UDT:
                        Debug.Assert(false, "UDT binding should not have been encountered");
                        goto default;
#endif
                    case NativeDBType.DBDATE:
                        Value_DBDATE = (DateTime) value;
                        break;

                    case NativeDBType.DBTIME:
                        Value_DBTIME = (TimeSpan) value;
                        break;

                    case NativeDBType.DBTIMESTAMP:
                        Value_DBTIMESTAMP = (DateTime) value;
                        break;

                    case NativeDBType.PROPVARIANT:
                        Value_VARIANT = value;
                        break;
#if DEBUG
                    case NativeDBType.HCHAPTER:
                        Debug.Assert(false, "not allowed to set HCHAPTER");
                        goto default;

                    case NativeDBType.VARNUMERIC:
                        Debug.Assert(false, "should have bound as NUMERIC");
                        goto default;
#endif
                    case (NativeDBType.BYREF | NativeDBType.BYTES):
                        Value_ByRefBYTES = (Byte[]) value;
                        break;
#if DEBUG
                    case (NativeDBType.BYREF | NativeDBType.STR):
                        Debug.Assert(false, "should have bound as BYREF|WSTR");
                        goto default;
#endif
                    case (NativeDBType.BYREF | NativeDBType.WSTR):
                        Value_ByRefWSTR = (String) value;
                        break;

                    default:
                        throw ODB.SVtUnknown(DbType);
                }
                GC.KeepAlive(this);
            }
        }

        private IntPtr ValueAsPtr {
            get {
                return Marshal.ReadIntPtr(DataPtr, 0);
            }
            set {
                Marshal.WriteIntPtr(DataPtr, 0, value);
            }
        }
        private IntPtr DataPtr {
            get {
                return this.valuePtrs[this.index];
            }
        }
        internal Boolean Value_BOOL {
            get {
                Debug.Assert(NativeDBType.BOOL == DbType, "Value_BOOL");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_BOOL");
                return (0 != Marshal.ReadInt16(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.BOOL == DbType, "Value_BOOL");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt16(DataPtr, 0, (short)(value ? ODB.VARIANT_TRUE : ODB.VARIANT_FALSE));
            }
        }
        private String Value_BSTR {
            get {
                Debug.Assert(NativeDBType.BSTR == DbType, "Value_BSTR");
                Debug.Assert((DBStatus.S_OK == StatusValue) || (DBStatus.S_TRUNCATED == StatusValue), "Value_BSTR");
                return ((DBBindingBSTR) memoryHandler[this.index]).GetString();
            }
            set {
                Debug.Assert(null != value, "set null Value_BSTR");
                Debug.Assert(NativeDBType.BSTR == DbType, "Value_BSTR");

                // we expect the provider/server to apply the silent truncation when binding BSTR
                LengthValue = value.Length * 2; /* bytecount*/
                StatusValue = DBStatus.S_OK;
                ((DBBindingBSTR) memoryHandler[this.index]).SetValue(value);
            }
        }
        private Byte[] Value_ByRefBYTES {
            get {
                Debug.Assert((NativeDBType.BYREF | NativeDBType.BYTES) == DbType, "Value_ByRefBYTES");
                Debug.Assert((DBStatus.S_OK == StatusValue) || (DBStatus.S_TRUNCATED == StatusValue), "Value_ByRefBYTES");

                int byteCount = LengthValue;
                return ((DBBindingCoTaskMem) memoryHandler[this.index]).GetBinary(byteCount);
            }
            set {
                Debug.Assert(null != value, "set null Value_ByRefBYTES");
                Debug.Assert((NativeDBType.BYREF | NativeDBType.BYTES) == DbType, "Value_ByRefBYTES");
                if (0 == value.Length) {
                    SetValuePtrStrEmpty(); // MDAC 76518
                }
                else {
                    // we expect the provider/server to apply the silent truncation when binding BY_REF
                    LengthValue = value.Length; // MDAC 80657
                    StatusValue = DBStatus.S_OK;
                    ((DBBindingCoTaskMem) memoryHandler[this.index]).SetValue(value);
                }
            }
        }
        private String Value_ByRefWSTR {
            get {
                Debug.Assert((NativeDBType.BYREF | NativeDBType.WSTR) == DbType, "Value_ByRefWSTR");
                Debug.Assert((DBStatus.S_OK == StatusValue) || (DBStatus.S_TRUNCATED == StatusValue), "Value_ByRefWSTR");

                int charCount = LengthValue / 2;
                return ((DBBindingCoTaskMem) memoryHandler[this.index]).GetString(charCount);
            }
            set {
                Debug.Assert(null != value, "set null Value_ByRefWSTR");
                Debug.Assert((NativeDBType.BYREF | NativeDBType.WSTR) == DbType, "Value_ByRefWSTR");

                // we expect the provider/server to apply the silent truncation when binding BY_REF
                LengthValue = value.Length * 2; /*bytecount*/ // MDAC 80657
                StatusValue = DBStatus.S_OK;
                ((DBBindingCoTaskMem) memoryHandler[this.index]).SetValue(value, 0);
            }
        }
        private Byte[] Value_BYTES {
            get {
                Debug.Assert(NativeDBType.BYTES == DbType, "Value_BYTES");
                Debug.Assert((DBStatus.S_OK == StatusValue) || (DBStatus.S_TRUNCATED == StatusValue), "Value_BYTES");
                int byteCount = Math.Min(LengthValue, MaxLen);
                byte[] value = new byte[byteCount];
                Marshal.Copy(DataPtr, value, 0, byteCount);
                return value;
            }
            set {
                if ((null == value) || (0 == value.Length)) {
                    SetValueNull();
                }
                // we silently truncate when the user has specified a given Size
                int bytecount = Math.Min(value.Length, MaxLen); // 70232

                LengthValue = bytecount;
                StatusValue = DBStatus.S_OK;
                Marshal.Copy(value, 0, DataPtr, bytecount);
            }
        }
        private Decimal Value_CY {
            get {
                Debug.Assert(NativeDBType.CY == DbType, "Value_CY");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_CY");
                return Decimal.FromOACurrency(Marshal.ReadInt64(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.CY == DbType, "Value_CY");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt64(DataPtr, 0, Decimal.ToOACurrency(value));
            }
        }
        private DateTime Value_DATE {
            get {
                Debug.Assert(NativeDBType.DATE == DbType, "Value_DATE");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_DATE");
                return DateTime.FromOADate((Double)Marshal.PtrToStructure(DataPtr, typeof(Double)));
            }
            set {
                Debug.Assert(NativeDBType.DATE == DbType, "Value_DATE");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.StructureToPtr(value.ToOADate(), DataPtr, false/*deleteold*/);
            }
        }
        private DateTime Value_DBDATE {
            get {
                Debug.Assert(NativeDBType.DBDATE == DbType, "Value_DBDATE");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_DBDATE");
                return Get_DBDATE(DataPtr);
            }
            set {
                Debug.Assert(NativeDBType.DBDATE == DbType, "Value_DATE");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;

                timeBuffer[0] = (short)value.Year;
                timeBuffer[1] = (short)value.Month;
                timeBuffer[2] = (short)value.Day;
                Marshal.Copy(timeBuffer, 0, DataPtr, 3);
            }
        }
        private TimeSpan Value_DBTIME {
            get {
                Debug.Assert(NativeDBType.DBTIME == DbType, "Value_DBTIME");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_DBTIME");
                return Get_DBTIME(DataPtr);
            }
            set {
                Debug.Assert(NativeDBType.DBTIME == DbType, "Value_DBTIME");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;

                timeBuffer[0] = (short)value.Hours;
                timeBuffer[1] = (short)value.Minutes;
                timeBuffer[2] = (short)value.Seconds;
                Marshal.Copy(timeBuffer, 0, DataPtr, 3);
            }
        }
        private DateTime Value_DBTIMESTAMP {
            get {
                Debug.Assert(NativeDBType.DBTIMESTAMP == DbType, "Value_DBTIMESTAMP");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_DBTIMESTAMP");
                return Get_DBTIMESTAMP(DataPtr);
            }
            set {
                Debug.Assert(NativeDBType.DBTIMESTAMP == DbType, "Value_DBTIMESTAMP");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;

                timeBuffer[0] = (short)value.Year;
                timeBuffer[1] = (short)value.Month;
                timeBuffer[2] = (short)value.Day;
                timeBuffer[3] = (short)value.Hour;
                timeBuffer[4] = (short)value.Minute;
                timeBuffer[5] = (short)value.Second;
                Marshal.Copy(timeBuffer, 0, DataPtr, 6);
                Marshal.WriteInt32(DataPtr, 12, (int)((value.Ticks % 10000000L)*100L)); // MDAC 62374
            }
        }
        private Decimal Value_DECIMAL {
            get {
                Debug.Assert(NativeDBType.DECIMAL == DbType, "Value_DECIMAL");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_DECIMAL");
                return Get_DECIMAL(DataPtr, this.decimalBuffer);
            }
            set {
                Debug.Assert(NativeDBType.DECIMAL == DbType, "Value_DECIMAL");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;

                int[] tmp = Decimal.GetBits(value); // UNDONE Decimal.CopyTo(this.decimalBuffer);
                IntPtr ptr = DataPtr;
                Marshal.WriteInt32(ptr,  0, tmp[3]);
                Marshal.WriteInt32(ptr,  4, tmp[2]);
                Marshal.WriteInt32(ptr,  8, tmp[0]);
                Marshal.WriteInt32(ptr, 12, tmp[1]);
            }
        }
        private Int32 Value_ERROR {
            get {
                Debug.Assert(NativeDBType.ERROR == DbType, "Value_ERROR");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_ERROR");
                return Marshal.ReadInt32(DataPtr, 0);
            }
            set {
                Debug.Assert(NativeDBType.ERROR == DbType, "Value_ERROR");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt32(DataPtr, 0, value);
            }
        }
        private DateTime Value_FILETIME {
            get {
                Debug.Assert(NativeDBType.FILETIME == DbType, "Value_FILETIME");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_FILETIME");
                return DateTime.FromFileTimeUtc(Marshal.ReadInt64(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.FILETIME == DbType, "Value_FILETIME");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt64(DataPtr, 0, value.ToFileTimeUtc());
            }
        }
        internal Guid Value_GUID {
            get {
                Debug.Assert(NativeDBType.GUID == DbType, "Value_GUID");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_GUID");
                return (Guid) Marshal.PtrToStructure(DataPtr, typeof(Guid));
            }
            set {
                Debug.Assert(NativeDBType.GUID == DbType, "Value_GUID");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.StructureToPtr(value, DataPtr, false/*deleteold*/);
            }
        }
        private OleDbDataReader Value_HCHAPTER {
            get {
                Debug.Assert(NativeDBType.HCHAPTER == DbType, "Value_HCHAPTER");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_HCHAPTER");
                Debug.Assert(null != this.parent, "Value_HCHAPTER");
                return this.parent.ResetChapter(this.bindingIndex, this.index, ValueAsPtr);
            }
        }
        private SByte Value_I1 {
            get {
                Debug.Assert(NativeDBType.I1 == DbType, "Value_I1");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_I1");
                return unchecked((SByte)Marshal.ReadByte(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.I1 == DbType, "Value_I1");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteByte(DataPtr, 0, unchecked((Byte) value));
            }
        }
        internal Int16 Value_I2 {
            get {
                Debug.Assert(NativeDBType.I2 == DbType, "Value_I2");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_I2");
                return Marshal.ReadInt16(DataPtr, 0);
            }
            set {
                Debug.Assert(NativeDBType.I2 == DbType, "Value_I2");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt16(DataPtr, 0, value);
            }
        }
        private Int32 Value_I4 {
            get {
                Debug.Assert(NativeDBType.I4 == DbType, "Value_I4");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_I4");
                return Marshal.ReadInt32(DataPtr, 0);
            }
            set {
                Debug.Assert(NativeDBType.I4 == DbType, "Value_I4");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt32(DataPtr, 0, value);
            }
        }
        private Int64 Value_I8 {
            get {
                Debug.Assert(NativeDBType.I8 == DbType, "Value_I8");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_I8");
                return Marshal.ReadInt64(DataPtr, 0);
            }
            set {
                Debug.Assert(NativeDBType.I8 == DbType, "Value_I8");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt64(DataPtr, 0, value);
            }
        }
        private object Value_IDISPATCH {
            get {
                Debug.Assert(NativeDBType.IDISPATCH == DbType, "Value_IDISPATCH");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_IDISPATCH");
                return Marshal.GetObjectForIUnknown(Marshal.ReadIntPtr(DataPtr, 0));
            }
            set {
                // UNDONE: OLE DB will IUnknown.Release input storage parameter values
                Debug.Assert(NativeDBType.IDISPATCH == DbType, "Value_IDISPATCH");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                ValueAsPtr = Marshal.GetIDispatchForObject(value); // MDAC 80727
            }
        }
        private object Value_IUNKNOWN {
            get {
                Debug.Assert(NativeDBType.IUNKNOWN == DbType, "Value_IUNKNOWN");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_IUNKNOWN");
                return Marshal.GetObjectForIUnknown(ValueAsPtr);
            }
            set {
                // UNDONE: OLE DB will IUnknown.Release input storage parameter values
                Debug.Assert(NativeDBType.IUNKNOWN == DbType, "Value_IUNKNOWN");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                ValueAsPtr = Marshal.GetIUnknownForObject(value); // MDAC 80727
            }
        }
        private Decimal Value_NUMERIC {
            get {
                Debug.Assert(NativeDBType.NUMERIC == DbType, "Value_NUMERIC");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_NUMERIC");
                return Get_NUMERIC(DataPtr, this.decimalBuffer);
            }
            set {
                Debug.Assert(NativeDBType.NUMERIC == DbType, "Value_NUMERIC");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;

                int[] tmp = Decimal.GetBits(value);
                byte[] bits;
                bits = BitConverter.GetBytes(tmp[3]);

                IntPtr ptr = DataPtr;
                Marshal.WriteByte (ptr,  0, Precision);
                Marshal.WriteByte (ptr,  1, bits[2]);
                Marshal.WriteByte (ptr,  2, (Byte) ((0 == bits[3]) ? 1 : 0));
                Marshal.WriteInt32(ptr,  3, tmp[0]);
                Marshal.WriteInt32(ptr,  7, tmp[1]);
                Marshal.WriteInt32(ptr, 11, tmp[2]);
                Marshal.WriteInt32(ptr, 15, 0);
            }
        }
        private Single Value_R4 {
            get {
                Debug.Assert(NativeDBType.R4 == DbType, "Value_R4");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_R4");
                return (Single) Marshal.PtrToStructure(DataPtr, typeof(Single));
            }
            set {
                Debug.Assert(NativeDBType.R4 == DbType, "Value_R4");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.StructureToPtr(value, DataPtr, false/*deleteold*/);
            }
        }
        private Double Value_R8 {
            get {
                Debug.Assert(NativeDBType.R8 == DbType, "Value_R8");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_R8");
                return (Double) Marshal.PtrToStructure(DataPtr, typeof(Double));
            }
            set {
                Debug.Assert(NativeDBType.R8 == DbType, "Value_I4");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.StructureToPtr(value, DataPtr, false/*deleteold*/);
            }
        }
        private Byte Value_UI1 {
            get {
                Debug.Assert(NativeDBType.UI1 == DbType, "Value_UI1");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_UI1");
                return Marshal.ReadByte(DataPtr, 0);
            }
            set {
                Debug.Assert(NativeDBType.UI1 == DbType, "Value_UI1");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteByte(DataPtr, 0, value);
            }
        }
        internal UInt16 Value_UI2 {
            get {
                Debug.Assert(NativeDBType.UI2 == DbType, "Value_UI2");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_UI2");
                return unchecked((UInt16) Marshal.ReadInt16(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.UI2 == DbType, "Value_UI2");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt16(DataPtr, 0, unchecked((Int16) value));
            }
        }
        internal UInt32 Value_UI4 {
            get {
                Debug.Assert(NativeDBType.UI4 == DbType, "Value_UI4");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_UI4");
                return unchecked((UInt32) Marshal.ReadInt32(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.UI4 == DbType, "Value_UI4");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt32(DataPtr, 0, unchecked((Int32) value));
            }
        }
        private UInt64 Value_UI8 {
            get {
                Debug.Assert(NativeDBType.UI8 == DbType, "Value_UI8");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_UI8");
                return unchecked((UInt64) Marshal.ReadInt64(DataPtr, 0));
            }
            set {
                Debug.Assert(NativeDBType.UI8 == DbType, "Value_UI8");
                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                Marshal.WriteInt64(DataPtr, 0, unchecked((Int64) value));
            }
        }
        private String Value_WSTR {
            get {
                Debug.Assert(NativeDBType.WSTR == DbType, "Value_WSTR");
                Debug.Assert((DBStatus.S_OK == StatusValue) || (DBStatus.S_TRUNCATED == StatusValue), "Value_WSTR");
                int byteCount = Math.Min(LengthValue, MaxLen-2);
                return Marshal.PtrToStringUni(DataPtr, byteCount / 2);
            }
            set {
                Debug.Assert(NativeDBType.WSTR == DbType, "Value_WSTR");
                if ((null == value) || (0 == value.Length)) {
                    SetValueNull();
                }
                else {
                    char[] chars = value.ToCharArray();
                    // we silently truncate when the user has specified a given Size
                    int charCount = Math.Min((MaxLen-2)/2, chars.Length); // MDAC 70232
                    int byteCount = charCount*2;
                    LengthValue = byteCount;
                    StatusValue = DBStatus.S_OK;
                    Marshal.Copy(chars, 0, DataPtr, charCount);
                }
            }
        }
        private object Value_VARIANT {
            get {
                Debug.Assert((NativeDBType.VARIANT == DbType) || (NativeDBType.PROPVARIANT == DbType), "Value_VARIANT");
                Debug.Assert(DBStatus.S_OK == StatusValue, "Value_VARIANT");

                return ((DBBindingVARIANT) memoryHandler[this.index]).GetValue();
            }
            set {
                Debug.Assert((NativeDBType.VARIANT == DbType) || (NativeDBType.PROPVARIANT == DbType), "Value_VARIANT");

                LengthValue = 0;
                StatusValue = DBStatus.S_OK;
                ((DBBindingVARIANT) memoryHandler[this.index]).SetValue(value);
            }
        }

        internal Boolean ValueBoolean {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.BOOL == DbType) {
                        return Value_BOOL;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        return (Boolean) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Boolean));
            }
        }
        internal Byte ValueByte {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.UI1 == DbType) {
                        return Value_UI1;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        return (Byte) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Byte));
            }
        }
        internal DateTime ValueDateTime {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.DBTIMESTAMP == DbType) {
                        return Value_DBTIMESTAMP;
                    }
                    else if (NativeDBType.DBDATE == DbType) {
                        return Value_DBDATE;
                    }
                    else if (NativeDBType.DATE == DbType) {
                        return Value_DATE;
                    }
                    else if (NativeDBType.FILETIME == DbType) {
                        return Value_FILETIME;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        return (DateTime) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(DateTime));
            }
        }
        internal Decimal ValueDecimal {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.DECIMAL == DbType) {
                        return Value_DECIMAL;
                    }
                    else if (NativeDBType.NUMERIC == DbType) {
                        return Value_NUMERIC;
                    }
                    else if (NativeDBType.CY == DbType) {
                        return Value_CY;
                    }
                    else if (NativeDBType.UI8 == DbType) {
                        return Convert.ToDecimal(Value_UI8);
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        object value = Value_VARIANT;
                        if (value is UInt64) {
                            return (Decimal) ((UInt64) value);
                        }
                        return (Decimal) value;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Decimal));
            }
        }
        internal Double ValueDouble {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.R8 == DbType) {
                        return Value_R8;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        return (Double) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Double));
            }
        }
        internal Guid ValueGuid {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.GUID == DbType) {
                        return Value_GUID;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        return (Guid) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Guid));
            }
        }
        internal Int16 ValueInt16 {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.I2 == DbType) {
                        return Value_I2;
                    }
                    else if (NativeDBType.I1 == DbType) {
                        return Value_I1;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        object value = Value_VARIANT;
                        if (value is SByte) {
                            return (Int16) ((SByte) value);
                        }
                        return (Int16) value;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Int16));
            }
        }
        internal Int32 ValueInt32 {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.I4 == DbType) {
                        return Value_I4;
                    }
                    else if (NativeDBType.UI2 == DbType) {
                        return Value_UI2;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        object value = Value_VARIANT;
                        if (value is UInt16) {
                            return (Int32) ((UInt16) value);
                        }
                        return (Int32) value;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Int32));
            }
        }
        internal Int64 ValueInt64 {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.I8 == DbType) {
                        return Value_I8;
                    }
                    else if (NativeDBType.UI4 == DbType) {
                        return Value_UI4;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        object value = Value_VARIANT;
                        if (value is UInt32) {
                            return (Int64) ((UInt32) value);
                        }
                        return (Int64) value;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Int64));
            }
        }
        internal Single ValueSingle {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.R4 == DbType) {
                        return Value_R4;
                    }
                    else if (NativeDBType.VARIANT == DbType) {
                        return (Single) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(Single));
            }
        }
        internal String ValueString {
            get {
                switch(StatusValue) {
                case DBStatus.S_OK:
                case DBStatus.S_TRUNCATED:
                    switch(DbType) {
#if DEBUG
                    case NativeDBType.STR:
                        Debug.Assert(false, "should have bound as WSTR");
                        break;
#endif
                    case NativeDBType.WSTR:
                        return Value_WSTR;

                    case NativeDBType.BSTR:
                        return Value_BSTR;
#if DEBUG
                    case (NativeDBType.BYREF | NativeDBType.STR):
                        Debug.Assert(false, "should have bound as BYREF|WSTR");
                        break;
#endif
                    case (NativeDBType.BYREF | NativeDBType.WSTR):
                        return Value_ByRefWSTR;

                    case NativeDBType.VARIANT:
                        return (string) Value_VARIANT;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(String));
            }
        }
        internal TimeSpan ValueTimeSpan {
            get {
                if (DBStatus.S_OK == StatusValue) {
                    if (NativeDBType.DBTIME == DbType) {
                        return Value_DBTIME;
                    }
                    throw ODB.CantConvertValue();
                }
                throw CheckTypeValueStatusValue(typeof(TimeSpan));
            }
        }

        internal void CleanupBindings() {
            if (null != memoryHandler) {
                for (int i = 0; i < count; ++i) {
                    if (null != memoryHandler[i]) {
                        memoryHandler[i].Close();
                    }
                }
            }
        }

        static private int AlignDataSize(int value) {
            // buffer data to start on 8-byte boundary
            return Math.Max(8, value + ((8 - (value % 8)) % 8)); // MDAC 70350
        }

        static internal DateTime Get_DBTIMESTAMP(IntPtr buffer) {
            DateTime value = new DateTime(
                Marshal.ReadInt16(buffer,  0),  //year
                Marshal.ReadInt16(buffer,  2),  //month
                Marshal.ReadInt16(buffer,  4),  //day
                Marshal.ReadInt16(buffer,  6),  //hour
                Marshal.ReadInt16(buffer,  8),  //minutes
                Marshal.ReadInt16(buffer, 10)   //seconds
            );
            value = value.AddTicks(Marshal.ReadInt32(buffer, 12) / 100); // MDAC 62374
            return value;
        }
        static internal DateTime Get_DBDATE(IntPtr buffer) {
            return new DateTime(
                Marshal.ReadInt16(buffer, 0), // hours
                Marshal.ReadInt16(buffer, 2), // minutes
                Marshal.ReadInt16(buffer, 4)  // seconds
            );
        }
        static internal Decimal Get_DECIMAL(IntPtr buffer, int[] tmp) {
            Debug.Assert(null != tmp, "null DecimalBuffer");
            tmp[3] = Marshal.ReadInt32(buffer,  0) & unchecked((int)0x80FF0000);// sign & scale
            tmp[2] = Marshal.ReadInt32(buffer,  4);  // high
            tmp[0] = Marshal.ReadInt32(buffer,  8);  // low
            tmp[1] = Marshal.ReadInt32(buffer, 12);  // mid
            return new Decimal(tmp);
        }
        static internal Decimal Get_NUMERIC(IntPtr buffer, int[] tmp) {
            Debug.Assert(null != tmp, "null DecimalBuffer");

            short flag = Marshal.ReadInt16(buffer, 1);
            byte[] bits = BitConverter.GetBytes(flag);

            tmp[3] = ((int) bits[0]) << 16; // scale
            if (0 == bits[1]) {
                tmp[3] |= unchecked((int)0x80000000); //sign
            }
            tmp[0] = Marshal.ReadInt32(buffer,  3);  // low
            tmp[1] = Marshal.ReadInt32(buffer,  7);  // mid
            tmp[2] = Marshal.ReadInt32(buffer, 11);  // high
            if (0 != Marshal.ReadInt32(buffer, 15)) {
                throw ODB.NumericToDecimalOverflow(/* UNDONE: convert value to string*/);
            }
            return new Decimal(tmp);
        }
        static internal TimeSpan Get_DBTIME(IntPtr buffer) {
            return new TimeSpan(
                Marshal.ReadInt16(buffer, 0), // hours
                Marshal.ReadInt16(buffer, 2), // minutes
                Marshal.ReadInt16(buffer, 4)  // seconds
            );
        }
    }

    internal abstract class DBBindingCleanup {

        internal IntPtr dataPtr;

        abstract internal void Close();

        internal void Dispose() {
            Close();
            dataPtr = IntPtr.Zero;
        }
    }

    sealed internal class DBBindingCoTaskMem : DBBindingCleanup  {

        IntPtr valuePtr;
        GCHandle handle; // client allocated memory is a pinned buffer

        override internal void Close() {
            if (handle.IsAllocated) {
                handle.Free(); // GCHandles appear to Free/Unpin themselves correctly
            }
            if (IntPtr.Zero != dataPtr) {
                IntPtr ptr = Marshal.ReadIntPtr(dataPtr, 0);

                if (IntPtr.Zero != ptr) {
                    Marshal.WriteIntPtr(dataPtr, 0, IntPtr.Zero);

                    if (ptr != valuePtr) {
                        Marshal.FreeCoTaskMem(ptr); // free provider allocated memory
                    }
                }
                valuePtr = IntPtr.Zero;
            }
        }

        internal byte[] GetBinary(int byteCount) {
            byte[] value = new byte[byteCount];

            if (IntPtr.Zero != dataPtr) {
                IntPtr ptr = Marshal.ReadIntPtr(dataPtr, 0);

                if (IntPtr.Zero != ptr) {
                    Marshal.Copy(ptr, value, 0, byteCount);
                }
            }
#if DEBUG
            else {
                Debug.Assert(IntPtr.Zero != dataPtr, "DBBindingCoTaskMem: GetBinary() IntPtr.Zero");
            }
#endif
            return value;
        }

        internal string GetString(int charCount) {
            string value = "";

            if (IntPtr.Zero != dataPtr) {
                IntPtr ptr = Marshal.ReadIntPtr(dataPtr, 0);

                if (IntPtr.Zero != ptr) {
                    value = Marshal.PtrToStringUni(ptr, charCount);
                }
            }
#if DEBUG
            else {
                Debug.Assert(IntPtr.Zero != dataPtr, "DBBindingCoTaskMem: GetString() IntPtr.Zero");
            }
#endif
            return value;
        }

        internal void SetValue(byte[] value) {
            try {
                handle = GCHandle.Alloc(value, GCHandleType.Pinned);
                valuePtr = handle.AddrOfPinnedObject(); // UnsafeAddrOfPinnedArrayElement now does full stackwalk
                Marshal.WriteIntPtr(dataPtr, 0, valuePtr);
            }
            catch(Exception e) {
                valuePtr = IntPtr.Zero;
                Marshal.WriteIntPtr(dataPtr, 0, IntPtr.Zero);
                if (handle.IsAllocated) {
                    handle.Free();
                }
                throw e;
            }
        }
        internal void SetValue(string value, int offset) {
            try {
                handle = GCHandle.Alloc(value, GCHandleType.Pinned);
                valuePtr = handle.AddrOfPinnedObject();
                valuePtr = ADP.IntPtrOffset(valuePtr, offset);
                Marshal.WriteIntPtr(dataPtr, 0, valuePtr);
            }
            catch(Exception e) {
                valuePtr = IntPtr.Zero;
                Marshal.WriteIntPtr(dataPtr, 0, IntPtr.Zero);
                if (handle.IsAllocated) {
                    handle.Free();
                }
                throw ADP.TraceException(e);
            }
        }
    }

    sealed internal class DBBindingBSTR : DBBindingCleanup {

        IntPtr valuePtr;

        override internal void Close() {
            if (IntPtr.Zero != dataPtr) {
                IntPtr ptr = Marshal.ReadIntPtr(dataPtr, 0);

                if (IntPtr.Zero != ptr) {
                    Marshal.WriteIntPtr(dataPtr, 0, IntPtr.Zero);

                    if (ptr != valuePtr) {
                        Marshal.FreeBSTR(ptr); // free provider allocated bstr
                    }
                }
                if (IntPtr.Zero != valuePtr) {
                    Marshal.FreeBSTR(valuePtr); // free client allocated bstr
                }
                valuePtr = IntPtr.Zero;
            }
        }

        internal string GetString() {
            string value = "";
            if (IntPtr.Zero != dataPtr) {
                IntPtr ptr = Marshal.ReadIntPtr(dataPtr, 0);
                value = Marshal.PtrToStringBSTR(ptr);
            }
#if DEBUG
            else {
                Debug.Assert(IntPtr.Zero != dataPtr, "DBBindingBSTR: GetValue() IntPtr.Zero");
            }
#endif
            return value;
        }

        internal void SetValue(string value) {
            try {
                valuePtr = Marshal.StringToBSTR(value);
                Marshal.WriteIntPtr(dataPtr, 0, valuePtr);
            }
            catch(Exception e) {
                Marshal.WriteIntPtr(dataPtr, 0, IntPtr.Zero);
                Marshal.FreeBSTR(valuePtr);
                valuePtr = IntPtr.Zero;
                throw e;
            }
        }
    }

    sealed internal class DBBindingVARIANT : DBBindingCleanup {

        Int64 partA, partB;

        override internal void Close() {
            if (IntPtr.Zero != dataPtr) {
                Int64 a = Marshal.ReadInt64(dataPtr,  0);
                Int64 b = Marshal.ReadInt64(dataPtr,  8);

                SafeNativeMethods.VariantClear(dataPtr);

                if ((a != partA) && (b != partB)) {
                    Marshal.WriteInt64(dataPtr,  0, partA);
                    Marshal.WriteInt64(dataPtr,  8, partB);
                    SafeNativeMethods.VariantClear(dataPtr);
                }
                Marshal.WriteInt64(dataPtr,  0, 0L);
                Marshal.WriteInt64(dataPtr,  8, 0L);
                partA = 0L;
                partB = 0L;
            }
        }

        internal object GetValue() {
            object value = null;
            if (IntPtr.Zero != dataPtr) {
                value = Marshal.GetObjectForNativeVariant(dataPtr);
            }
#if DEBUG
            else {
                Debug.Assert(IntPtr.Zero != dataPtr, "DBBindingVARIANT: GetValue() IntPtr.Zero");
            }
#endif
            return ((null != value) ? value : DBNull.Value);
        }

        internal void SetValue(object value) {
            try {
                Marshal.GetNativeVariantForObject(value, dataPtr);

                partA = Marshal.ReadInt64(dataPtr, 0);
                partB = Marshal.ReadInt64(dataPtr, 8);
            }
            catch(Exception e) {
                SafeNativeMethods.VariantClear(dataPtr);
                Marshal.WriteInt64(dataPtr,  0, 0L);
                Marshal.WriteInt64(dataPtr,  8, 0L);
                partA = 0L;
                partB = 0L;
                throw e;
            }
        }
    }

    sealed internal class StringPtr {
        internal IntPtr ptr;

        internal StringPtr(string value) {
            if (null != value) {
                ptr = Marshal.StringToCoTaskMemUni(value);
            }
        }

        ~StringPtr() {
            Marshal.FreeCoTaskMem(ptr); // guards itself against 0
            ptr = IntPtr.Zero;
        }

        internal void Dispose() {
            Marshal.FreeCoTaskMem(ptr); // guards itself against 0
            ptr = IntPtr.Zero;
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbctype.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;

namespace System.Data.Odbc
{
    /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType"]/*' />
    public enum OdbcType {
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.BigInt"]/*' />
        BigInt = 1,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Binary"]/*' />
        Binary = 2,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Bit"]/*' />
        Bit = 3,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Char"]/*' />
        Char = 4,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.DateTime"]/*' />
        DateTime = 5,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Decimal"]/*' />
        Decimal = 6,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Numeric"]/*' />
        Numeric = 7,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Double"]/*' />
        Double = 8,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Image"]/*' />
        Image = 9,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Int"]/*' />
        Int = 10,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.NChar"]/*' />
        NChar = 11,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.NText"]/*' />
        NText = 12,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.NVarChar"]/*' />
        NVarChar = 13,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Real"]/*' />
        Real = 14,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.UniqueIdentifier"]/*' />
        UniqueIdentifier = 15,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.SmallDateTime"]/*' />
        SmallDateTime = 16,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.SmallInt"]/*' />
        SmallInt = 17,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Text"]/*' />
        Text = 18,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Timestamp"]/*' />
        Timestamp = 19,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.TinyInt"]/*' />
        TinyInt = 20,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.VarBinary"]/*' />
        VarBinary = 21,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.VarChar"]/*' />
        VarChar = 22,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Date"]/*' />
        Date = 23,
        /// <include file='doc\OdbcType.uex' path='docs/doc[@for="OdbcType.Time"]/*' />
        Time = 24,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbctransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Data.Common;
using System.Runtime.InteropServices;

namespace System.Data.Odbc
{
    /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcTransaction : MarshalByRefObject, IDbTransaction, IDisposable
    {
        internal bool autocommit = true;
        internal OdbcConnection connection;
        internal IsolationLevel isolevel = IsolationLevel.Unspecified;

        internal OdbcTransaction(OdbcConnection connection, IsolationLevel isolevel) {
            this.connection = connection;
            this.isolevel   = isolevel;
        }

        //~OdbcTransaction() {
        //    Dispose(false);
        //}

        internal bool AutoCommit {
            get {
                return autocommit;
            }
            set { 
                //Turning off auto-commit - which will implictly start a transaction
                ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                    UnsafeNativeMethods.Odbc32.SQLSetConnectAttrW(
                        this.connection._dbcWrapper,    
                        (Int32)ODBC32.SQL_ATTR.AUTOCOMMIT,
                        new HandleRef(null, (IntPtr)(value == true ? 1 : 0)),        //1:on, 0:off
                        (Int32)ODBC32.SQL_IS.UINTEGER);
                if(retcode != ODBC32.RETCODE.SUCCESS)
                    this.connection.HandleError(this.connection._dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);

                //AutoCommit (update after success)
                autocommit = value;
            }
        }

        /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction.Connection"]/*' />
        public OdbcConnection Connection { // MDAC 66655
            get {
                return connection;
            }
        }

        // comment out for 'Managed WR1 B1' release
        /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction.IDbTransaction.Connection"]/*' />
        /// <internalonly/>
        IDbConnection IDbTransaction.Connection {
            get {
                return Connection;
            }
        }

        /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction.IsolationLevel"]/*' />
        public IsolationLevel IsolationLevel {
            get {
                if (null == this.connection) {
                    throw ADP.TransactionZombied(this);
                }

                //We need to query for the case where the user didn't set the isolevel
                //BeginTransaction(), but we should also query to see if the driver 
                //"rolled" the level to a higher supported one...
                if(isolevel == IsolationLevel.Unspecified)
                {
                    //Get the isolation level
                    ODBC32.SQL_ISOLATION sql_iso = 
                        (ODBC32.SQL_ISOLATION)connection.GetConnectAttr(ODBC32.SQL_ATTR.TXN_ISOLATION, ODBC32.HANDLER.THROW);
                    switch(sql_iso)
                    {
                        case ODBC32.SQL_ISOLATION.READ_UNCOMMITTED:
                            return isolevel = IsolationLevel.ReadUncommitted;
                        case ODBC32.SQL_ISOLATION.READ_COMMITTED:
                            return isolevel = IsolationLevel.ReadCommitted;
                        case ODBC32.SQL_ISOLATION.REPEATABLE_READ:
                            return isolevel = IsolationLevel.RepeatableRead;
                        case ODBC32.SQL_ISOLATION.SERIALIZABLE:
                            return isolevel = IsolationLevel.Serializable;
                        
                        default:
                            throw ODC.UnsupportedIsolationLevel(sql_iso);
                    };
                }
                return isolevel;
            }
        }

        internal void BeginTransaction() {
            //Turn off auto-commit (which basically starts the transaciton
            AutoCommit = false;
        }

        /*public OdbcCommand CreateCommand() { // MDAC 68309
            OdbcCommand cmd = Connection.CreateCommand();
            cmd.Transaction = this;
            return cmd;
        }

        IDbCommand IDbTransaction.CreateCommand() {
            return CreateCommand();
        }*/

        /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction.Commit"]/*' />
        public void Commit() {
            OdbcConnection.OdbcPermission.Demand(); // MDAC 81476

            if (null == this.connection) {
                throw ADP.TransactionZombied(this);
            }
            connection.CheckState(ADP.CommitTransaction); // MDAC 68289

            //Note: SQLEndTran success if not actually in a transaction, so we have to throw
            //since the IDbTransaciton spec indicates this is an error for the managed packages
            if(AutoCommit)
                throw ODC.NotInTransaction();
            
            //Commit the transaction (for just this connection)
            ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                        UnsafeNativeMethods.Odbc32.SQLEndTran(
                                    (short)ODBC32.SQL_HANDLE.DBC,
                                    this.connection._dbcWrapper,
                                    (Int16)ODBC32.SQL_TXN.COMMIT);
            if(retcode != ODBC32.RETCODE.SUCCESS)
                this.connection.HandleError(this.connection._dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);

            //Transaction is complete...
            AutoCommit = true;
            this.connection.weakTransaction = null;
            this.connection._dbcWrapper._isInTransaction = false;
            this.connection = null;
        }

        /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /*virtual protected*/private void Dispose(bool disposing) {
            if (disposing) { // release mananged objects
                if ((null != this.connection) && !AutoCommit) {
                    try {
                        this.Rollback();
                    }
                    catch (Exception e) {
                        ADP.TraceException (e); // Never throw!
                    }
                } 
                this.connection = null;
                this.isolevel = IsolationLevel.Unspecified;
            }
            // release unmanaged objects

            // base.Dispose(disposing); // notify base classes
        }


        /// <include file='doc\OdbcTransaction.uex' path='docs/doc[@for="OdbcTransaction.Rollback"]/*' />
        public void Rollback() {
            if (null == this.connection) {
                throw ADP.TransactionZombied(this);
            }
            connection.CheckState(ADP.RollbackTransaction); // MDAC 68289

            //Note: SQLEndTran success if not actually in a transaction, so we have to throw
            //since the IDbTransaciton spec indicates this is an error for the managed packages
            if(AutoCommit)
                throw ODC.NotInTransaction();          

            try { // try-finally inside try-catch-throw
                try {
                    //Abort the transaction (for just this connection)
                    ODBC32.RETCODE retcode = (ODBC32.RETCODE)
                                UnsafeNativeMethods.Odbc32.SQLEndTran(
                                            (short)ODBC32.SQL_HANDLE.DBC,
                                            this.connection._dbcWrapper,
                                            (Int16)ODBC32.SQL_TXN.ROLLBACK);
                    if(retcode != ODBC32.RETCODE.SUCCESS)
                        this.connection.HandleError(this.connection._dbcWrapper, ODBC32.SQL_HANDLE.DBC, retcode);

                    //Transaction is complete...
                    AutoCommit = true;
                }
                finally {
                    this.connection.weakTransaction = null;
                    this.connection._dbcWrapper._isInTransaction = false;
                    this.connection = null;
                }
            }
            catch { // MDAC 81875
                throw;
            }
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcutils.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcUtils.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Data.Common;
using System.Diagnostics;                   // Debug services
using System.Runtime.InteropServices;   //Marshal
using System.Text;                      // StringBuilder
using System.Globalization;

namespace System.Data.Odbc
{
    sealed internal class CNativeBuffer : IDisposable
    {
        //Data
        internal   IntPtr   _buffer;
        internal   int      _bufferlen;
        internal    bool    _memowner;

        //Constructor
        public CNativeBuffer (int initialsize) {
            _bufferlen  = initialsize;
            _memowner = false;
        }

        public CNativeBuffer (int size, IntPtr pmem) {
            _bufferlen = size; 
            _buffer = pmem;
            _memowner = false;
        }

        public static implicit operator HandleRef(CNativeBuffer x) {
            return new HandleRef(x, x.Ptr);
        }
        
        //Accessors

        // get_Ptr
        // -------
        // If there is no real memory associated with this CNativeBuffer object get_Ptr will allocate
        // native memory and assign it to this object.
        //
        public IntPtr Ptr {
            get {
                if(_buffer == IntPtr.Zero) {
                    _buffer = Marshal.AllocCoTaskMem(_bufferlen);
                    SafeNativeMethods.ZeroMemory(_buffer, Math.Min(64, _bufferlen));
                    _memowner = true;
                }
// fxcop moans but keepalive does not make sense here
//                GC.KeepAlive(this);
                return _buffer;
            }
        }

        public  int Length {
            get{
// fxcop moans but keepalive does not make sense here
//                GC.KeepAlive(this);
                return _bufferlen;
            }
        }


        // EnsureAlloc
        // -----------
        // If there is no real memory associated with this CNativeBuffer object EnsureAlloc will not
        // just change the length of the buffer. 
        //
        public  void EnsureAlloc(int cb) {
            // Check if we need to grow the buffer (no action otherwise)
            if(_bufferlen < cb) {
                // Check if there is already memory associated with this object. 
                // If not get_Ptr will take care of that.
                if (IntPtr.Zero != _buffer) {
                    // Check if the object owns the memory. 
                    // If not we just drop the buffer and get_Ptr will take care of the allocation
                    if (_memowner) {
                        _buffer = Marshal.ReAllocCoTaskMem(_buffer, cb);
                    }
                    else {
                        _buffer = IntPtr.Zero;
                    }
                }
                _bufferlen = cb;
                GC.KeepAlive(this);
            }
        }

        ~CNativeBuffer() {
            Dispose(false);
        }

        public void Dispose() {
            Dispose(true);            
            //GC.SuppressFinalize(this); // UNDONE: not worth the perf hit
        }

        // Helpers

        // Dispose
        // -------
        // Dispose frees the memory associated with this object.
        //
        public void Dispose(bool disposing) {
            if(_buffer != IntPtr.Zero) {
                if (_memowner) {
                    Marshal.FreeCoTaskMem(_buffer);
                    _memowner = false;
                }
                _buffer = IntPtr.Zero;
                GC.KeepAlive(this);
            }
        }

        public  object      MarshalToManaged(ODBC32.SQL_C sqlctype, int cb)
        {
            IntPtr buffer = this.Ptr;
            switch(sqlctype)
            {
/*
#if DEBUG
               case ODBC32.SQL_C.CHAR:
                    Debug.Assert(false, "should have bound as WCHAR");
                    goto default;
#endif
*/
                case ODBC32.SQL_C.WCHAR:
                    //Note: We always bind as unicode
                    if(cb<0) {
                        String retstr = Marshal.PtrToStringUni(buffer);
                        Debug.Assert(retstr.Length <= this.Length/2);
                        return retstr;
                    }
                    Debug.Assert((Length >= cb), "Native buffer too small ");
                    cb = Math.Min(cb/2, (Length-2)/2);
                    return Marshal.PtrToStringUni(buffer, cb);

                case ODBC32.SQL_C.CHAR:                
                case ODBC32.SQL_C.BINARY:
                {
                    Debug.Assert((Length >= cb), "Native buffer too small ");
                    cb = Math.Min(cb, Length);
                    Byte[] rgBytes = new Byte[cb];
                    Marshal.Copy(buffer, rgBytes, 0, cb);
                    return rgBytes;
                }

                case ODBC32.SQL_C.SSHORT:
                    Debug.Assert((Length >= 2), "Native buffer too small ");
                    return Marshal.PtrToStructure(buffer, typeof(Int16));

                case ODBC32.SQL_C.SLONG:
                    Debug.Assert((Length >= 4), "Native buffer too small ");
                    return Marshal.PtrToStructure(buffer, typeof(int));

                case ODBC32.SQL_C.SBIGINT:
                    Debug.Assert((Length >= 8), "Native buffer too small ");
                    return Marshal.PtrToStructure(buffer, typeof(Int64));

                case ODBC32.SQL_C.BIT:
                {
                    Debug.Assert((Length >= 1), "Native buffer too small ");
                    Byte b = Marshal.ReadByte(buffer);
                    return (b != 0x00);
                }

                case ODBC32.SQL_C.REAL:
                    Debug.Assert((Length >= 8), "Native buffer too small ");
                    return Marshal.PtrToStructure(buffer, typeof(float));

                case ODBC32.SQL_C.DOUBLE:
                    Debug.Assert((Length >= 8), "Native buffer too small ");
                    return Marshal.PtrToStructure(buffer, typeof(double));

                case ODBC32.SQL_C.UTINYINT:
                    Debug.Assert((Length >= 1), "Native buffer too small ");
                    return Marshal.ReadByte(buffer);

                case ODBC32.SQL_C.GUID:
                    Debug.Assert((Length >= 16), "Native buffer too small ");
                    return Marshal.PtrToStructure(buffer, typeof(Guid));

                case ODBC32.SQL_C.TYPE_TIMESTAMP:
                {
                    //So we are mapping this ourselves.
                    //typedef struct tagTIMESTAMP_STRUCT
                    //{
                    //      SQLSMALLINT    year;
                    //      SQLUSMALLINT   month;
                    //      SQLUSMALLINT   day;
                    //      SQLUSMALLINT   hour;
                    //      SQLUSMALLINT   minute;
                    //      SQLUSMALLINT   second;
                    //      SQLUINTEGER    fraction;    (billoniths of a second)
                    //}

        //          return (DateTime)Marshal.PtrToStructure(buffer, typeof(DateTime));
                    Debug.Assert(16 <= Length, "Native buffer too small ");
                    return  new DateTime(
                        Marshal.ReadInt16(buffer, 0),           //year
                        Marshal.ReadInt16(buffer, 2),           //month
                        Marshal.ReadInt16(buffer, 4),           //day
                        Marshal.ReadInt16(buffer, 6),           //hour
                        Marshal.ReadInt16(buffer, 8),           //mintue
                        Marshal.ReadInt16(buffer, 10),          //second
                        Marshal.ReadInt32(buffer, 12)/1000000   //milliseconds
                        );
                }

                // Note: System does not provide a date-only type
                case ODBC32.SQL_C.TYPE_DATE:
                {
                    //  typedef struct tagDATE_STRUCT
                    //  {
                    //      SQLSMALLINT    year;
                    //      SQLUSMALLINT   month;
                    //      SQLUSMALLINT   day;
                    //  } DATE_STRUCT;

                    return  new DateTime(
                        Marshal.ReadInt16(buffer, 0),           //year
                        Marshal.ReadInt16(buffer, 2),           //month
                        Marshal.ReadInt16(buffer, 4)            //day
                        );
                }                    

                // Note: System does not provide a date-only type
                case ODBC32.SQL_C.TYPE_TIME:
                {
                    //  typedef struct tagTIME_STRUCT
                    //  {
                    //      SQLUSMALLINT   hour;
                    //      SQLUSMALLINT   minute;
                    //      SQLUSMALLINT   second;
                    //  } TIME_STRUCT;

                    return  new TimeSpan(
                        Marshal.ReadInt16(buffer, 0),           //hours
                        Marshal.ReadInt16(buffer, 2),           //minutes
                        Marshal.ReadInt16(buffer, 4)           //seconds
                        );
                    }

                case ODBC32.SQL_C.NUMERIC:
                {
                    //Note: Unfortunatly the ODBC NUMERIC structure and the URT DECIMAL structure do not
                    //align, so we can't so do the typical "PtrToStructure" call (below) like other types
                    //We actually have to go through the pain of pulling our raw bytes and building the decimal
                    //  Marshal.PtrToStructure(buffer, typeof(decimal));

                    //So we are mapping this ourselves
                    //typedef struct tagSQL_NUMERIC_STRUCT
                    //{
                    //  SQLCHAR     precision;
                    //  SQLSCHAR    scale;
                    //  SQLCHAR     sign;   /* 1 if positive, 0 if negative */
                    //  SQLCHAR     val[SQL_MAX_NUMERIC_LEN];
                    //} SQL_NUMERIC_STRUCT;
                    Debug.Assert(19 <= Length, "Native buffer too small ");
                    return new Decimal(
                        Marshal.ReadInt32(buffer, 3),       //val(low)
                        Marshal.ReadInt32(buffer, 7),       //val(mid)
                        Marshal.ReadInt32(buffer, 11),      //val(hi)
                        Marshal.ReadByte(buffer, 2) == 0,   //sign(isnegative)
                        Marshal.ReadByte(buffer, 1)         //scale
        //              Marshal.ReadByte(buffer, 0),        //precision
                    );
                }

                default:
                    throw ODC.UnknownSQLCType(sqlctype);
            };
        }

        internal void MarshalToNative(object value, ODBC32.SQL_C sqlctype, byte precision) {
            IntPtr buffer = this.Ptr;
            switch(sqlctype)
            {
/*            
#if DEBUG
                case ODBC32.SQL_C.CHAR:
                    Debug.Assert(false, "should have bound as SQL_C.WCHAR");
                    goto default;
#endif
*/
                case ODBC32.SQL_C.WCHAR:
                {
                    //Note: We always bind as unicode
                    //Note: StructureToPtr fails indicating string it a non-blittable type
                    //and there is no MarshalStringTo* that moves to an existing buffer,
                    //they all alloc and return a new one, not at all what we want...

                    //So we have to copy the raw bytes of the string ourself?!
                    Char[] rgChars = ((string)value).ToCharArray();
                    EnsureAlloc((rgChars.Length+1) * 2);
                    buffer = this.Ptr;      // Realloc may have changed buffer address
                    Marshal.Copy(rgChars, 0, buffer, rgChars.Length);
                    Marshal.WriteInt16(buffer, rgChars.Length * 2, 0); // Add the null terminator
                    break;
                }

                case ODBC32.SQL_C.BINARY:
                case ODBC32.SQL_C.CHAR:
                {
                    Byte[] rgBytes = (Byte[])value;
                    EnsureAlloc(rgBytes.Length+1);
                    buffer = this.Ptr;      // Realloc may have changed buffer address
                    Marshal.Copy(rgBytes, 0, buffer, rgBytes.Length);
                    break;
                }

                case ODBC32.SQL_C.UTINYINT:
                    Debug.Assert((Length >= 1), "Native buffer too small ");
                    Marshal.WriteByte(buffer, (Byte)value);
                    break;

                case ODBC32.SQL_C.SSHORT:   //Int16
                    Debug.Assert((Length >= 2), "Native buffer too small ");
                    Marshal.WriteInt16(buffer, (Int16)value);
                    break;
                case ODBC32.SQL_C.SLONG:    //Int32
                case ODBC32.SQL_C.REAL:     //float
                    Debug.Assert((Length >= 4), "Native buffer too small ");
                    Marshal.StructureToPtr(value, buffer, false/*deleteold*/);
                    break;
                case ODBC32.SQL_C.SBIGINT:  //Int64
                case ODBC32.SQL_C.DOUBLE:   //Double
                    Debug.Assert((Length >= 8), "Native buffer too small ");
                    Marshal.StructureToPtr(value, buffer, false/*deleteold*/);
                    break;
                case ODBC32.SQL_C.GUID:     //Guid
                    //All of these we can just delegate
                    Debug.Assert(16 <= Length, "Native buffer too small ");
                    Marshal.StructureToPtr(value, buffer, false/*deleteold*/);
                    break;

                case ODBC32.SQL_C.BIT:
                    Debug.Assert((Length >= 1), "Native buffer too small ");
                    Marshal.WriteByte(buffer, (Byte)(((bool)value) ? 1 : 0));
                    break;

                case ODBC32.SQL_C.TYPE_TIMESTAMP:
                {
                    //typedef struct tagTIMESTAMP_STRUCT
                    //{
                    //      SQLSMALLINT    year;
                    //      SQLUSMALLINT   month;
                    //      SQLUSMALLINT   day;
                    //      SQLUSMALLINT   hour;
                    //      SQLUSMALLINT   minute;
                    //      SQLUSMALLINT   second;
                    //      SQLUINTEGER    fraction;    (billoniths of a second)
                    //}

                    //We have to map this ourselves, due to the different structures between
                    //ODBC TIMESTAMP and URT DateTime, (ie: can't use StructureToPtr)

                    Debug.Assert(16 <= Length, "Native buffer too small ");
                    DateTime datetime = (DateTime)value;
                    Marshal.WriteInt16(buffer, 0,   (short)datetime.Year);          //year
                    Marshal.WriteInt16(buffer, 2,   (short)datetime.Month);         //month
                    Marshal.WriteInt16(buffer, 4,   (short)datetime.Day);           //day
                    Marshal.WriteInt16(buffer, 6,   (short)datetime.Hour);          //hour
                    Marshal.WriteInt16(buffer, 8,   (short)datetime.Minute);        //minute
                    Marshal.WriteInt16(buffer, 10,  (short)datetime.Second);        //second
                    Marshal.WriteInt32(buffer, 12,  datetime.Millisecond*1000000);  //fraction
                    break;
                }

                // Note: System does not provide a date-only type
                case ODBC32.SQL_C.TYPE_DATE:
                {
                    //  typedef struct tagDATE_STRUCT
                    //  {
                    //      SQLSMALLINT    year;
                    //      SQLUSMALLINT   month;
                    //      SQLUSMALLINT   day;
                    //  } DATE_STRUCT;

                    Debug.Assert(6 <= Length, "Native buffer too small ");
                    DateTime datetime = (DateTime)value;
                    Marshal.WriteInt16(buffer, 0,   (short)datetime.Year);          //year
                    Marshal.WriteInt16(buffer, 2,   (short)datetime.Month);         //month
                    Marshal.WriteInt16(buffer, 4,   (short)datetime.Day);           //day
                    break;
                }                    

                // Note: System does not provide a date-only type
                case ODBC32.SQL_C.TYPE_TIME:
                {
                    //  typedef struct tagTIME_STRUCT
                    //  {
                    //      SQLUSMALLINT   hour;
                    //      SQLUSMALLINT   minute;
                    //      SQLUSMALLINT   second;
                    //  } TIME_STRUCT;

                    Debug.Assert(6 <= Length, "Native buffer too small ");
                    TimeSpan timespan = (TimeSpan)value;
                    Marshal.WriteInt16(buffer, 0,   (short)timespan.Hours);          //hours
                    Marshal.WriteInt16(buffer, 2,   (short)timespan.Minutes);        //minutes
                    Marshal.WriteInt16(buffer, 4,  (short)timespan.Seconds);        //seconds
                    break;
                }

                case ODBC32.SQL_C.NUMERIC:
                {
                    //Note: Unfortunatly the ODBC NUMERIC structure and the URT DECIMAL structure do not
                    //align, so we can't so do the typical "PtrToStructure" call (below) like other types
                    //We actually have to go through the pain of pulling our raw bytes and building the decimal
                    //  Marshal.PtrToStructure(buffer, typeof(decimal));

                    //So we are mapping this ourselves
                    //typedef struct tagSQL_NUMERIC_STRUCT
                    //{
                    //  SQLCHAR     precision;
                    //  SQLSCHAR    scale;
                    //  SQLCHAR     sign;
                    //  SQLCHAR     val[SQL_MAX_NUMERIC_LEN];
                    //} SQL_NUMERIC_STRUCT;
                    int[] parts = Decimal.GetBits((Decimal)value);
                    byte[] bits = BitConverter.GetBytes(parts[3]);

                    Debug.Assert(19 <= Length, "Native buffer too small ");
                    Marshal.WriteByte(buffer,   0,  (Byte)precision);           //precision
                    Marshal.WriteByte(buffer,   1,  bits[2]);     //Bits 16-23 scale
                    Marshal.WriteByte(buffer,   2,  (Byte) ((0 == bits[3]) ? 1 : 0));    //Bit 31 - sign(isnegative)

                    Marshal.WriteInt32(buffer,  3,  parts[0]);      //val(low)
                    Marshal.WriteInt32(buffer,  7,  parts[1]);      //val(mid)
                    Marshal.WriteInt32(buffer,  11, parts[2]);      //val(hi)
                    Marshal.WriteInt32(buffer,  15, 0);      //val(xhi)
                    break;
                }

                default:
                    throw ODC.UnknownSQLCType(sqlctype);

            };
        }
    }


    sealed internal class CStringTokenizer
    {
        StringBuilder _token;
        String      _sqlstatement;
        char        _quote;         // typically the semicolon '"'
        char        _escape;        // typically the backslash '\'
        int         _len = 0;
        int         _idx = 0;

        public  CStringTokenizer(char quote, char escape)
        {
            _token = new StringBuilder();
            _quote = quote;
            _escape = escape;
        }
            
        public  int  Length
        {
              get{ return _len; }
        }

        public int CurrentPosition
        {
              get{ return _idx; }
        }

        public String Statement
        {
              get{ return _sqlstatement; }
              set {
                _sqlstatement = value;
                if (value != null) {
                    _len = _sqlstatement.Length;
                }
                else {
                    _len = 0;
                }
                _idx = 0;
                if (_token.Length != 0) {
                    _token.Remove(0, _token.Length);
                }
              }
        }


        // Returns the next token in the statement, advancing the current index to
        //  the start of the token
        public String NextToken()
        {
            if (_token.Length != 0) {                   // if we've read a token before
                _idx += _token.Length;                  // proceed the internal marker (_idx) behind the token
                _token.Remove(0, _token.Length);        // and start over with a fresh token
            }

            while((_idx < _len) && Char.IsWhiteSpace(_sqlstatement[_idx]))  // skip whitespace
                _idx++;
            
            if (_idx == _len)                           // return if string is empty
                return String.Empty;
                        
            int curidx = _idx;                          // start with internal index at current index
            bool endtoken = false;                      // 

            // process characters until we reache the end of the token or the end of the string
            //
            while (!endtoken && curidx < _len) {
                if (IsValidNameChar(_sqlstatement[curidx])) {
                    while ((curidx < _len) && IsValidNameChar(_sqlstatement[curidx])) {
                        _token.Append(_sqlstatement[curidx]);
                        curidx++;
                    }
                }
                else {   
                    switch(_sqlstatement[curidx])
                    {
                    case '[':
                        curidx = GetTokenFromBracket(curidx);
                        break;
                    case '\'':
                        curidx = GetTokenFromQuote(curidx, _escape);
                        break;
                    case '"':
                        curidx = GetTokenFromQuote(curidx, _quote);
                        break;
                    default:
                        // Some other marker like , ; ( or )
                        if (!Char.IsWhiteSpace(_sqlstatement[curidx])) {
                            _token.Append(_sqlstatement[curidx]);
                        }
                        endtoken = true;
                        break;
                    }
                }          
            }
                
            return (_token.Length > 0) ? _token.ToString() : String.Empty ;

        }

        internal int GetTokenFromBracket(int curidx)
        {
            Debug.Assert((_sqlstatement[curidx] == '['), "GetTokenFromQuote: character at starting position must be same as quotechar");
            while (curidx < _len) {
                _token.Append(_sqlstatement[curidx]);
                curidx++;
                if (_sqlstatement[curidx-1] == ']') 
                    break;
            }
            return curidx;
        }
        


        // attempts to complete an encapsulated token (e.g. "scott")
        // escaped quotes are valid part of the token (e.g. "fi\"sh")
        // double quotes are valid part of the tokne (e.g. "foo""bar")
        //
        internal int GetTokenFromQuote(int curidx, char quotechar)
        {
            Debug.Assert((_sqlstatement[curidx] == quotechar), "GetTokenFromQuote: character at starting position must be same as quotechar");

            int localidx = curidx;                                    // start with local index at current index
            while (localidx < _len) {                               // run to the end of the statement
                _token.Append(_sqlstatement[localidx]);             // append current character to token
                if (_sqlstatement[localidx] == quotechar) {
                    if(localidx > curidx) {                           // don't care for the first char
                        if (_sqlstatement[localidx-1] != _escape) {    // if it's not \" then we look at the following char
                            if (localidx+1 < _len) {                // do not overrun the end of the string
                                if (_sqlstatement[localidx+1] != quotechar) {
                                    return localidx+1;              // We've reached the end of the quoted text
                                }
                            }
                        }
                    }
                }
                localidx++;
            }
            return localidx;
        }
       
        internal bool IsValidNameChar(char ch)
        {
            return (Char.IsLetterOrDigit(ch) ||
                    (ch == '_') || (ch == '-') ||(ch == '.') ||
                    (ch == '$') || (ch == '#') || (ch == '@') ||
                    (ch == '~') || (ch == '`') || (ch == '%') ||
                    (ch == '^') || (ch == '&') || (ch == '|') ) ;
        }
        
        // Searches for the token given, starting from the current position
        // If found, positions the currentindex at the 
        // beginning of the token if found.
        public int FindTokenIndex(String tokenString, bool caseIgnore)
        {
            String nextToken;
            while (true) {
                nextToken = NextToken();
                if ((_idx == _len) || ADP.IsEmpty(nextToken)) { // fxcop
                    break;
                }
                if (caseIgnore == false) { // simple comparision (case sensitive)
                    if (tokenString == nextToken) return _idx;
                }
                else { // extended comparision (case insensitive)
                    if (String.Compare(tokenString, nextToken, caseIgnore, System.Globalization.CultureInfo.InvariantCulture) == 0) 
                        return _idx;
                }
            }
            return -1;
        }

        public void ResetPosition() 
        {
            _idx = 0;
            if (_token.Length != 0) {
                _token.Remove(0, _token.Length);
            }

        }

        // Skips the white space found in the beginning of the string.
        public bool StartsWith(String tokenString, bool caseIgnore)
        {
            int     tempidx = 0;
            bool    foundstarts;
            while((tempidx < _len) && Char.IsWhiteSpace(_sqlstatement[tempidx]))
                tempidx++;
            if ((_len - tempidx) < tokenString.Length)
                return false;
            foundstarts = String.Compare(_sqlstatement, tempidx, tokenString, 0, tokenString.Length, caseIgnore, System.Globalization.CultureInfo.InvariantCulture) == 0;
            if (foundstarts) {
                // Reset current position and token
                _idx = 0;
                NextToken();                   
            }
            return foundstarts;       
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace System.Data.Odbc {

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Security;
    using System.Security.Permissions;


    /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermission"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    [Serializable] sealed public class OdbcPermission :  DBDataPermission {

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermission.OdbcPermission"]/*' />
        [ Obsolete("use OdbcPermission(PermissionState.None)", true) ]
        public OdbcPermission() {
        }

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermission.OdbcPermission1"]/*' />
        public OdbcPermission(PermissionState state) : base(state) {
        }

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermission.OdbcPermission2"]/*' />
        [ Obsolete("use OdbcPermission(PermissionState.None)", true) ]
        public OdbcPermission(PermissionState state, bool allowBlankPassword) : base(state, allowBlankPassword) {
        }

        private OdbcPermission(OdbcPermission permission) : base(permission) { // for Copy
        }

        internal OdbcPermission(OdbcPermissionAttribute permissionAttribute) : base(permissionAttribute) { // for CreatePermission
        }

        internal OdbcPermission(OdbcConnectionString constr) : base(constr) { // for Open
        }

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermission.Add"]/*' />
        override public void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior) {
            switch(behavior) {
            case KeyRestrictionBehavior.PreventUsage:
            case KeyRestrictionBehavior.AllowOnly:
                break;
            default:
                throw ADP.Argument("value");
            }
            DBConnectionString entry = new OdbcConnectionString(connectionString, restrictions, behavior); // MDAC 85142
            base.AddPermissionEntry(entry);
        }

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermission.Copy"]/*' />
        override public IPermission Copy () {
            return new OdbcPermission(this);
        }
    }
    
    /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    [Serializable()] sealed public class OdbcPermissionAttribute : DBDataPermissionAttribute {

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermissionAttribute.OdbcPermissionAttribute"]/*' />
        public OdbcPermissionAttribute(SecurityAction action) : base(action) {
		}

        /// <include file='doc\OdbcPermission.uex' path='docs/doc[@for="OdbcPermissionAttribute.CreatePermission"]/*' />
        override public IPermission CreatePermission() {
            return new OdbcPermission(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\odbc\odbcrowupdatingevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="OdbcRowUpdatingEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Data.Common;       //DbDataAdapter
using System.ComponentModel;    //Component

namespace System.Data.Odbc
{
    //-----------------------------------------------------------------------
    // Event Handlers
    //
    //-----------------------------------------------------------------------
    /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatingEventHandler"]/*' />
    public delegate void OdbcRowUpdatingEventHandler(object sender, OdbcRowUpdatingEventArgs e);
    /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatedEventHandler"]/*' />
    public delegate void OdbcRowUpdatedEventHandler(object sender, OdbcRowUpdatedEventArgs e);

    //-----------------------------------------------------------------------
    // OdbcRowUpdatingEventArgs
    //
    //-----------------------------------------------------------------------
    /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatingEventArgs"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcRowUpdatingEventArgs : RowUpdatingEventArgs 
    {
        /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatingEventArgs.OdbcRowUpdatingEventArgs"]/*' />
        public OdbcRowUpdatingEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) 
        : base(row, command, statementType, tableMapping) 
        {
        }

        /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatingEventArgs.Command"]/*' />
        new public OdbcCommand Command 
        {
            get {   return(OdbcCommand)base.Command;    }
            set {   base.Command = value;               }
        }
    }

    //-----------------------------------------------------------------------
    // OdbcRowUpdatedEventArgs
    //
    //-----------------------------------------------------------------------
    /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatedEventArgs"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OdbcRowUpdatedEventArgs : RowUpdatedEventArgs 
    {
        /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatedEventArgs.OdbcRowUpdatedEventArgs"]/*' />
        public OdbcRowUpdatedEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
        : base(row, command, statementType, tableMapping) 
        {
        }

        /// <include file='doc\OdbcRowUpdatingEvent.uex' path='docs/doc[@for="OdbcRowUpdatedEventArgs.Command"]/*' />
        new public OdbcCommand Command 
        {
            get {   return(OdbcCommand) base.Command;   }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\dbpropset.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBPropSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Permissions;

namespace System.Data.OleDb {

    /// <include file='doc\DBPropSet.uex' path='docs/doc[@for="DBPropSet"]/*' />
    sealed internal class DBPropSet {
        internal int totalPropertySetCount;
        internal IntPtr nativePropertySet;

        private IntPtr rgProperties;
        private Int32 cProperties;
        private Guid guidPropertySet;
        private int currentPropertySetIndex;

        private Int32 dwPropertyID;
        private Int32 dwStatus;
        private int currentPropertyIndex;

        ~DBPropSet() {
            Dispose(false);
        }

        internal void Dispose() {
            Dispose(true);
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            if (IntPtr.Zero != this.nativePropertySet) {
                for (int i = 0, offset = 0; i < this.totalPropertySetCount; ++i, offset += ODB.SizeOf_tagDBPROPSET) {
                    rgProperties = Marshal.ReadIntPtr(this.nativePropertySet, offset);
                    if(IntPtr.Zero != rgProperties) {
                        cProperties = Marshal.ReadInt32(this.nativePropertySet, offset + IntPtr.Size);

                        long vptr = rgProperties.ToInt64() + ODB.SizeOf_tagDBPROP - ODB.SizeOf_Variant;
                        for (int k = 0; k < cProperties; ++k, vptr += ODB.SizeOf_tagDBPROP) {
                            SafeNativeMethods.VariantClear((IntPtr)vptr);
                        }
                        Marshal.FreeCoTaskMem(rgProperties);
                        rgProperties = IntPtr.Zero;
                        cProperties = 0;
                    }
                }
                Marshal.FreeCoTaskMem(this.nativePropertySet);
                this.nativePropertySet = IntPtr.Zero;
            }
        }

        internal int PropertySetCount {
            get {
                return totalPropertySetCount;
            }
            set {
                Debug.Assert(0 < value, "PropertySetCount - zero size");
                Debug.Assert(0 == totalPropertySetCount, "PropertySetCount - already set");
                Debug.Assert(IntPtr.Zero == nativePropertySet, "PropertySetCount - memory already allocated");

                int byteCount = value * ODB.SizeOf_tagDBPROPSET;
                try {
                    nativePropertySet = Marshal.AllocCoTaskMem(byteCount);
                    SafeNativeMethods.ZeroMemory(nativePropertySet, byteCount);
                }
                catch(Exception e) {
                    Marshal.FreeCoTaskMem(nativePropertySet); // FreeCoTaskMem protects itself from IntPtr.Zero
                    nativePropertySet = IntPtr.Zero;
                    throw e;
                }
                GC.KeepAlive(this);

#if DEBUG
                ODB.TraceData_Alloc(nativePropertySet,  "DBPropSet - propertyset");
#endif
                totalPropertySetCount = value;

                Debug.Assert(IntPtr.Zero != nativePropertySet,  "PropertySetCount - no memory allocated");
            }
        }

        public static implicit operator HandleRef(DBPropSet x) {
            Debug.Assert(IntPtr.Zero != x.nativePropertySet, "null DataBuffer");
            return new HandleRef(x, x.nativePropertySet);
        }

        internal void ResetToReadSetPropertyResults() {
            currentPropertySetIndex = 0;
            currentPropertyIndex = 0;
        }

        //
        // DBPROPSET
        //
        internal int PropertyCount { // cProperties
            get {
                return cProperties;
            }
        }
        internal Guid PropertySet { // guidPropertySet
            get {
                return guidPropertySet;
            }
        }
        internal void ReadPropertySet() {
            Debug.Assert(IntPtr.Zero != nativePropertySet, "ReadPropertySet - no memory");
            Debug.Assert(currentPropertySetIndex < totalPropertySetCount, "ReadPropertySet too far");
            if ((currentPropertySetIndex < totalPropertySetCount) && (IntPtr.Zero != nativePropertySet)) { // guard against memory overflow

                IntPtr ptr = ADP.IntPtrOffset(nativePropertySet, currentPropertySetIndex * ODB.SizeOf_tagDBPROPSET);
                rgProperties = Marshal.ReadIntPtr(ptr, 0);
                cProperties = Marshal.ReadInt32(ptr, IntPtr.Size);

                ptr = ADP.IntPtrOffset(ptr, IntPtr.Size + 4);
                guidPropertySet = (Guid) Marshal.PtrToStructure(ptr, typeof(Guid));

                currentPropertySetIndex++;
                currentPropertyIndex = 0;
                GC.KeepAlive(this);
            }
        }
        private void WritePropertySet() {
            Debug.Assert(0 < PropertyCount, "PropertyCount - zero size");
            Debug.Assert(IntPtr.Zero != nativePropertySet, "ReadPropertySet - no memory");
            Debug.Assert(currentPropertySetIndex < totalPropertySetCount, "WritePropertySet too far");
            if ((currentPropertySetIndex < totalPropertySetCount) && (IntPtr.Zero != nativePropertySet)) { // guard against memory overflow

                int byteCount = PropertyCount * ODB.SizeOf_tagDBPROP;
                IntPtr ptr = ADP.IntPtrOffset(nativePropertySet, currentPropertySetIndex * ODB.SizeOf_tagDBPROPSET);
                try {
                    rgProperties = Marshal.AllocCoTaskMem(byteCount);
                    SafeNativeMethods.ZeroMemory(rgProperties, byteCount);
#if DEBUG
                    ODB.TraceData_Alloc(rgProperties,  "DBPropSet - properties");
#endif
                    Marshal.WriteIntPtr(ptr, 0, rgProperties);
                    Marshal.WriteInt32(ptr, IntPtr.Size, cProperties);

                    IntPtr tmp = ADP.IntPtrOffset(ptr, IntPtr.Size + 4);
                    Marshal.StructureToPtr(guidPropertySet, tmp, false/*deleteold*/);
                }
                catch(Exception e) {
                    Marshal.WriteIntPtr(ptr, 0, IntPtr.Zero); // clear rgProperties
                    Marshal.WriteInt32(ptr, IntPtr.Size, 0); // clear cProperties
                    Marshal.FreeCoTaskMem(rgProperties); // FreeCoTaskMem protects itself from IntPtr.Zero
                    rgProperties = IntPtr.Zero;
                    cProperties = 0;
                    throw e;
                }

                currentPropertySetIndex++;
                currentPropertyIndex = 0;
                GC.KeepAlive(this);
            }
        }

        internal void WritePropertySet(Guid propertySet, int propertyCount) {
            Debug.Assert(0 < propertyCount, "PropertyCount - zero size");
            rgProperties    = IntPtr.Zero;
            guidPropertySet = propertySet;
            cProperties     = propertyCount;
            WritePropertySet();
        }

        //
        // DBPROP
        //
        internal int PropertyId { // dwPropertyID
            get {
                return dwPropertyID;
            }
        }
        internal int Status { // dwStatus
            get {
                return dwStatus;
            }
        }

        internal object ReadProperty() {
            object value = null;
            Debug.Assert(IntPtr.Zero != rgProperties, "ReadProperty no memory");
            Debug.Assert(currentPropertyIndex < PropertyCount, "ReadProperty too far");
            if ((currentPropertyIndex < PropertyCount) && (IntPtr.Zero != rgProperties)) { // guard against memory overflow

                IntPtr ptr = ADP.IntPtrOffset(rgProperties, currentPropertyIndex * ODB.SizeOf_tagDBPROP);
                dwPropertyID = Marshal.ReadInt32(ptr, 0);
                dwStatus = Marshal.ReadInt32(ptr, 8);

                ptr = ADP.IntPtrOffset(ptr, ODB.SizeOf_tagDBPROP - ODB.SizeOf_Variant);
                value = Marshal.GetObjectForNativeVariant(ptr);
                SafeNativeMethods.VariantClear(ptr);
                currentPropertyIndex++;

                if (currentPropertyIndex == PropertyCount) { // free this now so dispose does less work later
                    ptr = ADP.IntPtrOffset(nativePropertySet, (currentPropertySetIndex-1) * ODB.SizeOf_tagDBPROPSET);
                    Marshal.WriteIntPtr(ptr, 0, IntPtr.Zero);
                    Marshal.FreeCoTaskMem(rgProperties);
                    rgProperties = IntPtr.Zero;
                    cProperties = 0;

                    if (currentPropertySetIndex == PropertySetCount) {
                        Marshal.FreeCoTaskMem(this.nativePropertySet);
                        nativePropertySet = IntPtr.Zero;
                        totalPropertySetCount = 0;
                    }
                }
                GC.KeepAlive(this);
            }
            return value;
        }

        internal void WriteProperty(int propertyId, object value) {
            Debug.Assert(IntPtr.Zero != rgProperties, "ReadProperty no memory");
            Debug.Assert(currentPropertyIndex < PropertyCount, "WriteProperty too far");
            if ((currentPropertyIndex < PropertyCount) && (IntPtr.Zero != rgProperties)) { // guard against memory overflow

                IntPtr ptr = ADP.IntPtrOffset(rgProperties, currentPropertyIndex * ODB.SizeOf_tagDBPROP);
                Marshal.WriteInt32(ptr, 0, propertyId);
                Marshal.WriteInt32(ptr, 4, ODB.DBPROPOPTIONS_OPTIONAL);
                //Marshal.WriteInt32(ptr, 8, ODB.DBPROPSTATUS_OK); // is 0
                // all other properties had zero written just after the memory allocation

                ptr = ADP.IntPtrOffset(ptr, ODB.SizeOf_tagDBPROP - ODB.SizeOf_Variant);
                Marshal.GetNativeVariantForObject(value, ptr);

                currentPropertyIndex++;
                GC.KeepAlive(this);
            }
        }

        static internal DBPropSet CreateProperty(Guid propertySet, int propertyId, object value) {
            DBPropSet propertyset = new DBPropSet();
            propertyset.PropertySetCount = 1;
            propertyset.WritePropertySet(propertySet, 1);
            propertyset.WriteProperty(propertyId, value);
            return propertyset;
        }
    }

    sealed internal class PropertyIDSetWrapper {
        private IntPtr nativePropertyIDSet;

        ~PropertyIDSetWrapper() {
            Dispose(false);
        }

        internal void Dispose() {
            Dispose(true);
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            Marshal.FreeCoTaskMem(nativePropertyIDSet);
            nativePropertyIDSet = IntPtr.Zero;
        }


        public static implicit operator HandleRef(PropertyIDSetWrapper x) {
            Debug.Assert(IntPtr.Zero != x.nativePropertyIDSet, "null nativePropertyIDSet");
            return new HandleRef(x, x.nativePropertyIDSet);
        }

        internal void Initialize() {
            // cache the buffer since will be called several times over the lifetime of the connection
            // we do the buffer this way instead of new tagDBPROPIDSET and pinning a new int[] for the propertyid
            int bytecount = ODB.SizeOf_tagDBPROPIDSET + /*sizeof(int32)*/4;
            try {
                this.nativePropertyIDSet = Marshal.AllocCoTaskMem(bytecount);
                SafeNativeMethods.ZeroMemory(this.nativePropertyIDSet, bytecount);

                // the PropertyID is stored at the end of the tagDBPROPIDSET structure
                // this way only a single memory allocation is required instead of two
                IntPtr ptr = ADP.IntPtrOffset(this.nativePropertyIDSet, ODB.SizeOf_tagDBPROPIDSET);
                Marshal.WriteIntPtr(this.nativePropertyIDSet, 0, ptr);
                Marshal.WriteInt32(this.nativePropertyIDSet, IntPtr.Size, 1);
            }
            catch(Exception e) {
                Marshal.FreeCoTaskMem(this.nativePropertyIDSet);
                this.nativePropertyIDSet = IntPtr.Zero;
                throw e;
            }
            GC.KeepAlive(this);
        }

        internal void SetValue(Guid propertySet, int propertyId) {
            IntPtr ptr = ADP.IntPtrOffset(nativePropertyIDSet, IntPtr.Size + /*sizeof(int32)*/4);
            Marshal.StructureToPtr(propertySet, ptr, false/*deleteold*/);
            Marshal.WriteInt32(this.nativePropertyIDSet, ODB.SizeOf_tagDBPROPIDSET, propertyId);
            GC.KeepAlive(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbconnection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

// CLR thread information
// using mscorwks (singlethread.cs)
//      1 thread for concurrent gc
//      1 thread for finalizer
//      1 thread for debugger
//      1 thread for main thread
//      2 thread for OleDbServices
//      2 thread for interop
//      1 thread per processor for thread pool + as needed
//      = 8 thread for single thread app that uses System.Data.OleDb on 2proc (8 on 4p)
//      = 11 thread for threadpool app (perfharness) that uses System.Data.OleDb on 2proc (13 on 4p)
// using mscorsvr (perfharness using threadpool)
//      1 thread per proccessor for concurrent gc
//      1 thread for finalizer
//      1 thread for debugger
//      1 thread for main thread
//      1 thread per processor for thread pool + as needed
//      2 thread for interop
//      2 thread for OleDbServices
//      = 10 thread for single thread app that uses System.Data.OleDb on 2proc (15 on 4p)
//      = 13 thread for threadpool app (perfharness) that uses System.Data.OleDb on 2proc (17 on 4p)

namespace System.Data.OleDb {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection"]/*' />
    // wraps the OLEDB IDBInitialize interface which represents a connection
    // Notes about connection pooling
    // 1. Connection pooling isn't supported on Win95
    // 2. Only happens if we use the IDataInitialize or IDBPromptInitialize interfaces
    //    it won't happen if you directly create the provider and set its properties
    // 3. First call on IDBInitialize must be Initialize, can't QI for any other interfaces before that
    [
    DefaultEvent("InfoMessage")
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbConnection : Component, ICloneable, IDbConnection {

        // execpt for OleDbConnection.Open ConnectionString, only demand for the existance of OleDbPermission
        // during OleDbCommand.ExecuteXXX and OleDbConnection.ChangeDatabase
        // an additional check occurs if OLE DB Services is created for the first time via UDL file loading
        static private PermissionSet _OleDbPermission;

        static internal PermissionSet OleDbPermission {
            get {
                PermissionSet permission = _OleDbPermission;
                if (null == permission) {
                    _OleDbPermission = permission = OleDbConnectionString.CreatePermission(null);
                }
                return permission;
            }
        }

        static private OleDbWrapper idataInitialize;
        static private Hashtable cachedProviderProperties; // cached properties to reduce getting static provider properties

        private OleDbConnectionString _constr;
        private bool                  _hidePasswordPwd;

        private int objectState; /*ConnectionState.Closed*/

        // the "connection object".  Required OLE DB interfaces
        private UnsafeNativeMethods.IDBInitialize idbInitialize;

        // the "session object".  Required OLE DB interface
        private UnsafeNativeMethods.ISessionProperties isessionProperties;
        private OleDbWrapper _sessionwrp;

        private OleDbWeakReference weakReferenceCache;
        internal WeakReference weakTransaction;

        private Guid[] supportedSchemaRowsets;
        private int[] schemaRowsetRestrictions;

        private PropertySetInformation[] propertySetInformation;

        private PropertyIDSetWrapper propertyIDSet;

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.OleDbConnection"]/*' />
        //[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public OleDbConnection() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.OleDbConnection1"]/*' />
        //[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public OleDbConnection(string connectionString) : base() {
            GC.SuppressFinalize(this);
            ConnectionString = connectionString;
        }

        private OleDbConnection(OleDbConnection connection) : base() { // Clone
            GC.SuppressFinalize(this);
            _hidePasswordPwd = connection._hidePasswordPwd;
            _constr = connection._constr;
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.ConnectionString"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        RecommendedAsConfigurable(true),
        RefreshProperties(RefreshProperties.All),
        DataSysDescription(Res.OleDbConnection_ConnectionString),
        Editor("Microsoft.VSDesigner.Data.ADO.Design.OleDbConnectionStringEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public string ConnectionString {
            get {
                bool hidePasswordPwd = _hidePasswordPwd;
                OleDbConnectionString constr = _constr;
                return ((null != constr) ? constr.GetConnectionString(hidePasswordPwd) : ADP.StrEmpty);
            }
            set {
                OleDbConnectionString constr = OleDbConnectionString.ParseString(value);

                ConnectionState currentState = StateInternal;
                if (ConnectionState.Closed != currentState) {
                    throw ADP.OpenConnectionPropertySet(ADP.ConnectionString, currentState);
                }
                _constr = constr;
                _hidePasswordPwd = false;
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.ConnectionTimeout"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbConnection_ConnectionTimeout)
        ]
        public int ConnectionTimeout {
            get {
                object value = PropertyValueGet(ODB.Connect_Timeout, OleDbPropertySetGuid.DBInit, ODB.DBPROP_INIT_TIMEOUT);
                if (value is string) {
                    return Int32.Parse((string)value, NumberStyles.Integer, null);
                }
                else if (value is int) {
                    return (int) value;
                }
                return ADP.DefaultConnectionTimeout;
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.Database"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbConnection_Database)
        ]
        public string Database {
            get {
                if (0 == (ConnectionState.Open & StateInternal)) {
                    return Convert.ToString(PropertyValueGet(ODB.Initial_Catalog, OleDbPropertySetGuid.DBInit, ODB.DBPROP_INIT_CATALOG));
                }
                return Convert.ToString(PropertyValueGet(ODB.Current_Catalog, OleDbPropertySetGuid.DataSource, ODB.DBPROP_CURRENTCATALOG)); // MDAC 65047
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.DataSource"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbConnection_DataSource)
        ]
        public string DataSource {
            get {
                return Convert.ToString(PropertyValueGet(ODB.Data_Source, OleDbPropertySetGuid.DBInit, ODB.DBPROP_INIT_DATASOURCE));
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.Provider"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbConnection_Provider)
        ]
        public String Provider {
            get {
                OleDbConnectionString constr = _constr;
                if ((null != constr) && constr.Contains(ODB.Provider)) {
                    string value = (string) constr[ODB.Provider];
                    return ((null != value) ? value : ADP.StrEmpty);
                }
                return ADP.StrEmpty;
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.ServerVersion"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbConnection_ServerVersion)
        ]
        public string ServerVersion { // MDAC 55481
            get {
                if (0 != (ConnectionState.Open & StateInternal)) {
                    return Convert.ToString(PropertyValueGet(ODB.DBMS_Version, OleDbPropertySetGuid.DataSourceInfo, ODB.DBPROP_DBMSVER));
                }
                throw ADP.ClosedConnectionError(); // MDAC 60360
            }
        }

        internal int SqlSupport() {
            object value;
            if (0 == PropertyValueGetInitialCached(OleDbPropertySetGuid.DataSourceInfo, ODB.DBPROP_SQLSUPPORT, out value)) {
                return Convert.ToInt32(value);
            }
            return 0;
        }

        internal bool SupportMultipleResults() {
            object value;
            if (0 == PropertyValueGetInitialCached(OleDbPropertySetGuid.DataSourceInfo, ODB.DBPROP_MULTIPLERESULTS, out value)) {
                return (0 != Convert.ToInt32(value));
            }
            return false;
        }

        internal bool SupportIRow(OleDbCommand cmd) { // MDAC 72902
            object[] values;
            string lookupid = Provider + ODB.DBPROP_IRow.ToString();
            Hashtable hash = OleDbConnection.GetProviderPropertyCache();
            if (hash.Contains(lookupid)) {
                values = (object[]) hash[lookupid];

                // SQLOLEDB always returns VARIANT_FALSE for DBPROP_IROW, so base the answer on existance
                return (ODB.DBPROPSTATUS_OK == (int) values[1]);
            }
            object value = null;
            int support = ODB.DBPROPSTATUS_NOTSUPPORTED;
            if (null != cmd) {
                support = cmd.CommandProperties(ODB.DBPROP_IRow, out value);
            }
            values = new object[2] { value, support };
            try {
                lock(hash.SyncRoot) {
                    hash[lookupid] = values;
                }
            }
            catch { // MDAC 80973
                throw;
            }
            // SQLOLEDB always returns VARIANT_FALSE for DBPROP_IROW, so base the answer on existance
            return (ODB.DBPROPSTATUS_OK == support);
        }

        internal int QuotedIdentifierCase() { // MDAC 67385
            object value;
            if (0 == PropertyValueGetInitialCached(OleDbPropertySetGuid.DataSourceInfo, ODB.DBPROP_QUOTEDIDENTIFIERCASE, out value)) {
                return Convert.ToInt32(value);
            }
            return -1;
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.State"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DbConnection_State)
        ]
        public ConnectionState State {
            get {
                if ((ODB.InternalStateOpen == this.objectState) && !DesignMode) { // MDAC 58606
                    // if Executing or Fetching don't bother with ResetState because
                    // the exception handling code will call ResetState

                    // $CONSIDER: tracking last interaction time and only call if > a period of time
                    // i.e. only every 60sec or calling State twice in a row
                    ResetState();
                }
                return (ConnectionState) (ODB.InternalStateOpen & this.objectState);
            }
        }

        internal ConnectionState StateInternal {
            get {
                return (ConnectionState) this.objectState;
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.InfoMessage"]/*' />
        [
        DataCategory(Res.DataCategory_InfoMessage),
        DataSysDescription(Res.DbConnection_InfoMessage)
        ]
        public event OleDbInfoMessageEventHandler InfoMessage {
            add {
                Events.AddHandler(ADP.EventInfoMessage, value);
            }
            remove {
                Events.RemoveHandler(ADP.EventInfoMessage, value);
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.StateChange"]/*' />
        [
        DataCategory(Res.DataCategory_StateChange),
        DataSysDescription(Res.DbConnection_StateChange)
        ]
        public event StateChangeEventHandler StateChange {
            add {
                Events.AddHandler(ADP.EventStateChange, value);
            }
            remove {
                Events.RemoveHandler(ADP.EventStateChange, value);
            }
        }

        // grouping the native OLE DB casts togther by required interfaces and optional interfaces, connection then session
        // want these to be methods, not properties otherwise they appear in VS7 managed debugger which attempts to evaluate them

        // required interface, safe cast
        private UnsafeNativeMethods.IDBCreateSession IDBCreateSession() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "IDBCreateSession: null IDBInitialize");
            ODB.Trace_Cast("IDBInitialize", "IDBCreateSession", "CreateSession");
#endif
            return (UnsafeNativeMethods.IDBCreateSession) this.idbInitialize;
        }

        // required interface, safe cast
        private UnsafeNativeMethods.IDBProperties IDBProperties() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "IDBProperties: null IDBInitialize");
            ODB.Trace_Cast("IDBInitialize", "IDBProperties", "method");
#endif
            return (UnsafeNativeMethods.IDBProperties) this.idbInitialize;
        }

        // required interface, safe cast
        internal UnsafeNativeMethods.IOpenRowset IOpenRowset() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "IOpenRowset: null IDBInitialize");
            Debug.Assert(null != this.isessionProperties, "IOpenRowset: null ISessionProperties");
            ODB.Trace_Cast("ISessionProperties", "IOpenRowset", "OpenRowset");
#endif
            return (UnsafeNativeMethods.IOpenRowset) this.isessionProperties;
        }

        // optional interface, unsafe cast
        private UnsafeNativeMethods.IDBInfo IDBInfo() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "IDBInfo: null IDBInitialize");
            ODB.Trace_Cast("IDBInitialize", "IDBInfo", "GetKeywords, GetLiteralInfo");
#endif
            UnsafeNativeMethods.IDBInfo value = null;
            try {
                value = (UnsafeNativeMethods.IDBInfo) this.idbInitialize;
            }
            catch(InvalidCastException e) {
                ADP.TraceException(e);
            }
            return value;
        }

        // optional interface, unsafe cast
        private UnsafeNativeMethods.IDBCreateCommand IDBCreateCommand() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "IDBCreateCommand: null IDBInitialize");
            Debug.Assert(null != this.isessionProperties, "IDBCreateCommand: null ISessionProperties");
            ODB.Trace_Cast("ISessionProperties", "IDBCreateCommand", "CreateCommand");
#endif
            UnsafeNativeMethods.IDBCreateCommand value = null;
            try {
                //value = (UnsafeNativeMethods.IDBCreateCommand) this.isessionProperties;
                value = (_sessionwrp.ComWrapper as UnsafeNativeMethods.IDBCreateCommand); // MDAC 86633
            }
            catch(InvalidCastException e) { // MDAC 57856
                ADP.TraceException(e);
            }
            return value;
        }

        // optional interface, unsafe cast
        private UnsafeNativeMethods.IDBSchemaRowset IDBSchemaRowset() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "IDBSchemaRowset: null IDBInitialize");
            Debug.Assert(null != this.isessionProperties, "IDBSchemaRowset: null ISessionProperties");
            ODB.Trace_Cast("ISessionProperties", "IDBSchemaRowset", "GetSchemas");
#endif
            UnsafeNativeMethods.IDBSchemaRowset value = null;
            try {
                value = (UnsafeNativeMethods.IDBSchemaRowset) this.isessionProperties;
            }
            catch(InvalidCastException e) {
                ADP.TraceException(e);
            }
            return value;
        }

        // optional interface, unsafe cast
        private NativeMethods.ITransactionJoin ITransactionJoin() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "ITransactionJoin: null datasource");
            Debug.Assert(null != this.isessionProperties, "ITransactionJoin: null session");
            ODB.Trace_Cast("session", "ITransactionJoin", "generic");
#endif
            NativeMethods.ITransactionJoin value = null;
            try {
                //value = (NativeMethods.ITransactionJoin) this.isessionProperties;
                value = (_sessionwrp.ComWrapper as NativeMethods.ITransactionJoin); // MDAC 86633
            }
            catch(InvalidCastException e) {
                throw ODB.TransactionsNotSupported(Provider, e);
            }
            return value;
        }

        // optional interface, unsafe cast
        private UnsafeNativeMethods.ITransactionLocal ITransactionLocal() {
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "ITransactionLocal: null IDBInitialize");
            Debug.Assert(null != this.isessionProperties, "ITransactionLocal: null ISessionProperties");
            ODB.Trace_Cast("ISessionProperties", "ITransactionLocal", "generic");
#endif
            UnsafeNativeMethods.ITransactionLocal value = null;
            try {
                value = (UnsafeNativeMethods.ITransactionLocal) isessionProperties;
            }
            catch(InvalidCastException e) {
                throw ODB.TransactionsNotSupported(Provider, e);
            }
            return value;
        }

        internal UnsafeNativeMethods.ICommandText ICommandText() {
            UnsafeNativeMethods.ICommandText icommandText = null;
            UnsafeNativeMethods.IDBCreateCommand dbCreateCommand = null;
            try {
                dbCreateCommand = IDBCreateCommand();
                if (null != dbCreateCommand) {
                    int hr;
    #if DEBUG
                    ODB.Trace_Begin("IDBCreateCommand", "CreateCommand");
    #endif
                    hr = dbCreateCommand.CreateCommand(IntPtr.Zero, ODB.IID_ICommandText, out icommandText);
    #if DEBUG
                    ODB.Trace_End("IDBCreateCommand", "CreateCommand", hr);
                    Debug.Assert((0 <= hr) || (null == icommandText), "CreateICommandText: error with ICommandText");
    #endif
                    if (hr < 0) {
                        if (ODB.E_NOINTERFACE != hr) { // MDAC 57856
                            ProcessResults(hr);
                        }
                        else {
                            SafeNativeMethods.ClearErrorInfo();
                        }
                    }
                }
            }
            finally {
                if (null != dbCreateCommand) {
                    Marshal.ReleaseComObject(dbCreateCommand);
                }
            }
            return icommandText;
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.BeginTransaction"]/*' />
        public OleDbTransaction BeginTransaction(IsolationLevel isolationLevel) {
            OleDbConnection.OleDbPermission.Demand(); // MDAC 81476
            CheckStateOpen(ADP.BeginTransaction);
            if ((null != this.weakTransaction) && this.weakTransaction.IsAlive) { // regression from Dispose/Finalize work
                throw ADP.ParallelTransactionsNotSupported(this);
            }

            UnsafeNativeMethods.ITransactionLocal transactionLocal = ITransactionLocal();
            OleDbTransaction transaction = new OleDbTransaction(this);
            transaction.BeginInternal(transactionLocal, isolationLevel);
            this.weakTransaction = new WeakReference(transaction); // MDAC 69081
            return transaction;
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.IDbConnection.BeginTransaction"]/*' />
        /// <internalonly/>
        IDbTransaction IDbConnection.BeginTransaction(IsolationLevel isolationLevel) {
            return BeginTransaction(isolationLevel);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.BeginTransaction1"]/*' />
        public OleDbTransaction BeginTransaction() {
            return BeginTransaction(IsolationLevel.ReadCommitted);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.IDbConnection.BeginTransaction1"]/*' />
        /// <internalonly/>
        IDbTransaction IDbConnection.BeginTransaction() {
            return BeginTransaction(IsolationLevel.ReadCommitted);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.ChangeDatabase"]/*' />
        public void ChangeDatabase(string value) {
            OleDbConnection.OleDbPermission.Demand(); // MDAC 80961

            CheckStateOpen(ADP.ChangeDatabase);
            if ((null == value) || (0 == value.Trim().Length)) { // MDAC 62679
                throw ADP.EmptyDatabaseName();
            }
            PropertyValueSetInitial(OleDbPropertySetGuid.DataSource, ODB.DBPROP_CURRENTCATALOG, ODB.Current_Catalog, value);
        }

        internal void CheckStateOpen(string method) {
            ConnectionState currentState = StateInternal;
            if (ConnectionState.Open != currentState) {
                throw ADP.OpenConnectionRequired(method, currentState);
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            return new OleDbConnection(this);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.Close"]/*' />
        public void Close() {
            if (ODB.InternalStateClosed != this.objectState) {
                DisposeManaged();

                OnStateChange(ConnectionState.Open, ConnectionState.Closed);
            }
        }

        private void CloseConnection() {
            if (null != this.idbInitialize) {
#if false
    #if DEBUG
                ODB.Trace_Begin("IDBInitialize", "Uninitialize");
    #endif
                int hr = this.idbInitialize.Uninitialize();
    #if DEBUG
                ODB.Trace_End("IDBInitialize", "Uninitialize", hr);
    #endif
#endif

#if DEBUG
                ODB.Trace_Release("IDBInitialize");
#endif
                Marshal.ReleaseComObject(this.idbInitialize);
                this.idbInitialize = null;
            }
        }

        private void CloseSession() {
            OleDbWrapper wrp = _sessionwrp;
            if (null != wrp) {
                _sessionwrp = null;
                wrp.Dispose();
            }
            if (null != this.isessionProperties) {
                if (null != this.weakTransaction) {
                    IDisposable transaction = (IDisposable) this.weakTransaction.Target;
                    if ((null != transaction) && this.weakTransaction.IsAlive) {
                        // required to rollback any transactions on this connection
                        // before releasing the back to the oledb connection pool
                        transaction.Dispose();
                    }
                    this.weakTransaction = null;
                }
#if DEBUG
                ODB.Trace_Release("ISessionProperties");
#endif
                Marshal.ReleaseComObject(this.isessionProperties);
                this.isessionProperties = null;
            }
            Debug.Assert(null == this.weakTransaction, "transaction not rolled back");
        }

        internal void AddWeakReference(object value) {
            if (null == this.weakReferenceCache) {
                this.weakReferenceCache = new OleDbWeakReference(value);
            }
            else {
                this.weakReferenceCache.Add(value);
            }
        }

        internal void RemoveWeakReference(object value) {
            if (null != this.weakReferenceCache) {
                this.weakReferenceCache.Remove(value);
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.CreateCommand"]/*' />
        public OleDbCommand CreateCommand() {
            return new OleDbCommand("", this);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.IDbConnection.CreateCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbConnection.CreateCommand() {
            return CreateCommand();
        }

        private void CreateProvider(OleDbConnectionString constr) {
            Debug.Assert(null == this.idbInitialize, "CreateProvider: caller error, provider exists");
            UnsafeNativeMethods.IDataInitialize dataInitialize = OleDbConnection.GetObjectPool();
            int hr;

#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceWarning) {
                // @devnote: its a security hole to print with the password because of PersistSecurityInfo
                ODB.Trace_Begin(2, "IDataInitialize", "GetDataSource");
            }
#endif
#if USECRYPTO
            string encryptedActualConnectionString = constr.EncryptedActualConnectionString;
            byte[] actualConnectionString = new Byte[ADP.CharSize+ADP.CharSize*encryptedActualConnectionString.Length];
            GCHandle textHandle = GCHandle.Alloc(actualConnectionString, GCHandleType.Pinned);
            try {
                Crypto.DecryptToBlock(encryptedActualConnectionString, actualConnectionString, 0, actualConnectionString.Length-ADP.CharSize);
                Debug.Assert('\0' == actualConnectionString[actualConnectionString.Length-1], "missing null termination");
                Debug.Assert('\0' == actualConnectionString[actualConnectionString.Length-2], "missing null termination");
#else
                string actualConnectionString = constr.EncryptedActualConnectionString;
#endif
                hr = dataInitialize.GetDataSource(IntPtr.Zero, ODB.CLSCTX_ALL, actualConnectionString, ODB.IID_IDBInitialize, out this.idbInitialize);
#if USECRYPTO
            }
            finally {
                Array.Clear(actualConnectionString, 0, actualConnectionString.Length);
                if (textHandle.IsAllocated) {
                    textHandle.Free();
                }
                actualConnectionString = null;
            }
#endif
#if DEBUG
            ODB.Trace_End("IDataInitialize", "GetDataSource", hr);
#endif
            if ((hr < 0) || (null == this.idbInitialize)) { // ignore infomsg
                CreateProviderError(hr);
            }
        }

        private void CreateProviderError(int hr) {
            if (ODB.REGDB_E_CLASSNOTREG != hr) {
                ProcessResults(hr);
            }
            else {
                SafeNativeMethods.ClearErrorInfo();
            }
            Exception e = OleDbConnection.ProcessResults(hr, this, this);
            throw ODB.ProviderUnavailable(Provider, e);
        }

        private void CreateSession() {
            Debug.Assert(null == this.isessionProperties, "CreateSession: caller error, session exists");
            Debug.Assert(null != this.idbInitialize, "CreateSession: provider doesn't exist");

            int hr;
            UnsafeNativeMethods.IDBCreateSession dbCreateSession = IDBCreateSession();
#if DEBUG
            ODB.Trace_Begin("IDBCreateSession", "CreateSession");
#endif
            hr = dbCreateSession.CreateSession(IntPtr.Zero, ODB.IID_ISessionProperties, out this.isessionProperties);
#if DEBUG
            ODB.Trace_End("IDBCreateSession", "CreateSession", hr);
#endif
            if (hr < 0) { // ignore infomsg
                ProcessResults(hr);
            }

            Debug.Assert(null != this.isessionProperties, "CreateSession: null isessionProperties");

            _sessionwrp = new OleDbWrapper(this.isessionProperties); // MDAC 86633

            // instead of setting the following property to false which is a performance hit
            // wait until the user attempts to execute a second simultanous command
            // and if the OLE DB property exists and is true, then fail in managed code
            //PropertyValueSetInitial(OleDbPropertySetGuid.DataSource, ODB.DBPROP_MULTIPLECONNECTIONS, null, false);
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects

                if (ODB.InternalStateClosed != this.objectState) {
                    DisposeManaged();

                    if (DesignMode) {
                        // release the object pool in design-mode so that
                        // native MDAC can be properly released during shutdown
                        OleDbConnection.ReleaseObjectPool();
                    }
                    // everything after the event should be safe
                    // to not run in case the user throws an exception
                    OnStateChange(ConnectionState.Open, ConnectionState.Closed); // MDAC 67832
                }
                if (null != propertyIDSet) {
                    propertyIDSet.Dispose();
                    propertyIDSet = null;
                }
                // don't release the connection string until after the OnStateChange
                // so the user can track which connection closed
                _constr = null;
            }
            // release unmanaged objects
            base.Dispose(disposing); // notify base classes
        }

        private void DisposeManaged() { // clear the cached information
            this.supportedSchemaRowsets = null;
            this.schemaRowsetRestrictions = null;
            this.propertySetInformation = null;

            CloseReferences(false);
            CloseSession();
            CloseConnection();

            this.objectState = ODB.InternalStateClosed;
        }

        internal void CloseReferences(bool canceling) {
            if (null != this.weakReferenceCache) {
                this.weakReferenceCache.Close(canceling);
            }
        }

        internal bool RecoverReferences(object exceptfor) {
            bool recovered = true;
            if (null != this.weakReferenceCache) {
                recovered = this.weakReferenceCache.Recover(exceptfor);
            }
            if (recovered) { // MDAC 67411
                this.objectState &= (ODB.InternalStateConnecting | ODB.InternalStateOpen);
            }
            return recovered;
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.EnlistDistributedTransaction"]/*' />
        public void EnlistDistributedTransaction(System.EnterpriseServices.ITransaction transaction) { // MDAC 78997
            OleDbConnection.OleDbPermission.Demand(); // MDAC 81476
            //(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();

            ConnectionState currentState = State;
            if (ConnectionState.Open != currentState) {
                throw ADP.OpenConnectionPropertySet(ADP.ConnectionString, currentState);
            }
            if ((null != this.weakTransaction) && this.weakTransaction.IsAlive) {
                throw ADP.LocalTransactionPresent();
            }
            NativeMethods.ITransactionJoin transactionJoin = null;
            try {
                transactionJoin = ITransactionJoin();
                transactionJoin.JoinTransaction(transaction, (int) IsolationLevel.Unspecified, 0, IntPtr.Zero);
            }
            finally {
                if (null != transactionJoin) {
                    Marshal.ReleaseComObject(transactionJoin);
                }
            }
        }

        // use the property id and property sets to get the property values
        private Exception GetPropertyValueErrors(Exception inner) {
            if (null == this.idbInitialize) {
                return inner;
            }

            DBPropSet propSet = new DBPropSet();
            UnsafeNativeMethods.IDBProperties idbProperties = IDBProperties();

            int hr;
            IntPtr propIDSet = IntPtr.Zero;
            try {
                try {
                    // using native memory as a sideaffect of optimizing for
                    // the PropertyValueGetInitial scenario
                    propIDSet = Marshal.AllocCoTaskMem(ODB.SizeOf_tagDBPROPIDSET);
                    Marshal.WriteIntPtr(propIDSet, 0, IntPtr.Zero);
                    Marshal.WriteInt32(propIDSet, IntPtr.Size, 0);

                    IntPtr ptr = ADP.IntPtrOffset(propIDSet, IntPtr.Size + /*sizeof(int32)*/4); // MDAC 69539
                    Marshal.StructureToPtr(OleDbPropertySetGuid.PropertiesInError, ptr, false/*deleteold*/);

#if DEBUG
                    ODB.Trace_Begin("IDBProperties", "GetProperties", "PROPERTIESINERROR");
#endif
                    hr = idbProperties.GetProperties(1, new HandleRef(this, propIDSet), out propSet.totalPropertySetCount, out propSet.nativePropertySet);
#if DEBUG
                    ODB.Trace_End("IDBProperties", "GetProperties", hr, "PropertySetsCount = " + propSet.totalPropertySetCount);
#endif
                    if (hr < 0) {
                        SafeNativeMethods.ClearErrorInfo();
                    }
                }
                finally { // FreeCoTaskMem
                    Marshal.FreeCoTaskMem(propIDSet);
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return OleDbConnection.PropertyErrors(this, propSet, inner);
        }

        private object PropertyValueGet(string propertyName, Guid propertySet, int propertyID) {
            Debug.Assert(null != propertyName, "PropertyValueGet: bad propertyName");

            if ((null != this.idbInitialize) && !DesignMode) {
                object value = null;
                if (0 == PropertyValueGetInitial(propertySet, propertyID, out value)) {
                    if (!Convert.IsDBNull(value)) {
                        return value;
                    }
                    return null;
                }
            }
            // if the provider exists, but the property doesn't - return default
            OleDbConnectionString constr = _constr;
            if ((null != constr) && constr.Contains(propertyName)) {
                return constr[propertyName];
            }
            return null;
        }

        private int PropertyValueGetInitialCached(Guid propertySet, int propertyId, out object value) {
            object[] values;
            string lookupid = Provider + propertyId.ToString();
            Hashtable hash = OleDbConnection.GetProviderPropertyCache();
            if (hash.Contains(lookupid)) {
                values = (object[]) hash[lookupid];
                value = values[0];
                return (int) values[1];
            }
            int retValue = PropertyValueGetInitial(propertySet, propertyId, out value);

            values = new object[2] { value, retValue };
            try {
                lock(hash.SyncRoot) {
                    hash[lookupid] = values;
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return retValue;
        }

        internal PropertyIDSetWrapper PropertyIDSet(Guid propertySet, int propertyId) {
            if (null == propertyIDSet) {
                propertyIDSet = new PropertyIDSetWrapper();
                propertyIDSet.Initialize();
            }
            propertyIDSet.SetValue(propertySet, propertyId);
            return propertyIDSet;
        }

        private int PropertyValueGetInitial(Guid propertySet, int propertyId, out object value) {
            UnsafeNativeMethods.IDBProperties idbProperties = IDBProperties();

            DBPropSet propSet = new DBPropSet();
            PropertyIDSetWrapper propertyIDSet = PropertyIDSet(propertySet, propertyId);

            int hr;
#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_Begin("IDBProperties", "GetProperties", ODB.PLookup(propertyId));
            }
#endif
            hr = idbProperties.GetProperties(1, propertyIDSet, out propSet.totalPropertySetCount, out propSet.nativePropertySet);
#if DEBUG
            ODB.Trace_End("IDBProperties", "GetProperties", hr, "PropertySetsCount = " + propSet.totalPropertySetCount);
#endif
            GC.KeepAlive(propertyIDSet);
            return PropertyValueResults(hr, propSet, out value);
        }

        internal void PropertyValueSetInitial(Guid propertySet, int propertyId, string processFailure, object propertyValue) {
            DBPropSet propSet = DBPropSet.CreateProperty(propertySet, propertyId, propertyValue);
            UnsafeNativeMethods.IDBProperties idbProperties = IDBProperties();
            int hr;
#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_Begin("IDBProperties", "SetProperties", ODB.PLookup(propertyId));
            }
#endif
            hr = idbProperties.SetProperties(propSet.PropertySetCount, propSet);
#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_End("IDBProperties", "SetProperties", hr);
            }
#endif
            if (null != processFailure) {
                Exception e = OleDbConnection.ProcessResults(hr, this, this);
                if (ODB.DB_E_ERRORSOCCURRED == hr) {
                    Debug.Assert(null != e, "PropertyValueSetInitial: null innerException");
                    Debug.Assert(1 == propSet.PropertyCount, "PropertyValueSetInitial: 1 < PropertyCount");

                    propSet.ResetToReadSetPropertyResults(); // MDAC 72630
                    propSet.ReadPropertySet();
                    propSet.ReadProperty();

                    e = ODB.PropsetSetFailure(propSet.Status, processFailure, Provider, e);
                }
                if (null != e) {
                    throw e;
                }
            }
            else if (hr < 0) {
                SafeNativeMethods.ClearErrorInfo();
            }
            propSet.Dispose(); // MDAC 64040
        }

        private int PropertyValueResults(int hr, DBPropSet propSet, out object value) {
            value = null;
            int status = ODB.DBPROPSTATUS_NOTSUPPORTED;
            if (ODB.DB_E_ERRORSOCCURRED != hr) {
                if (hr < 0) {
                    ProcessResults(hr);
                }
                if (null != propSet) {
                    if (0 < propSet.PropertySetCount) {
                        propSet.ReadPropertySet();
                        if (0 < propSet.PropertyCount) {
                            value = propSet.ReadProperty();
                            status = propSet.Status;
                        }
                    }
                    propSet.Dispose();
                }
            }
            return status;
        }

        private DataTable BuildInfoLiterals() {
            UnsafeNativeMethods.IDBInfo dbInfo = IDBInfo();
            if (null == dbInfo) {
                return null;
            }

            DataTable table = new DataTable("DbInfoLiterals");
            DataColumn literalName  = new DataColumn("LiteralName", typeof(String));
            DataColumn literalValue = new DataColumn("LiteralValue", typeof(String));
            DataColumn invalidChars = new DataColumn("InvalidChars", typeof(String));
            DataColumn invalidStart = new DataColumn("InvalidStartingChars", typeof(String));
            DataColumn literal      = new DataColumn("Literal", typeof(Int32));
            DataColumn maxlen       = new DataColumn("Maxlen", typeof(Int32));

            table.Columns.Add(literalName);
            table.Columns.Add(literalValue);
            table.Columns.Add(invalidChars);
            table.Columns.Add(invalidStart);
            table.Columns.Add(literal);
            table.Columns.Add(maxlen);

            int hr;
            int literalCount = 0;
            IntPtr literalInfo = IntPtr.Zero, charBuffer = IntPtr.Zero;

            try {
                try {
#if DEBUG
                    ODB.Trace_Begin("IDBInfo", "GetLiteralInfo");
#endif
                    hr = dbInfo.GetLiteralInfo(0, null, out literalCount, out literalInfo, out charBuffer);
#if DEBUG
                    ODB.Trace_End("IDBInfo", "GetLiteralInfo", hr);
#endif

                    // All literals were either invalid or unsupported. The provider allocates memory for *prgLiteralInfo and sets the value of the fSupported element in all of the structures to FALSE. The consumer frees this memory when it no longer needs the information.
                    if (ODB.DB_E_ERRORSOCCURRED != hr) {
                        long offset = literalInfo.ToInt64();
                        UnsafeNativeMethods.tagDBLITERALINFO tag = new UnsafeNativeMethods.tagDBLITERALINFO();
                        for (int i = 0; i < literalCount; ++i, offset += ODB.SizeOf_tagDBLITERALINFO) {
                            Marshal.PtrToStructure((IntPtr)offset, tag);

                            DataRow row = table.NewRow();
                            row[literalName ] = ((OleDbLiteral) tag.it).ToString("G");
                            row[literalValue] = tag.pwszLiteralValue;
                            row[invalidChars] = tag.pwszInvalidChars;
                            row[invalidStart] = tag.pwszInvalidStartingChars;
                            row[literal     ] = tag.it;
                            row[maxlen      ] = tag.cchMaxLen;

                            table.Rows.Add(row);
                            row.AcceptChanges();
                        }
                        if (hr < 0) { // ignore infomsg
                            ProcessResults(hr);
                        }
                    }
                    else {
                        SafeNativeMethods.ClearErrorInfo();
                    }
                }
                finally { // FreeCoTaskMem
#if DEBUG
                    ODB.TraceData_Free(literalInfo, "literalInfo");
                    ODB.TraceData_Free(charBuffer, "charBuffer");
#endif
                    Marshal.FreeCoTaskMem(literalInfo); // FreeCoTaskMem protects itself from IntPtr.Zero
                    Marshal.FreeCoTaskMem(charBuffer);  // was allocated by provider
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return table;
        }

#if SCHEMAINFO
        private DataTable BuildInfoKeywords() {
            UnsafeNativeMethods.IDBInfo dbInfo = IDBInfo();
            if (null == dbInfo) {
                return null;
            }

            DataTable table = new DataTable("DbInfoKeywords");
            DataColumn keyword  = new DataColumn("Keyword", typeof(String));
            table.Columns.Add(keyword);

            int hr;
            string keywords;
#if DEBUG
            ODB.Trace_Begin("IDBInfo", "GetKeywords");
#endif
            hr = dbInfo.GetKeywords(out keywords);
#if DEBUG
            ODB.Trace_End("IDBInfo", "GetKeywords", hr);
#endif

            if (hr < 0) { // ignore infomsg
                ProcessResults(hr);
            }

            if (null != keywords) {
                string[] values = keywords.Split(ODB.KeywordSeparatorChar);
                for (int i = 0; i < values.Length; ++i) {
                    DataRow row = table.NewRow();
                    row[keyword] = values[i];

                    table.Rows.Add(row);
                    row.AcceptChanges();
                }
            }
            return table;
        }

        private DataTable BuildSchemaGuids() {
            GetSchemaRowsetInformation();

            DataTable table = new DataTable("SchemaGuids");
            DataColumn schemaGuid  = new DataColumn("Schema", typeof(Guid));
            DataColumn restrictionSupport = new DataColumn("RestrictionSupport", typeof(Int32));

            table.Columns.Add(schemaGuid);
            table.Columns.Add(restrictionSupport);

            Debug.Assert(null != this.supportedSchemaRowsets, "GetSchemaRowsetInformation should have thrown");
            if (null != this.supportedSchemaRowsets) {

                for (int i = 0; i < this.supportedSchemaRowsets.Length; ++i) {
                    DataRow row = table.NewRow();
                    row[schemaGuid] = this.supportedSchemaRowsets[i];
                    row[restrictionSupport] = this.schemaRowsetRestrictions[i];

                    table.Rows.Add(row);
                    row.AcceptChanges();
                }
            }
            return table;
        }
#endif

        internal string GetLiteralInfo(int literal) {
            UnsafeNativeMethods.IDBInfo dbInfo = IDBInfo();
            if (null == dbInfo) {
                return null;
            }
            string literalValue = null;
            IntPtr literalInfo = IntPtr.Zero, charBuffer = IntPtr.Zero;
            int literalCount = 0;
            int hr;

            try {
                try {
#if DEBUG
                    ODB.Trace_Begin("IDBInfo", "GetLiteralInfo",  "Literal=" + literal);
#endif
                    hr = dbInfo.GetLiteralInfo(1, new int[1] { literal}, out literalCount, out literalInfo, out charBuffer);
#if DEBUG
                    ODB.Trace_End("IDBInfo", "GetLiteralInfo", hr);
#endif

                    // All literals were either invalid or unsupported. The provider allocates memory for *prgLiteralInfo and sets the value of the fSupported element in all of the structures to FALSE. The consumer frees this memory when it no longer needs the information.
                    if (ODB.DB_E_ERRORSOCCURRED != hr) {
                        if ((1 == literalCount) && Marshal.ReadInt32(literalInfo, 12) == literal) {
                            literalValue = Marshal.PtrToStringUni(Marshal.ReadIntPtr(literalInfo, 0));
                        }
                        if (hr < 0) { // ignore infomsg
                            ProcessResults(hr);
                        }
                    }
                    else {
                        SafeNativeMethods.ClearErrorInfo();
                    }
                }
                finally { // FreeCoTaskMem
#if DEBUG
                    ODB.TraceData_Free(literalInfo, "literalInfo");
                    ODB.TraceData_Free(charBuffer, "charBuffer");
#endif
                    Marshal.FreeCoTaskMem(literalInfo); // FreeCoTaskMem protects itself from IntPtr.Zero
                    Marshal.FreeCoTaskMem(charBuffer);  // was allocated by provider
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return literalValue;
        }

        internal void GetLiteralQuotes(out string quotePrefix, out string quoteSuffix) {
            quotePrefix = GetLiteralInfo(/*DBLITERAL_QUOTE_PREFIX*/15);
            quoteSuffix = GetLiteralInfo(/*DBLITERAL_QUOTE_SUFFIX*/28);
            if (null == quotePrefix) {
                quotePrefix = "";
            }
            if (null == quoteSuffix) {
                quoteSuffix = quotePrefix;
            }
        }

        private void BuildPropertySetInformation() {
            UnsafeNativeMethods.IDBProperties idbProperties = IDBProperties();
            IntPtr rgPropertyInfoSets = IntPtr.Zero;
            IntPtr pDescBuffer = IntPtr.Zero;
            int cPropertySets;
            int hr;

            try {
                try {
#if DEBUG
                    ODB.Trace_Begin("IDBProperties", "GetPropertyInfo");
#endif
                    hr = idbProperties.GetPropertyInfo(0, IntPtr.Zero, out cPropertySets, out rgPropertyInfoSets, out pDescBuffer);
#if DEBUG
                    ODB.Trace_End("IDBProperties", "GetPropertyInfo", hr, "PropertySetsCount = " + cPropertySets.ToString());
#endif
                    if (0 <= hr) {
                        this.propertySetInformation = new PropertySetInformation[cPropertySets];

                        UnsafeNativeMethods.tagDBPROPINFO propinfo = new UnsafeNativeMethods.tagDBPROPINFO();
                        UnsafeNativeMethods.tagDBPROPINFOSET propinfoset = new UnsafeNativeMethods.tagDBPROPINFOSET();

                        long offsetInfoSet = rgPropertyInfoSets.ToInt64();
                        for (int i = 0; i < cPropertySets; ++i, offsetInfoSet += ODB.SizeOf_tagDBPROPINFOSET) {
                            Marshal.PtrToStructure(new IntPtr(offsetInfoSet), propinfoset);
                            try {
#if DEBUG
                                if (AdapterSwitches.OleDbTrace.TraceVerbose) {
                                    Debug.WriteLine("PropertySet=" + OleDbPropertySetGuid.GetTextFromValue(propinfoset.guidPropertySet) + " Count=" + propinfoset.cPropertyInfos.ToString());
                                }
#endif
                                PropertyInformation[] propinfos = new PropertyInformation[propinfoset.cPropertyInfos];

                                long offsetInfo = propinfoset.rgPropertyInfos.ToInt64();
                                long offsetValue = offsetInfo + ODB.SizeOf_tagDBPROPINFO - ODB.SizeOf_Variant;

                                for (int k = 0; k < propinfoset.cPropertyInfos; ++k, offsetInfo += ODB.SizeOf_tagDBPROPINFO, offsetValue += ODB.SizeOf_tagDBPROPINFO) {
                                    try {
                                        Marshal.PtrToStructure(new IntPtr(offsetInfo), propinfo);

                                        PropertyInformation propertyInfo = new PropertyInformation();
                                        propertyInfo.description = propinfo.pwszDescription;
                                        propertyInfo.propertyId = propinfo.dwPropertyID;
                                        propertyInfo.flags = propinfo.dwFlags;
                                        propertyInfo.type = propinfo.vtType;
                                        propertyInfo.value = Marshal.GetObjectForNativeVariant((IntPtr)offsetValue);
#if DEBUG
                                        if (AdapterSwitches.OleDbTrace.TraceVerbose) {
                                            Debug.WriteLine("\tPropertyID=" + ODB.PLookup(propertyInfo.propertyId) + " '" + propertyInfo.description + "'");
                                        }
#endif
                                        propinfos[k] = propertyInfo;
                                    }
                                    catch(Exception e) {
                                        ADP.TraceException(e);
                                    }
#if DEBUG
                                    ODB.TraceData_Free((IntPtr)offsetValue, "VariantClear");
#endif
                                    SafeNativeMethods.VariantClear((IntPtr)offsetValue);
                                }

                                this.propertySetInformation[i] = new PropertySetInformation(propinfoset.guidPropertySet, propinfos);
                            }
                            catch(Exception e) {
                                ADP.TraceException(e);
                            }
#if DEBUG
                            ODB.TraceData_Free(propinfoset.rgPropertyInfos, "propinfoset.rgPropertyInfos");
#endif
                            Marshal.FreeCoTaskMem(propinfoset.rgPropertyInfos); // FreeCoTaskMem protects itself from IntPtr.Zero
                        }
                    }
                }
                finally { // FreeCoTaskMem
#if DEBUG
                    ODB.TraceData_Free(pDescBuffer, "pDescBuffer");
                    ODB.TraceData_Free(rgPropertyInfoSets, "rgPropertyInfoSets");
#endif
                    Marshal.FreeCoTaskMem(pDescBuffer); // FreeCoTaskMem protects itself from IntPtr.Zero
                    Marshal.FreeCoTaskMem(rgPropertyInfoSets); // was allocated by provider
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        private void GetSchemaRowsetInformation() {
            if (null != this.supportedSchemaRowsets) {
                return;
            }
            UnsafeNativeMethods.IDBSchemaRowset dbSchemaRowset = IDBSchemaRowset();
            if (null == dbSchemaRowset) {
                return;
            }
            int schemaCount = 0;
            IntPtr schemaGuids = IntPtr.Zero;
            IntPtr schemaRestrictions = IntPtr.Zero;

            try {
                try {
#if DEBUG
                    if (AdapterSwitches.OleDbTrace.TraceInfo) {
                        ODB.Trace_Begin("IDBSchemaRowset", "GetSchemas");
                    }
#endif
                    int hr;
                    hr = dbSchemaRowset.GetSchemas(out schemaCount, out schemaGuids, out schemaRestrictions);

#if DEBUG
                    if (AdapterSwitches.OleDbTrace.TraceInfo) {
                        ODB.Trace_End("IDBSchemaRowset", "GetSchemas", hr);
                    }
#endif
                    dbSchemaRowset = null;
                    if (hr < 0) { // ignore infomsg
                        ProcessResults(hr);
                    }

                    Guid[] schemaRowsets = new Guid[schemaCount];
                    int[] restrictions = new int[schemaCount];

                    if (IntPtr.Zero != schemaGuids) {
                        byte[] guid = new byte[16];
                        for (int i = 0, offset = 0; i < schemaCount; ++i, offset += 16) {
                            Marshal.Copy(ADP.IntPtrOffset(schemaGuids, offset), guid, 0, 16);
                            schemaRowsets[i] = new Guid (guid);
                        }
                    }
                    if (IntPtr.Zero != schemaRestrictions) {
                        Marshal.Copy(schemaRestrictions, restrictions, 0, schemaCount);
                    }
                    this.supportedSchemaRowsets = schemaRowsets;
                    this.schemaRowsetRestrictions = restrictions;
                }
                finally { // FreeCoTaskMem
#if DEBUG
                    ODB.TraceData_Free(schemaGuids, "schemaGuids");
                    ODB.TraceData_Free(schemaRestrictions, "schemaRestrictions");
#endif
                    Marshal.FreeCoTaskMem(schemaGuids); // FreeCoTaskMem protects itself from IntPtr.Zero
                    Marshal.FreeCoTaskMem(schemaRestrictions); // was allocated by provider
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.GetOleDbSchemaTable"]/*' />
        public DataTable GetOleDbSchemaTable(Guid schema, object[] restrictions) { // MDAC 61846
            OleDbConnection.OleDbPermission.Demand(); // MDAC 80961

            if (0 == (ConnectionState.Open & StateInternal)) {
                throw ADP.ClosedConnectionError();
            }
            if (OleDbSchemaGuid.DbInfoLiterals == schema) {
                if ((null == restrictions) || (0 == restrictions.Length)) {
                    return BuildInfoLiterals();
                }
                throw ODB.InvalidDbInfoLiteralRestrictions("restrictions");
            }
#if SCHEMAINFO
            else if (OleDbSchemaGuid.SchemaGuids == schema) {
                if ((null == restrictions) || (0 == restrictions.Length)) {
                    return BuildSchemaGuids();
                }
                throw ODB.InvalidRestrictionsSchemaGuids("restrictions");
            }
            else if (OleDbSchemaGuid.DbInfoKeywords == schema) {
                if ((null == restrictions) || (0 == restrictions.Length)) {
                    return BuildInfoKeywords();
                }
                throw ODB.InvalidRestrictionsInfoKeywords("restrictions");
            }
#endif
            int support = 0;
            if (SupportSchemaRowset(schema, out support)) {
                return GetSchemaRowset(schema, restrictions);
            }
            else if (null == IDBSchemaRowset()) {
                throw ODB.SchemaRowsetsNotSupported(Provider); // MDAC 72689
            }
            throw ODB.NotSupportedSchemaTable(schema, this); // MDAC 63279
        }

        internal DataTable GetSchemaRowset(Guid schema, object[] restrictions) {
            if (null == restrictions) { // MDAC 62243
                restrictions = new object[0];
            }
            DataTable dataTable = null;
            UnsafeNativeMethods.IDBSchemaRowset dbSchemaRowset = IDBSchemaRowset();
            if (null == dbSchemaRowset) {
                throw ODB.SchemaRowsetsNotSupported(Provider);
            }

            UnsafeNativeMethods.IRowset rowset = null;
            int hr;

#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_Begin("IDBSchemaRowset", "GetRowset", OleDbSchemaGuid.GetTextFromValue(schema));
                if (AdapterSwitches.OleDbTrace.TraceVerbose && (0 < restrictions.Length)) {
                    Debug.Write("restriction[]=" + ADP.ValueToString(restrictions[0]));
                    for (int i = 1; i < restrictions.Length; ++i) {
                        Debug.Write(", " + ADP.ValueToString(restrictions[i]));
                    }
                    Debug.WriteLine("");
                }
            }
#endif
            hr = dbSchemaRowset.GetRowset(IntPtr.Zero, schema, restrictions.Length, restrictions, ODB.IID_IRowset, 0, IntPtr.Zero, out rowset);
#if DEBUG
            ODB.Trace_End("IDBSchemaRowset", "GetRowset", hr);
#endif

            if (hr < 0) { // ignore infomsg
                ProcessResults(hr);
            }

            if (null != rowset) {
                dataTable = OleDbDataReader.DumpToTable(this, rowset);
                dataTable.TableName = OleDbSchemaGuid.GetTextFromValue(schema);
            }
            return dataTable;
        }

        private void OnInfoMessage(UnsafeNativeMethods.IErrorInfo errorInfo, int errorCode, object src) {
            OleDbInfoMessageEventHandler handler = (OleDbInfoMessageEventHandler) Events[ADP.EventInfoMessage];
            if (null != handler) {
                try {
                    OleDbInfoMessageEventArgs e = new OleDbInfoMessageEventArgs(errorInfo, errorCode, src);
#if DEBUG
                    if (AdapterSwitches.DataError.TraceWarning) {
                        Debug.WriteLine(e);
                    }
#endif
                    handler(this, e);
                }
                catch (Exception e) { // eat the exception
                    ADP.TraceException(e);
                }
            }
#if DEBUG
            else if (AdapterSwitches.DataError.TraceWarning || AdapterSwitches.OleDbTrace.TraceWarning) {
                Debug.WriteLine(new OleDbInfoMessageEventArgs(errorInfo, errorCode, src));
            }
#endif
        }

        private void OnStateChange(ConnectionState original, ConnectionState state) {
            StateChangeEventHandler handler = (StateChangeEventHandler) Events[ADP.EventStateChange];
            if (null != handler) {
                handler(this, new StateChangeEventArgs(original, state));
            }
        }

        private void InitializeProvider() {
            int hr;
#if DEBUG
            Debug.Assert(null != this.idbInitialize, "InitializeProvider: null IDBInitialize");
            ODB.Trace_Begin("IDBInitialize", "Initialize");
#endif
            hr = this.idbInitialize.Initialize();
#if DEBUG
            ODB.Trace_End("IDBInitialize", "Initialize", hr);
#endif

            if (ODB.DB_E_ALREADYINITIALIZED == hr) {
                SafeNativeMethods.ClearErrorInfo();
                // object was in a bogus state, but we can recover
                // just eat it, may fire an infomessage event
                hr = 0;
            }
            ProcessResults(hr); // may throw an exception
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.Open"]/*' />
        public void Open() {
            OleDbConnectionString constr = _constr;
            OleDbConnectionString.Demand(constr);  // MDAC 59651, 62038

            try {
                try {
                    // Without the Connecting state, a race condition exists between the OleDbPermission.Demand and the actual
                    // IDataInitialize.GetDataSource with the user attempting to change ConnectionString on a different thread
                    int state = Interlocked.CompareExchange(ref this.objectState, ODB.InternalStateConnecting, ODB.InternalStateClosed);
                    if (ODB.InternalStateClosed != state) {
                        throw ADP.ConnectionAlreadyOpen((ConnectionState) state);
                    }

                    if ((null == constr) || constr.IsEmpty()) {
                        throw ADP.NoConnectionString();
                    }

                    CreateProvider(constr);

                    InitializeProvider();

                    CreateSession(); // MDAC 63533

                    _hidePasswordPwd = true;
                    this.objectState = ODB.InternalStateOpen;
                }
                finally { // Close
                    if (ODB.InternalStateOpen != this.objectState) {
                        CloseSession();
                        CloseConnection();

                        this.objectState = ODB.InternalStateClosed;
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
            if (ODB.InternalStateOpen == this.objectState) { // MDAC 82470
                OnStateChange(ConnectionState.Closed, ConnectionState.Open);
            }
        }

        private void ProcessResults(int hr) {
            Exception e = OleDbConnection.ProcessResults(hr, this, this);
            if (null != e) { throw e; }
        }

        private void ResetState() { // MDAC 58606
            Debug.Assert (0 != (ConnectionState.Open & StateInternal), "ResetState - connection not open");
            object value;
            if (0 == PropertyValueGetInitial(OleDbPropertySetGuid.DataSourceInfo, ODB.DBPROP_CONNECTIONSTATUS, out value)) {
                int connectionStatus = Convert.ToInt32(value);
                switch (connectionStatus) {
                case ODB.DBPROPVAL_CS_UNINITIALIZED: // provider closed on us
                case ODB.DBPROPVAL_CS_COMMUNICATIONFAILURE: // broken connection
                    CloseReferences(true); // MDAC 71435
                    Close();
                    break;

                case ODB.DBPROPVAL_CS_INITIALIZED: // everything is okay
                    break;

                default: // have to assume everything is okay
                    Debug.Assert(false, "Unknown 'Connection Status' value " + (connectionStatus).ToString());
                    break;
                }
            }
        }

        internal void SetStateExecuting(OleDbCommand attempt, string method, bool flag) { // MDAC 65877, 65988
            if (flag) {
                int state = Interlocked.CompareExchange(ref this.objectState, ODB.InternalStateExecuting, ODB.InternalStateOpen);
                if (ODB.InternalStateOpen != state) {
                    RecoverReferences(attempt); // recover for a potentially finalized reader

                    state = Interlocked.CompareExchange(ref this.objectState, ODB.InternalStateExecuting, ODB.InternalStateOpen);

                    if (ODB.InternalStateOpen != state) { // MDAC 67411
                        if (ODB.InternalStateFetching == this.objectState) {
                            throw ADP.OpenReaderExists(); // MDAC 66411
                        }
                        throw ADP.OpenConnectionRequired(method, (ConnectionState) state);
                    }
                }
            }
            else {
#if DEBUG
                switch(this.objectState) {
                case ODB.InternalStateClosed:
                case ODB.InternalStateOpen:
                case ODB.InternalStateExecuting:
                case ODB.InternalStateFetching:
                    break;
                default:
                    Debug.Assert(false, "SetStateExecuting(false): " + StateInternal.ToString("G"));
                    break;
                }
#endif
                this.objectState &= ODB.InternalStateExecutingNot;
            }
        }

        internal void SetStateFetching(bool flag) { // MDAC 65877, 65988
            // SetStateFetching(false) could occur due to OleDbCommand.AttemptCommandRecovery
            if (flag) {
#if DEBUG
                switch(this.objectState) {
                case ODB.InternalStateExecuting:
                    break;
                default:
                    Debug.Assert(false, "SetStateFetching(true): " + StateInternal.ToString("G"));
                    break;
                }
#endif
                this.objectState = ODB.InternalStateFetching;
            }
            else {
#if DEBUG
                switch(this.objectState) {
                case ODB.InternalStateClosed:
                case ODB.InternalStateFetching:
                    break;
                case ODB.InternalStateOpen:
                default:
                    Debug.Assert(false, "SetStateFetching(false): " + StateInternal.ToString("G"));
                    break;
                }
#endif
                this.objectState &= ODB.InternalStateFetchingNot;
            }
        }

        internal bool SupportSchemaRowset(Guid schema, out int support) {
            support = 0;
            GetSchemaRowsetInformation();
            if (null != this.supportedSchemaRowsets) { // MDAC 68385
                for (int i = 0; i < this.supportedSchemaRowsets.Length; ++i) {
                    if (schema == this.supportedSchemaRowsets[i]) {
                        support = this.schemaRowsetRestrictions[i];
                        return true;
                    }
                }
            }
            return false;
        }

        internal OleDbTransaction ValidateTransaction(OleDbTransaction transaction) {
            if (null != this.weakTransaction) {

                OleDbTransaction head = (OleDbTransaction) this.weakTransaction.Target;
                if ((null != head) && this.weakTransaction.IsAlive) {
                    head = OleDbTransaction.TransactionUpdate(head);

                    // either we are wrong or finalize was called and object still alive
                    Debug.Assert(null != head, "unexcpted Transaction state");
                }
                // else transaction has finalized on user

                if (null != head) {
                    if (null == transaction) {
                        // valid transaction exists and cmd doesn't have it
                        throw ADP.TransactionRequired();
                    }
                    else {
                        OleDbTransaction tail = OleDbTransaction.TransactionLast(head);
                        if (tail != transaction) {
                            if (tail.parentConnection != transaction.parentConnection) {
                                throw ADP.TransactionConnectionMismatch();
                            }
                            // else cmd has incorrect transaction
                            throw ADP.TransactionCompleted();
                        }
                        // else cmd has correct transaction
                        return transaction;
                    }
                }
                else { // cleanup for Finalized transaction
                    this.weakTransaction = null;
                }
            }
            else if ((null != transaction) && (null != transaction.Connection)) { // MDAC 72706
                throw ADP.TransactionConnectionMismatch();
            }
            // else no transaction and cmd is correct

            // MDAC 61649
            // if transactionObject is from this connection but zombied
            // and no transactions currently exists - then ignore the bogus object
            return null;
        }

        // @devnote: should be multithread safe access to OleDbConnection.idataInitialize,
        // though last one wins for setting variable.  It may be different objects, but
        // OLE DB will ensure I'll work with just the single pool
        static private UnsafeNativeMethods.IDataInitialize GetObjectPool() {
            OleDbWrapper wrapper = OleDbConnection.idataInitialize;
            if (null == wrapper) {
                try {
                    lock(typeof(OleDbConnection)) { // CONSIDER: do we care about this lock?
                        wrapper = OleDbConnection.idataInitialize;
                        if (null == wrapper) {
                            IntPtr dataInitialize = CreateInstanceMDAC();
                            wrapper = new OleDbWrapper(dataInitialize);
                            OleDbConnection.idataInitialize = wrapper;
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
            Debug.Assert(null != wrapper, "GetObjectPool: null dataInitialize");
            return wrapper.IDataInitialize();
        }

        static private IntPtr CreateInstanceDataLinks() {
            try { // try-filter-finally so and catch-throw
                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Assert(); // MDAC 62028
                try {
                    return UnsafeNativeMethods.CoCreateInstance(ODB.CLSID_DataLinks, IntPtr.Zero, ODB.CLSCTX_ALL, ODB.IID_IDataInitialize);
                }
                finally { // RevertAssert w/ catch-throw
                    CodeAccessPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }

        static private IntPtr CreateInstanceMDAC() {

            // $REVIEW: do we still need this?
            // if ApartmentUnknown, then CoInitialize may not have been called yet
            if (ApartmentState.Unknown == Thread.CurrentThread.ApartmentState) {

                // we are defaulting to a multithread apartment state
                Thread.CurrentThread.ApartmentState = ApartmentState.MTA;
            }

            IntPtr dataInitialize = IntPtr.Zero;
            try {
                dataInitialize = CreateInstanceDataLinks();
            }
            catch (SecurityException e) {
                ADP.TraceException(e);
                throw ODB.MDACSecurityDeny(e);
            }
            catch (Exception e) {
                ADP.TraceException(e);
                throw ODB.MDACNotAvailable(e);
            }
            if (IntPtr.Zero == dataInitialize) {
                throw ODB.MDACNotAvailable(null);
            }

            string filename = String.Empty; // MDAC 80945
            try {
                filename = (string)ADP.ClassesRootRegistryValue(ODB.DataLinks_CLSID, String.Empty);
                Debug.Assert(!ADP.IsEmpty(filename), "created MDAC but can't find it");
            }
            catch (SecurityException e) {
                ADP.TraceException(e);
                throw ODB.MDACSecurityHive(e);
            }

            try {
                FileVersionInfo versionInfo = ADP.GetVersionInfo(filename);
                int major = versionInfo.FileMajorPart;
                int minor = versionInfo.FileMinorPart;
                int build = versionInfo.FileBuildPart;
                // disallow any MDAC version before MDAC 2.6 rtm
                // include MDAC 2.51 that ships with Win2k
                if ((major < 2) || ((major == 2) && ((minor < 60) || ((minor == 60) && (build < 6526))))) { // MDAC 66628
                    throw ODB.MDACWrongVersion(versionInfo.FileVersion);
                }
            }
            catch (SecurityException e) {
                ADP.TraceException(e);
                throw ODB.MDACSecurityFile(e);
            }
            return dataInitialize;
        }

        static private Hashtable GetProviderPropertyCache() {
            Hashtable hash = OleDbConnection.cachedProviderProperties;
            if (null == hash) {
                try {
                    lock(typeof(OleDbConnection)) {
                        hash = OleDbConnection.cachedProviderProperties;
                        if (null == hash) {
                            hash = new Hashtable();
                            OleDbConnection.cachedProviderProperties = hash;
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
            return hash;
        }

        static internal Exception ProcessResults(int hResult, OleDbConnection connection, object src) {
            if ((0 <= hResult) && ((null == connection) || (null == connection.Events[ADP.EventInfoMessage]))) {
                SafeNativeMethods.ClearErrorInfo();
                return null;
            }

            // ErrorInfo object is to be checked regardless the hResult returned by the function called
            UnsafeNativeMethods.IErrorInfo errorInfo = null;
            int hr = UnsafeNativeMethods.GetErrorInfo(0, out errorInfo);  // 0 - IErrorInfo exists, 1 - no IErrorInfo
            if ((0 == hr) && (null != errorInfo)) {
                if (hResult < 0) {
                    Exception e;
                    // UNDONE: if authentication failed - throw a unique exception object type
                    //if (/*OLEDB_Error.DB_SEC_E_AUTH_FAILED*/unchecked((int)0x80040E4D) == hr) {
                    //}
                    //else if (/*OLEDB_Error.DB_E_CANCELED*/unchecked((int)0x80040E4E) == hr) {
                    //}
                    // else {
                    e = new OleDbException(errorInfo, hResult, null);
                    //}

                    if (ODB.DB_E_ERRORSOCCURRED == hResult) {
                        Exception f = null;
                        if (src is OleDbConnection) {
                            f = ((OleDbConnection) src).GetPropertyValueErrors(e);
                            //connection.OnInfoMessage(new OleDbInfoMessageEventArgs(errorInfo, hResult, src));
                        }
                        else if (src is OleDbCommand) {
                            f = ((OleDbCommand) src).PropertyValueErrors(e);
                            //connection.OnInfoMessage(new OleDbInfoMessageEventArgs(errorInfo, hResult, src));
                        }
                        if (null != f) {
                            e = f;
                        }
                    }
                    if ((null != connection) && (0 != (ODB.InternalStateOpen & connection.objectState))) {
                        connection.ResetState();
                    }
                    return ADP.TraceException(e);
                }
                else if (null != connection) {
                    connection.OnInfoMessage(errorInfo, hResult, src);
                }
                else {
                    Debug.Assert(null != connection, "info message event without connection");
#if DEBUG
                    if (AdapterSwitches.OleDbTrace.TraceWarning) {
                        Debug.WriteLine("ProcessResults: error info available, but no connection: " + ODB.ELookup(hResult));
                    }
#endif
                }
            }
            else if (0 <= hResult) {
                /*if (ODB.DB_S_ERRORSOCCURRED == hResult) {
                    if (src is OleDbConnection) {
                        //((OleDbConnection) src).GetPropertyValueErrors(); // UNDONE - see MDAC BUG 27327
                        //connection.OnInfoMessage(new OleDbInfoMessageEventArgs(errorInfo, hResult, src));
                    }
                    else if (src is OleDbCommand) {
                        //((OleDbCommand) src).PropertyValueErrors(); // UNDONE - see MDAC BUG 27327
                        //connection.OnInfoMessage(new OleDbInfoMessageEventArgs(errorInfo, hResult, src));
                    }
                }*/
#if DEBUG
                // @devnote: OnInfoMessage with no ErrorInfo
                if ((0 < hResult) && AdapterSwitches.OleDbTrace.TraceWarning) {
                    Debug.WriteLine("InfoMessage with no ErrorInfo: " + ODB.ELookup(hResult));
                }
#endif
            }
            else {
                Exception nested = ODB.NoErrorInformation(hResult, null);

                if (ODB.DB_E_ERRORSOCCURRED == hResult) {
                    Exception e = null;
                    if (src is OleDbConnection) {
                        e = ((OleDbConnection) src).GetPropertyValueErrors(nested); // UNDONE - see MDAC BUG 27327
                        //if ((null == e) || (e == nested)) { // MDAC 70980
                        //    e = ODB.ConnectionPropertyErrors(((OleDbConnection) src).ConnectionString, nested);
                        //}
                    }
                    else if (src is OleDbCommand) {
                        e = ((OleDbCommand) src).PropertyValueErrors(nested); // UNDONE - see MDAC BUG 27327
                        //if ((null == e) || (e == nested)) { // MDAC 70980
                        //    e = ODB.CommandPropertyErrors(((OleDbCommand) src).CommandText, nested);
                        //}
                    }
                    if (null != e) {
                        nested = e;
                    }
                }
                if ((null != connection) && (0 != (ODB.InternalStateOpen & connection.objectState))) {
                    connection.ResetState();
                }
                return nested;
            }
            return null;
        }

        // UNDONE - getting specific property error values
        // Se MDAC BUG 27327 - SC: GetProperties(..DBPROPSET_PROPERTIESINERROR..) should be passed to underlying provider if Initialize returns DB_E_ERRORSOCCURRED
        // this will free if required everything in rgPropertySets
        static internal Exception PropertyErrors(OleDbConnection connection, DBPropSet propSet, Exception inner) {
            if (null != propSet) {
                int propsetSetCount = propSet.PropertySetCount;
                for (int i = 0; i < propsetSetCount; ++i) {
                    propSet.ReadPropertySet();

                    int count = propSet.PropertyCount;

                    PropertySetInformation propertySetInformation = null;
                    if (null != connection) {
                        if (null == connection.propertySetInformation) {
                            connection.BuildPropertySetInformation();
                        }
                        propertySetInformation = PropertySetInformation.FindPropertySet(connection.propertySetInformation, propSet.PropertySet);
                    }

#if DEBUG
                    if (AdapterSwitches.OleDbTrace.TraceWarning) {
                        Debug.WriteLine("PropertiesInError=" + OleDbPropertySetGuid.GetTextFromValue(propSet.PropertySet) + " Count=" + count.ToString());
                    }
#endif
                    for (int k = 0; k < count; ++k) {
                        object propertyValue = propSet.ReadProperty();
#if DEBUG
                        if (AdapterSwitches.OleDbTrace.TraceWarning) {
                            Debug.WriteLine("\tPropertyID = " + ODB.PLookup(propSet.PropertyId));
                            Debug.WriteLine("\tStatus     = " + propSet.Status);
                            Debug.WriteLine("\tValue      = " + ADP.ValueToString(propertyValue));
                        }
#endif
                        if (null != propertySetInformation) {
                            PropertyInformation propertyInformation = propertySetInformation.FindProperty(propSet.PropertyId);
#if DEBUG
                            if (AdapterSwitches.OleDbTrace.TraceWarning) {
                                Debug.WriteLine("\tDescription = " + propertyInformation.description);
                                Debug.WriteLine("\tPropertyID  = " + ODB.PLookup(propertyInformation.propertyId));
                                Debug.WriteLine("\tFlags       = " + propertyInformation.flags);
                                Debug.WriteLine("\tType        = " + propertyInformation.type);
                                Debug.WriteLine("\tValue       = " + ADP.ValueToString(propertyInformation.value));
                            }
#endif
                            Debug.Assert(null != connection, "PropertyErrors: null connection");
                            inner = ODB.PropsetSetFailure(propSet.Status, propertyInformation.description, connection.Provider, inner);
                        }
                    }
                }
                propSet.Dispose();
            }
            return inner;
        }

        /// <include file='doc\OleDbConnection.uex' path='docs/doc[@for="OleDbConnection.ReleaseObjectPool"]/*' />
        // @devnote: should be multithread safe
        static public void ReleaseObjectPool() {
            OleDbConnection.idataInitialize = null;
            OleDbConnection.cachedProviderProperties = null;
        }

        sealed private class PropertyInformation {
            internal string description;
            internal Int32 propertyId;
            internal Int32 flags;
            internal Int16 type;
            internal object value;
        }

        sealed private class PropertySetInformation {
            private Guid propertySet;
            private PropertyInformation[] propertyInformation;

            internal PropertySetInformation(Guid propertySet, PropertyInformation[] propertyInformation) {
                this.propertySet = propertySet;
                this.propertyInformation = propertyInformation;
            }

            internal PropertyInformation FindProperty(int propertyId) {
                if (null != this.propertyInformation) {
                    int count = this.propertyInformation.Length;
                    for (int i = 0; i < count; ++i) {
                        PropertyInformation value = this.propertyInformation[i];
                        if ((null != value) && (propertyId == value.propertyId)) {
                            return value;
                        }
                    }
                }
                return null;
            }

            static internal PropertySetInformation FindPropertySet(PropertySetInformation[] propertySets, Guid propertySet) {
                if (null != propertySets) {
                    int count = propertySets.Length;
                    for (int i = 0; i < count; ++i) {
                        PropertySetInformation value = propertySets[i];
                        if ((null != value) && (propertySet == value.propertySet)) {
                            return value;
                        }
                    }
                }
                return null;
            }
        }

        sealed private class OleDbWeakReference : WeakReferenceCollection {

            internal OleDbWeakReference(object value) : base(value) {
            }

            override protected bool CloseItem(object value, bool canceling) {
                if (value is OleDbCommand) {
                    ((OleDbCommand) value).CloseFromConnection(canceling);
                    return false; // do not set WeakReference.Target to null
                }
                else if (value is OleDbDataReader) {
                    ((OleDbDataReader) value).CloseFromConnection(canceling);
                    return true; // set WeakReference.Target to null
                }
                Debug.Assert(false, "shouldn't be here");
                return false;
            }

            override protected bool RecoverItem(object value) {
                if (value is OleDbCommand) {
                    return ((OleDbCommand) value).IsClosed;
                }
                else if (value is OleDbDataReader) {
                    return ((OleDbDataReader) value).IsClosed;
                }
                Debug.Assert(false, "shouldn't be here");
                return false;
            }
        }

        sealed private class OleDbWrapper {
            private IntPtr iunknown;

            ~OleDbWrapper() {
                if (IntPtr.Zero != this.iunknown) {
                    Marshal.Release(this.iunknown);
                    this.iunknown = IntPtr.Zero;
                }
            }

            internal OleDbWrapper(IntPtr ptr) {
                this.iunknown = ptr;
            }

            internal OleDbWrapper(object obj) {
                this.iunknown = Marshal.GetIUnknownForObject(obj);
            }

            public void Dispose() {
                if (ADP.PtrZero != iunknown) {
                    Marshal.Release(iunknown);
                    iunknown = ADP.PtrZero;
                }
                GC.KeepAlive(this);
                GC.SuppressFinalize(this);
            }

            internal object ComWrapper {
                get {
                    object value = System.Runtime.Remoting.Services.EnterpriseServicesHelper.WrapIUnknownWithComObject(iunknown);
                    GC.KeepAlive(this); // MDAC 79539
                    return value;
                }
            }
            
            // the interface, safe cast
            internal UnsafeNativeMethods.IDataInitialize IDataInitialize() {
                return (ComWrapper as UnsafeNativeMethods.IDataInitialize);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbdatareader.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbDataReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#define FIXEDFETCH

namespace System.Data.OleDb {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Xml;

    /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader"]/*' />
    sealed public class OleDbDataReader : MarshalByRefObject, IDataReader, IEnumerable {

        // object model interaction
        private OleDbConnection connection;
        private OleDbCommand command;

        // DataReader owns the parameter bindings until CloseDataReader
        // this allows OleDbCommand.Dispose to not require OleDbDataReader.Dispose
        private DBBindings parameterBindings;

        // OLEDB interfaces
        private UnsafeNativeMethods.IMultipleResults imultipleResults;
        private UnsafeNativeMethods.IRowset irowset;
        private UnsafeNativeMethods.IRow irow;

        private IntPtr chapter; /*ODB.DB_NULL_HCHAPTER*/
        private int depth;
        private bool isClosed, isRead, _hasRows, _hasRowsReadCheck;

        long sequentialBytesRead;
        int sequentialOrdinal;

        // the bindings (+buffer) and accesssor handle
        // dbBinding[indexToAccessor[i]].CurrentIndex = indexToOrdinal[i]
        // where ordinalMap[i] == dbBinding[indexToAccessor[i]].Ordinal
        // and dataValue[indexMap[i]] == dbBinding[indexToAccessor[i]].Value
        private int[] indexToOrdinal;
        private int[] indexToAccessor;
        private int nextAccessorForRetrieval;

        // must increment the counter before retrieving value so that
        // if an exception is thrown, user can continue without erroring again
        private int nextValueForRetrieval;

        private DBBindings[] dbBindings;
        private IntPtr[] accessors;

        // record affected for the current dataset
        private int recordsAffected = -1;
        private bool useIColumnsRowset;
        private bool sequentialAccess;
        private bool singleRow;
        private CommandBehavior behavior;

        // cached information for Reading (rowhandles/status)
#if FIXEDFETCH
        private IntPtr rowHandle;
#else
        private IntPtr[] rowHandles;
#endif
        private IntPtr rowHandleNativeBuffer;

        private int currentRow = 0;
        private int rowFetchedCount = -1;

#if FIXEDFETCH
        // MDAC 70986 (==1 fails against Sample Provider)
        // UNDONE: consider using DBPROP_MAXROWS property, if (0 == DBPROP_MAXROWS) 20, else Math.Min
        private const int rowHandleFetchCount = /*20*/1; // MDAC 60111 (>1 fails against jet)
#else
        private int rowHandleFetchCount = 20; // MDAC 60111 (>1 fails against jet)
#endif
        // with CLR 2804.1, 20 vs. 1 only results in a small perf gain.

        private DataTable dbSchemaTable;

        private int fieldCount = -1;

        private MetaData[] metadata;
        private FieldNameLookup _fieldNameLookup;

        // ctor for an ICommandText, IMultipleResults, IRowset, IRow
        // ctor for an ADODB.Recordset, ADODB.Record or Hierarchial resultset
        internal OleDbDataReader(OleDbConnection connection, OleDbCommand command, int depth, IntPtr chapter) {
            this.connection = connection;
            this.command = command;
            if ((null != command) && (0 == depth)) {
                this.parameterBindings = command.TakeBindingOwnerShip();
            }
            this.depth = depth;
            this.chapter = chapter; // MDAC 69514

#if !FIXEDFETCH
            // if from ADODB, connection will be null
            if ((null == connection) || (IntPtr.Zero != chapter)) { // MDAC 59629
                this.rowHandleFetchCount = 1;
            }
#endif
        }

        private void Initialize(CommandBehavior behavior) {
            this.behavior = behavior;
            this.useIColumnsRowset = (0 != (CommandBehavior.KeyInfo & behavior));
            this.sequentialAccess  = (0 != (CommandBehavior.SequentialAccess & behavior)); // MDAC 60296
            if (0 == depth) { // MDAC 70886
                this.singleRow     = (0 != (CommandBehavior.SingleRow & behavior));
            }
            else {
                // only when the first datareader is closed will the connection close
                behavior &= ~CommandBehavior.CloseConnection; // MDAC 72901
            }
        }

        internal void InitializeIMultipleResults(object result, CommandBehavior behavior) {
            Initialize(behavior);
            this.imultipleResults = (UnsafeNativeMethods.IMultipleResults) result; // maybe null if no results
        }
        internal void InitializeIRowset(object result, int recordsAffected, CommandBehavior behavior) {
            Initialize(behavior);
            this.recordsAffected = recordsAffected;
            this.irowset = (UnsafeNativeMethods.IRowset) result; // maybe null if no results
        }
        internal void InitializeIRow(object result, int recordsAffected, CommandBehavior behavior) {
            Initialize(behavior);
            Debug.Assert(this.singleRow, "SingleRow not already set");
            this.singleRow = true;
            this.recordsAffected = recordsAffected;
            this.irow = (UnsafeNativeMethods.IRow) result; // maybe null if no results
            _hasRows = (null != this.irow);
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.Depth"]/*' />
        public int Depth {
            get {
                if (IsClosed) { // MDAC 63669
                    throw ADP.DataReaderClosed("Depth");
                }
                Debug.Assert(0 <= this.depth, "negative Depth");
                return this.depth;
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.FieldCount"]/*' />
        public Int32 FieldCount {
            get {
                if (IsClosed) { // MDAC 63669
                    throw ADP.DataReaderClosed("FieldCount");
                }
                Debug.Assert(0 <= this.fieldCount, "negative FieldCount");
                Debug.Assert((null == metadata && 0 == fieldCount) || (metadata.Length == fieldCount), "fieldCount mismatch");
                return this.fieldCount;
            }
        }
        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.IsClosed"]/*' />
        public Boolean IsClosed {
            get { // if we have a rowset or multipleresults, we may have more to read
                Debug.Assert(this.isClosed == ((null == this.irow) && (null == this.irowset) && (null == this.imultipleResults)
                                               && (null == this.dbSchemaTable) && (null == this.connection) && (null == this.command)
                                               && (-1 == this.fieldCount)), // MDAC 59536
                                               "IsClosed mismatch");
                return this.isClosed;
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.HasRows"]/*' />
        public bool HasRows { // MDAC 78405
            get {
                if (IsClosed) { // MDAC 63669
                    throw ADP.DataReaderClosed("HasRows");
                }
                return _hasRows;
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.RecordsAffected"]/*' />
        public int RecordsAffected {
            get {
                return this.recordsAffected;
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.this"]/*' />
        public object this[Int32 index] {
            get {
                return GetValue(index);
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.this1"]/*' />
        public object this[String name] {
            get {
                return GetValue(GetOrdinal(name));
            }
        }

        // grouping the native OLE DB casts togther by required interfaces and optional interfaces
        // want these to be methods, not properties otherwise they appear in VS7 managed debugger which attempts to evaluate them

        // required interface, safe cast
        private UnsafeNativeMethods.IAccessor IAccessor() {
#if DEBUG
            Debug.Assert(null != this.irowset, "IAccessor: null IRowset");
            ODB.Trace_Cast("IRowset", "IAccessor", "CreateAccessor");
#endif
            return (UnsafeNativeMethods.IAccessor) this.irowset;
        }

        // required interface, safe cast
        private UnsafeNativeMethods.IRowsetInfo IRowsetInfo() {
#if DEBUG
            Debug.Assert(null != this.irowset, "IRowsetInfo: null IRowset");
            ODB.Trace_Cast("IRowset", "IRowsetInfo", "GetReferencedRowset");
#endif
            return (UnsafeNativeMethods.IRowsetInfo) this.irowset;
        }

        // hidden interface for IEnumerable
        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return new DbEnumerator((IDataReader)this,  (0 != (CommandBehavior.CloseConnection & behavior))); // MDAC 68670
        }

#if INDEXINFO
        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetIndexTable"]/*' />
        public DataTable GetIndexTable() {
            // if we can't get index info, it's not catastrophic
            return null;
        }
#endif

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetSchemaTable"]/*' />
        public DataTable GetSchemaTable() {
            if (null == this.dbSchemaTable) {
                if (0 < this.fieldCount) {
                    if (this.useIColumnsRowset && (null != this.connection)) {
                        AppendSchemaInfo();
                    }
                    BuildSchemaTable();
                }
                else if (IsClosed) { // MDAC 68331
                    throw ADP.DataReaderClosed("GetSchemaTable");
                }
                else if (0 > this.fieldCount) {
                    throw ADP.DataReaderNoData();
                }
            }
            return this.dbSchemaTable;
        }

        internal void BuildMetaInfo() {
            Debug.Assert(-1 == this.fieldCount, "BuildMetaInfo: already built, by fieldcount");
            Debug.Assert(null == this.metadata, "BuildMetaInfo: already built, by metadata");

            if (null != this.irow) {
                BuildSchemaTableInfo(this.irow, false, false);
                if (0 < fieldCount) {
                    CreateBindingsFromMetaData(this.fieldCount, true);
                    for (int bindingIndex = 0; bindingIndex < dbBindings.Length; ++bindingIndex) {
                        dbBindings[bindingIndex].AllocData();
                    }
                }
            }
            else if (null != this.irowset) {
                if (this.useIColumnsRowset) {
                    BuildSchemaTableRowset(this.irowset);
                }
                else {
                    BuildSchemaTableInfo(this.irowset, false, false);
                }
                if (0 < this.fieldCount) {
                    // @devnote: because we want to use the DBACCESSOR_OPTIMIZED bit,
                    // we are required to create the accessor before fetching any rows
                    CreateAccessors(this.fieldCount, true);
                    Debug.Assert(null != this.dbBindings, "unexpected dbBindings");
                }
            }
            else {
                _hasRows = false;
                this.fieldCount = 0;
            }
            Debug.Assert(0 <= this.fieldCount, "negative fieldcount");
        }

        private void BuildSchemaTable() {
            Debug.Assert(null == this.dbSchemaTable, "BuildSchemaTable: schema table already exists");
            Debug.Assert(null != this.metadata, "BuildSchemaTable: no metadata");

            DataTable schemaTable = new DataTable("SchemaTable");
            schemaTable.MinimumCapacity = this.fieldCount;

            DataColumn name       = new DataColumn("ColumnName",       typeof(System.String));
            DataColumn ordinal    = new DataColumn("ColumnOrdinal",    typeof(System.Int32));
            DataColumn size       = new DataColumn("ColumnSize",       typeof(System.Int32));
            DataColumn precision  = new DataColumn("NumericPrecision", typeof(System.Int16));
            DataColumn scale      = new DataColumn("NumericScale",     typeof(System.Int16));

            DataColumn dataType   = new DataColumn("DataType",         typeof(System.Type));
            DataColumn providerType = new DataColumn("ProviderType", typeof(System.Int32));

            DataColumn isLong        = new DataColumn("IsLong",           typeof(System.Boolean));
            DataColumn allowDBNull   = new DataColumn("AllowDBNull",      typeof(System.Boolean));
            DataColumn isReadOnly    = new DataColumn("IsReadOnly",       typeof(System.Boolean));
            DataColumn isRowVersion  = new DataColumn("IsRowVersion",     typeof(System.Boolean));

            DataColumn isUnique        = new DataColumn("IsUnique",        typeof(System.Boolean));
            DataColumn isKey           = new DataColumn("IsKey",     typeof(System.Boolean));
            DataColumn isAutoIncrement = new DataColumn("IsAutoIncrement", typeof(System.Boolean));
            DataColumn baseSchemaName  = new DataColumn("BaseSchemaName",  typeof(System.String));
            DataColumn baseCatalogName = new DataColumn("BaseCatalogName", typeof(System.String));
            DataColumn baseTableName   = new DataColumn("BaseTableName",   typeof(System.String));
            DataColumn baseColumnName  = new DataColumn("BaseColumnName",  typeof(System.String));

            ordinal.DefaultValue = 0;
            isLong.DefaultValue = false;

            DataColumnCollection columns = schemaTable.Columns;

            columns.Add(name);
            columns.Add(ordinal);
            columns.Add(size);
            columns.Add(precision);
            columns.Add(scale);

            columns.Add(dataType);
            columns.Add(providerType);

            columns.Add(isLong);
            columns.Add(allowDBNull);
            columns.Add(isReadOnly);
            columns.Add(isRowVersion);

            columns.Add(isUnique);
            columns.Add(isKey);
            columns.Add(isAutoIncrement);
            columns.Add(baseSchemaName);
            columns.Add(baseCatalogName);
            columns.Add(baseTableName);
            columns.Add(baseColumnName);

            for (int i = 0; i < this.fieldCount; ++i) {
                MetaData info = this.metadata[i];

                DataRow newRow = schemaTable.NewRow();
                newRow[name] = info.columnName;
                newRow[ordinal] = i; // MDAC 68319
                // @devnote: size is count of characters for WSTR or STR, bytes otherwise
                // @devnote: see OLEDB spec under IColumnsInfo::GetColumnInfo
                newRow[size] = ((info.type.enumOleDbType != OleDbType.BSTR) ? info.size : -1); // MDAC 72653
                newRow[precision] = info.precision; // MDAC 72800
                newRow[scale] = info.scale;

                newRow[dataType] = info.type.dataType;
                newRow[providerType] = info.type.enumOleDbType;
                newRow[isLong] = OleDbDataReader.IsLong(info.flags);
                if (info.isKeyColumn) {
                    newRow[allowDBNull] = OleDbDataReader.AllowDBNull(info.flags);
                }
                else {
                    newRow[allowDBNull] = OleDbDataReader.AllowDBNullMaybeNull(info.flags);
                }
                newRow[isReadOnly] = OleDbDataReader.IsReadOnly(info.flags);
                newRow[isRowVersion] = OleDbDataReader.IsRowVersion(info.flags);

                newRow[isUnique] = info.isUnique;
                newRow[isKey] = info.isKeyColumn;
                newRow[isAutoIncrement] = info.isAutoIncrement;

                if (null != info.baseSchemaName) {
                    newRow[baseSchemaName] = info.baseSchemaName;
                }
                if (null != info.baseCatalogName) {
                    newRow[baseCatalogName] = info.baseCatalogName;
                }
                if (null != info.baseTableName) {
                    newRow[baseTableName] = info.baseTableName;
                }
                if (null != info.baseColumnName) {
                    newRow[baseColumnName] = info.baseColumnName;
                }

                schemaTable.AddRow(newRow);
                newRow.AcceptChanges();
            }

            // mark all columns as readonly
            for (int i=0; i < columns.Count; i++) {
                columns[i].ReadOnly = true; // MDAC 70943
            }

#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceVerbose) {
                ADP.TraceDataTable("SchemaTable", schemaTable);
            }
#endif
            this.dbSchemaTable = schemaTable;
        }

        private void BuildSchemaTableInfo(object handle, bool filterITypeInfo, bool filterChapters) {
            Debug.Assert(null == this.dbSchemaTable, "BuildSchemaTableInfo - non-null SchemaTable");
            Debug.Assert(null != handle, "BuildSchemaTableInfo - unexpected null rowset");

            UnsafeNativeMethods.IColumnsInfo icolumnsInfo = null;
            try {
#if DEBUG
                if (AdapterSwitches.OleDbTrace.TraceInfo) {
                    ODB.Trace_Cast("Object", "IColumnsInfo", "GetColumnInfo");
                }
#endif
                icolumnsInfo = (UnsafeNativeMethods.IColumnsInfo) handle;
            }
            catch (InvalidCastException e) {
#if DEBUG
                if (handle is UnsafeNativeMethods.IRow) {
                    Debug.Assert(false, "bad IRow - IColumnsInfo not available");
                }
                else {
                    Debug.Assert(handle is UnsafeNativeMethods.IRowset, "bad IRowset - IColumnsInfo not available");
                }
#endif
                ADP.TraceException(e);
            }
            if (null == icolumnsInfo) {
                this.dbSchemaTable = null;
                return;
            }

            int columnCount = 0; // column count
            IntPtr columnInfos = IntPtr.Zero; // ptr to byvalue tagDBCOLUMNINFO[]
            IntPtr columnNames = IntPtr.Zero; // ptr to string buffer referenced by items in column info

            try {
                try {
#if DEBUG
                    ODB.Trace_Begin(3, "IColumnsInfo", "GetColumnInfo");
#endif
                    int hr;
                    hr = icolumnsInfo.GetColumnInfo(out columnCount, out columnInfos, out columnNames);

#if DEBUG
                    ODB.Trace_End(3, "IColumnsInfo", "GetColumnInfo", hr, "ColumnCount=" + columnCount);
#endif
                    if (hr < 0) {
                        ProcessResults(hr);
                    }
                    if (0 < columnCount) {
                        BuildSchemaTableInfoTable(columnCount, columnInfos, filterITypeInfo, filterChapters);
                    }
                }
                finally { // FreeCoTaskMem
#if DEBUG
                    ODB.TraceData_Free(columnInfos, "columnInfos");
                    ODB.TraceData_Free(columnNames, "columnNames");
#endif
                    Marshal.FreeCoTaskMem(columnInfos); // FreeCoTaskMem protects itself from IntPtr.Zero
                    Marshal.FreeCoTaskMem(columnNames); // was allocated by provider
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        // create DataColumns
        // add DataColumns to DataTable
        // add schema information to DataTable
        // generate unique column names
        private void BuildSchemaTableInfoTable(int columnCount, IntPtr columnInfos, bool filterITypeInfo, bool filterChapters) {
            Debug.Assert(0 < columnCount, "BuildSchemaTableInfoTable - no column");

            int rowCount = 0;
            MetaData[] metainfo = new MetaData[columnCount];

            // for every column, build an equivalent to tagDBCOLUMNINFO
            UnsafeNativeMethods.tagDBCOLUMNINFO dbColumnInfo = new UnsafeNativeMethods.tagDBCOLUMNINFO();
            for (int i = 0, offset = 0; i < columnCount; ++i, offset += ODB.SizeOf_tagDBCOLUMNINFO) {
                Marshal.PtrToStructure(ADP.IntPtrOffset(columnInfos, offset), dbColumnInfo);

                if (0 >= (int) dbColumnInfo.iOrdinal) {
                    continue;
                }
                if (OleDbDataReader.DoColumnDropFilter(dbColumnInfo.dwFlags)) {
                    continue;
                }

                if (null == dbColumnInfo.pwszName) {
                    dbColumnInfo.pwszName = "";
                }
                if (filterITypeInfo && (ODB.DBCOLUMN_TYPEINFO == dbColumnInfo.pwszName)) { // MDAC 65306
                    continue;
                }
                if (filterChapters && (NativeDBType.HCHAPTER == dbColumnInfo.wType)) {
                    continue;  // filter chapters in IRowset from IDBSchemaRowset for DumpToTable
                }

                bool islong  = OleDbDataReader.IsLong(dbColumnInfo.dwFlags);
                bool isfixed = OleDbDataReader.IsFixed(dbColumnInfo.dwFlags);
                NativeDBType dbType = NativeDBType.FromDBType(dbColumnInfo.wType, islong, isfixed);

                MetaData info = new MetaData();
                info.columnName = dbColumnInfo.pwszName;
                info.type = dbType;
                info.ordinal = (int) dbColumnInfo.iOrdinal;
                info.size = (int) dbColumnInfo.ulColumnSize;
                info.flags = dbColumnInfo.dwFlags;
                info.precision = dbColumnInfo.bPrecision;
                info.scale = dbColumnInfo.bScale;

                info.kind = dbColumnInfo.eKind;
                switch(dbColumnInfo.eKind) {
                    case ODB.DBKIND_GUID_NAME:
                    case ODB.DBKIND_GUID_PROPID:
                    case ODB.DBKIND_GUID:
                        info.guid = dbColumnInfo.uGuid;
                        break;
                    default:
                        Debug.Assert(ODB.DBKIND_PGUID_NAME != dbColumnInfo.eKind, "OLE DB providers never return pGuid-style bindings.");
                        Debug.Assert(ODB.DBKIND_PGUID_PROPID != dbColumnInfo.eKind, "OLE DB providers never return pGuid-style bindings.");
                        info.guid = Guid.Empty;
                        break;
                }
                switch(dbColumnInfo.eKind) {
                    case ODB.DBKIND_GUID_PROPID:
                    case ODB.DBKIND_PROPID:
                        info.propid = dbColumnInfo.ulPropid;
                        break;
                    case ODB.DBKIND_GUID_NAME:
                    case ODB.DBKIND_NAME:
                        info.idname = Marshal.PtrToStringUni(dbColumnInfo.ulPropid);
                        break;
                    default:
                        info.propid = IntPtr.Zero;
                        break;
                }
                metainfo[rowCount] = info;

#if DEBUG
                if (AdapterSwitches.DataSchema.TraceVerbose) {
                    Debug.WriteLine("OleDbDataReader[" + info.ordinal + ", " + dbColumnInfo.pwszName + "]=" + dbType.enumOleDbType.ToString("G") + "," + dbType.dataSourceType + ", " + dbType.wType);
                }
#endif
                rowCount++;
            }
            if (rowCount < columnCount) { // shorten names array appropriately
                MetaData[] tmpinfo = new MetaData[rowCount];
                for (int i = 0; i < rowCount; ++i) {
                    tmpinfo[i] = metainfo[i];
                }
                metainfo = tmpinfo;
            }
            this.fieldCount = rowCount;
            this.metadata = metainfo;
        }

        private void BuildSchemaTableRowset(object handle) {
            Debug.Assert(null == this.dbSchemaTable, "BuildSchemaTableRowset - non-null SchemaTable");
            Debug.Assert(null != handle, "BuildSchemaTableRowset(object) - unexpected null handle");

            UnsafeNativeMethods.IColumnsRowset icolumnsRowset = null;
            try {
#if DEBUG
                ODB.Trace_Cast("Object", "IColumnsRowset", "GetColumnsRowset");
#endif
                icolumnsRowset = (UnsafeNativeMethods.IColumnsRowset) handle;
            }
            catch (InvalidCastException) {
                this.useIColumnsRowset = false; // MDAC 72653
            }

            if (null != icolumnsRowset) {
                IntPtr cOptColumns, prgOptColumns = IntPtr.Zero;
                UnsafeNativeMethods.IRowset rowset;
                int hr;

                try {
                    try {
#if DEBUG
                        ODB.Trace_Begin(3, "IColumnsRowset", "GetAvailableColumns");
#endif
                        hr = icolumnsRowset.GetAvailableColumns(out cOptColumns, out prgOptColumns);
#if DEBUG
                        ODB.Trace_End(3, "IColumnsRowset", "GetAvailableColumns", hr, "OptionalColumns=" + cOptColumns);
                        Debug.Assert((0 == hr) || (IntPtr.Zero == prgOptColumns), "GetAvailableCOlumns: unexpected return");

                        ODB.Trace_Begin(3, "IColumnsRowset", "GetColumnsRowset");
#endif
                        hr = icolumnsRowset.GetColumnsRowset(IntPtr.Zero, cOptColumns, prgOptColumns, ODB.IID_IRowset, 0, IntPtr.Zero, out rowset);
#if DEBUG
                        ODB.Trace_End(3, "IColumnsRowset", "GetColumnsRowset", hr);
#endif
                    }
                    finally { // FreeCoTaskMem
                        Marshal.FreeCoTaskMem(prgOptColumns); // was allocated by provider
                    }
                }
                catch { // MDAC 80973
                    throw;
                }

                Debug.Assert((0 <= hr) || (null == rowset), "if GetColumnsRowset failed, rowset should be null");
                if (hr < 0) {
                    ProcessResults(hr);
                }
                DumpToSchemaTable(rowset);
            }
            else {
                BuildSchemaTableInfo(handle, false, false); // MDAC 85542
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.Close"]/*' />
        public void Close() {
            CloseInternal(true); // MDAC 78504
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        internal void CloseFromConnection(bool canceling) {
            // being called from the connection, we will have a command. that command
            // may be Disposed, but it doesn't matter since another command can't execute
            // until all DataReader are closed
            if (null != this.command) { // UNDONE: understand why this could be null, it shouldn't be but was
                this.command.canceling = canceling;
            }

            // called from the connection which will remove this from its WeakReferenceCollection
            // we want the NextResult behavior, but no errors
            this.connection = null;

            CloseInternal(true);
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        // <fxcop ignore="MethodsInTypesWithIntPtrFieldAndFinalizeMethodRequireGCKeepAlive"/>
        private void CloseInternal(bool noerror) {
            OleDbConnection con = this.connection;
            OleDbCommand cmd = this.command;
            DBBindings bindings = this.parameterBindings;
            this.connection = null;
            this.command = null;
            this.parameterBindings = null;

            this.isClosed = true;

            DisposeOpenResults();
            _hasRows = false;

            if (IntPtr.Zero != this.rowHandleNativeBuffer) { // also closed by DisposeOpenResults->DisposeNativeRowset
                Marshal.FreeCoTaskMem(this.rowHandleNativeBuffer);
                this.rowHandleNativeBuffer = IntPtr.Zero;
            }

            if ((null != command) && command.canceling) { // MDAC 68964
                DisposeNativeMultipleResults();
            }
            else if (null != this.imultipleResults) {
                UnsafeNativeMethods.IMultipleResults multipleResults = this.imultipleResults;
                this.imultipleResults = null;

                // if we don't have a cmd, same as a cancel (don't call NextResults) which is ADODB behavior

                try {
                    try {
                        // tricky code path is an exception is thrown
                        // causing connection to do a ResetState and connection.Close
                        // resulting in OleDbCommand.CloseFromConnection
                        if ((null != cmd) && !cmd.canceling) { // MDAC 71435
                            int affected;
                            if (noerror) {
                                affected = NextResults(multipleResults, null, null);
                            }
                            else {
                                affected = NextResults(multipleResults, con, cmd);
                            }
                            this.recordsAffected = AddRecordsAffected(this.recordsAffected, affected);
                        }
                    }
                    finally { // ReleaseComObject
                        if (null != multipleResults) {
#if DEBUG
                            ODB.Trace_Release("IMultipleResults");
#endif
                            Marshal.ReleaseComObject(multipleResults);
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }

            if ((null != cmd) && (0 == this.depth)) {
                // return bindings back to the cmd after closure of root DataReader
                cmd.CloseFromDataReader(bindings); // MDAC 52283
            }

            if (null != con) {
                con.RemoveWeakReference(this);

                // if the DataReader is Finalized it will not close the connection
                if (0 != (CommandBehavior.CloseConnection & this.behavior)) {
                    con.Close();
                }
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.Finalize"]/*' />
        ~OleDbDataReader() {
            Dispose(false);
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        /*virtual protected*/private void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects
                CloseInternal(true);
            }
            // release unmanaged objects
            else if (IntPtr.Zero != this.rowHandleNativeBuffer) { // also closed by DisposeOpenResults->DisposeNativeRowset
                Marshal.FreeCoTaskMem(this.rowHandleNativeBuffer);
                this.rowHandleNativeBuffer = IntPtr.Zero;
            }
        }

        private void DisposeManagedRowset() {
            this.isRead = false;
            this._hasRowsReadCheck = false;

            this.indexToOrdinal = null;
            this.indexToAccessor = null;
            this.nextAccessorForRetrieval = 0;
            this.nextValueForRetrieval = 0;

            if (null != this.dbBindings) {
                int count = this.dbBindings.Length;
                for (int i = 0; i < count; ++i) {
                    DBBindings binding = dbBindings[i];
                    if (null != binding) { // MDAC 77007
                        binding.Dispose();
                    }
                }
                this.dbBindings = null;
            }
            this.accessors = null;

#if FIXEDFETCH
            this.rowHandle = ODB.DB_NULL_HROW;
#else
            this.rowHandles = null;
#endif

            this.currentRow = 0;
            this.rowFetchedCount = -1;

            this.dbSchemaTable = null;

            this.fieldCount = -1;

            this.metadata = null;
            _fieldNameLookup = null;
        }

        private void DisposeNativeMultipleResults() {
            if (null != this.imultipleResults) {
#if DEBUG
                ODB.Trace_Release("IMultipleResults");
#endif
                Marshal.ReleaseComObject(this.imultipleResults);
                this.imultipleResults = null;
            }
        }

        private void DisposeNativeRowset() {
            if (null != this.irowset) {

                if (ODB.DB_NULL_HCHAPTER != this.chapter) { // MDAC 81441
                    int refcount;
                    try {
                        ((UnsafeNativeMethods.IChapteredRowset) this.irowset).ReleaseChapter(this.chapter, out refcount);
                    }
                    catch(InvalidCastException e) { // IChapteredRowset is an optional interface
                        ADP.TraceException(e);
                    }
                    finally {
                        this.chapter = ODB.DB_NULL_HCHAPTER;
                    }
                }
#if DEBUG
                ODB.Trace_Release("IRowset");
#endif
                Marshal.ReleaseComObject(this.irowset);
                this.irowset = null;
            }
        }

        private void DisposeNativeRow() {
            if (null != this.irow) {
#if DEBUG
                ODB.Trace_Release("IRow");
#endif
                Marshal.ReleaseComObject(this.irow);
                this.irow = null;
            }
        }

        private void DisposeOpenResults() {
            DisposeManagedRowset();

            DisposeNativeRow();
            DisposeNativeRowset();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetBoolean"]/*' />
        public Boolean GetBoolean(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Boolean) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueBoolean;
            }
            if (null != this.irow) {
                return (Boolean) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetByte"]/*' />
        public Byte GetByte(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Byte) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueByte;
            }
            if (null != this.irow) {
                return (Byte) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        private MetaData DoSequentialCheck(int ordinal, Int64 dataIndex, string method) {
            MetaData info = DoValueCheck(ordinal);

            if (dataIndex > Int32.MaxValue) {
                throw ADP.InvalidSourceBufferIndex(0 /*undone*/, dataIndex);
            }
            if (this.sequentialOrdinal != ordinal) {
                this.sequentialOrdinal = ordinal;
                this.sequentialBytesRead = 0;
            }
            else if (sequentialAccess && (sequentialBytesRead < dataIndex)) {
                throw ADP.NonSeqByteAccess(dataIndex, sequentialBytesRead, method);
            }
            // getting the value doesn't really belong, but it's common to both
            // callers GetBytes and GetChars so we might as well have the code here
            if (null == info.value) {
                if (null != this.irowset) {
                    info.value = PeekValueBinding(ordinal).Value;
                }
                else if (null != this.irow) {
                    GetRowValue(info, ordinal);
                }
            }
            return info;
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetBytes"]/*' />
        public Int64 GetBytes(int ordinal, Int64 dataIndex, byte[] buffer, Int32 bufferIndex, Int32 length) {
            MetaData info = DoSequentialCheck(ordinal, dataIndex, ADP.GetBytes);
            if (null != info.value) {
                // @usernote: user may encounter the InvalidCastException (byte[])
                byte[] value = (byte[]) info.value;
                if (null == buffer) {
                    return value.Length;
                }
                int srcIndex = (int) dataIndex;
                int byteCount = Math.Min(value.Length - srcIndex, length);
                if (srcIndex < 0) { // MDAC 72830
                    throw ADP.InvalidSourceBufferIndex(value.Length, srcIndex);
                }
                else if ((bufferIndex < 0) || (bufferIndex >= buffer.Length)) { // MDAC 71013
                    throw ADP.InvalidDestinationBufferIndex(buffer.Length, bufferIndex);
                }
                if (0 < byteCount) {
                    // @usernote: user may encounter ArgumentException from Buffer.BlockCopy
                    Buffer.BlockCopy(value, srcIndex, buffer, bufferIndex, byteCount);
                    sequentialBytesRead = srcIndex + byteCount; // MDAC 71013
                }
                else if (length < 0) { // MDAC 71007
                    throw ADP.InvalidDataLength(length);
                }
                else {
                    byteCount = 0;
                }
                return byteCount;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetChars"]/*' />
        public Int64 GetChars(int ordinal, Int64 dataIndex, char[] buffer, Int32 bufferIndex, Int32 length) {
            MetaData info = DoSequentialCheck(ordinal, dataIndex, ADP.GetChars);
            if (null != info.value) {
                // @usernote: user may encounter the InvalidCastException to string
                string value = (string) info.value;
                if (null == buffer) {
                    return value.Length;
                }

                int srcIndex = (int) dataIndex;
                int charCount = Math.Min(value.Length - srcIndex, length);
                if (srcIndex < 0) { // MDAC 72830
                    throw ADP.InvalidSourceBufferIndex(value.Length, srcIndex);
                }
                else if ((bufferIndex < 0) || (bufferIndex >= buffer.Length)) { // MDAC 71013
                    throw ADP.InvalidDestinationBufferIndex(buffer.Length, bufferIndex);
                }
                if (0 < charCount) {
                    // @usernote: user may encounter ArgumentException from String.CopyTo
                    value.CopyTo(srcIndex, buffer, bufferIndex, charCount);
                    sequentialBytesRead = srcIndex + charCount; // MDAC 71013
                }
                else if (length < 0) { // MDAC 71007
                    throw ADP.InvalidDataLength(length);
                }
                else {
                    charCount = 0;
                }
                return charCount;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetChar"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Never) ] // MDAC 69508
        public Char GetChar(int ordinal) {
            throw ADP.NotSupported();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetData"]/*' />
        public OleDbDataReader GetData(int ordinal) {
            OleDbDataReader dataReader = null;
            MetaData info = DoValueCheck(ordinal);
            if (null == info.value) {
                if (null != this.irowset) {
                    info.value = PeekValueBinding(ordinal).Value;
                    dataReader = (OleDbDataReader) info.value;
                }
                else if (null != this.irow) {
                    dataReader = (OleDbDataReader) GetDataFromIRow(info, ordinal);
                }
                else {
                    throw ADP.DataReaderNoData();
                }
            }
            else {
                dataReader = (OleDbDataReader) info.value;
            }
            GC.KeepAlive(this);
            return dataReader;
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.IDataRecord.GetData"]/*' />
        /// <internalonly/>
        IDataReader IDataRecord.GetData(int ordinal) {
            return GetData(ordinal);
        }

        private OleDbDataReader GetDataForReader(int ordinal, IntPtr chapter) {
            UnsafeNativeMethods.IRowsetInfo rowsetInfo = IRowsetInfo();
            UnsafeNativeMethods.IRowset result;
            int hr;

#if DEBUG
            ODB.Trace_Begin(3, "IRowsetInfo", "GetReferencedRowset", "ColumnOrdinal=" + ordinal);
#endif
            hr = rowsetInfo.GetReferencedRowset((IntPtr)ordinal, ODB.IID_IRowset, out result);
#if DEBUG
            ODB.Trace_End(3, "IRowsetInfo", "GetReferencedRowset", hr, "Chapter=" + chapter);
#endif
            ProcessResults(hr);

            OleDbDataReader reader = null;
            if (null != result) {
                reader = new OleDbDataReader(this.connection, this.command, 1+Depth, chapter);
                reader.InitializeIRowset(result, -1, this.behavior);
                reader.BuildMetaInfo();
                reader.HasRowsRead();

                if (null != this.connection) {
                    // connection tracks all readers to prevent cmd from executing
                    // until all readers (including nested) are closed
                    this.connection.AddWeakReference(reader);
                }
            }
            return reader;
        }

        private OleDbDataReader GetDataFromIRow(MetaData info, int ordinal) {
            if (OleDbDataReader.IsRowset(info.flags)) {
                return GetDataFromIRow(info, ordinal, ODB.IID_IRowset);
            }
            if (OleDbDataReader.IsRow(info.flags)) {
                return GetDataFromIRow(info, ordinal, ODB.IID_IRow);
            }
            throw ADP.DataReaderNoData();
        }

        private OleDbDataReader GetDataFromIRow(MetaData info, int ordinal, Guid iid) {

            StringPtr sptr = null;
            if ((ODB.DBKIND_GUID_NAME == info.kind) || (ODB.DBKIND_NAME == info.kind)) {
                sptr = new StringPtr(info.idname);
            }

            UnsafeNativeMethods.tagDBID columnid= new UnsafeNativeMethods.tagDBID();
            columnid.uGuid = info.guid;
            columnid.eKind = info.kind;
            columnid.ulPropid = ((null != sptr) ? sptr.ptr : info.propid);

            object result;
            int hr;
#if DEBUG
            ODB.Trace_Begin(3, "IRow", "Open");
#endif
            hr = this.irow.Open(IntPtr.Zero, columnid, ODB.DBGUID_ROWSET, 0, iid, out result);
#if DEBUG
            ODB.Trace_End(3, "IRow", "Open", hr);
#endif
            if (null != sptr) {
                sptr.Dispose();
            }
            if (ODB.DB_E_NOTFOUND == hr) {
                return null;
            }
            if (hr < 0) {
                ProcessResults(hr);
            }

            OleDbDataReader reader = null;
            if (null != result) {
                reader = new OleDbDataReader(this.connection, this.command, 1+Depth, IntPtr.Zero);
                if (ODB.IID_IRow == iid) {
                    reader.InitializeIRow(result, -1, this.behavior);
                    reader.BuildMetaInfo();
                    reader.HasRowsRead();
                }
                else {
                    reader.InitializeIRowset(result, -1, this.behavior);
                    reader.BuildMetaInfo();
                }
                if (null != this.connection) {
                    // connection tracks all readers to prevent cmd from executing
                    // until all readers (including nested) are closed
                    this.connection.AddWeakReference(reader);
                }
            }
            return reader;
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetDataTypeName"]/*' />
        public String GetDataTypeName(int index) {
            if (null != this.metadata) {
                return this.metadata[index].type.dataSourceType;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetDateTime"]/*' />
        public DateTime GetDateTime(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (DateTime) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueDateTime;
            }
            if (null != this.irow) {
                return (DateTime) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetDecimal"]/*' />
        public Decimal GetDecimal(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Decimal) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueDecimal;
            }
            if (null != this.irow) {
                return (Decimal) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetDouble"]/*' />
        public Double GetDouble(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Double) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueDouble;
            }
            if (null != this.irow) {
                return (Double) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetFieldType"]/*' />
        public Type GetFieldType(int index) {
            if (null != this.metadata) {
                return this.metadata[index].type.dataType;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetFloat"]/*' />
        public Single GetFloat(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Single) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueSingle;
            }
            if (null != this.irow) {
                return (Single) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetGuid"]/*' />
        public Guid GetGuid(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Guid) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueGuid;
            }
            if (null != this.irow) {
                return (Guid) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetInt16"]/*' />
        public Int16 GetInt16(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Int16) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueInt16;
            }
            if (null != this.irow) {
                return (Int16) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetInt32"]/*' />
        public Int32 GetInt32(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Int32) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueInt32;
            }
            if (null != this.irow) {
                return (Int32) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetInt64"]/*' />
        public Int64 GetInt64(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (Int64) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueInt64;
            }
            if (null != this.irow) {
                return (Int64) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetName"]/*' />
        public String GetName(int index) {
            if (null != this.metadata) {
                Debug.Assert(null != this.metadata[index].columnName, "MDAC 66681");
                return this.metadata[index].columnName;
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetOrdinal"]/*' />
        public Int32 GetOrdinal(String name) {
            if (null == _fieldNameLookup) {
                if (null == this.metadata) {
                    throw ADP.DataReaderNoData();
                }
                _fieldNameLookup = new FieldNameLookup(this, -1);
            }
            return _fieldNameLookup.GetOrdinal(name); // MDAC 71470
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetString"]/*' />
        public String GetString(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null == info.value) {
                if (null != this.irowset) {
                    info.value = PeekValueBinding(ordinal).ValueString;
                }
                else if (null != this.irow) {
                    GetRowValue(info, ordinal);
                }
                else {
                    throw ADP.DataReaderNoData();
                }
            }
            return (String) info.value;
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetTimeSpan"]/*' />
        public TimeSpan GetTimeSpan(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null != info.value) {
                return (TimeSpan) info.value;
            }
            if (null != this.irowset) {
                return PeekValueBinding(ordinal).ValueTimeSpan;
            }
            if (null != this.irow) {
                return (TimeSpan) GetRowValue(info, ordinal);
            }
            throw ADP.DataReaderNoData();
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetValue"]/*' />
        public object GetValue(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null == info.value) {
                if (null != this.irowset) {
                    info.value = PeekValueBinding(ordinal).Value;
                }
                else if (null != this.irow) {
                    GetRowValue(info, ordinal);
                }
                else {
                    throw ADP.DataReaderNoData();
                }
            }
#if DEBUG
            if (AdapterSwitches.DataValue.TraceVerbose) {
                Debug.WriteLine("GetValue("+ordinal+")="+ADP.ValueToString(info.value));
            }
#endif
            GC.KeepAlive(this); // keeps bindings alive
            return info.value;
        }

        private DBBindings FindValueBinding(int index) {
            Debug.Assert(null != this.irowset, "FindValueBinding - no irowset");
            Debug.Assert(null != this.indexToAccessor, "FindValueBinding - no indexToAccessor");
            Debug.Assert(null != this.indexToOrdinal, "FindValueBinding - no indexToOrdinal");

            // do we need to jump to the next accessor
            // if index is out of range, i.e. too large - it will be thrown here as we work up to it
            int accessorIndex = this.indexToAccessor[index];
            if (this.nextAccessorForRetrieval <= accessorIndex) {
                this.nextAccessorForRetrieval = accessorIndex;
                GetRowDataFromHandle();
            }

            DBBindings bindings = this.dbBindings[accessorIndex];
            Debug.Assert(null != bindings, "FindValueBinding - null bindings");
            bindings.CurrentIndex = this.indexToOrdinal[index];
            return bindings;
        }

        private DBBindings PeekValueBinding(int index) {
            DBBindings bindings = FindValueBinding(index);
            this.nextValueForRetrieval = index;
            GC.KeepAlive(this);
            return bindings;
        }

        private MetaData DoValueCheck(int ordinal) {
            if (!isRead) {
                throw ADP.DataReaderNoData(); // UNDONE: Read hasn't been called yet
            }
            else if ((ordinal < this.nextValueForRetrieval) && this.sequentialAccess) {
                throw ADP.NonSequentialColumnAccess(ordinal, this.nextValueForRetrieval);
            }
            // @usernote: user may encounter the IndexOutOfRangeException
            return this.metadata[ordinal];
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetValues"]/*' />
        public Int32 GetValues(object[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            MetaData info = DoValueCheck(0);
            int count = Math.Min(values.Length, FieldCount);
            if (null != this.irowset) {
                for (int i = 0; i < count; ++i) {
                    info = this.metadata[i];
                    if (null == info.value) {
                        info.value = PeekValueBinding(i).Value;
                    }
                    values[i] = info.value;
                }
            }
            else if (null != this.irow) {
                for (int i = 0; i < count; ++i) {
                    info = this.metadata[i];
                    if (null == info.value) {
                        GetRowValue(info, i);
                    }
                    values[i] = info.value;
                }
            }
            else {
                throw ADP.DataReaderNoData();
            }
#if DEBUG
            if (AdapterSwitches.DataValue.TraceVerbose) {
                for (int k = 0; k < count; ++k) {
                    Debug.WriteLine("GetValues("+k+")="+ADP.ValueToString(values[k]));
                }
            }
#endif
            GC.KeepAlive(this); // keeps bindings alive
            return count;
        }

       /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.IsDBNull"]/*' />
        public Boolean IsDBNull(int ordinal) {
            MetaData info = DoValueCheck(ordinal);
            if (null == info.value) {
                if (null != this.irowset) {
                    info.value = PeekValueBinding(ordinal).Value;
                    return Convert.IsDBNull(info.value);
                }
                else if (null != this.irow) {
                    GetRowValue(info, ordinal);
                    return Convert.IsDBNull(info.value);
                }
            }
            else {
                return Convert.IsDBNull(info.value);
            }
            throw ADP.DataReaderNoData();
        }

        private void ProcessResults(int hr) {
            Exception e;
            if (null != this.command) {
                e = OleDbConnection.ProcessResults(hr, this.command.Connection, this.command);
            }
            else {
                e = OleDbConnection.ProcessResults(hr, this.connection, this.connection);
            }
            if (null != e) { throw e; }
        }

        static private int AddRecordsAffected(int recordsAffected, int affected) { // MDAC 65374
            if (0 <= affected) {
                if (0 <= recordsAffected) {
                    return recordsAffected + affected;
                }
                return affected;
            }
            return recordsAffected;
        }

        internal void HasRowsRead() { // MDAC 78405
            bool flag = Read();
            _hasRows = flag;
            _hasRowsReadCheck = true;
            this.isRead = false;
        }

        static internal int NextResults(UnsafeNativeMethods.IMultipleResults imultipleResults, OleDbConnection connection, OleDbCommand command) {
            int recordsAffected = -1;
            if (null != imultipleResults) {
                object result;
                int affected, hr;

                // MSOLAP provider doesn't move onto the next result when calling GetResult with IID_NULL, but does return S_OK with 0 affected records.
                // we want to break out of that infinite loop for ExecuteNonQuery and the multiple result Close scenarios
                for (int loop = 0;; ++loop) {
                    if ((null != command) && command.canceling) { // MDAC 68964
                        break;
                    }
#if DEBUG
                    ODB.Trace_Begin(3, "IMultipleResults", "GetResult", "IID_NULL");
#endif
                    hr = imultipleResults.GetResult(IntPtr.Zero, ODB.DBRESULTFLAG_DEFAULT, ODB.IID_NULL, out affected, out result);
#if DEBUG
                    ODB.Trace_End(3, "IMultipleResults", "GetResult", hr, "RecordsAffected=" + affected);
#endif
                    // If a provider doesn't support IID_NULL and returns E_NOINTERFACE we want to break out
                    // of the loop without throwing an exception.  Our behavior will match ADODB in that scenario
                    // where Recordset.Close just releases the interfaces without proccessing remaining results
                    if ((ODB.DB_S_NORESULT == hr) || (ODB.E_NOINTERFACE == hr)) { // MDAC 70874
                        break;
                    }
                    if (null != connection) {
                        Exception e = OleDbConnection.ProcessResults(hr, connection, command);
                        if (null != e) {
#if DEBUG
                            ODB.Trace_Release("IMultipleResults with exception");
#endif
                            Marshal.ReleaseComObject(imultipleResults);
                            throw e;
                        }
                    }
                    else if (hr < 0) {
                        SafeNativeMethods.ClearErrorInfo();
                        break; // MDAC 72694
                    }
                    recordsAffected = AddRecordsAffected(recordsAffected, affected);

                    if (0 != affected) {
                        loop = 0;
                    }
                    else if (2000 <= loop) { // MDAC 72126 (reason for more than 1000 iterations)
                        NextResultsInfinite(); // MDAC 72738
                        break;
                    }
                }
            }
            return recordsAffected;
        }

        static private void NextResultsInfinite() { // MDAC 72738
            // always print the message so if customers encounter this they have a chance of understanding what happened
            string msg = "System.Data.OleDb.OleDbDataReader: 2000 IMultipleResult.GetResult(NULL, DBRESULTFLAG_DEFAULT, IID_NULL, NULL, NULL) iterations with 0 records affected. Stopping suspect infinite loop. To work-around try using ExecuteReader() and iterating through results with NextResult().";
            SafeNativeMethods.OutputDebugString(msg);

            // edtriou's suggestion is that we debug assert so that users will learn of MSOLAP's misbehavior and not call ExecuteNonQuery
            Debug.Assert(false, msg);
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.NextResult"]/*' />
        public bool NextResult() {
            bool retval = false;
            if (null != this.imultipleResults) {
                DisposeOpenResults();
                _hasRows = false;

                for (;;) {
                    Debug.Assert(null == this.irow, "NextResult: row loop check");
                    Debug.Assert(null == this.irowset, "NextResult: rowset loop check");
                    object result = null;
                    int affected, hr;

                    if ((null != command) && command.canceling) { // MDAC 69986
                        Close();
                        break;
                    }
#if DEBUG
                    ODB.Trace_Begin(3, "IMultipleResults", "GetResult", "IRowset");
#endif
                    hr = imultipleResults.GetResult(IntPtr.Zero, ODB.DBRESULTFLAG_DEFAULT, ODB.IID_IRowset, out affected, out result);
                    if ((0 <= hr) && (null != result)) {
                        this.irowset = (UnsafeNativeMethods.IRowset) result;
                    }
#if DEBUG
                    ODB.Trace_End(3, "IMultipleResults", "GetResult", hr, "RowsAffected=" + affected);
#endif
                    Debug.Assert((0 <= hr) || (null == this.irow) || (null == this.irowset), "if GetResult failed, subRowset[0] should be null");

                    recordsAffected = AddRecordsAffected(recordsAffected, affected);

                    Debug.Assert(null == this.irow, "NextResult: row loop check");
                    if (null != this.irowset) {
                        // @devnote: infomessage events may be fired from here
                        ProcessResults(hr);
                        BuildMetaInfo();
                        HasRowsRead();
                        retval = true;
                        break;
                    }
                    if (ODB.DB_S_NORESULT == hr) {
                        DisposeNativeMultipleResults();
                        this.fieldCount = 0;
                        break;
                    }
                    // @devnote: infomessage events may be fired from here
                    ProcessResults(hr);
                }
            }
            else if (IsClosed) {
                throw ADP.DataReaderClosed("NextResult");
            }
            else {
                DisposeOpenResults(); // MDAC 70934
                this.fieldCount = 0; // MDAC 71391
		_hasRows = false; // MDAC 85850
            }
            GC.KeepAlive(this);
            return retval;
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.Read"]/*' />
        public bool Read() {
            bool retval = false;
            if ((null != command) && command.canceling) { // MDAC 69986
                DisposeOpenResults();
            }
            else if (null != this.irowset) {
                if (_hasRowsReadCheck) {
                    this.isRead = true;
                    _hasRowsReadCheck = false;
                    retval = _hasRows;
                }
                else if (this.singleRow && this.isRead) {
                    DisposeOpenResults(); // MDAC 66109
                }
                else {
                    retval = ReadRowset();
                }
            }
            else if (null != this.irow) {
                retval = ReadRow();
            }
            else if (IsClosed) {
                throw ADP.DataReaderClosed("Read");
            }
            GC.KeepAlive(this);
            return retval;
        }

        private bool ReadRow() {
            Debug.Assert(0 <= fieldCount, "incorrect state for fieldCount");
            if (this.isRead) {
                this.isRead = false; // for DoValueCheck

                DisposeNativeRow();

                this.sequentialOrdinal = -1; // sequentialBytesRead will reset when used
                for (int i = 0; i < this.fieldCount; ++i) {
                    this.metadata[i].value = null;
                }
            }
            else {
                this.isRead = true;
                return (0 < this.fieldCount);
            }
            return false;
        }

        private bool ReadRowset() {
            Debug.Assert(null != this.irowset, "ReadRow: null IRowset");
            Debug.Assert(0 <= fieldCount, "incorrect state for fieldCount");

            // releases bindings as necessary
            // bumps current row, else resets it back to initial state
            ReleaseCurrentRow();

            this.sequentialOrdinal = -1; // sequentialBytesRead will reset when used
            for (int i = 0; i < this.fieldCount; ++i) {
                this.metadata[i].value = null;
            }

            // making the check if (null != irowset) unnecessary
            // if necessary, get next group of row handles
            if (-1 == this.rowFetchedCount) { // starts at (-1 <= 0)
                Debug.Assert(0 == this.currentRow, "incorrect state for currentRow");
                //Debug.Assert(null != this.rowHandles, "incorrect state for rowHandles");
                Debug.Assert(0 <= fieldCount, "incorrect state for fieldCount");
                Debug.Assert(0 == this.nextAccessorForRetrieval, "incorrect state for nextAccessorForRetrieval");
                Debug.Assert(0 == this.nextValueForRetrieval, "incorrect state for nextValueForRetrieval");

                // @devnote: releasing row handles occurs next time user calls read, skip, or close
                GetRowHandles(/*skipCount*/);
            }
            return (this.currentRow < this.rowFetchedCount);
        }

        private void ReleaseCurrentRow() {
            Debug.Assert(null != this.irowset, "ReleaseCurrentRow: no rowset");
            if (0 < this.rowFetchedCount) {

                // release the data in the current row
                Debug.Assert(null != this.dbBindings, "ReleaseCurrentRow: null dbBindings");
                for (int i = 0; i < this.nextAccessorForRetrieval; ++i) {
                    this.dbBindings[i].CleanupBindings();
                }
                this.nextAccessorForRetrieval = 0;
                this.nextValueForRetrieval = 0;

                this.currentRow++;
                if (this.currentRow == this.rowFetchedCount) {
                    ReleaseRowHandles();
                }
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.CreateAccessors"]/*' />
        private void CreateAccessors(int columnCount, bool allowMultipleAccessor) {
            Debug.Assert(null == this.dbBindings, "CreateAccessor: dbBindings already exists");
            Debug.Assert(null == this.accessors,  "CreateAccessor: accessor already exists");
            Debug.Assert(null != this.irowset, "CreateAccessor: no IRowset available");

            //Debug.Assert(null == this.rowHandles, "rowHandles already initialized");
            Debug.Assert(0 < rowHandleFetchCount, "invalid rowHandleFetchCount");

            Debug.Assert(0 != columnCount, "CreateAccessors: no columns");

            CreateBindingsFromMetaData(columnCount, allowMultipleAccessor);

            // per column status when creating the accessor
            UnsafeNativeMethods.DBBindStatus[] rowBindStatus = new UnsafeNativeMethods.DBBindStatus[columnCount];

            // create the accessor handle for each binding
            this.accessors = new IntPtr[dbBindings.Length];

            UnsafeNativeMethods.IAccessor iaccessor = IAccessor();

            for (int i = 0; i < dbBindings.Length; ++i) {
                DBBindings bindings = dbBindings[i];
                int bindingCount = bindings.Count;
                Debug.Assert(bindingCount <= columnCount, "CreateAccessor: status buffer too small");

                UnsafeNativeMethods.tagDBBINDING[] buffer = bindings.DBBinding;
#if DEBUG
                ODB.Trace_Begin(3, "IAccessor", "CreateAccessor", "ColumnCount=" + bindingCount);
#endif
                int hr;
                hr = iaccessor.CreateAccessor(ODB.DBACCESSOR_ROWDATA, bindingCount, buffer, bindings.DataBufferSize, out this.accessors[i], rowBindStatus); // MDAC 69530
#if DEBUG
                ODB.Trace_End(3, "IAccessor", "CreateAccessor", hr, "AccessorHandle=0x" + this.accessors[i].ToInt32().ToString("X8"));
#endif

                for (int k = 0; k < bindingCount; ++k) {
                    if (UnsafeNativeMethods.DBBindStatus.OK != rowBindStatus[k]) {
                        bindings.CurrentIndex = k;
                        throw ODB.BadStatusRowAccessor(bindings.Ordinal, rowBindStatus[k]);
                    }
                }
                if (hr < 0) {
                    ProcessResults(hr);
                }
            }

            for (int bindingIndex = 0; bindingIndex < dbBindings.Length; ++bindingIndex) {
                dbBindings[bindingIndex].AllocData();
            }
#if !FIXEDFETCH
            object maxrows = null;
            if (0 == RowSetProperties(ODB.DBPROP_MAXROWS, out maxrows)) {
                if (maxRows is Int32) {
                    rowHandleFetchCount = (int) maxRows;
                }
            }
            if ((0 == rowHandleFetchCount) || (20 < rowHandleFetchCount)) {
                rowHandleFetchCount = 20;
            }
            else rowHandleFetchCount = 1;

            this.rowHandles = new IntPtr[rowHandleFetchCount];
#endif
            if (IntPtr.Zero == this.rowHandleNativeBuffer) {
                IntPtr dataPtr = IntPtr.Zero;
                int byteCount = IntPtr.Size * rowHandleFetchCount;
                try {
                    dataPtr = Marshal.AllocCoTaskMem(byteCount);
                    SafeNativeMethods.ZeroMemory(dataPtr, byteCount);
                    this.rowHandleNativeBuffer = dataPtr;
                }
                catch {
                    this.rowHandleNativeBuffer = IntPtr.Zero;
                    Marshal.FreeCoTaskMem(dataPtr);
                    throw;
                }
            }
            GC.KeepAlive(this);
        }

        private void CreateBindingsFromMetaData(int columnCount, bool allowMultipleAccessor) {
            int bindingCount = 0;
            int currentBindingIndex = 0;

            DBBindings bindings;

            this.indexToAccessor = new int[columnCount];
            this.indexToOrdinal = new int[columnCount];

            // walk through the schemaRows to determine the number of binding groups
            if (allowMultipleAccessor) {
                if (null != this.irowset) {
                    for (int i = 0; i < columnCount; ++i) {
                        this.indexToAccessor[i] = bindingCount;
                        this.indexToOrdinal[i] = currentBindingIndex;
#if false
                        // @denote: single/multiple Accessors
                        if ((bindingCount < 2) && IsLong(this.metadata[i].flags)) { 
                            bindingCount++;
                            currentBindingIndex = 0;
                        }
                        else {
                            currentBindingIndex++;
                        }
#elif false
                        // @devnote: one accessor per column option
                        bindingCount++;
                        currentBindingIndex = 0;
#else
                        // @devnote: one accessor only for IRowset
                        currentBindingIndex++;
#endif
                    }
                    if (0 < currentBindingIndex) { // when blob is not the last column
                        bindingCount++;
                    }
                }
                else if (null != this.irow) {
                    for (int i = 0; i < columnCount; ++i) {
                        this.indexToAccessor[i] = i;
                        this.indexToOrdinal[i] = 0;
                    }
                    bindingCount = columnCount;
                }
            }
            else {
                for (int i = 0; i < columnCount; ++i) {
                    this.indexToAccessor[i] = 0;
                    this.indexToOrdinal[i] = i;
                }
                bindingCount = 1;
            }

            Debug.Assert(0 < bindingCount, "bad bindingCount");
            this.dbBindings = new DBBindings[bindingCount];

            bindingCount = 0;

            // for every column, build tagDBBinding info
            for (int index = 0; index < columnCount; ++index) {
                Debug.Assert(this.indexToAccessor[index] < this.dbBindings.Length, "bad indexToAccessor");
                bindings = this.dbBindings[this.indexToAccessor[index]];
                if (null == bindings) {
                    bindingCount = 0;
                    for (int i = index; (i < columnCount) && (bindingCount == indexToOrdinal[i]); ++i) {
                        bindingCount++;
                    }
                    this.dbBindings[this.indexToAccessor[index]] = bindings = new DBBindings((OleDbDataReader)this, index, bindingCount, (null != this.irowset));

                    // runningTotal is buffered to start values on 16-byte boundary
                    // the first columnCount * 8 bytes are for the length and status fields
                    //bindings.DataBufferSize = (bindingCount + (bindingCount % 2)) * sizeof_int64;
                }
                MetaData info = this.metadata[index];

                int maxLen = info.type.fixlen;
                int getType = info.type.wType;
#if DEBUG
                Debug.Assert(NativeDBType.STR != getType, "Should have bound as WSTR");
                Debug.Assert(!NativeDBType.HasHighBit(getType), "CreateAccessor - unexpected high bits on datatype");
#endif
                if (-1 != info.size) {
                    if (info.type.islong) {
                        maxLen = IntPtr.Size;
                        getType |= NativeDBType.BYREF;
                    }
                    else if (-1 == maxLen) {
                        // @devnote: not using provider owned memory for PDC, no one really supports it anyway.
                        /*if (((null != connection) && connection.PropertyGetProviderOwnedMemory())
                            || ((null != command) && command.Connection.PropertyGetProviderOwnedMemory())) {
                            bindings.MemOwner = DBMemOwner.ProviderOwned;

                            bindings.MaxLen = IntPtr.Size;
                            bindings.DbType = (short) (getType | DbType.BYREF);
                        }
                        else*/

                        if (ODB.LargeDataSize < info.size) {
                            maxLen = IntPtr.Size;
                            getType |= NativeDBType.BYREF;
                        }
                        else if (NativeDBType.WSTR == getType) {
                            maxLen = info.size * 2 + 2;
                        }
                        else {
                            maxLen = info.size;
                        }
                    }
                }
                else if (maxLen < 0) {
                    // if variable length and no defined size we require this to be byref at this time
                    /*if (((null != connection) && connection.PropertyGetProviderOwnedMemory())
                        || ((null != command) && command.Connection.PropertyGetProviderOwnedMemory())) {
                        bindings.MemOwner = DBMemOwner.ProviderOwned;
                    }*/
                    maxLen = IntPtr.Size;
                    getType |= (short) NativeDBType.BYREF;
                }

                currentBindingIndex = this.indexToOrdinal[index];
                Debug.Assert(currentBindingIndex < bindings.Count, "bad indexToOrdinal " + currentBindingIndex + " " + bindings.Count);
                bindings.CurrentIndex = currentBindingIndex;

                bindings.Ordinal      = info.ordinal;
              //bindings.ValueOffset  = bindings.DataBufferSize; // set via MaxLen
              //bindings.LengthOffset = currentBindingIndex * sizeof_int64; //((fixLen <= 0) ? currentBindingIndex * sizeof_int64 : -1);
              //bindings.StatusOffset = currentBindingIndex * sizeof_int64 + sizeof_int32;
              //bindings.TypeInfoPtr  = 0;
              //bindings.ObjectPtr    = 0;
              //bindings.BindExtPtr   = 0;
                bindings.Part         = info.type.dbPart;
              //bindings.MemOwner     = /*DBMEMOWNER_CLIENTOWNED*/0;
              //bindings.ParamIO      = ODB.DBPARAMIO_NOTPARAM;
                bindings.MaxLen       = maxLen; // also increments databuffer size
              //bindings.Flags        = 0;
                bindings.DbType       = (short) getType;
                bindings.Precision    = (byte) info.precision;
                bindings.Scale        = (byte) info.scale;
#if DEBUG
                if (AdapterSwitches.OleDbTrace.TraceVerbose) {
                    ODB.Trace_Binding(info.ordinal, bindings, info.columnName);
                }
#endif
            }
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetRowHandles"]/*' />
        private void GetRowHandles(/*int skipCount*/) {
            Debug.Assert(null != this.irowset, "GetRowHandles: null irowset");
            //Debug.Assert(null != this.rowHandles, "GetRowHandles: null rowHandles");
            Debug.Assert(0 < rowHandleFetchCount, "GetRowHandles: bad rowHandleFetchCount");
            Debug.Assert(!this.isRead, "GetRowHandles: isRead");

#if DEBUG
            ODB.Trace_Begin(4, "IRowset", "GetNextRow", "Chapter=0x" + this.chapter.ToInt64().ToString("X") + " RowsRequested=" + rowHandleFetchCount);
#endif
            int hr;
            try {
                hr = irowset.GetNextRows(this.chapter, /*skipCount*/0, rowHandleFetchCount, out this.rowFetchedCount, ref this.rowHandleNativeBuffer);
            }
            catch(System.InvalidCastException e) { // MDAC 64320
                ADP.TraceException(e);
                throw ODB.ThreadApartmentState(e);
            }

#if DEBUG
            ODB.Trace_End(4, "IRowset", "GetNextRow", hr, "RowsObtained=" + this.rowFetchedCount);
#endif
            if (ODB.DB_S_ENDOFROWSET == hr) {
                if (0 >= this.rowFetchedCount) {
                    this.rowFetchedCount = -2;
                }
                else {
                    this.isRead = true;
                }
            }
            //else if (/*DB_S_ROWLIMITEXCEEDED*/0x00040EC0 == hr) {
            //    this.rowHandleFetchCount = 1;
            //}
            else {
                // filter out the BadStartPosition due to the skipCount which
                // maybe greater than the number of rows in the return rowset
                //const int /*OLEDB_Error.*/DB_E_BADSTARTPOSITION = unchecked((int)0x80040E1E);
                //if (DB_E_BADSTARTPOSITION != hr) {
                if (hr < 0) {
                    ProcessResults(hr);
                }
                this.isRead = true; // MDAC 59264
            }
            //}
            //else if (AdapterSwitches.DataError.TraceWarning || AdapterSwitches.OleDbTrace.TraceWarning) {
            //    Debug.WriteLine("DB_E_BADSTARTPOSITION SkipCount=" + (skipCount).ToString());
            //}
#if FIXEDFETCH
            this.rowHandle = Marshal.ReadIntPtr(this.rowHandleNativeBuffer, /*offset*/0);
#else
            for (int i = 0, offset = 0; i < this.rowFetchedCount; ++i, offset += IntPtr.Size) {
                this.rowHandles[i] = Marshal.ReadIntPtr(this.rowHandleNativeBuffer, offset);
            }
#endif
            Debug.Assert((-2 == this.rowFetchedCount) || (0 < this.rowFetchedCount), "unexpected rowsObtained");
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.GetRowDataFromHandle"]/*' />
        private void GetRowDataFromHandle() {
            Debug.Assert(null != this.irowset, "GetRowDataFromHandle: null irowset");
            Debug.Assert(null != this.dbBindings, "GetRowDataFromHandle: null dbBindings");
            Debug.Assert(null != this.accessors, "GetRowDataFromHandle: null accessors");

#if !FIXEDFETCH
            IntPtr rowHandle = this.rowHandles[this.currentRow];
#endif
            Debug.Assert(/*DB_NULL_HROW*/IntPtr.Zero != rowHandle, "GetRowDataFromHandle: bad rowHandle");

            int nextIndex = this.nextAccessorForRetrieval;
            IntPtr accessorHandle = this.accessors[nextIndex];
            Debug.Assert(ODB.DB_INVALID_HACCESSOR != accessorHandle, "GetRowDataFromHandle: bad accessor handle");

#if DEBUG
            ODB.Trace_Begin(4, "IRowset", "GetData", "RowHandle=" + rowHandle + " AccessorHandle=" + accessorHandle);
#endif
            int hr;
            UnsafeNativeMethods.IRowset irowset = this.irowset;
            hr = irowset.GetData(rowHandle, accessorHandle, this.dbBindings[nextIndex]);
#if DEBUG
            ODB.Trace_End(4, "IRowset", "GetData", hr);
#endif
            //if (AdapterSwitches.DataError.TraceWarning) {
            //    DBBindings binding = this.dbBindings[i];
            //    for (int k = 0; k < binding.Count; ++k) {
            //        binding.CurrentIndex = k;
            //        Debug.WriteLine("Status[" + (k).ToString() + "] = " + binding.StatusValue.ToString("G"));
            //    }
            //}
            if (hr < 0) {
                ProcessResults(hr);
            }

            this.nextAccessorForRetrieval++;
        }

        /// <include file='doc\OleDbDataReader.uex' path='docs/doc[@for="OleDbDataReader.ReleaseRowHandles"]/*' />
        private void ReleaseRowHandles() {
            Debug.Assert(null != this.irowset, "ReleaseRowHandles: null irowset");
            //Debug.Assert(null != this.rowHandles, "ReleaseRowHandles: null rowHandles");
            //Debug.Assert(this.rowFetchedCount <= this.rowHandles.Length, "ReleaseRowHandles: count too large");
            Debug.Assert(0 < this.rowFetchedCount, "ReleaseRowHandles: invalid rowFetchedCount");

#if DEBUG
            ODB.Trace_Begin(4, "IRowset", "ReleaseRows", "Request=" + this.rowFetchedCount);
#endif
            int hr;
            hr = irowset.ReleaseRows(this.rowFetchedCount, this.rowHandleNativeBuffer, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
#if DEBUG
            ODB.Trace_End(4, "IRowset", "ReleaseRows", hr);
#endif
            //@devnote: since there is no error recovery from this, don't bother
            //ProcessFailure(hr);
            if (hr < 0) {
                SafeNativeMethods.ClearErrorInfo();
            }

#if FIXEDFETCH
            rowHandle = ODB.DB_NULL_HROW;
#else
            for (int i = 0; i < this.rowFetchedCount; ++i) {
                this.rowHandles[i] = ODB.DB_NULL_HROW;
            }
#endif
            this.rowFetchedCount = -1;
            this.currentRow = 0;
            this.isRead = false; // MDAC 59264
        }

        internal PropertyIDSetWrapper PropertyIDSet(Guid propertySet, int propertyId) {
            if (null != connection) {
                return connection.PropertyIDSet(OleDbPropertySetGuid.Rowset, propertyId);
            }
            PropertyIDSetWrapper propertyIDSet = new PropertyIDSetWrapper();
            propertyIDSet.Initialize();
            propertyIDSet.SetValue(propertySet, propertyId);
            return propertyIDSet;
        }

        private int PropertyValueResults(int hr, DBPropSet propSet, out object value) {
            value = null;
            int status = ODB.DBPROPSTATUS_NOTSUPPORTED;
            if (ODB.DB_E_ERRORSOCCURRED != hr) {
                if (hr < 0) {
                    ProcessResults(hr);
                }
                if (null != propSet) {
                    if (0 < propSet.PropertySetCount) {
                        propSet.ReadPropertySet();
                        if (0 < propSet.PropertyCount) {
                            value = propSet.ReadProperty();
                            status = propSet.Status;
                        }
                    }
                    propSet.Dispose();
                }
            }
            return status;
        }

        private int Properties(int propertyId, out object value) { // MDAC 72106
            if (null != this.irowset) {
                return RowSetProperties(propertyId, out value);
            }
            else if (null != this.command) {
                return this.command.CommandProperties(propertyId, out value);
            }
            value = null;
            return ODB.DBPROPSTATUS_NOTSUPPORTED;
        }

        private int RowSetProperties(int propertyId, out object value) {
            UnsafeNativeMethods.IRowsetInfo irowsetinfo = IRowsetInfo();

            DBPropSet propSet = new DBPropSet();
            PropertyIDSetWrapper propertyIDSet = PropertyIDSet(OleDbPropertySetGuid.Rowset, propertyId);

            int hr;
#if DEBUG
            ODB.Trace_Begin(3, "IDBProperties", "GetProperties", ODB.PLookup(propertyId));
#endif
            hr = irowsetinfo.GetProperties(1, propertyIDSet, out propSet.totalPropertySetCount, out propSet.nativePropertySet);
#if DEBUG
            ODB.Trace_End(3, "IDBProperties", "GetProperties", hr, "PropertySetsCount = " + propSet.totalPropertySetCount);
#endif
            GC.KeepAlive(propertyIDSet); // MDAC 79539
            return PropertyValueResults(hr, propSet, out value);
        }

        internal OleDbDataReader ResetChapter(int bindingIndex, int index, IntPtr chapter) {
            return GetDataForReader(this.metadata[bindingIndex + index].ordinal, chapter);
        }

        private object GetRowValue(MetaData info, int index) {
            Debug.Assert(null != info, "GetRowValue: null MetaData[index]");
            Debug.Assert(null == info.value, "GetRowValue: value already exists");

            Debug.Assert(null != this.irow, "GetRowValue: null IRow");
            Debug.Assert(null != this.metadata, "GetRowValue: null MetaData");

            if (this.sequentialAccess) {
                this.metadata[this.nextValueForRetrieval].value = null;
            }
            else {
                while (this.nextValueForRetrieval < index) { // cache the skipped values
                    int k = this.nextValueForRetrieval;
                    MetaData next = this.metadata[k];
                    this.nextValueForRetrieval++; // must increment before getting value
                    if ((null == next.value) && (NativeDBType.HCHAPTER != info.type.wType)) { // don't cache hierarchial results when skpping
                        next.value = GetRowValueInternal(next, k);
                    }
                }
            }
            this.nextValueForRetrieval = index;
            info.value = GetRowValueInternal(info, index); // retrieve and cache value in question
            return info.value;
        }

        private object GetRowValueInternal(MetaData info, int index) {
            Debug.Assert(null != this.irow, "not IRow");

            object value;
            StringPtr sptr = null;
            DBBindings binding = this.dbBindings[index];
            binding.CurrentIndex = 0;
            try {
                try {
                    if ((ODB.DBKIND_GUID_NAME == info.kind) || (ODB.DBKIND_NAME == info.kind)) {
                        sptr = new StringPtr(info.idname);
                    }
                    binding.GuidKindName(info.guid, info.kind, ((null != sptr) ? sptr.ptr : info.propid));

                    UnsafeNativeMethods.tagDBCOLUMNACCESS[] access = binding.DBColumnAccess;
                    Debug.Assert(1 == access.Length, "more than one column for IRow.GetColums");
#if DEBUG
                    ODB.Trace_Begin(4, "IRow", "GetColumns", "Index=" + index);
#endif
                    int hr = this.irow.GetColumns(new IntPtr(access.Length), access);
#if DEBUG
                    ODB.Trace_End(4, "IRow", "GetColumns", hr, access[0].cbDataLen.ToString());
#endif
                    ProcessResults(hr);

                    value = binding.Value;
                }
                finally { // CleanupBindings
                    binding.CleanupBindings();

                    if (null != sptr) {
                        sptr.Dispose();
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return value;
        }

        private Int32 IndexOf(Hashtable hash, string name) { // MDAC 67385
            // via case sensitive search, first match with lowest ordinal matches
            if (hash.Contains(name)) {
                return (int) hash[name]; // match via case-insensitive or by chance lowercase
            }

            // via case insensitive search, first match with lowest ordinal matches
            string tmp = name.ToLower(CultureInfo.InvariantCulture);
            if (hash.Contains(tmp)) {
                return (int) hash[tmp]; // match via lowercase
            }
            return -1;
        }

        private void AppendSchemaInfo() {
            Debug.Assert(null != this.connection, "null connection");
            Debug.Assert(null != this.metadata, "no metadata");

            int metacount = this.metadata.Length;
            if (metacount <= 0) {
                return;
            }

            int keyCount = 0;
            for (int i = 0; i < metacount; ++i) {
                if (this.metadata[i].isKeyColumn) {
                    keyCount++;
                }
            }
            if (0 != keyCount) /*|| this.connection.IsServer_msdaora || this.connection.IsServer_Microsoft_SQL)*/ { // MDAC 60109
                return;
            }

            string schemaName, catalogName; // enforce single table
            string baseSchemaName = null, baseCatalogName = null, baseTableName = null;
            for (int i = 0; i < metacount; ++i) {
                MetaData info = metadata[i];
                if ((null != info.baseTableName) && (0 < info.baseTableName.Length)) {
                    catalogName = ((null != info.baseCatalogName) ? info.baseCatalogName : ""); // MDAC 67249
                    schemaName = ((null != info.baseSchemaName) ? info.baseSchemaName : "");
                    if (null == baseTableName) {
                        baseSchemaName = schemaName;
                        baseCatalogName = catalogName;
                        baseTableName = info.baseTableName;
                    }
                    else if ((0 != ADP.SrcCompare(baseTableName, info.baseTableName))
                            || (0 != ADP.SrcCompare(baseCatalogName, catalogName))
                            || (0 != ADP.SrcCompare(baseSchemaName, schemaName))) { // MDAC 71808
#if DEBUG
                        if (AdapterSwitches.DataSchema.TraceVerbose) {
                            Debug.WriteLine("Multiple BaseTableName detected:"
                                +" <"+baseCatalogName+"."+baseCatalogName+"."+baseTableName+">"
                                +" <"+info.baseCatalogName+"."+info.baseCatalogName+"."+info.baseTableName+">");
                        }
#endif
                        baseTableName = null;
                        break;
                    }
                }
            }
            if (null == baseTableName) {
                return;
            }
            baseCatalogName = ADP.IsEmpty(baseCatalogName) ? null : baseCatalogName;
            baseSchemaName = ADP.IsEmpty(baseSchemaName) ? null : baseSchemaName;

            if (null != connection) { // MDAC 67394
                if (ODB.DBPROPVAL_IC_SENSITIVE == connection.QuotedIdentifierCase()) {
                    string p = null, s = null;
                    connection.GetLiteralQuotes(out s, out p);
                    if (null == s) {
                        s = "";
                    }
                    if (null == p) {
                        p = "";
                    }
                    baseTableName = s + baseTableName + p;
                }
            }

            int count = this.fieldCount;
            Hashtable baseColumnNames = new Hashtable(count * 2); // MDAC 67385

            for (int i = count-1; 0 <= i; --i) {
                string basecolumname = this.metadata[i].baseColumnName;
                if (!ADP.IsEmpty(basecolumname)) {
                    baseColumnNames[basecolumname] = i;
                }
            }
            for (int i = 0; i < count; ++i) {
                string basecolumname = this.metadata[i].baseColumnName;
                if (!ADP.IsEmpty(basecolumname)) {
                    basecolumname = basecolumname.ToLower(CultureInfo.InvariantCulture);
                    if (!baseColumnNames.Contains(basecolumname)) {
                        baseColumnNames[basecolumname] = i;
                    }
                }
            }

            int support = 0;

            // look for primary keys in the table
            if (connection.SupportSchemaRowset(OleDbSchemaGuid.Primary_Keys, out support)) {
                Object[] restrictions = new Object[] { baseCatalogName, baseSchemaName, baseTableName };
                keyCount = AppendSchemaPrimaryKey(metacount, baseColumnNames, restrictions);
            }
            if (0 != keyCount) {
                return;
            }

            // look for a single unique contraint that can be upgraded
            if (connection.SupportSchemaRowset(OleDbSchemaGuid.Indexes, out support)) {
                Object[] restrictions = new Object[] { baseCatalogName, baseSchemaName, null, null, baseTableName };
                AppendSchemaUniqueIndexAsKey(metacount, baseColumnNames, restrictions);
            }
        }

        private int AppendSchemaPrimaryKey(int metacount, Hashtable baseColumnNames, object[] restrictions) {
            int keyCount = 0;
            bool partialPrimaryKey = false;
            DataTable table = null;
            try {
                table = connection.GetSchemaRowset(OleDbSchemaGuid.Primary_Keys, restrictions);
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
            if (null != table) {
                DataRowCollection rowCollection = table.Rows;
                int rowCount = rowCollection.Count;

                if (0 < rowCount) {
                    DataColumnCollection dataColumns = table.Columns;
                    int nameColumnIndex = dataColumns.IndexOf(ODB.COLUMN_NAME);

                    if (-1 != nameColumnIndex) {
                        DataColumn nameColumn = dataColumns[nameColumnIndex];

                        for(int i = 0; i < rowCount; ++i) {
                            DataRow dataRow = rowCollection[i];

                            string name = (string) dataRow[nameColumn, DataRowVersion.Default];

                            int metaindex = IndexOf(baseColumnNames, name); // MDAC 67385
                            if (0 <= metaindex) {
                                MetaData info = this.metadata[metaindex];
                                info.isKeyColumn = true;
                                info.flags &= ~ODB.DBCOLUMNFLAGS_ISNULLABLE;
                                keyCount++;
                            }
                            else {
#if DEBUG
                                if (AdapterSwitches.DataSchema.TraceVerbose) {
                                    Debug.WriteLine("PartialKeyColumn detected: <" + name + "> metaindex=" + metaindex);
                                }
#endif
                                partialPrimaryKey = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (partialPrimaryKey) { // partial primary key detected
                for (int i = 0; i < metacount; ++i) {
                    this.metadata[i].isKeyColumn = false;
                }
                return -1;
            }
            return keyCount;
        }

        private void AppendSchemaUniqueIndexAsKey(int metacount, Hashtable baseColumnNames, object[] restrictions) {
            bool partialPrimaryKey = false;
            DataTable table = null;
            try { // MDAC 66209
                table = connection.GetSchemaRowset(OleDbSchemaGuid.Indexes, restrictions);
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
            if (null != table) {
                DataRowCollection rowCollection = table.Rows;
                int rowCount = rowCollection.Count;

                if (0 < rowCount) {
                    DataColumnCollection dataColumns = table.Columns;

                    int indxIndex = dataColumns.IndexOf(ODB.INDEX_NAME);
                    int pkeyIndex = dataColumns.IndexOf(ODB.PRIMARY_KEY);
                    int uniqIndex = dataColumns.IndexOf(ODB.UNIQUE);
                    int nameIndex = dataColumns.IndexOf(ODB.COLUMN_NAME);
                    int nullIndex = dataColumns.IndexOf(ODB.NULLS);

                    if ((-1 != indxIndex) && (-1 != pkeyIndex) && (-1 != uniqIndex) && (-1 != nameIndex)) {

                        DataColumn indxColumn = dataColumns[indxIndex];
                        DataColumn pkeyColumn = dataColumns[pkeyIndex];
                        DataColumn uniqCOlumn = dataColumns[uniqIndex];
                        DataColumn nameColumn = dataColumns[nameIndex];
                        DataColumn nulls = ((-1 != nullIndex) ? dataColumns[nullIndex] : null);

                        bool[] keys = new bool[metacount];
                        bool[] uniq = new bool[metacount];
                        string uniqueIndexName = null;

                        // match pkey name BaseColumnName
                        for(int index = 0; index < rowCount; ++index) {
                            DataRow dataRow = rowCollection[index];

                            bool isPKey = (!dataRow.IsNull(pkeyColumn, DataRowVersion.Default) && (bool)dataRow[pkeyColumn, DataRowVersion.Default]);
                            bool isUniq = (!dataRow.IsNull(uniqCOlumn, DataRowVersion.Default) && (bool)dataRow[uniqCOlumn, DataRowVersion.Default]);
                            bool nullsVal = (null != nulls) && (dataRow.IsNull(nulls, DataRowVersion.Default) || (ODB.DBPROPVAL_IN_ALLOWNULL == Convert.ToInt32(dataRow[nulls, DataRowVersion.Default])));

                            if (isPKey || isUniq) {
                                string name = (string) dataRow[nameColumn, DataRowVersion.Default];

                                int metaindex = IndexOf(baseColumnNames, name); // MDAC 67385
                                if (0 <= metaindex) {
                                    if (isPKey) {
                                        keys[metaindex] = true;
                                    }
                                    if (isUniq && (null != uniq)) {
                                        uniq[metaindex] = true;

                                        string indexname = (string) dataRow[indxColumn, DataRowVersion.Default];
                                        if (null == uniqueIndexName) {
                                            uniqueIndexName = indexname;
                                        }
                                        else if (indexname != uniqueIndexName) {
#if DEBUG
                                            if (AdapterSwitches.DataSchema.TraceVerbose) {
                                                Debug.WriteLine("MultipleUniqueIndexes detected: <" + uniqueIndexName + "> <" + indexname + ">");
                                            }
#endif
                                            uniq = null;
                                        }
                                    }
                                }
                                else if (isPKey) {
#if DEBUG
                                    if (AdapterSwitches.DataSchema.TraceVerbose) {
                                        Debug.WriteLine("PartialKeyColumn detected: " + name);
                                    }
#endif
                                    partialPrimaryKey = true;
                                    break;
                                }
                                else if (null != uniqueIndexName) {
                                    string indexname = (string) dataRow[indxColumn, DataRowVersion.Default];

                                    if (indexname != uniqueIndexName) {
#if DEBUG
                                        if (AdapterSwitches.DataSchema.TraceVerbose) {
                                            Debug.WriteLine("PartialUniqueIndexes detected: <" + uniqueIndexName + "> <" + indexname + ">");
                                        }
#endif
                                        uniq = null;
                                    }
                                }
                            }
                        }
                        if (partialPrimaryKey) {
                            for (int i = 0; i < metacount; ++i) {
                                this.metadata[i].isKeyColumn = false;
                            }
                            return;
                        }
                        else if (null != uniq) {
#if DEBUG
                            if (AdapterSwitches.DataSchema.TraceVerbose) {
                                Debug.WriteLine("upgrade single unique index to be a key: <" + uniqueIndexName + ">");
                            }
#endif
                            // upgrade single unique index to be a key
                            for (int i = 0; i < metacount; ++i) {
                                this.metadata[i].isKeyColumn = uniq[i];
                            }
                        }
                    }
                }
            }
        }

        static internal DataTable DumpToTable(OleDbConnection connection, UnsafeNativeMethods.IRowset rowset) {
            Debug.Assert(null != connection, "null connection");
            Debug.Assert(null != rowset, "null rowset");

            DataTable dataTable = null;
            try {
                OleDbDataReader dataReader = null;
                try {
                    // depth is negative but user isn't exposed to it - more of an internal check
                    dataReader = new OleDbDataReader(connection, null, Int32.MinValue, IntPtr.Zero);
                    dataReader.InitializeIRowset(rowset, 0, CommandBehavior.SequentialAccess);
                    dataReader.BuildSchemaTableInfo(rowset, false, true);

                    int columnCount = dataReader.fieldCount;
                    if (0 == columnCount) {
                        return null;
                    }
                    // @devnote: because we want to use the DBACCESSOR_OPTIMIZED bit,
                    // we are required to create the accessor before fetching any rows
                    dataReader.CreateAccessors(columnCount, false);

                    dataTable = new DataTable("SchemaTable"); // MDAC 62356
                    DataColumnCollection columns = dataTable.Columns;

                    for (int i = 0; i < columnCount; ++i) {
                        columns.Add(dataReader.GetName(i), dataReader.GetFieldType(i));
                    }

                    dataTable.BeginLoadData();
                    try {
                        object[] values = new object[columnCount];
                        while (dataReader.ReadRowset()) {
                            dataReader.GetValues(values);
                            dataTable.LoadDataRow(values, true);
                        }
                    }
                    finally { // EndLoadData
                        dataTable.EndLoadData();
                    }
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceVerbose) {
                        ADP.TraceDataTable("DumpToTable", dataTable);
                    }
#endif
                }
                finally { // DisposeNativeRowset
                    if (null != dataReader) {
                        // optimized shutdown of this datareader since we know it only has an IRowset
                        dataReader.DisposeNativeRowset();
                        GC.KeepAlive(dataReader);
                        GC.SuppressFinalize(dataReader);
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return dataTable;
        }

        internal void DumpToSchemaTable(UnsafeNativeMethods.IRowset rowset) {
            ArrayList metainfo = new ArrayList();

            object hiddenColumns = null;
            OleDbDataReader dataReader = null;
            try {
                try {
                    // depth is negative but user isn't exposed to it - more of an internal check
                    dataReader = new OleDbDataReader(this.connection, this.command, Int32.MinValue, IntPtr.Zero);
                    dataReader.InitializeIRowset(rowset, 0, 0);
                    dataReader.BuildSchemaTableInfo(rowset, true, false); // MDAC 85542

                    Properties(ODB.DBPROP_HIDDENCOLUMNS, out hiddenColumns); // MDAC 55611, 72106

                    int columnCount = dataReader.fieldCount;
                    if (0 == columnCount) {
                        return;
                    }
                    Debug.Assert(null == dataReader._fieldNameLookup, "lookup already exists");
                    FieldNameLookup lookup = new FieldNameLookup(dataReader, -1);
                    dataReader._fieldNameLookup = lookup;

                    // This column, together with the DBCOLUMN_GUID and DBCOLUMN_PROPID
                    // columns, forms the ID of the column. One or more (but not all) of these columns
                    // will be NULL, depending on which elements of the DBID structure the provider uses.
                    int columnidname     = lookup.IndexOfName(ODB.DBCOLUMN_IDNAME);
                    int columnguid       = lookup.IndexOfName(ODB.DBCOLUMN_GUID);
                    int columnpropid     = lookup.IndexOfName(ODB.DBCOLUMN_PROPID);

                    int columnname       = lookup.IndexOfName(ODB.DBCOLUMN_NAME);
                    int columnordinal    = lookup.IndexOfName(ODB.DBCOLUMN_NUMBER);
                    int dbtype           = lookup.IndexOfName(ODB.DBCOLUMN_TYPE);
                    int columnsize       = lookup.IndexOfName(ODB.DBCOLUMN_COLUMNSIZE);
                    int numericprecision = lookup.IndexOfName(ODB.DBCOLUMN_PRECISION);
                    int numericscale     = lookup.IndexOfName(ODB.DBCOLUMN_SCALE);
                    int columnflags      = lookup.IndexOfName(ODB.DBCOLUMN_FLAGS);
                    int baseschemaname   = lookup.IndexOfName(ODB.DBCOLUMN_BASESCHEMANAME);
                    int basecatalogname  = lookup.IndexOfName(ODB.DBCOLUMN_BASECATALOGNAME);
                    int basetablename    = lookup.IndexOfName(ODB.DBCOLUMN_BASETABLENAME);
                    int basecolumnname   = lookup.IndexOfName(ODB.DBCOLUMN_BASECOLUMNNAME);
                    int isautoincrement  = lookup.IndexOfName(ODB.DBCOLUMN_ISAUTOINCREMENT);
                    int isunique         = lookup.IndexOfName(ODB.DBCOLUMN_ISUNIQUE);
                    int iskeycolumn      = lookup.IndexOfName(ODB.DBCOLUMN_KEYCOLUMN);

                    // @devnote: because we want to use the DBACCESSOR_OPTIMIZED bit,
                    // we are required to create the accessor before fetching any rows
                    dataReader.CreateAccessors(columnCount, false);

                    DBBindings binding;
                    while (dataReader.ReadRowset()) {
                        Debug.Assert((null != dataReader.accessors) && (1 == dataReader.accessors.Length), "unexpected multiple accessors in IColumnsRowset schematable");
                        dataReader.GetRowDataFromHandle();

                        MetaData info = new MetaData();

                        binding = dataReader.PeekValueBinding(columnidname); // MDAC 72627
                        if (!binding.IsValueNull()) {
                            info.idname = binding.ValueString;
                            info.kind = ODB.DBKIND_NAME;
                        }

                        binding = dataReader.PeekValueBinding(columnguid);
                        if (!binding.IsValueNull()) {
                            info.guid = binding.Value_GUID;
                            info.kind = ((ODB.DBKIND_NAME == info.kind) ? ODB.DBKIND_GUID_NAME : ODB.DBKIND_GUID);
                        }

                        binding = dataReader.PeekValueBinding(columnpropid);
                        if (!binding.IsValueNull()) {
                            info.propid = new IntPtr(binding.Value_UI4);
                            info.kind = ((ODB.DBKIND_GUID == info.kind) ? ODB.DBKIND_GUID_PROPID : ODB.DBKIND_PROPID);
                        }

                        binding = dataReader.PeekValueBinding(columnname);
                        if (!binding.IsValueNull()) {
                            info.columnName = binding.ValueString;
                        }
                        else {
                            info.columnName = "";
                        }

                        info.ordinal = (int) dataReader.PeekValueBinding(columnordinal).Value_UI4;
                        int type = (int) dataReader.PeekValueBinding(dbtype).Value_UI2;

                        info.size = (int) dataReader.PeekValueBinding(columnsize).Value_UI4;

                        binding = dataReader.PeekValueBinding(numericprecision);
                        if (!binding.IsValueNull()) {
                            info.precision = (byte) binding.Value_UI2;
                        }

                        binding = dataReader.PeekValueBinding(numericscale);
                        if (!binding.IsValueNull()) {
                            info.scale = (byte) binding.Value_I2;
                        }

                        info.flags = (int) dataReader.PeekValueBinding(columnflags).Value_UI4;

                        bool islong  = OleDbDataReader.IsLong(info.flags);
                        bool isfixed = OleDbDataReader.IsFixed(info.flags);
                        NativeDBType dbType = NativeDBType.FromDBType(type, islong, isfixed);

                        info.type = dbType;

                        if (-1 != isautoincrement) {
                            binding = dataReader.PeekValueBinding(isautoincrement);
                            if (!binding.IsValueNull()) {
                                info.isAutoIncrement = binding.Value_BOOL;
                            }
                        }
                        if (-1 != isunique) {
                            binding = dataReader.PeekValueBinding(isunique);
                            if (!binding.IsValueNull()) {
                                info.isUnique = binding.Value_BOOL;
                            }
                        }
                        if (-1 != iskeycolumn) {
                            binding = dataReader.PeekValueBinding(iskeycolumn);
                            if (!binding.IsValueNull()) {
                                info.isKeyColumn = binding.Value_BOOL;
                            }
                        }
                        if (-1 != baseschemaname) {
                            binding = dataReader.PeekValueBinding(baseschemaname);
                            if (!binding.IsValueNull()) {
                                info.baseSchemaName = binding.ValueString;
                            }
                        }
                        if (-1 != basecatalogname) {
                            binding = dataReader.PeekValueBinding(basecatalogname);
                            if (!binding.IsValueNull()) {
                                info.baseCatalogName = binding.ValueString;
                            }
                        }
                        if (-1 != basetablename) {
                            binding = dataReader.PeekValueBinding(basetablename);
                            if (!binding.IsValueNull()) {
                                info.baseTableName = binding.ValueString;
                            }
                        }
                        if (-1 != basecolumnname) {
                            binding = dataReader.PeekValueBinding(basecolumnname);
                            if (!binding.IsValueNull()) {
                                info.baseColumnName = binding.ValueString;
                            }
                        }
                        metainfo.Add(info);
                    }
                }
                finally { // DisposeNativeRowset
                    if (null != dataReader) {
                        // optimized shutdown of this datareader since we know it only has an IRowset
                        dataReader.DisposeNativeRowset();
                        GC.KeepAlive(dataReader);
                        GC.SuppressFinalize(dataReader);
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }

            bool visibleKeyColumns = true;
            
            int visibleCount = metainfo.Count;
            if (hiddenColumns is Int32) {
                visibleCount -= (int) hiddenColumns;
            }

            for (int index = metainfo.Count-1; visibleCount <= index; --index) {
                MetaData info = (MetaData) metainfo[index];

                if (info.isKeyColumn) {
                    // if hidden column is a key column then the user
                    // selected a partial set of keys so we don't want to
                    // create a primary key in the dataset
                    visibleKeyColumns = false;
                    break;
                }
            }

            for (int index = visibleCount-1; 0 <= index; --index) {
                MetaData info = (MetaData) metainfo[index];

                if (ODB.DBCOL_SPECIALCOL == info.guid) { // MDAC 72390
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceVerbose) {
                        Debug.WriteLine("Filtered Column: DBCOLUMN_GUID=DBCOL_SPECIALCOL DBCOLUMN_NAME=" + info.columnName + " DBCOLUMN_KEYCOLUMN=" + info.isKeyColumn);
                    }
#endif
                    if (info.isKeyColumn) {
                        visibleKeyColumns = false;
                    }
                    metainfo.RemoveAt(index);
                    visibleCount--;
                }
                else if (0 >= info.ordinal) {
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceVerbose) {
                        Debug.WriteLine("Filtered Column: DBCOLUMN_NUMBER=" + info.ordinal + " DBCOLUMN_NAME=" + info.columnName);
                    }
#endif
                    metainfo.RemoveAt(index);
                    visibleCount--;
                }
                else if (OleDbDataReader.DoColumnDropFilter(info.flags)) {
#if DEBUG
                    if (AdapterSwitches.DataSchema.TraceVerbose) {
                        Debug.WriteLine("Filtered Column: DBCOLUMN_FLAGS=" + info.flags.ToString("X8") + " DBCOLUMN_NAME=" + info.columnName);
                    }
#endif
                    metainfo.RemoveAt(index);
                    visibleCount--;
                }
            }

            MetaData[] metaInfos = new MetaData[visibleCount];
            for (int i = 0; i < visibleCount; ++i) {
                metaInfos[i] = (MetaData) metainfo[i];
                metaInfos[i].isKeyColumn &= visibleKeyColumns;
            }
            // UNDONE: consider perf tracking to see if we need to sort or not
            Array.Sort(metaInfos); // MDAC 68319

            this.fieldCount = visibleCount;
            this.metadata = metaInfos;
        }

        static internal void GenerateSchemaTable(OleDbDataReader dataReader, object handle, CommandBehavior behavior) {
            if (0 != (CommandBehavior.KeyInfo & behavior)) {
                dataReader.BuildSchemaTableRowset(handle); // tries IColumnsRowset first then IColumnsInfo
                dataReader.AppendSchemaInfo();
            }
            else {
                dataReader.BuildSchemaTableInfo(handle, false, false); // only tries IColumnsInfo, MDAC 85542
            }
            dataReader.BuildSchemaTable();
        }

        static private bool DoColumnDropFilter(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISBOOKMARK & flags));
        }
        static private bool IsLong(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISLONG & flags));
        }
        static private bool IsFixed(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISFIXEDLENGTH & flags));
        }
        static private bool IsRowVersion(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISROWID_DBCOLUMNFLAGS_ISROWVER & flags));
        }
        static private bool AllowDBNull(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISNULLABLE & flags));
        }
        static private bool AllowDBNullMaybeNull(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISNULLABLE_DBCOLUMNFLAGS_MAYBENULL & flags));
        }
        static private bool IsReadOnly(int flags) {
            return (0 == (ODB.DBCOLUMNFLAGS_WRITE_DBCOLUMNFLAGS_WRITEUNKNOWN & flags));
        }
        static private bool IsRowset(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISROWSET & flags));
        }
        static private bool IsRow(int flags) {
            return (0 != (ODB.DBCOLUMNFLAGS_ISROW & flags));
        }

        sealed private class MetaData : IComparable {

            internal string columnName;
            internal object value; // MDAC 66185

            internal Guid guid; // MDAC 72627
            internal int kind;
            internal IntPtr propid;
            internal string idname;

            internal NativeDBType type;

            internal int ordinal;
            internal int size;

            internal int flags;

            internal byte precision;
            internal byte scale;

            internal bool isAutoIncrement;
            internal bool isUnique;
            internal bool isKeyColumn;

            internal string baseSchemaName;
            internal string baseCatalogName;
            internal string baseTableName;
            internal string baseColumnName;

            int IComparable.CompareTo(object obj) { // MDAC 68319
                return (this.ordinal - ((MetaData)obj).ordinal);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbcommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Text;

    /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand"]/*' />
    [
    ToolboxItem(true),
    Designer("Microsoft.VSDesigner.Data.VS.OleDbCommandDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbCommand : Component, ICloneable, IDbCommand {

        // command data
        private OleDbConnection cmdConnection;
        private OleDbTransaction transaction;

        private OleDbParameterCollection cmdParameters;
        private string cmdText;
        private CommandType cmdType = Data.CommandType.Text;
        private UpdateRowSource updatedRowSource = UpdateRowSource.Both;

        // command behavior
        private int commandTimeout = ADP.DefaultCommandTimeout;

        // native information
        private UnsafeNativeMethods.ICommandText icommandText;
        private IntPtr handle_Accessor;// = DB_INVALID_HACCESSOR;

        // if executing with a different CommandBehavior.KeyInfo behavior
        // original ICommandText must be released and a new ICommandText generated
        private CommandBehavior commandBehavior;

        private DBBindings dbBindings;

        internal bool canceling; // MDAC 68964
        private bool isPrepared;
        private bool executeQuery;
        private bool computedParameters;
        private bool designTimeVisible;

        // see ODB.InternalState* for possible states
        private int cmdState; // = ODB.InternalStateClosed;
        private int recordsAffected;

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.OleDbCommand"]/*' />
        public OleDbCommand() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.OleDbCommand1"]/*' />
        public OleDbCommand(string cmdText) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.OleDbCommand2"]/*' />
        public OleDbCommand(string cmdText, OleDbConnection connection) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
            Connection = connection;
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.OleDbCommand3"]/*' />
        public OleDbCommand(string cmdText, OleDbConnection connection, OleDbTransaction transaction) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
            Connection = connection;
            Transaction = transaction;
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.CommandText"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DbCommand_CommandText),
        Editor("Microsoft.VSDesigner.Data.ADO.Design.OleDbCommandTextEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
        RefreshProperties(RefreshProperties.All) // MDAC 67707
        ]
        public string CommandText {
            get {
                return ((null != this.cmdText) ? this.cmdText : String.Empty);
            }
            set {
                if (0 != ADP.SrcCompare(this.cmdText, value)) {
                    OnSchemaChanging(); // fire event before value is validated
                    this.cmdText = value;
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.CommandTimeout"]/*' />
        [
        DefaultValue(ADP.DefaultCommandTimeout),
        DataSysDescription(Res.DbCommand_CommandTimeout)
        ]
        public int CommandTimeout {
            get {
                return this.commandTimeout;
            }
            set {
                if (value < 0) {
                    throw ADP.InvalidCommandTimeout(value);
                }
                this.commandTimeout = value;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.CommandType"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(System.Data.CommandType.Text),
        DataSysDescription(Res.DbCommand_CommandType),
        RefreshProperties(RefreshProperties.All)
        ]
        public CommandType CommandType {
            get {
                return cmdType;
            }
            set {
                if (this.cmdType != value) {
                    OnSchemaChanging(); // fire event before value is validated

                    switch(value) { // @perfnote: Enum.IsDefined
                    case CommandType.Text:
                    case CommandType.StoredProcedure:
                    case CommandType.TableDirect:
                        this.cmdType = value;
                        break;
                    default:
                        throw ADP.InvalidCommandType(value);
                    }
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.Connection"]/*' />
        [
        DataCategory(Res.DataCategory_Behavior),
        DefaultValue(null),
        DataSysDescription(Res.DbCommand_Connection),
        Editor("Microsoft.VSDesigner.Data.Design.DbConnectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OleDbConnection Connection {
            get {
                return this.cmdConnection;
            }
            set {
                if (value != this.cmdConnection) {
                    OnSchemaChanging(); // fire event before value is validated

                    if (null != this.cmdConnection) {
                        this.cmdConnection.RemoveWeakReference(this);
                    }
                    this.cmdConnection = value;

                    if (null != this.cmdConnection) {
                        this.cmdConnection.AddWeakReference(this);
                        this.transaction = OleDbTransaction.TransactionUpdate(this.transaction); // MDAC 63226
                    }
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.IDbCommand.Connection"]/*' />
        /// <internalonly/>
        IDbConnection IDbCommand.Connection {
            get {
                return Connection;
            }
            set {
                Connection = (OleDbConnection) value;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.DesignTimeVisible"]/*' />
        [
        DefaultValue(true),
        DesignOnly(true),
        Browsable(false),
        ]
        public bool DesignTimeVisible {
            get {
                return !this.designTimeVisible;
            }
            set {
                this.designTimeVisible = !value;                
                TypeDescriptor.Refresh(this); // VS7 208845
            }
        }

        internal bool IsClosed {
            get {
                // if closed, then this command is not busy
                // if executing, then this command is busy
                // if fetching, then the connection should have DataReaders to track IsClosed on
                return (ODB.InternalStateExecuting != cmdState);
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.Parameters"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataSysDescription(Res.DbCommand_Parameters)
        ]
        public OleDbParameterCollection Parameters {
            get {
                if (null == this.cmdParameters) {
                    // delay the creation of the OleDbParameterCollection
                    // until user actually uses the Parameters property
                    this.cmdParameters = new OleDbParameterCollection(this);
                }
                return this.cmdParameters;
            }
        }

        private bool HasParameters() { // MDAC 65548
            return (null != this.cmdParameters) && (0 < this.cmdParameters.Count); // VS 300569
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.IDbCommand.Parameters"]/*' />
        /// <internalonly/>
        IDataParameterCollection IDbCommand.Parameters {
            get {
                return Parameters;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.Transaction"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DbCommand_Transaction)
        ]
        public OleDbTransaction Transaction {
            get {
                // find the last non-zombied local transaction object, but not transactions
                // that may have been started after the current local transaction
                this.transaction = OleDbTransaction.TransactionZombie(this.transaction);
                return this.transaction;
            }
            set {
                if (this.transaction != value) {
                    OnSchemaChanging(); // fire event before value is validated
                    this.transaction = value;
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.IDbCommand.Transaction"]/*' />
        /// <internalonly/>
        IDbTransaction IDbCommand.Transaction {
            get {
                return Transaction;
            }
            set {
                Transaction = (OleDbTransaction) value;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.UpdatedRowSource"]/*' />
        [
        DataCategory(Res.DataCategory_Behavior),
        DefaultValue(System.Data.UpdateRowSource.Both),
        DataSysDescription(Res.DbCommand_UpdatedRowSource)
        ]
        public UpdateRowSource UpdatedRowSource {
            get {
                return this.updatedRowSource;
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case UpdateRowSource.None:
                case UpdateRowSource.OutputParameters:
                case UpdateRowSource.FirstReturnedRecord:
                case UpdateRowSource.Both:
                    this.updatedRowSource = value;
                    break;
                default:
                    throw ADP.InvalidUpdateRowSource((int) value);
                }
            }
        }

        // required interface, safe cast
        private UnsafeNativeMethods.IAccessor IAccessor() {
#if DEBUG
            Debug.Assert(null != this.icommandText, "IAccessor: null ICommandText");
            ODB.Trace_Cast("ICommandText", "IAccessor", "CreateAccessor");
#endif
            return (UnsafeNativeMethods.IAccessor) this.icommandText;
        }

        // required interface, safe cast
        internal UnsafeNativeMethods.ICommandProperties ICommandProperties() {
#if DEBUG
            Debug.Assert(null != this.icommandText, "ICommandProperties: null ICommandText");
            ODB.Trace_Cast("ICommandText", "ICommandProperties", "GetProperties/SetProperties");
#endif
            return (UnsafeNativeMethods.ICommandProperties) this.icommandText;
        }

        // optional interface, unsafe cast
        private UnsafeNativeMethods.ICommandPrepare ICommandPrepare() {
#if DEBUG
            Debug.Assert(null != this.icommandText, "ICommandPrepare: null ICommandText");
            ODB.Trace_Cast("ICommandText", "ICommandPrepare", "Prepare");
#endif
            UnsafeNativeMethods.ICommandPrepare value = null;
            try {
                value = (UnsafeNativeMethods.ICommandPrepare) this.icommandText;
            }
            catch (InvalidCastException e) {
                ADP.TraceException(e);
            }
            return value;
        }

        // optional interface, unsafe cast
        private UnsafeNativeMethods.ICommandWithParameters ICommandWithParameters() {
#if DEBUG
            Debug.Assert(null != this.icommandText, "ICommandWithParameters: null ICommandText");
            ODB.Trace_Cast("ICommandText", "ICommandWithParameters", "SetParameterInfo");
#endif
            UnsafeNativeMethods.ICommandWithParameters value = null;
            try {
                value = (UnsafeNativeMethods.ICommandWithParameters) this.icommandText;
            }
            catch (InvalidCastException e) {
                throw ODB.NoProviderSupportForParameters(cmdConnection.Provider, e);
            }
            return value;
        }

        private void CreateAccessor() {
            Debug.Assert(System.Data.CommandType.Text == CommandType || System.Data.CommandType.StoredProcedure == CommandType, "CreateAccessor: incorrect CommandType");
            Debug.Assert(ODB.DB_INVALID_HACCESSOR == handle_Accessor, "CreateAccessor: already has accessor");
            Debug.Assert(null == this.dbBindings, "CreateAccessor: already has dbBindings");
            Debug.Assert(HasParameters(), "CreateAccessor: unexpected, no parameter collection");

            // do this first in-case the command doesn't support parameters
            UnsafeNativeMethods.ICommandWithParameters commandWithParameters = ICommandWithParameters();

            int parameterCount = 0;

            OleDbParameterCollection parameters = this.cmdParameters;
            Debug.Assert(0 < parameters.Count, "CreateAccessor: unexpected, no parameters");

            parameterCount = parameters.Count;

            // this.dbBindings is used as a switch during ExecuteCommand, so don't set it until everything okay
            DBBindings bindings = new DBBindings(null, 0, parameterCount, true);
            bindings.collection = parameters;

            // runningTotal is buffered to start values on 16-byte boundary
            // the first parameter * 8 bytes are for the length and status fields
            //bindings.DataBufferSize = (parameterCount + (parameterCount % 2)) * 8;

            UnsafeNativeMethods.tagDBPARAMBINDINFO[] bindInfo = new UnsafeNativeMethods.tagDBPARAMBINDINFO[parameterCount];

            bool computed = false;
            for (int i = 0; i < parameterCount; ++i) {
                computed |= parameters[i].BindParameter(i, bindings, bindInfo);
            }
            bindings.AllocData();

            ApplyParameterBindings(commandWithParameters, parameterCount, bindInfo);

            ApplyAccessor(parameterCount, bindings);

            this.computedParameters = computed;
            this.dbBindings = bindings;
        }

        private void ApplyParameterBindings(UnsafeNativeMethods.ICommandWithParameters commandWithParameters, int count, UnsafeNativeMethods.tagDBPARAMBINDINFO[] bindInfo) {
            int[] ordinals = new int[count];
            for (int i = 0; i < count; ) {
                ordinals[i] = ++i;
            }
            int hr;
#if DEBUG
            ODB.Trace_Begin("ICommandWithParameters", "SetParameterInfo", "ParameterCount=" + count);
#endif
            hr = commandWithParameters.SetParameterInfo((IntPtr)count, ordinals, bindInfo);
#if DEBUG
            ODB.Trace_End("ICommandWithParameters", "SetParameterInfo", hr);
#endif
            if (hr < 0) {
                ProcessResults(hr);
            }
        }

        private void ApplyAccessor(int count, DBBindings bindings) {
            Debug.Assert(ODB.DB_INVALID_HACCESSOR == handle_Accessor, "CreateAccessor: already has accessor");

            UnsafeNativeMethods.DBBindStatus[] rowBindStatus = new UnsafeNativeMethods.DBBindStatus[count];
            UnsafeNativeMethods.tagDBBINDING[] buffer = bindings.DBBinding;
            UnsafeNativeMethods.IAccessor iaccessor = IAccessor();
            int hr;

#if DEBUG
            ODB.Trace_Begin("IAccessor", "CreateAccessor", "ParameterCount=" + count);
#endif
            hr = iaccessor.CreateAccessor(ODB.DBACCESSOR_PARAMETERDATA, count, buffer, bindings.DataBufferSize, out this.handle_Accessor, rowBindStatus);
#if DEBUG
            ODB.Trace_End("IAccessor", "CreateAccessor", hr, "AccessorHandle=" + handle_Accessor);
#endif

            if (hr < 0) {
                ProcessResults(hr);
            }
            for (int i = 0; i < count; ++i) {
                if (UnsafeNativeMethods.DBBindStatus.OK != rowBindStatus[i]) {

                    // check against badbindinfo which can mean provider doesn't support provider owned memory
                    // $CONSIDER - provider entire binding info in the error message
                    throw ODB.BadStatus_ParamAcc(i, rowBindStatus[i]);
                }
            }
        }

        private void ReleaseAccessor() {
            Debug.Assert(null != this.dbBindings, "ReleaseAccessor: doesn't have dbBindings");
            Debug.Assert(ODB.DB_INVALID_HACCESSOR != this.handle_Accessor, "ReleaseAccessor: doesn't have accessor");

            CloseInternalParameters();
            Debug.Assert(null == this.dbBindings, "ReleaseAccessor: has dbBindings");

            if (ODB.DB_INVALID_HACCESSOR != this.handle_Accessor) {
                UnsafeNativeMethods.IAccessor iaccessor = IAccessor();
                int hr, refCount = 0;
#if DEBUG
                ODB.Trace_Begin("IAccessor", "ReleaseAccessor", "Parameter AccessorHandle=" + this.handle_Accessor);
#endif
                hr = iaccessor.ReleaseAccessor(this.handle_Accessor, out refCount);
#if DEBUG
                ODB.Trace_End("IAccessor", "ReleaseAccessor", hr);
#endif
                this.handle_Accessor = ODB.DB_INVALID_HACCESSOR;

                if (hr < 0) {
                    SafeNativeMethods.ClearErrorInfo();
                }
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.Cancel"]/*' />
        public void Cancel() {
            if (null == cmdConnection) {
                throw ADP.ConnectionRequired(ADP.Cancel); // MDAC 69985
            }
            if (0 == (ConnectionState.Open & cmdConnection.StateInternal)) {
                throw ADP.OpenConnectionRequired(ADP.Cancel, cmdConnection.StateInternal);
            }
            UnsafeNativeMethods.ICommandText icmdtxt = this.icommandText;
            if (null != icmdtxt) {
                int hr;
#if DEBUG
                ODB.Trace_Begin("ICommandText", "Cancel");
#endif
                hr = icmdtxt.Cancel();
#if DEBUG
                ODB.Trace_End("ICommandText", "Cancel", hr);
#endif
                if (ODB.DB_E_CANTCANCEL != hr) {
                    // if the provider can't cancel the command - don't cancel the DataReader
                    this.canceling = true;
                }
                // since cancel is allowed to occur at anytime we can't check the connection status
                // since if it returns as closed then the connection will close causing the reader to close
                // and that would introduce the possilbility of one thread reading and one thread closing at the same time
                ProcessResultsNoReset(hr); // MDAC 72667
            }
            else {
                this.canceling = true;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.ICloneable.Clone"]/*' />
        /// <internalonly/>
        Object ICloneable.Clone() {
            OleDbCommand clone = new OleDbCommand(); // MDAC 81448
            clone.Connection = this.Connection;
            clone.CommandText = CommandText;
            clone.CommandTimeout = this.CommandTimeout;
            clone.CommandType = CommandType;
            clone.Transaction = this.Transaction;
            clone.UpdatedRowSource = UpdatedRowSource;

            if (HasParameters()) {
                OleDbParameterCollection parameters = clone.Parameters;
                foreach(ICloneable parameter in Parameters) {
                    parameters.Add(parameter.Clone());
                }
            }
            return clone;
        }

        // Connection.Close & Connection.Dispose(true) notification
        internal void CloseFromConnection(bool canceling) {
            this.canceling = canceling; // MDAC 71435
            CloseInternal();

            this.transaction = null;
        }

        internal void CloseInternal() {
            CloseInternalParameters();
            CloseInternalCommand();
            cmdState = ODB.InternalStateClosed;
        }

        // may be called from either
        //      OleDbDataReader.Close/Dispose
        //      via OleDbCommand.Dispose or OleDbConnection.Close
        internal void CloseFromDataReader(DBBindings bindings) {

            // if connection dies between NextResults, connection will close everything
            // during which something else can open/execute while the first reader is not closed
            bool outputParametersAvailable = !this.canceling && (ODB.InternalStateExecuting != this.cmdState);
            try {
                try {
                    this.dbBindings = bindings; // MDAC 72397
                    if (outputParametersAvailable) {
                        Debug.Assert((ODB.InternalStateFetching == this.cmdState) || ((ODB.InternalStateClosed == this.cmdState) && (null == this.icommandText)), "!InternalStateFetching");

                        if ((null != bindings) && (bindings.collection == this.cmdParameters)) { // Dispose not called
                            GetOutputParameters(); // populate output parameters
                        }
                    }
                }
                finally { // CleanupBindings
                    if (null != bindings) {
                        if (outputParametersAvailable) {
                            bindings.CleanupBindings();
                        }
                        else if (ODB.InternalStateClosed == this.cmdState) { // MDAC 72397
                            // CloseFromConnection or Dispose already called
                            this.dbBindings = null;
                            bindings.Dispose();
                            ReleaseAccessor();
                        }
                    }
                    if (ODB.InternalStateFetching == this.cmdState) {
                        this.cmdConnection.SetStateFetching(false);
                    }
                    this.cmdState = ODB.InternalStateClosed;
                }
                GC.KeepAlive(bindings);
            }
            catch { // MDAC 80973
                throw;
            }
        }

        private void CloseInternalCommand() {
            this.commandBehavior = CommandBehavior.Default;
            this.isPrepared = false;
            this.handle_Accessor = IntPtr.Zero;

            if (null != this.icommandText) {
#if DEBUG
                ODB.Trace_Release("ICommandText");
#endif
                Marshal.ReleaseComObject(this.icommandText);
                this.icommandText = null;
            }
        }
        private void CloseInternalParameters() {
            if (null != this.dbBindings) {
                this.dbBindings.Dispose();
                GC.KeepAlive(this.dbBindings);
                this.dbBindings = null;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.CreateParameter"]/*' />
        public OleDbParameter CreateParameter() {
            return new OleDbParameter();
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.IDbCommand.CreateParameter"]/*' />
        /// <internalonly/>
        IDbDataParameter IDbCommand.CreateParameter() { // MDAC 68310
            return CreateParameter();
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects
                // the DataReader takes ownership of the parameter DBBindings
                // this way they don't get destroyed when user calls OleDbCommand.Dispose
                // when there is an open DataReader

                if (null != this.cmdConnection) {
                    this.cmdConnection.RemoveWeakReference(this);
                    this.cmdConnection = null;
                }
                this.transaction = null;
                this.cmdText = null;
                this.cmdParameters = null;

                CloseInternal();
            }
            // release unmanaged objects
            base.Dispose(disposing); // notify base classes
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.ExecuteReader"]/*' />
        public OleDbDataReader ExecuteReader() {
            return ExecuteReader(CommandBehavior.Default);
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.IDbCommand.ExecuteReader"]/*' />
        /// <internalonly/>
        IDataReader IDbCommand.ExecuteReader() {
            return ExecuteReader(CommandBehavior.Default);
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.ExecuteReader1"]/*' />
        public OleDbDataReader ExecuteReader(CommandBehavior behavior) {
            OleDbConnection.OleDbPermission.Demand();

            this.executeQuery = true;
            try {
                return ExecuteReaderInternal(behavior, ADP.ExecuteReader);
            }
            catch { // MDAC 80973
                throw;
            }
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.IDbCommand.ExecuteReader1"]/*' />
        /// <internalonly/>
        IDataReader IDbCommand.ExecuteReader(CommandBehavior behavior) {
            return ExecuteReader(behavior);
        }

        private OleDbDataReader ExecuteReaderInternal(CommandBehavior behavior, string method) {
            OleDbDataReader dataReader = null;
            int localState = ODB.InternalStateClosed;
            try {
                ValidateConnectionAndTransaction(method, ref localState);

                if (0 != (CommandBehavior.SingleRow & behavior)) {
                    // CommandBehavior.SingleRow implies CommandBehavior.SingleResult
                    behavior |= CommandBehavior.SingleResult;
                }

                object executeResult;
                int resultType;

                switch(this.cmdType) {
                case CommandType.Text:
                case CommandType.StoredProcedure:
                    /*if ((CommandType.StoredProcedure == cmdType) && (0 != (CommandBehavior.SchemaOnly & behavior)) && connection.SupportSchemaRowset(OleDbSchemaGuid.Procedure_Columns, out support)) {
                        DataTable table = connection.GetSchemaRowset(OleDbSchemaGuid.Procedure_Columns, new object[] { DBNull.Value, DBNull.Value, CommandText, DBNull.Value});
                    } else*/
                    resultType = ExecuteCommand(behavior, out executeResult);
                    break;

                case CommandType.TableDirect:
                    /*if ((0 != (CommandBehavior.SchemaOnly & behavior)) && connection.SupportSchemaRowset(OleDbSchemaGuid.Columns, out support)) {
                        DataTable table = connection.GetSchemaRowset(OleDbSchemaGuid.Columns, new object[] { DBNull.Value, DBNull.Value, CommandText, DBNull.Value});
                    } else */
                    resultType = ExecuteTableDirect(behavior, out executeResult);
                    break;

                default:
                    throw ADP.InvalidCommandType(CommandType);
                }

                Debug.Assert(ODB.InternalStateExecuting == this.cmdState, "!InternalStateExecuting");

                if (executeQuery) {
                    try {
                        dataReader = new OleDbDataReader(this.cmdConnection, this, 0, IntPtr.Zero);

                        switch(resultType) {
                        case ODB.ExecutedIMultipleResults:
                            dataReader.InitializeIMultipleResults(executeResult, this.commandBehavior);
                            dataReader.NextResult();
                            break;
                        case ODB.ExecutedIRowset:
                            dataReader.InitializeIRowset(executeResult, recordsAffected, this.commandBehavior);
                            dataReader.BuildMetaInfo();
                            dataReader.HasRowsRead();
                            break;
                        case ODB.ExecutedIRow:
                            dataReader.InitializeIRow(executeResult, recordsAffected, this.commandBehavior);
                            dataReader.BuildMetaInfo();
                            break;
                        case ODB.PrepareICommandText:
                            if (!this.isPrepared) {
                                PrepareCommandText(2);
                            }
                            OleDbDataReader.GenerateSchemaTable(dataReader, this.icommandText, behavior);
                            break;
                        default:
                            Debug.Assert(false, "ExecuteReaderInternal: unknown result type");
                            break;
                        }
                        executeResult = null;
                        this.cmdConnection.AddWeakReference(dataReader);

                        // command stays in the executing state until the connection
                        // has a datareader to track for it being closed
                        localState = ODB.InternalStateFetching; // MDAC 72655
                        this.cmdState = ODB.InternalStateFetching;
                        this.cmdConnection.SetStateFetching(true);
                    }
                    finally { // canceling
                        if ((ODB.InternalStateFetching != this.cmdState) || this.canceling) {
                            this.canceling = true;
                            if (null != dataReader) {
                                ((IDisposable) dataReader).Dispose();
                                dataReader = null;
                            }
                        }
                    }
                    Debug.Assert(null != dataReader, "ExecuteReader should never return a null DataReader");
                }
                else { // optimized code path for ExecuteNonQuery to not create a OleDbDataReader object
                    try {
                        if (ODB.ExecutedIMultipleResults == resultType) {
                            UnsafeNativeMethods.IMultipleResults multipleResults = (UnsafeNativeMethods.IMultipleResults) executeResult;

                            // may cause a Connection.ResetState which closes connection
                            this.recordsAffected = OleDbDataReader.NextResults(multipleResults, this.cmdConnection, this);
                        }
                        // command stays in the executing state until the connection
                        // has a datareader to track for it being closed
                        localState = ODB.InternalStateFetching; // MDAC 72655
                        this.cmdState = ODB.InternalStateFetching;
                        this.cmdConnection.SetStateFetching(true);
                    }
                    finally { // CloseFromDataReader
                        if (null != executeResult) {
#if DEBUG
                            ODB.Trace_Release("ExecuteResult");
#endif
                            Marshal.ReleaseComObject(executeResult);
                            executeResult = null;
                        }
                        CloseFromDataReader(this.dbBindings);
                    }
                }
            }
            finally { // finally clear executing state
                if ((null == dataReader) && (0 != (ODB.InternalStateOpen & localState))) { // MDAC 67218
                    ParameterCleanup();
                    this.cmdState = ODB.InternalStateClosed;
                }
                if (ODB.InternalStateExecuting == localState) {
                    // during the normal case, the 'Executing' flag would be cleared by calling SetStateFetching
                    // this exists to clear the flag during the exception case
                    this.cmdConnection.SetStateExecuting(this, method, false);
                }
            }
            GC.KeepAlive(dataReader);
            GC.KeepAlive(this);
            return dataReader;
        }

        private int ExecuteCommand(CommandBehavior behavior, out object executeResult) {
            if (InitializeCommand(behavior, false)) {
                if (0 != (CommandBehavior.SchemaOnly & this.commandBehavior)) {
                    executeResult = null;
                    return ODB.PrepareICommandText;
                }
                return ExecuteCommandText(out executeResult);
            }
            return ExecuteTableDirect(behavior, out executeResult); // MDAC 57856
        }

        // dbindings handle can't be freed until the output parameters
        // have been filled in which occurs after the last rowset is released
        // dbbindings.FreeDataHandle occurs in
        //    GetOutputParameters & Close
        private int ExecuteCommandText(out object executeResult) {
            UnsafeNativeMethods.tagDBPARAMS dbParams = null;
            if (null != this.dbBindings) { // parameters may be suppressed
                dbParams = GetInputParameters(); // data value buffer unpinned during GetOutputParameters
            }
            if ((0 == (CommandBehavior.SingleResult & this.commandBehavior)) && this.cmdConnection.SupportMultipleResults()) {
                return ExecuteCommandTextForMultpleResults(dbParams, out executeResult);
            }
            else if (0 == (CommandBehavior.SingleRow & this.commandBehavior) || !this.executeQuery) {
                return ExecuteCommandTextForSingleResult(dbParams, out executeResult);
            }
            return ExecuteCommandTextForSingleRow(dbParams, out executeResult);
        }

        private int ExecuteCommandTextForMultpleResults(UnsafeNativeMethods.tagDBPARAMS dbParams, out object executeResult) {
            Debug.Assert(0 == (CommandBehavior.SingleRow & this.commandBehavior), "SingleRow implies SingleResult");
            int hr;
#if DEBUG
            ODB.Trace_Begin("ICommandText", "Execute", "IMultipleResults");
#endif
            hr = this.icommandText.Execute(IntPtr.Zero, ODB.IID_IMultipleResults, dbParams, out recordsAffected, out executeResult);
#if DEBUG
            ODB.Trace_End("ICommandText", "Execute", hr, "RecordsAffected=" + recordsAffected);
#endif
            if (ODB.E_NOINTERFACE != hr) {
                ExecuteCommandTextErrorHandling(hr);
                return ODB.ExecutedIMultipleResults;
            }
            SafeNativeMethods.ClearErrorInfo();
            return ExecuteCommandTextForSingleResult(dbParams, out executeResult);
        }

        private int ExecuteCommandTextForSingleResult(UnsafeNativeMethods.tagDBPARAMS dbParams, out object executeResult) {
            int hr;

            // MDAC 64465 (Microsoft.Jet.OLEDB.4.0 returns 0 for recordsAffected instead of -1)
            if (this.executeQuery) {
#if DEBUG
                ODB.Trace_Begin("ICommandText", "Execute", "IRowset: IID_IRowset");
#endif
                hr = this.icommandText.Execute(IntPtr.Zero, ODB.IID_IRowset, dbParams, out recordsAffected, out executeResult);
            }
            else {
#if DEBUG
                ODB.Trace_Begin("ICommandText", "Execute", "IRowset: IID_NULL");
#endif
                hr = this.icommandText.Execute(IntPtr.Zero, ODB.IID_NULL, dbParams, out recordsAffected, out executeResult);
            }
#if DEBUG
            ODB.Trace_End("ICommandText", "Execute", hr, "RecordsAffected=" + recordsAffected);
#endif
            ExecuteCommandTextErrorHandling(hr);
            return ODB.ExecutedIRowset;
        }

        private int ExecuteCommandTextForSingleRow(UnsafeNativeMethods.tagDBPARAMS dbParams, out object executeResult) {
            Debug.Assert(this.executeQuery, "ExecuteNonQuery should always use ExecuteCommandTextForSingleResult");

            if (this.cmdConnection.SupportIRow(this)) {
                int hr;
#if DEBUG
                ODB.Trace_Begin("ICommandText", "Execute", "IRow: IID_IRow");
#endif
                hr = icommandText.Execute(IntPtr.Zero, ODB.IID_IRow, dbParams, out recordsAffected, out executeResult);
#if DEBUG
                ODB.Trace_End("ICommandText", "Execute", hr, "RecordsAffected=" + recordsAffected);
#endif
                if (ODB.DB_E_NOTFOUND == hr) { // MDAC 76110
                    SafeNativeMethods.ClearErrorInfo();
                    return ODB.ExecutedIRow;
                }
                else if (ODB.E_NOINTERFACE != hr) {
                    ExecuteCommandTextErrorHandling(hr);
                    return ODB.ExecutedIRow;
                }
            }
            SafeNativeMethods.ClearErrorInfo();
            return ExecuteCommandTextForSingleResult(dbParams, out executeResult);
        }

        private void ExecuteCommandTextErrorHandling(int hr) {
            Exception e = OleDbConnection.ProcessResults(hr, this.cmdConnection, this);
            if (null != e) {
                e = ExecuteCommandTextSpecialErrorHandling(hr, e);
                throw e;
            }
        }

        private Exception ExecuteCommandTextSpecialErrorHandling(int hr, Exception e) {
            if (((ODB.DB_E_ERRORSOCCURRED == hr) || (ODB.DB_E_BADBINDINFO == hr)) && (null != this.dbBindings)) { // MDAC 66026, 67039
                //
                // this code exist to try for a better user error message by post-morten detection
                // of invalid parameter types being passed to a provider that doesn't understand
                // the user specified parameter OleDbType

                Debug.Assert(null != e, "missing inner exception");

                OleDbParameterCollection parameters = cmdParameters; // MDAC 53656
                StringBuilder builder = new StringBuilder();
                int parameterCount = parameters.Count;
                for (int i = 0; i < parameterCount; ++i) {
                    this.dbBindings.CurrentIndex = i;
                    ODB.CommandParameterStatus(builder, parameters[i].ParameterName, i, this.dbBindings.StatusValue);
                }
                e = ODB.CommandParameterStatus(builder.ToString(), e);
            }
            return e;
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.ExecuteNonQuery"]/*' />
        public int ExecuteNonQuery() {
            OleDbConnection.OleDbPermission.Demand();

            this.executeQuery = false;
            try {
                ExecuteReaderInternal(CommandBehavior.Default, ADP.ExecuteNonQuery);
            }
            catch { // MDAC 80973
                throw;
            }
            Debug.Assert(ODB.InternalStateClosed == this.cmdState, "internal failure, still executing");
            return this.recordsAffected;
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.ExecuteScalar"]/*' />
        public object ExecuteScalar() {
            OleDbConnection.OleDbPermission.Demand();

            object value = null;
            try {
                this.executeQuery = true;
                using(OleDbDataReader reader = ExecuteReaderInternal(CommandBehavior.Default, ADP.ExecuteScalar)) { // MDAC 66990
                    if (reader.Read() && (0 < reader.FieldCount)) {
                        value = reader.GetValue(0);
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
            Debug.Assert(ODB.InternalStateClosed == this.cmdState, "internal failure, still executing");
            return value;
        }

        private int ExecuteTableDirect(CommandBehavior behavior, out object executeResult) {
            this.commandBehavior = behavior;

            StringPtr sptr = new StringPtr(ExpandCommandText());
            UnsafeNativeMethods.tagDBID tableID = new UnsafeNativeMethods.tagDBID();
            tableID.uGuid = Guid.Empty;
            tableID.eKind = ODB.DBKIND_NAME;
            tableID.ulPropid = sptr.ptr;

            UnsafeNativeMethods.IOpenRowset iopenRowset = this.cmdConnection.IOpenRowset();
            int hr;

            DBPropSet propSet = CommandPropertySets();
#if DEBUG
            ODB.Trace_Begin("IOpenRowset", "OpenRowset", "IID_IRowset");
#endif
            // MDAC 65279
            hr = iopenRowset.OpenRowset(IntPtr.Zero, tableID, IntPtr.Zero, ODB.IID_IRowset, propSet.PropertySetCount, propSet, out executeResult);
            propSet.Dispose();

            // provider doesn't support the properties - so try again without passing them along
            if (ODB.DB_E_ERRORSOCCURRED == hr) {
#if DEBUG
                ODB.Trace_Begin("IOpenRowset", "OpenRowset", "DB_E_ERRORSOCCURRED - RETRY");
#endif
                hr = iopenRowset.OpenRowset(IntPtr.Zero, tableID, IntPtr.Zero, ODB.IID_IRowset, 0, ADP.NullHandle, out executeResult);
            }
#if DEBUG
            ODB.Trace_End("IOpenRowset", "OpenRowset", hr);
#endif
            sptr.Dispose();
            ProcessResults(hr);
            this.recordsAffected = -1;
            return ODB.ExecutedIRowset;
        }

        private string ExpandCommandText() {
            if ((null == this.cmdText) || (0 == this.cmdText.Length)) {
                return String.Empty;
            }
            switch(CommandType) {
            case System.Data.CommandType.Text:
                // do nothing, already expanded by user
                return this.cmdText;

            case System.Data.CommandType.StoredProcedure:
                // { ? = CALL SPROC (? ?) }, { ? = CALL SPROC }, { CALL SPRC (? ?) }, { CALL SPROC }
                return ExpandStoredProcedureToText(this.cmdText);

            case System.Data.CommandType.TableDirect:
                // @devnote: Provider=Jolt4.0 doesn't like quoted table names, SQOLEDB requires them
                // Providers should not require table names to be quoted and should guarantee that
                // unquoted table names correctly open the specified table, even if the table name
                // contains special characters, as long as the table can be unambiguously identified
                // without quoting.
                return this.cmdText;

            default:
                throw ADP.InvalidCommandType(CommandType);
            }
        }

        private string ExpandOdbcMaximumToText(string sproctext, int parameterCount) {
            StringBuilder builder = new StringBuilder();
            if ((0 < parameterCount) && (ParameterDirection.ReturnValue == Parameters[0].Direction)) {
                parameterCount--;
                builder.Append("{ ? = CALL ");
            }
            else {
                builder.Append("{ CALL ");
            }
            builder.Append(sproctext);

            switch(parameterCount) {
            case 0:
                builder.Append(" }");
                break;
            case 1:
                builder.Append("( ? ) }");
                break;
            default:
                builder.Append("( ?, ?");
                for (int i = 2; i < parameterCount; ++i) {
                    builder.Append(", ?");
                }
                builder.Append(" ) }");
                break;
            }
            return builder.ToString();
        }

        private string ExpandOdbcMinimumToText(string sproctext, int parameterCount) {
            //if ((0 < parameterCount) && (ParameterDirection.ReturnValue == Parameters[0].Direction)) {
            //    Debug.Assert("doesn't support ReturnValue parameters");
            //}
            StringBuilder builder = new StringBuilder();
            builder.Append("exec ");
            builder.Append(sproctext);
            if (0 < parameterCount) {
                builder.Append(" ?");
                for(int i = 1; i < parameterCount; ++i) {
                    builder.Append(", ?");
                }
            }
            return builder.ToString();
        }

        private string ExpandStoredProcedureToText(string sproctext) {
            Debug.Assert(null != this.cmdConnection, "ExpandStoredProcedureToText: null Connection");

            int parameterCount = (null != this.cmdParameters) ? this.cmdParameters.Count : 0;
            if (0 == (ODB.DBPROPVAL_SQL_ODBC_MINIMUM & this.cmdConnection.SqlSupport())) {
                return ExpandOdbcMinimumToText(sproctext, parameterCount);
            }
            return ExpandOdbcMaximumToText(sproctext, parameterCount);
        }

        private UnsafeNativeMethods.tagDBPARAMS GetInputParameters() {
            Debug.Assert(null != this.dbBindings, "caller didn't check");

            // bindings can't be released until after last rowset is released
            // that is when output parameters are populated
            // initialize the input parameters to the input databuffer
            OleDbParameterCollection parameters = this.cmdParameters;
            int parameterCount = parameters.Count;
            for (int i = 0; i < parameterCount; ++i) {
                OleDbParameter parameter = parameters[i];

                if (0 != (ParameterDirection.Input & parameter.Direction)) {
                    this.dbBindings.CurrentIndex = i;
                    this.dbBindings.Value = parameter.GetParameterValue();
                }
                else {
                    // always set ouput only and return value parameter values to null when executing
                    parameter.Value = null;
                }
            }
            UnsafeNativeMethods.tagDBPARAMS dbParams = new UnsafeNativeMethods.tagDBPARAMS();

            dbParams.pData = this.dbBindings.DataHandle;
            dbParams.cParamSets = 1;
            dbParams.hAccessor = this.handle_Accessor;

            return dbParams;
        }

        private void GetOutputParameters() {
            // dbindings handle can't be freed until the output parameters (here)

            Debug.Assert(null != this.dbBindings, "caller didn't check");

            // output parameters are not valid until after execution is fully completed
            OleDbParameterCollection parameters = this.cmdParameters;
            int parameterCount = parameters.Count;
            for (int i = 0; i < parameterCount; ++i) {
                OleDbParameter parameter = parameters[i];
                if (0 != (ParameterDirection.Output & parameter.Direction)) {
                    this.dbBindings.CurrentIndex = i;
                    parameter.Value = this.dbBindings.Value;
                }
            }
            // ParameterCleanup called by CloseFromDataReader
        }

        private void ParameterCleanup() {
            if (null != this.dbBindings) {
                this.dbBindings.CleanupBindings();
            }
        }

        private bool InitializeCommand(CommandBehavior behavior, bool throwifnotsupported) {
            Debug.Assert(ODB.InternalStateExecuting == this.cmdState, "wrong internal state");
            Debug.Assert(null != this.cmdConnection, "InitializeCommand: null OleDbConnection");

            if (0 != (CommandBehavior.KeyInfo & (this.commandBehavior ^ behavior))) {
                CloseInternalParameters(); // could optimize out
                CloseInternalCommand();
            }
            this.commandBehavior = behavior;

            bool settext = (null == this.icommandText);
            if (settext) {
                Debug.Assert(!this.isPrepared, "InitializeCommand: isPrepared");

                this.icommandText = this.cmdConnection.ICommandText();

                if (null == this.icommandText) {
                    if (throwifnotsupported || HasParameters()) {
                        throw ODB.CommandTextNotSupported(cmdConnection.Provider, null);
                    }
                    return false; // MDAC 57856
                }
            }

            PropertyValueSetInternal();

            if (computedParameters && (null != this.dbBindings)) {
                ReleaseAccessor();
            }

            // if we already having bindings - don't create the accessor
            // if cmdParameters is null - no parameters exist - don't create the collection
            // do we actually have parameters since the collection exists
            if ((null == this.dbBindings) && HasParameters()) {
                // if we setup the parameters before setting cmdtxt then named parameters can happen
                CreateAccessor();
            }

            if (settext) {
                int hr;

                String commandText = ExpandCommandText();
#if DEBUG
                ODB.Trace_Begin(2, "ICommandText", "SetCommandText", commandText);
#endif
                hr = this.icommandText.SetCommandText(ODB.DBGUID_DEFAULT, commandText);
#if DEBUG
                ODB.Trace_End("ICommandText", "SetCommandText", hr);
#endif
                if (hr < 0) {
                    ProcessResults(hr);
                }
            }

            return true;
        }

        //internal void OnSchemaChanged() {
        //}

        internal void OnSchemaChanging() {
            int state = this.cmdState;
            if (ODB.InternalStateClosed != state) {
                if (!this.cmdConnection.RecoverReferences(this)) { // MDAC 86765
                    throw ADP.CommandIsActive(this, (ConnectionState) state);
                }
            }
            CloseInternal();
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.Prepare"]/*' />
        public void Prepare() {
            OleDbConnection.OleDbPermission.Demand();

            if (CommandType.TableDirect != CommandType) { // MDAC 70946, 71194
                int localState = ODB.InternalStateClosed;
                try {
                    try {
                        ValidateConnectionAndTransaction(ADP.Prepare, ref localState);
                        Debug.Assert(ODB.InternalStateExecuting == this.cmdState, "!InternalStateExecuting");

                        this.isPrepared = false;
                        if (CommandType.TableDirect != CommandType) {
                            InitializeCommand(0, true);
                            PrepareCommandText(1);
                        }
                    }
                    finally { // cmdState
                        if (0 != (ODB.InternalStateOpen & localState)) { // MDAC 67218
                            this.cmdState = ODB.InternalStateClosed;
                        }
                        if (ODB.InternalStateExecuting == localState) {
                            this.cmdConnection.SetStateExecuting(this, ADP.Prepare, false);
                        }
                    }
                    GC.KeepAlive(this);
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        private void PrepareCommandText(int expectedExecutionCount) {
            if (null != cmdParameters) {
                int count = cmdParameters.Count;
                for (int i = 0; i < count; ++i) {
                    cmdParameters[i].Prepare(this); // MDAC 70232
                }
            }
            UnsafeNativeMethods.ICommandPrepare icommandPrepare = ICommandPrepare();
            if (null != icommandPrepare) {
                int hr;
#if DEBUG
                ODB.Trace_Begin("ICommandPrepare", "Prepare", "ExepectedCount=" + expectedExecutionCount);
#endif
                hr = icommandPrepare.Prepare(expectedExecutionCount);
#if DEBUG
                ODB.Trace_End("ICommandPrepare", "Prepare", hr);
#endif
                ProcessResults(hr);

            }
            // don't recompute bindings on prepared statements
            this.computedParameters = false; // MDAC 67065
            this.isPrepared = true;
        }

        private void ProcessResults(int hr) {
            Exception e = OleDbConnection.ProcessResults(hr, this.cmdConnection, this);
            if (null != e) { throw e; }
        }

        private void ProcessResultsNoReset(int hr) {
            Exception e = OleDbConnection.ProcessResults(hr, null, this);
            if (null != e) { throw e; }
        }

        internal Exception PropertyValueErrors(Exception inner) {
            if (null == this.icommandText) {
                return inner;
            }
            DBPropSet propSet = new DBPropSet();
            UnsafeNativeMethods.ICommandProperties icommandProperties = ICommandProperties();

            int hr;
            IntPtr propIDSet = IntPtr.Zero;
            try {
                try {
                    // using native memory as a sideaffect of optimizing for
                    // the PropertyValueGetInitial scenario
                    propIDSet = Marshal.AllocCoTaskMem(ODB.SizeOf_tagDBPROPIDSET);
                    Marshal.WriteIntPtr(propIDSet, 0, IntPtr.Zero);
                    Marshal.WriteInt32(propIDSet, IntPtr.Size, 0);

                    IntPtr ptr = ADP.IntPtrOffset(propIDSet, IntPtr.Size + /*sizeof(int32)*/4); // MDAC 69539
                    Marshal.StructureToPtr(OleDbPropertySetGuid.PropertiesInError, ptr, false/*deleteold*/);

#if DEBUG
                    ODB.Trace_Begin("ICommandProperties", "GetProperties", "PROPERTIESINERROR");
#endif
                    hr = icommandProperties.GetProperties(1, new HandleRef(this, propIDSet), out propSet.totalPropertySetCount, out propSet.nativePropertySet);
#if DEBUG
                    ODB.Trace_End("ICommandProperties", "GetProperties", hr, "PropertySetsCount = " + propSet.totalPropertySetCount);
#endif
                    if (hr < 0) {
                        SafeNativeMethods.ClearErrorInfo();
                    }
                }
                finally { // FreeCoTaskMem
                    Marshal.FreeCoTaskMem(propIDSet);
                }
            }
            catch { // MDAC 80973
                throw;
            }
            // this will free if required everything in rgPropertySets
            return OleDbConnection.PropertyErrors(this.cmdConnection, propSet, inner);
        }

        private void PropertyValueSetInternal() {
            DBPropSet propSet = CommandPropertySets();

            UnsafeNativeMethods.ICommandProperties icommandProperties = ICommandProperties();
            int hr;
#if DEBUG
            ODB.Trace_Begin("ICommandProperties", "SetProperties");
#endif
            hr = icommandProperties.SetProperties(propSet.PropertySetCount, propSet);
#if DEBUG
            ODB.Trace_End("ICommandProperties", "SetProperties", hr);
#endif
            if (hr < 0) {
                SafeNativeMethods.ClearErrorInfo();
            }
            propSet.Dispose();
        }

        private int PropertyValueResults(int hr, DBPropSet propSet, out object value) {
            value = null;
            int status = ODB.DBPROPSTATUS_NOTSUPPORTED;
            if (ODB.DB_E_ERRORSOCCURRED != hr) {
                if (hr < 0) {
                    ProcessResults(hr);
                }
                if (null != propSet) {
                    if (0 < propSet.PropertySetCount) {
                        propSet.ReadPropertySet();
                        if (0 < propSet.PropertyCount) {
                            value = propSet.ReadProperty();
                            status = propSet.Status;
                        }
                    }
                    propSet.Dispose();
                }
            }
            return status;
        }

        internal int CommandProperties(int propertyId, out object value) {
            UnsafeNativeMethods.ICommandProperties icommandProperties = ICommandProperties();

            DBPropSet propSet = new DBPropSet();
            PropertyIDSetWrapper propertyIDSet = cmdConnection.PropertyIDSet(OleDbPropertySetGuid.Rowset, propertyId);

            int hr;
#if DEBUG
            ODB.Trace_Begin(3, "IDBProperties", "GetProperties", ODB.PLookup(propertyId));
#endif
            hr = icommandProperties.GetProperties(1, propertyIDSet, out propSet.totalPropertySetCount, out propSet.nativePropertySet);
#if DEBUG
            ODB.Trace_End(3, "IDBProperties", "GetProperties", hr, "PropertySetsCount = " + propSet.totalPropertySetCount);
#endif
            GC.KeepAlive(propertyIDSet);
            return PropertyValueResults(hr, propSet, out value);
        }

        private DBPropSet CommandPropertySets() {
            DBPropSet propSet = new DBPropSet();
            propSet.PropertySetCount = 1;

            bool keyInfo = (0 != (CommandBehavior.KeyInfo & this.commandBehavior));

            // CommandTimeout, Access Order, UniqueRows, IColumnsRowset
            int count = (executeQuery ? (keyInfo ? 4 : 2) : 1);

            propSet.WritePropertySet(OleDbPropertySetGuid.Rowset, count);

            // always set the CommandTimeout value
            propSet.WriteProperty(ODB.DBPROP_COMMANDTIMEOUT, CommandTimeout);

            if (this.executeQuery) {
                // UNDONE: this appears to create a cursor by default for SQLOLEDB

                // 'Microsoft.Jet.OLEDB.4.0' default is DBPROPVAL_AO_SEQUENTIAL
                propSet.WriteProperty(ODB.DBPROP_ACCESSORDER, ODB.DBPROPVAL_AO_RANDOM); // MDAC 73030

                if (keyInfo) {
                    // 'Unique Rows' property required for SQLOLEDB to retrieve things like 'BaseTableName'
                    propSet.WriteProperty(ODB.DBPROP_UNIQUEROWS, keyInfo);

                    // otherwise 'Microsoft.Jet.OLEDB.4.0' doesn't support IColumnsRowset
                    propSet.WriteProperty(ODB.DBPROP_IColumnsRowset, true);
                }
            }
            return propSet;
        }

        /// <include file='doc\OleDbCommand.uex' path='docs/doc[@for="OleDbCommand.ResetCommandTimeout"]/*' />
        public void ResetCommandTimeout() {
            this.commandTimeout = ADP.DefaultCommandTimeout;
        }

        internal DBBindings TakeBindingOwnerShip() {
            DBBindings bindings = this.dbBindings;
            this.dbBindings = null;
            return bindings;
        }

        private void ValidateConnectionAndTransaction(string method, ref int localState) {
            int state = Interlocked.CompareExchange(ref this.cmdState, ODB.InternalStateExecuting, ODB.InternalStateClosed);
            if (ODB.InternalStateClosed != state) {
                // if previous state was executing, then user calling execute in multi-thread way
                // if previous state was fetching, then a datareader may be active
                // since not closed, connection should be non-null
                if ((ODB.InternalStateFetching != state) || !this.cmdConnection.RecoverReferences(this)) {
                    throw ADP.OpenConnectionRequired(method, (ConnectionState) state);
                }

                // a previous datareader has been finalized without user calling Close
                ParameterCleanup();
                this.cmdState = ODB.InternalStateExecuting;
            }

            localState = ODB.InternalStateOpen; // MDAC 67218
            if (null == this.cmdConnection) {
                throw ADP.ConnectionRequired(method);
            }
            this.cmdConnection.SetStateExecuting(this, method, true);

            localState = ODB.InternalStateExecuting;

            Debug.Assert(0 != (ConnectionState.Open & this.cmdConnection.StateInternal), "Connection.State: not Open");
            Debug.Assert(0 != (ConnectionState.Executing & this.cmdConnection.StateInternal), "Connection.State: not Executing");
            this.transaction = this.cmdConnection.ValidateTransaction(Transaction);
            this.canceling = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbcommandbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbCommandBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbCommandBuilder : Component {
        private CommandBuilder cmdBuilder;

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.OleDbCommandBuilder"]/*' />
        public OleDbCommandBuilder() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.OleDbCommandBuilder1"]/*' />
        public OleDbCommandBuilder(OleDbDataAdapter adapter) : base() {
            GC.SuppressFinalize(this);
            DataAdapter = adapter;
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.DataAdapter"]/*' />
        [
        DefaultValue(null),
        DataSysDescription(Res.OleDbCommandBuilder_DataAdapter) // MDAC 60524
        ]
        public OleDbDataAdapter DataAdapter {
            get {
                return (OleDbDataAdapter) GetBuilder().DataAdapter;
            }
            set {
                GetBuilder().DataAdapter = value;
            }
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.QuotePrefix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbCommandBuilder_QuotePrefix)
        ]
        public string QuotePrefix {
            get {
                return GetBuilder().QuotePrefix;
            }
            set {
                GetBuilder().QuotePrefix = value;
            }
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.QuoteSuffix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.OleDbCommandBuilder_QuoteSuffix)
        ]
        public string QuoteSuffix {
            get {
                return GetBuilder().QuoteSuffix;
            }
            set {
                GetBuilder().QuoteSuffix = value;
            }
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects
                if (null != this.cmdBuilder) {
                    this.cmdBuilder.Dispose();
                    this.cmdBuilder = null;
                }
            }
            //release unmanaged objects

            base.Dispose(disposing); // notify base classes
        }

        // method instead of property because VS7 debugger will evaluate
        // properties and we don't want the object created just for that
        private CommandBuilder GetBuilder() {
            if (null == this.cmdBuilder) {
                this.cmdBuilder = new CommandBuilder();
            }
            return this.cmdBuilder;
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.GetInsertCommand"]/*' />
        public OleDbCommand GetInsertCommand() {
            return (OleDbCommand) GetBuilder().GetInsertCommand();
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.GetUpdateCommand"]/*' />
        public OleDbCommand GetUpdateCommand() {
            return (OleDbCommand) GetBuilder().GetUpdateCommand();
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.GetDeleteCommand"]/*' />
        public OleDbCommand GetDeleteCommand() {
            return (OleDbCommand) GetBuilder().GetDeleteCommand();
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.RefreshSchema"]/*' />
        public void RefreshSchema() {
            GetBuilder().RefreshSchema();
        }

        /// <include file='doc\OleDbCommandBuilder.uex' path='docs/doc[@for="OleDbCommandBuilder.DeriveParameters"]/*' />
        static public void DeriveParameters(OleDbCommand command) { // MDAC 65927
            OleDbConnection.OleDbPermission.Demand();

            if (null == command) {
                throw ADP.ArgumentNull("command");
            }
            switch (command.CommandType) {
                case System.Data.CommandType.Text:
                    throw ADP.DeriveParametersNotSupported(command);
                case System.Data.CommandType.StoredProcedure:
                    break;
                case System.Data.CommandType.TableDirect:
                    // CommandType.TableDirect - do nothing, parameters are not supported
                    throw ADP.DeriveParametersNotSupported(command);
                default:
                    throw ADP.InvalidCommandType(command.CommandType);
            }
            if (ADP.IsEmpty(command.CommandText)) {
                throw ADP.CommandTextRequired(ADP.DeriveParameters);
            }
            OleDbConnection connection = command.Connection;
            if (null == connection) {
                throw ADP.ConnectionRequired(ADP.DeriveParameters);
            }
            ConnectionState state = connection.State;
            if (ConnectionState.Open != state) {
                throw ADP.OpenConnectionRequired(ADP.DeriveParameters, state);
            }
            OleDbParameter[] list = DeriveParametersFromStoredProcedure(connection, command);

            OleDbParameterCollection parameters = command.Parameters;
            parameters.Clear();

            int count = list.Length;
            if (0 < count) {
                for(int i = 0; i < list.Length; ++i) {
                    parameters.Add(list[i]);
                }
            }
        }

        // known difference: when getting the parameters for a sproc, the
        //   return value gets marked as a return value but for a sql stmt
        //   the return value gets marked as an output parameter.
        static private OleDbParameter[] DeriveParametersFromStoredProcedure(OleDbConnection connection, OleDbCommand command) {
            OleDbParameter[] plist = new OleDbParameter[0];

            int support = 0;
            if (connection.SupportSchemaRowset(OleDbSchemaGuid.Procedure_Parameters, out support)) {
                Object[] parsed = ADP.ParseProcedureName(command.CommandText); // MDAC 70930
                Object[] restrictions = new object[4];
                object value;

                // Parse returns 4 part array:
                // 0) Server
                // 1) Catalog
                // 2) Schema
                // 3) ProcedureName

                // Restrictions array which is passed to OleDb API expects:
                // 0) Catalog
                // 1) Schema
                // 2) ProcedureName
                // 3) ParameterName (leave null)

                // Copy from Parse format to OleDb API format
                Array.Copy(parsed, 1, restrictions, 0, 3);
                
                //if (cmdConnection.IsServer_msdaora) {
                //    restrictions[1] = Convert.ToString(cmdConnection.UserId).ToUpper(CultureInfo.InvariantCulture);
                //}
                DataTable table = connection.GetSchemaRowset(OleDbSchemaGuid.Procedure_Parameters, restrictions);

                if (null != table) {
                    DataColumnCollection columns = table.Columns;

                    DataColumn parameterName = null;
                    DataColumn parameterDirection = null;
                    DataColumn dataType = null;
                    DataColumn maxLen = null;
                    DataColumn numericPrecision = null;
                    DataColumn numericScale = null;
                    DataColumn backendtype = null;

                    int index = columns.IndexOf(ODB.PARAMETER_NAME);
                    if (-1 != index) parameterName = columns[index];

                    index = columns.IndexOf(ODB.PARAMETER_TYPE);
                    if (-1 != index) parameterDirection = columns[index];

                    index = columns.IndexOf(ODB.DATA_TYPE);
                    if (-1 != index) dataType = columns[index];

                    index = columns.IndexOf(ODB.CHARACTER_MAXIMUM_LENGTH);
                    if (-1 != index) maxLen = columns[index];

                    index = columns.IndexOf(ODB.NUMERIC_PRECISION);
                    if (-1 != index) numericPrecision = columns[index];

                    index = columns.IndexOf(ODB.NUMERIC_SCALE);
                    if (-1 != index) numericScale = columns[index];

                    index = columns.IndexOf(ODB.TYPE_NAME); // MDAC 72315
                    if (-1 != index) backendtype = columns[index];

                    DataRow[] dataRows = table.Select(null, ODB.ORDINAL_POSITION_ASC, DataViewRowState.CurrentRows); // MDAC 70928
                    int rowCount = dataRows.Length;
                    plist = new OleDbParameter[rowCount];
                    for(index = 0; index < rowCount; ++index) {
                        DataRow dataRow = dataRows[index];

                        OleDbParameter parameter = new OleDbParameter();

                        if ((null != parameterName) && !dataRow.IsNull(parameterName, DataRowVersion.Default)) {
                            // $CONSIDER - not trimming the @ from the beginning but to left the designer do that
                            parameter.ParameterName = Convert.ToString(dataRow[parameterName, DataRowVersion.Default]).TrimStart(new char[] { '@', ' ', ':'});
                        }
                        if ((null != parameterDirection) && !dataRow.IsNull(parameterDirection, DataRowVersion.Default)) {
                            parameter.Direction = ConvertToParameterDirection(Convert.ToInt16(dataRow[parameterDirection, DataRowVersion.Default]));
                        }
                        if ((null != dataType) && !dataRow.IsNull(dataType, DataRowVersion.Default)) {
                            // need to ping FromDBType, otherwise WChar->WChar when the user really wants VarWChar
                            parameter.OleDbType = NativeDBType.FromDBType(Convert.ToInt16(dataRow[dataType, DataRowVersion.Default]), false, false).enumOleDbType;
                        }
                        if ((null != maxLen) && !dataRow.IsNull(maxLen, DataRowVersion.Default)) {
                            parameter.Size = Convert.ToInt32(dataRow[maxLen, DataRowVersion.Default]);
                        }
                        switch(parameter.OleDbType) {
                            case OleDbType.Decimal:
                            case OleDbType.Numeric:
                            case OleDbType.VarNumeric:
                                if ((null != numericPrecision) && !dataRow.IsNull(numericPrecision, DataRowVersion.Default)) {
                                    // @devnote: unguarded cast from Int16 to Byte
                                    parameter.Precision = (Byte) Convert.ToInt16(dataRow[numericPrecision, DataRowVersion.Default]);
                                }
                                if ((null != numericScale) && !dataRow.IsNull(numericScale, DataRowVersion.Default)) {
                                    // @devnote: unguarded cast from Int16 to Byte
                                    parameter.Scale = (Byte) Convert.ToInt16(dataRow[numericScale, DataRowVersion.Default]);
                                }
                                break;

                            case OleDbType.VarBinary: // MDAC 72315
                            case OleDbType.VarChar:
                            case OleDbType.VarWChar:
                                value = dataRow[backendtype, DataRowVersion.Default];
                                if (value is string) {
                                    string backendtypename = ((string) value).ToLower(CultureInfo.InvariantCulture);
                                    switch(backendtypename) {
                                    case "binary":
                                        parameter.OleDbType = OleDbType.Binary;
                                        break;
                                    //case "varbinary":
                                    //    parameter.OleDbType = OleDbType.VarBinary;
                                    //    break;
                                    case "image":
                                        parameter.OleDbType = OleDbType.LongVarBinary;
                                        break;
                                    case "char":
                                        parameter.OleDbType = OleDbType.Char;
                                        break;
                                    //case "varchar":
                                    //case "varchar2":
                                    //    parameter.OleDbType = OleDbType.VarChar;
                                    //    break;
                                    case "text":
                                        parameter.OleDbType = OleDbType.LongVarChar;
                                        break;
                                    case "nchar":
                                        parameter.OleDbType = OleDbType.WChar;
                                        break;
                                    //case "nvarchar":
                                    //    parameter.OleDbType = OleDbType.VarWChar;
                                    case "ntext":
                                        parameter.OleDbType = OleDbType.LongVarWChar;
                                        break;
                                    }
                                }
                                break;
                        }
                        //if (AdapterSwitches.OleDbSql.TraceVerbose) {
                        //    ADP.Trace_Parameter("StoredProcedure", parameter);
                        //}
                        plist[index] = parameter;
                    }
                }
                if ((0 == plist.Length) &&(connection.SupportSchemaRowset(OleDbSchemaGuid.Procedures, out support))) {
                    restrictions = new Object[4] { null, null, command.CommandText, null};
                    table = connection.GetSchemaRowset(OleDbSchemaGuid.Procedures, restrictions);
                    if (0 == table.Rows.Count) {
                        throw ADP.NoStoredProcedureExists(command.CommandText);
                    }
                }
            }
            else if (connection.SupportSchemaRowset(OleDbSchemaGuid.Procedures, out support)) {
                Object[] restrictions = new Object[4] { null, null, command.CommandText, null};
                DataTable table = connection.GetSchemaRowset(OleDbSchemaGuid.Procedures, restrictions);
                if (0 == table.Rows.Count) {
                    throw ODB.NoStoredProcedureExists(command.CommandText);
                }
                // we don't ever expect a procedure with 0 parameters, they should have at least a return value
                throw ODB.NoProviderSupportForSProcResetParameters(connection.Provider); // MDAC 71968
            }
            else {
                throw ODB.NoProviderSupportForSProcResetParameters(connection.Provider); // MDAC 70918
            }
            return plist;
        }

        static private ParameterDirection ConvertToParameterDirection(int value) {
            switch (value) {
                case ODB.DBPARAMTYPE_INPUT:
                    return System.Data.ParameterDirection.Input;
                case ODB.DBPARAMTYPE_INPUTOUTPUT:
                    return System.Data.ParameterDirection.InputOutput;
                case ODB.DBPARAMTYPE_OUTPUT:
                    return System.Data.ParameterDirection.Output;
                case ODB.DBPARAMTYPE_RETURNVALUE:
                    return System.Data.ParameterDirection.ReturnValue;
                default:
                    return System.Data.ParameterDirection.Input;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledberror.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbError.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError"]/*' />
    [Serializable]
    sealed public class OleDbError {
        private string message;
        private int nativeError;
        private string source;
        private string sqlState;

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.OleDbError"]/*' />
        internal OleDbError(UnsafeNativeMethods.IErrorRecords errorRecords, int index) {
            // populate this structure so that we can marshal by value
            GetErrorInfo(errorRecords, index);
            GetSQLErrorInfo(errorRecords, index);
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.Message"]/*' />
        public string Message {
            get {
                return ((null != this.message) ? this.message : String.Empty);
            }
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.NativeError"]/*' />
        public int NativeError {
            get {
                return this.nativeError;
            }
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.Source"]/*' />
        public string Source {
            get {
                return ((null != this.source) ? this.source : String.Empty);
            }
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.SQLState"]/*' />
        public string SQLState {
            get {
                return ((null != this.sqlState) ? this.sqlState : String.Empty);
            }
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.GetErrorInfo"]/*' />
        private void GetErrorInfo(UnsafeNativeMethods.IErrorRecords errorRecords, int index) {
            int lcid = System.Globalization.CultureInfo.CurrentCulture.LCID;
            UnsafeNativeMethods.IErrorInfo errorInfo = null;
            int hr = errorRecords.GetErrorInfo(index, lcid, out errorInfo);
            if ((0 <= hr) && (null != errorInfo)) {
#if DEBUG
                ODB.Trace_Begin(4, "IErrorInfo", "GetDescription");
#endif
                hr = errorInfo.GetDescription(out message);
#if DEBUG
                ODB.Trace_End(4, "IErrorInfo", "GetDescription", hr, this.message);
#endif
                if (ODB.DB_E_NOLOCALE == hr) { // MDAC 87303
                    Marshal.ReleaseComObject(errorInfo);
#if DEBUG
                    ODB.Trace_Begin(4, "Kernel32", "GetUserDefaultLCID");
#endif
                    lcid = UnsafeNativeMethods.GetUserDefaultLCID();
#if DEBUG
                    ODB.Trace_End(4, "Kernel32", "GetUserDefaultLCID", lcid);
                    ODB.Trace_Begin(4, "IErrorRecords", "GetErrorInfo");
#endif
                    hr = errorRecords.GetErrorInfo(index, lcid, out errorInfo);
#if DEBUG
                    ODB.Trace_End(4, "IErrorRecords", "GetErrorInfo", hr);
#endif
                    if ((0 <= hr) && (null != errorInfo)) {
#if DEBUG
                        ODB.Trace_Begin(4, "IErrorInfo", "GetDescription", "retry");
#endif
                        hr = errorInfo.GetDescription(out this.message);
#if DEBUG
                        ODB.Trace_End(4, "IErrorInfo", "GetDescription", hr, this.message);
#endif
                   }
                }
                if ((hr < 0) && ADP.IsEmpty(this.message)) {
                    this.message = ODB.FailedGetDescription(hr);
                }
                if (null != errorInfo) {
#if DEBUG
                    ODB.Trace_Begin(4, "IErrorInfo", "GetSource");
#endif
                    hr = errorInfo.GetSource(out this.source);
#if DEBUG
                    ODB.Trace_End(4, "IErrorInfo", "GetSource", hr, this.source);
#endif
                    if (ODB.DB_E_NOLOCALE == hr) { // MDAC 87303
                        Marshal.ReleaseComObject(errorInfo);

#if DEBUG
                        ODB.Trace_Begin(4, "Kernel32", "GetUserDefaultLCID");
#endif
                        lcid = UnsafeNativeMethods.GetUserDefaultLCID();
#if DEBUG
                        ODB.Trace_End(4, "Kernel32", "GetUserDefaultLCID", lcid);
                        ODB.Trace_Begin(4, "IErrorRecords", "GetErrorInfo");
#endif
                        hr = errorRecords.GetErrorInfo(index, lcid, out errorInfo);
#if DEBUG
                        ODB.Trace_End(4, "IErrorRecords", "GetErrorInfo", hr);
#endif
                        if ((0 <= hr) && (null != errorInfo)) {
#if DEBUG
                            ODB.Trace_Begin(4, "IErrorInfo", "GetSource", "retry");
#endif
                            hr = errorInfo.GetSource(out this.source);
#if DEBUG
                            ODB.Trace_End(4, "IErrorInfo", "GetSource", hr, this.source);
#endif
                        }
                    }
                    if ((hr < 0) && ADP.IsEmpty(this.source)) {
                        this.source = ODB.FailedGetSource(hr);
                    }
                    Marshal.ReleaseComObject(errorInfo);
                }
            }
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.GetSQLErrorInfo"]/*' />
        private void GetSQLErrorInfo(UnsafeNativeMethods.IErrorRecords errorRecords, int index) {
            UnsafeNativeMethods.ISQLErrorInfo sqlErrorInfo = null;            
            int hr = errorRecords.GetCustomErrorObject(index, ODB.IID_ISQLErrorInfo, out sqlErrorInfo);
            if ((0 <= hr) && (null != sqlErrorInfo)) {

                this.sqlState = null;
                this.nativeError = 0;
#if DEBUG
                ODB.Trace_Begin(4, "ISQLErrorInfo", "GetSQLInfo");
#endif
                sqlErrorInfo.GetSQLInfo(out this.sqlState, out nativeError);
#if DEBUG
                ODB.Trace_End(4, "ISQLErrorInfo", "GetSQLInfo", 0);
#endif
            }
        }

        /// <include file='doc\OleDbError.uex' path='docs/doc[@for="OleDbError.ToString"]/*' />
        override public string ToString() {
            return Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbconnectionstring.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbConnectionString.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using Microsoft.Win32;

    sealed internal class OleDbConnectionString : DBConnectionString {

        sealed private class KEY {
            internal const string Asynchronous_Processing = "asynchronous processing";
            internal const string Connect_Timeout         = "connect timeout";
            internal const string Data_Provider           = "data provider";
            internal const string Extended_Properties     = "extended properties";
            internal const string File_Name               = "file name";
            internal const string Ole_DB_Services         = "ole db services";
            internal const string Persist_Security_Info   = "persist security info";
            internal const string Provider                = "provider";
        }

        static private Hashtable _oledbParseCache;

        private readonly PermissionSet _permission;

        private int _oledbservices; // set during Validate

        static public OleDbConnectionString ParseString(string connectionString) {
            OleDbConnectionString constr = null;
            if (!ADP.IsEmpty(connectionString)) {

                constr = (DBConnectionString.CacheQuery(connectionString, _oledbParseCache) as OleDbConnectionString);
                if (null == constr) {
#if USECRYPTO
                    string encrypted = null/*Crypto.EncryptString(connectionString)*/;
                    string hashvalue = (null == encrypted) ? Crypto.ComputeHash(connectionString) : encrypted;
                    constr = (DBConnectionString.CacheQuery(hashvalue, _oledbParseCache) as OleDbConnectionString);
                    if (null == constr) {
                        constr = new OleDbConnectionString(connectionString, encrypted);
#else
                        constr = new OleDbConnectionString(connectionString);
#endif
                        if (constr.ShouldCache()) {
#if USECRYPTO
                            if (!constr.IsEncrypted) {
                                hashvalue = connectionString;
                            }
                            CacheAdd(hashvalue, constr, ref _oledbParseCache);
#else
                            CacheAdd(connectionString, constr, ref _oledbParseCache);
#endif
                        }
#if USECRYPTO
                    }
#endif
                }
            }
            return constr;
        }

#if USECRYPTO
        private OleDbConnectionString(string connectionString, string encrypted) : base(connectionString, encrypted, UdlSupport.LoadFromFile) {
#else
        private OleDbConnectionString(string connectionString) : base(connectionString, UdlSupport.LoadFromFile) {
#endif
            _permission = OleDbConnectionString.CreatePermission(this);
        }

        static internal PermissionSet CreatePermission(OleDbConnectionString constr) {
            OleDbPermission p = new OleDbPermission(constr);
            if (null == constr) {
                p.Add(ADP.StrEmpty, ADP.StrEmpty, KeyRestrictionBehavior.AllowOnly); // ExecuteOnly permission
            }
            PermissionSet permission;
            NamedPermissionSet fulltrust = new NamedPermissionSet("FullTrust"); // MDAC 83159
            fulltrust.Assert();
            try {
                permission = new PermissionSet(fulltrust);
                permission.AddPermission(p);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return permission;
        }

        static internal void Demand(OleDbConnectionString constr) {
            PermissionSet permission = ((null != constr) ? constr._permission : OleDbConnection.OleDbPermission);
            permission.Demand();
        }

#if MDAC80721
        protected override bool EmbeddedExtendedProperties {
            get { return true; }
        }
#endif
        internal int OLEDBSerivces {
            get { return _oledbservices; }
        }

        override protected bool IsSensitiveOption(string keyname) {
            return (base.IsSensitiveOption(keyname) || (KEY.Extended_Properties == keyname));
        }

        override protected string ValidateParse() {
            int connectTimeout = base.CheckConvertToInt32(KEY.Connect_Timeout, 0);
            if (connectTimeout < 0) {
                throw ADP.InvalidConnectTimeoutValue();
            }

            if (!CheckConvertToBoolean(KEY.Persist_Security_Info, false)) {
                // because we allow the user direct access to the ole db properties and
                // we've changed the default of 'persisit security info' from true to false
                // we need to force the provider to hide the password
                //if (!base.Contains(KEY.Ole_DB_Services) || (null == (value = base[KEY.Ole_DB_Services]))) {
                //    hiddenConnectionString += ";persist security info=false;";
                //}
            }

            if (CheckConvertToBoolean(KEY.Asynchronous_Processing, false)) {
                throw ODB.AsynchronousNotSupported();
            }

            bool hasOleDBServices = (base.Contains(KEY.Ole_DB_Services) && !ADP.IsEmpty((string)base[KEY.Ole_DB_Services]));

            string progid = CheckConvertToString(KEY.Data_Provider, null); // MDAC 71923
            if (null != progid) {
                ValidateNotMSDASQL(progid);
            }
            
            progid = CheckConvertToString(KEY.Provider, null);
            if (null != progid) {
                progid = progid.Trim();
            }
            if (ADP.IsEmpty(progid)) {
                throw ODB.NoProviderSpecified();
            }
            if (ODB.MaxProgIdLength <= progid.Length) { // MDAC 63151
                throw ODB.InvalidProviderSpecified();
            }
            ValidateNotMSDASQL(progid);

            if (!hasOleDBServices) { // don't touch registry if they have OLE DB Services
                string classid = (string) ADP.ClassesRootRegistryValue(progid + "\\CLSID", String.Empty);
                if ((null != classid) && (0 < classid.Length)) {
                    // CLSID detection of 'Microsoft OLE DB Provider for ODBC Drivers'
                    if (ODB.CLSID_MSDASQL == new Guid(classid)) {
                        throw ODB.MSDASQLNotSupported();
                    }
                    object tmp = ADP.ClassesRootRegistryValue("CLSID\\" + classid, ODB.OLEDB_SERVICES);
                    if (null != tmp) {
                        Int32 oledbservices = 0;

                        // @devnote: some providers like MSDataShape don't have the OLEDB_SERVICES value
                        // the MSDataShape provider doesn't support the 'Ole Db Services' keyword
                        // hence, if the value doesn't exist - don't prepend to string
                        try {
                            oledbservices  = Convert.ToInt32(tmp);
                        }
                        catch(Exception e) {
                            ADP.TraceException(e);
                        }
                        oledbservices &= ~(ODB.DBPROPVAL_OS_AGR_AFTERSESSION | ODB.DBPROPVAL_OS_CLIENTCURSOR); // NT 347436, MDAC 58606
                        _oledbservices = oledbservices;

                        // prepend 'OLE DB SERVICES=-13' (or with registry bits included)
#if USECRYPTO
                        byte[] newconstr;
                        string prepend = ODB.Ole_DB_Services + "=" + oledbservices.ToString(System.Globalization.CultureInfo.InvariantCulture) + ";";
                        byte[] plainText = Crypto.DecryptString(EncryptedActualConnectionString);
                        GCHandle handle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
                        try {
                            newconstr = new byte[ADP.CharSize*prepend.Length + plainText.Length];
                            GCHandle newhandle = GCHandle.Alloc(newconstr, GCHandleType.Pinned);
                            try {
                                System.Text.Encoding.Unicode.GetBytes(prepend, 0, prepend.Length, newconstr, 0);
                                plainText.CopyTo(newconstr, ADP.CharSize*prepend.Length);
                                newconstr = Crypto.EncryptOrDecryptData(true, newconstr, 0, newconstr.Length);
                            }
                            catch {
                                Array.Clear(newconstr, 0, newconstr.Length);
                                if (newhandle.IsAllocated) {
                                    newhandle.Free();
                                }
                                throw;
                            }
                            if (newhandle.IsAllocated) {
                                newhandle.Free();
                            }
                        }
                        finally {
                            Array.Clear(plainText, 0, plainText.Length);
                            if (handle.IsAllocated) {
                                handle.Free();
                            }
                        }
                        return System.Text.Encoding.Unicode.GetString(newconstr, 0, newconstr.Length);
#else
                        StringBuilder builder = new StringBuilder();
                        builder.Append(ODB.Ole_DB_Services);
                        builder.Append("=");
                        builder.Append(oledbservices.ToString(System.Globalization.CultureInfo.InvariantCulture));
                        builder.Append(";");
                        builder.Append(EncryptedActualConnectionString);
                        return builder.ToString();
#endif
                    }
                }
            }
            else {
                _oledbservices = CheckConvertToInt32(KEY.Ole_DB_Services, 0);
            }
            return EncryptedActualConnectionString;
        }

        static private void ValidateNotMSDASQL(string progid) {
            progid = progid.ToLower(CultureInfo.InvariantCulture); //MDAC 65389
            if ((ODB.MSDASQL == progid) || progid.StartsWith(ODB.MSDASQLdot) || (ODB.DefaultDescription_MSDASQL == progid)) {
                throw ODB.MSDASQLNotSupported();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbdataadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbDataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Data.Common;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;

namespace System.Data.OleDb {

    /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter"]/*' />
    [
    DefaultEvent("RowUpdated"),
    ToolboxItem("Microsoft.VSDesigner.Data.VS.OleDbDataAdapterToolboxItem, " + AssemblyRef.MicrosoftVSDesigner),
    Designer("Microsoft.VSDesigner.Data.VS.OleDbDataAdapterDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbDataAdapter : DbDataAdapter, IDbDataAdapter, ICloneable {

        private OleDbCommand cmdSelect;
        private OleDbCommand cmdInsert;
        private OleDbCommand cmdUpdate;
        private OleDbCommand cmdDelete;
        private OleDbCommand internalCmdSelect; // MDAC 82556

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.OleDbDataAdapter"]/*' />
        public OleDbDataAdapter() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.OleDbDataAdapter1"]/*' />
        public OleDbDataAdapter(OleDbCommand selectCommand) : base() {
            GC.SuppressFinalize(this);
            SelectCommand = selectCommand;
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.OleDbDataAdapter2"]/*' />
        //[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public OleDbDataAdapter(string selectCommandText, string selectConnectionString) : base() {
            GC.SuppressFinalize(this);
            internalCmdSelect = SelectCommand = new OleDbCommand(selectCommandText, new OleDbConnection(selectConnectionString));
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.OleDbDataAdapter3"]/*' />
        public OleDbDataAdapter(string selectCommandText, OleDbConnection selectConnection) : base() {
            GC.SuppressFinalize(this);
            internalCmdSelect = SelectCommand = new OleDbCommand(selectCommandText, selectConnection);
        }

        private OleDbDataAdapter(OleDbDataAdapter adapter) : base(adapter) {  // MDAC 81448
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.DeleteCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_DeleteCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OleDbCommand DeleteCommand {
            get {
                return this.cmdDelete;
            }
            set {
                this.cmdDelete = value;
            }
        }
        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.IDbDataAdapter.DeleteCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.DeleteCommand {
            get {
                return this.cmdDelete;
            }
            set {
                DeleteCommand = (OleDbCommand)value;
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.InsertCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_InsertCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OleDbCommand InsertCommand {
            get {
                return this.cmdInsert;
            }
            set {
                this.cmdInsert = value;
            }
        }
        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.IDbDataAdapter.InsertCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.InsertCommand {
            get {
                return this.cmdInsert;
            }
            set {
                InsertCommand = (OleDbCommand)value;
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.SelectCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Fill),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_SelectCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OleDbCommand SelectCommand {
            get {
                return this.cmdSelect;
            }
            set {
                if (this.cmdSelect != value) {
                    this.cmdSelect = value;
                    ADP.SafeDispose(internalCmdSelect);
                    internalCmdSelect = null;
                }            
            }
        }
        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.IDbDataAdapter.SelectCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.SelectCommand {
            get {
                return this.cmdSelect;
            }
            set {
                SelectCommand = (OleDbCommand)value;
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.UpdateCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_UpdateCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public OleDbCommand UpdateCommand {
            get {
                return this.cmdUpdate;
            }
            set {
                this.cmdUpdate = value;
            }
        }
        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.IDbDataAdapter.UpdateCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.UpdateCommand {
            get {
                return this.cmdUpdate;
            }
            set {
                UpdateCommand = (OleDbCommand)value;
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.RowUpdated"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DataSysDescription(Res.DbDataAdapter_RowUpdated)
        ]
        public event OleDbRowUpdatedEventHandler RowUpdated {
            add {
                Events.AddHandler(ADP.EventRowUpdated, value);
            }
            remove {
                Events.RemoveHandler(ADP.EventRowUpdated, value);
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.RowUpdating"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DataSysDescription(Res.DbDataAdapter_RowUpdating)
        ]
        public event OleDbRowUpdatingEventHandler RowUpdating {
            add {
                OleDbRowUpdatingEventHandler handler = (OleDbRowUpdatingEventHandler) Events[ADP.EventRowUpdating];

                // MDAC 58177, 64513
                // prevent someone from registering two different command builders on the adapter by
                // silently removing the old one
                if ((null != handler) && (value.Target is CommandBuilder)) {
                    OleDbRowUpdatingEventHandler d = (OleDbRowUpdatingEventHandler) CommandBuilder.FindBuilder(handler);
                    if (null != d) {
                        Events.RemoveHandler(ADP.EventRowUpdating, d);
                    }
            	}
                Events.AddHandler(ADP.EventRowUpdating, value);
            }
            remove {
                Events.RemoveHandler(ADP.EventRowUpdating, value);
            }
        }

        object ICloneable.Clone() { // MDAC 81448
            return new OleDbDataAdapter(this);
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.CreateRowUpdatedEvent"]/*' />
        /// <internalonly/>
        override protected RowUpdatedEventArgs CreateRowUpdatedEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            return new OleDbRowUpdatedEventArgs(dataRow, command, statementType, tableMapping);
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.CreateRowUpdatingEvent"]/*' />
        /// <internalonly/>
        override protected RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            return new OleDbRowUpdatingEventArgs(dataRow, command, statementType, tableMapping);
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 82556
            if (disposing) {
                if (this.internalCmdSelect != null) {
                    internalCmdSelect.Dispose();
                    internalCmdSelect = null;
                }
            }
            base.Dispose(disposing); // notify base classes 
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.Fill"]/*' />
        public int Fill(DataTable dataTable, object ADODBRecordSet) {
            OleDbConnection.OleDbPermission.Demand(); // MDAC 77737
            //(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();

            if (null == dataTable) {
                throw ADP.FillRequires("dataTable");
            }
            if (null == ADODBRecordSet) {
                throw ADP.FillRequires("adodb");
            }
            return FillFromADODB((object)dataTable, ADODBRecordSet, null, false); // MDAC 59249
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.Fill1"]/*' />
        public int Fill(DataSet dataSet, object ADODBRecordSet, string srcTable) {
            OleDbConnection.OleDbPermission.Demand(); // MDAC 77737
            //(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();

            if (null == dataSet) {
                throw ADP.FillRequires("dataSet");
            }
            if (null == ADODBRecordSet) {
                throw ADP.FillRequires("adodb");
            }
            if (ADP.IsEmpty(srcTable)) {
                throw ADP.FillRequiresSourceTableName("srcTable");
            }
            return FillFromADODB((object)dataSet, ADODBRecordSet, srcTable, true);
        }

        private int FillFromADODB(Object data, object adodb, string srcTable, bool multipleResults) {

            Debug.Assert(null != data, "FillFromADODB: null data object");
            Debug.Assert(null != adodb, "FillFromADODB: null ADODB");
            Debug.Assert(!(adodb is DataTable), "call Fill( (DataTable) value)");
            Debug.Assert(!(adodb is DataSet), "call Fill( (DataSet) value)");

            /*
            IntPtr adodbptr = ADP.PtrZero;
            try { // generate a new COM Callable Wrapper around the user object so they can't ReleaseComObject on us.
                adodbptr = Marshal.GetIUnknownForObject(adodb);
                adodb = System.Runtime.Remoting.Services.EnterpriseServicesHelper.WrapIUnknownWithComObject(adodbptr);
            }
            finally {
                if (ADP.PtrZero != adodbptr) {
                    Marshal.Release(adodbptr);
                }
            }
            */

            bool closeRecordset = multipleResults; // MDAC 60332, 66668
            Type recordsetType = null;
            UnsafeNativeMethods.ADORecordConstruction record = null;
            UnsafeNativeMethods.ADORecordsetConstruction recordset = null;
            try {
#if DEBUG
                ODB.Trace_Cast("Object", "ADORecordsetConstruction", "get_Rowset");
#endif
                recordset = (UnsafeNativeMethods.ADORecordsetConstruction) adodb;
                recordsetType = adodb.GetType();

                if (multipleResults) {
                    // The NextRecordset method is not available on a disconnected Recordset object, where ActiveConnection has been set to NULL
                    object activeConnection = recordsetType.InvokeMember("ActiveConnection", BindingFlags.GetProperty, null, adodb, new object[0]);
                    if (null == activeConnection) {
                        multipleResults = false;
                    }
                }
            }
            catch(InvalidCastException e) {
                ADP.TraceException(e);

                try {
#if DEBUG
                    ODB.Trace_Cast("Object", "ADORecordConstruction", "get_Row");
#endif
                    record = (UnsafeNativeMethods.ADORecordConstruction) adodb;
                    multipleResults = false; // IRow implies CommandBehavior.SingleRow which implies CommandBehavior.SingleResult
                }
                catch(InvalidCastException f) {
                    // $Consider: telling use either type of object passed in
                    throw ODB.Fill_NotADODB("adodb", f);
                }
            }
            int results = 0;
            if (null != recordset) {
                int resultCount = 0;
                bool incrementResultCount; // MDAC 59632
                object[] value = new object[1];

                do {
                    string tmp = null;
                    if (data is DataSet) {
                        tmp = DbDataAdapter.GetSourceTableName(srcTable, resultCount);
                    }
                    results += FillFromRecordset(data, recordset, tmp, out incrementResultCount);

                    if (multipleResults) {
                        value[0] = DBNull.Value;
                        try {
                            adodb = recordsetType.InvokeMember("NextRecordset", BindingFlags.InvokeMethod, null, adodb, value);
                            if (null != adodb) {
                                try {
#if DEBUG
                                    ODB.Trace_Cast("ADODB", "ADORecordsetConstruction", "get_Rowset");
#endif
                                    recordset = (UnsafeNativeMethods.ADORecordsetConstruction) adodb;
                                }
                                catch(Exception e) {
                                    ADP.TraceException(e);
                                    break;
                                }
                                recordsetType = adodb.GetType(); // MDAC 59253
                                if (incrementResultCount) {
                                    resultCount++;
                                }
                                continue;
                            }
                        }
                        catch(TargetInvocationException e) { // MDAC 59244, 65506
                            if (e.InnerException is COMException) {
                                FillNextResultError((COMException) e.InnerException, e);
                                closeRecordset = true; // MDAC 60408
                            }
                            else {
                                throw;
                            }
                        }
                        catch(COMException e) { // used as backup to the TargetInvocationException
                            FillNextResultError(e, e);
                            closeRecordset = true; // MDAC 60408
                        }
                    }
                    break;
                } while(null != recordset);

                if ((null != recordset) && (closeRecordset || (null == adodb))) { // MDAC 59746, 60902
                    FillClose(recordsetType, recordset);
                }
            }
            else if (null != record) {
                results = FillFromRecord(data, record, srcTable);
                if (closeRecordset) { // MDAC 66668
                    FillClose(adodb.GetType(), record); // MDAC 60848
                }
            }
            else {
                throw ODB.Fill_NotADODB("adodb", null);
            }
            return results;
        }

        private void FillNextResultError(COMException e, Exception f) {
#if DEBUG
            if (AdapterSwitches.DataError.TraceError) {
                Debug.WriteLine(e.ToString() + " " + ODB.ELookup(e.ErrorCode));
            }
#endif
            // i.e. ADODB.Recordset opened with adCmdTableDirect
            // Current provider does not support returning multiple recordsets from a single execution.
            if (ODB.ADODB_NextResultError != e.ErrorCode) {
                throw f;
            }
        }

        //override protected int Fill(DataTable dataTable, IDataReader dataReader) { // MDAC 65506
        //    return base.Fill(dataTable, dataReader);
        //}

        private int FillFromRecordset(Object data, UnsafeNativeMethods.ADORecordsetConstruction recordset, string srcTable, out bool incrementResultCount) {
            incrementResultCount = false;

            IntPtr chapter; /*ODB.DB_NULL_HCHAPTER*/
            object result = null;
            try {
                int hr;
#if DEBUG
                ODB.Trace_Begin("ADORecordsetConstruction", "get_Rowset");
#endif
                hr = recordset.get_Rowset(out result);
#if DEBUG
                ODB.Trace_End("ADORecordsetConstruction", "get_Rowset", hr);
                ODB.Trace_Begin("ADORecordsetConstruction", "get_Chapter");
#endif
                hr = recordset.get_Chapter(out chapter);
#if DEBUG
                ODB.Trace_End("ADORecordsetConstruction", "get_Chapter", hr);
#endif
            }
            catch(Exception e) {
                ADP.TraceException(e);
                throw ODB.Fill_EmptyRecordSet("adodbRecordSet", e);
            }

            if (null != result) {
                CommandBehavior behavior = (MissingSchemaAction.AddWithKey != MissingSchemaAction) ? 0 : CommandBehavior.KeyInfo;
                behavior |= CommandBehavior.SequentialAccess;

                try {
                    using(OleDbDataReader dataReader = new OleDbDataReader(null, null, 0, chapter)) {
                        dataReader.InitializeIRowset(result, -1, behavior);
                        dataReader.BuildMetaInfo();

                        incrementResultCount = (0 < dataReader.FieldCount); // MDAC 59632
                        if (incrementResultCount) {
                            if (data is DataTable) {
                                return base.Fill((DataTable) data, dataReader); // MDAC 65506
                            }
                            else {
                                return base.Fill((DataSet) data, srcTable, dataReader, 0, 0);
                            }
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
            return 0;
        }

        private int FillFromRecord(Object data, UnsafeNativeMethods.ADORecordConstruction record, string srcTable) {
            object result = null;
            try {
                int hr;
#if DEBUG
                ODB.Trace_Begin("ADORecordConstruction", "get_Row");
#endif
                hr = record.get_Row(out result);
#if DEBUG
                ODB.Trace_End("ADORecordConstruction", "get_Row", hr);
#endif
            }
            catch(Exception e) {
                ADP.TraceException(e);
                throw ODB.Fill_EmptyRecord("adodb", e);
            }

            if (null != result) {
                CommandBehavior behavior = (MissingSchemaAction.AddWithKey != MissingSchemaAction) ? 0 : CommandBehavior.KeyInfo;

                try {
                    using(OleDbDataReader dataReader = new OleDbDataReader(null, null, 0, IntPtr.Zero)) {
                        dataReader.InitializeIRow(result, -1, behavior | CommandBehavior.SingleRow);
                        dataReader.BuildMetaInfo();

                        if (data is DataTable) {
                            return base.Fill((DataTable) data, dataReader); // MDAC 65506
                        }
                        else {
                            return base.Fill((DataSet) data, srcTable, dataReader, 0, 0);
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
            return 0;
        }

        private void FillClose(Type type, object value) {
            try {
                type.InvokeMember("Close", BindingFlags.InvokeMethod, null, value, new object[0]);
            }
            catch(TargetInvocationException e) { // CLR 2812 changed from throwing COMException to TargetInvocationException
                if (e.InnerException is COMException) {
                    FillCloseError((COMException) e.InnerException, e);
                }
                else {
                    throw;
                }
            }
            catch(COMException e) { // used as backup to the TargetInvocationException
                FillCloseError(e, e);
            }
        }

        private void FillCloseError(COMException e, Exception f) {
#if DEBUG
            if (AdapterSwitches.DataError.TraceError) {
                Debug.WriteLine(e.ToString() + " " + ODB.ELookup(e.ErrorCode));
            }
#endif
            if (ODB.ADODB_AlreadyClosedError != e.ErrorCode) {
                throw f;
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.OnRowUpdated1"]/*' />
        override protected void OnRowUpdated(RowUpdatedEventArgs value) {
            OleDbRowUpdatedEventHandler handler = (OleDbRowUpdatedEventHandler) Events[ADP.EventRowUpdated];
            if ((null != handler) && (value is OleDbRowUpdatedEventArgs)) {
                handler(this, (OleDbRowUpdatedEventArgs) value);
            }
        }

        /// <include file='doc\OleDbDataAdapter.uex' path='docs/doc[@for="OleDbDataAdapter.OnRowUpdating1"]/*' />
        override protected void OnRowUpdating(RowUpdatingEventArgs value) {
            OleDbRowUpdatingEventHandler handler = (OleDbRowUpdatingEventHandler) Events[ADP.EventRowUpdating];
            if ((null != handler) && (value is OleDbRowUpdatingEventArgs)) {
                handler(this, (OleDbRowUpdatingEventArgs) value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledberrorcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbErrorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Collections;
    using System.Data.Common;
    using System.Text;

    /// <include file='doc\OleDbErrorCollection.uex' path='docs/doc[@for="OleDbErrorCollection"]/*' />
    [Serializable, ListBindable(false)]
    sealed public class OleDbErrorCollection : System.Collections.ICollection {
        private ArrayList items = new  ArrayList();

        /// <include file='doc\OleDbErrorCollection.uex' path='docs/doc[@for="OleDbErrorCollection.OleDbErrorCollection"]/*' />
        internal OleDbErrorCollection(UnsafeNativeMethods.IErrorRecords errorRecords) {
            if (null != errorRecords) {

                int recordCount;
#if DEBUG
                ODB.Trace_Begin(4, "IErrorRecords", "GetRecordCount");
#endif
                int hr = errorRecords.GetRecordCount(out recordCount);
#if DEBUG
                ODB.Trace_End(4, "IErrorRecords", "GetRecordCount", hr, "Count="+recordCount);
#endif
                if ((0 <= hr) && (0 < recordCount)) {
                    for (int i = 0; i < recordCount; ++i) {
                        items.Add(new OleDbError(errorRecords, i));
                    }
                }
            }
        }

        // explicit ICollection implementation
        bool System.Collections.ICollection.IsSynchronized {
            get { return false;}
        }

        object System.Collections.ICollection.SyncRoot {
            get { return this;}
        }

        /// <include file='doc\OleDbErrorCollection.uex' path='docs/doc[@for="OleDbErrorCollection.Count"]/*' />
        public int Count {
            get {
                return ((null != items) ? items.Count : 0);
            }
        }

        /// <include file='doc\OleDbErrorCollection.uex' path='docs/doc[@for="OleDbErrorCollection.this"]/*' />
        public OleDbError this[int index] {
            get {
                return(OleDbError) items[index];
            }
        }

        /// <include file='doc\OleDbErrorCollection.uex' path='docs/doc[@for="OleDbErrorCollection.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            items.CopyTo(array, index);
        }

        /// <include file='doc\OleDbErrorCollection.uex' path='docs/doc[@for="OleDbErrorCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return items.GetEnumerator();
        }

        static internal String BuildFullMessage(OleDbErrorCollection errors, string errMsg) { // MDAC 65533
            if ((null != errors) && (0 < errors.Count)) {
                StringBuilder str = new StringBuilder();

                int count = errors.Count;
                if ((null != errMsg) && (0 != ADP.DstCompare(errMsg, errors[0].Message))) {
                    str.Append(errMsg.TrimEnd(ODB.ErrorTrimCharacters)); // MDAC 73707
                    if (1 < count) {
                        str.Append("\r\n");
                    }
                }
                for (int i = 0; i < count; ++i) {
                    if (0 < i) {
                        str.Append("\r\n");
                    }
                    str.Append(errors[i].Message.TrimEnd(ODB.ErrorTrimCharacters)); // MDAC 73707
                }
                return str.ToString();
            }
            return "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbinfomessageeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbInfoMessageEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    /// <include file='doc\ADOInfoMessageEventHandler.uex' path='docs/doc[@for="OleDbInfoMessageEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.OleDb.OleDbConnection.InfoMessage'/> event of an <see cref='System.Data.OleDb.OleDbConnection'/>.
    ///    </para>
    /// </devdoc>
    public delegate void OleDbInfoMessageEventHandler(object sender, OleDbInfoMessageEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbinfomessageevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbInfoMessageEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.Data.Common;

    /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs"]/*' />
    sealed public class OleDbInfoMessageEventArgs : System.EventArgs {
        private object src;
        private UnsafeNativeMethods.IErrorInfo errorInfo;
        private OleDbErrorCollection oledbErrors;

        private string message;
        private string source;
        private int errorCode;

        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs.OleDbInfoMessageEventArgs"]/*' />
        internal OleDbInfoMessageEventArgs(UnsafeNativeMethods.IErrorInfo errorInfo, int errorCode, object src) {
            this.errorInfo = errorInfo;
            this.errorCode = errorCode;
            this.src = src;
        }

        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs.ErrorCode"]/*' />
        public int ErrorCode {
            get {
                return this.errorCode;
            }
        }

        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs.Errors"]/*' />
        public OleDbErrorCollection Errors {
            get {
                if (null == this.oledbErrors) {
                    this.oledbErrors = new OleDbErrorCollection((UnsafeNativeMethods.IErrorRecords) this.errorInfo);
                }
                return this.oledbErrors;
            }
        }

        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEvent.ShouldSerializeErrors"]/*' />
        /*virtual protected*/private bool ShouldSerializeErrors() { // MDAC 65548
            return (null != this.oledbErrors) && (0 < Errors.Count);
        }


        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs.Message"]/*' />
        public string Message {
            get {
                if (null == this.message) {
                    if (null != errorInfo) {
                        errorInfo.GetDescription(out this.message);

                        this.message = OleDbErrorCollection.BuildFullMessage(Errors, this.message);
                        if (null == this.message) {
                            this.message = "";
                        }
                    }
                }
                return this.message;
            }
        }

        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs.Source"]/*' />
        public string Source {
            get {
                if (null == this.source) {
                    if (null != this.errorInfo) {
                        this.errorInfo.GetSource(out this.source);
                    }
                    if (null == this.source) {
                        this.source = "";
                    }
                }
                return this.source;
            }
        }

        /// <include file='doc\OleDbInfoMessageEvent.uex' path='docs/doc[@for="OleDbInfoMessageEventArgs.ToString"]/*' />
        override public string ToString() {
            return Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Data.Common;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;

    /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException"]/*' />
    [Serializable]
    sealed public class OleDbException : ExternalException {
        private OleDbErrorCollection oledbErrors;
        private string message;
        private string source;

        internal OleDbException(UnsafeNativeMethods.IErrorInfo errorInfo, int errorCode, Exception inner) : base("", inner) {
            // copy error information into this structure so that it can be serialized by value
            this.oledbErrors = new OleDbErrorCollection((UnsafeNativeMethods.IErrorRecords) errorInfo);

            if (null != errorInfo) {
                // message
#if DEBUG
                ODB.Trace_Begin(4, "IErrorInfo", "GetDescription");
#endif
                errorInfo.GetDescription(out this.message);
#if DEBUG
                ODB.Trace_End(4, "IErrorInfo", "GetDescription", 0, this.message);
#endif
                this.message = OleDbErrorCollection.BuildFullMessage(Errors, this.message);
                if (ADP.IsEmpty(this.message)) {
                    this.message = ODB.NoErrorMessage(errorCode); // MDAC 71170
                }
                
                // source
#if DEBUG
                ODB.Trace_Begin(4, "IErrorInfo", "GetSource");
#endif
                errorInfo.GetSource(out this.source);
#if DEBUG
                ODB.Trace_End(4, "IErrorInfo", "GetSource", 0, this.source);
#endif
                if (null == this.source) {
                    this.source = "";
                }
            }
            HResult = errorCode;
        }

        internal OleDbException(string message, int errorCode, Exception inner) : base(message, inner) {
            this.oledbErrors = new OleDbErrorCollection(null);
            this.message = message;
            HResult = errorCode;
        }

        // runtime will call even if private...
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        private OleDbException(SerializationInfo si, StreamingContext sc) : base(si, sc) {
            oledbErrors = (OleDbErrorCollection) si.GetValue("oledbErrors", typeof(OleDbErrorCollection));
            message     = (string) si.GetValue("message", typeof(string));
            source      = (string) si.GetValue("source", typeof(string));
        }

        /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        override public void GetObjectData(SerializationInfo si, StreamingContext context) { // MDAC 72003
            if (null == si) {
                throw new ArgumentNullException("si");
            }
            si.AddValue("oledbErrors", oledbErrors, typeof(OleDbErrorCollection));
            si.AddValue("message", message, typeof(string));
            si.AddValue("source", source, typeof(string));
            base.GetObjectData(si, context);
        }

        /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException.ErrorCode"]/*' />
        [
        TypeConverterAttribute(typeof(ErrorCodeConverter))
        ]
        override public int ErrorCode {
            get {
                return base.ErrorCode;
            }
        }

        /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException.Errors"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content)
        ]
        public OleDbErrorCollection Errors {
            get {
                return this.oledbErrors;
            }
        }
        
        /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException.ShouldSerializeErrors"]/*' />
        /*virtual protected*/private bool ShouldSerializeErrors() { // MDAC 65548
            return ((null != this.oledbErrors) && (0 < Errors.Count));
        }

        /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException.Message"]/*' />
        override public string Message {
            get {
                return this.message;
            }
        }

        /// <include file='doc\OleDbException.uex' path='docs/doc[@for="OleDbException.Source"]/*' />
        override public string Source {
            get {
                return this.source;
            }
        }

        /// <internalonly/>
        internal class ErrorCodeConverter : Int32Converter { // MDAC 68557

            /// <internalonly/>
            override public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                if (destinationType == null) {
                    throw ADP.ArgumentNull("destinationType");
                }
                if ((destinationType == typeof(string)) && (value != null) && (value is Int32)) {
                    return ODB.ELookup((int) value);
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbliteral.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbLiteral.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;

    /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral"]/*' />
    public enum OleDbLiteral : int { // MDAC 61846
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Invalid"]/*' />
        Invalid = 0,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Binary_Literal"]/*' />
        Binary_Literal = 1,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Catalog_Name"]/*' />
        Catalog_Name = 2,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Catalog_Separator"]/*' />
        Catalog_Separator = 3,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Char_Literal"]/*' />
        Char_Literal = 4,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Column_Alias"]/*' />
        Column_Alias = 5,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Column_Name"]/*' />
        Column_Name = 6,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Correlation_Name"]/*' />
        Correlation_Name = 7,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Cursor_Name"]/*' />
        Cursor_Name = 8,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Escape_Percent_Prefix"]/*' />
        Escape_Percent_Prefix = 9,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Escape_Underscore_Prefix"]/*' />
        Escape_Underscore_Prefix = 10,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Index_Name"]/*' />
        Index_Name = 11,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Like_Percent"]/*' />
        Like_Percent = 12,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Like_Underscore"]/*' />
        Like_Underscore = 13,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Procedure_Name"]/*' />
        Procedure_Name = 14,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Quote_Prefix"]/*' />
        Quote_Prefix = 15,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Schema_Name"]/*' />
        Schema_Name = 16,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Table_Name"]/*' />
        Table_Name = 17,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Text_Command"]/*' />
        Text_Command = 18,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.User_Name"]/*' />
        User_Name = 19,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.View_Name"]/*' />
        View_Name = 20,

        // MDAC 2.0
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Cube_Name"]/*' />
        Cube_Name = 21,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Dimension_Name"]/*' />
        Dimension_Name = 22,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Hierarchy_Name"]/*' />
        Hierarchy_Name = 23,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Level_Name"]/*' />
        Level_Name = 24,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Member_Name"]/*' />
        Member_Name = 25,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Property_Name"]/*' />
        Property_Name = 26,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Schema_Separator"]/*' />
        Schema_Separator = 27,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Quote_Suffix"]/*' />
        Quote_Suffix = 28,

        // MDAC 2.1
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Escape_Percent_Suffix"]/*' />
        Escape_Percent_Suffix = 29,
        /// <include file='doc\OleDbLiteral.uex' path='docs/doc[@for="OleDbLiteral.Escape_Underscore_Suffix"]/*' />
        Escape_Underscore_Suffix = 30,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbparametercollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbParameterCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;

    /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection"]/*' />
    [
    Editor("Microsoft.VSDesigner.Data.Design.DBParametersEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
    ListBindable(false)
    ]
    sealed public class OleDbParameterCollection : MarshalByRefObject, IDataParameterCollection {
        private OleDbCommand parent;
        private ArrayList items; // delay creation until AddWithoutEvents, Insert, CopyTo, GetEnumerator

        internal OleDbParameterCollection(OleDbCommand parent) { // called by OleDbCommand.get_Parameters
            this.parent = parent;
        }

        // explicit ICollection implementation
        bool System.Collections.ICollection.IsSynchronized {
            get { return false;}
        }
        object System.Collections.ICollection.SyncRoot {
            get { return this;}
        }

        // explicit IList implementation
        bool System.Collections.IList.IsReadOnly {
            get { return false;}
        }
        bool System.Collections.IList.IsFixedSize {
            get { return false;}
        }
        object System.Collections.IList.this[int index] {
            get {
                return this[index];
            }
            set { 
                ValidateType(value);
                this[index] = (OleDbParameter) value;
            }
        }

        // explicit IDataParameterCollection implementation
        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.IDataParameterCollection.this"]/*' />
        /// <internalonly/>
        object IDataParameterCollection.this[string index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (OleDbParameter) value;
            }
        }


        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Count"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Count {
            get {
                return ((null != items) ? items.Count : 0);
            }
        }

        private Type ItemType {
            get { return typeof(OleDbParameter); }
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.this"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public OleDbParameter this[int index] {
            get {
                RangeCheck(index);
                return(OleDbParameter) items[index];
            }
            set {
                OnSchemaChanging();  // fire event before value is validated
                RangeCheck(index);
                Replace(index, value);
            }
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.this1"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public OleDbParameter this[string parameterName] {
            get {
                int index = RangeCheck(parameterName);
                return(OleDbParameter) items[index];
            }
            set {
                OnSchemaChanging();  // fire event before value is validated
                int index = RangeCheck(parameterName);
                Replace(index, value);
            }
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Add"]/*' />
        public int Add(object value) {
            ValidateType(value);
            Add((OleDbParameter) value);
            return Count-1;
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Add1"]/*' />
        public OleDbParameter Add(OleDbParameter value) { // MDAC 59206
            OnSchemaChanging();  // fire event before value is validated
            AddWithoutEvents(value);
            //OnSchemaChanged();
            return value;
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Add5"]/*' />
        public OleDbParameter Add(string parameterName, object value) { // MDAC 59206
            return Add(new OleDbParameter(parameterName, value));
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Add2"]/*' />
        public OleDbParameter Add(string parameterName, OleDbType oleDbType) {
            return Add(new OleDbParameter(parameterName, oleDbType));
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Add3"]/*' />
        public OleDbParameter Add(string parameterName, OleDbType oleDbType, int size) {
            return Add(new OleDbParameter(parameterName, oleDbType, size));
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Add4"]/*' />
        public OleDbParameter Add(string parameterName, OleDbType oleDbType, int size, string sourceColumn) {
            return Add(new OleDbParameter(parameterName, oleDbType, size, sourceColumn));
        }

        /*public void AddRange(OleDbParameter[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            int length = values.Length;
            for (int i = 0; i < length; ++i) {
                ValidateType(values[i]);
            }
            for (int i = 0; i < length; ++i) {
                AddWithoutEvents(values[i]);
            }
        }*/

        internal void AddWithoutEvents(OleDbParameter value) { // also called by OleDbCommand.DeriveParameters
            Validate(-1, value);
            value.Parent = this;
            ArrayList().Add(value);
        }

        // implemented as a method, not as a property because the VS7 debugger 
        // object browser calls properties to display their value, and we want this delayed
        private ArrayList ArrayList() {
            if (null == this.items) {
                this.items = new ArrayList();
            }
            return this.items;
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Contains"]/*' />
        public bool Contains(string value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Contains1"]/*' />
        public bool Contains(object value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Clear"]/*' />
        public void Clear() {
            if (0 < Count) {
                OnSchemaChanging();  // fire event before value is validated
                ClearWithoutEvents();
                //OnSchemaChanged();
            }
        }

        internal void ClearWithoutEvents() { // also called by OleDbCommand.DeriveParameters
            if (null != items) {
                int count = items.Count;
                for(int i = 0; i < count; ++i) {
                    ((OleDbParameter) items[i]).Parent = null;
                }
                items.Clear();
            }
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            ArrayList().CopyTo(array, index);
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return ArrayList().GetEnumerator();
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.IndexOf"]/*' />
        public int IndexOf(string parameterName) {
            if (null != items) {
                int count = items.Count;
                for (int i = 0; i < count; ++i) {
                    if (0 == ADP.DstCompare(parameterName, ((OleDbParameter) items[i]).ParameterName)) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.IndexOf1"]/*' />
        public int IndexOf(object value) {
            if (null != value) {
                ValidateType(value);
                if (null != items) {
                    int count = items.Count;
                    for (int i = 0; i < count; ++i) {
                        if (value == items[i]) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Insert"]/*' />
        public void Insert(int index, object value) {
            OnSchemaChanging();  // fire event before value is validated
            ValidateType(value);
            Validate(-1, (OleDbParameter) value);
            ((OleDbParameter) value).Parent = this;
            ArrayList().Insert(index, value);
            //OnSchemaChanged();
        }

        //internal void OnSchemaChanged() { // commented out because OleDbCommand does nothing
        //    if (null != this.parent) {
        //        this.parent.OnSchemaChangedInternal(this);
        //    }
        //}

        internal void OnSchemaChanging() { // also called by OleDbParameter.OnSchemaChanging
            if (null != this.parent) {
                this.parent.OnSchemaChanging();
            }
        }

        private void RangeCheck(int index) {
            if ((index < 0) || (Count <= index)) {
                throw ADP.ParametersMappingIndex(index, this);
            }
        }

        private int RangeCheck(string parameterName) {
            int index = IndexOf(parameterName);
            if (index < 0) {
                throw ADP.ParametersSourceIndex(parameterName, this, ItemType);
            }
            return index;
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.RemoveAt"]/*' />
        public void RemoveAt(int index) {
            OnSchemaChanging(); // fire event before value is validated
            RangeCheck(index);
            RemoveIndex(index);
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.RemoveAt1"]/*' />
        public void RemoveAt(string parameterName) {
            OnSchemaChanging(); // fire event before value is validated
            int index = RangeCheck(parameterName);
            RemoveIndex(index);
        }

        private void RemoveIndex(int index) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            ((OleDbParameter) items[index]).Parent = null;
            items.RemoveAt(index);
            //OnSchemaChanged();
        }

        /// <include file='doc\OleDbParameterCollection.uex' path='docs/doc[@for="OleDbParameterCollection.Remove"]/*' />
        public void Remove(object value) {
            OnSchemaChanging(); // fire event before value is validated
            ValidateType(value);
            int index = IndexOf((OleDbParameter) value);
            if (-1 != index) {
                RemoveIndex(index);
            }
            else {
                throw ADP.CollectionRemoveInvalidObject(ItemType, this);
            }
        }

        private void Replace(int index, OleDbParameter newValue) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");            
            Validate(index, newValue);
            ((OleDbParameter) items[index]).Parent = null;
            newValue.Parent = this;
            items[index] = newValue;
            //OnSchemaChanged();
        }

        private void ValidateType(object value) {
            if (null == value) {
                throw ADP.ParameterNull("value", this, ItemType);
            }
            else if (!ItemType.IsInstanceOfType(value)) {
                throw ADP.InvalidParameterType(this, ItemType, value);
            }
        }

        private void Validate(int index, OleDbParameter value) {
            if (null == value) {
                throw ADP.ParameterNull("value", this, ItemType);
            }
            if (null != value.Parent) {
                if (this != value.Parent) {
                    throw ADP.ParametersIsNotParent(ItemType, value.ParameterName, this);
                }
                else if (index != IndexOf(value)) {
                    throw ADP.ParametersIsParent(ItemType, value.ParameterName, this);
                }
            }
            String name = value.ParameterName;
            if (ADP.IsEmpty(name)) { // generate a ParameterName
                index = 1;
                do {
                    name = ADP.Parameter + index.ToString();
                    index++;
                } while (-1 != IndexOf(name));
                value.ParameterName = name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbrowupdatedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbRowUpdatedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.Data;
    using System.Data.Common;

    /// <include file='doc\OleDbRowUpdatedEvent.uex' path='docs/doc[@for="OleDbRowUpdatedEventArgs"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbRowUpdatedEventArgs : RowUpdatedEventArgs {

        /// <include file='doc\OleDbRowUpdatedEvent.uex' path='docs/doc[@for="OleDbRowUpdatedEventArgs.OleDbRowUpdatedEventArgs"]/*' />
        public OleDbRowUpdatedEventArgs(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) 
        : base(dataRow, command, statementType, tableMapping) {
        }

        /// <include file='doc\OleDbRowUpdatedEvent.uex' path='docs/doc[@for="OleDbRowUpdatedEventArgs.Command"]/*' />
        new public OleDbCommand Command {
            get {
                return(OleDbCommand) base.Command;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbpropertysetguid.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbPropertySetGuid.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;

    sealed internal class OleDbPropertySetGuid {

        static internal readonly Guid DBInit            = new Guid(0xc8b522bc,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Rowset            = new Guid(0xc8b522be,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DataSource        = new Guid(0xc8b522ba,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DataSourceInfo    = new Guid(0xc8b522bb,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid PropertiesInError = new Guid(0xc8b522d4,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
#if DEBUG
        static internal readonly Guid View              = new Guid(0xc8b522df,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Trustee           = new Guid(0xc8b522e1,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid ColumnAll         = new Guid(0xc8b522f0,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid IndexAll          = new Guid(0xc8b522f1,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid TableAll          = new Guid(0xc8b522f2,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid TrusteeAll        = new Guid(0xc8b522f3,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid ConstraintAll     = new Guid(0xc8b522fa,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Column            = new Guid(0xc8b522b9,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Index             = new Guid(0xc8b522bd,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Table             = new Guid(0xc8b522bf,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DataSourceAll     = new Guid(0xc8b522c0,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DataSourceInfoAll = new Guid(0xc8b522c1,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid RowsetAll         = new Guid(0xc8b522c2,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Session           = new Guid(0xc8b522c6,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid SessionAll        = new Guid(0xc8b522c7,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DBInitAll         = new Guid(0xc8b522ca,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid ViewAll           = new Guid(0xc8b522fc,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid Stream            = new Guid(0xc8b522fd,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid StreamAll         = new Guid(0xc8b522fe,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        static internal string GetTextFromValue(Guid guid) { // UNDONE MDAC 74085
            if (guid == DBInit) { return "DBInit"; }
            if (guid == Rowset) { return "Rowset"; }
            if (guid == DataSource) { return "DataSource"; }
            if (guid == DataSourceInfo) { return "DataSourceInfo"; }
            if (guid == PropertiesInError) { return "PropertiesInError"; }

            if (guid == View) { return "View"; }
            if (guid == Trustee) { return "Trustee"; }
            if (guid == ColumnAll) { return "ColumnAll"; }
            if (guid == IndexAll) { return "IndexAll"; }
            if (guid == TableAll) { return "TableAll"; }
            if (guid == TrusteeAll) { return "TrusteeAll"; }
            if (guid == ConstraintAll) { return "ConstraintAll"; }
            if (guid == Column) { return "Column"; }
            if (guid == Index) { return "Index"; }
            if (guid == Table) { return "Table"; }
            if (guid == DataSourceAll) { return "DataSourceAll"; }
            if (guid == DataSourceInfoAll) { return "DataSourceInfoAll"; }
            if (guid == RowsetAll) { return "RowsetAll"; }
            if (guid == Session) { return "Session"; }
            if (guid == SessionAll) { return "SessionAll"; }
            if (guid == DBInitAll) { return "DBInitAll"; }
            if (guid == ViewAll) { return "ViewAll"; }
            if (guid == Stream) { return "Stream"; }
            if (guid == StreamAll) { return "StreamAll"; }

            return "{" + guid.ToString() + "}";
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbparameterconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbParameterConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Data.Common;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\OleDbParameterConverter.uex' path='docs/doc[@for="OleDbParameterConverter"]/*' />
    /// <internalonly/>
    sealed internal class OleDbParameterConverter : ExpandableObjectConverter {

        /// <include file='doc\OleDbParameterConverter.uex' path='docs/doc[@for="OleDbParameterConverter.CanConvertTo"]/*' />
        /// <internalonly/>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\OleDbParameterConverter.uex' path='docs/doc[@for="OleDbParameterConverter.ConvertTo"]/*' />
        /// <internalonly/>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw ADP.ArgumentNull("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is OleDbParameter) {
                OleDbParameter p = (OleDbParameter)value;

                // MDAC 67321 - reducing parameter generated code
                int flags = 0; // if part of the collection - the parametername can't be empty

                if (OleDbType.VarWChar != p.OleDbType) {
                    flags |= 1;
                }
                if (0 != p.Size) {
                    flags |= 2;
                }
                if (!ADP.IsEmpty(p.SourceColumn)) {
                    flags |= 4;
                }
                if (null != p.Value) {
                    flags |= 8;
                }
                if ((ParameterDirection.Input != p.Direction) || p.IsNullable
                    || (0 != p.Precision) || (0 != p.Scale) || (DataRowVersion.Current != p.SourceVersion)) {
                    flags |= 16;
                }

                Type[] ctorParams;
                object[] ctorValues;
                switch(flags) {
                case  0: // ParameterName
                case  1: // SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(OleDbType) };
                    ctorValues = new object[] { p.ParameterName, p.OleDbType };
                    break;
                case  2: // Size
                case  3: // Size, SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(OleDbType), typeof(int) };
                    ctorValues = new object[] { p.ParameterName, p.OleDbType, p.Size };
                    break;
                case  4: // SourceColumn
                case  5: // SourceColumn, SqlDbType
                case  6: // SourceColumn, Size
                case  7: // SourceColumn, Size, SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(OleDbType), typeof(int), typeof(string) };
                    ctorValues = new object[] { p.ParameterName, p.OleDbType, p.Size, p.SourceColumn };
                    break;
                case  8: // Value
                    ctorParams = new Type[] { typeof(string), typeof(object) };
                    ctorValues = new object[] { p.ParameterName, p.Value };
                    break;
                default:
                    ctorParams = new Type[] {
                        typeof(string), typeof(OleDbType), typeof(int), typeof(ParameterDirection),
                        typeof(bool), typeof(byte), typeof(byte), typeof(string), 
                        typeof(DataRowVersion), typeof(object) };
                    ctorValues = new object[] {
                        p.ParameterName, p.OleDbType,  p.Size, p.Direction,
                        p.IsNullable, p.Precision, p.Scale, p.SourceColumn,
                        p.SourceVersion, p.Value };
                    break;
                }
                ConstructorInfo ctor = typeof(OleDbParameter).GetConstructor(ctorParams);
                if (null != ctor) {
                    return new InstanceDescriptor(ctor, ctorValues);
                }
            }            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

// switch between Provider="" meaning to allow all providers or no provider
//#define EMPTYFORALL

namespace System.Data.OleDb {

    using System.Collections;
    using System.Data.Common;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    [Serializable] sealed public class OleDbPermission :  DBDataPermission {

        private String[] _providerRestriction; // should never be string[0]
        private String _providers;

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.OleDbPermission"]/*' />
        [ Obsolete("use OleDbPermission(PermissionState.None)", true) ]
        public OleDbPermission() {
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.OleDbPermission1"]/*' />
        public OleDbPermission(PermissionState state) : base(state) {
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.OleDbPermission2"]/*' />
        [ Obsolete("use OleDbPermission(PermissionState.None)", true) ]
        public OleDbPermission(PermissionState state, bool allowBlankPassword) : base(state, allowBlankPassword) {
        }

        private OleDbPermission(OleDbPermission permission) : base(permission) { // for Copy
            if (null != permission) {
                _providerRestriction = permission._providerRestriction;
                _providers = permission._providers;
            }
        }

        internal OleDbPermission(OleDbPermissionAttribute permissionAttribute) : base(permissionAttribute) { // for CreatePermission
            if (null == permissionAttribute) {
                throw ADP.ArgumentNull("permissionAttribute");
            }
            Provider = permissionAttribute.Provider;
        }

        internal OleDbPermission(OleDbConnectionString constr) : base(constr) { // for Open
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.Provider"]/*' />
        public string Provider {
            get {
                string providers = _providers; // MDAC 83103
                if (null == providers) {
                    string[] restrictions = _providerRestriction;
                    if (null != restrictions) {
                        int count = restrictions.Length;
                        if (0 < count) {
                            providers = restrictions[0];
                            for (int i = 1; i < count; ++i) {
                                providers += ";" + restrictions[i];
                            }
                        }
                    }
                }
                return ((null != providers) ? providers : ADP.StrEmpty);
            }
            set { // MDAC 61263
                string[] restrictions = null;
                if (!ADP.IsEmpty(value)) {
                    restrictions = value.Split(ODB.ProviderSeparatorChar);
                    restrictions = DBConnectionString.RemoveDuplicates(restrictions);

                    Clear(); // MDAC 83105

                    bool shapeflag = false;
                    for (int i = 0; i < restrictions.Length; ++i) {
                        string provider = restrictions[i];
                        if (!IsShapeProvider(provider)) { // MDAC 83104
                            Add("provider=" + provider, ADP.StrEmpty, KeyRestrictionBehavior.PreventUsage);
                        }
                        else {
                            shapeflag = true;
                        }
                    }
                    if (shapeflag) {
                        for (int i = 0; i < restrictions.Length; ++i) {
                            string provider = restrictions[i];
                            if (!IsShapeProvider(provider)) {
                                Add("provider=MSDataShape;data provider=" + provider, ADP.StrEmpty, KeyRestrictionBehavior.PreventUsage);
                            }
                        }
                    }

                    string[] oldrestrictions = _providerRestriction; // appending to existing
                    if ((null != oldrestrictions) && (0 < oldrestrictions.Length)) {
                        int count = restrictions.Length + oldrestrictions.Length;

                        string[] tmp = new string[count];
                        restrictions.CopyTo(tmp, 0);
                        oldrestrictions.CopyTo(tmp, restrictions.Length);
                        restrictions = DBConnectionString.RemoveDuplicates(tmp);
                        value = null;
                    }
                }
                _providerRestriction = restrictions;
                _providers = value;
            }
        }

        static private bool IsShapeProvider(string provider) {
            return (("MSDataShape" == provider) || provider.StartsWith("MSDataShapte."));
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.Copy"]/*' />
        override public IPermission Copy () {
            return new OleDbPermission(this);
        }
#if false
        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.IsSubsetOf"]/*' />
        override public bool IsSubsetOf(IPermission target) {
            // (null == target) check for when IsEmpty returns true for null target
            bool subset = (base.IsSubsetOf(target) && ((null == target) || IsSubsetOfOleDb((OleDbPermission)target)));
            return subset;
        }

        private bool IsSubsetOfOleDb(OleDbPermission target) {
            if (null != _providerRestriction) {
#if EMPTYFORALL
                if ((null != target._providerRestriction) && (0 < target._providerRestriction.Length)) {
#else
                if (null != target._providerRestriction) {
#endif
                    int count = _providerRestriction.Length;
                    for (int i = 0; i < count; ++i) {
                        if (0 > Array.BinarySearch(target._providerRestriction, _providerRestriction[i], InvariantComparer.Default)) {
                            // when Provider="SQLOLEDB" and target.Provider="SQLOLEDB.1"
                            // or when Provider="SQLOLEDB" and target.Provider="" but not when EMPTYFORALL
                            return false;
                        }
                    }
                    // when Provider="SQLOLEDB" and target.Provider="SQLOLEDB"
                    // not when Provider="" and target.Provider="SQLOLEDB"
                    return (0 < count);
                }
#if EMPTYFORALL
                // when target.Provider="" or target.Provider=""
                return true;
#else
                // when Provider="" or target.Provider=""
                return (0 == _providerRestriction.Length);
#endif
            }
            // when Provider="" and target.Provider=""
            // when Provider="" and target.Provider="SQLOLEDB"
            return true; // MDAC 68928
        }
#endif

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.Intersect"]/*' />
        override public IPermission Intersect(IPermission target) { // used during Deny actions
            OleDbPermission newPermission = (OleDbPermission) base.Intersect(target);
            if ((null != newPermission) && !newPermission.IsUnrestricted()) {
                newPermission = IntersectOleDb((target as OleDbPermission), newPermission);
            }
            return newPermission;
        }

        private OleDbPermission IntersectOleDb(OleDbPermission target, OleDbPermission newPermission) {
            string[] theseRestrictions = _providerRestriction; // MDAC 83107
            string[] thoseRestrictions = target._providerRestriction;

            if (null != theseRestrictions) {
                if (null != thoseRestrictions) {

                    int count = theseRestrictions.Length;
                    string[] restriction = new string[count];

                    int k = 0;
                    for (int i = 0; i < count; ++i) {
                        if (0 <= Array.BinarySearch(thoseRestrictions, theseRestrictions[i], InvariantComparer.Default)) {
                            restriction[k] = theseRestrictions[i];
                            k++;
                        }
                    }
                    if (0 < k) {
                        if (k < count) {
                            // when Provider="SQLOLEDB" and target.Provider="SQLOLEDB;SQLOLEDB.1"
                            string[] tmp = new string[k];
                            for(int i = 0; i < k; ++i) {
                                tmp[i] = restriction[i];
                            }
                            newPermission._providerRestriction = tmp;
                        }
                        else {
                            // when Provider="SQLOLEDB" and target.Provider="SQLOLEDB"
                            newPermission._providerRestriction = restriction;
                        }
                    }
                    else {
                        // when Provider="SQLOLEDB" and target.Provider="SQLOLEDB.1"
                        newPermission = null;
                    }
                }
                // else {
                    // when Provider="SQLOLEDB" and target.Provider=""
                    // return a non-null object so that later IsSubset calls fail
                //}
            }
            // else if ((null != thoseRestrictions) && (0 <= thoseRestrictions.Length)) {
                // when Provider="" and target.Provider="SQLOLEDB"
                // return a non-null object so that later IsSubset calls fail
            //}
            return newPermission;
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.Union"]/*' />
        override public IPermission Union(IPermission target) {
            OleDbPermission newPermission = (OleDbPermission) base.Union(target);
            if ((null != newPermission) && !newPermission.IsUnrestricted()) {
                newPermission = UnionOleDb((target as OleDbPermission), newPermission);
            }
            return newPermission;
        }

        private OleDbPermission UnionOleDb(OleDbPermission target, OleDbPermission newPermission) {
            if (null == target) {
                newPermission._providerRestriction = _providerRestriction;
            }
            else {
                string[] theseRestrictions = _providerRestriction; // MDAC 83107
                string[] thoseRestrictions = target._providerRestriction;

                if (null == theseRestrictions) {
                    newPermission._providerRestriction = thoseRestrictions;
                }
                else if (null == thoseRestrictions) {
                    newPermission._providerRestriction = theseRestrictions;
                }
                else { // union of two string[]
                    int a = theseRestrictions.Length;
                    int b = thoseRestrictions.Length;

                    string[] restrictions = new string[a+b];
                    theseRestrictions.CopyTo(restrictions, 0);
                    thoseRestrictions.CopyTo(restrictions, a);
                    newPermission._providerRestriction = DBConnectionString.RemoveDuplicates(restrictions);
                }
            }
            return newPermission;
        }

        // <IPermission class="OleDbPermission" version="1"  AllowBlankPassword=false>
        //   <keyword name="provider">
        //       <value value="sqloledb"/>
        //       <value value="sqloledb.1"/>
        //   </keyword>
        // </IPermission>
        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.FromXml"]/*' />
        override public void FromXml(SecurityElement securityElement) {
            base.FromXml(securityElement);

            ArrayList children = securityElement.Children;
            if (IsUnrestricted() || (null == children)) {
                return;
            }
            int count;
            Hashtable hash = new Hashtable();
            foreach(SecurityElement keyElement in children) {
                string keyword = keyElement.Attribute(ODB._Name);
                if (null != keyword) {
                    keyword = keyword.ToLower(CultureInfo.InvariantCulture);
                }
                if (keyElement.Tag.Equals(ODB._Keyword) && (null != keyword) && (ODB.Provider == keyword)) {

                    ArrayList keyvaluepair = keyElement.Children;
                    if (null != keyvaluepair) {
                        count = keyvaluepair.Count;
                        for (int i = 0; i < count; ++i) {
                            SecurityElement valueElement = (SecurityElement) keyvaluepair[i];

                            string value = (string) valueElement.Attribute(ODB._Value);
                            if (valueElement.Tag.Equals(ODB._Value) && (null != value)) {
                                value = value.Trim();
                                if (0 < value.Length) {
                                    hash[value] = null;
                                }
                            }
                        }
                    }
                }
            }
            count = hash.Count;
            if (0 < count) {
                string[] oldrestrictions = _providerRestriction; // appending to
                if (null != oldrestrictions) {
                    count += oldrestrictions.Length;
                }
                string[] restrictions = new string[count];
                hash.Keys.CopyTo(restrictions, 0);
                if (null != oldrestrictions) {
                    oldrestrictions.CopyTo(restrictions, count - oldrestrictions.Length);                    
                }
                _providerRestriction = DBConnectionString.RemoveDuplicates(restrictions);
                _providers = null;
            }
        }

        // <IPermission class="OleDbPermission" version="1" AllowBlankPassword=false>
        //   <keyword name="provider">
        //       <value value="sqloledb"/>
        //       <value value="sqloledb.1"/>
        //   </keyword>
        // </IPermission>
        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermission.ToXml"]/*' />
        override public SecurityElement ToXml() {
            SecurityElement securityElement = base.ToXml();

            if (IsUnrestricted() || (null == securityElement)
                || (null == _providerRestriction) || (0 == _providerRestriction.Length)) {
                return securityElement;
            }

            SecurityElement keyElement = new SecurityElement(ODB._Keyword);
            keyElement.AddAttribute(ODB._Name, ODB.Provider);

            foreach(string value in this._providerRestriction) {
                SecurityElement valueElement = new SecurityElement(ODB._Value);
                valueElement.AddAttribute(ODB._Value, value);
                keyElement.AddChild(valueElement);
            }
            securityElement.AddChild(keyElement);
            return securityElement;
        }
    }

    /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    [Serializable()] sealed public class OleDbPermissionAttribute : DBDataPermissionAttribute {

        private String _providers;

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermissionAttribute.OleDbPermissionAttribute"]/*' />
        public OleDbPermissionAttribute(SecurityAction action) : base(action) {
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermissionAttribute.Provider"]/*' />
        public String Provider {
            get {
                string providers = _providers;
                return ((null != providers) ? providers : ADP.StrEmpty);
            }
            set {
                _providers = value;
            }
        }

        /// <include file='doc\OleDbPermission.uex' path='docs/doc[@for="OleDbPermissionAttribute.CreatePermission"]/*' />
        override public IPermission CreatePermission() {
            return new OleDbPermission(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    
    /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter"]/*' />
    [
    TypeConverterAttribute(typeof(OleDbParameterConverter))
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbParameter : MarshalByRefObject, IDbDataParameter, ICloneable {
        private string parameterName;
        private OleDbParameterCollection parent;
        private object pvalue; // null

        private string sourceColumn;
        private DataRowVersion sourceVersion = DataRowVersion.Current;

        private int size; // maximum as set by user
        //private int offset;
        //private int actualSize;

        private bool designNullable;
        private bool userSpecifiedType, userSpecifiedScale;
        private NativeDBType inferType;
        private NativeDBType _oledbType = OleDb.NativeDBType.Default;
        private ParameterDirection direction = ParameterDirection.Input;

        // used for decimal and numeric input parameters
        private Byte precision;  // # digits
        private Byte scale;      // # digits to left or right of decimal point

        private bool valueConverted; // MDAC 68460
        private object convertedValue;        

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbParameter"]/*' />
        public OleDbParameter() {
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbParameter5"]/*' />
        public OleDbParameter(string name, object value) { // MDAC 59521
            // UNDONE: a desire for a retail type of assert so users don't use SqlDbType for OleDb
            Debug.Assert(!(value is SqlDbType), "use OleDbParameter(string, OleDbType)");

            this.ParameterName = name;
            this.Value = value;
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbParameter1"]/*' />
        public OleDbParameter(string name, OleDbType dataType) {
            this.ParameterName = name;
            this.OleDbType = dataType;
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbParameter2"]/*' />
        public OleDbParameter(string name, OleDbType dataType, int size) {
            this.ParameterName = name;
            this.OleDbType = dataType;
            this.Size = size;
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbParameter3"]/*' />
        public OleDbParameter(string name, OleDbType dataType, int size, string srcColumn) {
            this.ParameterName = name;
            this.OleDbType = dataType;
            this.Size = size;
            this.SourceColumn = srcColumn;
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbParameter4"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        public OleDbParameter(string parameterName,
                              OleDbType dbType, int size,
                              ParameterDirection direction, Boolean isNullable,
                              Byte precision, Byte scale,
                              string srcColumn, DataRowVersion srcVersion,
                              object value) {
            this.ParameterName = parameterName;
            this.OleDbType = dbType;
            this.Size = size;
            this.Direction = direction;
            this.IsNullable = isNullable;
            this.Precision = precision;
            this.Scale = scale;
            this.SourceColumn = srcColumn;
            this.SourceVersion = srcVersion;
            this.Value = value;
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.DbType"]/*' />
        [
        Browsable(false),
        DataCategory(Res.DataCategory_Data),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataParameter_DbType),
        RefreshProperties(RefreshProperties.All)
        ]
        public DbType DbType {
            get {
                //return ((null != _oledbType) ? _oledbType.enumDbType : OleDb.NativeDBType.Default.enumDbType));
                return _oledbType.enumDbType;
            }
            set {
                if (!this.userSpecifiedType || (_oledbType.enumDbType != value)) { // MDAC 63571
                    BindingChange();
                    NativeDBType = NativeDBType.FromDbType(value);
                }
            }
        }
        
        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.Direction"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(ParameterDirection.Input),
        DataSysDescription(Res.DataParameter_Direction)
        ]
        public ParameterDirection Direction {
            get {
                return direction;
            }
            set {
                if (this.direction != value) {
                    BindingChange();
                    switch (value) { // @perfnote: Enum.IsDefined
                    case ParameterDirection.Input:
                    case ParameterDirection.Output:
                    case ParameterDirection.InputOutput:
                    case ParameterDirection.ReturnValue:
                        this.direction = value;
                        break;
                    default:
                        throw ADP.InvalidParameterDirection((int) value, ParameterName);
                    }
                }
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.IsNullable"]/*' />
        [
        Browsable(false), // MDAC 70780
        DefaultValue(false),
        DesignOnly(true),
        DataSysDescription(Res.DataParameter_IsNullable),
        EditorBrowsableAttribute(EditorBrowsableState.Advanced) // MDAC 69508
        ]
        public bool IsNullable {
            get {
                return designNullable;
            }
            set {
                designNullable = value;
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.OleDbType"]/*' />
        [
        DefaultValue(OleDbType.VarWChar), // MDAC 65862
        DataCategory(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DataSysDescription(Res.OleDbParameter_OleDbType)
        ]
        public OleDbType OleDbType {
            get {
                //return ((null != _oledbType) ? _oledbType.enumOleDbType : OleDb.NativeDBType.Default.enumOleDbType));
                return _oledbType.enumOleDbType;
            }
            set {
                if (!this.userSpecifiedType || (_oledbType.enumOleDbType != value)) { // MDAC 63571
                    BindingChange();
                    NativeDBType = NativeDBType.FromDataType(value);
                }
            }
        }

        private bool ShouldSerializeOleDbType() {
            return this.userSpecifiedType;
        }

        private NativeDBType NativeDBType { // MDAC 60513
            get {
                if (null == this.inferType) {
                    if (this.userSpecifiedType || (null == this.pvalue) || Convert.IsDBNull(this.pvalue)) {
                        return this._oledbType; // default is NativeDBType.Default
                    }
                    this.inferType = NativeDBType.FromSystemType(this.pvalue.GetType());
                }
                return this.inferType;
            }
            set {
                this.inferType = this._oledbType = value;
                this.userSpecifiedType = true;
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.ParameterName"]/*' />
        [
        DefaultValue(""),
        DataSysDescription(Res.DataParameter_ParameterName)
        ]
        public string ParameterName {
            get {
                return ((null != this.parameterName) ? this.parameterName : String.Empty);
            }
            set {
                if (0 != String.Compare(value, this.parameterName, false, CultureInfo.InvariantCulture)) {
                    BindingChange();
                    this.parameterName = value;
                }
            }
        }

        internal OleDbParameterCollection Parent {
            get {
                return this.parent;
            }
            set {
                this.parent = value;
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.Precision"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        DataSysDescription(Res.DbDataParameter_Precision)
        ]
        public Byte Precision {
            get {
                return precision;
            }
            set {
                if (this.precision != value) {
                    BindingChange();
                    this.precision = value;
                }
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.Scale"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        DataSysDescription(Res.DbDataParameter_Scale)
        ]
        public Byte Scale {
            get {
                return scale;
            }
            set {
                if (this.scale != value) {
                    BindingChange();
                    this.scale = value;
                }
                this.userSpecifiedScale = true;
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.Size"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(0),
        DataSysDescription(Res.DbDataParameter_Size)
        ]
        public int Size {
            get {
                return this.size;
            }
            set {
                if (this.size != value) {
                    BindingChange();
                    if (value < 0) {
                        throw ADP.InvalidSizeValue(value);
                    }
                    this.size = value;
                }
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.SourceColumn"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataParameter_SourceColumn)
        ]
        public string SourceColumn {
            get {
                return ((null != this.sourceColumn) ? this.sourceColumn : String.Empty);
            }
            set {
                this.sourceColumn = value;
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.SourceVersion"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(DataRowVersion.Current),
        DataSysDescription(Res.DataParameter_SourceVersion)
        ]
        public DataRowVersion SourceVersion {
            get {
                return sourceVersion;
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case DataRowVersion.Original:
                case DataRowVersion.Current:
                case DataRowVersion.Proposed:
                case DataRowVersion.Default:
                    this.sourceVersion = value;
                    break;
                default:
                    throw ADP.InvalidDataRowVersion(ParameterName, (int) value);
                }
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.Value"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(null),
        DataSysDescription(Res.DataParameter_Value),
        TypeConverterAttribute(typeof(StringConverter))
        ]
        public object Value {
            get {
                return this.pvalue;
            }
            set {
                this.valueConverted = false;
                this.convertedValue = null;

                this.pvalue = value;
                this.inferType = null;
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            OleDbParameter clone = new OleDbParameter(); // MDAC 81448
            clone.ParameterName = ParameterName;
            clone.Direction = Direction;
            clone.IsNullable = IsNullable;
            clone.SourceColumn = SourceColumn;
            clone.SourceVersion = SourceVersion;
            clone.Precision = Precision;
            if (userSpecifiedScale) {
                clone.Scale = Scale;
            }
            clone.Size = Size;

            object value = Value;
            if (value is ICloneable) {
                value = ((ICloneable) value).Clone();
            }
            clone.Value = value;

            clone.userSpecifiedType = this.userSpecifiedType;
            clone.inferType = this.inferType;
            clone._oledbType = _oledbType; // DataType & DbType
            return clone;
        }

        private void BindingChange() {
            this.valueConverted = false;
            this.convertedValue = null;
            if (null != this.parent) {
                this.parent.OnSchemaChanging();
            }
        }

        internal bool BindParameter(int i, DBBindings bindings, UnsafeNativeMethods.tagDBPARAMBINDINFO[] bindInfo) {
            ValidateParameter();

            int wtype = NativeDBType.wType;

            int maxLen = GetParameterByteCount();

            NativeDBType dbType = NativeDBType;
            if (dbType.islong || (IsParameterVarLength() && (ODB.LargeDataSize < maxLen))) {
                maxLen = IntPtr.Size;
                wtype |= NativeDBType.BYREF;
            }
            byte precision = GetParameterPrecision();
            byte scale = GetParameterScale();

            bindInfo[i].pwszDataSourceType = NativeDBType.dbString;
            bindInfo[i].pwszName = IntPtr.Zero;
            bindInfo[i].ulParamSize = new IntPtr(GetParameterSize());
            bindInfo[i].dwFlags = GetParameterFlags();
            bindInfo[i].bPrecision = precision;
            bindInfo[i].bScale = scale;

            // tagDBBINDING info for CreateAccessor
            bindings.CurrentIndex = i;
            bindings.Ordinal      = i+1;
          //bindings.ValueOffset  = bindings.DataBufferSize; // set via MaxLen
          //bindings.LengthOffset = i * sizeof_int64;
          //bindings.StatusOffset = i * sizeof_int64 + sizeof_int32;
          //bindings.TypeInfoPtr  = 0;
          //bindings.ObjectPtr    = 0;
          //bindings.BindExtPtr   = 0;
            bindings.Part         = NativeDBType.dbPart;
          //bindings.MemOwner     = /*DBMEMOWNER_CLIENTOWNED*/0;
            bindings.ParamIO      = GetParameterDirection();
            bindings.MaxLen       = maxLen; // also increments databuffer size
          //bindings.Flags        = 0;
            bindings.DbType       = wtype;
            bindings.Precision    = precision;
            bindings.Scale        = scale;

#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceVerbose) {
                ODB.Trace_Binding(i, bindings, ParameterName);
            }
#endif
            return IsParameterComputed();
        }

        private int GetParameterByteCount() {
            NativeDBType dbType = NativeDBType;
            int tmp = dbType.fixlen; // fixed length
            Debug.Assert(0 != tmp, "GetParameterByteCount: 0 length in lookup table");
            if (0 >= tmp) {
                tmp = Size;
                if ((0 == tmp) && (0 != (ParameterDirection.Input & Direction))) {
                    tmp = GetParameterValueSize();
                }
                tmp = Math.Max(tmp, 0);
                if (0 < tmp) {
                    if (NativeDBType.STR == dbType.wType) {
                        tmp = Math.Min(tmp, Int32.MaxValue-1) + 1;
                    }
                    else if (NativeDBType.WSTR == dbType.wType) {
                        tmp = Math.Min(tmp, 1073741822/*Int32.MaxValue/2-1*/) * 2 + 2;
                    }
                }
                else if (NativeDBType.STR == dbType.wType) { // allow space for null termination character
                    tmp = 1;
                }
                else if (NativeDBType.WSTR == dbType.wType) { // allow space for null termination character
                    tmp = 2;
                }
            }
            Debug.Assert(0 < tmp || NativeDBType.BYTES == dbType.wType, "GetParameterByteCount");
            return tmp;
        }

        private int GetParameterSize() {
            NativeDBType dbType = NativeDBType;
            if (-1 != dbType.fixlen) {
                return dbType.fixlen;
            }
            if (dbType.islong) { // MDAC 80657
                return ~0;
            }
            if (0 < Size) {
                return Size;
            }
            if (ParameterDirection.Input == Direction) { // MDAC 63571, 69475
                object value = GetParameterValue();
                if (typeof(string) == dbType.dataType) {
                    if (value is String) {
                        int len = ((String) value).Length;
                        if (NativeDBType.STR == dbType.dbType) { // MDAC 63961
                            len *= 2;
                        }
                        return len;
                    }
                }
                else if (typeof(Byte[]) == dbType.dataType) {
                    if (value is Byte[]) {
                        return ((Byte[]) value).Length;
                    }
                }
            }
            return 0;
        }

        private int GetParameterDirection() {
            return (ODB.ParameterDirectionFlag & (int)Direction);
            /*switch(Direction) {
            default:
            case ParameterDirection.Input:
                return ODB.DBPARAMIO_INPUT;
            case ParameterDirection.Output:
            case ParameterDirection.ReturnValue:
                return ODB.DBPARAMIO_OUTPUT;
            case ParameterDirection.InputOutput:
                return (ODB.DBPARAMIO_INPUT | ODB.DBPARAMIO_OUTPUT);
            }*/
        }

        private int GetParameterFlags() {
            return (ODB.ParameterDirectionFlag & (int)Direction);
            /*switch(Direction) {
            default:
            case ParameterDirection.Input:
                return ODB.DBPARAMFLAGS_ISINPUT;
            case ParameterDirection.Output:
            case ParameterDirection.ReturnValue:
                return ODB.DBPARAMFLAGS_ISOUTPUT;
            case ParameterDirection.InputOutput:
                return (ODB.DBPARAMFLAGS_ISINPUT | ODB.DBPARAMFLAGS_ISOUTPUT);
            }*/
        }

        private byte GetParameterPrecision() {
            if (0 == this.precision) { // MDAC 60882, 65832, 65992
                return NativeDBType.maxpre;
            }
            return this.precision;
        }

        private byte GetParameterScale() {
            if (userSpecifiedScale && ((0 != this.scale) || (0 != this.precision))) {
                return this.scale;
            }
            object v = GetParameterValue(); // MDAC 68460
            if (v is Decimal) { // MDAC 60882
                return (byte)((Decimal.GetBits((Decimal)v)[3] & 0x00ff0000) >> 0x10);
            }
            return 0;
        }

        internal object GetParameterValue() { // MDAC 60513
            if (!this.valueConverted) {
                this.convertedValue = this.pvalue;
                if (this.userSpecifiedType && (null != this.pvalue) && (DBNull.Value != this.pvalue)) {
                    Type type = this.pvalue.GetType();
                    if ((type != _oledbType.dataType) && !type.IsArray && !Convert.IsDBNull(this.pvalue)) {
                        this.convertedValue = Convert.ChangeType(this.pvalue, _oledbType.dataType);
                    }
                }
                this.valueConverted = true;
            }
            return this.convertedValue;
        }

        private int GetParameterValueSize() {
            NativeDBType dbType = NativeDBType;
            Type dataType = dbType.dataType;

            object value = GetParameterValue();
            if (typeof(string) == dataType) {
                if (value is String) {
                    if (NativeDBType.STR == dbType.wType) {
                        // CONSIDER: doing slow method to compute correct ansi length
                        // user work-around is to specify a size
                        return ((String) value).Length * 2; // MDAC 69865
                    }
                    return ((String) value).Length; // MDAC 69865
                }
            }
            else if ((typeof(byte[]) == dataType) && (value is byte[])) {
                return ((Byte[]) value).Length; // MDAC 69865
            }
            return 0;
        }

        private bool IsParameterComputed() {
            return (!this.userSpecifiedType
                    || ((0 == Size) && IsParameterVarLength())
                    || ((NativeDBType.DECIMAL == NativeDBType.dbType) || (NativeDBType.NUMERIC == NativeDBType.dbType)
                        && (!this.userSpecifiedScale || ((0 == Scale) && (0 == Precision)))
                        )
                    ); // MDAC 69299
        }

        private bool IsParameterVarLength() {
            return(-1 == NativeDBType.fixlen);
        }

        /*protected void SetValueChunk(object value, int offset, int actualSize) {
            if ((value is byte[]) || (value is string)) {
                this.value = value;
                this.offset = offset;
                this.actualSize = actualSize;
            }
            else {
                throw ADP.Argument();
            }
        }*/

        internal void Prepare(OleDbCommand cmd) { // MDAC 70232
            if (!this.userSpecifiedType) {
                throw ADP.PrepareParameterType(cmd);
            }
            else if ((0 == Size) && IsParameterVarLength()) {
                throw ADP.PrepareParameterSize(cmd);
            }
            else if ((0 == Precision) && (0 == Scale) && ((NativeDBType.DECIMAL == _oledbType.wType) || (NativeDBType.NUMERIC == _oledbType.wType))) { // MDAC 71441
                throw ADP.PrepareParameterScale(cmd, _oledbType.wType.ToString("G"));
            }
        }

        /// <include file='doc\OleDbParameter.uex' path='docs/doc[@for="OleDbParameter.ToString"]/*' />
        override public string ToString() {
            return ParameterName;
        }

        private void ValidateParameter() {
            if (this.userSpecifiedType && (OleDbType.Empty == OleDbType)) {
                throw ODB.UninitializedParameters(this.parent.IndexOf(this), ParameterName, OleDbType);
            } 
            else if ((0 == GetParameterSize()) && (0 != (ParameterDirection.Output & Direction))) {
                throw ADP.UninitializedParameterSize(this.parent.IndexOf(this), ParameterName, NativeDBType.dataType, Size);
            }
            Debug.Assert(0 <= Size, "unexpected parameter size");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbrowupdatedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbRowUpdatedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    /// <include file='doc\OleDbRowUpdatedEventHandler.uex' path='docs/doc[@for="OleDbRowUpdatedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.OleDb.OleDbDataAdapter.RowUpdated'/> event of an <see cref='System.Data.OleDb.OleDbDataAdapter'/>.
    ///    </para>
    /// </devdoc>
    public delegate void OleDbRowUpdatedEventHandler(object sender, OleDbRowUpdatedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbrowupdatingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbRowUpdatingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    /// <include file='doc\OleDbRowUpdatingEventHandler.uex' path='docs/doc[@for="OleDbRowUpdatingEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.OleDb.OleDbDataAdapter.RowUpdating'/> event of an <see cref='System.Data.OleDb.OleDbDataAdapter'/>.
    ///    </para>
    /// </devdoc>
    public delegate void OleDbRowUpdatingEventHandler(object sender, OleDbRowUpdatingEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbrowupdatingevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbRowUpdatingEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.Data;
    using System.Data.Common;

    /// <include file='doc\OleDbRowUpdatingEvent.uex' path='docs/doc[@for="OleDbRowUpdatingEventArgs"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    sealed public class OleDbRowUpdatingEventArgs : RowUpdatingEventArgs {

        /// <include file='doc\OleDbRowUpdatingEvent.uex' path='docs/doc[@for="OleDbRowUpdatingEventArgs.OleDbRowUpdatingEventArgs"]/*' />
        public OleDbRowUpdatingEventArgs(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) 
        : base(dataRow, command, statementType, tableMapping) {
        }


        /// <include file='doc\OleDbRowUpdatingEvent.uex' path='docs/doc[@for="OleDbRowUpdatingEventArgs.Command"]/*' />
        new public OleDbCommand Command {
            get {
                return(OleDbCommand) base.Command;
            }
            set {
                base.Command = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbtransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System.Data.Common;
    using System.Data;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction"]/*' />
    sealed public class OleDbTransaction : MarshalByRefObject, IDbTransaction {

        private UnsafeNativeMethods.ITransactionLocal localTransaction;
        private System.Data.IsolationLevel isolationLevel;
        private OleDbTransaction parentTransaction; // strong reference to keep parent alive
        private WeakReference weakTransaction; // child transactions
        private IntPtr iunknown;

        internal OleDbConnection parentConnection;

        internal OleDbTransaction(OleDbConnection connection) {
            this.parentConnection = connection;
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.Connection"]/*' />
        public OleDbConnection Connection { // MDAC 66655
            get {
                return parentConnection;
            }
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.IDbTransaction.Connection"]/*' />
        /// <internalonly/>
        IDbConnection IDbTransaction.Connection {
            get {
                return Connection;
            }
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.IsolationLevel"]/*' />
        public IsolationLevel IsolationLevel {
            get {
                if (null == this.localTransaction) {
                    throw ADP.TransactionZombied(this);
                }
                return isolationLevel;
            }
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.Begin"]/*' />
        public OleDbTransaction Begin(IsolationLevel isolevel) {
            OleDbConnection.OleDbPermission.Demand(); // MDAC 81476

            if (null == this.localTransaction) {
                throw ADP.TransactionZombied(this);
            }
            parentConnection.CheckStateOpen(ADP.BeginTransaction);
            OleDbTransaction transaction = new OleDbTransaction(this.parentConnection);
            this.weakTransaction = new WeakReference(transaction);
            transaction.BeginInternal(this.localTransaction, isolevel);
            transaction.parentTransaction = this;
            return transaction;
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.Begin1"]/*' />
        public OleDbTransaction Begin() {
            return Begin(IsolationLevel.ReadCommitted);
        }

        internal void BeginInternal(UnsafeNativeMethods.ITransactionLocal transaction, IsolationLevel isolevel) {
            switch(isolevel) {
            case IsolationLevel.Unspecified:
            case IsolationLevel.Chaos:
            case IsolationLevel.ReadUncommitted:
            case IsolationLevel.ReadCommitted:
            case IsolationLevel.RepeatableRead:
            case IsolationLevel.Serializable:
                break;
            default:
                throw ADP.InvalidIsolationLevel((int) isolationLevel);
            }

            int hr, transactionLevel = 0;
#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_Begin("ITransactionLocal", "StartTransaction", this.isolationLevel.ToString("G"));
            }
#endif
            // $UNDONE: how is it possible to guard against something like ThreadAbortException
            //          when transaction started, but aborted before localTransaction is set
            //          so we know to rollback the transaction for when connection is returned to the pool
            hr = transaction.StartTransaction((int) isolevel, 0, null, out transactionLevel);

#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_End("ITransactionLocal", "StartTransaction", hr, "TransactionLevel=" + transactionLevel);
            }
#endif
            if (hr < 0) {
                ProcessResults(hr);
            }

            this.isolationLevel = isolevel;
            this.localTransaction = transaction;
            this.iunknown = Marshal.GetIUnknownForObject(transaction);
            GC.KeepAlive(this);
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.Commit"]/*' />
        public void Commit() {
            OleDbConnection.OleDbPermission.Demand(); // MDAC 81476

            if (null == this.localTransaction) {
                throw ADP.TransactionZombied(this);
            }
            parentConnection.CheckStateOpen(ADP.CommitTransaction);
            CommitInternal();
        }

        private void CommitInternal() {
            if (null == this.localTransaction) {
                return;
            }
            if (null != this.weakTransaction) {
                OleDbTransaction transaction = (OleDbTransaction) this.weakTransaction.Target;
                if ((null != transaction) && this.weakTransaction.IsAlive) {
                    transaction.CommitInternal();
                }
                this.weakTransaction = null;
            }
#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_Begin("ITransactionLocal", "Commit");
            }
#endif
            int hr;
            hr = this.localTransaction.Commit(0, /*OleDbTransactionControl.SynchronousPhaseTwo*/2, 0);

#if DEBUG
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                ODB.Trace_End("ITransactionLocal", "Commit", hr);
            }
#endif
            if (hr < 0) {
                if (ODB.XACT_E_NOTRANSACTION == hr) {
                    Marshal.Release(this.iunknown);
                    this.iunknown = IntPtr.Zero;

                    this.localTransaction = null;
                    DisposeManaged();
                }
                ProcessResults(hr);
            }

            if (IntPtr.Zero != this.iunknown) {
                Marshal.Release(this.iunknown);
                this.iunknown = IntPtr.Zero;
            }

            // if an exception is thrown, user can try to commit their transaction again
            this.localTransaction = null;
            DisposeManaged();
            GC.KeepAlive(this);
            GC.SuppressFinalize(this);
        }

        /*public OleDbCommand CreateCommand() { // MDAC 68309
            OleDbCommand cmd = Connection.CreateCommand();
            cmd.Transaction = this;
            return cmd;
        }

        IDbCommand IDbTransaction.CreateCommand() {
            return CreateCommand();
        }*/

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.Finalize"]/*' />
        ~OleDbTransaction() {
            Dispose(false);
            // during finalize we don't care about the order of rollback
            // either there is a strong reference were our nested transaction keeps alive
            // or the user does

            // or the connection will start rolling back transactions from the last to first transaction
            // during its close or its finalization before release the session object which kills localTransaction
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.KeepAlive(this); // MDAC 79539
            GC.SuppressFinalize(this);
        }

        // <fxcop ignore="MethodsInTypesWithIntPtrFieldAndFinalizeMethodRequireGCKeepAlive"/>
        private void Dispose(bool disposing) {
            if (disposing) { // release mananged objects
                DisposeManaged();

                RollbackInternal(false);
            }
            // release unmanaged objects

            this.localTransaction = null;
            if (IntPtr.Zero != this.iunknown) {
                // create a new UnsafeNativeMethods.ITransactionLocal from IntPtr
                // to avoid using existing managed wrapper on the com object
                try {
                    object local = Marshal.GetObjectForIUnknown(this.iunknown);
                    UnsafeNativeMethods.ITransactionLocal transaction = (UnsafeNativeMethods.ITransactionLocal) local;
                    transaction.Abort(0, 0, 0);
                    Marshal.Release(this.iunknown);
                }
                catch(Exception) {
                }
                this.iunknown = IntPtr.Zero;
            }
        }

        private void DisposeManaged() {
            if (null != this.parentTransaction) {
                this.parentTransaction.weakTransaction = null;
                this.parentTransaction = null;
            }
            else if (null != this.parentConnection) { // MDAC 67287
                this.parentConnection.weakTransaction = null;
            }
            this.parentConnection = null;
        }

        private void ProcessResults(int hr) {
            Exception e = OleDbConnection.ProcessResults(hr, this.parentConnection, this);
            if (null != e) { throw e; }
        }

        /// <include file='doc\OleDbTransaction.uex' path='docs/doc[@for="OleDbTransaction.Rollback"]/*' />
        public void Rollback() {
            if (null == this.localTransaction) {
                throw ADP.TransactionZombied(this);
            }
            parentConnection.CheckStateOpen(ADP.RollbackTransaction);
            DisposeManaged();
            try {
                RollbackInternal(true); // no recover if this throws an exception
            }
            finally {
                GC.KeepAlive(this);
                GC.SuppressFinalize(this);
            }
        }

        private int RollbackInternal(bool exceptionHandling) {
            int hr = 0;
            if (null != this.localTransaction) {
                Marshal.Release(this.iunknown);
                this.iunknown = IntPtr.Zero;

                // there is no recovery if Rollback throws an exception
                UnsafeNativeMethods.ITransactionLocal local = this.localTransaction;
                this.localTransaction = null;

                if (null != this.weakTransaction) {
                    OleDbTransaction transaction = (OleDbTransaction) this.weakTransaction.Target;
                    if ((null != transaction) && this.weakTransaction.IsAlive) {
                        hr = transaction.RollbackInternal(exceptionHandling);
                        GC.KeepAlive(transaction);
                        GC.SuppressFinalize(transaction);
                        if (hr < 0) {
                            SafeNativeMethods.ClearErrorInfo();
                            return hr;
                        }
                    }
                    this.weakTransaction = null;
                }
#if DEBUG
                if (AdapterSwitches.OleDbTrace.TraceInfo) {
                    ODB.Trace_Begin("ITransactionLocal", "Abort");
                }
#endif
                hr = local.Abort(0, 0, 0);

#if DEBUG
                if (AdapterSwitches.OleDbTrace.TraceInfo) {
                    ODB.Trace_End("ITransactionLocal", "Abort", hr);
                }
#endif
                if (hr < 0) {
                    if (exceptionHandling) {
                        ProcessResults(hr);
                    }
                    else {
                        SafeNativeMethods.ClearErrorInfo();
                    }
                }
            }
            return hr;
        }

        static internal OleDbTransaction TransactionLast(OleDbTransaction head) {
            if (null != head.weakTransaction) {
                OleDbTransaction current = (OleDbTransaction) head.weakTransaction.Target;
                if ((null != current) && head.weakTransaction.IsAlive) {
                    return TransactionLast(current);
                }
            }
            return head;
        }

        static internal OleDbTransaction TransactionUpdate(OleDbTransaction transaction) {
            if ((null != transaction) && (null == transaction.localTransaction)) {
                return null;
            }
            return transaction;
        }

        static internal OleDbTransaction TransactionZombie(OleDbTransaction transaction) {
            while ((null != transaction) && (null == transaction.Connection)) {
                transaction = transaction.parentTransaction;
            }
            return transaction;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType"]/*' />
    public enum OleDbType {

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.BigInt"]/*' />
        BigInt = 20,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Binary"]/*' />
        Binary = 128,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Boolean"]/*' />
        Boolean = 11,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.BSTR"]/*' />
        BSTR = 8,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Char"]/*' />
        Char = 129,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Currency"]/*' />
        Currency = 6,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Date"]/*' />
        Date = 7,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.DBDate"]/*' />
        DBDate = 133,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.DBTime"]/*' />
        DBTime = 134,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.DBTimeStamp"]/*' />
        DBTimeStamp = 135,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Decimal"]/*' />
        Decimal = 14,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Double"]/*' />
        Double = 5,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Empty"]/*' />
        Empty = 0,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Error"]/*' />
        Error = 10,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Filetime"]/*' />
        Filetime = 64,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Guid"]/*' />
        Guid = 72,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.IDispatch"]/*' />
        IDispatch = 9,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Integer"]/*' />
        Integer = 3,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.IUnknown"]/*' />
        IUnknown = 13,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.LongVarBinary"]/*' />
        LongVarBinary = 205,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.LongVarChar"]/*' />
        LongVarChar = 201,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.LongVarWChar"]/*' />
        LongVarWChar = 203,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Numeric"]/*' />
        Numeric = 131,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.PropVariant"]/*' />
        PropVariant = 138,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Single"]/*' />
        Single = 4,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.SmallInt"]/*' />
        SmallInt = 2,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.TinyInt"]/*' />
        TinyInt = 16,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.UnsignedBigInt"]/*' />
        UnsignedBigInt = 21,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.UnsignedInt"]/*' />
        UnsignedInt = 19,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.UnsignedSmallInt"]/*' />
        UnsignedSmallInt = 18,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.UnsignedTinyInt"]/*' />
        UnsignedTinyInt = 17,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.VarBinary"]/*' />
        VarBinary = 204,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.VarChar"]/*' />
        VarChar = 200,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.Variant"]/*' />
        Variant = 12,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.VarNumeric"]/*' />
        VarNumeric = 139,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.VarWChar"]/*' />
        VarWChar = 202,

        /// <include file='doc\OleDbType.uex' path='docs/doc[@for="OleDbType.WChar"]/*' />
        WChar = 130,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledbschemaguid.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDbSchemaGuid.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;

    /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid"]/*' />
    sealed public class OleDbSchemaGuid { // MDAC 61846

        // MDAC 2.0

        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Tables_Info"]/*' />
        static public readonly Guid Tables_Info                 = new Guid(0xc8b522e0,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        // MDAC 2.1

        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Trustee"]/*' />
        static public readonly Guid Trustee                     = new Guid(0xc8b522ef,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Assertions"]/*' />
        static public readonly Guid Assertions                  = new Guid(0xc8b52210,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Catalogs"]/*' />
        static public readonly Guid Catalogs                    = new Guid(0xc8b52211,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Character_Sets"]/*' />
        static public readonly Guid Character_Sets              = new Guid(0xc8b52212,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Collations"]/*' />
        static public readonly Guid Collations                  = new Guid(0xc8b52213,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Columns"]/*' />
        static public readonly Guid Columns                     = new Guid(0xc8b52214,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Check_Constraints"]/*' />
        static public readonly Guid Check_Constraints           = new Guid(0xc8b52215,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Constraint_Column_Usage"]/*' />
        static public readonly Guid Constraint_Column_Usage     = new Guid(0xc8b52216,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Constraint_Table_Usage"]/*' />
        static public readonly Guid Constraint_Table_Usage      = new Guid(0xc8b52217,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Key_Column_Usage"]/*' />
        static public readonly Guid Key_Column_Usage            = new Guid(0xc8b52218,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Referential_Constraints"]/*' />
        static public readonly Guid Referential_Constraints     = new Guid(0xc8b52219,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Table_Constraints"]/*' />
        static public readonly Guid Table_Constraints           = new Guid(0xc8b5221a,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Column_Domain_Usage"]/*' />
        static public readonly Guid Column_Domain_Usage         = new Guid(0xc8b5221b,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Indexes"]/*' />
        static public readonly Guid Indexes                     = new Guid(0xc8b5221e,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Column_Privileges"]/*' />
        static public readonly Guid Column_Privileges           = new Guid(0xc8b52221,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Table_Privileges"]/*' />
        static publi