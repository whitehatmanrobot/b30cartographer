ACKDOOR              0x01000000
#define DEBUG_ALLOC                 0x02000000
#define DEBUG_PERF                  0x04000000
#define DEBUG_TRACE                 0x08000000

#define DEBUG_API                   0x10000000
#define DEBUG_OPTIONS               0x20000000
#define DEBUG_BREAK_POINT           0x40000000
#define DEBUG_TRACE_CALLS           0x80000000

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\place.inc ===
#
#  Places all of the internet binaries into the inetsrv tree
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\rockall\library\unique.hpp ===
#ifndef _UNIQUE_HPP_
#define _UNIQUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Hash.hpp"
#include "List.hpp"
#include "Pool.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control how unique strings         */
    /*   are constructed.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinDetails				  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> class UNIQUE;

    /********************************************************************/
    /*                                                                  */
    /*   A string description.                                          */
    /*                                                                  */
    /*   All unique strings have a string drescription which is         */
    /*   into either the active or free list.                           */
    /*                                                                  */
    /********************************************************************/

class DETAIL : public LIST
	{
	private:
		//
		//   Friend classes.
		//
		friend class				  UNIQUE<NO_LOCK>;
		friend class				  UNIQUE<PARTIAL_LOCK>;
		friend class				  UNIQUE<FULL_LOCK>;

		//
		//   Private data.
		//
		BOOLEAN						  Active;
		SBIT32						  Size;
		CHAR						  *Text;
		SBIT32						  Uses;
	};

    /********************************************************************/
    /*                                                                  */
    /*   A unique string.                                               */
    /*                                                                  */
    /*   Almost all the other classes in the library offer valuable     */
    /*   free-standing functionality.  However, this class is really    */
    /*   just a support class for the variable length string class.     */
    /*                                                                  */
    /********************************************************************/

template <class LOCK=PARTIAL_LOCK> class UNIQUE : public HASH<SBIT32,POINTER>
    {
		//
		//   Private data.
		//
		LIST						  Active;
		LIST						  Free;

		DETAIL						  *Default;
		POOL<DETAIL>				  Details;
		LOCK						  Sharelock;

    public:
        //
        //   Public functions.
        //
        UNIQUE( VOID );

		DETAIL *CreateString( CHAR *String,SBIT32 Size );

		SBIT32 CompareStrings( DETAIL *Detail1,DETAIL *Detail2 );

		DETAIL *CopyString( DETAIL *Detail1,DETAIL *Detail2 );

		VOID DeleteString( DETAIL *Detail );

        ~UNIQUE( VOID );

		//
		//   Public inline functions.
		//
		INLINE DETAIL *DefaultString( VOID )
			{ return Default; }

		INLINE SBIT32 Size( DETAIL *Detail )
			{ return Detail -> Size; }

		INLINE CHAR *Value( DETAIL *Detail )
			{ return Detail -> Text; }

	private:
		//
		//   Private functions.
		//
		VIRTUAL SBIT32 ComputeHashKey
			( 
			CONST SBIT32			  & Key 
			);

		VIRTUAL BOOLEAN MatchingKeys
			( 
			CONST SBIT32			  & Key1,
			CONST SBIT32			  & Key2 
			);

        //
        //   Disabled operations.
        //
        UNIQUE( CONST UNIQUE & Copy );

        VOID operator=( CONST UNIQUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new unique string table.  This call is not thread     */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::UNIQUE( VOID )
	{
	//
	//   Create the default string.
	//
	Default = CreateString( "",0 );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new unique string.                                    */
    /*                                                                  */
    /*   When we are handed a new string we need to find out whether    */
    /*   it is unique (and needs to be added to the table) or just a    */
    /*   duplicate of an existing string.                               */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CreateString
		( 
		CHAR						  *String,
		SBIT32						  Size 
		)
	{
	AUTO DETAIL *Detail1;
	AUTO DETAIL *Detail2;

	//
	//   Claim an exclusive lock (if enabled).
	//
    Sharelock.ClaimExclusiveLock();

	//
	//   Let us assume that the string is unique and
	//   build an entry to for it.  If we later find
	//   it is not then we just back out the changes.
	//
	if ( Free.EndOfList() )
		{
		REGISTER SBIT32 Count;

		//
		//   Create a several new string descriptions 
		//   and link them into the free list.
		//
		for ( Count=0;Count < MinDetails;Count ++ )
			{
			//
			//   Create a new description and add it 
			//   to the free list.
			//
			Detail1 = new DETAIL;

			Detail1 -> Active = False;

			Detail1 -> Insert( & Free );
			}
		}

	//
	//   We know that the free list must contain 
	//   least one element (if not we would have 
	//   just made some).  We extract the oldest
	//   here.
	//
	if ( (Detail1 = ((DETAIL*) Free.Last())) -> Active )
		{
		//
		//   Delete any existing value when we
		//   recycle an old and unused string
		//   description.  Remember to remove
		//   it from the hash before deleting
		//   the string as the hash uses the
		//   string.
		//
		RemoveFromHash( ((SBIT32) Detail1) );

		delete [] Detail1 -> Text;

		Detail1 -> Active = False;
		}

	//
	//   We now setup the string description for the 
	//   new string.
	//
	Detail1 -> Size = Size;
	Detail1 -> Text = String;
	Detail1 -> Uses = 1;

	//
	//   We are now ready to search the hash table for
	//   a matching string.  We do this by overloading
	//   the hash table key comparision (see later).
	//
	if ( ! FindInHash( ((SBIT32) Detail1),((POINTER*) & Detail2) ) )
		{
		//
		//   We have found a new string so we need to
		//   make the string description active and
		//   insert it in the active list.
		//
		(Detail2 = Detail1) -> Active = True;

		Detail1 -> Delete( & Free );
		Detail1 -> Insert( & Active );

		//
		//   Add the new unique string the the hash 
		//   table so we can find it later.
		//
		AddToHash( ((SBIT32) Detail1),((POINTER) Detail1) );

		//
		//   We know the string is unique so lets
		//   allocate some space for it and copy it 
		//   into the new area.
		//
		Detail1 -> Text = 
			(
			strncpy
				( 
				new CHAR [ (Size + 1) ],
				String,
				Size 
				)
			);

		Detail1 -> Text[ Size ] = '\0';
		}
	else
		{
		//
		//   Increment the use count for an existing
		//   string.
		//
		if ( Detail2 != Default )
			{ 
			//
			//   We may be lucky and find an unused
			//   string.  If so we need to add it to
			//   the active list again.
			//
			if ( (Detail2 -> Uses ++) == 0 )
				{
				//
				//   Add an unused string back to the 
				//   active list again.
				//
				Detail2 -> Delete( & Free );
				Detail2 -> Insert( & Active );
				}
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two strings.                                           */
    /*                                                                  */
    /*   Compare two strings and find the relationship between them.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::CompareStrings
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   We know that all strings are unique so if the
	//   string pointers match then they must be the 
	//   the same string.
	//
	if ( Detail1 != Detail2 )
		{
		REGISTER SBIT32 Result =
			(
			strncmp
				( 
				Detail1 -> Text,
				Detail2 -> Text,
				(Detail1 -> Size < Detail2 -> Size)
					? Detail1 -> Size
					: Detail2 -> Size
				)
			);

		//
		//   If the strings match pick the longest.
		//
		if ( Result == 0 )
			{ Result = ((Detail1 -> Size < Detail2 -> Size) ? -1 : 1); }

		return Result;
		}
	else
		{ return 0; }
	}
#if 0
    /********************************************************************/
    /*                                                                  */
    /*   Compute a hash key.                                            */
    /*                                                                  */
    /*   Compute a hash key for the supplied key.  This hash key        */
    /*   is used to select the hash chain to search.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::ComputeHashKey
		( 
		CONST SBIT32				  & Key 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER DETAIL *Detail = ((DETAIL*) Key);
	REGISTER SBIT32 HashKey = 2964557531;

	for ( Count=0;Count < Detail -> Size;Count ++ )
		{
		REGISTER SBIT32 Value = ((SBIT32) Detail -> Text[ Count ]);

		HashKey = ((HashKey * Value) + Value); 
		}

	return (HashKey & 0x3fffffff);
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Copy a string.                                                 */
    /*                                                                  */
    /*   All strings are unique so there is no need to copy a string.   */
    /*   Nonetheless, we still have to update the use counts.           */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CopyString
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for old string.
	//
	if ( Detail1 != Default )
		{ Detail1 -> Uses --; }

	//
	//   Increment the use count for new string.
	//
	if ( Detail2 != Default )
		{ Detail2 -> Uses ++; }

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}
#if 0
    /********************************************************************/
    /*                                                                  */
    /*   Compare two hash keys.                                         */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> BOOLEAN UNIQUE<LOCK>::MatchingKeys
		( 
		CONST SBIT32				  & Key1,
		CONST SBIT32				  & Key2 
		)
	{
	REGISTER DETAIL *Detail1 = ((DETAIL*) Key1);
	REGISTER DETAIL *Detail2 = ((DETAIL*) Key2);

	return
		(
		(Detail1 -> Size == Detail2 -> Size)
			&&
		(strncmp( Detail1 -> Text,Detail2 -> Text,Detail1 -> Size ) == 0)
		);
	}
#endif
    /********************************************************************/
    /*                                                                  */
    /*   Delete a string.                                               */
    /*                                                                  */
    /*   Delete a text string.                                          */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> VOID UNIQUE<LOCK>::DeleteString( DETAIL *Detail )
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for the string.
	//
	if ( Detail != Default )
		{
		//
		//   Decrement the use count and ensure that
		//   this is not the last use of the string.
		//
		if ( (-- Detail -> Uses) == 0 )
			{
			//
			//   When we delete the last use of
			//   a string we add it to the free 
			//   list.  The string can be reclaimed
			//   if it is recreated before it is
			//   deleted.
			//
			Detail -> Delete( & Active );
			Detail -> Insert( & Free );
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the unique string table.  This call is not thread      */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::~UNIQUE( VOID )
	{ 
	//
	//   Delete all active strings.
	//
	while ( ! Active.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Active.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Active );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SBIT32) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}

	//
	//   Delete all free strings.
	//
	while ( ! Free.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Free.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Free );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SBIT32) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\rockall\library\vector.hpp ===
#ifndef _VECTOR_HPP_
#define _VECTOR_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"
#ifdef DEBUGGING

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specified here control various aspects of the    */
    /*   vector classes debugging operations.                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DebugDisplaySize		  = 8;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Vector creation, management and use.                           */
    /*                                                                  */
    /*   A vector is esentially an allocated array of data.  However,   */
    /*   vectors also have some special features.  A vector can be      */
    /*   aligned to any binary boundary and each element can also be    */
    /*   aligned to any binary boundary.  This is very helpful in       */
    /*   SMP systems as increased performance can be obtained by        */
    /*   using vectors on selected data structures.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class VECTOR
    {
        //
        //   Private data.
        //
        SBIT32                        Alignment;
        SBIT32                        Elements;
        SBIT32                        Size;

        CHAR                          *Allocated;
        CHAR                          *Aligned;
#ifdef DEBUGGING
		TYPE                          *Display[DebugDisplaySize];
#endif


    public:
        //
        //   Public functions.
        //
        VECTOR
            ( 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  Two, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

        VOID Resize( SBIT32 Reallocate );

        ~VECTOR( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE & operator[]( SBIT32 Index )
			{
#ifdef DEBUGGING
			if ( (Index < 0) || (Index >= Elements) )
				{ Failure( "Array subscript in VECTOR[]" ); }

#endif
			return (*((TYPE*) & Aligned[ (Index * Size) ]));
			}

        INLINE TYPE *operator&( VOID )
			{ return ((TYPE*) & Aligned[0]); }

		SBIT32 SizeOfVector( VOID ) 
			{ return Elements; }

	private:
		//
		//   Private functions.
		//
        VOID AllocateAndAlignVector
            ( 
            SBIT32                        NumberOfElements, 
            SBIT32                        AlignSize, 
            SBIT32                        AlignStart
            );

		TYPE & ComputeAddressWithMultiply( SBIT32 Index );

		TYPE & ComputeAddressWithShift( SBIT32 Index );

        //
        //   Disabled operations.
        //
        VECTOR( CONST VECTOR & Copy );

        VOID operator=( CONST VECTOR & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        One,
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize,
        SBIT32                        AlignStart
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE( One ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        One, 
        SBIT32                        Two, 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE( One,Two ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Allocate and align a vector.                                   */
    /*                                                                  */
    /*   We need to allocate some memory and align it as requested      */
    /*   by the user.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::AllocateAndAlignVector
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
    if ( NumberOfElements > 0 )
        {
#ifdef DEBUGGING
		REGISTER SBIT32 Count;

#endif
        //
        //   We need to remember the initial alignment and count of
		//   elements for later.
        //   
        Alignment = AlignStart;
        Elements = NumberOfElements;

        //
        //   Calculate the new element size using the requested alignment
		//   value.
        //
		Size = (AlignSize - (sizeof(TYPE) % AlignSize));
		Size = (Size == AlignSize) ? 0 : Size;
		Size += sizeof(TYPE);

        //
        //   Allocate memory and call constructor for each element.
        //   Calculate the start address for requested alignment.
        //
        Allocated = new CHAR [ (AlignStart + (NumberOfElements * Size)) ];

		Aligned = (CHAR*) (AlignStart - (((LONG) Allocated) % AlignStart));
		Aligned = (((SBIT32) Aligned) == AlignStart) ? 0 : Aligned;
		Aligned += (LONG) Allocated;
#ifdef DEBUGGING

		//
		//   When we are in debug mode calculate the addresses
		//   of the first few elements of the vector.
		//
		for 
				( 
				Count = 0;
				(Count < NumberOfElements) && (Count < DebugDisplaySize);
				Count ++ 
				)
			{ Display[ Count ] = (TYPE*) & Aligned[ (Count * Size) ]; }
#endif
        }
    else
        { Failure( "Allocation size in AllocateAndAlignVector" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize a memory allocation.                                    */
    /*                                                                  */
    /*   Resize a memory allocation and initialize the resized area.    */
    /*   This call is not thread safe and should only be made in a      */
    /*   single thread environment.                                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::Resize( SBIT32 Reallocate )
    {
    if ( Reallocate > 0 )
        {
		REGISTER SBIT32 Count;
		REGISTER CHAR *NewAllocated = new CHAR [ (Alignment + (Reallocate * Size)) ];
		REGISTER CHAR *NewAligned = ((CHAR*) (((LONG) NewAllocated) % Alignment));
		REGISTER SBIT32 Minimum = (Elements < Reallocate) ? Elements : Reallocate;

		//
		//   Ensure we were able to allocate some memory.
		//
		if ( NewAllocated != NULL )
			{
			//
			//   Calculate the new aligned address
			//.
			NewAligned = (CHAR*) (Alignment - ((LONG) NewAligned));
			NewAligned = (((SBIT32) NewAligned) == Alignment) ? 0 : NewAligned;
			NewAligned += (LONG) NewAllocated;

			//
			//   Copy each existing element into the new allocation.
			//
			for ( Count = 0;Count < Minimum;Count ++ )
				{ 
				REGISTER SBIT32 Offset = (Count * Size);

				(*((TYPE*) & NewAligned[ Offset ])) = 
					(*((TYPE*) & Aligned[ Offset ])); 
				}

			//
			//   Call the constructor for each new element.
			//
			for ( Count = Elements;Count < Reallocate;Count ++ )
				{ (VOID) PLACEMENT_NEW( & NewAligned[ (Count * Size) ], TYPE ); }

			//
			//   Call the destructor for each original original element.
			//
			for ( Count = (Elements - 1);Count >= 0;Count -- )
				{ PLACEMENT_DELETE( & Aligned[ (Count * Size) ], TYPE ); }

			//
			//   Delete the original allocation.
			//
			delete [] Allocated;
#ifdef DEBUGGING

			//
			//   When we are in debug mode calculate the addresses
			//   of the first few elements of the vector.
			//
			for 
					( 
					Count = 0;
					(Count < Reallocate) && (Count < DebugDisplaySize);
					Count ++ 
					)
			{ Display[ Count ] = (TYPE*) & NewAligned[ (Count * Size) ]; }
#endif
 
			//
			//   Finally, lets update the information about the new
			//   amended allocation.
			//   
			this -> Elements = Reallocate;
			this -> Allocated = NewAllocated;
			this -> Aligned = NewAligned;
			}
		else
			{ Failure( "No memory available in Resize" ); }
        }
    else
        { Failure( "Rellocation size in Resize" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a vector.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::~VECTOR( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Call the destructors.
	//
	for ( Count = (Elements - 1);Count >= 0;Count -- )
		{ PLACEMENT_DELETE( & Aligned[ (Count * Size) ], TYPE ); }

	//
	//   Delete the storage.
	//
    delete [] Allocated;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\wininet.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininet.inc

Abstract:

    Common makefile contents for wininet project

Author:

    Richard L Firth (rfirth) 10-Feb-1996

Revision History:

    10-Feb-1996 rfirth
        Created

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#

!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#

MAJORCOMP=wininet

USE_NOLIBS=1
NO_NTDLL=1
USE_MSVCRT=1

#
# compiler definitions
#

C_DEFINES=$(C_DEFINES) -D_WINX32_ -DTHREAD_POOL
#C_DEFINES=$(C_DEFINES) -D_WINX32_

# If we are building for X86 we use w95fiber.dll or NT kernel fibers.
!IF "$(PROCESSOR_ARCHITECTURE)"=="x86"
C_DEFINES=$(C_DEFINES) -DW95_FIBERS
!ENDIF

# Get same version from NT or IE builds.
C_DEFINES=$(C_DEFINES) -DNASHVILLE

!IFDEF USE_ICECAP
C_DEFINES=$(C_DEFINES) -DICECAP
!ENDIF

#
# Set debugging level
#

!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG -DINET_DEBUG=1

#
# remove maximal diagnostics for customer debug version based on environment
# variable
#

!IF "$(FULL_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_DEBUG_MEMORY
!ELSE
C_DEFINES=$(C_DEFINES) -DRETAIL_LOGGING
!IF "$(BUILD_PRODUCT)" != "IE"
C_DEFINES=$(C_DEFINES) -DDISABLE_ASSERTS
!ENDIF
!ENDIF

!ELSE IF "$(ALMOSTRETAIL)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG
!ENDIF


#
# performance diagnostics
#

!IF "$(PERF_BUILD)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_PERF_DIAG
!ENDIF

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

#
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#

MSC_WARNING_LEVEL=/W3 /WX

#
# precompiled header options
#

!IFNDEF WININET_PCH

PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\wininetp.pch /Yuwininetp.h
PRECOMPILED_CXX=1

!ENDIF

!IF $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!ENDIF

CONDITIONAL_INCLUDES = \
        winwlm.h \
        macwin32.h \
        ia64inst.h \
        pshpck16.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpub.h \
        macapi.h \
        macname2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\dhcpcli.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcli.h

Abstract:

    This file is the central include file for the DHCP client service.

Author:

    Manny Weiser  (mannyw)  20-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _DHCPCLI_H_
#define _DHCPCLI_H_

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef VXD
#define WIN32_LEAN_AND_MEAN         // Don't include extraneous headers
#endif

#include <windows.h>                // (spec. winsock.h)
#include <winsock.h>

//
//  DHCP public header files
//

#include <dhcp.h>
#include <dhcplib.h>
#if !defined(VXD)
#include <dhcpcapi.h>
#endif

//
// C Runtime Lib.
//

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

//
//  Local header files
//

#include <dhcpdef.h>
#include <debug.h>
#include <gmacros.h>

#ifdef VXD
#include <vxdmsg.h>
#else
#include <dhcpmsg.h>
#endif

#if     defined(_PNP_POWER_)
#include <ipexport.h>
#ifndef VXD
#include <ntddip.h>
#endif
#endif _PNP_POWER_

#include <proto.h>


#ifdef VXD
#include <vxdprocs.h>
#endif


//
// debug heap
//
#include <heapx.h>

#ifndef VXD
#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Client will use debug heap ***" )

#define DhcpAllocateMemory(x) ALLOCATE_MEMORY(LPTR,x)
#define DhcpFreeMemory(x)     FREE_MEMORY(x)

#endif
#endif
#endif

#ifdef CHICAGO
#define _WINNT_
#include <vmm.h>
#endif  // CHICAGO
//
// Macros for pageable code.
//
#define CTEMakePageable( _Page, _Routine )  \
    alloc_text(_Page,_Routine)

#ifdef CHICAGO
#define ALLOC_PRAGMA
#undef  INIT
#define INIT _ITEXT
#undef  PAGE
#define PAGE _PTEXT
#define PAGEDHCP _PTEXT
#endif // CHICAGO

#if     defined(CHICAGO) && defined(DEBUG)
//
// This is asserts when the pageable code is called at inappropriate time.
// Since in reality all our pageable code is dynamically locked, there is no
// need for this.
//
//#define CTEPagedCode() _Debug_Flags_Service(DFS_TEST_REENTER+DFS_TEST_BLOCK)
#define CTEPagedCode()
#else
#define CTEPagedCode()
#endif

#include <options.h>
#include <optreg.h>
#include <stack.h>

#endif //_DHCPCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\apdetect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apdetect.cxx

Abstract:

    This is the overall generic wrappers and entry code to the 
      auto-proxy, auto-detection code, that sends DHCP informs,
      and mundges through DNS to find an URL for proxy configuration

Author:

    Arthur Bierer (arthurbi)  15-Jul-1998

Environment:

    User Mode - Win32

Revision History:

    Arthur Bierer (arthurbi)  15-Jul-1998
        Created

    Josh Cohen (joshco)     7-oct-1998
        added proxydetecttype
        
--*/

#include <wininetp.h>
#include "aproxp.h"

#include "apdetect.h"

// this isnt the most efficient thing
//  should probably move this to autoprox class...
//    
     
DWORD
WINAPI
GetProxyDetectType(VOID) 
{
    static DWORD _adType = PROXY_AUTO_DETECT_TYPE_DEFAULT;
    static DWORD UseCached = 0;

    if (! UseCached ) 
    {
        InternetReadRegistryDword("AutoProxyDetectType",
                              (LPDWORD)&(_adType)
                              );

        if (_adType & PROXY_AUTO_DETECT_CACHE_ME ) 
        {
             UseCached = 1;
        }

    }
    return _adType;
}
  
STDAPI_(BOOL)
DetectAutoProxyUrl(
    IN OUT LPSTR lpszAutoProxyUrl,
    IN DWORD dwAutoProxyUrlLength,
    IN DWORD dwDetectFlags
    )
{
    BOOL fRet = FALSE;
    DWORD error;

    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "DetectAutoProxyUrl",
                 "%x, %u",
                 lpszAutoProxyUrl,
                 dwAutoProxyUrlLength                 
                 ));

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {            
            goto quit;
        }
    }

    error = LoadWinsock();

    if ( error != ERROR_SUCCESS ) {
        goto quit;
    }

    {
        CIpConfig Interfaces;
        if ( (GetProxyDetectType() & PROXY_AUTO_DETECT_TYPE_DHCP) & dwDetectFlags ) {

            //Interfaces.GetAdapterInfo();       
            if ( Interfaces.DoInformsOnEachInterface(lpszAutoProxyUrl, dwAutoProxyUrlLength) )
            {
                //printf("success on DHCP search: got %s\n", szAutoProxyUrl);
                fRet = TRUE;
                goto quit;
            }
        }
        if ( (GetProxyDetectType() & PROXY_AUTO_DETECT_TYPE_DNS_A) & dwDetectFlags ) {
    
            if ( QueryWellKnownDnsName(lpszAutoProxyUrl, dwAutoProxyUrlLength) == ERROR_SUCCESS)
            {
                //printf("success on well qualified name search: got %s\n", szAutoProxyUrl);
                fRet = TRUE;
                goto quit;
            }
        }
    }

quit:

    DEBUG_LEAVE(fRet);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\dhcpdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpdef.h

Abstract:

    This module contains data type definitions for the DHCP client.

Author:

    Madan Appiah (madana) 31-Oct-1993

Environment:

    User Mode - Win32

Revision History:

--*/
//
// init.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifndef _DHCPDEF_
#define _DHCPDEF_

#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// the registry key is of different type between NT and Memphis.
//
#ifdef VXD
typedef VMMHKEY   DHCPKEY;
#else  //  NT
typedef HKEY      DHCPKEY;
#endif


#ifndef VXD
#define RUNNING_IN_RAS_CONTEXT()     (!DhcpGlobalIsService)
#else
#define RUNNING_IN_RAS_CONTEXT()     FALSE
#endif


//
// The amount of time to wait for a retry if we have no IP address
//

#define ADDRESS_ALLOCATION_RETRY        300 //  5 minutes
#define EASYNET_ALLOCATION_RETRY        300 //  5 minutes

//
// The amount of time to wait for a retry if we have an IP address,
// but the renewal on startup failed.
//

#if !DBG
#define RENEWAL_RETRY                   600 // 10 minutes
#else
#define RENEWAL_RETRY                   60  // 1 minute
#endif

//
// The number of times to send a request before giving up waiting
// for a response.
//

#define DHCP_MAX_RETRIES                4
#define DHCP_ACCEPT_RETRIES             2
#define DHCP_MAX_RENEW_RETRIES          2


//
// amount of time required between consequtive send_informs..
//

#define DHCP_DEFAULT_INFORM_SEPARATION_INTERVAL   60 // one minute

//
// amount of time to wait after an address conflict is detected
//

#define ADDRESS_CONFLICT_RETRY          10 // 10 seconds

//
//
// Expoenential backoff delay.
//

#define DHCP_EXPO_DELAY                  4

//
// The maximum total amount of time to spend trying to obtain an
// initial address.
//
// This delay is computed as below:
//
// DHCP_MAX_RETRIES - n
// DHCP_EXPO_DELAY - m
// WAIT_FOR_RESPONSE_TIME - w
// MAX_STARTUP_DELAY - t
//
// Binary Exponential backup Algorithm.
//
// t > m * (n*(n+1)/2) + n + w*n
//     -------------------   ---
//        random wait      + response wait
//

#define MAX_STARTUP_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RETRIES * (DHCP_MAX_RETRIES + 1)) / 2) + \
            DHCP_MAX_RETRIES + DHCP_MAX_RETRIES * WAIT_FOR_RESPONSE_TIME

#define MAX_RENEW_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RENEW_RETRIES * (DHCP_MAX_RENEW_RETRIES + 1)) / 2) + \
            DHCP_MAX_RENEW_RETRIES + DHCP_MAX_RENEW_RETRIES * \
                WAIT_FOR_RESPONSE_TIME

//
// The maximum amount of time to wait between renewal retries, if the
// lease period is between T1 and T2.
//

#define MAX_RETRY_TIME                  3600    // 1 hour

//
// Minimum time to sleep between retries.
//

#if DBG
#define MIN_SLEEP_TIME                  1 * 60      // 1 min.
#else
#define MIN_SLEEP_TIME                  5 * 60      // 5 min.
#endif

//
// Minimum lease time.
//

#define DHCP_MINIMUM_LEASE              60*60   // 24 hours.

#ifdef __DHCP_DYNDNS_ENABLED__

#define DHCP_DNS_TTL                    0       // let the DNS api decide..

#endif


//
// IP Autoconfiguration defaults
//

#define DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET  "169.254.0.0"
#define DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK    "255.255.0.0"

// define the reserved range of autonet addresses..

#define DHCP_RESERVED_AUTOCFG_SUBNET             "169.254.255.0"
#define DHCP_RESERVED_AUTOCFG_MASK               "255.255.255.0"

// will dhcp pick any reserved autonet addr? NO!
#define DHCP_RESERVED_AUTOCFG_FLAG                (1)

// self default route (0,0,<self>) will have a metric of (3)
#define DHCP_SELF_DEFAULT_METRIC                  (3)

//
// General purpose macros
//

#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
#define MAX(a,b)                        ((a) > (b) ? (a) : (b))

#if DBG
#define STATIC
#else
#define STATIC static
#endif

/*#define LOCK_RENEW_LIST()       EnterCriticalSection(&DhcpGlobalRenewListCritSect)
#define UNLOCK_RENEW_LIST()     LeaveCriticalSection(&DhcpGlobalRenewListCritSect)

#define LOCK_INTERFACE()        EnterCriticalSection(&DhcpGlobalSetInterfaceCritSect)
#define UNLOCK_INTERFACE()      LeaveCriticalSection(&DhcpGlobalSetInterfaceCritSect)

#define LOCK_OPTIONS_LIST()     EnterCriticalSection(&DhcpGlobalOptionsListCritSect)
#define UNLOCK_OPTIONS_LIST()   LeaveCriticalSection(&DhcpGlobalOptionsListCritSect)
*/
#define LOCK_RENEW_LIST()       
#define UNLOCK_RENEW_LIST()     

#define LOCK_INTERFACE()        
#define UNLOCK_INTERFACE()      

#define LOCK_OPTIONS_LIST()     
#define UNLOCK_OPTIONS_LIST()   


#define ZERO_TIME                       0x0         // in secs.

//
// length of the time string returned by ctime.
// actually it is 26.
//

#define TIME_STRING_LEN                 32

//
// String size when a long converted to printable string.
// 2^32 = 4294967295 (10 digits) + termination char.
//

#define LONG_STRING_SIZE                12

//
// A renewal function.
//

typedef
DWORD
(*PRENEWAL_FUNCTION) (
    IN PVOID Context,
    LPDWORD Sleep
    );

//
// DHCP Client-Identifier (option 61)
//
typedef struct _DHCP_CLIENT_IDENTIFIER
{
    BYTE  *pbID;
    DWORD  cbID;
    BYTE   bType;
    BOOL   fSpecified;
} DHCP_CLIENT_IDENTIFIER;


//
// state information for IP autoconfiguration
//

typedef struct _DHCP_IPAUTOCONFIGURATION_CONTEXT
{
    DHCP_IP_ADDRESS   Address;
    DHCP_IP_ADDRESS   Subnet;
    DHCP_IP_ADDRESS   Mask;
    DWORD             Seed;
} DHCP_IPAUTOCONFIGURATION_CONTEXT;

//
// A DHCP context block.  One block is maintained per NIC (network
// interface Card).
//

typedef struct _DHCP_CONTEXT {

        // list of adapters.
    //LIST_ENTRY NicListEntry;

        // hardware type.
    BYTE HardwareAddressType;
        // HW address, just follows this context structure.
    LPBYTE HardwareAddress;
        // Length of HW address.
    DWORD HardwareAddressLength;

        // Selected IpAddress, NetworkOrder.
    DHCP_IP_ADDRESS IpAddress;
        // Selected subnet mask. NetworkOrder.
    //DHCP_IP_ADDRESS SubnetMask;
        // Selected DHCP server address. Network Order.
    DHCP_IP_ADDRESS DhcpServerAddress;
        // Desired IpAddress the client request in next discover.
    //DHCP_IP_ADDRESS DesiredIpAddress;
        // The ip address that was used just before losing this..
    //DHCP_IP_ADDRESS LastKnownGoodAddress; // ONLY DNS uses this..
        // the domain name that was used with last registration..
    //WCHAR LastUsedDomainName[257]; // dns domain name is atmost 255 bytes.
        // current domain name for this adapter.
    //BYTE  DomainName[257];

        // IP Autoconfiguration state
    //DHCP_IPAUTOCONFIGURATION_CONTEXT IPAutoconfigurationContext;

    DHCP_CLIENT_IDENTIFIER ClientIdentifier;

        // Lease time in seconds.
    //DWORD Lease;
        // Time the lease was obtained.
    //time_t LeaseObtained;
        // Time the client should start renew its address.
    //time_t T1Time;
        // Time the client should start broadcast to renew address.
    time_t T2Time;
        // Time the lease expires. The clinet should stop using the
        // IpAddress.
        // LeaseObtained  < T1Time < T2Time < LeaseExpires
    //time_t LeaseExpires;
        // when was the last time an inform was sent?
    time_t LastInformSent;
        // how many seconds between consecutive informs?
    //DWORD  InformSeparationInterval;
        // # of gateways and the currently plumbed gateways are stored here
    //DWORD  nGateways;
    //DHCP_IP_ADDRESS *GatewayAddresses;

        // # of static routes and the actual static routes are stored here
    //DWORD  nStaticRoutes;
    //DHCP_IP_ADDRESS *StaticRouteAddresses;

        // to place in renewal list.
    //LIST_ENTRY RenewalListEntry;
        // Time for next renewal state.
    //time_t RunTime;

        // seconds passed since boot.
    DWORD SecondsSinceBoot;

        // should we ping the g/w or always assume g/w is NOT present?
    //BOOL  DontPingGatewayFlag;

        // can we use DHCP_INFORM packets or should we use DHCP_REQUEST instead?
    //BOOL  UseInformFlag;

    //WORD  ClientPort;

        // what to function at next renewal state.
    //PRENEWAL_FUNCTION RenewalFunction;

    	// A semaphore for synchronization to this structure
    //HANDLE RenewHandle;

        // the list of options to send and the list of options received
    LIST_ENTRY  SendOptionsList;
    LIST_ENTRY  RecdOptionsList;

        // the opened key to the adapter info storage location
    //DHCPKEY AdapterInfoKey;

        // the class this adapter belongs to
    LPBYTE ClassId;
    DWORD  ClassIdLength;

        // Message buffer to send and receive DHCP message.
    PDHCP_MESSAGE MessageBuffer;

        // state information for this interface. see below for manifests
    struct /* anonymous */ {
        unsigned Plumbed       : 1 ;    // is this interface plumbed
        unsigned ServerReached : 1 ;    // Did we reach the server ever
        unsigned AutonetEnabled: 1 ;    // Autonet enabled?
        unsigned HasBeenLooked : 1 ;    // Has this context been looked at?
        unsigned DhcpEnabled   : 1 ;    // Is this context dhcp enabled?
        unsigned AutoMode      : 1 ;    // Currently in autonet mode?
        unsigned MediaState    : 2 ;    // One of connected, disconnected, reconnected
        unsigned MDhcp         : 1 ;    // Is this context created for Mdhcp?
        unsigned PowerResumed  : 1 ;    // Was power just resumed on this interface?
        unsigned Broadcast     : 1 ;
    }   State;

	    // machine specific information
    //PVOID LocalInformation;
     
//    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    LPTSTR AdapterName;
//    LPWSTR DeviceName;
//    LPWSTR NetBTDeviceName;
//    LPWSTR RegistryKey;
    SOCKET Socket;
    DWORD  IpInterfaceContext;
//    BOOL DefaultGatewaysSet;

    CHAR szMessageBuffer[DHCP_MESSAGE_SIZE];
} DHCP_CONTEXT, *PDHCP_CONTEXT;

#define ADDRESS_PLUMBED(Ctxt)        ((Ctxt)->State.Plumbed = 1)
#define ADDRESS_UNPLUMBED(Ctxt)      ((Ctxt)->State.Plumbed = 0)
#define IS_ADDRESS_PLUMBED(Ctxt)     ((Ctxt)->State.Plumbed)
#define IS_ADDRESS_UNPLUMBED(Ctxt)   (!(Ctxt)->State.Plumbed)

#define CONNECTION_BROADCAST(Ctxt)        ((Ctxt)->State.Broadcast = 1)
#define CONNECTION_NO_BROADCAST(Ctxt)      ((Ctxt)->State.Broadcast = 0)
#define IS_CONNECTION_BROADCAST(Ctxt)     ((Ctxt)->State.Broadcast)
#define IS_CONNECTION_NOBROADCAST(Ctxt)   (!(Ctxt)->State.Broadcast)

#define SERVER_REACHED(Ctxt)         ((Ctxt)->State.ServerReached = 1)
#define SERVER_UNREACHED(Ctxt)       ((Ctxt)->State.ServerReached = 0)
#define IS_SERVER_REACHABLE(Ctxt)    ((Ctxt)->State.ServerReached)
#define IS_SERVER_UNREACHABLE(Ctxt)  (!(Ctxt)->State.ServerReached)

#define AUTONET_ENABLED(Ctxt)        ((Ctxt)->State.AutonetEnabled = 1)
#define AUTONET_DISABLED(Ctxt)       ((Ctxt)->State.AutonetEnabled = 0)
#define IS_AUTONET_ENABLED(Ctxt)     ((Ctxt)->State.AutonetEnabled)
#define IS_AUTONET_DISABLED(Ctxt)    (!(Ctxt)->State.AutonetEnabled)

#define CTXT_WAS_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked = 1)
#define CTXT_WAS_NOT_LOOKED(Ctxt)    ((Ctxt)->State.HasBeenLooked = 0)
#define WAS_CTXT_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked)
#define WAS_CTXT_NOT_LOOKED(Ctxt)    (!(Ctxt)->State.HasBeenLooked)

#define DHCP_ENABLED(Ctxt)           ((Ctxt)->State.DhcpEnabled = 1)
#define DHCP_DISABLED(Ctxt)          ((Ctxt)->State.DhcpEnabled = 0)
#define IS_DHCP_ENABLED(Ctxt)        ((Ctxt)->State.DhcpEnabled )
#define IS_DHCP_DISABLED(Ctxt)       (!(Ctxt)->State.DhcpEnabled )

#define ADDRESS_TYPE_AUTO            1
#define ADDRESS_TYPE_DHCP            0

#define ACQUIRED_DHCP_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 0 )
#define ACQUIRED_AUTO_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 1 )
#define IS_ADDRESS_DHCP(Ctxt)        (!(Ctxt)->State.AutoMode)
#define IS_ADDRESS_AUTO(Ctxt)        ((Ctxt)->State.AutoMode)

#define MEDIA_CONNECTED(Ctxt)        ((Ctxt)->State.MediaState = 0)
#define MEDIA_RECONNECTED(Ctxt)      ((Ctxt)->State.MediaState = 1)
#define MEDIA_DISCONNECTED(Ctxt)     ((Ctxt)->State.MediaState = 2)
#define IS_MEDIA_CONNECTED(Ctxt)     ((Ctxt)->State.MediaState == 0)
#define IS_MEDIA_RECONNECTED(Ctxt)   ((Ctxt)->State.MediaState == 1)
#define IS_MEDIA_DISCONNECTED(Ctxt)  ((Ctxt)->State.MediaState == 2)

#define _INIT_STATE1(Ctxt)           do{(Ctxt)->State.Plumbed = 0; (Ctxt)->State.AutonetEnabled=0;}while(0)
#define _INIT_STATE2(Ctxt)           do{(Ctxt)->State.HasBeenLooked = 0; (Ctxt)->State.DhcpEnabled=1;}while(0)
#define _INIT_STATE3(Ctxt)           do{(Ctxt)->State.AutoMode = 0; (Ctxt)->State.MediaState = 0;}while(0)
#define INIT_STATE(Ctxt)             do{_INIT_STATE1(Ctxt);_INIT_STATE2(Ctxt);_INIT_STATE3(Ctxt);}while(0)

#define MDHCP_CTX(Ctxt)           ((Ctxt)->State.MDhcp = 1)
#define NONMDHCP_CTX(Ctxt)          ((Ctxt)->State.MDhcp = 0)
#define IS_MDHCP_CTX(Ctxt)        ((Ctxt)->State.MDhcp )
#define SET_MDHCP_STATE( Ctxt ) { \
    ADDRESS_PLUMBED( Ctxt ), MDHCP_CTX( Ctxt ); \
}

#define POWER_RESUMED(Ctxt)           ((Ctxt)->State.PowerResumed = 1)
#define POWER_NOT_RESUMED(Ctxt)       ((Ctxt)->State.PowerResumed = 0)
#define IS_POWER_RESUMED(Ctxt)        ((Ctxt)->State.PowerResumed )


/*LPSTR _inline                        //  the string'ed version of state (same as Buffer)
ConvertStateToString(                //  convert from bits to string
    IN PDHCP_CONTEXT   Ctxt,         //  The context to print state for
    IN LPBYTE          Buffer        //  The input buffer to write state into
) {
    strcpy(Buffer, IS_DHCP_ENABLED(Ctxt)?"DhcpEnabled ":"DhcpDisabled ");
    strcat(Buffer, IS_AUTONET_ENABLED(Ctxt)?"AutonetEnabled ":"AutonetDisabled ");
    strcat(Buffer, IS_ADDRESS_DHCP(Ctxt)?"DhcpMode ":"AutoMode ");
    strcat(Buffer, IS_ADDRESS_PLUMBED(Ctxt)?"Plumbed ":"UnPlumbed ");
    strcat(Buffer, IS_SERVER_REACHABLE(Ctxt)?"(server-present) ":"(server-absent) ");
    strcat(Buffer, WAS_CTXT_LOOKED(Ctxt)? "(seen) ":"(not-seen) ");

    if(IS_MEDIA_CONNECTED(Ctxt) ) strcat(Buffer, "MediaConnected\n");
    else if(IS_MEDIA_RECONNECTED(Ctxt)) strcat(Buffer, "MediaReConnected\n");
    else if(IS_MEDIA_DISCONNECTED(Ctxt)) strcat(Buffer, "MediaDisConnected\n");
    else strcat(Buffer, "MediaUnknownState\n");

    strcat(Buffer, IS_MDHCP_CTX(Ctxt)? "(MDhcp) ":"");
    strcat(Buffer, IS_POWER_RESUMED(Ctxt)? "Pwr Resumed ":"");

    return Buffer;
}
*/

//
// The types of machines.. laptop would have aggressive EASYNET behaviour.
//

#define MACHINE_NONE   0
#define MACHINE_LAPTOP 1

//
//  Here is the set of expected options by the client -- If they are absent, not much can be done
//

typedef struct _DHCP_EXPECTED_OPTIONS {
    BYTE            UNALIGNED*     MessageType;
    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    // Wpad Auto-Proxy Url
    BYTE            UNALIGNED*     WpadUrl;
    DWORD                          WpadUrlSize;
} DHCP_EXPECTED_OPTIONS, *PDHCP_EXPECTED_OPTIONS, *LPDHCP_EXPECTED_OPTIONS;

//
//  Here is the set of options understood by the client
//
typedef struct _DHCP_FULL_OPTIONS {
    BYTE            UNALIGNED*     MessageType;   // What kind of message is this?

    // Basic IP Parameters

    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     T1Time;
    DHCP_IP_ADDRESS UNALIGNED*     T2Time;
    DHCP_IP_ADDRESS UNALIGNED*     GatewayAddresses;
    DWORD                          nGateways;
    DHCP_IP_ADDRESS UNALIGNED*     StaticRouteAddresses;
    DWORD                          nStaticRoutes;

    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;

    // DNS parameters

    BYTE            UNALIGNED*     DnsFlags;
    BYTE            UNALIGNED*     DnsRcode1;
    BYTE            UNALIGNED*     DnsRcode2;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    DHCP_IP_ADDRESS UNALIGNED*     DnsServerList;
    DWORD                          nDnsServers;

    // Multicast options.
    DWORD           UNALIGNED*     MCastLeaseStartTime;
    BYTE            UNALIGNED     *MCastTTL;

    // Server message is something that the server may inform us of

    BYTE            UNALIGNED*     ServerMessage;
    DWORD                          ServerMessageLength;

    // Wpad Auto-Proxy Url
    BYTE            UNALIGNED*     WpadUrl;
    DWORD                          WpadUrlSize;

} DHCP_FULL_OPTIONS, *PDHCP_FULL_OPTIONS, *LPDHCP_FULL_OPTIONS;

typedef DHCP_FULL_OPTIONS DHCP_OPTIONS, *PDHCP_OPTIONS;

//
// structure for a list of messages
//

typedef struct _MSG_LIST {
    LIST_ENTRY     MessageListEntry;
    DWORD          ServerIdentifier;
    DWORD          MessageSize;
    DWORD          LeaseExpirationTime;
    DHCP_MESSAGE   Message;
} MSGLIST, *PMSGLIST, *LPMSGLIST;


//
// DHCP Global data.
//

extern BOOL DhcpGlobalServiceRunning;   // initialized global.

EXTERN LPSTR DhcpGlobalHostName;
EXTERN LPWSTR DhcpGlobalHostNameW;
EXTERN LPSTR DhcpGlobalHostComment;

//
// NIC List.
//

EXTERN LIST_ENTRY DhcpGlobalNICList;
EXTERN LIST_ENTRY DhcpGlobalRenewList;

//
// Synchronization variables.
//

EXTERN CRITICAL_SECTION DhcpGlobalRenewListCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalSetInterfaceCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalOptionsListCritSect;
EXTERN HANDLE DhcpGlobalRecomputeTimerEvent;
EXTERN HANDLE DhcpGlobalResumePowerEvent;

// waitable timer
EXTERN HANDLE DhcpGlobalWaitableTimerHandle;

//
// to display success message.
//

EXTERN BOOL DhcpGlobalProtocolFailed;

//
// This varible tells if we are going to provide the DynDns api support to external clients
// and if we are going to use the corresponding DnsApi.  The define below gives the default
// value.
//

EXTERN DWORD UseMHAsyncDns;
#define DEFAULT_USEMHASYNCDNS             1

//
// This flag tells if we need to use inform or request packets
//
EXTERN DWORD DhcpGlobalUseInformFlag;

//
// This flag tells if pinging the g/w is disabled. (in this case the g/w is always NOT present)
//
EXTERN DWORD DhcpGlobalDontPingGatewayFlag;

//
// The # of seconds before retrying according to AUTONET... default is EASYNET_ALLOCATION_RETRY
//

EXTERN DWORD AutonetRetriesSeconds;

//
// Not used on NT.  Just here for memphis.
//

EXTERN DWORD DhcpGlobalMachineType;

//
// Do we need to do a global refresh?
//

EXTERN ULONG DhcpGlobalDoRefresh;


//
// options related lists
//

EXTERN LIST_ENTRY DhcpGlobalClassesList;
EXTERN LIST_ENTRY DhcpGlobalOptionDefList;


//
// dhcpmsg.c.. list for doing parallel recv on..
//

EXTERN LIST_ENTRY DhcpGlobalRecvFromList;
EXTERN CRITICAL_SECTION DhcpGlobalRecvFromCritSect;

//
// the client vendor name ( "MSFT 5.0" or something like that )
//

EXTERN LPSTR   DhcpGlobalClientClassInfo;

//
// The following global keys are used to avoid re-opening each time
//
EXTERN DHCPKEY DhcpGlobalParametersKey;
EXTERN DHCPKEY DhcpGlobalTcpipParametersKey;
EXTERN DHCPKEY DhcpGlobalClientOptionKey;
EXTERN DHCPKEY DhcpGlobalServicesKey;

//
// debug variables.
//

#if DBG
EXTERN DWORD DhcpGlobalDebugFlag;
#endif

#endif // _DHCPDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\dhcp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    This module defines the DHCP server service definitions and structures.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Revision History:

    Madan Appiah (madana) 10-Oct-1993

--*/

#ifndef _DHCP_
#define _DHCP_

#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// update dhcpapi.h also if you modify the following three typedefs.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH        0
#define DHCP_DATE_TIME_ZERO_LOW         0

#define DHCP_DATE_TIME_INFINIT_HIGH     0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW      0xFFFFFFFF

#define DOT_IP_ADDR_SIZE                16          // XXX.XXX.XXX.XXX + '\0'
#define NO_DHCP_IP_ADDRESS              ((DHCP_IP_ADDRESS)-1)
#define DHCP_IP_KEY_LEN                 32          //arbitary size.

#define INFINIT_TIME                    0x7FFFFFFF  // time_t is int
#define INFINIT_LEASE                   0xFFFFFFFF  // in secs. (unsigned int.)
#define MDHCP_SERVER_IP_ADDRESS         0x0100efef // 239.239.0.1
//
// hardware types.
//
#define HARDWARE_TYPE_NONE              0 // used for non-hardware type client id
#define HARDWARE_TYPE_10MB_EITHERNET    1
#define HARDWARE_TYPE_IEEE_802          6
#define HARDWARE_ARCNET                 7
#define HARDWARE_PPP                    8

//
// Client-server protoocol reserved ports
//

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67

//
// DHCP BROADCAST flag.
//

#define DHCP_BROADCAST      0x8000
#define DHCP_NO_BROADCAST   0x0000

// MDHCP flag
#define DHCP_MBIT           0x4000
#define IS_MDHCP_MESSAGE( _msg ) ( _I_ntohs((_msg)->Reserved) & DHCP_MBIT ? TRUE : FALSE )
#define MDHCP_MESSAGE( _msg ) ( (_msg)->Reserved |= htons(DHCP_MBIT) )

#define CLASSD_NET_ADDR(a)  ( (a & 0xf0) == 0xe0)
#define CLASSD_HOST_ADDR(a)  ((a & 0xf0000000) == 0xe0000000)

#define DHCP_MESSAGE_SIZE       576
#define DHCP_SEND_MESSAGE_SIZE  548
#define BOOTP_MESSAGE_SIZE      300 // the options field for bootp is 64 bytes.

//
// The amount of time to wait for a DHCP response after a request
// has been sent.
//

#if !DBG
#define WAIT_FOR_RESPONSE_TIME          5
#else
#define WAIT_FOR_RESPONSE_TIME          10
#endif

//
// DHCP Operations
//

#define BOOT_REQUEST   1
#define BOOT_REPLY     2

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67

//
//  user class id
//
#define OPTION_USER_CLASS               77

//
//  Dynamic DNS Stuff.  Tells if we should do both A+PTR updates?
//
#define OPTION_DYNDNS_BOTH              81

// Multicast options.
#define OPTION_MCAST_SCOPE_ID           101
#define OPTION_MCAST_LEASE_START        102
#define OPTION_MCAST_TTL                103
#define OPTION_CLIENT_PORT              105
#define OPTION_MCAST_SCOPE_LIST         107

// special option to extend options
#define     OPTION_LARGE_OPTION    127

#define OPTION_WPAD_URL                 252 

#define OPTION_END                      255

// default mcast_ttl value.
#define DEFAULT_MCAST_TTL               32

//
// Different option values for the DYNDNS_BOTH option ...
//

#define DYNDNS_REGISTER_AT_CLIENT       0     // Client will do both registrations
#define DYNDNS_REGISTER_AT_SERVER       1     // Server will do registrations
#define DYNDNS_DOWNLEVEL_CLIENT         3     // arbitraty # diff from above

//
// Microsoft-specific options
//
#define OPTION_MSFT_DSDOMAINNAME_REQ    94    // send me your DS Domain name
#define OPTION_MSFT_DSDOMAINNAME_RESP   95    // sending my DS Domain name
#define OPTION_MSFT_CONTINUED           250   // the previous option is being continued..

//
// DHCP Message types
//

#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_OFFER_MESSAGE     2
#define DHCP_REQUEST_MESSAGE   3
#define DHCP_DECLINE_MESSAGE   4
#define DHCP_ACK_MESSAGE       5
#define DHCP_NACK_MESSAGE      6
#define DHCP_RELEASE_MESSAGE   7
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// DHCP APP names - used to indentify to the eventlogger.
//

#define DHCP_EVENT_CLIENT     TEXT("Dhcp")
#define DHCP_EVENT_SERVER     TEXT("DhcpServer")


typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;

//
// A DHCP message buffer
//


#pragma pack(1)         /* Assume byte packing */
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    DHCP_IP_ADDRESS ClientIpAddress;
    DHCP_IP_ADDRESS YourIpAddress;
    DHCP_IP_ADDRESS BootstrapServerAddress;
    DHCP_IP_ADDRESS RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;
#pragma pack()

#define DHCP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(DHCP_MESSAGE) - sizeof(OPTION))

#define DHCP_MIN_SEND_RECV_PK_SIZE \
            (DHCP_MESSAGE_FIXED_PART_SIZE + 64)

//
// JET - DHCP database constants.
//

#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page

#if DBG

//
// debug functions.
//

#ifdef CHICAGO // No Tracing available on CHICAGO
#define DhcpPrintTrace
#endif

//#define IF_DEBUG(flag) if (DhcpGlobalDebugFlag & (DEBUG_ ## flag))
#define DhcpPrint(_x_) DEBUG_PRINT(UTIL,INFO,_x_)
#define Trace          DhcpPrintTrace

#ifndef CHICAGO
VOID
DhcpPrintTrace(
    IN LPSTR Format,
    ...
    );

#endif

#if DBG

/*
VOID
//extern "C"
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    //DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}
*/
#endif // DBG


#else

//#define IF_DEBUG(flag) if (FALSE)
#define DhcpPrint(_x_)
#define Trace       (void)

#endif // DBG

#define OpenDriver     DhcpOpenDriver

#endif // _DHCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
        ulong           ipsi_forwarding;
        ulong           ipsi_defaultttl;
        ulong           ipsi_inreceives;
        ulong           ipsi_inhdrerrors;
        ulong           ipsi_inaddrerrors;
        ulong           ipsi_forwdatagrams;
        ulong           ipsi_inunknownprotos;
        ulong           ipsi_indiscards;
        ulong           ipsi_indelivers;
        ulong           ipsi_outrequests;
        ulong           ipsi_routingdiscards;
        ulong           ipsi_outdiscards;
        ulong           ipsi_outnoroutes;
        ulong           ipsi_reasmtimeout;
        ulong           ipsi_reasmreqds;
        ulong           ipsi_reasmoks;
        ulong           ipsi_reasmfails;
        ulong           ipsi_fragoks;
        ulong           ipsi_fragfails;
        ulong           ipsi_fragcreates;
        ulong           ipsi_numif;
        ulong           ipsi_numaddr;
        ulong           ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
        ulong           icmps_msgs;
        ulong           icmps_errors;
        ulong           icmps_destunreachs;
        ulong           icmps_timeexcds;
        ulong           icmps_parmprobs;
        ulong           icmps_srcquenchs;
        ulong           icmps_redirects;
        ulong           icmps_echos;
        ulong           icmps_echoreps;
        ulong           icmps_timestamps;
        ulong           icmps_timestampreps;
        ulong           icmps_addrmasks;
        ulong           icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
        ICMPStats       icsi_instats;
        ICMPStats       icsi_outstats;
} ICMPSNMPInfo;

#define IP_FORWARDING           1
#define IP_NOT_FORWARDING       2

typedef struct IPAddrEntry {
        ulong           iae_addr;
        ulong           iae_index;
        ulong           iae_mask;
        ulong           iae_bcastaddr;
        ulong           iae_reasmsize;
        ushort          iae_context;
        ushort          iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
        ulong           ire_context;
} IPRouteEntry;

typedef struct IPRouteEntry95 {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
} IPRouteEntry95;

typedef struct AddrXlatInfo {
        ulong           axi_count;
        ulong           axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                                 1
#define ICMP_MIB_STATS_ID                               1

#define AT_MIB_ADDRXLAT_INFO_ID                 1
#define AT_MIB_ADDRXLAT_ENTRY_ID                0x101

#define IP_MIB_RTTABLE_ENTRY_ID                 0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID               0x102

#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\dhcploc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    local.h

Abstract:

    This module contains various declarations for implementation
    specific "stuff".

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _LOCAL_
#define _LOCAL_

//
// dhcp.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#define DAY_LONG_SLEEP                          24*60*60    // in secs.
#define INVALID_INTERFACE_CONTEXT               0xFFFF

#define DHCP_NEW_IPADDRESS_EVENT_NAME   TEXT("DHCPNEWIPADDRESS"

//
// Registry keys and values we're interested in.
//

#define DHCP_SERVICES_KEY                       TEXT("System\\CurrentControlSet\\Services")

#define DHCP_ADAPTERS_KEY                       TEXT("System\\CurrentControlSet\\Services\\TCPIP\\Linkage")
#define DHCP_ADAPTERS_VALUE                     TEXT("Bind")
#define DHCP_ADAPTERS_VALUE_TYPE                REG_MULTI_SZ
#define DHCP_ADAPTERS_DEVICE_STRING             TEXT("\\Device\\")
#define DHCP_TCPIP_DEVICE_STRING                TEXT("\\Device\\TCPIP_")
#if     defined(_PNP_POWER_)
#define DHCP_NETBT_DEVICE_STRING                TEXT("NetBT_TCPIP_")
#else
#define DHCP_NETBT_DEVICE_STRING                TEXT("NetBT_")
#endif _PNP_POWER_

#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE         TEXT("EnableDynDNS")
#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE_TYPE    REG_DWORD

#ifdef DYNDNS_DNS_OVERRIDE_ENABLED

#define DHCP_CLIENT_DYNDNS_DNS_OVERRIDE_VALUE   TEXT("DynDNSServer")
#define DHCP_CLIENT_DYNDNS_DNS_OVERRIDE_VALUE_TYPE REG_DWORD

#endif

#define DHCP_CLIENT_PARAMETER_KEY               TEXT("System\\CurrentControlSet\\Services\\Dhcp\\Parameters")

#if DBG
#define DHCP_DEBUG_FLAG_VALUE                   TEXT("DebugFlag")
#define DHCP_DEBUG_FLAG_VALUE_TYPE              REG_DWORD
#endif

#define DHCP_CLIENT_OPTION_KEY                  TEXT("System\\CurrentControlSet\\Services\\Dhcp\\Parameters\\Options")

#define DHCP_CLIENT_GLOBAL_CLASSES_KEY          TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Classes")
#define DHCP_CLIENT_CLASS_VALUE                 TEXT("DhcpMachineClass")

#if     defined(_PNP_POWER_)
#define DHCP_ADAPTER_PARAMETERS_KEY             TEXT("\\TCPIP\\Parameters\\Interfaces")
#else
#define DHCP_ADAPTER_PARAMETERS_KEY             TEXT("\\Parameters\\TCPIP")
#endif _PNP_POWER_

#define DHCP_DEFAULT_GATEWAY_PARAMETER          TEXT("DefaultGateway")
#define DHCP_DONT_ADD_DEFAULT_GATEWAY_FLAG      TEXT("DontAddDefaultGateway")
#define DHCP_DONT_PING_GATEWAY_FLAG             TEXT("DontPingGateway")
#define DHCP_USE_MHASYNCDNS_FLAG                TEXT("UseMHAsyncDns")
#define DHCP_USE_INFORM_FLAG                    TEXT("UseInform")
#define DHCP_INFORM_SEPARATION_INTERVAL         TEXT("DhcpInformInterval")

#define DHCP_TCPIP_PARAMETERS_KEY               DHCP_SERVICES_KEY TEXT("\\TCPIP\\Parameters")
#define DHCP_TCPIP_ADAPTER_PARAMETERS_KEY       NULL
#define DHCP_NAME_SERVER_VALUE                  TEXT("NameServer")
#define DHCP_IPADDRESS_VALUE                    TEXT("IPAddress")
#define DHCP_HOSTNAME_VALUE                     TEXT("Hostname")
#define DHCP_DOMAINNAME_VALUE                   TEXT("Domain")
#define DHCP_STATIC_DOMAIN_VALUE_A              "Domain"

#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__

#define DHCP_CLIENT_OPTION_SIZE                 TEXT("OptionSize")
#define DHCP_CLIENT_OPTION_SIZE_TYPE            REG_DWORD
#define DHCP_CLIENT_OPTION_VALUE                TEXT("OptionValue")
#define DHCP_CLIENT_OPTION_VALUE_TYPE           REG_BINARY

#endif

#define REGISTRY_CONNECT                        L'\\'
#define REGISTRY_CONNECT_STRING                 TEXT("\\")

#define DHCP_CLIENT_OPTION_REG_LOCATION         TEXT("RegLocation")
#define DHCP_CLIENT_OPTION_REG_LOCATION_TYPE    REG_SZ

#define DHCP_CLIENT_OPTION_REG_KEY_TYPE         TEXT("KeyType")
#define DHCP_CLIENT_OPTION_REG_KEY_TYPE_TYPE    REG_DWORD

#define DHCP_CLASS_LOCATION_VALUE               TEXT("DhcpClientClassLocation")
#define DHCP_CLASS_LOCATION_TYPE                REG_MULTI_SZ

#define DEFAULT_USER_CLASS_LOCATION             TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpClassIdBin")
#define DEFAULT_USER_CLASS_LOC_FULL             DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_LOCATION

#define DEFAULT_USER_CLASS_UI_LOCATION          TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpClassId")
#define DEFAULT_USER_CLASS_UI_LOC_FULL          DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_UI_LOCATION

// ******** Don;t chagne regloc for below.. it also affects DHCP_REGISTER_OPTION_LOC below
#define DEFAULT_REGISTER_OPT_LOC            TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpRequestOptions")

#define DHCP_OPTION_LIST_VALUE                  TEXT("DhcpOptionLocationList")
#define DHCP_OPTION_LIST_TYPE                   REG_MULTI_SZ

#define NETBIOSLESS_OPT                         TEXT("DhcpNetbiosLessOption\0")
#define DEFAULT_DHCP_KEYS_LIST_VALUE            (L"1\0" L"15\0" L"3\0" L"44\0" L"46\0" L"47\0" L"6\0" NETBIOSLESS_OPT)

#define DHCP_OPTION_OPTIONID_VALUE              TEXT("OptionId")
#define DHCP_OPTION_OPTIONID_TYPE               REG_DWORD

#define DHCP_OPTION_ISVENDOR_VALUE              TEXT("VendorType")
#define DHCP_OPTION_ISVENDOR_TYPE               REG_DWORD

#define DHCP_OPTION_SAVE_TYPE_VALUE             TEXT("KeyType")
#define DHCP_OPTION_SAVE_TYPE_TYPE              REG_DWORD

#define DHCP_OPTION_CLASSID_VALUE               TEXT("ClassId")
#define DHCP_OPTION_CLASSID_TYPE                REG_BINARY

#define DHCP_OPTION_SAVE_LOCATION_VALUE         TEXT("RegLocation")
#define DHCP_OPTION_SAVE_LOCATION_TYPE          REG_MULTI_SZ

#define DHCP_OPTION_SEND_LOCATION_VALUE         TEXT("RegSendLocation")
#define DHCP_OPTION_SEND_LOCATION_TYPE          REG_MULTI_SZ



#define DHCP_ENABLE_STRING                      TEXT("EnableDhcp")
#define DHCP_ENABLE_STRING_TYPE                 REG_DWORD

#define DHCP_IP_ADDRESS_STRING                  TEXT("DhcpIPAddress")
#define DHCP_IP_ADDRESS_STRING_TYPE             REG_SZ

#define DHCP_SUBNET_MASK_STRING                 TEXT("DhcpSubnetMask")
#define DHCP_SUBNET_MASK_STRING_TYPE            REG_SZ

#define DHCP_SERVER                             TEXT("DhcpServer")
#define DHCP_SERVER_TYPE                        REG_SZ

#define DHCP_LEASE                              TEXT("Lease")
#define DHCP_LEASE_TYPE                         REG_DWORD

#define DHCP_LEASE_OBTAINED_TIME                TEXT("LeaseObtainedTime")
#define DHCP_LEASE_OBTAINED_TIME_TYPE           REG_DWORD

#define DHCP_LEASE_T1_TIME                      TEXT("T1")
#define DHCP_LEASE_T1_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_T2_TIME                      TEXT("T2")
#define DHCP_LEASE_T2_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_TERMINATED_TIME              TEXT("LeaseTerminatesTime")
#define DHCP_LEASE_TERMINATED_TIME_TYPE         REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT               TEXT("IpInterfaceContext")
#define DHCP_IP_INTERFACE_CONTEXT_TYPE          REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT_MAX           TEXT("IpInterfaceContextMax")
#define DHCP_IP_INTERFACE_CONTEXT_MAX_TYPE      REG_DWORD

#if     defined(_PNP_POWER_)
#define DHCP_NTE_CONTEXT_LIST                   TEXT("NTEContextList")
#define DHCP_NTE_CONTEXT_LIST_TYPE              REG_MULTI_SZ
#endif _PNP_POWER_

#define DHCP_CLIENT_IDENTIFIER_FORMAT           TEXT("DhcpClientIdentifierType")
#define DHCP_CLIENT_IDENTIFIER_FORMAT_TYPE      REG_DWORD

#define DHCP_CLIENT_IDENTIFIER_VALUE            TEXT("DhcpClientIdentifier")

#define DHCP_DYNDNS_UPDATE_REQUIRED             TEXT("DNSUpdateRequired")
#define DHCP_DYNDNS_UPDATE_REQUIRED_TYPE        REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ENABLED        TEXT("IPAutoconfigurationEnabled")
#define DHCP_IPAUTOCONFIGURATION_ENABLED_TYPE   REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ADDRESS        TEXT("IPAutoconfigurationAddress")
#define DHCP_IPAUTOCONFIGURATION_ADDRESS_TYPE   REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SUBNET         TEXT("IPAutoconfigurationSubnet")
#define DHCP_IPAUTOCONFIGURATION_SUBNET_TYPE    REG_SZ

#define DHCP_IPAUTOCONFIGURATION_MASK           TEXT("IPAutoconfigurationMask")
#define DHCP_IPAUTOCONFIGURATION_MASK_TYPE      REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SEED           TEXT("IPAutoconfigurationSeed")
#define DHCP_IPAUTOCONFIGURATION_SEED_TYPE      REG_DWORD

#define DHCP_OPTION_EXPIRATION_DATE             TEXT("ExpirationTime")
#define DHCP_OPTION_EXPIRATION_DATE_TYPE        REG_BINARY

#define DHCP_MACHINE_TYPE                       TEXT("MachineType")
#define DHCP_MACHINE_TYPE_TYPE                  REG_DWORD

#define DHCP_AUTONET_RETRIES_VALUE              TEXT("AutonetRetries")
#define DHCP_AUTONET_RETRIES_VALUE_TYPE         REG_DWORD

#define DHCP_ADDRESS_TYPE_VALUE                 TEXT("AddressType")
#define DHCP_ADDRESS_TYPE_TYPE                  REG_DWORD

#if DBG

#define DHCP_LEASE_OBTAINED_CTIME               TEXT("LeaseObtainedCTime"
#define DHCP_LEASE_OBTAINED_CTIME_TYPE          REG_SZ

#define DHCP_LEASE_T1_CTIME                     TEXT("T1CTime")
#define DHCP_LEASE_T1_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_T2_CTIME                     TEXT("T2CTime")
#define DHCP_LEASE_T2_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_TERMINATED_CTIME             TEXT("LeaseTerminatesCTime")
#define DHCP_LEASE_TERMINATED_CTIME_TYPE        REG_SZ

#define DHCP_OPTION_EXPIRATION_CDATE            TEXT("ExpirationCTime")
#define DHCP_OPTION_EXPIRATION_CDATE_TYPE       REG_SZ


#endif

// options api specials
#define DHCPAPI_VALID_VALUE                     TEXT("Valid")
#define DHCPAPI_VALID_VALUE_TYPE                REG_DWORD

#define DHCPAPI_AVAIL_VALUE                     TEXT("AvailableOptions")
#define DHCPAPI_AVAIL_VALUE_TYPE                REG_BINARY

#define DHCPAPI_REQUESTED_VALUE                 TEXT("RequestedOptions")
#define DHCPAPI_REQUESTED_VALUE_TYPE            REG_BINARY

#define DHCPAPI_RAW_OPTIONS_VALUE               TEXT("RawOptionsValue")
#define DHCPAPI_RAW_OPTIONS_VALUE_TYPE          REG_BINARY

#define DHCPAPI_RAW_LENGTH_VALUE                TEXT("RawOptionsLength")
#define DHCPAPI_RAW_LENGTH_VALUE_TYPE           REG_DWORD

#define DHCPAPI_GATEWAY_VALUE                   TEXT("LastGateWay")
#define DHCPAPI_GATEWAY_VALUE_TYPE              REG_DWORD

// this tag is used to locate dns updates requests on the renewal list
#define DHCP_DNS_UPDATE_CONTEXT_TAG             TEXT("DNSUpdateRetry")

// This semaphore cannot have backward slashes in it.
#define DHCP_REQUEST_OPTIONS_API_SEMAPHORE      TEXT("DhcpRequestOptionsAPI")

// the client vendor name (DhcpGlobalClientClassInfo) value is this..
#define DHCP_DEFAULT_CLIENT_CLASS_INFO          "MSFT 5.0"

// the location for storing options for DhcpRegisterOptions API.
// ****** Don't change the foll value -- it also changes DEFAULT_REGISTER_OPT_LOC above
//
#define DHCP_REGISTER_OPTIONS_LOC               DHCP_TCPIP_PARAMETERS_KEY L"\\Interfaces\\?\\DhcpRequestOptions"

//
// size of the largest adapter name in unicode.
//
#define ADAPTER_STRING_SIZE 512

//
// windows version info.
//

#define HOST_COMMENT_LENGTH                     128
#define WINDOWS_32S                             "Win32s on Windows 3.1"
#define WINDOWS_NT                              "Windows NT"

#define DHCP_NAMESERVER_BACKUP                  TEXT("Backup")
#define DHCP_NAMESERVER_BACKUP_LIST             TEXT("BackupList")

//
// Adapter Key - replacement character.
//
#define OPTION_REPLACE_CHAR                     L'\?'

//
// registry access key.
//

#define DHCP_CLIENT_KEY_ACCESS  (KEY_QUERY_VALUE |           \
                                    KEY_SET_VALUE |          \
                                    KEY_CREATE_SUB_KEY |     \
                                    KEY_ENUMERATE_SUB_KEYS)

//
// Dhcp registry class.
//

#define DHCP_CLASS                      TEXT("DhcpClientClass")
#define DHCP_CLASS_SIZE                 sizeof(DHCP_CLASS)


//
// Option ID key length.
//

#define DHCP_OPTION_KEY_LEN             32

//
// The name of the DHCP service DLL
//

#define DHCP_SERVICE_DLL                TEXT("dhcpcsvc.dll")

//
// command values for SetDefaultGateway function.

#define DEFAULT_GATEWAY_ADD             0
#define DEFAULT_GATEWAY_DELETE          1


//
// A block NT specific context information, appended the the DHCP work
// context block.
//

typedef struct _LOCAL_CONTEXT_INFO {
    DWORD  IpInterfaceContext;
    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    LPWSTR AdapterName;
#if     !defined(_PNP_POWER_)
    LPWSTR DeviceName;
#endif _PNP_POWER_
    LPWSTR NetBTDeviceName;
    LPWSTR RegistryKey;
    SOCKET Socket;
    BOOL DefaultGatewaysSet;
} LOCAL_CONTEXT_INFO, *PLOCAL_CONTEXT_INFO;

//
// Other service specific options info struct.
//

typedef struct _SERVICE_SPECIFIC_DHCP_OPTION {
    DHCP_OPTION_ID OptionId;
    LPWSTR RegKey;              // alloted memory.
    LPWSTR ValueName;           // embedded in the RegKey memory.
    DWORD ValueType;
    DWORD OptionLength;
#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__
    time_t ExpirationDate; // this value is used to decide when to stop
                           // requested unneeded options.
#endif
    LPBYTE RawOptionValue;
} SERVICE_SPECIFIC_DHCP_OPTION, *LPSERVICE_SPECIFIC_DHCP_OPTION;


//
// Key query Info.
//

typedef struct _DHCP_KEY_QUERY_INFO {
    WCHAR Class[DHCP_CLASS_SIZE];
    DWORD ClassSize;
    DWORD NumSubKeys;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD NumValues;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptorLen;
    FILETIME LastWriteTime;
} DHCP_KEY_QUERY_INFO, *LPDHCP_KEY_QUERY_INFO;

//
// Global variables.
//

//
// client specific option list.
//


EXTERN HINSTANCE DhcpGlobalMessageFileHandle;

EXTERN DWORD DhcpGlobalOptionCount;
EXTERN LPSERVICE_SPECIFIC_DHCP_OPTION DhcpGlobalOptionInfo;
EXTERN LPBYTE DhcpGlobalOptionList;

//
// Service variables
//

EXTERN SERVICE_STATUS DhcpGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE DhcpGlobalServiceStatusHandle;

//
// To signal to stop the service.
//

EXTERN HANDLE DhcpGlobalTerminateEvent;

//
// multi home flag.
//

EXTERN BOOL DhcpGlobalMultiHomedHost;

//
// Client APIs over name pipe variables.
//

EXTERN HANDLE DhcpGlobalClientApiPipe;
EXTERN HANDLE DhcpGlobalClientApiPipeEvent;
EXTERN OVERLAPPED DhcpGlobalClientApiOverLapBuffer;

//
// Message Popup Thread handle.
//

EXTERN HANDLE DhcpGlobalMsgPopupThreadHandle;
EXTERN BOOL DhcpGlobalDisplayPopup;
EXTERN CRITICAL_SECTION DhcpGlobalPopupCritSect;

#define LOCK_POPUP()   EnterCriticalSection(&DhcpGlobalPopupCritSect)
#define UNLOCK_POPUP() LeaveCriticalSection(&DhcpGlobalPopupCritSect)


//
// winsock variables.
//

EXTERN WSADATA DhcpGlobalWsaData;
EXTERN BOOL DhcpGlobalWinSockInitialized;

EXTERN BOOL DhcpGlobalGatewaysSet;

EXTERN BOOL DhcpGlobalIsService;

//
// a named event that notifies the ip address changes to
// external apps.
//

EXTERN HANDLE DhcpGlobalNewIpAddressNotifyEvent;
EXTERN UINT   DhcpGlobalIPEventSeqNo;


#endif // _LOCAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\ntddtcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _NTDDTCP_
#define _NTDDTCP_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"


//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif  // ifndef _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\optchg.h ===
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: handles the noticiations and other mechanisms for parameter
//      changes (options )
//================================================================================

#ifndef OPTCHG_H_INCLUDED
#define OPTCHG_H_INCLUDED

//================================================================================
// exported APIS
//================================================================================
DWORD                                             // win32 status
DhcpAddParamChangeRequest(                        // add a new param change notification request
    IN      LPWSTR                 AdapterName,   // for this adapter, can be NULL
    IN      LPBYTE                 ClassId,       // what class id does this belong to?
    IN      DWORD                  ClassIdLength, // how big is this class id?
    IN      LPBYTE                 OptList,       // this is the list of options of interest
    IN      DWORD                  OptListSize,   // this is the # of bytes of above
    IN      BOOL                   IsVendor,      // is this vendor specific?
    IN      DWORD                  ProcId,        // which is the calling process?
    IN      DWORD                  Descriptor,    // what is the unique descriptor in this process?
    IN      HANDLE                 Handle         // what is the handle in the calling process space?
);

DWORD                                             // win32 status
DhcpDelParamChangeRequest(                        // delete a particular request
    IN      DWORD                  ProcId,        // the process id of the caller
    IN      HANDLE                 Handle         // the handle as used by the calling process
);

DWORD                                             // win32 status
DhcpMarkParamChangeRequests(                      // find all params that are affected and mark then as pending
    IN      LPTSTR                 AdapterName,   // adapter of relevance
    IN      BYTE                   OptionId,      // the option id itself
    IN      BOOL                   IsVendor,      // is this vendor specific
    IN      LPBYTE                 ClassId        // which class --> this must be something that has been ADD-CLASSED
);

typedef DWORD (*DHCP_NOTIFY_FUNC)(                // this is the type of the fucntion that actually notifies clients of option change
    IN      DWORD                  ProcId,        // <ProcId + Descriptor> make a unique key used for finding the event
    IN      DWORD                  Descriptor     // --- on Win98, only Descriptor is really needed.
);                                                // if return value is NOT error success, we delete this request

DWORD                                             // win32 status
DhcpNotifyMarkedParamChangeRequests(              // notify pending param change requests
    IN      DHCP_NOTIFY_FUNC       NotifyHandler  // call this function for each unique id that is present
);


DWORD                                             // win32 status
DhcpNotifyClientOnParamChange(                    // notify clients
    IN      DWORD                  ProcId,        // which process called this
    IN      DWORD                  Descriptor     // unique descriptor for that process
);

DWORD                                             // win32 status
DhcpInitializeParamChangeRequests(                // initialize everything in this file
    VOID
);

VOID
DhcpCleanupParamChangeRequests(                   // unwind this module
    VOID
);

DWORD                                             // win32 status
DhcpAddParamRequestChangeRequestList(             // add to the request list the list of params registered for notifications
    IN      LPWSTR                 AdapterName,   // which adatper is this request list being requested for?
    IN      LPBYTE                 Buffer,        // buffer to add options to
    IN OUT  LPDWORD                Size,          // in: existing filled up size, out: total size filled up
    IN      LPBYTE                 ClassName,     // ClassId
    IN      DWORD                  ClassLen       // size of ClassId in bytes
);

#endif OPTCHG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\optreg.h ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------
#ifndef  OPTREG_H
#define  OPTREG_H
//--------------------------------------------------------------------------------
// Exported functions: Caller must take locks and any lists accessed
//--------------------------------------------------------------------------------

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);


POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
);


#endif OPTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\dhcplib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    This file contains proto type definitions for the dhcp lib
    functions.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef DHCPLIB_H_INCLUDED
#define DHCPLIB_H_INCLUDED


#define DhcpAllocateMemory(x) ALLOCATE_MEMORY(LPTR,(x))
#define DhcpFreeMemory(x)     FREE_MEMORY(x)


//
// network.c
//

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

//
// dhcp.c
//


/*PVOID
DhcpAllocateMemory(
    DWORD Size
    );

VOID
DhcpFreeMemory(
    PVOID Memory
    );*/


#if DBG

#ifndef DEBUG_ALLOC
#define DEBUG_ALLOC 0x02000000
#endif

/*
PVOID _inline
DhcpAllocateMemoryEx(
    DWORD Size,
    DWORD LineNo,
    LPSTR FileName
) {
    LPVOID Ptr = DhcpAllocateMemory(Size);

    DhcpPrint(("Allocate %010x %04x %04d %s\n", Ptr, Size, LineNo, FileName));
    return Ptr;
}

VOID _inline
DhcpFreeMemoryEx(
    LPVOID Ptr,
    DWORD  LineNo,
    LPSTR  FileName
) {
    DhcpFreeMemory(Ptr);
    DhcpPrint("Free %010x %04x %04d %s\n", Ptr, 0, LineNo, FileName));
} 
*/

//#define DhcpAllocateMemory(Sz)    DhcpAllocateMemoryEx(Sz, __LINE__, __FILE__)
//#define DhcpFreeMemory(Ptr)       DhcpFreeMemoryEx(Ptr, __LINE__, __FILE__)

#endif

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
    );

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    );

LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd

    );

LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    );

DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    );

DATE_TIME
DhcpGetDateTime(
    VOID
    );

DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    );

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    );

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime);


//
// convert.c
//

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN LPSTR Ansi,
    IN OUT LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    );

#if 0

VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD HexNumber
    );

VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    );

#endif

VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    );

#if 0

DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

#endif

LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    LPWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    );

#if 0 //DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage
    );

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    );

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    );


#endif DHCPLIB_H_INCLUDED

//------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\ipconfig.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ipconfig.cxx

Abstract:

    CIpConfig class implementation

    Contents:
        CIpAddress::GetAddress

        CIpAddressList::Find
        CIpAddressList::Add(CIpAddress *)
        CIpAddressList::Add(DWORD, DWORD, DWORD)
        CIpAddressList::GetAddress
        CIpAddressList::ThrowOutUnfoundEntries

        CAdapterInterface::CAdapterInterface
        CAdapterInterface::~CAdapterInterface

        CIpConfig::CIpConfig
        CIpConfig::~CIpConfig
        CIpConfig::GetRouterAddress
        CIpConfig::GetDnsAddress
        CIpConfig::IsKnownIpAddress
        CIpConfig::Refresh
        (CIpConfig::GetAdapterList)
        (CIpConfig::LoadEntryPoints)
        (CIpConfig::UnloadEntryPoints)
        (CIpConfig::FindOrCreateInterface)
        (CIpConfig::FindInterface)
        (CIpConfig::ThrowOutUnfoundEntries)

        WsControl
        (WinNtWsControl)
        (OpenTcpipDriverHandle)
        (CloseTcpipDriverHandle)
        (GetEntityList)
        [InternetMapEntity]
        [InternetMapInterface]

Author:

    Richard L Firth (rfirth) 29-Oct-1996

Environment:

    Win32 user-mode DLL

Notes:

    In order to operate correctly, we require the Microsoft Winsock implementation
    (WSOCK32.DLL) and the Microsoft TCP/IP stack to be loaded

Revision History:

    29-Oct-1996 rfirth
        Created

    15-Jul-1998 arthurbi
        Resurrected from the dead

--*/

#include <wininetp.h>
#include "aproxp.h"

//
// manifests
//

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arbitrary
//#define DEFAULT_MINIMUM_ENTITIES        MAX_TDI_ENTITIES

//
// macros
//

//
// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
//

#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == IF_TYPE_LOOPBACK))
#define IS_INTERESTING_ADAPTER_NT5(p) (!((p)->Type == IF_TYPE_RFC877_X25))

//
// globals
//

const char SERVICES_KEY_NAME[] = "SYSTEM\\CurrentControlSet\\Services";

HKEY TcpipLinkageKey = NULL;//     = INVALID_HANDLE_VALUE;
HKEY ServicesKey = NULL;  //       = INVALID_HANDLE_VALUE;

//
// private prototypes
//

PRIVATE
DWORD
WinNtWsControl(
    DWORD dwProtocol,
    DWORD dwRequest,
    LPVOID lpInputBuffer,
    LPDWORD lpdwInputBufferLength,
    LPVOID lpOutputBuffer,
    LPDWORD lpdwOutputBufferLength
    );

PRIVATE
DWORD
OpenTcpipDriverHandle(
    VOID
    );

PRIVATE
VOID
CloseTcpipDriverHandle(
    VOID
    );

PRIVATE
DWORD
GetEntityList(
    OUT TDIEntityID * * lplpEntities
    );

//
// private debug prototypes
//

PRIVATE
LPCSTR
InternetMapEntity(
    IN INT EntityId
    );

PRIVATE
LPCSTR
InternetMapInterface(
    IN DWORD InterfaceType
    );

PRIVATE
LPCSTR
InternetMapInterfaceOnNT5(
    IN DWORD InterfaceType
    );


//
// private data
//

//
// NTDLL info - if the platform is NT then we use the following entry points in
// NTDLL.DLL to talk to the TCP/IP device driver
//

PRIVATE VOID (* _I_RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR) = NULL;
PRIVATE NTSTATUS (* _I_NtCreateFile)(PHANDLE,
                                     ACCESS_MASK,
                                     POBJECT_ATTRIBUTES,
                                     PIO_STATUS_BLOCK,
                                     PLARGE_INTEGER,
                                     ULONG,
                                     ULONG,
                                     ULONG,
                                     ULONG,
                                     PVOID,
                                     ULONG
                                     ) = NULL;
PRIVATE ULONG (* _I_RtlNtStatusToDosError)(NTSTATUS) = NULL;

PRIVATE DLL_ENTRY_POINT NtDllEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(RtlInitUnicodeString),
    DLL_ENTRY_POINT_ELEMENT(NtCreateFile),
    DLL_ENTRY_POINT_ELEMENT(RtlNtStatusToDosError)
};

PRIVATE DLL_INFO NtDllInfo = DLL_INFO_INIT("NTDLL.DLL", NtDllEntryPoints);

//
// WSOCK32 info - if the platform is Windows 95 then we use the WsControl entry
// point in WSOCK32.DLL to access the TCP/IP device driver. If we are running
// over non-MS Winsock or TCP/IP then we cannot get the IpConfig info (unless
// the same features are supported)
//

PRIVATE DWORD (PASCAL FAR * _I_WsControl)(DWORD,
                                          DWORD,
                                          LPVOID,
                                          LPDWORD,
                                          LPVOID,
                                          LPDWORD
                                          ) = NULL;

PRIVATE DLL_ENTRY_POINT WsControlEntryPoint[] = {
    DLL_ENTRY_POINT_ELEMENT(WsControl)
};

PRIVATE DLL_INFO WsControlInfo = DLL_INFO_INIT("WSOCK32.DLL", WsControlEntryPoint);
PRIVATE HANDLE TcpipDriverHandle = INVALID_HANDLE_VALUE;

//
// Iphlpapi - Ip Helper APIs only found on NT 5 and Win 98, must dynaload,
//   Used to gather information on what adapters are avaible on the machine
//

PRIVATE DWORD (PASCAL FAR * _I_GetAdaptersInfo)(PIP_ADAPTER_INFO,
                                          PULONG
                                          ) = NULL;

PRIVATE DLL_ENTRY_POINT IpHlpApiEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(GetAdaptersInfo)
};

PRIVATE DLL_INFO IpHlpApiDllInfo = DLL_INFO_INIT("IPHLPAPI.DLL", IpHlpApiEntryPoints);

//
// DhcpcSvc - DHCP dll, Only found on Win'98 and NT 5.  This function does almost all the
//   work for us using the native DHCP services found on these cool new OSes.
//

PRIVATE DWORD (PASCAL FAR * _I_DhcpRequestOptions)(LPWSTR,
                            BYTE  *,
                            DWORD,
                            BYTE **,
                            DWORD *,
                            BYTE **,
                            DWORD *
                          ) = NULL;

PRIVATE DLL_ENTRY_POINT DhcpcSvcEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(DhcpRequestOptions)
};

PRIVATE DLL_INFO DhcpcSvcDllInfo = DLL_INFO_INIT("DHCPCSVC.DLL", DhcpcSvcEntryPoints);


//
// global data
//

// none.

//
// methods
//

//
// public CIpAddress methods
//


BOOL
CIpAddress::GetAddress(
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the IP address from this CIpAddress

Arguments:

    lpbAddress          - pointer to returned address

    lpdwAddressLength   - size of IP address

Return Value:

    BOOL
        TRUE    - address copied

        FALSE   - address not copied (buffer not large enough)

--*/

{
    if (*lpdwAddressLength >= sizeof(DWORD)) {
        *(LPDWORD)lpbAddress = m_dwIpAddress;
        *lpdwAddressLength = sizeof(DWORD);
        return TRUE;
    }
    return FALSE;
}


//
// public CIpAddressList methods
//

BOOL
CIpAddressList::IsContextInList(
    IN DWORD dwContext
    )
{
   for (CIpAddress * pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
       if (pEntry->Context() == dwContext) {
           return TRUE;
       }
   }
   return FALSE;
}




CIpAddress *
CIpAddressList::Find(
    IN DWORD dwIpAddress,
    IN DWORD dwIpMask
    )

/*++

Routine Description:

    Finds the CIpAddress object corresponding to (dwIpAddress, dwIpMask)

Arguments:

    dwIpAddress - IP address to find

    dwIpMask    - IP address mask, or INADDR_ANY (0) if we don't care

Return Value:

    CIpAddress *
        Success - pointer to found object

        Failure - NULL

--*/

{
    for (CIpAddress * pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
        if ((pEntry->IpAddress() == dwIpAddress)
        && ((dwIpMask == INADDR_ANY) || (pEntry->IpMask() == dwIpMask))) {
            break;
        }
    }
    return pEntry;
}


VOID
CIpAddressList::Add(
    IN CIpAddress * pAddress
    )

/*++

Routine Description:

    Adds an IP address entry to the list

Arguments:

    pAddress    - pointer to CIpAddress to add

Return Value:

    None.

--*/

{
    INET_ASSERT(pAddress->m_Next == NULL);

    CIpAddress * pEntry = (CIpAddress *)&m_List;

    while (pEntry->m_Next != NULL) {
        pEntry = pEntry->m_Next;
    }
    pEntry->m_Next = pAddress;
}


BOOL
CIpAddressList::Add(
    IN DWORD dwIpAddress,
    IN DWORD dwIpMask,
    IN DWORD dwContext
    )

/*++

Routine Description:

    Adds an IP address entry to the list

Arguments:

    dwIpAddress - IP address to add

    dwIpMask    - IP subnet mask

    dwContext   - unique interface context value

Return Value:

    BOOL
        TRUE    - item added

        FALSE   - out of memory

--*/

{
    CIpAddress * pIpAddress = new CIpAddress(dwIpAddress, dwIpMask, dwContext);

    if (pIpAddress != NULL) {
        Add(pIpAddress);
        return TRUE;
    }
    return FALSE;
}


BOOL
CIpAddressList::GetAddress(
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th address from the list

Arguments:

    lpdwIndex           - which address to return. Updated on output

    lpbAddress          - pointer to returned address

    lpdwAddressLength   - pointer to returned address length

Return Value:

    BOOL
        TRUE    - address returned

        FALSE   - address not returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpAddressList::GetAddress",
                 "%#x [%d], %#x, %#x [%d]",
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    CIpAddress * p = m_List;

    for (DWORD i = 0; (i < *lpdwIndex) && (p != NULL); ++i) {
        p = p->m_Next;
    }

    BOOL found;

    if (p != NULL) {
        found = p->GetAddress(lpbAddress, lpdwAddressLength);
        if (found) {
            ++*lpdwIndex;
        }
    } else {
        found = FALSE;
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
CIpAddressList::ThrowOutUnfoundEntries(
    VOID
    )

/*++

Routine Description:

    Throws out (deletes) any addresses that are marked not-found

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces thrown out

        FALSE   -      "     not "   "

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpAddressList::ThrowOutUnfoundEntries",
                 NULL
                 ));

    CIpAddress * pLast = (CIpAddress *)&m_List;
    CIpAddress * pEntry;
    BOOL bThrownOut = FALSE;

    for (pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
        if (!pEntry->IsFound()) {
            pLast->m_Next = pEntry->m_Next;
            delete pEntry;
            bThrownOut = TRUE;
            pEntry = pLast;
        } else {
            pLast = pEntry;
        }
    }

    DEBUG_LEAVE(bThrownOut);

    return bThrownOut;
}

//
// public CAdapterInterface methods
//


CAdapterInterface::CAdapterInterface(
    IN DWORD dwIndex,
    IN DWORD dwType,
    IN DWORD dwSpeed,
    IN LPSTR lpszDescription,
    IN DWORD dwDescriptionLength,
    IN LPBYTE lpPhysicalAddress,
    IN DWORD dwPhysicalAddressLength
    )

/*++

Routine Description:

    CAdapterInterface constructor

Arguments:

    dwIndex             - unique adapter interface index

    dwType              - type of interface

    dwSpeed             - speed of interface

    lpszDescription     - pointer to descriptive name of adapter

    dwDescriptionLength - length of lpszDescription

    lpPhysicalAddress   -
    dwPhysicalAddressLength -


Return Value:

    None.

--*/

{
    if ((lpszDescription != NULL) && (dwDescriptionLength != 0)) {
        m_lpszDescription = new char[dwDescriptionLength + 1];
        if (m_lpszDescription != NULL) {
            memcpy(m_lpszDescription, lpszDescription, dwDescriptionLength);
        } else {
            dwDescriptionLength = 0;
        }
    }

    if ((lpPhysicalAddress != NULL) && (dwPhysicalAddressLength != 0)) {
        m_lpPhysicalAddress = new BYTE[dwPhysicalAddressLength];
        if ( m_lpPhysicalAddress != NULL ) {
            memcpy(m_lpPhysicalAddress, lpPhysicalAddress, dwPhysicalAddressLength);
        }
        else {
            dwPhysicalAddressLength = 0;
        }
    }

    switch( dwType )
    {
        case IF_TYPE_ETHERNET:
            m_dwPhysicalAddressType  = HARDWARE_TYPE_10MB_EITHERNET;
            break;

        case IF_TYPE_TOKENRING:
        case IF_TYPE_FDDI:
            m_dwPhysicalAddressType = HARDWARE_TYPE_IEEE_802;
            break;

        case IF_TYPE_OTHER:
            m_dwPhysicalAddressType = HARDWARE_ARCNET;
            break;

        case IF_TYPE_PPP:
            m_dwPhysicalAddressType = HARDWARE_PPP;
            break;

        default:
            //DhcpPrint(("Invalid HW Type, %ld.\n", IFE.if_type ));
            INET_ASSERT( FALSE );
            m_dwPhysicalAddressType = HARDWARE_ARCNET;
            break;
    }

    m_dwPhysicalAddressLength = dwPhysicalAddressLength;
    m_dwDescriptionLength = dwDescriptionLength;
    m_lpszAdapterName = NULL;
    m_dwIndex = dwIndex;
    m_dwType = dwType;
    m_dwSpeed = dwSpeed;
    m_Flags.Word = 0;
    SetFound(TRUE);
}


CAdapterInterface::~CAdapterInterface(
    VOID
    )

/*++

Routine Description:

    CAdapterInterface destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_lpszDescription != NULL) {
        delete m_lpszDescription;
    }

    if (m_lpPhysicalAddress != NULL) {
        delete m_lpPhysicalAddress;
    }

    if ( m_lpszAdapterName != NULL) {
        FREE_MEMORY(m_lpszAdapterName);
    }
}


BOOL
CAdapterInterface::DhcpDoInformNT5(
    IN OUT LPSTR lpszAutoProxyUrl,
    IN DWORD dwAutoProxyUrlLength
    )

/*++

Routine Description:

     For a given Interface, this nifly little method uses the new wizbang NT 5/Win'98 specific API
       to do the DHCP Inform request and determine an auto-proxy Url that we can use.

     Kinda of nice when we're on NT 5, otherwise we need to pull in the kitchen sink equivlent of
       DHCP code that has been ripped off from the NT 4/Win'95 code base

Arguments:

    lpszAutoProxyUrl  - a piece of memory where we can stuff our new auto-proxy URL

    dwAutoProxyUrlLength - size of the space to store the string above

Return Value:

    BOOL
        TRUE    - successfully talked to server and got Url

        FALSE   - failed to allocate memory or failure talking to TCP/IP or failure to get an Url needed to continue

--*/

{
    DWORD error;
    BYTE bRequestOptions[] = { OPTION_WPAD_URL, OPTION_SUBNET_MASK, OPTION_ROUTER_ADDRESS,
        OPTION_DOMAIN_NAME_SERVERS, OPTION_HOST_NAME, OPTION_DOMAIN_NAME };
    LPBYTE pbOptionList = NULL, pbReturnOptions = NULL;
    DWORD dwOptionListSize, dwReturnOptionSize;
    WCHAR wszAdapterName[(MAX_ADAPTER_NAME_LENGTH + 6)];
    int len;

    len = MultiByteToWideChar(
        CP_ACP,
        0, // flags
        GetAdapterName(),
        -1, // assume null-terminated
        wszAdapterName,
        (MAX_ADAPTER_NAME_LENGTH + 6)
        );

    if ( len == 0 ) {
        return FALSE;  // failed to convert string
    }

    if ( _I_DhcpRequestOptions == NULL )
    {
        error = LoadDllEntryPoints(&DhcpcSvcDllInfo, 0);

        if ( error != ERROR_SUCCESS ) {
            return FALSE;
        }
    }

    error = _I_DhcpRequestOptions(
                wszAdapterName,         // adapter name
                bRequestOptions,        // array of byte codes, each represnts an option
                sizeof(bRequestOptions),// size of array above
                &pbOptionList,          // allocated array of option ids returned from server
                &dwOptionListSize,      // size of above allocated array
                &pbReturnOptions,       // allocated array of option values
                &dwReturnOptionSize
                );

    if ( error == ERROR_SUCCESS )
    {
        DWORD dwNextInc = 0;

        //
        // option ids are returned as byte codes in an array while
        //  the option data contains a byte size descritor followed
        //  by the option data itself which is a second array.
        //
        //  pbReturnedOptions = <OPTION_ID_1><OPTION_ID_2> ... <OPTION_ID_N>
        //  pbOptionValue = (<OPTION_LEN_1><OPTION_DATA_1>) ...
        //          (<OPTION_LEN_N><OPTION_DATA_N>)
        //
        //  pbOptionId is the byte code of the option itself
        //  pbOptionValue points to the option length, or the data following it.
        //
        //

        for ( LPBYTE pbOptionId = pbReturnOptions, pbOptionValue = pbOptionList;
                (pbOptionId < (pbReturnOptions+dwReturnOptionSize) &&
                    pbOptionValue < (pbOptionList+dwOptionListSize));
                 pbOptionId++, pbOptionValue+=(dwNextInc+1) )
        {
            dwNextInc = *pbOptionValue;
            pbOptionValue++; // advance past the size/length byte

            if (*pbOptionId == OPTION_WPAD_URL &&
                dwAutoProxyUrlLength > dwNextInc &&
                lpszAutoProxyUrl)
            {
                strncpy(lpszAutoProxyUrl, (char *) pbOptionValue, dwNextInc);
                return TRUE;
            }
        }
    }

    //
    // BUGBUG [arthurbi] pbOptionList & pbReturnOptions - need to be freed
    //   but the documentation says it needs to be freed by DhcpFreeMemory?!?
    //

    return FALSE;
}



BOOL
CAdapterInterface::CopyAdapterInfoToDhcpContext(
    PDHCP_CONTEXT pDhcpContext
    )
{
    memset ((void *) pDhcpContext, 0, sizeof(DHCP_CONTEXT));

    // hardware address, length, and type
    pDhcpContext->HardwareAddressType = m_dwPhysicalAddressType;
    pDhcpContext->HardwareAddress = m_lpPhysicalAddress;
    pDhcpContext->HardwareAddressLength = m_dwPhysicalAddressLength;

    if (m_IpList.m_List) {
        // Selected IpAddress, NetworkOrder. htonl
        // note: assumed to be in network order
        pDhcpContext->IpAddress = ((m_IpList.m_List)->IpAddress());
        pDhcpContext->IpInterfaceContext = ((m_IpList.m_List)->Context());
    }

    if (m_DhcpList.m_List) {
        // Selected DHCP server address. Network Order. htonl
        // note: assumed to be in network order
        pDhcpContext->DhcpServerAddress = ((m_DhcpList.m_List)->IpAddress());
    }

    pDhcpContext->ClientIdentifier.fSpecified = FALSE;
    pDhcpContext->T2Time = 0;
    // when was the last time an inform was sent?
    pDhcpContext->LastInformSent = 0;
    // seconds passed since boot.
    pDhcpContext->SecondsSinceBoot = 0;

    // the list of options to send and the list of options received
    InitializeListHead(&pDhcpContext->RecdOptionsList);
    InitializeListHead(&pDhcpContext->SendOptionsList);

    // the class this adapter belongs to

    if (  m_lpszAdapterName )
    {
        pDhcpContext->ClassId = (unsigned char *) m_lpszAdapterName;
        pDhcpContext->ClassIdLength = lstrlen(m_lpszAdapterName);
    }
    else
    {
        pDhcpContext->ClassId = NULL;
        pDhcpContext->ClassIdLength = 0;
    }

    // Message buffer to send and receive DHCP message.
    pDhcpContext->MessageBuffer = (PDHCP_MESSAGE) pDhcpContext->szMessageBuffer;
    memset(pDhcpContext->szMessageBuffer, 0, sizeof(pDhcpContext->szMessageBuffer));

    //LocalInfo = (PLOCAL_CONTEXT_INFO)((*pDhcpContext)->LocalInformation);
    //LocalInfo->IpInterfaceContext = IpInterfaceContext;
    //LocalInfo->IpInterfaceInstance = IpInterfaceInstance;
    // IpInterfaceInstance is filled in make context

    pDhcpContext->Socket = INVALID_SOCKET;
    pDhcpContext->State.Plumbed = TRUE;
    pDhcpContext->State.ServerReached = FALSE;
    pDhcpContext->State.AutonetEnabled= FALSE;
    pDhcpContext->State.HasBeenLooked = FALSE;
    pDhcpContext->State.DhcpEnabled   = FALSE;
    pDhcpContext->State.AutoMode      = FALSE;
    pDhcpContext->State.MediaState    = FALSE;
    pDhcpContext->State.MDhcp         = FALSE;
    pDhcpContext->State.PowerResumed  = FALSE;
    pDhcpContext->State.Broadcast     = FALSE;

    return TRUE;
}



//
// public CIpConfig methods
//


CIpConfig::CIpConfig(
    VOID
    )

/*++

Routine Description:

    CIpConfig constructor - initializes the object & loads the requird DLLs if
    not already loaded

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CIpConfig::CIpConfig",
                 NULL
                 ));

    InitializeListHead(&m_List);
    m_dwNumberOfInterfaces = 0;
    m_Loaded = TRI_STATE_UNKNOWN;

    DWORD error = LoadEntryPoints();

    if (error == ERROR_SUCCESS) {
#ifndef unix
        GetAdapterList();
#endif /* unix */
    }

    DEBUG_LEAVE(0);
}


CIpConfig::~CIpConfig()

/*++

Routine Description:

    CIpConfig destructor - destroys this object and unloads (or reduces the
    reference count on) the DLLs

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CIpConfig::~CIpConfig",
                 NULL
                 ));

    while (!IsListEmpty(&m_List)) {

        PLIST_ENTRY pEntry = RemoveHeadList(&m_List);

        //
        // BUGBUG - need CONTAINING_RECORD() if m_List is not @ start of
        //          CAdapterInterface
        //

        CAdapterInterface * pInterface = (CAdapterInterface *)pEntry;

        delete pInterface;
    }

    UnloadEntryPoints();
    CloseTcpipDriverHandle();

    DEBUG_LEAVE(0);
}


BOOL
CIpConfig::GetRouterAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th router address belonging to the interface
    corresponding to the address in lpbInterfaceAddress

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpdwIndex                   - index of router address to return

    lpbAddress                  - returned router address

    lpdwAddressLength           - length of router address

Return Value:

    BOOL
        TRUE    - *lpdwIndex'th router address returned for requested interface

        FALSE   - requested address not returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetRouterAddress",
                 "%#x, %d, %#x [%d], %#x, %#x [%d]",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    //
    // for now, we default to 1st interface
    //

    INET_ASSERT(lpbInterfaceAddress == NULL);
    INET_ASSERT(dwInterfaceAddressLength == sizeof(DWORD));

    BOOL found;

    //
    // no one uses this any more
    //

    INET_ASSERT(FALSE);

    //if (!IsListEmpty(&m_List)) {
    //    found = ((CAdapterInterface *)m_List.Flink)->m_RouterList.GetAddress(
    //                lpdwIndex,
    //                lpbAddress,
    //                lpdwAddressLength
    //                );
    //} else {
        found = FALSE;
    //}

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::GetDnsAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th DNS address belonging to the interface
    corresponding to the address in lpbInterfaceAddress

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpdwIndex                   - index of DNS address to return

    lpbAddress                  - returned DNS address

    lpdwAddressLength           - length of DNS address

Return Value:

    BOOL
        TRUE    - *lpdwIndex'th DNS address returned for requested interface

        FALSE   - requested address not returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetDnsAddress",
                 "%#x, %d, %#x [%d], %#x, %#x [%d]",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    //
    // for now, we only return the global DNS info
    //

    INET_ASSERT(lpbInterfaceAddress == NULL);
    INET_ASSERT(dwInterfaceAddressLength == sizeof(DWORD));

    BOOL found;

    if (!m_DnsList.IsEmpty()) {
        found = m_DnsList.GetAddress(lpdwIndex,
                                     lpbAddress,
                                     lpdwAddressLength
                                     );
    } else {
        found = FALSE;
    }

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::IsKnownIpAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN LPBYTE lpbAddress,
    IN DWORD dwAddressLength
    )

/*++

Routine Description:

    Return TRUE if lpbAddress is a known interface address

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpbAddress                  - pointer to address to check

    dwAddressLength             - length of address

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::IsKnownIpAddress",
                 "%#x, %d, %#x, %d",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpbAddress,
                 dwAddressLength
                 ));

    BOOL found = FALSE;

    for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
         pEntry != (CAdapterInterface *)&m_List.Flink;
         pEntry = (CAdapterInterface *)pEntry->m_List.Flink) {

        if (pEntry->FindIpAddress(*(LPDWORD)lpbAddress)) {
            found = TRUE;
            break;
        }
    }

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::Refresh(
    VOID
    )

/*++

Routine Description:

    Refreshes the interface information - re-reads the interfaces and IP
    addresses

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces or IP address changed

        FALSE   - nothing changed

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::Refresh",
                 NULL
                 ));

    BOOL bChanged;

    GetAdapterList(&bChanged);

    if (bChanged) {
//dprintf("flushing hostent cache\n");
//        FlushHostentCache();
    }

    DEBUG_LEAVE(bChanged);

    return bChanged;
}

//
// private CIpConfig methods
//


PRIVATE
BOOL
CIpConfig::GetAdapterList(
    OUT LPBOOL lpbChanged
    )

/*++

Routine Description:

    Builds a list of interfaces corresponding to physical and logical adapters,
      Uses Win'95 and NT 4 private VxD driver/registry entry points to get this data.

Arguments:

    lpbChanged  - if present, returns interface changed state

Return Value:

    BOOL
        TRUE    - successfully built list

        FALSE   - failed to allocate memory or failure talking to TCP/IP

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetAdapterList",
                 "%#x",
                 lpbChanged
                 ));

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    TDIObjectID id;
    UINT numberOfEntities;
    TDIEntityID* pEntity;
    TDIEntityID* entityList = NULL;
    IPRouteEntry* routeTable = NULL;
    LPVOID buffer = NULL;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    BOOL ok = FALSE;
    UINT i; // major loop index
    UINT j; // minor loop index
    BOOL bChanged = FALSE;

    //
    // default is interfaces unchanged
    //

    if (lpbChanged) {
        *lpbChanged = FALSE;
    }

    //
    // On NT 5 we override and use a different method for
    //   getting network settings.
    //

    if ( GlobalPlatformVersion5 ) {
        return GetAdapterListOnNT5();
    }

    //
    // get the list of entities supported by TCP/IP then make 2 passes on the
    // list. Pass 1 scans for IF_ENTITY's (interface entities perhaps?) which
    // describe adapter instances (physical and virtual). Once we have our list
    // of adapters, on pass 2 we look for CL_NL_ENTITY's (connection-less
    // network layer entities peut-etre?) which will give us the list of IP
    // addresses for the adapters we found in pass 1
    //

    numberOfEntities = GetEntityList(&entityList);
    if (numberOfEntities == 0) {

        INET_ASSERT(entityList == NULL);

        DEBUG_PRINT(UTIL,
                    ERROR,
                    ("GetAdapterList: failed to get entity list\n"
                    ));

        goto quit;
    }

    //
    // first off, mark all the current interfaces (if any), including current
    // IP addresses, as not found
    //

    SetNotFound();

    //
    // pass 1
    //

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Pass 1: Entity %#x (%s) Instance #%d\n",
                    pEntity->tei_entity,
                    InternetMapEntity(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity != IF_ENTITY) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("Entity %#x (%s) Instance #%d not IF_ENTITY - skipping\n",
                        pEntity->tei_entity,
                        InternetMapEntity(pEntity->tei_entity),
                        pEntity->tei_instance
                        ));

            continue;
        }

        //
        // IF_ENTITY: this entity/instance describes an adapter
        //

        DWORD isMib;
        BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
        IFEntry* pIfEntry = (IFEntry*)info;
        int len;

        //
        // find out if this entity supports MIB requests
        //

        memset(&req, 0, sizeof(req));

        id.toi_entity = *pEntity;
        id.toi_class = INFO_CLASS_GENERIC;
        id.toi_type = INFO_TYPE_PROVIDER;
        id.toi_id = ENTITY_TYPE_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(isMib);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&isMib,
                           &outputLen
                           );

        //
        // BUGBUG - this returns 0 as outputLen
        //

//        if ((status != TDI_SUCCESS) || (outputLen != sizeof(isMib))) {
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(ENTITY_TYPE_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }
        if (isMib != IF_MIB) {

            //
            // entity doesn't support MIB requests - try another
            //

            DEBUG_PRINT(UTIL,
                        WARNING,
                        ("Entity %#x, Instance #%d doesn't support MIB (%#x)\n",
                        id.toi_entity.tei_entity,
                        id.toi_entity.tei_instance,
                        isMib
                        ));

            continue;
        }

        //
        // MIB requests supported - query the adapter info
        //

        id.toi_class = INFO_CLASS_PROTOCOL;
        id.toi_id = IF_MIB_STATS_ID;

        memset(&req, 0, sizeof(req));
        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(info);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&info,
                           &outputLen
                           );
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(IF_MIB_STATS_ID) returns %d\n",
                        status
                        ));

            goto error_exit;
        }

        //
        // we only want physical adapters
        //

        if (!IS_INTERESTING_ADAPTER(pIfEntry)) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("ignoring adapter #%d [%s]\n",
                        pIfEntry->if_index,
                        InternetMapInterface(pIfEntry->if_type)
                        ));

            continue;
        }

        //
        // got this adapter info ok. Find or create an interface object and fill
        // in what we can
        //

        CAdapterInterface * pInterface;

        len = min(MAX_ADAPTER_ADDRESS_LENGTH, (size_t)pIfEntry->if_physaddrlen);

        pInterface = FindOrCreateInterface(pIfEntry->if_index,
                                           pIfEntry->if_type,
                                           pIfEntry->if_speed,
                                           (LPSTR)pIfEntry->if_descr,
                                           pIfEntry->if_descrlen,
                                           (LPBYTE)pIfEntry->if_physaddr,
                                           (DWORD) len
                                           );
        if (pInterface == NULL) {

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("failed to allocate memory for CAdapterInterface\n"
                        ));

            goto error_exit;
        }
    }

    //
    // pass 2
    //

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Pass 2: Entity %#x (%s) Instance %d\n",
                    pEntity->tei_entity,
                    InternetMapEntity(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity != CL_NL_ENTITY) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("Entity %#x (%s) Instance %d - not CL_NL_ENTITY - skipping\n",
                        pEntity->tei_entity,
                        InternetMapEntity(pEntity->tei_entity),
                        pEntity->tei_instance
                        ));

            continue;
        }

        IPSNMPInfo info;
        DWORD type;

        //
        // first off, see if this network layer entity supports IP
        //

        memset(&req, 0, sizeof(req));

        id.toi_entity = *pEntity;
        id.toi_class = INFO_CLASS_GENERIC;
        id.toi_type = INFO_TYPE_PROVIDER;
        id.toi_id = ENTITY_TYPE_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(type);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&type,
                           &outputLen
                           );

        //
        // BUGBUG - this returns 0 as outputLen
        //

//        if ((status != TDI_SUCCESS) || (outputLen != sizeof(type))) {
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(ENTITY_TYPE_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }
        if (type != CL_NL_IP) {

            //
            // nope, not IP - try next one
            //

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("CL_NL_ENTITY #%d not CL_NL_IP - skipping\n",
                        pEntity->tei_instance
                        ));

            continue;
        }

        //
        // okay, this NL provider supports IP. Let's get them addresses: First
        // we find out how many by getting the SNMP stats and looking at the
        // number of addresses supported by this interface
        //

        memset(&req, 0, sizeof(req));

        id.toi_class = INFO_CLASS_PROTOCOL;
        id.toi_id = IP_MIB_STATS_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(info);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&info,
                           &outputLen
                           );
        if ((status != TDI_SUCCESS) || (outputLen != sizeof(info))) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(IP_MIB_STATS_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }

        //
        // get the IP addresses & subnet masks
        //

        if (info.ipsi_numaddr != 0) {

            //
            // this interface has some addresses. What are they?
            //

            UINT numberOfAddresses;
            IPAddrEntry* pAddr;

            outputLen = info.ipsi_numaddr * sizeof(IPAddrEntry);
            buffer = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, outputLen);
            if (buffer == NULL) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(UTIL,
                            ERROR,
                            ("failed to allocate %d bytes\n",
                            outputLen
                            ));

                goto error_exit;
            }

            memset(&req, 0, sizeof(req));

            id.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

            req.ID = id;

            inputLen = sizeof(req);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)buffer,
                               &outputLen
                               );
            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(UTIL,
                            ERROR,
                            ("WsControl(IP_MIB_ADDRTABLE_ENTRY_ID): status = %d, outputLen = %d\n",
                            status,
                            outputLen
                            ));

                goto error_exit;
            }

            //
            // now loop through this list of IP addresses, applying them
            // to the correct adapter
            //

            numberOfAddresses = min((UINT)(outputLen / sizeof(IPAddrEntry)),
                                    (UINT)info.ipsi_numaddr
                                    );

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("%d IP addresses\n",
                        numberOfAddresses
                        ));

            pAddr = (IPAddrEntry *)buffer;
            for (j = 0; j < numberOfAddresses; ++j, ++pAddr) {

                DEBUG_PRINT(UTIL,
                            INFO,
                            ("IP address %d.%d.%d.%d, index %d, context %d\n",
                            ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                            pAddr->iae_index,
                            pAddr->iae_context
                            ));

                CAdapterInterface * pInterface = FindInterface(pAddr->iae_index);

                if (pInterface != NULL) {

                    CIpAddress * pIpAddress;

                    pIpAddress = pInterface->m_IpList.Find(pAddr->iae_addr,
                                                           pAddr->iae_mask
                                                           );
                    if (pIpAddress == NULL) {
                        pInterface->m_IpList.Add(pAddr->iae_addr,
                                                 pAddr->iae_mask,
                                                 pAddr->iae_context
                                                 );

                        //
                        // added an address - interface is changed
                        //
//dprintf("adding IP address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[3] & 0xff
//        );
                        bChanged = TRUE;
                    } else {

                        INET_ASSERT(pAddr->iae_context == pIpAddress->Context());

                        pIpAddress->SetFound(TRUE);
                    }
                }
            }

            INET_ASSERT(buffer);

            FREE_MEMORY(buffer);

            buffer = NULL;
        }

        //
        // get the gateway server IP address(es)
        //

        //
        // We don't need this information any more
        //

#if 0
        if (info.ipsi_numroutes != 0) {

            IPRouteEntry* pRoute;

            memset(&req, 0, sizeof(req));

            id.toi_id = IP_MIB_RTTABLE_ENTRY_ID;

            req.ID = id;

            inputLen = sizeof(req);

            //
            // Warning: platform specifics; Win95 structure size is different
            // than NT 4.0
            //

            //
            // BUGBUG - this will probably have to be checked for version # on
            //          Memphis
            //

            int structLength = (GlobalPlatformType == PLATFORM_TYPE_WINNT)
                             ? sizeof(IPRouteEntry) : sizeof(IPRouteEntry95);

            outputLen = structLength * info.ipsi_numroutes;

            //
            // the route table may have grown since we got the SNMP stats
            //

            for (j = 0; j < 4; ++j) {

                DWORD previousOutputLen = outputLen;

                routeTable = (IPRouteEntry*)ResizeBuffer(routeTable,
                                                         outputLen,
                                                         FALSE
                                                         );
                if (routeTable == NULL) {
                    goto error_exit;
                }

                status = WsControl(IPPROTO_TCP,
                                   WSCNTL_TCPIP_QUERY_INFO,
                                   (LPVOID)&req,
                                   &inputLen,
                                   (LPVOID)routeTable,
                                   &outputLen
                                   );
                if (status != TDI_SUCCESS) {

                    //
                    // unexpected results - bail out
                    //

                    DEBUG_PRINT(UTIL,
                                ERROR,
                                ("WsControl(IP_MIB_RTTABLE_ENTRY_ID): status = %d, outputLen = %d\n",
                                status,
                                outputLen
                                ));

                    goto error_exit;
                }
                if (outputLen <= previousOutputLen) {
                    break;
                }
            }

            UINT numberOfRoutes = (UINT)(outputLen / sizeof(IPRouteEntry));

            for (j = 0, pRoute = routeTable; j < numberOfRoutes; ++j) {

                //
                // the gateway address has a destination of 0.0.0.0
                //

                if (pRoute->ire_dest == INADDR_ANY) {

                    CAdapterInterface * pInterface;

                    pInterface = FindInterface(pRoute->ire_index);
                    if (pInterface != NULL) {

                        DEBUG_PRINT(UTIL,
                                    INFO,
                                    ("router address %d.%d.%d.%d, index %d\n",
                                    ((LPBYTE)&pRoute->ire_nexthop)[0] & 0xff,
                                    ((LPBYTE)&pRoute->ire_nexthop)[1] & 0xff,
                                    ((LPBYTE)&pRoute->ire_nexthop)[2] & 0xff,
                                    ((LPBYTE)&pRoute->ire_nexthop)[3] & 0xff,
                                    pRoute->ire_index
                                    ));

                        CIpAddress * pIpAddress;

                        pIpAddress = pInterface->m_RouterList.Find(pRoute->ire_nexthop);
                        if (pIpAddress == NULL) {
                            pInterface->m_RouterList.Add(pRoute->ire_nexthop);

                            //
                            // added a router address - interface is changed
                            //

//dprintf("adding router address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&pRoute->ire_nexthop)[0] & 0xff,
//        ((LPBYTE)&pRoute->ire_nexthop)[1] & 0xff,
//        ((LPBYTE)&pRoute->ire_nexthop)[2] & 0xff,
//        ((LPBYTE)&pRoute->ire_nexthop)[3] & 0xff
//        );
                            bChanged = TRUE;
                        } else {
                            pIpAddress->SetFound(TRUE);
                        }
                    }
                } else {

                    DEBUG_PRINT(UTIL,
                                INFO,
                                ("rejecting router address %d.%d.%d.%d, index %d\n",
                                ((LPBYTE)&pRoute->ire_nexthop)[0] & 0xff,
                                ((LPBYTE)&pRoute->ire_nexthop)[1] & 0xff,
                                ((LPBYTE)&pRoute->ire_nexthop)[2] & 0xff,
                                ((LPBYTE)&pRoute->ire_nexthop)[3] & 0xff,
                                pRoute->ire_index
                                ));

                }

                pRoute = (IPRouteEntry *)((LPBYTE)pRoute + structLength);
            }

            INET_ASSERT(routeTable);

            FREE_MEMORY(routeTable);

            routeTable = NULL;
        }
#endif // if 0, disable gathering of router addresses

    }

    //
    // add the DNS servers, read from registry or DHCP depending on platform.
    // Even if we don't get any DNS servers, we deem that this function has
    // succeeded
    //

    char dnsBuffer[1024];   // arbitrary (how many DNS entries?)
    UINT error;

    error = SockGetSingleValue(CONFIG_NAME_SERVER,
                               (LPBYTE)dnsBuffer,
                               sizeof(dnsBuffer)
                               );
    if (error == ERROR_SUCCESS) {
        //m_DnsList.Clear();

        char ipString[4 * 4];
        LPSTR p = dnsBuffer;
        DWORD buflen = (DWORD)lstrlen(dnsBuffer);

        do {
            if (SkipWhitespace(&p, &buflen)) {

                int i = 0;

                while ((*p != '\0')
                       && (*p != ',')
                       && (buflen != 0)
                       && (i < sizeof(ipString))
                       && !isspace(*p)) {
                    ipString[i++] = *p++;
                    --buflen;
                }
                ipString[i] = '\0';

                DWORD ipAddress = _I_inet_addr(ipString);

                if (IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress)) {

                    CIpAddress * pIpAddress;

                    pIpAddress = m_DnsList.Find(ipAddress);
                    if (pIpAddress == NULL) {
                        m_DnsList.Add(ipAddress);

                        //
                        // added a DNS address - interface is changed
                        //

//dprintf("adding DNS address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&ipAddress)[0] & 0xff,
//        ((LPBYTE)&ipAddress)[1] & 0xff,
//        ((LPBYTE)&ipAddress)[2] & 0xff,
//        ((LPBYTE)&ipAddress)[3] & 0xff
//        );
                        bChanged = TRUE;
                    } else {
                        pIpAddress->SetFound(TRUE);
                    }
                }
                while ((*p == ',') && (buflen != 0)) {
                    ++p;
                    --buflen;
                }
            } else {
                break;
            }
        } while (TRUE);
    }

    //
    // Refresh registry settings of DHCP server stuff
    //  and figure out what DHCP server we have
    //

    GetAdapterInfo();

    //
    // throw out any adapter interfaces which were not found this time. This may
    // happen if we support PnP devices that are unplugged
    //

    BOOL bThrownOut;

    bThrownOut = ThrowOutUnfoundEntries();
    if (!bChanged) {
        bChanged = bThrownOut;
    }

    INET_ASSERT(entityList != NULL);

    FREE_MEMORY(entityList);

    ok = TRUE;

    //
    // return the change state of the interfaces, if required
    //

    if (lpbChanged) {
        *lpbChanged = bChanged;
    }

quit:

    if (routeTable != NULL) {
        FREE_MEMORY(routeTable);
    }

    if (buffer != NULL) {
        FREE_MEMORY(buffer);
    }

    DEBUG_LEAVE(ok);

    return ok;

error_exit:

    //
    // here because of an error. Throw out all interfaces
    //

    SetNotFound();
    ThrowOutUnfoundEntries();

    INET_ASSERT(!ok);

    goto quit;
}



PRIVATE
BOOL
CIpConfig::GetAdapterListOnNT5(
    OUT LPBOOL lpbChanged
    )

/*++

Routine Description:

    Builds a list of interfaces corresponding to physical and logical adapters
     using the new NT 5 and Win98 APIs.

    BUGBUG [arthurbi] - turned off for Win '98 because we were getting erronous
      data values from the APIs (we currently fall back to old Win'95 code on '98).

Arguments:

    lpbChanged  - if present, returns interface changed state

Return Value:

    BOOL
        TRUE    - successfully built list

        FALSE   - failed to allocate memory or failure talking to TCP/IP

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetAdapterListOnNT5",
                 "%#x",
                 lpbChanged
                 ));

    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    BOOL ok = FALSE;
    UINT i; // major loop index
    UINT j; // minor loop index
    BOOL bChanged = FALSE;
    int len;

    IP_ADAPTER_INFO AdapterInfo[15];
    PIP_ADAPTER_INFO pAdapterInfo;
    DWORD dwError;
    ULONG uSize;

    //
    // Load the IPHLPAPI DLL, cause we need this function find adapter info on NT 5/Win98
    //

    if ( _I_GetAdaptersInfo == NULL )
    {
        DEBUG_PRINT(UTIL,
            ERROR,
            ("GetAdapterListOnNT5: IPHLPAPI dll could not be found with correct entry point\n"
            ));

        goto quit;
    }

    //
    // get the list of adapters supported by TCP/IP
    //

    uSize = sizeof(IP_ADAPTER_INFO)*15;
    pAdapterInfo = AdapterInfo;
    dwError = _I_GetAdaptersInfo(pAdapterInfo, &uSize);

    if ( dwError != ERROR_SUCCESS )
    {
        //
        // BUGBUG [arthurbi] handle the case where we have more than 15 adapters,
        //    need to be brave and start allocating memory for a change.
        //

        DEBUG_PRINT(UTIL,
            ERROR,
            ("GetAdapterListOnNT5: failed to get adapters list\n"
            ));

        goto quit;
    }

    //
    // first off, mark all the current interfaces (if any), including current
    // IP addresses, as not found
    //

    SetNotFound();

    //
    // pass 1
    //

    for (pAdapterInfo = AdapterInfo; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next)
    {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Adapter Pass: [#%u] Adapter name=%s, description=%s\n",
                    pAdapterInfo->Index,
                    pAdapterInfo->AdapterName,
                    pAdapterInfo->Description
                    ));

        //
        // we only want physical adapters
        //

        if (!IS_INTERESTING_ADAPTER_NT5(pAdapterInfo)) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("ignoring adapter #%u [%s]\n",
                        pAdapterInfo->Index,
                        InternetMapInterfaceOnNT5(pAdapterInfo->Type)
                        ));

            continue;
        }

        //
        // got this adapter info ok. Find or create an interface object and fill
        // in what we can
        //

        CAdapterInterface * pInterface;

        len = min(MAX_ADAPTER_ADDRESS_LENGTH, (size_t)pAdapterInfo->AddressLength);


        pInterface = FindOrCreateInterface(pAdapterInfo->Index,
                                           pAdapterInfo->Type,
                                           0,                   // speed
                                           pAdapterInfo->Description,
                                           lstrlen(pAdapterInfo->Description),
                                           pAdapterInfo->Address,
                                           (DWORD) len
                                           );
        if (pInterface == NULL) {

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("failed to allocate memory for CAdapterInterface\n"
                        ));

            goto error_exit;
        }

        //
        // Update the Adapter Name, this is the critical glue to make the new NT 5 DHCP Apis work,
        //   as they need this Adapter name as an ID to work.
        //

        if ( pInterface->GetAdapterName() == NULL )  {
            pInterface->SetAdapterName(pAdapterInfo->AdapterName);
        } else {
            INET_ASSERT(lstrcmpi(pInterface->GetAdapterName(), pAdapterInfo->AdapterName) == 0 );
        }

        //
        // Update the IP address found in the structure, as we're not getting anything back with this filled in.
        //

        if (  pAdapterInfo->CurrentIpAddress == NULL )
        {
            pAdapterInfo->CurrentIpAddress = &pAdapterInfo->IpAddressList;
        }
        else
        {
            INET_ASSERT(FALSE);  // want to know about this case.
        }

        //
        // Gather the IP addresses from the structure, doing all the necessary,
        //  IP string to network-ordered DWORD thingie usable for winsock.
        //
        //  BUGBUG [arthurbi] do we really need to do this anymore? As the
        //    the new NT 5 APIs can handle themselves without IP addresses...
        //


        if ( pAdapterInfo->CurrentIpAddress->IpAddress.String &&
             pAdapterInfo->CurrentIpAddress->IpMask.String )
        {
            DWORD dwAddress = _I_inet_addr(pAdapterInfo->CurrentIpAddress->IpAddress.String);
            DWORD dwMask = _I_inet_addr(pAdapterInfo->CurrentIpAddress->IpMask.String);
            DWORD dwContext = pAdapterInfo->CurrentIpAddress->Context;

            if ( dwAddress   != INADDR_NONE &&
                 dwMask      != INADDR_NONE  )
            {

                DEBUG_PRINT(UTIL,
                            INFO,
                            ("IP address %d.%d.%d.%d, index %d, context %d\n",
                            ((LPBYTE)&dwAddress)[0] & 0xff,
                            ((LPBYTE)&dwAddress)[1] & 0xff,
                            ((LPBYTE)&dwAddress)[2] & 0xff,
                            ((LPBYTE)&dwAddress)[3] & 0xff,
                            pAdapterInfo->Index,
                            dwContext
                            ));

                INET_ASSERT(pInterface != NULL);

                CIpAddress * pIpAddress;

                pIpAddress = pInterface->m_IpList.Find(dwAddress,
                                                       dwMask
                                                       );
                if (pIpAddress == NULL) {
                    pInterface->m_IpList.Add(dwAddress,
                                             dwMask,
                                             dwContext
                                             );

                    //
                    // added an address - interface is changed
                    //

                    bChanged = TRUE;
                } else {

                    INET_ASSERT(dwContext == pIpAddress->Context());

                    pIpAddress->SetFound(TRUE);
                }
            }
        }

        //
        // Gather DHCP server addresses to use, once again do we need this info on NT 5?
        //

        if ( pAdapterInfo->DhcpEnabled )
        {
            PIP_ADDR_STRING pDhcpServer;
            INET_ASSERT(pInterface != NULL);

            for ( pDhcpServer = &pAdapterInfo->DhcpServer; pDhcpServer; pDhcpServer = pDhcpServer->Next )
            {
                CIpAddress * pDhcpAddress;

                DWORD dwAddress = _I_inet_addr(pDhcpServer->IpAddress.String);
                DWORD dwMask = _I_inet_addr(pDhcpServer->IpMask.String);
                DWORD dwContext = pDhcpServer->Context;

                if ( dwAddress   != INADDR_NONE )
                {
                    CIpAddress * pIpAddress;

                    pInterface->SetDhcp();

                    pIpAddress = pInterface->m_DhcpList.Find(dwAddress,
                                                           dwMask
                                                           );
                    if (pIpAddress == NULL)
                    {
                        pInterface->m_DhcpList.Add(dwAddress,
                                                  dwMask,
                                                  dwContext
                                                  );

                        //
                        // added an address - interface is changed
                        //

                        bChanged = TRUE;
                    } else {

                        INET_ASSERT(dwContext == pIpAddress->Context());

                        pIpAddress->SetFound(TRUE);
                    }
                }

            }
        }
    }

    //
    // add the DNS servers, read from registry or DHCP depending on platform.
    // Even if we don't get any DNS servers, we deem that this function has
    // succeeded
    //

    char dnsBuffer[1024];   // arbitrary (how many DNS entries?)
    UINT error;

    error = SockGetSingleValue(CONFIG_NAME_SERVER,
                               (LPBYTE)dnsBuffer,
                               sizeof(dnsBuffer)
                               );
    if (error == ERROR_SUCCESS) {
        //m_DnsList.Clear();

        char ipString[4 * 4];
        LPSTR p = dnsBuffer;
        DWORD buflen = (DWORD)lstrlen(dnsBuffer);

        do {
            if (SkipWhitespace(&p, &buflen)) {

                int i = 0;

                while ((*p != '\0')
                       && (*p != ',')
                       && (buflen != 0)
                       && (i < sizeof(ipString))
                       && !isspace(*p)) {
                    ipString[i++] = *p++;
                    --buflen;
                }
                ipString[i] = '\0';

                DWORD ipAddress = _I_inet_addr(ipString);

                if (IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress)) {

                    CIpAddress * pIpAddress;

                    pIpAddress = m_DnsList.Find(ipAddress);
                    if (pIpAddress == NULL) {
                        m_DnsList.Add(ipAddress);

                        //
                        // added a DNS address - interface is changed
                        //

                        bChanged = TRUE;
                    } else {
                        pIpAddress->SetFound(TRUE);
                    }
                }
                while ((*p == ',') && (buflen != 0)) {
                    ++p;
                    --buflen;
                }
            } else {
                break;
            }
        } while (TRUE);
    }

    //
    // throw out any adapter interfaces which were not found this time. This may
    // happen if we support PnP devices that are unplugged
    //
    //  Do we need to still do this ???
    //

    BOOL bThrownOut;

    bThrownOut = ThrowOutUnfoundEntries();
    if (!bChanged) {
        bChanged = bThrownOut;
    }

    ok = TRUE;

    //
    // return the change state of the interfaces, if required
    //

    if (lpbChanged) {
        *lpbChanged = bChanged;
    }

quit:

    DEBUG_LEAVE(ok);

    return ok;

error_exit:

    //
    // here because of an error. Throw out all interfaces
    //

    SetNotFound();
    ThrowOutUnfoundEntries();

    INET_ASSERT(!ok);

    goto quit;
}


BOOL
CIpConfig::DoInformsOnEachInterface(
    IN OUT LPSTR lpszAutoProxyUrl,
    IN     DWORD dwAutoProxyUrlLength
    )
{
    for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
         pEntry != (CAdapterInterface *)&m_List.Flink;
         pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
    {
        if ( pEntry->IsDhcp() )
        {
            BOOL fSuccess;

            if ( GlobalPlatformVersion5 )
            {
                fSuccess = pEntry->DhcpDoInformNT5(
                                lpszAutoProxyUrl,
                                dwAutoProxyUrlLength
                                );
            }
            else
            {
                fSuccess = DhcpDoInform(     // send an inform packet if necessary
                        pEntry,
                        FALSE,
                        lpszAutoProxyUrl,
                        dwAutoProxyUrlLength
                        );
            }

            if ( fSuccess ) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


/*******************************************************************************
 *
 *  GetAdapterInfo
 *
 *  Gets a list of all adapters to which TCP/IP is bound and reads the per-
 *  adapter information that we want to display. Most of the information now
 *  comes from the TCP/IP stack itself. In order to keep the 'short' names that
 *  exist in the registry to refer to the individual adapters, we read the names
 *  from the registry then match them to the adapters returned by TCP/IP by
 *  matching the IPInterfaceContext value with the adapter which owns the IP
 *  address with that context value
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to linked list of ADAPTER_INFO structures
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID
CIpConfig::GetAdapterInfo()
{
    LPSTR* boundAdapterNames = NULL;
    DWORD err = ERROR_SUCCESS;

    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        if ( ServicesKey == NULL )
        {
            err = REGOPENKEY(HKEY_LOCAL_MACHINE,
                             SERVICES_KEY_NAME,
                             &ServicesKey
                             );
        }

        if ( err == ERROR_SUCCESS && TcpipLinkageKey == NULL )
        {
            err = REGOPENKEY(ServicesKey,
                             "Tcpip\\Linkage",
                             //"Tcpip\\Parameters\\Interfaces",
                             &TcpipLinkageKey
                             );
        }

        if (err == ERROR_SUCCESS && (boundAdapterNames = GetBoundAdapterList(TcpipLinkageKey)))
        {
            int i;

            //
            // apply the short name to the right adapter info by comparing
            // the IPInterfaceContext value in the adapter\Parameters\Tcpip
            // section with the context values read from the stack for the
            // IP addresses
            //

            for (i = 0; boundAdapterNames[i]; ++i) {

                LPSTR name;
                DWORD context;
                HKEY key;
                BOOL found;

                name = boundAdapterNames[i];

                if (!OpenAdapterKey(KEY_TCP, name, &key)) {
                    DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo cannot open %s\n",
                                 name ));

                    goto quit;
                }
                if (!ReadRegistryDword(key,
                                       "IPInterfaceContext",
                                       &context
                                       )) {
                    DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo: IPInterfaceContext failed\n"));
                    goto quit;
                }
                REGCLOSEKEY(key);

                //
                // now search through the list of adapters, looking for the one
                // that has the IP address with the same context value as that
                // just read. When found, apply the short name to that adapter
                //

                for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
                     pEntry != (CAdapterInterface *)&m_List.Flink;
                     pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
                {
                    if ( pEntry->IsContextInIPAddrList(context) )
                    {
                        pEntry->SetAdapterName(name);
                        GetDhcpServerFromDhcp(pEntry);
                        break;
                    }
                }
            }

        } else {
            DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo failed\n"));
        }
    }
    else
    {
        //
        // Win95: search through the list of adapters, gather DHCP server names
        //  for each.
        //

        for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
             pEntry != (CAdapterInterface *)&m_List.Flink;
             pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
        {
            GetDhcpServerFromDhcp(pEntry);
        }

    }

quit:

    if (boundAdapterNames != NULL )
    {
        FREE_MEMORY(boundAdapterNames);
    }

    return;
}



PRIVATE
DWORD
CIpConfig::LoadEntryPoints(
    VOID
    )

/*++

Routine Description:

    Loads NTDLL.DLL entry points if Windows NT else (if Windows 95) loads
    WsControl from WSOCK32.DLL

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CIpConfig::LoadEntryPoints",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (m_Loaded == TRI_STATE_UNKNOWN) {
        error = LoadDllEntryPoints((GlobalPlatformType == PLATFORM_TYPE_WINNT)
                                   ? &NtDllInfo : &WsControlInfo, 0);
        m_Loaded = (error == ERROR_SUCCESS) ? TRI_STATE_TRUE : TRI_STATE_FALSE;
    }

    if (GlobalPlatformVersion5 && (_I_GetAdaptersInfo == NULL))
    {
        error = LoadDllEntryPoints(&IpHlpApiDllInfo, 0);
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
CIpConfig::UnloadEntryPoints(
    VOID
    )

/*++

Routine Description:

    Unloads NTDLL.DLL if platform is Windows NT

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CIpConfig::UnloadEntryPoints",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (m_Loaded == TRI_STATE_TRUE) {
        error = UnloadDllEntryPoints((GlobalPlatformType == PLATFORM_TYPE_WINNT)
                                     ? &NtDllInfo : &WsControlInfo, FALSE);
        if (error == ERROR_SUCCESS) {
            m_Loaded = TRI_STATE_UNKNOWN;
        }
    }

    if (GlobalPlatformVersion5)
    {
        if (_I_GetAdaptersInfo != NULL) {
            error = UnloadDllEntryPoints(&IpHlpApiDllInfo, FALSE);
        }

        if ( _I_DhcpRequestOptions != NULL ) {
            error = UnloadDllEntryPoints(&DhcpcSvcDllInfo, FALSE);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
CAdapterInterface *
CIpConfig::FindOrCreateInterface(
    IN DWORD dwIndex,
    IN DWORD dwType,
    IN DWORD dwSpeed,
    IN LPSTR lpszDescription,
    IN DWORD dwDescriptionLength,
    IN LPBYTE lpPhysicalAddress,
    IN DWORD dwPhysicalAddressLength
    )

/*++

Routine Description:

    Returns a pointer to the CAdapterInterface object corresponding to dwIndex.
    If none found in the list, a new entry is created

Arguments:

    dwIndex             - unique interface identifier to find or create

    dwType              - type of adapter

    dwSpeed             - adapter media speed

    lpszDescription     - name of this interface

    dwDescriptionLength - length of the name

Return Value:

    CAdapterInterface *
        Success - pointer to found or created object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Pointer,
                 "CIpConfig::FindOrCreateInterface",
                 "%d, %s (%d), %d, %.*q, %d, %x, (%u)",
                 dwIndex,
                 InternetMapInterface(dwType),
                 dwType,
                 dwSpeed,
                 dwDescriptionLength,
                 lpszDescription,
                 dwDescriptionLength,
                 lpPhysicalAddress,
                 dwPhysicalAddressLength
                 ));

    CAdapterInterface * pInterface = FindInterface(dwIndex);

    if (pInterface == NULL) {
        pInterface = new CAdapterInterface(dwIndex,
                                           dwType,
                                           dwSpeed,
                                           lpszDescription,
                                           dwDescriptionLength,
                                           lpPhysicalAddress,
                                           dwPhysicalAddressLength
                                           );
        if (pInterface != NULL) {
            InsertHeadList(&m_List, &pInterface->m_List);
            ++m_dwNumberOfInterfaces;
        }
    }

    DEBUG_LEAVE(pInterface);

    return pInterface;
}


PRIVATE
CAdapterInterface *
CIpConfig::FindInterface(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Returns a pointer to the CAdapterInterface object corresponding to dwIndex

Arguments:

    dwIndex - unique interface identifier to find

Return Value:

    CAdapterInterface *
        Success - pointer to found object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Pointer,
                 "CIpConfig::FindInterface",
                 "%d",
                 dwIndex
                 ));

    CAdapterInterface * pInterface = NULL;

    for (PLIST_ENTRY pEntry = m_List.Flink;
        pEntry != (PLIST_ENTRY)&m_List;
        pEntry = pEntry->Flink) {

        if (((CAdapterInterface *)pEntry)->m_dwIndex == dwIndex) {
            ((CAdapterInterface *)pEntry)->SetFound(TRUE);

            //
            // ASSUMES: pEntry == &CAdapterInterface
            //

            pInterface = (CAdapterInterface *)pEntry;
            break;
        }
    }

    DEBUG_LEAVE(pInterface);

    return pInterface;
}


PRIVATE
BOOL
CIpConfig::ThrowOutUnfoundEntries(
    VOID
    )

/*++

Routine Description:

    Throws out (deletes) any entries that are marked not-found

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces thrown out

        FALSE   -      "     not "   "

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::ThrowOutUnfoundEntries",
                 NULL
                 ));

    //
    // ASSUMES: CAdapterInterface.m_List.Flink is first element in structure
    //

    PLIST_ENTRY pPrevious = (PLIST_ENTRY)&m_List.Flink;
    PLIST_ENTRY pEntry = m_List.Flink;
    BOOL bThrownOut = FALSE;

    while (pEntry != (PLIST_ENTRY)&m_List) {

        CAdapterInterface * pInterface = (CAdapterInterface *)pEntry;

        if (!pInterface->IsFound()) {

            DEBUG_PRINT(UTIL,
                        WARNING,
                        ("adapter index %d (%q) not located in list\n",
                        pInterface->m_dwIndex,
                        pInterface->m_lpszDescription
                        ));

            RemoveEntryList(&pInterface->m_List);
            --m_dwNumberOfInterfaces;

            INET_ASSERT((int)m_dwNumberOfInterfaces >= 0);

            delete pInterface;
            bThrownOut = TRUE;
        } else {

            //
            // throw out any IP addresses
            //

            bThrownOut |= pInterface->m_IpList.ThrowOutUnfoundEntries();
            //bThrownOut |= pInterface->m_RouterList.ThrowOutUnfoundEntries();
            //bThrownOut |= pInterface->m_DnsList.ThrowOutUnfoundEntries();
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    DEBUG_LEAVE(bThrownOut);

    return bThrownOut;
}

//
// public functions
//


DWORD
WsControl(
    IN DWORD dwProtocol,
    IN DWORD dwRequest,
    IN LPVOID lpInputBuffer,
    IN OUT LPDWORD lpdwInputBufferLength,
    OUT LPVOID lpOutputBuffer,
    IN OUT LPDWORD lpdwOutputBufferLength
    )

/*++

Routine Description:

    Makes device-dependent driver call based on O/S

Arguments:

    dwProtocol              - ignored

    dwRequest               - ignored

    lpInputBuffer           - pointer to request buffer

    lpdwInputBufferLength   - pointer to DWORD: IN = request buffer length

    lpOutputBuffer          - pointer to output buffer

    lpdwOutputBufferLength  - pointer to DWORD: IN = length of output buffer;
                                               OUT = length of returned data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "WsControl",
                 "%d, %d, %#x, %#x [%d], %#x, %#x [%d]",
                 dwProtocol,
                 dwRequest,
                 lpInputBuffer,
                 lpdwInputBufferLength,
                 *lpdwInputBufferLength,
                 lpOutputBuffer,
                 lpdwOutputBufferLength,
                 *lpdwOutputBufferLength
                 ));

    DWORD error;

    if (GlobalPlatformType == PLATFORM_TYPE_WINNT) {
        error = WinNtWsControl(dwProtocol,
                               dwRequest,
                               lpInputBuffer,
                               lpdwInputBufferLength,
                               lpOutputBuffer,
                               lpdwOutputBufferLength
                               );
    } else {
        error = _I_WsControl(dwProtocol,
                             dwRequest,
                             lpInputBuffer,
                             lpdwInputBufferLength,
                             lpOutputBuffer,
                             lpdwOutputBufferLength
                             );
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
WinNtWsControl(
    DWORD dwProtocol,
    DWORD dwRequest,
    LPVOID lpInputBuffer,
    LPDWORD lpdwInputBufferLength,
    LPVOID lpOutputBuffer,
    LPDWORD lpdwOutputBufferLength
    )

/*++

Routine Description:

    Handles WsControl() functionality on NT platform. Assumes NTDLL.DLL has
    already been loaded

Arguments:

    dwProtocol              - unused

    dwRequest               - unused

    lpInputBuffer           - contains driver request structure

    lpdwInputBufferLength   - pointer to length of InputBuffer

    lpOutputBuffer          - pointer to buffer where results written

    lpdwOutputBufferLength  - pointer to length of OutputBuffer. Updated with
                              returned data length on successful return

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "WinNtWsControl",
                 "%d, %d, %#x, %#x [%d], %#x, %#x [%d]",
                 dwProtocol,
                 dwRequest,
                 lpInputBuffer,
                 lpdwInputBufferLength,
                 *lpdwInputBufferLength,
                 lpOutputBuffer,
                 lpdwOutputBufferLength,
                 *lpdwOutputBufferLength
                 ));

    UNREFERENCED_PARAMETER(dwProtocol);
    UNREFERENCED_PARAMETER(dwRequest);

    DWORD error;

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {
        error = OpenTcpipDriverHandle();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    DWORD bytesReturned;
    BOOL ok;

    ok = DeviceIoControl(TcpipDriverHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         lpInputBuffer,
                         *lpdwInputBufferLength,
                         lpOutputBuffer,
                         *lpdwOutputBufferLength,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        error = GetLastError();
    } else {
        *lpdwOutputBufferLength = bytesReturned;
        error = ERROR_SUCCESS;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
OpenTcpipDriverHandle(
    VOID
    )

/*++

Routine Description:

    Opens handle to TCP/IP device driver

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK iosb;
        UNICODE_STRING string;
        NTSTATUS status;

        _I_RtlInitUnicodeString(&string, DD_TCP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes,
                                   &string,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );
        status = _I_NtCreateFile(&TcpipDriverHandle,
                                 SYNCHRONIZE | GENERIC_EXECUTE,
                                 &objectAttributes,
                                 &iosb,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN_IF,
                                 FILE_SYNCHRONOUS_IO_NONALERT,
                                 NULL,
                                 0
                                 );
        if (!NT_SUCCESS(status)) {
            error = _I_RtlNtStatusToDosError(status);
        }
    }
    return error;
}


PRIVATE
VOID
CloseTcpipDriverHandle(
    VOID
    )

/*++

Routine Description:

    Closes TCP/IP device driver handle

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (TcpipDriverHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(TcpipDriverHandle);
        TcpipDriverHandle = INVALID_HANDLE_VALUE;
    }
}


PRIVATE
DWORD
GetEntityList(
    OUT TDIEntityID * * lplpEntities
    )

/*++

Routine Description:

    Allocates a buffer for, and retrieves, the list of entities supported by the
    TCP/IP device driver

Arguments:

    lplpEntities    - pointer to allocated returned list of entities. Caller
                      must free

Return Value:

    UINT    - number of entities returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "GetEntityList",
                 "%#x",
                 lplpEntities
                 ));

    TCP_REQUEST_QUERY_INFORMATION_EX req;

    memset(&req, 0, sizeof(req));

    req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    req.ID.toi_entity.tei_instance = 0;
    req.ID.toi_class = INFO_CLASS_GENERIC;
    req.ID.toi_type = INFO_TYPE_PROVIDER;
    req.ID.toi_id = ENTITY_LIST_ID;

    DWORD inputLen = sizeof(req);
    DWORD outputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;
    TDIEntityID * pEntity = NULL;
    DWORD status = TDI_SUCCESS;

    //
    // this is over-engineered - its very unlikely that we'll ever get >32
    // entities returned, never mind >64K's worth
    //
    // Go round this loop a maximum of 4 times - length of list shouldn't
    // change between calls. Stops us getting stuck in infinite loop if
    // something bad happens with outputLen
    //

    for (int i = 0; i < 4; ++i) {

        DWORD previousOutputLen = outputLen;

        pEntity = (TDIEntityID *)ResizeBuffer(pEntity, outputLen, FALSE);
        if (pEntity == NULL) {
            outputLen = 0;
            break;
        }

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)pEntity,
                           &outputLen
                           );

        //
        // TDI_SUCCESS is returned if all data is not returned: driver
        // communicates all/partial data via outputLen
        //

        if (status == TDI_SUCCESS) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("GENERIC_ENTITY required length = %d\n",
                        outputLen
                        ));

            if (outputLen && (outputLen <= previousOutputLen)) {
                break;
            }
        } else {
            outputLen = 0;
        }
    }

    if ((status != TDI_SUCCESS) && (pEntity != NULL)) {
        ResizeBuffer(pEntity, 0, FALSE);
    }

    DEBUG_PRINT(UTIL,
                INFO,
                ("%d entities returned in %#x\n",
                (outputLen / sizeof(TDIEntityID)),
                pEntity
                ));

    *lplpEntities = pEntity;

    DEBUG_LEAVE((UINT)(outputLen / sizeof(TDIEntityID)));

    return (UINT)(outputLen / sizeof(TDIEntityID));
}

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
LPCSTR
InternetMapEntity(
    IN INT EntityId
    ) {
    switch (EntityId) {
    case CO_TL_ENTITY:
        return "CO_TL_ENTITY";

    case CL_TL_ENTITY:
        return "CL_TL_ENTITY";

    case ER_ENTITY:
        return "ER_ENTITY";

    case CO_NL_ENTITY:
        return "CO_NL_ENTITY";

    case CL_NL_ENTITY:
        return "CL_NL_ENTITY";

    case AT_ENTITY:
        return "AT_ENTITY";

    case IF_ENTITY:
        return "IF_ENTITY";

    }
    return "*** UNKNOWN ENTITY ***";
}

PRIVATE
LPCSTR
InternetMapInterface(
    IN DWORD InterfaceType
    ) {
    switch (InterfaceType) {
    case IF_TYPE_OTHER:
        return "other";

    case IF_TYPE_ETHERNET:
        return "ethernet";

    case IF_TYPE_TOKENRING:
        return "token ring";

    case IF_TYPE_FDDI:
        return "FDDI";

    case IF_TYPE_PPP:
        return "PPP";

    case IF_TYPE_LOOPBACK:
        return "loopback";
    }
    return "???";
}

PRIVATE
LPCSTR
InternetMapInterfaceOnNT5(
    IN DWORD InterfaceType
    ) {
    switch (InterfaceType) {
    case IF_TYPE_OTHER:
        return "other";

    case IF_TYPE_ETHERNET_CSMACD:
        return "ethernet";

    case IF_TYPE_ISO88025_TOKENRING:
        return "token ring";

    case IF_TYPE_FDDI:
        return "FDDI";

    case IF_TYPE_PPP:
        return "PPP";

    case IF_TYPE_SOFTWARE_LOOPBACK:
        return "loopback";

    case IF_TYPE_SLIP:
        return "SLIP";

    default:
        return "???";
    }
    return "???";
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\gmacros.h ===
/*================================================================================
  File: gmacros.h
  Contains: Macros used in common by both the DHCP Server and the DHCP Client.
  	Most of them are inlines for sake of elegance and ease of usage.
  Author: RameshV
  Created: 04-Jun-97 00:01

================================================================================*/
//#include <align.h>

//  Some block macros; usage at end

//  Disable the warning about unreference labels.
#pragma warning(disable : 4102)

#define _shorten(string)    ( strrchr(string, '\\')? strrchr(string, '\\') : (string) )

// print a message and the file and line # of whoever is printing this.
#define _TracePrintLine(Msg)  DhcpPrint((DEBUG_TRACE_CALLS, "%s:%d %s\n", _shorten(__FILE__), __LINE__, Msg))

#define BlockBegin(Name)    { BlockStart_ ## Name : _TracePrintLine( "Block -> " #Name );
#define BlockEnd(Name)      BlockEnd_ ## Name : _TracePrintLine( "Block <- " #Name ) ;}
#define BlockContinue(Name) do { _TracePrintLine( "Continue to " #Name); goto BlockStart_ ## Name; } while (0)
#define BlockBreak(Name)    do { _TracePrintLine( "Breaking out of " #Name); goto BlockEnd_ ## Name; } while (0)
#define RetFunc(F,Ret)      do {_TracePrintLine( "Quitting function " #F ); return Ret ; } while (0)

// The way to use the above set of simple block macros is as follows: (example usage)
#if     0
int
DummyFunction(VOID) {
    BlockBegin(DummyFunctionMain) {
        if(GlobalCount > 0 )
            BlockContinue(DummyFunctionMain);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(DummyFunctionMain);
    } BlockEnd(DummyFunctionMain);

    RetFunc(DummyFunction, RetVal);
}
#endif

// now come some little more complicated functions..
// note that these can be freely mixed with the above set of simple functions.
#define BlockBeginEx(Name, String)    {BlockStart_ ## Name : _TracePrintLine( #String );
#define BlockEndEx(Name, String)      BlockEnd_## Name : _TracePrintLine( #String );}
#define BlockContinueEx(Name, String) do {_TracePrintLine( #String); goto BlockStart_ ## Name; } while (0)
#define BlockBreakEx(Name, String)    do {_TracePrintLine( #String); goto BlockEnd_ ## Name; } while(0)

#define RetFuncEx(Name,Ret,DebMsg)    do {_TracePrintLine( "QuittingFunction " #Name); DhcpPrint(DebMsg); return Ret;} while(0)

// usage example:

#if 0
int
DummyFunction(VOID) {
    BlockBeginEx(Main, "Entering Dummy Function" ) {
        if( GlobalCount > 0)
            BlockContinueEx(Main, GlobalCount > 0);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(Main);
    } BlockEndEx(Main, "Done Dummy Function");

    RetFunc(DummyFunc, RetVal);
    // OR
    RetFuncEx(DummyFunc, RetVal, (DEBUG_ERRROS, "Function returning, gcount = %ld\n", GlobalCount));

}

#endif 0


#define NOTHING

// Now if a VOID function (procedure) returns, we can say RetFunc(VoidFunc, NOTHING) and things will work.


//================================================================================
//  Now some useful inlines.
//================================================================================

VOID _inline
FreeEx(LPVOID Ptr) {
    if(Ptr) DhcpFreeMemory(Ptr);
}

VOID _inline
FreeEx2(LPVOID Ptr1, LPVOID Ptr2) {
    FreeEx(Ptr1); FreeEx(Ptr2);
}

VOID _inline
FreeEx3(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3) {
    FreeEx(Ptr1); FreeEx(Ptr2); FreeEx(Ptr3);
}

VOID _inline
FreeEx4(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3, LPVOID Ptr4) {
    FreeEx2(Ptr1, Ptr2); FreeEx2(Ptr3, Ptr4);
}

//--------------------------------------------------------------------------------
//  All the alloc functions below, allocate in one shot a few pointers,
//  and initialize them.. aligning them correctly.
//--------------------------------------------------------------------------------
LPVOID _inline
AllocEx(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx2(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx3(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2, LPVOID *Ptr3, DWORD Size3) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST) + Size3;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    return Ptr;
}

LPVOID _inline
AllocEx4(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2,
         LPVOID *Ptr3, DWORD Size3, LPVOID *Ptr4, DWORD Size4) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST) + Size4;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    (*Ptr4) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST);
    return Ptr;
}

//--------------------------------------------------------------------------------
//  This function takes an input string and a static buffer and if the input
//  string is not nul terminated, copies it to the static buffer and then null
//  terminates it.  It also change the size to reflect the new size..
//--------------------------------------------------------------------------------
LPBYTE _inline
AsciiNulTerminate(LPBYTE Input, DWORD *Size, LPBYTE StaticBuf, DWORD BufSize) {
    if( 0 == *Size) return Input;   // nothing to copy
    if(!Input[(*Size)-1]) return Input; // Everything is fine.

    if(*Size >= BufSize) {
        // Nothing much can be done here.. this is an error.. insufficient buffer space.
        DhcpAssert(FALSE);

        *Size = BufSize - 1;
    }

    memcpy(StaticBuf, Input, (*Size));
    StaticBuf[*Size] = '\0';
    (*Size) ++;
    return StaticBuf;
}

#if DBG
#define INLINE
#else
#define INLINE _inline
#endif

#define BEGIN_EXPORT
#define END_EXPORT

#define AssertReturn(Condition, RetVal )    do { DhcpAssert(Condition); return RetVal ;} while(0)

//================================================================================
//  End of File.
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\sockreg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sockreg.h

Abstract:

    Prototypes for sockreg.cxx

    stolen from Win95 winsock project (& modified)

Author:

    Richard L Firth (rfirth) 10-Feb-1994

Environment:

    Chicago/Snowball (i.e. Win32/Win16)

Revision History:

    10-Feb-1994 (rfirth)
        Created

--*/

//
// registry/config/ini items
//

#define CONFIG_HOSTNAME     1
#define CONFIG_DOMAIN       2
#define CONFIG_SEARCH_LIST  3
#define CONFIG_NAME_SERVER  4

//
// prototypes
//

UINT
SockGetSingleValue(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\nameser.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *  @(#)nameser.h   5.3
 *
 *  Last delta created  14:06:04 3/4/91
 *  This file extracted 11:19:28 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)nameser.h   5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ    512     /* maximum packet size */
#define MAXDNAME    256     /* maximum domain name */
#define MAXCDNAME   255     /* maximum compressed domain name */
#define MAXLABEL    63      /* maximum length of domain label */
    /* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ    4
    /* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ   10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT 53

/*
 * Currently defined opcodes
 */
#define QUERY       0x0     /* standard query */
#define IQUERY      0x1     /* inverse query */
#define STATUS      0x2     /* nameserver status query */
/*#define xxx       0x3     /* 0x3 reserved */
    /* non standard */
#define UPDATEA     0x9     /* add resource record */
#define UPDATED     0xa     /* delete a specific resource record */
#define UPDATEDA    0xb     /* delete all nemed resource record */
#define UPDATEM     0xc     /* modify a specific resource record */
#define UPDATEMA    0xd     /* modify all named resource record */

#define ZONEINIT    0xe     /* initial zone transfer */
#define ZONEREF     0xf     /* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR     0       /* no error */
#endif
#define FORMERR     1       /* format error */
#define SERVFAIL    2       /* server failure */
#define NXDOMAIN    3       /* non existent domain */
#define NOTIMP      4       /* not implemented */
#define REFUSED     5       /* query refused */
    /* non standard */
#define NOCHANGE    0xf     /* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A     1       /* host address */
#define T_NS        2       /* authoritative server */
#define T_MD        3       /* mail destination */
#define T_MF        4       /* mail forwarder */
#define T_CNAME     5       /* connonical name */
#define T_SOA       6       /* start of authority zone */
#define T_MB        7       /* mailbox domain name */
#define T_MG        8       /* mail group member */
#define T_MR        9       /* mail rename name */
#define T_NULL      10      /* null resource record */
#define T_WKS       11      /* well known service */
#define T_PTR       12      /* domain name pointer */
#define T_HINFO     13      /* host information */
#define T_MINFO     14      /* mailbox information */
#define T_MX        15      /* mail routing information */
#define T_TXT       16      /* text strings */
#define T_AFSDB     18      /* AFS database servers */
    /* non standard */
#define T_UINFO     100     /* user (finger) information */
#define T_UID       101     /* user ID */
#define T_GID       102     /* group ID */
#define T_UNSPEC    103     /* Unspecified format (binary data) */
    /* Query type values which do not appear in resource records */
#define T_AXFR      252     /* transfer zone of authority */
#define T_MAILB     253     /* transfer mailbox records */
#define T_MAILA     254     /* transfer mail agent records */
#define T_ANY       255     /* wildcard match */

/*
 * Values for class field
 */

#define C_IN        1       /* the arpa internet */
#define C_CHAOS     3       /* for chaos net at MIT */
#define C_HS        4       /* for Hesiod name server at MIT */
    /* Query class values which do not appear in resource records */
#define C_ANY       255     /* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define LITTLE_ENDIAN   1234    /* least-significant byte first (vax) */
#define BIG_ENDIAN  4321    /* most-significant byte first (IBM, net) */
#define PDP_ENDIAN  3412    /* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER  LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined(ux10) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#ifndef BYTE_ORDER      /* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define BYTE_ORDER  LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
    /* you must determine what the correct bit order is for your compiler */
    UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
    unsigned short  id;     /* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
            /* fields in third byte */
    unsigned char   qr:1;       /* response flag */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   rd:1;       /* recursion desired */
            /* fields in fourth byte */
    unsigned char   ra:1;       /* recursion available */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   rcode:4;    /* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
            /* fields in third byte */
    unsigned char   rd:1;       /* recursion desired */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   qr:1;       /* response flag */
            /* fields in fourth byte */
    unsigned char   rcode:4;    /* response code */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   ra:1;       /* recursion available */
#endif
            /* remaining bytes */
    unsigned short  qdcount;    /* number of question entries */
    unsigned short  ancount;    /* number of answer entries */
    unsigned short  nscount;    /* number of authority entries */
    unsigned short  arcount;    /* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK  0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
    short           r_zone;         /* zone number */
    short           r_class;        /* class number */
    short           r_type;         /* type number */
    unsigned long   r_ttl;          /* time to live */
    int         r_size;         /* size of data area */
    char           *r_data;             /* pointer to data */
};

extern  unsigned short  _getshort(char *);
extern  unsigned long   _getlong(char *);

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
    (s) = *(cp)++ << 8; \
    (s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
    (l) = *(cp)++ << 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
    *(cp)++ = (s) >> 8; \
    *(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
    (cp)[3] = l; \
    (cp)[2] = (l >>= 8); \
    (cp)[1] = (l >>= 8); \
    (cp)[0] = l >> 8; \
    (cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\stack.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// All dealings with the stack and other non-Dhcp components go through the API
// given here
//================================================================================

#ifndef STACK_H_INCLUDED
#define STACK_H_INCLUDED

//================================================================================
// Exported API's
//================================================================================

DWORD                                             // win32 status
DhcpClearAllStackParameters(                      // undo the effects
    IN      PDHCP_CONTEXT          DhcpContext    // the adapter to undo
);

DWORD                                             // win32 status
DhcpSetAllStackParameters(                        // set all stack details
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to set stuff
    IN      PDHCP_FULL_OPTIONS     DhcpOptions    // pick up the configuration from off here
);

#endif STACK_H_INCLUDED

#ifndef SYSSTACK_H_INCLUDED
#define SYSSTACK_H_INCLUDED
//================================================================================
// imported api's
//================================================================================
DWORD                                             // return interface index or -1
DhcpIpGetIfIndex(                                 // get the IF index for this adapter
    IN      PDHCP_CONTEXT          DhcpContext    // context of adapter to get IfIndex for
);

DWORD                                             // win32 status
DhcpSetRoute(                                     // set a route with the stack
    IN      DWORD                  Dest,          // network order destination
    IN      DWORD                  DestMask,      // network order destination mask
    IN      DWORD                  IfIndex,       // interface index to route
    IN      DWORD                  NextHop,       // next hop n/w order address
    IN      BOOL                   IsLocal,       // is this a local address? (IRE_DIRECT)
    IN      BOOL                   IsDelete       // is this route being deleted?
);

#endif SYSSTACK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			512

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_ITEM_NOT_FOUND      36          // Item not found.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING
#define TDI_ITEM_NOT_FOUND      STATUS_OBJECT_NAME_NOT_FOUND


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\dhcppro.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lproto.h

Abstract:

    This file contains function proto types for the NT specific
    functions.

Author:

    Madan Appiah (madana)  Dec-7-1993

Environment:

    User Mode - Win32

Revision History:


--*/

//
// dhcpreg.c
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    );

DWORD
GetRegistryString(
    HKEY Key,
    LPVOID ValueStringName,
    LPTSTR *String,
    LPDWORD StringSize
    );

DWORD
DhcpRegReadParamString(
    LPWSTR     AdapterName,
    LPWSTR     RegKeyLocation,
    LPWSTR     ValueName,
    LPWSTR    *ReturnValue
);

DWORD
RegSetIpAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS IpAddress
    );

#if DBG
DWORD
RegSetTimeField(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    time_t Time
    );
#endif

DWORD
DhcpGetRegistryValue(
    LPWSTR RegKey,
    LPWSTR ValueName,
    DWORD ValueType,
    PVOID *Data
    );

DWORD
DhcpSetDNSAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS UNALIGNED *Data,
    DWORD DataLength
    );

DWORD
SetDhcpOption(
    LPWSTR AdapterName,
    DHCP_OPTION_ID OptionId,
    LPBOOL DefaultGatewaysSet,
    BOOL LastKnownDefaultGateway
    );

DWORD
DhcpMakeNICList(
    VOID
    );

DWORD
DhcpAddNICtoList(
    LPWSTR AdapterName,
    LPWSTR DeviceName,
    PDHCP_CONTEXT *DhcpContext
    );

#if     defined(_PNP_POWER_)
DWORD
DhcpAddNICtoListEx(
    LPWSTR AdapterName,
    DWORD  ipInterfaceContext,
    PDHCP_CONTEXT *DhcpContext
    );

#endif _PNP_POWER_
BOOL
SetOverRideDefaultGateway(
    LPWSTR AdapterName
    );

BOOL
DhcpGetAddressOption(
    DHCP_IP_ADDRESS **ppDNSServerList,
    DWORD            *pNumberOfServers
    );


BOOL
DhcpRegReadUseMHAsyncDnsFlag(
    VOID
);

DWORD                                             // Win32 status
DhcpInitRegistry(                                 // Initialize registry based globals
    VOID
);

VOID
DhcpCleanupRegistry(                              // undo the effects of InitReg call
    VOID
);


DHCP_IP_ADDRESS                                   // the static ip address of the adapter
DhcpRegReadIpAddress(                             // get the first ip address
    LPWSTR    AdapterName,                        // the adaptor of interest
    LPWSTR    ValueName                           // the ip address value to read
);

DWORD                                             // status
DhcpRegReadIpAddresses(                           // read a set of ip addresses
    IN      DHCPKEY                RegKeyHandle,  // open key handle
    IN      LPWSTR                 ValueName,     // name of value to read frm
    IN      WCHAR                  Separation,    // a MULTI_SZ has L'\0', SZ has L' ' or L',' etc.
    OUT     PDHCP_IP_ADDRESS      *AddressArray,  // an array of addresses
    OUT     LPDWORD                AddressCount   // the output size of above array
);

VOID
DhcpRegInitializeClasses(                         // initialize the classes list
    IN OUT  PDHCP_CONTEXT          DhcpContext    // NULL or adpater context
);

DWORD                                             // status
DhcpGetRegistryValueWithKey(                      // see defn of GetRegistryValue
    IN      HKEY                   KeyHandle,     // keyhandle NOT location
    IN      LPTSTR                 ValueName,     // value to read from registry
    IN      DWORD                  ValueType,     // type of value
    OUT     LPVOID                 Data           // this will be filled in
);

DWORD                                             // status
DhcpRegExpandString(                              // replace '?' with AdapterName
    IN      LPWSTR                 InString,      // input string to expand
    IN      LPWSTR                 AdapterName,   // the adapter name
    OUT     LPWSTR                *OutString,     // the output ptr to store string
    IN OUT  LPWSTR                 Buffer         // the buffer to use if non NULL
);

DWORD                                             // status
DhcpRegReadFromLocation(                          // read from one location
    IN      LPWSTR                 OneLocation,   // value to read from
    IN      LPWSTR                 AdapterName,   // replace '?' with adapternames
    OUT     LPBYTE                *Value,         // output value
    OUT     DWORD                 *ValueType,     // data type of value
    OUT     DWORD                 *ValueSize      // the size in bytes
);

DWORD                                             // status
DhcpRegReadFromAnyLocation(                       // read from one of many locations
    IN      LPWSTR                 MzRegLocation, // multiple locations thru REG_MULTI_MZ
    IN      LPWSTR                 AdapterName,   // may have to replace '?' with AdapterName
    OUT     LPBYTE                *Value,         // data for the value read
    OUT     DWORD                 *ValueType,     // type of the data
    OUT     DWORD                 *ValueSize      // the size of data
);

DWORD                                             // win32 status
DhcpRegFillParams(                                // get the registry config for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // adapter context to fill in
    IN      BOOL                   ReadAllInfo    // read EVERYTHING or only some critical info?
);

VOID
DhcpRegReadClassId(                               // Read the class id stuff
    IN      PDHCP_CONTEXT          DhcpContext    // Input context to read for
);

//
// ioctl.c
//

DWORD
IPSetIPAddress(
    DWORD IpInterfaceContext,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPAddIPAddress(
    LPWSTR AdapterName,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPResetIPAddress(
    DWORD           dwInterfaceContext,
    DHCP_IP_ADDRESS SubnetMask
    );


DWORD
SetIPAddressAndArp(
    PVOID         pvLocalInformation,
    DWORD         dwAddress,
    DWORD         dwSubnetMask
    );


DWORD
NetBTSetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTResetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTNotifyRegChanges(
    LPWSTR DeviceName
    );

DWORD
SetDefaultGateway(
    DWORD Command,
    DHCP_IP_ADDRESS GatewayAddress
    );

HANDLE
DhcpOpenGlobalEvent(
    void
    );

#if     defined(_PNP_POWER_) && !defined(VXD)
DWORD
IPGetIPEventRequest(
    HANDLE  handle,
    HANDLE  event,
    UINT    seqNo,
    PIP_GET_IP_EVENT_RESPONSE  responseBuffer,
    DWORD                responseBufferSize,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

DWORD
IPCancelIPEventRequest(
    HANDLE  handle,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

#endif _PNP_POWER_ && !VXD

//
// api.c
//

DWORD
DhcpApiInit(
    VOID
    );



VOID
DhcpApiCleanup(
    VOID
    );

DWORD
ProcessApiRequest(
    HANDLE PipeHandle,
    LPOVERLAPPED Overlap
    );

//
// util.c
//


PDHCP_CONTEXT
FindDhcpContextOnRenewalList(
    LPWSTR AdapterName,
    DWORD  InterfaceContext
    );

PDHCP_CONTEXT
FindDhcpContextOnNicList(
    LPWSTR AdapterName,
    DWORD  InterfaceContext
    );

BOOL
IsMultiHomeMachine(
    VOID
    );


//
// options.c
//


SERVICE_SPECIFIC_DHCP_OPTION *
FindDhcpOption(
    DHCP_OPTION_ID OptionID
    );


DWORD
ReadGlobalOptionList();

DWORD
LoseAllEnvSpecificOptions(
    PDHCP_CONTEXT   dhcpContext
);


//
// dhcp.c
//

DWORD
SetIpConfigurationForNIC(
    HKEY            KeyHandle,
    PDHCP_CONTEXT   DhcpContext,
    PDHCP_OPTIONS   DhcpOptions,
    DHCP_IP_ADDRESS ServerIpAddress,
    DWORD           dwLeaseTime,
    DWORD           dwT1Time,
    DWORD           dwT2Time,
    BOOL            ObtainedNewAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\options.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997.
//  Author: RameshV
//  Date: 09-Sep-97 06:20
//  Description: Manages the class-id and options information
//================================================================================

#ifndef OPTIONS_H
#define OPTIONS_H

#define MAX_DATA_LEN               255            // atmost 255 bytes for an option

typedef struct _DHCP_CLASSES {                    // common pool of class names
    LIST_ENTRY                     ClassList;     // global list of classes
    LPBYTE                         ClassName;     // name of the class
    DWORD                          ClassLen;      // # of bytes in class name
    DWORD                          RefCount;      // # of references to this
} DHCP_CLASSES, *LPDHCP_CLASSES, *PDHCP_CLASSES;

typedef struct _DHCP_OPTION  {                    // list of options
    LIST_ENTRY                     OptionList;    // the fwd/back ptrs
    BYTE                           OptionId;      // the option value
    BOOL                           IsVendor;      // is this vendor specific
    LPBYTE                         ClassName;     // the class of this option
    DWORD                          ClassLen;      // the length of above option
    time_t                         ExpiryTime;    // when this option expires
    LPBYTE                         Data;          // the data value for this option
    DWORD                          DataLen;       // the # of bytes of above
} DHCP_OPTION , *LPDHCP_OPTION , *PDHCP_OPTION ;

typedef struct _DHCP_OPTION_DEF {
    LIST_ENTRY                     OptionDefList; // list of option definitions
    BYTE                           OptionId;      // the option id
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         ClassName;     // the class this belongs to
    DWORD                          ClassLen;      // the size of above in bytes

    LPWSTR                         RegSendLoc;    // where is the info about sending this out
    LPWSTR                         RegSaveLoc;    // where is this option going to be stored?
    DWORD                          RegValueType;  // as what value should this be stored?
} DHCP_OPTION_DEF, *LPDHCP_OPTION_DEF, *PDHCP_OPTION_DEF;


//================================================================================
//  exported functions classes
//================================================================================

//--------------------------------------------------------------------------------
// In all of the following functions, ClassesList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------
LPBYTE                                            // data bytes, or NULL (no mem)
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
);  // Add the new class into the list or bump up ref count if already there

DWORD                                             // status (FILE_NOT_FOUND => no such class)
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
);  // decrease refcount in the list and if becomes zero, free the struct

VOID                                              // always succeeds
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
);  // free every class in the list

//--------------------------------------------------------------------------------
// In all the following functions, OptionsList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------

PDHCP_OPTION                                      // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen       // # of bytes of above parameter
);  // search for the required option in the list, return NULL if not found

DWORD                                             // status or ERROR_FILE_NOT_FOUND
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           Option2Delete  // delete this option
);  // delete an existing option in the list, and free up space used

DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      BYTE                   OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
);  // replace or add new option to the list.  fail if not enough memory

VOID                                              // always succeeds
DhcpFreeAllOptions(                               // frees all the options
    IN OUT  PLIST_ENTRY            OptionsList    // input list of options
);  // free every option in the list

time_t                                            // 0 || time for next expiry (absolute)
DhcpGetExpiredOptions(                            // delete all expired options
    IN OUT  PLIST_ENTRY            OptionsList,   // list to search frm
    OUT     PLIST_ENTRY            ExpiredOptions // o/p list of expired options
);  // move expired options between lists and return timer. 0 => switch off timer.

//--------------------------------------------------------------------------------
//  In all the following functions, OptionsDefList is unprotected.  Caller has
//  to take a lock on it.
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpAddOptionDef(                                 // add a new option definition
    IN OUT  PLIST_ENTRY            OptionDefList, // input list of options to add to
    IN      BYTE                   OptionId,      // option to add
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // name of class it belongs to
    IN      DWORD                  ClassLen,      // the size of above in bytes
    IN      LPWSTR                 RegSendLoc,    // where to get info about sending this out
    IN      LPWSTR                 RegSaveLoc,    // where to get info about saving this
    IN      DWORD                  ValueType      // what is the type when saving it?
);

PDHCP_OPTION_DEF                                  // NULL, or requested option def
DhcpFindOptionDef(                                // search for a particular option
    IN      PLIST_ENTRY            OptionDefList, // list to search in
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

DWORD                                             // status
DhcpDelOptionDef(                                 // delete a particular option def
    IN      PLIST_ENTRY            OptionDefList, // list to delete from
    IN      BYTE                   OptionId,      // the option id to delete
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

VOID
DhcpFreeAllOptionDefs(                            // free each element of a list
    IN OUT  PLIST_ENTRY            OptionDefList, // the list to free
    IN OUT  PLIST_ENTRY            ClassesList    // classes to de-ref off
);

BOOL                                              // TRUE==>found..
DhcpOptionsFindDomain(                            // find the domain name option values
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // for this adapter
    OUT     LPBYTE                *Data,          // fill this ptr up
    OUT     LPDWORD                DataLen
);

#endif  OPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\vdhcpapi.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    vdhcpapi.h

Abstract:

    Worker functions for VDHCP APIs.

Author:

    Madan Appiah (madana)  28-May-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef VDHCPAPI_H_
#define VDHCPAPI_H_

#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3

typedef struct _DHCP_NIC_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
    DWORD IpAddress;
    DWORD Lease;
    DWORD LeaseObtainedTime;
    DWORD LeaseExpiresTime;
    DWORD DhcpServerAddress;
    DWORD DNSServersLen;
    DWORD OffsetDNSServers;
    DWORD DomainNameLen;
    DWORD OffsetDomainName;
} DHCP_NIC_INFO, *LPDHCP_NIC_INFO;

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

typedef struct _DHCP_QUERYINFO {
    DWORD NumNICs;
    DHCP_NIC_INFO NicInfo[1];
} DHCP_QUERYINFO, *LPDHCP_QUERYINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
PASCAL FAR
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (PASCAL FAR * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\optreg.cxx ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------

#include <wininetp.h>
#include "aproxp.h"

#ifndef  OPTREG_H
#define  OPTREG_H

//--------------------------------------------------------------------------------
// function definitions
//--------------------------------------------------------------------------------

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);


#endif OPTREG_H

// internal private function that takes the lock on OPTIONS_LIST

DWORD                                             // status
DhcpRegClearOptDefs(                              // clear all standard options
    IN      LPTSTR                 AdapterName    // clear for this adapter
);


//
// options related lists
//


LIST_ENTRY DhcpGlobalRecvFromList;
LPSTR   DhcpGlobalClientClassInfo = NULL;


LPBYTE                                            // ptr to buf loc where more appends can occur
DhcpAppendParamRequestList(                       // append the param request list option
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to append for
    IN      PLIST_ENTRY            SendOptionsList,// look thru this list
    IN      LPBYTE                 ClassName,     // which class does this belong to?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 BufStart,      // where to start adding this option
    IN      LPBYTE                 BufEnd         // limit for this option
) {
    BYTE                           Buffer[OPTION_END+1];
    LPBYTE                         Tmp;
    DWORD                          FirstSize;
    DWORD                          Size;
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOpt;
    DWORD                          i, j;

    Size = FirstSize = 0;
    Buffer[Size++] = OPTION_SUBNET_MASK;          // standard requested options
    Buffer[Size++] = OPTION_DOMAIN_NAME;
    Buffer[Size++] = OPTION_ROUTER_ADDRESS;
    Buffer[Size++] = OPTION_DOMAIN_NAME_SERVERS;
    Buffer[Size++] = OPTION_NETBIOS_NAME_SERVER;
    Buffer[Size++] = OPTION_NETBIOS_NODE_TYPE;
    Buffer[Size++] = OPTION_NETBIOS_SCOPE_OPTION;
    Buffer[Size++] = OPTION_VENDOR_SPEC_INFO;
    Buffer[Size++] = OPTION_USER_CLASS;
    Buffer[Size++] = OPTION_WPAD_URL;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor) continue;

        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( OPTION_PARAMETER_REQUEST_LIST != ThisOpt->OptionId ) {
            //
            // only if the option is param_request_list do we request..
            //
            continue;
        }

        for( i = 0; i < ThisOpt->DataLen ; i ++ ) {
            for( j = 0; j < Size; j ++ )
                if( ThisOpt->Data[i] == Buffer[j] ) break;
            if( j < Size ) continue;              // option already plugged in
            Buffer[Size++] = ThisOpt->Data[i]; // add this option
        }

        if( 0 == FirstSize ) FirstSize = Size;
    }

    if( 0 == FirstSize ) FirstSize = Size;

    Tmp = BufStart;
    BufStart = (LPBYTE)DhcpAppendOption(          // now add the param request list
        (POPTION)BufStart,
        (BYTE)OPTION_PARAMETER_REQUEST_LIST,
        Buffer,
        (BYTE)Size,
        BufEnd
    );

    if( Tmp == BufStart ) {                       // did not really add the option
        BufStart = (LPBYTE)DhcpAppendOption(      // now try adding the first request we saw instead of everything
            (POPTION)BufStart,
            (BYTE)OPTION_PARAMETER_REQUEST_LIST,
            Buffer,
            (BYTE)FirstSize,
            BufEnd
        );
    }

    return BufStart;
}

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOpt;

    DhcpAssert(FALSE == SentOptions[OPTION_PARAMETER_REQUEST_LIST]);
    BufStart = DhcpAppendParamRequestList(
        DhcpContext,
        SendOptionsList,
        ClassName,
        ClassLen,
        BufStart,
        BufEnd
    );
    SentOptions[OPTION_PARAMETER_REQUEST_LIST] = TRUE;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor ? VSentOptions[ThisOpt->OptionId] : SentOptions[ThisOpt->OptionId] )
            continue;

        // if( ThisOpt->IsVendor) continue;       // No vendor specific information this round through
        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( !ThisOpt->IsVendor ) {                // easy to add non-vendor spec options
            SentOptions[ThisOpt->OptionId] = TRUE;
            BufStart = (LPBYTE)DhcpAppendOption(
                (POPTION)BufStart,
                ThisOpt->OptionId,
                ThisOpt->Data,
                (BYTE)ThisOpt->DataLen,
                BufEnd
            );
        } else {                                  // ENCAPSULATE vendor specific options
            if( SentOptions[OPTION_VENDOR_SPEC_INFO] )
                continue;                         // Vendor spec info already added

            VSentOptions[ThisOpt->OptionId] = TRUE;

            if( ThisOpt->DataLen + 2 + *VendorOptLen > OPTION_END )
                continue;                         // this option overflows the buffer

            VendorOpt[(*VendorOptLen)++] = ThisOpt->OptionId;
            VendorOpt[(*VendorOptLen)++] = (BYTE)ThisOpt->DataLen;
            memcpy(&VendorOpt[*VendorOptLen], ThisOpt->Data, ThisOpt->DataLen);
            (*VendorOptLen) += ThisOpt->DataLen;
        }
    }
    return (POPTION)BufStart;
}


DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;
    DWORD                          Error;
    DWORD                          LastError;

    LastError = ERROR_SUCCESS;
    while(!IsListEmpty(OptionsList) ) {           // for each element of this list
        ThisEntry  = RemoveHeadList(OptionsList);
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        if( NULL != ThisOption->ClassName ) {     // if there is a class, deref it
            Error = DhcpDelClass(
                ClassesList,
                ThisOption->ClassName,
                ThisOption->ClassLen
            );
            if( ERROR_SUCCESS != Error ) {
                DhcpAssert( ERROR_SUCCESS == Error);
                LastError = Error;
            }
        }

        DhcpFreeMemory(ThisOption);               // now really free this
    }
    return LastError;
}

DWORD                                             // win32 status
DhcpClearAllOptions(                              // clear all the options information
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;
    DWORD                          LocalError;

    //(void) DhcpRegClearOptDefs(DhcpContext->AdapterName));

    ThisEntry = DhcpContext->RecdOptionsList.Flink;
    while(ThisEntry != &DhcpContext->RecdOptionsList) {
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry  = ThisEntry->Flink;

        // bug bug, need to return space?
        ThisOption->Data = NULL;
        ThisOption->DataLen = 0;

        //LocalError = DhcpMarkParamChangeRequests(
        //    DhcpContext->AdapterName,
        //    ThisOption->OptionId,
        //    ThisOption->IsVendor,
        //    ThisOption->ClassName
        //);
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }
    return ERROR_SUCCESS;
}

POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
) {
    DWORD                          Size;

    Size = (DWORD)(BufEnd - BufStart);

    if( DhcpContext->ClassId ) {
        DhcpAssert(DhcpContext->ClassIdLength);
        BufStart = (LPBYTE)DhcpAppendOption(
            (POPTION)BufStart,
            OPTION_USER_CLASS,
            DhcpContext->ClassId,
            (BYTE)DhcpContext->ClassIdLength,
            BufEnd
        );
    }

    return (POPTION) BufStart;
}

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;

    if ( OptionType == OPTION_END ) {

        //
        // we should alway have atleast one BYTE space in the buffer
        // to append this option.
        //

        DhcpAssert( (LPBYTE)Option < OptionEnd );


        Option->OptionType = OPTION_END;
        return( (LPOPTION) ((LPBYTE)(Option) + 1) );

    }

    if ( OptionType == OPTION_PAD ) {

        //
        // add this option only iff we have enough space in the buffer.
        //

        if(((LPBYTE)Option + 1) < (OptionEnd - 1) ) {
            Option->OptionType = OPTION_PAD;
            return( (LPOPTION) ((LPBYTE)(Option) + 1) );
        }

        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)Option + 2 + OptionLength) >= (OptionEnd - 1) ) {
        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    if( OptionLength <= 0xFF ) {
        // simple option.. no need to use OPTION_MSFT_CONTINUED
        Option->OptionType = OptionType;
        Option->OptionLength = (BYTE)OptionLength;
        memcpy( Option->OptionValue, OptionValue, OptionLength );
        return( (LPOPTION) ((LPBYTE)(Option) + Option->OptionLength + 2) );
    }

    // option size is > 0xFF --> need to continue it using multiple ones..
    // there are OptionLenght / 0xFF occurances using 0xFF+2 bytes + one
    // using 2 + (OptionLength % 0xFF ) space..

    // check to see if we have the space first..

    if( 2 + (OptionLength%0xFF) + 0x101*(OptionLength/0xFF)
        + (LPBYTE)Option >= (OptionEnd - 1) ) {
        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    // first finish off all chunks of 0xFF size that we can do..

    i = OptionLength/0xFF;
    while(i) {
        Option->OptionType = OptionType;
        Option->OptionLength = 0xFF;
        memcpy(Option->OptionValue, OptionValue, 0xFF);
        OptionValue = 0xFF+(LPBYTE)OptionValue;
        Option = (LPOPTION)(0x101 + (LPBYTE)Option);
        OptionType = OPTION_MSFT_CONTINUED;       // all but the first use this ...
        OptionLength -= 0xFF;
    }

    // now finish off the remaining stuff..
    DhcpAssert(OptionLength <= 0xFF);
    Option->OptionType = OPTION_MSFT_CONTINUED;
    Option->OptionLength = (BYTE)OptionLength;
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (LPOPTION)(2 + OptionLength + (LPBYTE)Option);
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}


LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd
    )
/*++

Routine Description:

    This routine appends magic cookie to a DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.

    Note : The magic cookie is :

     --------------------
    | 99 | 130 | 83 | 99 |
     --------------------

--*/
{
    DhcpAssert( (Option + 4) < (OptionEnd - 1) );
    if( (Option + 4) < (OptionEnd - 1) ) {
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE1;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE2;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE3;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE4;
    }

    return( Option );
}

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    )
/*++

Routine Description:

    This routine appends client ID option to a DHCP message.

History:
    8/26/96 Frankbee    Removed 16 byte limitation on the hardware
                        address

Arguments:

    Option - A pointer to the place to append the option request.

    ClientHWType - Client hardware type.

    ClientHWAddr - Client hardware address

    ClientHWAddrLength - Client hardware address length.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the newly appended option.

    Note : The client ID option will look like as below in the message:

     -----------------------------------------------------------------
    | OpNum | Len | HWType | HWA1 | HWA2 | .....               | HWAn |
     -----------------------------------------------------------------

--*/
{
#pragma warning(disable : 4200) // disable 0-sized array warning

    struct _CLIENT_ID {
        BYTE    bHardwareAddressType;
        BYTE    pbHardwareAddress[0];
    } *pClientID;


    LPOPTION lpNewOption;

    pClientID = (_CLIENT_ID *) DhcpAllocateMemory( sizeof( struct _CLIENT_ID ) + ClientHWAddrLength );

    //
    // currently there is no way to indicate failure.  simply return unmodified option
    // list
    //

    if ( !pClientID )
        return Option;

    pClientID->bHardwareAddressType    = ClientHWType;
    memcpy( pClientID->pbHardwareAddress, ClientHWAddr, ClientHWAddrLength );

    lpNewOption =  DhcpAppendOption(
                         Option,
                         OPTION_CLIENT_ID,
                         (LPBYTE)pClientID,
                         (BYTE)(ClientHWAddrLength + sizeof(BYTE)),
                         OptionEnd );

    DhcpFreeMemory( pClientID );

    return lpNewOption;
}

// data locks on ClassesList must be taken before calling this function
PDHCP_CLASSES PRIVATE                             // the required classes struct
DhcpFindClass(                                    // find a specified class
    IN OUT  PLIST_ENTRY            ClassesList,   // list of classes to srch in
    IN      LPBYTE                 Data,          // non-NULL data bytes
    IN      DWORD                  Len            // # of bytes of above, > 0
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_CLASSES                  ThisClass;

    ThisEntry = ClassesList->Flink;               // first element in list
    while( ThisEntry != ClassesList ) {           // search the full list
        ThisClass = CONTAINING_RECORD( ThisEntry, DHCP_CLASSES, ClassList );
        ThisEntry = ThisEntry->Flink;

        if( ThisClass->ClassLen == Len ) {        // lengths must match
            if( ThisClass->ClassName == Data )    // data ptrs can match OR data can match
                return ThisClass;
            if( 0 == memcmp(ThisClass->ClassName, Data, Len) )
                return ThisClass;
        }
    }
    return NULL;
}

// locks on ClassesList should be taken when using this function
LPBYTE                                            // data bytes, or NULL
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
) {
    PDHCP_CLASSES                  Class;
    DWORD                          MemSize;       // amt of memory reqd

    if( NULL == ClassesList ) {                   // invalid parameter
        DhcpAssert( NULL != ClassesList );
        return NULL;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameters
        DhcpAssert(0 != Len && NULL != Data );
        return NULL;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);  // already there in list?
    if(NULL != Class) {                           // yes, found
        Class->RefCount++;                        // increase ref-count
        return Class->ClassName;
    }

    MemSize = sizeof(*Class)+Len;                 // amt of memory reqd
    Class = (PDHCP_CLASSES) DhcpAllocateMemory(MemSize);
    if( NULL == Class ) {                         // not enough memory
        DhcpAssert( NULL != Class);
        return NULL;
    }

    Class->ClassLen = Len;
    Class->RefCount = 1;
    Class->ClassName = ((LPBYTE)Class) + sizeof(*Class);
    memcpy(Class->ClassName, Data, Len);

    InsertHeadList(ClassesList, &Class->ClassList);

    return Class->ClassName;
}

// locks on ClassesList must be taken before calling this function
DWORD                                             // status
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
) {
    PDHCP_CLASSES                  Class;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameter
        DhcpAssert( 0 != Len && NULL != Data );
        return ERROR_INVALID_PARAMETER;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);
    if( NULL == Class ) {                         // did not find this class?
        DhcpAssert( NULL != Class );
        return ERROR_FILE_NOT_FOUND;
    }

    Class->RefCount --;
    if( 0 == Class->RefCount ) {                  // all references removed
        RemoveEntryList( &Class->ClassList );     // remove this from the list
        DhcpFreeMemory(Class);                    // free it
    }

    return ERROR_SUCCESS;
}

// locks on ClassesList must be taken before calling this function
VOID                                              // always succeed
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
) {
    PDHCP_CLASSES                  ThisClass;
    PLIST_ENTRY                    ThisEntry;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList && "DhcpFreeAllClasses" );
        return ;
    }

    while( !IsListEmpty(ClassesList) ) {
        ThisEntry = RemoveHeadList(ClassesList);
        ThisClass = CONTAINING_RECORD(ThisEntry, DHCP_CLASSES, ClassList);

        if( ThisClass->RefCount ) {
            DhcpPrint(("Freeing with refcount = %ld\n", ThisClass->RefCount));
        }

        DhcpFreeMemory(ThisClass);
    }

    InitializeListHead(ClassesList);
}

//--------------------------------------------------------------------------------
// exported functions, options
//--------------------------------------------------------------------------------

// data locks need to be taken on OptionsList before calling this function
PDHCP_OPTION                                     // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen       // # of bytes of above parameter
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOption;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList );
        return NULL;
    }

    ThisEntry = OptionsList->Flink;
    while( ThisEntry != OptionsList ) {           // search the set of options
        ThisOption = CONTAINING_RECORD( ThisEntry, DHCP_OPTION, OptionList );
        ThisEntry  = ThisEntry->Flink;

        if( ThisOption->OptionId != OptionId ) continue;
        if( ThisOption->IsVendor != IsVendor ) continue;
        if( ThisOption->ClassLen != ClassLen ) continue;
        if( ClassLen && ThisOption->ClassName != ClassName )
            continue;                             // mismatched so far

        return ThisOption;                        // found the option
    }

    return NULL;                                  // did not find any match
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           ThisOption     // option to delete
) {
    if( NULL == ThisOption)                       // nope, did not find this option
        return ERROR_FILE_NOT_FOUND;

    RemoveEntryList( &ThisOption->OptionList);    // found it.  remove and free
    DhcpFreeMemory(ThisOption);

    return ERROR_SUCCESS;
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      BYTE                   OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
) {
    PDHCP_OPTION                  ThisOption;
    DWORD                          MemSize;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != ClassLen && NULL == ClassName ) {
        DhcpAssert( 0 == ClassLen || NULL != ClassName && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != DataLen && NULL == Data ) {
        DhcpAssert( 0 == DataLen || NULL != Data && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    MemSize = sizeof(DHCP_OPTION) + DataLen ;
    ThisOption = (PDHCP_OPTION) DhcpAllocateMemory(MemSize);
    if( NULL == ThisOption )                      // could not allocate memory
        return ERROR_NOT_ENOUGH_MEMORY;

    ThisOption->OptionId   = OptionId;
    ThisOption->IsVendor   = IsVendor;
    ThisOption->ClassName  = ClassName;
    ThisOption->ClassLen   = ClassLen;
    ThisOption->ExpiryTime = ExpiryTime;
    ThisOption->DataLen    = DataLen;
    ThisOption->Data       = ((LPBYTE)ThisOption) + sizeof(DHCP_OPTION);
    memcpy(ThisOption->Data, Data, DataLen);

    InsertHeadList( OptionsList, &ThisOption->OptionList );

    return ERROR_SUCCESS;
}



//================================================================================
//   end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\htuu.h ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com
 */

/*                              ENCODING TO PRINTABLE CHARACTERS

   File module provides functions HTUU_encode() and HTUU_decode() which convert a buffer
   of bytes to/from RFC 1113 printable encoding format. This technique is similar to the
   familiar Unix uuencode format in that it maps 6 binary bits to one ASCII character (or
   more aptly, 3 binary bytes to 4 ASCII characters).  However, RFC 1113 does not use the
   same mapping to printable characters as uuencode.

	Ported to WinINet Plug In DLL by arthurbi Dec-23-1995

 */

#ifndef HTUU_H
#define HTUU_H

#ifdef __cplusplus
extern "C" {
#endif

int HTUU_encode(unsigned char *bufin,
				unsigned int nbytes,
				char *bufcoded,
                long outbufmax);

int HTUU_decode(char *bufcoded,
				unsigned char *bufplain,
				int outbufsize);

#ifdef __cplusplus
} // end extern "C"
#endif

#endif
/*

   End of file.  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\protocol.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    protocol.cxx

Abstract:

    This module contains the server to client protocol for DHCP.

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

    Arthur Bierer (arthurbi) 15-July-1998
        hacked up to use with Wininet's auto-proxy detection code

--*/

#include <wininetp.h>
#include "aproxp.h"

#include "apdetect.h"

#ifndef VXD
// ping routines.. ICMP
#include <ipexport.h>
//#include <icmpif.h>
#include <icmpapi.h>
#endif

#ifdef NEWNT
extern BOOL DhcpGlobalIsService;
#endif // NEWNT

DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
);


POPTION
FormatDhcpInform(
    PDHCP_CONTEXT DhcpContext
);

DWORD
SendDhcpInform(
    PDHCP_CONTEXT DhcpContext,
    PDWORD TransactionId
);

DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait, // how many acks to wait for
    OUT     DHCP_EXPECTED_OPTIONS *pExpectedOptions // list of things parsed out of request
);

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  DWORD                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen       // if !LiteOnly this gives the # of bytes of classname
);

DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    );

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    );

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

//
// functions
//


DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
) {
    DWORD                          MilliSecs;
    //DWORD                          WaitTimes[4] = { 4000, 8000, 16000, 32000 };
    DWORD                          WaitTimes[4] = { 2000, 4000, 8000, 16000 };

    if( WaitMilliSecs ) *WaitMilliSecs = 0;
    if( RoundNum >= sizeof(WaitTimes)/sizeof(WaitTimes[0]) )
        return 0;

    MilliSecs = WaitTimes[RoundNum] - 1000 + ((rand()*((DWORD) 2000))/RAND_MAX);
    if( WaitMilliSecs ) *WaitMilliSecs = MilliSecs;

    return (MilliSecs + 501)/1000;
}


VOID        _inline
ConcatOption(
    IN OUT  LPBYTE                *Buf,           // input buffer to re-alloc
    IN OUT  ULONG                 *BufSize,       // input buffer size
    IN      BYTE UNALIGNED        *Data,          // data to append
    IN      ULONG                  DataSize       // how many bytes to add?
)
{
    LPBYTE                         NewBuf;
    ULONG                          NewSize;

    NewSize = (*BufSize) + DataSize;
    NewBuf = (LPBYTE) DhcpAllocateMemory(NewSize);
    if( NULL == NewBuf ) {                        // could not alloc memory?
        return;                                   // can't do much
    }

    memcpy(NewBuf, *Buf, *BufSize);               // copy existing part
    memcpy(NewBuf + *BufSize, Data, DataSize);    // copy new stuff

    if( NULL != *Buf ) DhcpFreeMemory(*Buf);      // if we alloc'ed mem, free it now
    *Buf = NewBuf;
    *BufSize = NewSize;                           // fill in new values..
}

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  DWORD                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen       // if !LiteOnly this gives the # of bytes of classname
) {
    BYTE    UNALIGNED*             ThisOpt;
    BYTE    UNALIGNED*             NextOpt;
    BYTE    UNALIGNED*             EndOpt;
    BYTE    UNALIGNED*             MagicCookie;
    DWORD                          Error;
    DWORD                          Size, ThisSize, UClassSize = 0;
    LPBYTE                         UClass= NULL;  // concatenation of all OPTION_USER_CLASS options
    PDHCP_EXPECTED_OPTIONS         ExpOptions;
    PDHCP_FULL_OPTIONS             FullOptions;
    BYTE                           ReqdCookie[] = {
        (BYTE)DHCP_MAGIC_COOKIE_BYTE1,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE2,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE3,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE4
    };


    EndOpt = OptStart + MessageSize;              // all options should be < EndOpt;
    ExpOptions = (PDHCP_EXPECTED_OPTIONS)DhcpOptions;
    FullOptions = (PDHCP_FULL_OPTIONS)DhcpOptions;
    RtlZeroMemory((LPBYTE)DhcpOptions, LiteOnly?sizeof(*ExpOptions):sizeof(*FullOptions));
    // if(!LiteOnly) InitializeListHead(RecdOptions); -- clear off this list for getting ALL options
    // dont clear off options... just accumulate over..

    MagicCookie = OptStart;
    if( 0 == MessageSize ) goto DropPkt;          // nothing to do in this case
    if( 0 != memcmp(MagicCookie, ReqdCookie, sizeof(ReqdCookie)) )
        goto DropPkt;                             // oops, cant handle this packet

    NextOpt = &MagicCookie[sizeof(ReqdCookie)];
    while( NextOpt < EndOpt && OPTION_END != *NextOpt ) {
        if( OPTION_PAD == *NextOpt ) {            // handle pads right away
            NextOpt++;
            continue;
        }

        ThisOpt = NextOpt;                        // take a good look at this option
        if( NextOpt + 2 >  EndOpt ) {             // goes over boundary?
            break;
        }

        NextOpt += 2 + (unsigned)ThisOpt[1];      // Option[1] holds the size of this option
        Size = ThisOpt[1];

        if( NextOpt > EndOpt ) {                  // illegal option that goes over boundary!
            break;                                // ignore the error, but dont take this option
        }

        if(!LiteOnly) do {                        // look for any OPTION_MSFT_CONTINUED ..
            if( NextOpt >= EndOpt ) break;        // no more options
            if( OPTION_MSFT_CONTINUED != NextOpt[0] ) break;
            if( NextOpt + 1 + NextOpt[1] > EndOpt ) {
                NextOpt = NULL;                   // do this so that we know to quit at the end..
                break;
            }

            NextOpt++;                            // skip opt code
            ThisSize = NextOpt[0];                // # of bytes to shift back..
            memcpy(ThisOpt+2+Size, NextOpt+1,ThisSize);
            NextOpt += ThisSize+1;
            Size += ThisSize;
        } while(1);                               // keep stringing up any "continued" options..

        if( NULL == NextOpt ) {                   // err parsing OPTION_MSFT_CONTINUED ..
            break;
        }

        if( LiteOnly ) {                          // handle the small subnet of options
            switch( ThisOpt[0] ) {                // ThisOpt[0] is OptionId, ThisOpt[1] is size
            case OPTION_MESSAGE_TYPE:
                if( ThisOpt[1] != 1 ) goto DropPkt;
                ExpOptions->MessageType = &ThisOpt[2];
                continue;
            case OPTION_SUBNET_MASK:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_LEASE_TIME:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_SERVER_IDENTIFIER:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_DOMAIN_NAME:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->DomainNameSize = ThisOpt[1];
                break;
            case OPTION_WPAD_URL:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->WpadUrl = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->WpadUrlSize = ThisOpt[1];
                break;

            default:
                continue;
            }
        } else {                                  // Handle the full set of options
            switch( ThisOpt[0] ) {
            case OPTION_MESSAGE_TYPE:
                if( Size != 1 ) goto DropPkt;
                FullOptions->MessageType = &ThisOpt[2];
                break;
            case OPTION_SUBNET_MASK:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_LEASE_TIME:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_SERVER_IDENTIFIER:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_RENEWAL_TIME:             // T1Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T1Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_REBIND_TIME:              // T2Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T2Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_ROUTER_ADDRESS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ) )
                    goto DropPkt;                 // There can be many router addresses
                FullOptions->GatewayAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nGateways = Size / sizeof(DWORD);
                break;
            case OPTION_STATIC_ROUTES:
                if( Size < 2*sizeof(DWORD) || (Size % (2*sizeof(DWORD))) )
                    goto DropPkt;                 // the static routes come in pairs
                FullOptions->StaticRouteAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nStaticRoutes = Size/(2*sizeof(DWORD));
                break;
            case OPTION_DYNDNS_BOTH:
                if( Size < 3 ) goto DropPkt;
                FullOptions->DnsFlags = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DnsRcode1 = (BYTE UNALIGNED *)&ThisOpt[3];
                FullOptions->DnsRcode2 = (BYTE UNALIGNED *)&ThisOpt[3];
                break;
            case OPTION_DOMAIN_NAME:
                if( Size == 0 ) goto DropPkt;
                FullOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DomainNameSize = Size;
                break;
            case OPTION_WPAD_URL:
                if( Size == 0 ) goto DropPkt;
                FullOptions->WpadUrl = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->WpadUrlSize = Size;
                break;
            case OPTION_DOMAIN_NAME_SERVERS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ))
                    goto DropPkt;
                FullOptions->DnsServerList = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nDnsServers = Size / sizeof(DWORD);
                break;
            case OPTION_MESSAGE:
                if( Size == 0 ) break;      // ignore zero sized packets
                FullOptions->ServerMessage = &ThisOpt[2];
                FullOptions->ServerMessageLength = ThisOpt[1];
                break;
            case OPTION_MCAST_LEASE_START:
                if ( Size != sizeof(DATE_TIME) ) goto DropPkt;
                FullOptions->MCastLeaseStartTime = (DWORD UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_MCAST_TTL:
                if ( Size != 1 ) goto DropPkt;
                FullOptions->MCastTTL = (BYTE UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_USER_CLASS:
                if( Size <= 6) goto DropPkt;
                ConcatOption(&UClass, &UClassSize, &ThisOpt[2], Size);
                continue;                         // don't add this option yet...

            default:
                // unknowm message, nothing to do.. especially dont log this
                break;
            }

        } // if LiteOnly then else
    } // while NextOpt < EndOpt

    if( LiteOnly && LeaseExpiry ) {               // If asked to calculate lease expiration time..
        DWORD    LeaseTime;
        time_t   TimeNow, ExpirationTime;

        // BBUGBUGBUG [arthurbi] broken intensionlly, dead code.
        //if( ExpOptions->LeaseTime ) LeaseTime = _I_ntohl(*ExpOptions->LeaseTime);
        if( ExpOptions->LeaseTime ) LeaseTime = 0;
        else LeaseTime = DHCP_MINIMUM_LEASE;
        ExpirationTime = (TimeNow = time(NULL)) + (time_t)LeaseTime;
        if( ExpirationTime < TimeNow ) {
            ExpirationTime = INFINIT_TIME;
        }

        *LeaseExpiry = (DWORD)ExpirationTime ;
    }

    if( !LiteOnly && NULL != UClass ) {           // we have a user class list to pass on..
        DhcpAssert(UClassSize != 0 );             // we better have something here..
        DhcpFreeMemory(UClass); UClass = NULL;
    }

    return;

  DropPkt:
    RtlZeroMemory(DhcpOptions, LiteOnly?sizeof(ExpOptions):sizeof(FullOptions));
    if( LiteOnly && LeaseExpiry ) *LeaseExpiry = (DWORD) time(NULL) + DHCP_MINIMUM_LEASE;
    //if(!LiteOnly) DhcpFreeAllOptions(RecdOptions);// ok undo the options that we just added
    if(!LiteOnly && NULL != UClass ) DhcpFreeMemory(UClass);
}

POPTION                                           // ptr to add additional options
FormatDhcpInform(                                 // format the packet for an INFORM
    IN      PDHCP_CONTEXT          DhcpContext    // format for this context
) {
    LPOPTION option;
    LPBYTE OptionEnd;

    BYTE value;
    PDHCP_MESSAGE dhcpMessage;


    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    //
    // BUGBUG [arthurbi] - 
    // For RAS client, use broadcast bit, otherwise the router will try
    // to send as unicast to made-up RAS client hardware address, which
    // will not work.  So will this work without it?
    //

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->Operation             = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType   = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot      = (WORD) DhcpContext->SecondsSinceBoot;
    memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
    dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    dhcpMessage->ClientIpAddress       = DhcpContext->IpAddress;
    //dhcpMessage->Reserved = 0;
    //dhcpMessage->Reserved = _I_htons(DHCP_BROADCAST);
    //if ( IS_MDHCP_CTX(DhcpContext ) ) MDHCP_MESSAGE( dhcpMessage );

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_INFORM_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &value,
        1,
        OptionEnd
    );

    //
    // BUGBUG [arthurbi], shouldn't we uncomment this?
    //

    // un comment later on
    /*option = DhcpAppendClassIdOption(
        DhcpContext,
        (LPBYTE)option,
        OptionEnd
    );*/

    return( option );
}


DWORD                                             // status
SendDhcpInform(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    DWORD                          Error;
    POPTION                        option;
    LPBYTE                         OptionEnd;
    BYTE                           SentOpt[OPTION_END+1];
    BYTE                           SentVOpt[OPTION_END+1];
    BYTE                           VendorOpt[OPTION_END+1];
    DWORD                          VendorOptSize;

    RtlZeroMemory(SentOpt, sizeof(SentOpt));      // initialize boolean arrays
    RtlZeroMemory(SentVOpt, sizeof(SentVOpt));    // so that no option is presumed sent
    VendorOptSize = 0;                            // encapsulated vendor option is empty
    option = FormatDhcpInform( DhcpContext );     // core format

    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if( DhcpContext->ClientIdentifier.fSpecified) // client id specified in registy
        option = DhcpAppendClientIDOption(        // ==> use this client id as option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else                                          // client id was not specified
        option = DhcpAppendClientIDOption(        // ==> use hw addr as client id
            option,
            DhcpContext->HardwareAddressType,
            DhcpContext->HardwareAddress,
            (BYTE)DhcpContext->HardwareAddressLength,
            OptionEnd
        );

    {   // add hostname and comment options
        char szHostName[255];

        if ( _I_gethostname(szHostName, ARRAY_ELEMENTS(szHostName)) != SOCKET_ERROR  ) 
        {
            option = DhcpAppendOption(
                option,
                OPTION_HOST_NAME,
                (LPBYTE)szHostName,
                (BYTE)((strlen(szHostName) + 1) * sizeof(CHAR)),
                OptionEnd
            );
        }
    }

    if( NULL != DhcpGlobalClientClassInfo ) {     // if we have any info on client class..
        option = DhcpAppendOption(
            option,
            OPTION_CLIENT_CLASS_INFO,
            (LPBYTE)DhcpGlobalClientClassInfo,
            strlen(DhcpGlobalClientClassInfo),
            OptionEnd
        );
    }

    SentOpt[OPTION_MESSAGE_TYPE] = TRUE;          // these must have been added by now
    if(DhcpContext->ClassIdLength) SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_CLIENT_CLASS_INFO] = TRUE;
    SentOpt[OPTION_CLIENT_ID] = TRUE;
    SentOpt[OPTION_REQUESTED_ADDRESS] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;

    option = DhcpAppendSendOptions(               // append all other options we need to send
        DhcpContext,                              // for this context
        &DhcpContext->SendOptionsList,            // this is the list of options to send out
        DhcpContext->ClassId,                     // which class.
        DhcpContext->ClassIdLength,               // how many bytes are there in the class id
        (LPBYTE)option,                           // start of the buffer to add the options
        (LPBYTE)OptionEnd,                        // end of the buffer up to which we can add options
        SentOpt,                                  // this is the boolean array that marks what opt were sent
        SentVOpt,                                 // this is for vendor spec options
        VendorOpt,                                // this would contain some vendor specific options
        &VendorOptSize                            // the # of bytes of vendor options added to VendorOpt param
    );

    if( !SentOpt[OPTION_VENDOR_SPEC_INFO] && VendorOptSize && VendorOptSize <= OPTION_END )
        option = DhcpAppendOption(                // add vendor specific options if we havent already sent it
            option,
            OPTION_VENDOR_SPEC_INFO,
            VendorOpt,
            (BYTE)VendorOptSize,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MessageBuffer);

    return  SendDhcpMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD
InitializeDhcpSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function initializes and binds a socket to the specified IP address.

Arguments:

    Socket - Returns a pointer to the initialized socket.

    IpAddress - The IP address to bind the socket to.  It is legitimate
        to bind a socket to 0.0.0.0 if the card has no current IP address.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    DWORD closeError;
    DWORD value;
    struct sockaddr_in socketName;
    DWORD i;
    SOCKET sock;

    //
    // Sockets initialization
    //

    sock = _I_socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( sock == INVALID_SOCKET ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("socket failed, error = %ld\n", error ));
        return( error );
    }

    //
    // Make the socket share-able
    //

    value = 1;

    error = _I_setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("setsockopt failed, err = %ld\n", error ));

        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    error = _I_setsockopt( sock, SOL_SOCKET, SO_BROADCAST, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("setsockopt failed, err = %ld\n", error ));

        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    //
    // If the IpAddress is zero, set the special socket option to make
    // stack work with zero address.
    //

    if( IpAddress == 0 ) {
        value = 1234;
        error = _I_setsockopt( sock, SOL_SOCKET, 0x8000, (char FAR *)&value, sizeof(value) );
        if ( error != 0 ) {
            error = _I_WSAGetLastError();
            DhcpPrint(("setsockopt failed, err = %ld\n", error ));

            closeError = _I_closesocket( sock );
            if ( closeError != 0 ) {
                DhcpPrint(("closesocket failed, err = %d\n", closeError ));
            }
            return( error );
        }
    }

    socketName.sin_family = PF_INET;
    socketName.sin_port = _I_htons( DHCP_CLIENT_PORT );
    socketName.sin_addr.s_addr = IpAddress;

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    //
    // Bind this socket to the DHCP server port
    //

    error = _I_bind(
               sock,
               (struct sockaddr FAR *)&socketName,
               sizeof( socketName )
               );

    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("bind failed (address 0x%lx), err = %ld\n", IpAddress, error ));
        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    *Socket = sock;
    return( NO_ERROR );
}


DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait, // how many acks to wait for
    OUT     DHCP_EXPECTED_OPTIONS *pExpectedOptions // list of things parsed out of request
) {
    time_t                         StartTime;
    time_t                         TimeNow;
    DWORD                          TimeToWait;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          MessageSize;
    DWORD                          RoundNum;
    DWORD                          MessageCount;
    DWORD                          LeaseExpirationTime;
    DHCP_FULL_OPTIONS              FullOptions;

    DhcpPrint(("SendInformAndGetReplies entered\n"));

    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS) {
        DhcpPrint(("Could not open socket for this interface! (%ld)\n", Error));
        return Error;
    }

    Xid                           = 0;            // Will be generated by first SendDhcpPacket
    MessageCount                  = 0;            // total # of messages we have got

    DhcpContext->SecondsSinceBoot = 0;            // start at zero..
    for( RoundNum = 0; RoundNum < nInformsToSend;  RoundNum ++ ) {
        Error = SendDhcpInform(DhcpContext, &Xid);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(("SendDhcpInform: %ld\n", Error));
            goto Cleanup;
        } else {
            DhcpPrint(("Sent DhcpInform\n"));
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        DhcpContext->SecondsSinceBoot += TimeToWait; // do this so that next time thru it can go thru relays..
        StartTime  = time(NULL);
        while ( TRUE ) {                          // wiat for the specified wait time
            MessageSize =  DHCP_MESSAGE_SIZE;

            DhcpPrint(("Waiting for ACK[Xid=%x]: %ld seconds\n",Xid, TimeToWait));
            Error = GetSpecifiedDhcpMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );
            if ( Error == ERROR_SEM_TIMEOUT ) break;
            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(("GetSpecifiedDhcpMessage: %ld\n", Error));
                goto Cleanup;
            }

            DhcpExtractFullOrLiteOptions(         // Need to see if this is an ACK
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // do lite extract only
                pExpectedOptions,                 // check for only expected options
                NULL,                             // unused
                &LeaseExpirationTime,
                NULL,                             // unused
                0                                 // unused
            );

            if( NULL == pExpectedOptions->MessageType ) {
                DhcpPrint(("Received no message type!\n"));
            } else if( DHCP_ACK_MESSAGE != *(pExpectedOptions->MessageType) ) {
                DhcpPrint(("Received unexpected message type: %ld\n", *(pExpectedOptions->MessageType)));
            } else if( NULL == pExpectedOptions->ServerIdentifier ) {
                DhcpPrint(("Received no server identifier, dropping inform ACK\n"));
            } else {
                MessageCount ++;
                DhcpPrint(("Received %ld ACKS so far\n", MessageCount));
                DhcpExtractFullOrLiteOptions(     // do FULL options..
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MessageBuffer->Option,
                    MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                    FALSE,
                    &FullOptions,
                    &(DhcpContext->RecdOptionsList),
                    &LeaseExpirationTime,
                    DhcpContext->ClassId,
                    DhcpContext->ClassIdLength
                );
                if( MessageCount >= MaxAcksToWait ) goto Cleanup;
            } // if( it is an ACK and ServerId present )

            TimeNow     = time(NULL);             // Reset the time values to reflect new time
            if( TimeToWait < (DWORD) (TimeNow - StartTime) ) {
                break;                            // no more time left to wait..
            }
            TimeToWait -= (DWORD)(TimeNow - StartTime);  // recalculate time now
            StartTime   = TimeNow;                // reset start time also
        } // end of while ( TimeToWait > 0)
    } // for (RoundNum = 0; RoundNum < nInformsToSend ; RoundNum ++ )

  Cleanup:
    CloseDhcpSocket(DhcpContext);
    if( MessageCount ) Error = ERROR_SUCCESS;
    DhcpPrint(("SendInformAndGetReplies: got %d ACKS (returning %ld)\n", MessageCount,Error));
    return Error;
}

//--------------------------------------------------------------------------------
//  This function gets the options from the server using DHCP_INFORM message.
//  It picks the first ACK and then processes it.
//  It ignores any errors caused by TIME_OUTS as that only means there is no
//  server, or the server does not have this functionality.  No point giving up
//  because of that.
//--------------------------------------------------------------------------------
BOOL                                              // win32 status
DhcpDoInform(                                     // send an inform packet if necessary
    IN      CAdapterInterface *    pAdapterInterface,
    IN      BOOL                   fBroadcast,    // Do we broadcast this inform, or unicast to server?
    OUT     LPSTR                  lpszAutoProxyUrl,
    IN      DWORD                  dwAutoProxyUrlLength
) {
    DHCP_CONTEXT                   StackDhcpContext;   // input context to do inform on
    PDHCP_CONTEXT                  DhcpContext = &StackDhcpContext;
    DWORD                          Error;
    DWORD                          LocalError;
    BOOL                           WasPlumbedBefore;
    time_t                         OldT2Time;
    DHCP_EXPECTED_OPTIONS          ExpectedOptions;

    *lpszAutoProxyUrl = '\0';
           
    if ( ! pAdapterInterface->IsDhcp() ) {
        return FALSE;
    }

    if (! pAdapterInterface->CopyAdapterInfoToDhcpContext(DhcpContext) ) {
        return FALSE;
    }
   
    // mdhcp uses INADDR_ANY so it does not have to have an ipaddress.
    if( 0 == DhcpContext->IpAddress && !IS_MDHCP_CTX( DhcpContext) ) {
        DhcpPrint(("Cannot do DhcpInform on an adapter without ip address!\n"));
        return FALSE;
    }

    // Open the socket ahead... so that things work. Tricky, else does not work!!!
    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS ) {
        DhcpPrint(("Could not open socket (%ld)\n", Error));
        return FALSE;
    }

    // If you always need to broadcast this message, the KLUDGE is to
    // set pContext->T2Time = 0; and pContext->fFlags &= ~DHCP_CONTEXT_FLAGS_PLUMBED
    // and that should do the trick! Safe to change the struct as it was cloned.
    OldT2Time = DhcpContext->T2Time;
    WasPlumbedBefore = IS_ADDRESS_PLUMBED(DhcpContext);
    if(fBroadcast) {
        DhcpContext->T2Time = 0; // !!!! KLUDGE.. look at SendDhcpMessage to understand this ..
        ADDRESS_UNPLUMBED(DhcpContext);
        CONNECTION_BROADCAST(DhcpContext);
    } else {
        DhcpContext->T2Time = (-1);
    }

    memset((void *) &ExpectedOptions, 0, sizeof(DHCP_EXPECTED_OPTIONS));

    Error = SendInformAndGetReplies(              // get replies on this
        DhcpContext,                              // context to send on
        2,                                        // send atmost 2 informs
        1,                                        // wait for as many as 4 packets..
        &ExpectedOptions
    );
    DhcpContext->LastInformSent = time(NULL);     // record when the last inform was sent
    DhcpContext->T2Time = OldT2Time;
    if( WasPlumbedBefore ) ADDRESS_PLUMBED(DhcpContext);

    LocalError = CloseDhcpSocket(DhcpContext);
    DhcpAssert(ERROR_SUCCESS == LocalError);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint(("DhcpDoInform:return [0x%lx]\n", Error));
    }
    else
    {
        //
        // Did we actually get a response with an URL that can be used ? 
        //

        if ( ExpectedOptions.WpadUrl && 
             ExpectedOptions.WpadUrlSize > 0 &&
             dwAutoProxyUrlLength > ExpectedOptions.WpadUrlSize )
        {
            memcpy(lpszAutoProxyUrl, ExpectedOptions.WpadUrl, ExpectedOptions.WpadUrlSize );
            return TRUE;
        }            
    }

    return FALSE;
}


DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    )
/*++

Routine Description:

    This function sends a UDP message to the DHCP server specified
    in the DhcpContext.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    MessageLength - The length of the message to send.

    TransactionID - The transaction ID for this message.  If 0, the
        function generates a random ID, and returns it.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    int i;
    struct sockaddr_in socketName;
    time_t TimeNow;
    BOOL   LockedInterface = FALSE;

    if ( *TransactionId == 0 ) {
        *TransactionId = (rand() << 16) + rand();
    }

    DhcpContext->MessageBuffer->TransactionID = *TransactionId;

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = _I_htons( DHCP_SERVR_PORT );

    if ( IS_MDHCP_CTX(DhcpContext) ) {
        socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        if ( CLASSD_NET_ADDR( DhcpContext->DhcpServerAddress ) ) {
            int   TTL = 16;
            //
            // Set TTL
            // MBUG: we need to read this from the registry.
            //
            if (_I_setsockopt(
                  DhcpContext->Socket,
                  IPPROTO_IP,
                  IP_MULTICAST_TTL,
                  (char *)&TTL,
                  sizeof((int)TTL)) == SOCKET_ERROR){

                 error = _I_WSAGetLastError();
                 DhcpPrint(("could not set MCast TTL %ld\n",error ));
                 return error;
            }

        }
    } else if( IS_ADDRESS_PLUMBED(DhcpContext) &&
               !IS_MEDIA_RECONNECTED(DhcpContext) &&    // media reconnect - braodcast
               !IS_POWER_RESUMED(DhcpContext) ) {       // power resumed - broadcast

        //
        // If we are past T2, use the broadcast address; otherwise,
        // direct this to the server.
        //

        TimeNow = time( NULL );

        // BUGBUG why did we broadcast here before ?
        if ( TimeNow > DhcpContext->T2Time && IS_CONNECTION_BROADCAST(DhcpContext)) {
            socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        } else {
            socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        }
    }
    else {
        socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        INET_ASSERT(FALSE);
    }

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    if( socketName.sin_addr.s_addr ==
            (DHCP_IP_ADDRESS)(INADDR_BROADCAST) ) {

        DWORD Error = ERROR_SUCCESS;
        DWORD InterfaceId;

        //
        // BUGBUG TODO [arthurbi] This code below is needed for 
        //  Broadcasts to work.  We need to make some fancy driver
        //  calls to work...
        //

        //
        // if we broadcast a message, inform IP stack - the adapter we
        // like to send this broadcast on, otherwise it will pick up the
        // first uninitialized adapter.
        //

//        InterfaceId = DhcpContext->IpInterfaceContext;            
//
//        if( !IPSetInterface( InterfaceId ) ) {
//            // DhcpAssert( FALSE );
//            Error = ERROR_GEN_FAILURE;
//        }

//        InterfaceId = ((PLOCAL_CONTEXT_INFO)
//            DhcpContext->LocalInformation)->IpInterfaceContext;
//
//        LOCK_INTERFACE();
//        LockedInterface = TRUE;
//        Error = IPSetInterface( InterfaceId );
        // DhcpAssert( Error == ERROR_SUCCESS );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(("IPSetInterface failed with %lx error\n", Error));
            UNLOCK_INTERFACE();
            return Error;
        }
    }

    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = (DWORD)((MessageLength > DHCP_MIN_SEND_RECV_PK_SIZE) ?
                        MessageLength : DHCP_MIN_SEND_RECV_PK_SIZE);
    error = _I_sendto(
                DhcpContext->Socket,
                (PCHAR)DhcpContext->MessageBuffer,
                MessageLength,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

#ifndef VXD
    if( LockedInterface ) { UNLOCK_INTERFACE(); }
#endif  VXD

    if ( error == SOCKET_ERROR ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("Send failed, error = %ld\n", error ));
    } else {
        IF_DEBUG( PROTOCOL ) {
            DhcpPrint(("Sent message to %s: \n", _I_inet_ntoa( socketName.sin_addr )));
        }

        DhcpDumpMessage( DEBUG_PROTOCOL_DUMP, DhcpContext->MessageBuffer );
        error = NO_ERROR;
    }

    return( error );
}

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error;
    PLOCAL_CONTEXT_INFO localInfo;

    if ( DhcpContext->Socket != INVALID_SOCKET ) {
        return ( ERROR_SUCCESS );
    }

    //
    // create a socket for the dhcp protocol.  it's important to bind the
    // socket to the correct ip address.  There are currently three cases:
    //
    // 1.  If the interface has been autoconfigured, it already has an address,
    //     say, IP1.  If the client receives a unicast offer from a dhcp server
    //     the offer will be addressed to IP2, which is the client's new dhcp
    //     address.  If we bind the dhcp socket to IP1, the client won't be able
    //     to receive unicast responses.  So, we bind the socket to 0.0.0.0.
    //     This will allow the socket to receive a unicast datagram addressed to
    //     any address.
    //
    // 2.  If the interface in not plumbed (i.e. doesn't have an address) bind
    //     the socket to 0.0.0.0
    //
    // 3.  If the interface has been plumbed has in *not* autoconfigured, then
    //     bind to the current address.


    Error =  InitializeDhcpSocket(
                 &DhcpContext->Socket,
                 DhcpContext->IpAddress 
                 );

    if( Error != ERROR_SUCCESS ) {
        DhcpContext->Socket = INVALID_SOCKET;
        DhcpPrint((" Socket Open failed, %ld\n", Error ));
    }

    return(Error);
}

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error = ERROR_SUCCESS;

    if( DhcpContext->Socket != INVALID_SOCKET ) {

        BOOL Bool;

        Error = _I_closesocket( DhcpContext->Socket );

        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((" Socket close failed, %ld\n", Error ));
        }

        DhcpContext->Socket = INVALID_SOCKET;

        //
        // Reset the IP stack to send DHCP broadcast to first
        // uninitialized stack.
        //

        //Bool = IPResetInterface();
        //DhcpAssert( Bool == TRUE );
    }

    return( Error );
}


typedef     struct  /* anonymous */ {             // structure to hold waiting recvfroms
    LIST_ENTRY                     RecvList;      // other elements in this list
    PDHCP_CONTEXT                  Ctxt;          // which context is this wait for?
    DWORD                          InBufLen;      // what was the buffer size to recv in?
    PDWORD                         BufLen;        // how many bytes did we recvd?
    DWORD                          Xid;           // what xid is this wait for?
    time_t                         ExpTime;       // wait until what time?
    HANDLE                         WaitEvent;     // event for waiting on..
    BOOL                           Recd;          // was a packet received..?
} RECV_CTXT, *PRECV_CTXT;                         // ctxt used to recv on..

VOID
InsertInPriorityList(                             // insert in priority list according to Secs
    IN OUT  PRECV_CTXT             Ctxt,          // Secs field changed to hold offset
    IN      PLIST_ENTRY            List,
    OUT     PBOOL                  First          // adding in first location?
)
{
    PRECV_CTXT                     ThisCtxt;
    PLIST_ENTRY                    InitList;      // "List" param at function entry


    if( IsListEmpty(List) ) {                     // no element in list? add this and quit
        *First = TRUE;                            // adding at head
    } else {
        *First = FALSE;                           // adding at tail..
    }

    InsertTailList( List, &Ctxt->RecvList);       // insert element..
    //LeaveCriticalSection( &DhcpGlobalRecvFromCritSect );
}

DWORD
TryReceive(                                       // try to recv pkt on 0.0.0.0 socket
    IN      SOCKET                 Socket,        // socket to recv on
    IN      LPBYTE                 Buffer,        // buffer to fill
    OUT     PDWORD                 BufLen,        // # of bytes filled in buffer
    OUT     PDWORD                 Xid,           // Xid of recd pkt
    IN      DWORD                  Secs           // # of secs to spend waiting?
)
{
    DWORD                          Error;
    struct timeval                 timeout;
    fd_set                         SockSet;
    struct sockaddr                SockName;
    int                            SockNameSize;

    FD_ZERO(&SockSet);
    FD_SET(Socket,&SockSet);

    SockNameSize = sizeof( SockName );

    timeout.tv_sec = Secs;
    timeout.tv_usec = 0;

    DhcpPrint(("Select: waiting for: %ld seconds\n", Secs));
    Error = _I_select( 0, &SockSet, NULL, NULL, &timeout );
    if( ERROR_SUCCESS == Error ) {            // timed out..
        DhcpPrint(("Recv timed out..\n"));
        return ERROR_SEM_TIMEOUT;
    }

    Error = _I_recvfrom(Socket,(char *)Buffer,*BufLen, 0, &SockName, &SockNameSize);
    if( SOCKET_ERROR == Error ) {
        Error = _I_WSAGetLastError();
        DhcpPrint(("Recv failed 0x%lx\n",Error));
    } else {
        *BufLen = Error;
        Error = ERROR_SUCCESS;
        *Xid = ((PDHCP_MESSAGE)Buffer)->TransactionID;
        DhcpPrint(("Recd msg XID: 0x%lx [Mdhcp? %s]\n", *Xid,
                   IS_MDHCP_MESSAGE(((PDHCP_MESSAGE)Buffer))?"yes":"no" ));

    }

    return Error;
}

VOID
DispatchPkt(                                      // find out any takers for Xid
    IN OUT  PRECV_CTXT             Ctxt,          // ctxt that has buffer and buflen
    IN      DWORD                  Xid            // recd Xid
)
{
    do {                                          // not a loop, just for ease of use
        LPBYTE                     Tmp;
        PLIST_ENTRY                Entry;
        PRECV_CTXT                 ThisCtxt;

        Entry = DhcpGlobalRecvFromList.Flink;
        while(Entry != &DhcpGlobalRecvFromList ) {
            ThisCtxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
            Entry = Entry->Flink;

            if(Xid != ThisCtxt->Xid ) continue;   // mismatch.. nothing more todo

            // now check for same type of message and ctxt...
            if( (unsigned)IS_MDHCP_MESSAGE((Ctxt->Ctxt->MessageBuffer))
                !=
                IS_MDHCP_CTX( (ThisCtxt->Ctxt) )
            ) {
                //
                // The contexts dont match.. give up
                //
                continue;
            }

            //
            // check for same hardware address..
            //

            if( ThisCtxt->Ctxt->HardwareAddressLength != Ctxt->Ctxt->MessageBuffer->HardwareAddressLength ) {
                continue;
            }

            if( 0 != memcmp(ThisCtxt->Ctxt->HardwareAddress,
                            Ctxt->Ctxt->MessageBuffer->HardwareAddress,
                            ThisCtxt->Ctxt->HardwareAddressLength
            ) ) {
                continue;
            }

            // matched.. switch buffers to give this guy this due..

            DhcpDumpMessage(DEBUG_PROTOCOL_DUMP, (PDHCP_MESSAGE)(Ctxt->Ctxt->MessageBuffer) );

            *(ThisCtxt->BufLen) = *(Ctxt->BufLen);
            Tmp = (LPBYTE)(Ctxt->Ctxt)->MessageBuffer;
            (Ctxt->Ctxt)->MessageBuffer = (ThisCtxt->Ctxt)->MessageBuffer;
            (ThisCtxt->Ctxt)->MessageBuffer = (PDHCP_MESSAGE)Tmp;

            RemoveEntryList(&ThisCtxt->RecvList);
            InitializeListHead(&ThisCtxt->RecvList);
            DhcpAssert(FALSE == ThisCtxt->Recd);
            ThisCtxt->Recd = TRUE;
            if( 0 == SetEvent(ThisCtxt->WaitEvent) ) {
                DhcpAssert(FALSE);
            }

            break;
        }
    } while (FALSE);
    //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
}

DWORD
ProcessRecvFromSocket(                            // wait using select and process incoming pkts
    IN OUT  PRECV_CTXT             Ctxt           // ctxt to use
)
{
    time_t                         TimeNow;
    SOCKET                         Socket;
    LPBYTE                         Buffer;
    DWORD                          Xid;
    DWORD                          Error;
    PLIST_ENTRY                    Entry;

    Socket = (Ctxt->Ctxt)->Socket;
    TimeNow = time(NULL);

    Error = ERROR_SEM_TIMEOUT;
    while(TimeNow <= Ctxt->ExpTime ) {            // while required to wait
        Buffer = (LPBYTE)((Ctxt->Ctxt)->MessageBuffer);
        *(Ctxt->BufLen) = Ctxt->InBufLen;
        Error = TryReceive(Socket, Buffer, Ctxt->BufLen, &Xid, (DWORD)(Ctxt->ExpTime - TimeNow));
        if( ERROR_SUCCESS != Error ) {            // did not recv?
            if( WSAECONNRESET != Error ) break;   // ignore possibly spurious conn-resets..
            else {  TimeNow = time(NULL); continue; }
        }

        if( Xid == Ctxt->Xid ) break;             // this was destined for this ctxt only..

        DispatchPkt(Ctxt, Xid);
        TimeNow = time(NULL);
    }

    if( TimeNow > Ctxt->ExpTime ) {               // we timed out.
        Error = ERROR_SEM_TIMEOUT;
    }

    // now done.. so we must remove this ctxt from the list and signal first guy
    //EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
    RemoveEntryList(&Ctxt->RecvList);
    CloseHandle(Ctxt->WaitEvent);
    if( !IsListEmpty(&DhcpGlobalRecvFromList)) {  // ok got an elt.. signal this.
        Entry = DhcpGlobalRecvFromList.Flink;
        Ctxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
        if( 0 == SetEvent(Ctxt->WaitEvent) ) {
            DhcpAssert(FALSE);
        }
    }
    //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);

    return Error;
}

//================================================================================
//  get dhcp message with requested transaction id, but also make sure only one
//  socket is used at any given time (one socket bound to 0.0.0.0), and also
//  re-distribute message for some other thread if that is also required..
//================================================================================
DWORD
GetSpecifiedDhcpMessageEx(
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // which context to recv for
    OUT     PDWORD                 BufferLength,  // how big a buffer was read?
    IN      DWORD                  Xid,           // which xid to look for?
    IN      DWORD                  TimeToWait     // how many seconds to sleep?
)
{
    RECV_CTXT                      Ctxt;          // element in list for this call to getspe..
    BOOL                           First;         // is this the first element in list?
    DWORD                          Result;

    Ctxt.Ctxt = DhcpContext;                      // fill in the context
    Ctxt.InBufLen = *BufferLength;
    Ctxt.BufLen = BufferLength;
    Ctxt.Xid = Xid;
    Ctxt.ExpTime = time(NULL) + TimeToWait;
    Ctxt.WaitEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    Ctxt.Recd = FALSE;
    if( NULL == Ctxt.WaitEvent ) {
        DhcpAssert(NULL != Ctxt.WaitEvent);
        return GetLastError();
    }

    First = FALSE;
    InsertInPriorityList(&Ctxt, &DhcpGlobalRecvFromList, &First);

    if( First ) {                                 // this *is* the first call to GetSpec..
        Result = ProcessRecvFromSocket(&Ctxt);
    } else {                                      // we wait for other calls to go thru..
        Result = WaitForSingleObject(Ctxt.WaitEvent, TimeToWait * 1000);
        //EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
        if( Ctxt.Recd || WAIT_FAILED == Result || WAIT_TIMEOUT == Result ) {
            if( WAIT_FAILED == Result ) Result = GetLastError();
            else if (WAIT_TIMEOUT == Result ) Result = ERROR_SEM_TIMEOUT;
            else Result = ERROR_SUCCESS;

            RemoveEntryList(&Ctxt.RecvList);      // remove it from list
            //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
            CloseHandle(Ctxt.WaitEvent);
            return Result;
        } else {
            DhcpAssert(WAIT_OBJECT_0 == Result && Ctxt.Recd == FALSE );
            // have not received a packet but have been woken up? must be first in line now..
            //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
            Result = ProcessRecvFromSocket(&Ctxt);
        }
    }

    return Result;
}


#define RATIO 1
DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    )
/*++

Routine Description:

    This function waits TimeToWait seconds to receives the specified
    DHCP response.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    BufferLength - Returns the size of the input buffer.

    TransactionID - A filter.  Wait for a message with this TID.

    TimeToWait - Time, in milli seconds, to wait for the message.

Return Value:

    The status of the operation.  If the specified message has been
    been returned, the status is ERROR_TIMEOUT.

--*/
{
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );
    struct timeval timeout;
    time_t startTime, now;
    DWORD error;
    DWORD actualTimeToWait;
    SOCKET clientSocket;
    fd_set readSocketSet;

    if( !IS_ADDRESS_PLUMBED(DhcpContext) ) {
        //
        // For RAS server Lease API this call won't happen as we don't have to do this nonsense
        //
        error = GetSpecifiedDhcpMessageEx(
            DhcpContext,
            BufferLength,
            TransactionId,
            TimeToWait
        );
        if( ERROR_SUCCESS == error ) {
            // received a message frm the dhcp server..
            SERVER_REACHED(DhcpContext);
        }
        return error;
    }

    startTime = time( NULL );
    actualTimeToWait = TimeToWait;

    //
    // Setup the file descriptor set for select.
    //

    clientSocket = DhcpContext->Socket;

    FD_ZERO( &readSocketSet );
    FD_SET( clientSocket, &readSocketSet );

    while ( 1 ) {

        timeout.tv_sec  = actualTimeToWait / RATIO;
        timeout.tv_usec = actualTimeToWait % RATIO;
        DhcpPrint(("Select: waiting for: %ld seconds\n", actualTimeToWait));
        error = _I_select( 0, &readSocketSet, NULL, NULL, &timeout );

        if ( error == 0 ) {

            //
            // Timeout before read data is available.
            //

            DhcpPrint(("Recv timed out\n", 0 ));
            error = ERROR_SEM_TIMEOUT;
            break;
        }

        error = _I_recvfrom(
                    clientSocket,
                    (PCHAR)DhcpContext->MessageBuffer,
                    *BufferLength,
                    0,
                    &socketName,
                    &socketNameSize
                    );

        if ( error == SOCKET_ERROR ) {
            error = _I_WSAGetLastError();
            DhcpPrint(("Recv failed, error = %ld\n", error ));

            if( WSAECONNRESET != error ) break;

            //
            // ignore connreset -- this could be caused by someone sending random ICMP port unreachable.
            //

        } else if (DhcpContext->MessageBuffer->TransactionID == TransactionId ) {
             
            DhcpPrint((  "Received Message, XID = %lx, MDhcp = %d.\n",
                            TransactionId,
                            IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) ));

            if (((unsigned)IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) == IS_MDHCP_CTX( DhcpContext))) {
                DhcpDumpMessage(DEBUG_PROTOCOL_DUMP, DhcpContext->MessageBuffer );

                *BufferLength = error;
                error = NO_ERROR;

                if( DhcpContext->MessageBuffer->HardwareAddressLength == DhcpContext->HardwareAddressLength
                    && 0 == memcmp(DhcpContext->MessageBuffer->HardwareAddress,
                                   DhcpContext->HardwareAddress,
                                   DhcpContext->HardwareAddressLength
                    )) {

                    //
                    // Transction IDs match, same type (MDHCP/DHCP), Hardware addresses match!
                    //

                    break;
                }
            }
        } else {            
            DhcpPrint(( "Received a buffer with unknown XID = %lx\n",
                         DhcpContext->MessageBuffer->TransactionID ));
        }

        //
        // We received a message, but not the one we're interested in.
        // Reset the timeout to reflect elapsed time, and wait for
        // another message.
        //
        now = time( NULL );
        actualTimeToWait = (DWORD)(TimeToWait - RATIO * (now - startTime));
        if ( (LONG)actualTimeToWait < 0 ) {
            error = ERROR_SEM_TIMEOUT;
            break;
        }
    }

    if ( ERROR_SEM_TIMEOUT != error )
    {
        //
        // a message was received from a DHCP server.  disable IP autoconfiguration.
        //

        SERVER_REACHED(DhcpContext);
    }

    return( error );
}


DWORD 
QueryWellKnownDnsName(
    IN OUT LPSTR lpszAutoProxyUrl,
    IN     DWORD dwAutoProxyUrlLength
    )
/*++

Routine Description:

    This function walks a list of standard DNS names trying to find
     an entry for "wpad.some-domain-here.org"  If it does, it constructs
     an URL that is suitable for use in auto-proxy.

Arguments:

    lpszAutoProxyUrl - Url used to return a successful auto-proxy discover

    dwAutoProxyUrlLength - length of buffer passed in above

Return Value:
        
    ERROR_SUCCESS - if we found a URL/DNS name

    ERROR_NOT_FOUND - on error

revised: joshco 7-oct-1998
  if we dont get a valid domain back, be sure and try
  the netbios name ("wpad") no trailing dot.

  revised: joshco 7-oct-1998
        use the define PROXY_AUTO_DETECT_PATH instead
        of hardcoding "wpad.dat"
        
--*/

{
#define WORK_BUFFER_SIZE 356

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "QueryWellKnownDnsName",
                 "%x, %u",
                 lpszAutoProxyUrl,
                 dwAutoProxyUrlLength                 
                 ));

    char szHostDomain[WORK_BUFFER_SIZE];
    char * pszTemp = szHostDomain ;
    char *pszDot1 = NULL;
    char *pszDot2 = NULL;
    DWORD error = ERROR_NOT_FOUND;
    DWORD dwMinDomain = 2;  //  By default, assume domain is of the form: .domain-name.org

    lstrcpy(szHostDomain, "wpad.");
    pszTemp += (sizeof("wpad.") - 1);

    if ( SockGetSingleValue(CONFIG_DOMAIN,
                            (LPBYTE)pszTemp,
                            WORK_BUFFER_SIZE - sizeof("wpad.")
                            ) != ERROR_SUCCESS )
    {
        lstrcpy(szHostDomain, "wpad.");
        pszTemp = szHostDomain ;
        pszTemp += (sizeof("wpad.") - 1);
    }

    if ( (GetProxyDetectType() & PROXY_AUTO_DETECT_TYPE_NO_DOMAIN ) ||
         *pszTemp == '\0' ) 
    {
        // if the debug setting for no domain (netbios) or 
        // we didnt get back a valid domain, then just do the
        // netbios name.  
        // XXBUG sockgetsinglevalue returns true even if there is no domain

        INET_ASSERT(*(pszTemp  - 1 ) == '.');

        *(pszTemp - 1) = '\0';
    }

    // Now determine which form the domain name follows:
    //     domain-name.org
    //     domain-name.co.uk
    pszDot1 = &szHostDomain[lstrlen(szHostDomain)-1];

    while (pszDot1 >= szHostDomain && *pszDot1 != '.')
        pszDot1--;

    // Only check .?? endings
    if (pszDot1 >= szHostDomain && (pszDot1 + 3 == &szHostDomain[lstrlen(szHostDomain)]) )
    {
        pszDot2 = pszDot1 - 1;

        while (pszDot2 >= szHostDomain && *pszDot2 != '.')
           pszDot2--;
   
        if (pszDot2 >= szHostDomain && pszDot2 + 3 >= pszDot1)
        {
           // Domain ended in something of the form: .co.uk
           // This requires at least 3 pieces then to be considered a domain
           dwMinDomain = 3;
        }
        else if ((pszDot2 + 4) == pszDot1)
        {
            // Check domain endings of the form ending in .com.uk
            // These special 3-letter pieces also need 3 dots to be classified
            // as a domain.  Unfortunately, we can't leverage the equivalent
            // code used by cookies because there, the strings are reversed.
            static const char *s_pachSpecialDomains[] = {"COM", "EDU", "NET", "ORG", "GOV", "MIL", "INT" };

            for (int i=0; i < ARRAY_ELEMENTS(s_pachSpecialDomains); i++)
            {
                if (StrCmpNIC(pszDot2+1, s_pachSpecialDomains[i], 3) == 0)
                {
                    dwMinDomain = 3;
                    break;
                }
            }
        }
    }

    // IE6 BUG #4242
    //   Append a "." suffix to the domain name in order to suppress
    //   the DNS suffix search list (if there's room in the string).
    if (lstrlen(szHostDomain)+1 < WORK_BUFFER_SIZE)
    {
        lstrcat(szHostDomain, ".");
        dwMinDomain++;
    }

    while (TRUE)
    {
        PHOSTENT lpHostent = _I_gethostbyname(szHostDomain);

        if ( lpHostent != NULL )
        {
            //
            // Found a host, extract the IP address and form an URL to use.
            //

            char *pszAddressStr;
            LPBYTE * addressList;
            struct  in_addr sin_addr;
            DWORD dwIPAddressSize;

            addressList         = (LPBYTE *)lpHostent->h_addr_list;
            *(LPDWORD)&sin_addr = *(LPDWORD)addressList[0] ;

            pszAddressStr = _I_inet_ntoa (sin_addr);

            INET_ASSERT(pszAddressStr);

            dwIPAddressSize = lstrlen(pszAddressStr);

            if ( dwAutoProxyUrlLength < (dwIPAddressSize + 
              sizeof("http:///") + sizeof(PROXY_AUTO_DETECT_PATH) )  )
            {
                error = ERROR_INSUFFICIENT_BUFFER;
                goto quit;
            }

            wsprintf(lpszAutoProxyUrl, "http://%s/%s", pszAddressStr, PROXY_AUTO_DETECT_PATH );
            error = ERROR_SUCCESS;
            goto quit;
        }
        else
        {
            //
            // Did not find anything yet, reduce the domain level, 
            //  and if we're in the root domain stop and return error
            //

            DWORD dwPeriodCnt = 0, dwNewEndLength = 0;
            LPSTR lpszPeriod1 = NULL, lpszPeriod2 = NULL;

            for (pszTemp = szHostDomain; *pszTemp; pszTemp++ )
            {
                if ( *pszTemp == '.' ) {
                    dwPeriodCnt ++;
                    if ( lpszPeriod1 == NULL ) {
                        lpszPeriod1 = pszTemp;
                    }
                    else if ( lpszPeriod2 == NULL ) {
                        lpszPeriod2 = pszTemp;
                    }
                }
            }

            if ( dwPeriodCnt <= dwMinDomain) 
            {
                error = ERROR_NOT_FOUND;
                goto quit;
            }

            dwNewEndLength = lstrlen(lpszPeriod2);
            MoveMemory(lpszPeriod1, lpszPeriod2, dwNewEndLength);
            *(lpszPeriod1 + dwNewEndLength) = '\0';
        }
    }
quit:

    DEBUG_LEAVE(error);

    return error;    
}


//================================================================================
// End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\apdetect\sockreg.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sockreg.cxx

Abstract:

    Contains the registry/ini-file specific functions from gethost.c

    Taken from Win95 Winsock 1.1 project

    Contents:
        SockGetSingleValue
        (CheckRegistryForParameter)
        (GetDnsServerListFromDhcp)
        (GetDomainNameFromDhcp)
        (GetDhcpHardwareInfo)
        (OpenDhcpVxdHandle)
        (DhcpVxdRequest)

Author:

    Richard L Firth (rfirth) 10-Feb-1994

Environment:

    Win32 user-mode DLL

Revision History:

    10-Feb-1994 (rfirth)
        Created

--*/

//
// includes
//


#include <wininetp.h>
#include "aproxp.h"



//
// manifests
//

#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
#define PLATFORM_TYPE_WINNT         ((DWORD)(1))

#define PLATFORM_SUPPORTS_UNICODE   0x00000001
#define DEVICE_PREFIX       "\\Device\\"


//
// manifests
//

//
// macros
//

#define FSTRLEN(p)      lstrlen((LPSTR)(p))
#define FSTRCPY(p1, p2) lstrcpy((LPSTR)(p1), (LPSTR)(p2))
#define FSTRCAT(p1, p2) lstrcat((LPSTR)(p1), (LPSTR)(p2))

//
// MAP_PARAMETER_ID - returns a string corresponding to the database parameter
//
// N.B. id MUST start at 1
//

#define MAP_PARAMETER_ID(id)    ParameterNames[(id) - 1]

//
// globally available registry keys
//

extern HKEY ServicesKey;  //       = INVALID_HANDLE_VALUE;


//
// private prototypes
//

PRIVATE
UINT
CheckRegistryForParameter(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    );

PRIVATE
UINT
GetDnsServerListFromDhcp(
    LPBYTE Data,
    UINT DataLength
    );

PRIVATE
UINT
GetDomainNameFromDhcp(
    LPBYTE Data,
    UINT DataLength
    );

PRIVATE
LPDHCP_QUERYINFO
GetDhcpHardwareInfo(
    VOID
    );

PRIVATE
DWORD_PTR
OpenDhcpVxdHandle(
    VOID
    );

PRIVATE
WORD
DhcpVxdRequest(
    IN DWORD_PTR Handle,
    IN WORD Request,
    IN WORD BufferLength,
    OUT LPVOID Buffer
    );

PRIVATE
DWORD_PTR
OsOpenVxdHandle(
    CHAR * VxdName,
    WORD   VxdId
    );

PRIVATE
VOID
OsCloseVxdHandle(
    DWORD_PTR VxdHandle
    );

PRIVATE
INT
OsSubmitVxdRequest(
    DWORD_PTR   VxdHandle,
    INT         OpCode,
    LPVOID      Param,
    INT         ParamLength
    );

//
// private data
//

//
// ParameterNames - the names of the registry values corresponding to the
// variables retrieved by SockGetSingleValue.
//
// N.B. These MUST be in order of the CONFIG_ manifests in sockreg.h
//

PRIVATE const LPCSTR ParameterNames[] = {
    "HostName",
    "Domain",
    "SearchList",
    "NameServer"
};

//
// functions
//

/*******************************************************************************
 *
 *  GetBoundAdapterList
 *
 *  Gets a list of names of all adapters bound to a protocol (TCP/IP). Returns
 *  a pointer to an array of pointers to strings - basically an argv list. The
 *  memory for the strings is concatenated to the array and the array is NULL
 *  terminated. If Elnkii1 and IbmTok2 are bound to TCP/IP then this function
 *  will return:
 *
 *          ---> addr of string1   \
 *               addr of string2    \
 *               NULL                > allocated as one block
 *     &string1: "Elnkii1"          /
 *     &string2: "IbmTok2"         /
 *
 *  ENTRY   BindingsSectionKey
 *              - Open registry handle to a linkage key (e.g. Tcpip\Linkage)
 *
 *  EXIT
 *
 *  RETURNS pointer to argv[] style array, or NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR* GetBoundAdapterList(HKEY BindingsSectionKey)
{

    LPSTR* resultBuffer;

    LONG err;
    DWORD valueType;
    PBYTE valueBuffer = NULL;
    DWORD valueLength;
    LPSTR* nextResult;
    int len;
    DWORD resultLength;
    LPSTR nextValue;
    LPSTR variableData;
    DWORD numberOfBindings;

    //
    // get required size of value buffer
    //

    valueLength = 0;
    resultBuffer = NULL;

    err = RegQueryValueEx(BindingsSectionKey,
                          "Bind",
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        goto quit;
    }
    if (valueType != REG_MULTI_SZ) {
        goto quit;
    }
    if (!valueLength) {
        goto quit;
    }
    valueBuffer = (PBYTE)ALLOCATE_MEMORY(LPTR, valueLength);
    if ( valueBuffer == NULL ) {
        goto quit;
    }

    err = RegQueryValueEx(BindingsSectionKey,
                          "Bind",
                          NULL, // reserved
                          &valueType,
                          valueBuffer,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        goto quit;
    }
    resultLength = sizeof(LPSTR);   // the NULL at the end of the list
    numberOfBindings = 0;
    nextValue = (LPSTR)valueBuffer;
    while (len = strlen(nextValue)) {
        resultLength += sizeof(LPSTR) + len + 1;
        if (!_strnicmp(nextValue, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            resultLength -= sizeof(DEVICE_PREFIX) - 1;
        }
        nextValue += len + 1;
        ++numberOfBindings;
    }
    resultBuffer = (LPSTR*)ALLOCATE_MEMORY(LPTR, resultLength);
    if ( resultBuffer == NULL ) {
        goto quit;
    }
    nextValue = (LPSTR)valueBuffer;
    nextResult = resultBuffer;
    variableData = (LPSTR)(((LPSTR*)resultBuffer) + numberOfBindings + 1);
    while (numberOfBindings--) {

        LPSTR adapterName;

        adapterName = nextValue;
        if (!_strnicmp(adapterName, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            adapterName += sizeof(DEVICE_PREFIX) - 1;
        }
        *nextResult++ = variableData;
        strcpy(variableData, adapterName);
        while (*variableData) {
            ++variableData;
        }
        ++variableData;
        while (*nextValue) {
            ++nextValue;
        }
        ++nextValue;
    }

    *nextResult = NULL;

quit:

    if ( valueBuffer != NULL )
    {
        FREE_MEMORY(valueBuffer);
    }

    return resultBuffer;
}


/*******************************************************************************
 *
 *  OpenAdapterKey
 *
 *  Opens one of the 2 per-adapter registry keys: <Adapter>\Parameters\Tcpip, or
 *  NetBT\Adapters\<Adapter>
 *
 *  ENTRY   KeyType - KEY_TCP or KEY_NBT
 *          Name    - pointer to adapter name to use
 *          Key     - pointer to returned key
 *
 *  EXIT    Key updated
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL OpenAdapterKey(DWORD KeyType, LPSTR Name, PHKEY Key)
{

    LONG err;
    CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof("\\Parameters\\Tcpip")];

    if ((lstrlen(Name)+sizeof("\\Parameters\\Tcpip")) < ARRAY_ELEMENTS(keyName))
    {
        if (KeyType == KEY_TCP) {

            //
            // open the handle to this adapter's TCPIP parameter key
            //

            strcpy(keyName, Name);
            strcat(keyName, "\\Parameters\\Tcpip");
        } else if (KeyType == KEY_NBT) {

            //
            // open the handle to the NetBT\Adapters\<Adapter> handle
            //

            strcpy(keyName, "NetBT\\Adapters\\");
            strcat(keyName, Name);
        }
    }
    else
    {
        INET_ASSERT((lstrlen(Name)+sizeof("\\Parameters\\Tcpip")) < ARRAY_ELEMENTS(keyName));
        return FALSE;
    }

    err = REGOPENKEY(ServicesKey,
                     keyName,
                     Key
                     );


    DEBUG_PRINT( SOCKETS,
                 INFO,
                 ("RegOpenKey %s %s %s %d\n",
                 SERVICES_KEY_NAME, keyName,
                 (err != ERROR_SUCCESS )? "failed":"success",
                 GetLastError()                              ));


    return (err == ERROR_SUCCESS);
}

/*******************************************************************************
 *
 *  ReadRegistryDword
 *
 *  Reads a registry value that is stored as a DWORD
 *
 *  ENTRY   Key             - open registry key where value resides
 *          ParameterName   - name of value to read from registry
 *          Value           - pointer to returned value
 *
 *  EXIT    *Value = value read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryDword(HKEY Key, LPSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);

    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );

    if(    (err         == ERROR_SUCCESS )
        && (valueType   == REG_DWORD     )
        && (valueLength == sizeof(DWORD))) {

        return 1;
    } else {
        DEBUG_PRINT(SOCKETS, INFO,
                 ("ReadRegistryDword(%s): err=%d\n", ParameterName, err ));
        return 0;
    }

}

/*******************************************************************************
 *
 *  ReadRegistryString
 *
 *  Reads a registry value that is stored as a string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL
ReadRegistryString(HKEY Key, LPSTR ParameterName, LPSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        DLL_ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        return  (*Length) > sizeof(char);

    } else {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("ReadRegistryString(%s): err=%d\n", ParameterName, err ));
        return 0;
    }

}



UINT
SockGetSingleValue(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    )

/*++

Routine Description:

    Retrieve parameter from Registry/DHCP/TCPIP

    This is what we look for and where:

        HostName:   1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\HostName                (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\Hostname         (NT)
                    2. (SYSTEM.INI:DNS.HostName)*                                               (N/A)
                    3. GetComputerName()

        DomainName: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\Domain                  (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\DhcpDomain       (NT)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\Domain           (NT)
                    2. (SYSTEM.INI:DNS.DomainName)*                                             (N/A)
                    3. DHCP                                                                     (Win95)

        SearchList: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\SearchList              (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\SearchList       (NT)
                    2. (SYSTEM.INI:DNS.DNSDomains)*                                             (N/A)

        NameServer: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\NameServer              (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\DhcpNameServer   (NT)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\NameServer       (NT)
                    2. (SYSTEM.INI:DNS.DNSServers)*                                             (N/A)
                    3. DHCP                                                                     (Win95)

        * Entries marked thus are registry backups from SYSTEM.INI until all
          keys are moved into registry or if platform is WFW 3.11 (in which
          case there is no registry)

    ASSUMES 1. Data is big enough to hold the default value (single byte for
               strings, dword for dwords)
            2. Registry is accessible from 16-bit code too

Arguments:

    ParameterId - identifier of parameter to retrieve

    Data        - pointer to untyped storage space for parameter

    DataLength  - length of data returned (in bytes)

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    can't locate required parameter in registry/ini/etc.

--*/

{
    UINT error = CheckRegistryForParameter(ParameterId, Data, DataLength);

    //
    // if the value was not in the registry then we must attempt to get it from
    // another place, specific to the particular variable requested
    //

    if (error != ERROR_SUCCESS) {
        if (ParameterId == CONFIG_HOSTNAME) {

            //
            // on Win32 platform we can call GetComputerName() to provide the
            // computer name, which is the default host name, if none is
            // specified elsewhere
            //

            DWORD length;

            length = DataLength;
            if (!GetComputerName((LPSTR)Data, &length)) {
                error = GetLastError();
            }
        } else if (ParameterId == CONFIG_DOMAIN) {
            if (GlobalPlatformType == PLATFORM_TYPE_WIN95) {
                error = GetDomainNameFromDhcp(Data, DataLength);
            }
        } else if (ParameterId == CONFIG_NAME_SERVER) {
            if (GlobalPlatformType == PLATFORM_TYPE_WIN95) {
                error = GetDnsServerListFromDhcp(Data, DataLength);
            }
        } else {

            //
            // the caller is requesting the domain list (or an invalid config
            // parameter value?!?). We have nowhere else to get this value -
            // return an error
            //

            error = ERROR_PATH_NOT_FOUND;
        }
    }

    IF_DEBUG(REGISTRY) {
        if (error != ERROR_SUCCESS) {
            DLL_PRINT(("SockGetSingleValue(%s) returns %d\r",
                        MAP_PARAMETER_ID(ParameterId),
                        error
                        ));
        } else {
            DLL_PRINT(("SockGetSingleValue(%s) returns \"%s\"\n",
                        MAP_PARAMETER_ID(ParameterId),
                        Data
                        ));
        }
    }

    return error;
}


PRIVATE
UINT
CheckRegistryForParameter(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    )

/*++

Routine Description:

    Retrieve parameter from registry

    ASSUMES 1. Data is big enough to hold the default value (single byte for
               strings, dword for dwords)

Arguments:

    ParameterId - identifier of parameter to retrieve

    Data        - pointer to untyped storage space for parameter

    DataLength  - length of data returned (in bytes)

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    HKEY key;
    LONG error = REGOPENKEY(HKEY_LOCAL_MACHINE,
                            (GlobalPlatformType == PLATFORM_TYPE_WINNT)
                            ? "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
                            : "System\\CurrentControlSet\\Services\\VxD\\MSTCP",
                            &key
                            );
    if (error == ERROR_SUCCESS) {

        char dhcpBuffer[128];   // arbitrary
        LPSTR p;
        DWORD length;
        DWORD type;
        BOOL tryDhcp;

        if (GlobalPlatformType == PLATFORM_TYPE_WINNT) {
            FSTRCPY(dhcpBuffer, "Dhcp");
            p = &dhcpBuffer[sizeof("Dhcp") - 1];
            tryDhcp = TRUE;
        } else {
            p = dhcpBuffer;
            tryDhcp = FALSE;
        }

        FSTRCPY(p, MAP_PARAMETER_ID(ParameterId));

        //
        // on NT, we look first for the manually-entered variables e.g. "Domain"
        // and if not found, we look a second time for the DHCP-configured
        // variant, e.g. "DhcpDomain"
        //

        for (int i = 0; i < 2; ++i) {

            //
            // if NT, first we try the transient key which is written to the
            // registry when we have a dial-up connection
            //

            if ((i == 0) && (GlobalPlatformType == PLATFORM_TYPE_WINNT)) {

                HKEY transientKey;

                error = REGOPENKEY(key, "Transient", &transientKey);
                if (error == ERROR_SUCCESS) {
                    length = DataLength;
                    error = RegQueryValueEx(transientKey,
                                            p,
                                            NULL,   // reserved
                                            &type,
                                            Data,
                                            &length
                                            );
                    REGCLOSEKEY(transientKey);

                    //
                    // if we succeeded in retrieving a non-empty string then
                    // we're done.
                    //
                    // We test for > 1 because the registry returns the length
                    // including the zero-terminator
                    //

                    if ((error == ERROR_SUCCESS) && (length > 1)) {
                        break;
                    }
                }
            }


            length = DataLength;
            error = RegQueryValueEx(key,
                                    p,
                                    NULL,   // reserved
                                    &type,
                                    Data,
                                    &length
                                    );

            //
            // if the key exists, but there is no value then return an error OR
            // if we didn't find the key (or value) AND NT then try for the DHCP
            // version (Note: We try for DhcpSearchList even though it doesn't
            // exist)
            //

            if ((error != ERROR_SUCCESS)
            || (length == 0)
            || ((length == 1) && (Data[0] == '\0'))) {
                if (tryDhcp) {
                    p = dhcpBuffer;
                    tryDhcp = FALSE;
                    continue;
                } else {
                    error = ERROR_PATH_NOT_FOUND;
                    break;
                }
            } else if ((UINT)length > DataLength) {
                error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }
        REGCLOSEKEY(key);
    }

    IF_DEBUG(REGISTRY) {
        DLL_PRINT(("CheckRegistryForParameter(%s): returning %d\n",
                    MAP_PARAMETER_ID(ParameterId),
                    error
                    ));
    }

    return (UINT)error;
}



UINT
GetDhcpServerFromDhcp(
    IN OUT CAdapterInterface * paiInterface
    )

/*******************************************************************************
 *
 *  GetDhcpServerFromDhcp
 *
 *  Updates an CAdapterInterface with the DHCP server from the DHCP info
 *
 *  ENTRY   paiInterface - pointer to CAdapterInterface to update
 *
 *  EXIT    paiInterface - DhcpServer may be updated
 *
 *  RETURNS TRUE if AdapterInfo->DhcpServer updated
 *
 *  ASSUMES 1. AdapterInfo->Address is valid
 *
 ******************************************************************************/

{
    LPDHCP_QUERYINFO pDhcpInfoPtr;

    if ( GlobalPlatformType == PLATFORM_TYPE_WINNT )
    {
        HKEY key;

        if (paiInterface->GetAdapterName() &&
            OpenAdapterKey(KEY_TCP, paiInterface->GetAdapterName(), &key))
        {
            char dhcpServerAddress[4 * 4];
            DWORD addressLength;
            DWORD fDhcpEnabled = FALSE;

            ReadRegistryDword(key,
                              "EnableDHCP",
                              &fDhcpEnabled
                              );

            if ( fDhcpEnabled )
            {

                addressLength = sizeof(dhcpServerAddress);
                if (ReadRegistryString(key,
                                       "DhcpServer",
                                       dhcpServerAddress,
                                       &addressLength
                                       ))
                {
                    DWORD ipAddress = _I_inet_addr(dhcpServerAddress);

                    if ( IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress) )
                    {
                        paiInterface->AddDhcpServer(ipAddress);
                        paiInterface->SetDhcp();
                    }
                }
            }

            //ReadRegistryDword(key,
            //                  "LeaseObtainedTime",
            //                  &AdapterInfo->LeaseObtained
            //                  );

            //ReadRegistryDword(key,
            //                  "LeaseTerminatesTime",
            //                  &AdapterInfo->LeaseExpires
            //                  );


            REGCLOSEKEY(key);
            return fDhcpEnabled;
        }
    }
    else
    {
        if (pDhcpInfoPtr = GetDhcpHardwareInfo()) {

            DWORD i;

            for (i = 0; i < pDhcpInfoPtr->NumNICs; ++i)
            {
                LPDHCP_NIC_INFO info;
                register BOOL match;

                info = &pDhcpInfoPtr->NicInfo[i];

                match = paiInterface->IsHardwareAddress( ((LPBYTE)pDhcpInfoPtr + info->OffsetHardwareAddress) );

                if (match && info->DhcpServerAddress) {

                    paiInterface->AddDhcpServer(info->DhcpServerAddress);

                    //
                    // side-effect: this adapter is DHCP enabled
                    //

                    paiInterface->SetDhcp();

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ( "GetDhcpServerFromDhcp %s\n",
                                  "bugbug"/*inet_ntoa((int)info->DhcpServerAddress)*/ ));

                    return TRUE;
                }
            }
        } else {
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("GetDhcpServerFromDhcp: DhcpInfoPtr is 0\n"));
        }
    }
    return FALSE;
}




PRIVATE
UINT
GetDnsServerListFromDhcp(
    LPBYTE Data,
    UINT DataLength
    )

/*++

Routine Description:

    Attempts to retrieve a list of DNS servers from DHCP if DHCP is active and
    the DNS servers option was specified at the DHCP server

Arguments:

    Data        - pointer to place to return the list

    DataLength  - length of Data

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    LPDHCP_QUERYINFO pInfo;
    LPBYTE originalData;

    originalData = Data;
    *Data = 0;

    if (pInfo = GetDhcpHardwareInfo()) {

        UINT n = (UINT)pInfo->NumNICs;
        LPDHCP_NIC_INFO pNicInfo = &pInfo->NicInfo[0];
        UINT first = TRUE;
        DWORD smallCache[16];
        UINT cacheIndex = 0;

        IF_DEBUG(REGISTRY) {
            DLL_PRINT(("GetDnsServerListFromDhcp(): DHCP has %d adapters\n",
                        pInfo->NumNICs
                        ));
        }

        while (n-- && DataLength) {

            UINT i;
            LPDWORD pServers = (LPDWORD)((LPBYTE)pInfo + pNicInfo->OffsetDNSServers);

            IF_DEBUG(REGISTRY) {
                DLL_PRINT(("GetDnsServerListFromDhcp(): NIC %x has %d DNS addresses\n",
                            pNicInfo,
                            pNicInfo->DNSServersLen / 4
                            ));
            }

            for (i = 0; i < pNicInfo->DNSServersLen; i += 4) {

                IN_ADDR inaddr;
                char* p;

                //
                // copy the next DNS address from the DHCP list
                //

                memcpy(&inaddr, pServers++, sizeof(DWORD));

                //
                // inet_ntoa will validate the address: if it returns NULL, the
                // address is no good, so we skip it
                //

                p = _I_inet_ntoa(inaddr);
                if ((p != NULL) && *p) {

                    BOOL found;
                    UINT cachePos;

                    //
                    // now check if we've already seen this address. If we have
                    // then we skip it: no sense in adding redundant DNS addresses.
                    // This can happen when we have multiple cards, all configured
                    // with the same DNS info
                    //

                    found = FALSE;
                    for (cachePos = 0; cachePos < cacheIndex; ++cachePos) {
                        if (smallCache[cachePos] == (DWORD)inaddr.s_addr) {
                            found = TRUE;
                            break;
                        }
                    }
                    if (!found) {

                        UINT len;

                        //
                        // new one: add it
                        //

                        if (cacheIndex < (sizeof(smallCache)/sizeof(smallCache[0])) - 1) {

                            IF_DEBUG(REGISTRY) {
                                DLL_PRINT(("GetDnsServerListFromDhcp(): adding %s to smallCache[%d]\n",
                                            p,
                                            cacheIndex
                                            ));
                            }

                            smallCache[cacheIndex] = (DWORD)inaddr.s_addr;

                            //
                            // increment the cache index; don't let it go past
                            // the last element
                            //

                            if (cacheIndex < (sizeof(smallCache)/sizeof(smallCache[0])) - 1) {
                                ++cacheIndex;
                            }
                        } else {

                            IF_DEBUG(REGISTRY) {
                                DLL_PRINT(("GetDnsServerListFromDhcp(): smallCache full (!)\n"));
                            }

                        }

                        len = FSTRLEN(p);

                        //
                        // this assumes that we have more buffer than just
                        // enough for one string: if there is only one address
                        // and we have been supplied with DataLength == length
                        // of the address plus 1 for the zero terminator, then
                        // we will fail to copy it since we check for space
                        // enough for the string, zero terminator, plus an extra
                        // byte for the space separator. But this is being
                        // overly pedantic. Casuistry even
                        //

                        if (DataLength > len + 1) {
                            if (!first) {
                                *Data++ = ' ';
                                --DataLength;
                            }

                            IF_DEBUG(REGISTRY) {
                                DLL_PRINT(("GetDnsServerListFromDhcp() found \"%s\"\n",
                                            p
                                            ));
                            }

                            FSTRCPY(Data, p);
                            DataLength -= len;
                            Data += len;
                            first = FALSE;
                        } else {

                            IF_DEBUG(REGISTRY) {
                                DLL_PRINT(("GetDnsServerListFromDhcp(): out of buffer space (need=%d, left=%d)\n",
                                            len + 1,
                                            DataLength
                                            ));
                            }

                        }
                    } else {

                        IF_DEBUG(REGISTRY) {
                            DLL_PRINT(("GetDnsServerListFromDhcp(): already seen address %s\n",
                                        p
                                        ));
                        }

                    }
                }
            }
            ++pNicInfo;
        }
        DllFreeMem((void*)pInfo);

        //
        // if we didn't find any DNS addresses or couldn't fit them in the
        // supplied buffer then return an error
        //

        return (UINT)((*originalData != 0) ? ERROR_SUCCESS : ERROR_PATH_NOT_FOUND);
    } else {

        IF_DEBUG(REGISTRY) {
            DLL_PRINT(("GetDnsServerListFromDhcp() returning %d\n",
                        ERROR_PATH_NOT_FOUND
                        ));
        }

        return ERROR_PATH_NOT_FOUND;
    }
}


PRIVATE
UINT
GetDomainNameFromDhcp(
    LPBYTE Data,
    UINT DataLength
    )

/*++

Routine Description:

    Attempts to retrieve the domain from DHCP. In this case, the DHCP server
    gave out the domain name we are supposed to use

Arguments:

    Data        - pointer to place to return the list

    DataLength  - length of Data

Return Value:

    UINT

--*/

{
    LPDHCP_QUERYINFO pInfo;

    pInfo = GetDhcpHardwareInfo();
    if (pInfo) {

        UINT n;
        LPDHCP_NIC_INFO pNicInfo;

        //
        // search for the first domain name in the NIC list
        //

        n = (UINT)pInfo->NumNICs;
        pNicInfo = &pInfo->NicInfo[0];

        //
        // BUGBUG - is this correct for multi-homed hosts?
        //

        while (n--) {

            DWORD dnLen;

            dnLen = pNicInfo->DomainNameLen;
            if (dnLen && (DataLength >= dnLen)) {

                IF_DEBUG(REGISTRY) {
                    DLL_PRINT(("GetDomainNameFromDhcp() found \"%s\"\n",
                                (LPBYTE)pInfo + pNicInfo->OffsetDomainName
                                ));
                }

                memcpy(Data,
                       (LPBYTE)pInfo + pNicInfo->OffsetDomainName,
                       (size_t)dnLen
                       );

                //
                // we've got our one and only domain name (that we're interested
                // in, anyway), so exit
                //

                break;
            }
        }
        DllFreeMem((void*)pInfo);
        return ERROR_SUCCESS;
    } else {

        IF_DEBUG(REGISTRY) {
            DLL_PRINT(("GetDomainNameFromDhcp() returning %d\n",
                        ERROR_PATH_NOT_FOUND
                        ));
        }

        return ERROR_PATH_NOT_FOUND;
    }
}

/*******************************************************************************
 *
 *  GetDhcpHardwareInfo
 *
 *  Retrieves all the hardware-specific information for all adapters from the
 *  DHCP VxD
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS Success - pointer to allocated buffer containing all hardware info
 *          Failure - NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

PRIVATE
LPDHCP_QUERYINFO
GetDhcpHardwareInfo(
    VOID
    )
{
    LPDHCP_QUERYINFO info = NULL;
    DWORD_PTR handle = OpenDhcpVxdHandle();

    if (handle) {

        WORD result;
        DWORD sizeRequired;

        result = DhcpVxdRequest(handle,
                                DHCP_QUERY_INFO,
                                sizeof(sizeRequired),
                                &sizeRequired
                                );

        //
        // ERROR_BUFFER_OVERFLOW tells us exactly how many bytes we need. If we
        // don't get this error back, then its an unexpected (i.e. error)
        // situation
        //

        if (result == ERROR_BUFFER_OVERFLOW) {
            info = (LPDHCP_QUERYINFO)DllAllocMem((size_t)sizeRequired);
            if (info) {
                result = DhcpVxdRequest(handle,
                                        DHCP_QUERY_INFO,
                                        (WORD)sizeRequired,
                                        info
                                        );
                if (result != ERROR_SUCCESS) {
                    DllFreeMem((void*)info);
                }
            }
        }
    }
    if (handle) {
        OsCloseVxdHandle(handle);
    }
    return info;
}

/*******************************************************************************
 *
 *  OpenDhcpVxdHandle
 *
 *  On Snowball, just retrieves the (real-mode) entry point address to the VxD
 *
 *  ENTRY   nothing
 *
 *  EXIT    DhcpVxdEntryPoint set
 *
 *  RETURNS DhcpVxdEntryPoint
 *
 *  ASSUMES 1. We are running in V86 mode
 *
 ******************************************************************************/

PRIVATE
DWORD_PTR
OpenDhcpVxdHandle(
    VOID
    )
{
    return OsOpenVxdHandle("VDHCP", VDHCP_Device_ID);
}

/*******************************************************************************
 *
 *  DhcpVxdRequest
 *
 *  Makes a DHCP VxD request - passes a function code, parameter buffer and
 *  length to the (real-mode/V86) VxD entry-point
 *
 *  ENTRY   Handle          - handle for Win32 call
 *          Request         - DHCP VxD request
 *          BufferLength    - length of Buffer
 *          Buffer          - pointer to request-specific parameters
 *
 *  EXIT    depends on request
 *
 *  RETURNS Success - 0
 *          Failure - ERROR_PATH_NOT_FOUND
 *                      Returned if a specified adapter address could not be
 *                      found
 *
 *                    ERROR_BUFFER_OVERFLOW
 *                      Returned if the supplied buffer is too small to contain
 *                      the requested information
 *
 *  ASSUMES
 *
 ******************************************************************************/

PRIVATE
WORD
DhcpVxdRequest(
    IN DWORD_PTR Handle,
    IN WORD Request,
    IN WORD BufferLength,
    OUT LPVOID Buffer
    )
{
    return (WORD) OsSubmitVxdRequest(Handle,
                                    (INT)Request,
                                    (LPVOID)Buffer,
                                    (INT)BufferLength
                                    );
}


PRIVATE
DWORD_PTR
OsOpenVxdHandle(
    CHAR * VxdName,
    WORD   VxdId
    )
{
    HANDLE  VxdHandle;
    CHAR    VxdPath[MAX_PATH];

    //
    //  Sanity check.
    //

    DLL_ASSERT( VxdName != NULL );
    DLL_ASSERT( VxdId != 0 );

    IF_DEBUG( VXD_IO )
    {
        DLL_PRINT(( "OsOpenVxdHandle: id = %04X, name = %s\n",
                    VxdId,
                    VxdName ));
    }

    //
    //  Build the VxD path.
    //

    FSTRCPY( VxdPath, "\\\\.\\");
	if(FSTRLEN(VxdPath) + FSTRLEN(VxdName) >= sizeof(VxdPath) / sizeof(VxdPath[0]))
	{
		DLL_ASSERT(FALSE);
		return 0;
	}

    FSTRCAT( VxdPath, VxdName);

    //
    //  Open the device.
    //
    //  First try the name without the .VXD extension.  This will
    //  cause CreateFile to connect with the VxD if it is already
    //  loaded (CreateFile will not load the VxD in this case).
    //

    VxdHandle = CreateFile( VxdPath,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_DELETE_ON_CLOSE,
                            NULL );

    if( VxdHandle == INVALID_HANDLE_VALUE )
    {
        //
        //  Not found.  Append the .VXD extension and try again.
        //  This will cause CreateFile to load the VxD.
        //

        FSTRCAT( VxdPath, ".VXD" );
        VxdHandle = CreateFile( VxdPath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
    }

    if( VxdHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VXD_IO )
        {
            DLL_PRINT(( "OsOpenVxdHandle: returning handle %08lX\n",
                        VxdHandle ));
        }

        return (DWORD_PTR)VxdHandle;
    }


    IF_DEBUG( VXD_IO )
    {
        DLL_PRINT(( "OsOpenVxdHandle: cannot open %s (%04X), error %d\n",
                    VxdPath,
                    VxdId,
                    GetLastError() ));
    }

    return 0;

}   // OsOpenVxdHandle


PRIVATE
VOID
OsCloseVxdHandle(
    DWORD_PTR VxdHandle
    )
{
    //
    //  Sanity check.
    //

    DLL_ASSERT( VxdHandle != 0 );

    IF_DEBUG( VXD_IO )
    {
        DLL_PRINT(( "OsCloseVxdHandle: handle %08X\n",
                    VxdHandle ));
    }

    if( !CloseHandle( (HANDLE)VxdHandle ) )
    {
        DLL_PRINT(( "OsCloseVxdHandle: cannot close handle %08X, error %d\n",
                    VxdHandle,
                    GetLastError() ));
    }

}   // OsCloseVxdHandle


PRIVATE
INT
OsSubmitVxdRequest(
    DWORD_PTR   VxdHandle,
    INT         OpCode,
    LPVOID      Param,
    INT         ParamLength
    )
{
    DWORD BytesRead;
    INT   Result = 0;

    //
    //  Sanity check.
    //

    DLL_ASSERT( VxdHandle != 0 );
    DLL_ASSERT( ( Param != NULL ) || ( ParamLength == 0 ) );

    IF_DEBUG( VXD_IO )
    {
        DLL_PRINT(( "OsSubmitVxdRequest: opcode %04X, param %08lX, length %d\n",
                    OpCode,
                    Param,
                    ParamLength ));
    }

    if( !DeviceIoControl( (HANDLE)VxdHandle,
                          OpCode,
                          Param,
                          ParamLength,
                          Param,
                          ParamLength,
                          &BytesRead,
                          NULL ) )
    {
        Result = GetLastError();
    }

    IF_DEBUG( VXD_IO )
    {
        DLL_PRINT(( "OsSubmitVxdRequest: returning %d\n",
                    Result ));
    }

    return Result;

}   // OsSubmitVxdRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\auth.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    auth.h

Abstract:

    Private include file for 

Author:

    Rajeev Dujari (rajeevd) 28-Jul-97
    
Revision History:

--*/

//
// manifests
//
 
#define HTTP_AUTHORIZATION_SZ           "Authorization:"
#define HTTP_AUTHORIZATION_LEN          (sizeof(HTTP_AUTHORIZATION_SZ)-1)

#define HTTP_PROXY_AUTHORIZATION_SZ     "Proxy-Authorization:"
#define HTTP_PROXY_AUTHORIZATION_LEN    (sizeof(HTTP_PROXY_AUTHORIZATION_SZ)-1)


//
// prototypes - versions of spluginx.hxx for basic auth
//


STDAPI_(void) UrlZonesDetach (void);

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD g_cSspiContexts; // refcount of sspi contexts

DWORD SSPI_Unload();

DWORD_PTR SSPI_InitScheme (LPSTR pszScheme);

#ifdef __cplusplus
} // end extern "C" {
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\basic.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
BASIC_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
BASIC_CTX::BASIC_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, PWC* pPWC)
    : AUTHCTX(pSPM, pPWC)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
BASIC_CTX::~BASIC_CTX()
{}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "BASIC_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    LPSTR pszUserPass = NULL;
    LPSTR pszPass = NULL;

    AuthLock();

    DWORD dwError = ERROR_SUCCESS;

    if (!_pPWC->lpszUser || !_pPWC->lpszPass)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    pszPass = _pPWC->GetPass();

    if (!pszPass)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    // Prefix the header value with the auth type.
    const static BYTE szBasic[] = "Basic ";

    #define BASIC_LEN sizeof(szBasic)-1

    memcpy (pBuf, szBasic, BASIC_LEN);
    pBuf += BASIC_LEN;
    
    DWORD cbMaxUserPathLen = strlen(_pPWC->lpszUser) + 1 
                             + strlen(pszPass) + 1 
                             + 10;
                // HTUU_encode() parse the buffer 3 bytes at a time; 
                // In the worst case we will be two bytes short, so add at least 2 here. 
                // longer buffer doesn't matter, HTUU_encode will adjust appropreiately.
    DWORD cbUserPass;

    pszUserPass = new CHAR[cbMaxUserPathLen];

    if (pszUserPass == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    cbUserPass = wsprintf(pszUserPass, "%s:%s", _pPWC->lpszUser, pszPass);
    
    INET_ASSERT (cbUserPass < sizeof(cbMaxUserPathLen));

    HTUU_encode ((PBYTE) pszUserPass, cbUserPass,
        pBuf, *pcbBuf - BASIC_LEN);

    *pcbBuf = BASIC_LEN + lstrlen (pBuf);
    
    _pvContext = (LPVOID) 1;

    
exit:
    if (pszUserPass != NULL)
        delete [] pszUserPass;

    if (pszPass != NULL)
    {
        SecureZeroMemory(pszPass, strlen(pszPass));
        FREE_MEMORY(pszPass);
    }

    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "BASIC_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    AuthLock();

    DWORD dwAuthIdx, cbRealm, dwError;
    LPSTR szRealm = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get any realm.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
        &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

    // No realm is OK.
    if (dwError != ERROR_SUCCESS)
        szRealm = NULL;

    // If we already have a pwc, ensure that the realm matches. If not,
    // find or create a new one and set it in the auth context.
    if (_pPWC)
    {
        if (_pPWC->lpszRealm && szRealm && lstrcmp(_pPWC->lpszRealm, szRealm))
        {
            // Realms don't match - create a new pwc entry, release the old.
            _pPWC->nLockCount--;
            _pPWC = FindOrCreatePWC(pRequest, fIsProxy, _pSPMData, szRealm);
            INET_ASSERT(_pPWC->pSPM == _pSPMData);
            _pPWC->nLockCount++;
        }
    }
    // If no password cache is set in the auth context,
    // find or create one and set it in the auth context.
    else
    {            
        // Find or create a password cache entry.
        _pPWC = FindOrCreatePWC(pRequest, fIsProxy, _pSPMData, szRealm);
        if (!_pPWC)
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
        INET_ASSERT(_pPWC->pSPM == _pSPMData);
        _pPWC->nLockCount++;
    }

    if (!_pPWC)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;
    }

    dwError = ERROR_SUCCESS;
        
    exit:

    if (szRealm)
        delete []szRealm;

    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}


/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "BASIC_CTX::PostAuthUser",
        "this=%#x",
        this
        ));

    DWORD dwRet;
    AuthLock();

    if (! _pvContext && !_pRequest->GetPWC() 
        && _pPWC->lpszUser && _pPWC->lpszPass)
        dwRet = ERROR_INTERNET_FORCE_RETRY;
    else
        dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;

    _pRequest->SetPWC(NULL);
    _pvContext = (LPVOID) 1;

    AuthUnlock();

    DEBUG_LEAVE(dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\htuu.c ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com

   This file was removed from LibWWW and placed into the
   Security Protocol Module.

   jeff@spyglass.com
 */

/* MODULE                           HTUU.c
   **           UUENCODE AND UUDECODE
   **
   ** ACKNOWLEDGEMENT:
   **   This code is taken from rpem distribution, and was originally
   **   written by Mark Riordan.
   **
   ** AUTHORS:
   **   MR  Mark Riordan    riordanmr@clvax1.cl.msu.edu
   **   AL  Ari Luotonen    luotonen@dxcern.cern.ch
   **
   ** HISTORY:
   **   Added as part of the WWW library and edited to conform
   **   with the WWW project coding standards by:   AL  5 Aug 1993
   **   Originally written by:              MR 12 Aug 1990
   **   Original header text:
   ** -------------------------------------------------------------
   **  File containing routines to convert a buffer
   **  of bytes to/from RFC 1113 printable encoding format.
   **
   **  This technique is similar to the familiar Unix uuencode
   **  format in that it maps 6 binary bits to one ASCII
   **  character (or more aptly, 3 binary bytes to 4 ASCII
   **  characters).  However, RFC 1113 does not use the same
   **  mapping to printable characters as uuencode.
   **
   **  Mark Riordan   12 August 1990 and 17 Feb 1991.
   **  This code is hereby placed in the public domain.
   ** -------------------------------------------------------------
   **
   ** BUGS:
   **
   **
 */


const static char six2pr[64] =
{
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

static unsigned char pr2six[256];


/*--- function HTUU_encode -----------------------------------------------
 *
 *   Encode a single line of binary data to a standard format that
 *   uses only printing ASCII characters (but takes up 33% more bytes).
 *
 *    Entry    bufin    points to a buffer of bytes.  If nbytes is not
 *                      a multiple of three, then the byte just beyond
 *                      the last byte in the buffer must be 0.
 *             nbytes   is the number of bytes in that buffer.
 *                      This cannot be more than 48.
 *             bufcoded points to an output buffer.  Be sure that this
 *                      can hold at least 1 + (4*nbytes)/3 characters.
 *             outbufmax maximum size of the buffer bufcoded.
 *
 *    Exit     bufcoded contains the coded line.  The first 4*nbytes/3 bytes
 *                      contain printing ASCII characters representing
 *                      those binary bytes. This may include one or
 *                      two '=' characters used as padding at the end.
 *                      The last byte is a zero byte.
 *             Returns the number of ASCII characters in "bufcoded".
 */
int HTUU_encode(unsigned char *bufin, unsigned int nbytes, char *bufcoded,
                long outbufmax)
{
/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

	register char *outptr = bufcoded;
	unsigned int i;

	for (i = 0; i < nbytes; i += 3)
	{
        if ( (outptr - bufcoded + 4) > outbufmax )
            return (-1);

		*(outptr++) = ENC(*bufin >> 2);		/* c1 */
		*(outptr++) = ENC(((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017));		/*c2 */
		*(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));	/*c3 */
		*(outptr++) = ENC(bufin[2] & 077);	/* c4 */

		bufin += 3;
	}

	/* If nbytes was not a multiple of 3, then we have encoded too
	 * many characters.  Adjust appropriately.
	 */
	if (i == nbytes + 1)
	{
		/* There were only 2 bytes in that last group */
		outptr[-1] = '=';
	}
	else if (i == nbytes + 2)
	{
		/* There was only 1 byte in that last group */
		outptr[-1] = '=';
		outptr[-2] = '=';
	}

    if ( (outptr - bufcoded) + 1 < outbufmax )
    	*outptr = '\0';

	return ((int)(outptr - bufcoded));
}


/*--- function HTUU_decode ------------------------------------------------
 *
 *  Decode an ASCII-encoded buffer back to its original binary form.
 *
 *    Entry    bufcoded    points to a uuencoded string.  It is 
 *                         terminated by any character not in
 *                         the printable character table six2pr, but
 *                         leading whitespace is stripped.
 *             bufplain    points to the output buffer; must be big
 *                         enough to hold the decoded string (generally
 *                         shorter than the encoded string) plus
 *                         as many as two extra bytes used during
 *                         the decoding process.
 *             outbufsize  is the maximum number of bytes that
 *                         can fit in bufplain.
 *
 *    Exit     Returns the number of binary bytes decoded.
 *             bufplain    contains these bytes.
 */
int HTUU_decode(char *bufcoded, unsigned char *bufplain, int outbufsize)
{
/* single character decode */
#define DEC(c) pr2six[(int)c]
#define MAXVAL 63

	static int first = 1;

	int nbytesdecoded, j;
	register char *bufin = bufcoded;
	register unsigned char *bufout = bufplain;
	register int nprbytes;

	/* If this is the first call, initialize the mapping table.
	 * This code should work even on non-ASCII machines.
	 */
	if (first)
	{
		first = 0;
		for (j = 0; j < 256; j++)
			pr2six[j] = MAXVAL + 1;

		for (j = 0; j < 64; j++)
			pr2six[(int) six2pr[j]] = (unsigned char) j;
#if 0
		pr2six['A'] = 0;
		pr2six['B'] = 1;
		pr2six['C'] = 2;
		pr2six['D'] = 3;
		pr2six['E'] = 4;
		pr2six['F'] = 5;
		pr2six['G'] = 6;
		pr2six['H'] = 7;
		pr2six['I'] = 8;
		pr2six['J'] = 9;
		pr2six['K'] = 10;
		pr2six['L'] = 11;
		pr2six['M'] = 12;
		pr2six['N'] = 13;
		pr2six['O'] = 14;
		pr2six['P'] = 15;
		pr2six['Q'] = 16;
		pr2six['R'] = 17;
		pr2six['S'] = 18;
		pr2six['T'] = 19;
		pr2six['U'] = 20;
		pr2six['V'] = 21;
		pr2six['W'] = 22;
		pr2six['X'] = 23;
		pr2six['Y'] = 24;
		pr2six['Z'] = 25;
		pr2six['a'] = 26;
		pr2six['b'] = 27;
		pr2six['c'] = 28;
		pr2six['d'] = 29;
		pr2six['e'] = 30;
		pr2six['f'] = 31;
		pr2six['g'] = 32;
		pr2six['h'] = 33;
		pr2six['i'] = 34;
		pr2six['j'] = 35;
		pr2six['k'] = 36;
		pr2six['l'] = 37;
		pr2six['m'] = 38;
		pr2six['n'] = 39;
		pr2six['o'] = 40;
		pr2six['p'] = 41;
		pr2six['q'] = 42;
		pr2six['r'] = 43;
		pr2six['s'] = 44;
		pr2six['t'] = 45;
		pr2six['u'] = 46;
		pr2six['v'] = 47;
		pr2six['w'] = 48;
		pr2six['x'] = 49;
		pr2six['y'] = 50;
		pr2six['z'] = 51;
		pr2six['0'] = 52;
		pr2six['1'] = 53;
		pr2six['2'] = 54;
		pr2six['3'] = 55;
		pr2six['4'] = 56;
		pr2six['5'] = 57;
		pr2six['6'] = 58;
		pr2six['7'] = 59;
		pr2six['8'] = 60;
		pr2six['9'] = 61;
		pr2six['+'] = 62;
		pr2six['/'] = 63;
#endif
	}

	/* Strip leading whitespace. */

	while (*bufcoded == ' ' || *bufcoded == '\t')
		bufcoded++;

	/* Figure out how many characters are in the input buffer.
	 * If this would decode into more bytes than would fit into
	 * the output buffer, adjust the number of input bytes downwards.
	 */
	bufin = bufcoded;
	while (pr2six[(int) *(bufin++)] <= MAXVAL) ;
	nprbytes = (int)(bufin - bufcoded) - 1;
	nbytesdecoded = ((nprbytes + 3) / 4) * 3;
	if (nbytesdecoded > outbufsize)
	{
		nprbytes = (outbufsize * 4) / 3;
	}

	bufin = bufcoded;

	while (nprbytes > 0)
	{
		*(bufout++) = (unsigned char) (DEC(*bufin) << 2 | DEC(bufin[1]) >> 4);
		*(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
		*(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
		bufin += 4;
		nprbytes -= 4;
	}

	if (nprbytes & 03)
	{
		if (pr2six[(int) bufin[-2]] > MAXVAL)
		{
			nbytesdecoded -= 2;
		}
		else
		{
			nbytesdecoded -= 1;
		}
	}

	return (nbytesdecoded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\digest.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include <security.h>
#include "auth.h"

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"

#define MAX_SILENT_RETRIES  3
#define OUTPUT_BUFFER_LEN   10000

#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

#define ISC_MODE_AUTH        0
#define ISC_MODE_PREAUTH     1
#define ISC_MODE_UI          2

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

/*-----------------------------------------------------------------------------
    DIGEST_CTX
-----------------------------------------------------------------------------*/

// Globals
PSecurityFunctionTable DIGEST_CTX::g_pFuncTbl = NULL;
CredHandle DIGEST_CTX::g_hCred;


/*---------------------------------------------------------------------------
DIGEST_CTX::GetFuncTbl
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::GetFuncTbl()
{
    HINSTANCE hSecLib;
    INIT_SECURITY_INTERFACE addrProcISI = NULL;
#ifndef UNIX
    OSVERSIONINFO   VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

    GetVersionEx (&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
    }
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#endif /* UNIX */
    {
        hSecLib = LoadLibrary (SSP_SPM_WIN95_DLL);
    }
        
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress(hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}

/*---------------------------------------------------------------------------
DIGEST_CTX::GetRequestUri
---------------------------------------------------------------------------*/
LPSTR DIGEST_CTX::GetRequestUri()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        String,
        "DIGEST_CTX::GetRequestUri",
        "this=%#x",
        this
        ));

    LPSTR szUrl;
    DWORD cbUrl;

    URL_COMPONENTS sUrl;        

    memset(&sUrl, 0, sizeof(sUrl));
    sUrl.dwStructSize = sizeof(sUrl);
    sUrl.dwHostNameLength = -1; 
    sUrl.dwUrlPathLength = -1; 
    sUrl.dwExtraInfoLength = -1; 

    szUrl = _pRequest->GetURL();

    // Generate request-uri
    if (InternetCrackUrl(szUrl, strlen(szUrl), 0, &sUrl))
    {
        cbUrl = sUrl.dwUrlPathLength;
        szUrl = new CHAR[cbUrl+1];

        if (!szUrl)
        {
            // Alloc failure. Return NULL. We will
            // use _pRequest->GetURL instead.
            DEBUG_LEAVE(NULL);
            return NULL;
        }
    
        memcpy(szUrl, sUrl.lpszUrlPath, cbUrl);
        szUrl[cbUrl] = '\0';
    }
    else
    {
        // ICU failed. Return NULL which
        // will cause _pRequest->GetURL
        // to be used.
        DEBUG_LEAVE(NULL);
        return NULL;
    }

    DEBUG_LEAVE(szUrl);
    return szUrl;
}


/*---------------------------------------------------------------------------
DIGEST_CTX::InitSecurityBuffers
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::InitSecurityBuffers(LPSTR szOutBuf, DWORD cbOutBuf,
    LPDWORD pdwSecFlags, DWORD dwISCMode)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "DIGEST_CTX::InitSecurityBuffers",
        "this=%#x szout=%#x cbout=%d secflags=%#x iscmode=%#x",
        this,
        szOutBuf,
        cbOutBuf,
        (pdwSecFlags ? *pdwSecFlags : NULL),
        dwISCMode
        ));

    LPSTR pszPass = NULL;

    // Input Buffer.    
    _SecBuffInDesc.cBuffers = NUM_BUFF;
    _SecBuffInDesc.pBuffers = _SecBuffIn;

    // Set Header
    _SecBuffIn[HEADER_IDX].pvBuffer     = _szData;
    _SecBuffIn[HEADER_IDX].cbBuffer     = _cbData;
    _SecBuffIn[HEADER_IDX].BufferType   = SECBUFFER_TOKEN;
    
    // If credentials are supplied will be set to
    // ISC_REQ_USE_SUPPLIED_CREDS.
    // If prompting for auth dialog will be set to
    // ISC_REQ_PROMPT_FOR_CREDS.
    *pdwSecFlags = 0;
    
    // Set realm if no header, otherwise NULL.
    if (_SecBuffIn[HEADER_IDX].pvBuffer)
    {
        _SecBuffIn[REALM_IDX].pvBuffer  = NULL;
        _SecBuffIn[REALM_IDX].cbBuffer  = 0;
    }
    else
    {
        // We are preauthenticating using the realm
        _SecBuffIn[REALM_IDX].pvBuffer = _pPWC->lpszRealm;
        _SecBuffIn[REALM_IDX].cbBuffer = strlen(_pPWC->lpszRealm);
    }
    
    // Host.
    _SecBuffIn[HOST_IDX].pvBuffer     = _pPWC->lpszHost;
    _SecBuffIn[HOST_IDX].cbBuffer     = strlen(_pPWC->lpszHost);
    _SecBuffIn[HOST_IDX].BufferType   = SECBUFFER_TOKEN;

    
    // Request URI.    
    if (!_szRequestUri)
    {
        _szRequestUri = GetRequestUri();
        if (_szRequestUri)
            _SecBuffIn[URL_IDX].pvBuffer     = _szRequestUri;
        else
            _SecBuffIn[URL_IDX].pvBuffer = _pRequest->GetURL();
    }

    _SecBuffIn[URL_IDX].cbBuffer     = strlen((LPSTR) _SecBuffIn[URL_IDX].pvBuffer);
    _SecBuffIn[URL_IDX].BufferType   = SECBUFFER_TOKEN;


    // HTTP method.
    _SecBuffIn[METHOD_IDX].cbBuffer = 
        MapHttpMethodType(_pRequest->GetMethodType(), (LPCSTR*) &_SecBuffIn[METHOD_IDX].pvBuffer);
    _SecBuffIn[METHOD_IDX].BufferType   = SECBUFFER_TOKEN;

    if (_SecBuffIn[PASS_IDX].pvBuffer)
    {
        INET_ASSERT(strlen((LPCSTR)_SecBuffIn[PASS_IDX].pvBuffer) == _SecBuffIn[PASS_IDX].cbBuffer);
        SecureZeroMemory(_SecBuffIn[PASS_IDX].pvBuffer, _SecBuffIn[PASS_IDX].cbBuffer);
        FREE_MEMORY(_SecBuffIn[PASS_IDX].pvBuffer);
    }

    // User and pass might be provided from pwc entry. Use only if
    // we have a challenge header (we don't pre-auth using supplied creds).
    if (dwISCMode == ISC_MODE_AUTH && _pPWC->lpszUser && *_pPWC->lpszUser 
        && (pszPass = _pPWC->GetPass()) && *pszPass)
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = _pPWC->lpszUser;
        _SecBuffIn[USER_IDX].cbBuffer     = strlen(_pPWC->lpszUser);
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = pszPass;
        _SecBuffIn[PASS_IDX].cbBuffer     = strlen(pszPass);
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
        *pdwSecFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }
    else
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = NULL;  
        _SecBuffIn[USER_IDX].cbBuffer     = 0;
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = NULL;
        _SecBuffIn[PASS_IDX].cbBuffer     = 0;
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
    }

    // If the 'if' statement above caused the pszPass variable to be allocated
    // but it was not assigned to _SecBuffIn[PASS_IDX].pvBuffer, then free it.
    if (pszPass != NULL && _SecBuffIn[PASS_IDX].pvBuffer == NULL)
    {
        SecureZeroMemory(pszPass, strlen(pszPass));
        FREE_MEMORY(pszPass);
    }

    if (dwISCMode == ISC_MODE_UI)
        *pdwSecFlags = ISC_REQ_PROMPT_FOR_CREDS;
        
    // Out Buffer.
    _SecBuffOutDesc.cBuffers    = 1;
    _SecBuffOutDesc.pBuffers    = _SecBuffOut;
    _SecBuffOut[0].pvBuffer     = szOutBuf;
    _SecBuffOut[0].cbBuffer     = cbOutBuf;
    _SecBuffOut[0].BufferType   = SECBUFFER_TOKEN;

    DEBUG_LEAVE(0);
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
DIGEST_CTX::DIGEST_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, PWC* pPWC)
    : AUTHCTX(pSPM, pPWC)
{
    SECURITY_STATUS ssResult;
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;

    _szAlloc      = NULL;
    _szData       = NULL;
    _pvContext    = NULL;
    _szRequestUri = NULL;
    _cbData       = 0;
    _cbContext    = 0;
    _nRetries     = 0;
    
    
    // Zero out the security buffers and request context.
    memset(&_SecBuffInDesc,  0, sizeof(_SecBuffInDesc));
    memset(&_SecBuffOutDesc, 0, sizeof(_SecBuffInDesc));
    memset(_SecBuffIn,       0, sizeof(_SecBuffIn));
    memset(_SecBuffOut,      0, sizeof(_SecBuffOut));
    memset(&_hCtxt,          0, sizeof(_hCtxt));
        
    // Is this the first time that the digest SSPI package
    // is being called for this process.
    if (!g_pFuncTbl)
    {
        // Get the global SSPI dispatch table.
        GetFuncTbl();

        DIGEST_PKG_DATA             PkgData;
        SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;

        // Logon with szAppCtx = szUserCtx = NULL.
        PkgData.szAppCtx = PkgData.szUserCtx = NULL;
        memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

        SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
        SecIdExA.User = (unsigned char*) &PkgData;
        SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);
        
        // Get the global credentials handle.
        ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
            (NULL, "Digest", SECPKG_CRED_OUTBOUND, NULL, &SecIdExA, NULL, 0, &g_hCred, NULL);
    }
}


/*---------------------------------------------------------------------------
DIGEST_CTX::PromptForCreds
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PromptForCreds(HWND hWnd)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "DIGEST_CTX::PromptForCreds",
        "this=%#x hwnd=%#x",
        this,
        hWnd
        ));

    SECURITY_STATUS ssResult;
        
    // Prompt for the credentials.
    INET_ASSERT(_pvContext);
    _cbContext = OUTPUT_BUFFER_LEN;

    DWORD sf;
    InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_UI);

    _SecBuffIn[HWND_IDX].pvBuffer = &hWnd;
    _SecBuffIn[HWND_IDX].cbBuffer = sizeof(HWND);

    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))(&g_hCred, &_hCtxt, NULL, sf, 
        0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

    _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;    

    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        DEBUG_LEAVE(ERROR_CANCELLED);
        return ERROR_CANCELLED;
    }

    DEBUG_LEAVE((DWORD) ssResult);
    return (DWORD) ssResult;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
DIGEST_CTX::~DIGEST_CTX()
{
    if (_szAlloc)
        delete _szAlloc;

    if (_pvContext)
        delete _pvContext;

    if (_szRequestUri)
        delete _szRequestUri;

    if (_SecBuffIn[PASS_IDX].pvBuffer)
    {
        INET_ASSERT(strlen((LPCSTR)_SecBuffIn[PASS_IDX].pvBuffer) == _SecBuffIn[PASS_IDX].cbBuffer);
        SecureZeroMemory(_SecBuffIn[PASS_IDX].pvBuffer, _SecBuffIn[PASS_IDX].cbBuffer);
        FREE_MEMORY(_SecBuffIn[PASS_IDX].pvBuffer);
    }
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PreAuthUser(OUT LPSTR pBuff, IN OUT LPDWORD pcbBuff)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "DIGEST_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuff,
        pcbBuff,
        *pcbBuff
        ));

    AuthLock();

    SECURITY_STATUS ssResult = SEC_E_OK;
    INET_ASSERT(_pSPMData == _pPWC->pSPM);

    // If a response has been generated copy into output buffer.
    if (_cbContext)
    {
        memcpy(pBuff, _pvContext, _cbContext);
        *pcbBuff = _cbContext;
    }
    // Otherwise attempt to preauthenticate.
    else
    {
        // Call into the SSPI package.
        DWORD sf;
        InitSecurityBuffers(pBuff, *pcbBuff, &sf, ISC_MODE_PREAUTH);
    
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
            0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
    
        *pcbBuff = _SecBuffOut[0].cbBuffer;
    }

    AuthUnlock();
    DEBUG_LEAVE((DWORD) ssResult);            
    return (DWORD) ssResult;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "DIGEST_CTX::UpdateFromHeaders",
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwError, cbExtra, dwAuthIdx;
    LPSTR szAuthHeader, szExtra, szScheme;
    LPSTR szRealm; 
    DWORD cbRealm;

    AuthLock();
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // If this auth ctx does not have pwc then it has been
    // just been constructed in response to a 401.
    if (!_pPWC)
    {
        // Get any realm.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
            &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

        _pPWC = FindOrCreatePWC(pRequest, fIsProxy, _pSPMData, szRealm);

        if (_pPWC)
        {
            INET_ASSERT(_pPWC->pSPM == _pSPMData);
            _pPWC->nLockCount++;
        }
        else
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
    }

    // Updating the buffer - delete old one if necessary.
    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = _szData = NULL;
        _cbData = 0;
    }

    // Get the entire authentication header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
        &_szAlloc, &_cbData, ALLOCATE_BUFFER, dwAuthIdx);
    
    // Point just past scheme
    _szData = _szAlloc;
    while (*_szData != ' ')
    {
        _szData++;
        _cbData--;
    }

    // The request will be retried.
    dwError = ERROR_SUCCESS;
exit:
    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "DIGEST_CTX::PostAuthUser",
        "this=%#x",
        this
        ));

    INET_ASSERT(_pSPMData == _pPWC->pSPM);

    AuthLock();
    
    DWORD dwError;
    SECURITY_STATUS ssResult;

    // Allocate an output buffer if not done so already.
    if (!_pvContext)
    {
        _pvContext = new CHAR[OUTPUT_BUFFER_LEN];
        if (!_pvContext)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }

    _cbContext = OUTPUT_BUFFER_LEN;


    if (_nRetries++ < MAX_SILENT_RETRIES)
    {
        // If we pre-authenticated, treat as second
        // or subsequent attempt. We depend on the
        // server correctly sending stale=FALSE (or no stale)
        // if the credentials sent during pre-auth were bad.
        // In this case the digest pkg will return SEC_E_NO_CREDENTIALS
        // and we will prompt for credentials.
        // BUGBUG - Use ApplyControlToken
        if (_nRetries == 1 && _pRequest->GetPWC())
        {
            // Increment num of retries to 2
            _nRetries++;

            // The dwLower member has to have the correct value
            // so that secur32.dll can route to correct provider.
            _hCtxt.dwLower = g_hCred.dwLower;
        }

        // Call into the SSPI package.

        DWORD sf;
        InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_AUTH);
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))
            (&g_hCred, (_nRetries == 1 ? NULL : &_hCtxt), NULL, sf, 
            0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
        _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;
        
        switch(ssResult)
        {
            case SEC_E_OK:
            {
                dwError = ERROR_INTERNET_FORCE_RETRY;
                break;
            }
            case SEC_E_NO_CREDENTIALS:
            {
                dwError = ERROR_INTERNET_INCORRECT_PASSWORD;
                break;
            }
            case SEC_E_CONTEXT_EXPIRED:
            {
                dwError = ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;
                break;
            }
            default:
                dwError = ERROR_INTERNET_LOGIN_FAILURE;
        }
    }
    else
    {
        _cbContext = 0;
        _nRetries = 0;
        dwError = ERROR_INTERNET_INCORRECT_PASSWORD;
    }

exit:
    _pRequest->SetPWC(NULL);
    
    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}

/*---------------------------------------------------------------------------
    Flush creds
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::FlushCreds()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "DIGEST_CTX::FlushCreds",
        NULL
        ));

    DWORD ssResult;
    if (g_pFuncTbl)
    {
        DWORD sf = ISC_REQ_NULL_SESSION;
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
            0, 0, NULL, 0, NULL, NULL, NULL, NULL);
    }

    DEBUG_LEAVE(0);
}

/*---------------------------------------------------------------------------
    Logoff
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::Logoff()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "DIGEST_CTX::Logoff",
        NULL
        ));

    DWORD ssResult;
    if (g_pFuncTbl)
    {
        ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(&g_hCred);
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\msnspmh.h ===
#ifndef _MSNSPMH_H_
#define _MSNSPMH_H_

#define SECURITY_WIN32  1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <winerror.h>
#include <rpc.h>
#include <stdarg.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>

#include <sspi.h>
#include <ntlmsp.h>
//#include <crypt.h>
//#include <ntlmsspi.h>
#include <msnssp.h>
#include <wininet.h>
#include <spluginx.hxx>
#include "htuu.h"
#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
extern BOOL g_fIsWhistler;
LPVOID SSPI_InitGlobals(void);

#endif  // _MSNSPMH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\msnssp.h ===
//+---------------------------------------------------------------------------
//
//  File:       msnssp.h
//
//  Contents:	MSNSSP specific parameters and characteristics
//
//  History:    SudK    Created     7/13/95
//
//----------------------------------------------------------------------------
#ifndef _MSNSSP_H_
#define _MSNSSP_H_

#define MSNSP_NAME_A		"MSN"
#define MSNSP_COMMENT_A		"MSN Security Package"
#define MSNSP_NAME_W		L"MSN"
#define MSNSP_COMMENT_W		L"MSN Security Package"

#ifdef UNICODE
#define MSNSP_NAME  MSNSP_NAME_W
#define MSNSP_COMMENT   MSNSP_COMMENT_W
#else
#define MSNSP_NAME  MSNSP_NAME_A
#define MSNSP_COMMENT   MSNSP_COMMENT_A
#endif

//
//  The following defines the possible values for the 'Type' field in 
//  the security context structure on a server or client application.
//
#define MSNSP_CLIENT_CTXT   0
#define MSNSP_SERVER_CTXT   1

typedef ULONG MSNSP_CTXT_TYPE;

#define MSNSP_CAPABILITIES	(SECPKG_FLAG_CONNECTION |			\
							 SECPKG_FLAG_MULTI_REQUIRED |		\
							 SECPKG_FLAG_TOKEN_ONLY |			\
							 SECPKG_FLAG_INTEGRITY |			\
							 SECPKG_FLAG_PRIVACY)

#define MSNSP_VERSION			1
#define MSNSP_MAX_TOKEN_SIZE	0x0300

#define MSNSP_RPCID			11		// BUGBUG. What should this be?

#define DUMMY_CREDHANDLE	400		// BUGBUG. This should go eventually

#define SEC_E_PRINCIPAL_UNKNOWN SEC_E_UNKNOWN_CREDENTIALS
#define SEC_E_PACKAGE_UNKNOWN SEC_E_SECPKG_NOT_FOUND
//#define SEC_E_BUFFER_TOO_SMALL SEC_E_INSUFFICIENT_MEMORY
//#define SEC_I_CALLBACK_NEEDED SEC_I_CONTINUE_NEEDED
#define SEC_E_INVALID_CONTEXT_REQ SEC_E_NOT_SUPPORTED
#define SEC_E_INVALID_CREDENTIAL_USE SEC_E_NOT_SUPPORTED

#define SSP_RET_REAUTHENTICATION 0x8000000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\httpfilt.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    httpfilt.cxx

Abstract:

    This file contains implementation for HTTP filters.

    Contents:
        HTTPFILT methods
        HttpFiltOpen
        HttpFiltClose
        HttpFiltOnRequest
        HttpFiltOnResponse
        HttpFiltOnBlockingOps
        HttpFiltOnTransactionComplete

Author:

    Rajeev Dujari (RajeevD) 01-Jul-1996

Revision History:

TO DO
    Get urlmon to call InternetErrorDlg on ERROR_INTERNET_NEED_UI
    Deal with OnRequest returning ERROR_INTERNET_NEED_UI

    Generate list of filters from registry.
    Call filters only if matching headers.
    Wrap debug statements around filter calls
    Update documentation.

    Allow filters to modify response headers

NOTES
    Don't unload filters before shutdown because request handles
      may have references to them.

--*/

#include "wininetp.h"
#include "httpfilt.h"

struct CONTEXT_ENTRY : public SERIALIZED_LIST_ENTRY
{
    HINTERNET hRequest;
    LPVOID    lpContext;
};

class HTTPFILT
{
    HMODULE hFilter;
    LPVOID  lpFilterContext;
    SERIALIZED_LIST slContexts;      // list of CONTEXT_ENTRY

    PFN_FILTEROPEN                   pfnOpen;
    PFN_FILTERBEGINNINGTRANSACTION   pfnOnRequest;
    PFN_FILTERONRESPONSE             pfnOnResponse;
    PFN_FILTERONBLOCKINGOPS          pfnOnBlockingOps;
    PFN_FILTERONTRANSACTIONCOMPLETE  pfnOnTransactionComplete;

    LPVOID* GetContextPtr (HINTERNET hRequest);

public:
    BOOL Open (void);
    BOOL Close (void);
    BOOL OnRequest (HINTERNET hRequest);
    BOOL OnResponse (HINTERNET hRequest);
    BOOL OnTransactionComplete (HINTERNET hRequest);
    BOOL OnBlockingOps (HINTERNET hRequest, HWND hwnd);
};

PRIVATE BOOL fOpen = FALSE;
PRIVATE HTTPFILT httpfiltRPA;
PRIVATE HTTPFILT *pRPA = NULL;

/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

LPVOID* HTTPFILT::GetContextPtr (HINTERNET hRequest)
{
    // Search for this entry.
    LockSerializedList (&slContexts);

    // Get the head of the list.  Be sure it is not the dummy entry.
    CONTEXT_ENTRY *pce = (CONTEXT_ENTRY *) HeadOfSerializedList (&slContexts);
    if ((PLIST_ENTRY) pce == &slContexts.List)
        pce = NULL;

    while (pce)
    {
        if (pce->hRequest == hRequest)
            goto done;
        pce = (CONTEXT_ENTRY *) NextInSerializedList (&slContexts, pce);
    }

    // Create a new entry.
    if (!(pce = new CONTEXT_ENTRY))
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        UnlockSerializedList (&slContexts);
        return NULL;
    }
    pce->hRequest = hRequest;
    pce->lpContext = NULL;
    InsertAtHeadOfSerializedList (&slContexts, &pce->List);

done:

    UnlockSerializedList (&slContexts);
    return &pce->lpContext;
}


/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

BOOL HttpFiltOpen (void)
{
    if (!fOpen)
    {
        HKEY hkey;

        char szRpaKey[MAX_PATH];
        strcpy (szRpaKey, INTERNET_SETTINGS_KEY);
        strcat (szRpaKey, "\\Http Filters\\RPA");
        if (  !RegOpenKeyEx (HKEY_CURRENT_USER,  szRpaKey, 0, KEY_READ, &hkey)
          || !RegOpenKeyEx (HKEY_LOCAL_MACHINE, szRpaKey, 0, KEY_READ, &hkey))
        {
            REGCLOSEKEY (hkey);
            if (httpfiltRPA.Open())
                pRPA = &httpfiltRPA;
        }

        fOpen = TRUE;
    }
    return TRUE;
}


BOOL HTTPFILT::Open(void)
{
    hFilter = LoadLibrary ("RPAWINET.DLL");
    if (!hFilter)
        goto err;

    // If there's an open function, call it.
    pfnOpen = (PFN_FILTEROPEN) GetProcAddress (hFilter, SZFN_FILTEROPEN);
    if (pfnOpen)
    {
        BOOL fFilter;

        __try
        {
            fFilter = (*pfnOpen) (&lpFilterContext, "RPA", NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT(HTTP, ERROR, ("HttpFilterOpen faulted\n"));
            fFilter = FALSE;
        }
        ENDEXCEPT
        if (!fFilter)
            goto err;
    }

    InitializeSerializedList (&slContexts);

    // Look up other entry points.
    pfnOnRequest  = (PFN_FILTERBEGINNINGTRANSACTION)
        GetProcAddress (hFilter, SZFN_FILTERBEGINNINGTRANSACTION);
    pfnOnResponse = (PFN_FILTERONRESPONSE)
        GetProcAddress (hFilter, SZFN_FILTERONRESPONSE);
    pfnOnTransactionComplete  = (PFN_FILTERONTRANSACTIONCOMPLETE)
        GetProcAddress (hFilter, SZFN_FILTERONTRANSACTIONCOMPLETE);
    pfnOnBlockingOps  = (PFN_FILTERONBLOCKINGOPS)
        GetProcAddress (hFilter, SZFN_FILTERONBLOCKINGOPS);
    return TRUE;

err:

    if (hFilter)
    {
        FreeLibrary (hFilter);
        hFilter = NULL;
    }
    return FALSE;
}

/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

HttpFiltClose(void)
{
    if (fOpen)
    {
        if (pRPA)
        {
            pRPA->Close();
            pRPA = NULL;
        }
        fOpen = FALSE;
    }
    return TRUE;
}


BOOL HTTPFILT::Close (void)
{
    TerminateSerializedList (&slContexts);

    if (hFilter)
    {
        if (pfnOpen)
        {
            PFN_FILTERCLOSE pfnClose;
            pfnClose = (PFN_FILTERCLOSE)
                GetProcAddress (hFilter, SZFN_FILTERCLOSE);

            __try
            {
                (*pfnClose) (lpFilterContext, InDllCleanup);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                 DEBUG_PRINT(HTTP, ERROR, ("HttpFilterClose faulted\n"));
            }
            ENDEXCEPT
        }
        FreeLibrary (hFilter);
    }
    return TRUE;
}

/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

BOOL HttpFiltOnRequest (LPVOID pRequest)
{
    INET_ASSERT (fOpen);
    if (!pRPA)
        return TRUE;
    return pRPA->OnRequest(((HTTP_REQUEST_HANDLE_OBJECT *)pRequest)->GetPseudoHandle());
}

BOOL HTTPFILT::OnRequest(HINTERNET hRequest)
{
    if (pfnOnRequest)
    {
        LPVOID *lppvContext = GetContextPtr(hRequest);
        if (!lppvContext)
            return FALSE;

        BOOL fFilter;

        __try
        {
            fFilter = (*pfnOnRequest)
                (lpFilterContext, lppvContext, hRequest, NULL);
            INET_ASSERT (fFilter);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
             DEBUG_PRINT(HTTP, ERROR, ("HttpFilterOnRequest faulted\n"));
             fFilter = FALSE;
        }
        ENDEXCEPT
    }
    return TRUE;
}

/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/


BOOL HttpFiltOnResponse (LPVOID pObject)
{
    INET_ASSERT (fOpen);
    if (!pRPA)
        return TRUE;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)pObject;
    BOOL fFilter = pRPA->OnResponse (pRequest->GetPseudoHandle());
    if (!fFilter)
    {
        switch (GetLastError())
        {
            case ERROR_INTERNET_NEED_UI:
            {
                pRequest->SetBlockingFilter (pRPA);
                break;
            }

            case ERROR_INTERNET_FORCE_RETRY:
            {
                    // Sink any bytes before restarting the send request.
                BYTE szSink[1024];
                    DWORD dwBytesRead = 1;
                while (dwBytesRead && ERROR_SUCCESS == pRequest->ReadData
                    (szSink, sizeof(szSink), &dwBytesRead, TRUE, 0));
                SetLastError (ERROR_INTERNET_FORCE_RETRY);
                break;
            }
        }
    }

    return fFilter;
}

BOOL HTTPFILT::OnResponse(HINTERNET hRequest)
{
    BOOL fFilter;

    if (pfnOnResponse)
    {
        LPVOID *lppvContext = GetContextPtr(hRequest);
        if (!lppvContext)
            return FALSE;

        __try
        {
            fFilter = (*pfnOnResponse)
                (lpFilterContext, lppvContext, hRequest, NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
             DEBUG_PRINT(HTTP, ERROR, ("HttpFilterOnResponse faulted\n"));
             fFilter = FALSE;
        }
        ENDEXCEPT
        if (!fFilter)
            return FALSE;
    }

    return TRUE;
}

/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

BOOL HttpFiltOnBlockingOps
    (LPVOID pObject, HINTERNET hRequest, HWND hwnd)
{
    INET_ASSERT (fOpen);
    INET_ASSERT (pRPA);

    HTTP_REQUEST_HANDLE_OBJECT * pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) pObject;
    HTTPFILT *lpFilter = (HTTPFILT *) pRequest->GetBlockingFilter();
    INET_ASSERT (lpFilter == pRPA);

    BOOL fFilter = lpFilter->OnBlockingOps(hRequest, hwnd);
    if (!fFilter && GetLastError() == ERROR_INTERNET_FORCE_RETRY)
    {
        // Sink any bytes before restarting the send request.
        BYTE szSink[1024];
        DWORD dwBytesRead = 1;
        while (dwBytesRead && ERROR_SUCCESS == pRequest->ReadData
            (szSink, sizeof(szSink), &dwBytesRead, TRUE, 0));
        SetLastError (ERROR_INTERNET_FORCE_RETRY);
    }
    return fFilter;
}


BOOL HTTPFILT::OnBlockingOps (HINTERNET hRequest, HWND hwnd)
{
    if (pfnOnBlockingOps)
    {
        LPVOID *lppvContext = GetContextPtr(hRequest);
        if (!lppvContext)
            return FALSE;
        BOOL fFilter;

        __try
        {
            fFilter = (*pfnOnBlockingOps)
                (lpFilterContext, lppvContext, hRequest, hwnd, NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
             DEBUG_PRINT(HTTP, ERROR, ("HttpFilterOnBlockingOps faulted\n"));
             fFilter = FALSE;
        }
        ENDEXCEPT
        return fFilter;
    }

    return TRUE;
}


/*++

Routine Description:

Arguments:

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

BOOL HttpFiltOnTransactionComplete (HINTERNET hRequest)
{
    INET_ASSERT (fOpen);
    if (!pRPA)
        return TRUE;
    else
        return pRPA->OnTransactionComplete (hRequest);
}

BOOL HTTPFILT::OnTransactionComplete (HINTERNET hRequest)
{
    LPVOID* lppvContext = GetContextPtr(hRequest);

    if (pfnOnTransactionComplete)
    {
        __try
        {
            (*pfnOnTransactionComplete)
                (lpFilterContext, lppvContext, hRequest, NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT (HTTP, ERROR, ("HttpFilterOnTransactionComplete faulted\n"));
        }
        ENDEXCEPT
    }

    // Destroy any context that was created.
    if (lppvContext)
    {
        CONTEXT_ENTRY* pce =  CONTAINING_RECORD
            (lppvContext, CONTEXT_ENTRY, lpContext);
        RemoveFromSerializedList (&slContexts, &pce->List);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\passport.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "htuu.h"

#include "md5.h"

/*---------------------------------------------------------------------------
PASSPORT_CTX
---------------------------------------------------------------------------*/

PWC *PWC_Create // PWC constructor
(
    LPSTR lpszHost,     // Host Name to place in structure.
    DWORD nPort,        // destination port of proxy or server
    LPSTR lpszUrl,      // URL to template, and place in the structure.
    LPSTR lpszRealm,    // Realm string to add.
    AUTHCTX::SPMData * pSPM
);

VOID PWC_Free(PWC *pwc);

/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::PASSPORT_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, PWC* pPWC)
    : AUTHCTX(pSPM, pPWC)
{
    _fIsProxy = fIsProxy;

    _pRequest = pRequest;
    
    m_hLogon = NULL;

    m_pNewThreadInfo = NULL;
    m_pwszPartnerInfo = NULL;

    m_wRealm[0] = '\0';
    m_pszFromPP = NULL;

    m_hPP = 0;

    m_lpszRetUrl = NULL;
    // m_fAuthDeferred = FALSE;

    //m_fCredsBad = FALSE;
    m_fPreauthFailed = FALSE;

    m_pCredTimestamp = NULL;

    m_fAnonymous = TRUE;

    _pPWC = PWC_Create(NULL, 0, NULL, NULL, NULL);

    m_hBitmap = NULL;
    m_pwszCbText = NULL;
    m_dwCbTextLen = 0;
    m_pwszReqUserName = NULL;
    m_dwReqUserNameLen = 0;

    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->GetServerName(), -1, m_wTarget, MAX_AUTH_TARGET_LEN);
}

BOOL PASSPORT_CTX::Init(void)
{
    m_pNewThreadInfo = ::InternetCreateThreadInfo(FALSE);
    if (m_pNewThreadInfo == NULL)
    {
        return FALSE;
    }

    return TRUE;
}
/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::~PASSPORT_CTX()
{
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    if (m_hLogon)
    {
        ::PP_FreeLogonContext(m_hLogon);
        m_hLogon = NULL;
    }

    if (m_hPP)
    {
        ::PP_FreeContext(m_hPP);
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (m_pNewThreadInfo)
    {
        ::InternetFreeThreadInfo(m_pNewThreadInfo);
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    if (m_pszFromPP)
    {
        delete [] m_pszFromPP;
    }

    if (m_pwszCbText)
        delete[] m_pwszCbText;

    if (m_pwszReqUserName)
        delete[] m_pwszReqUserName;

    PWC_Free(_pPWC);
    _pPWC = NULL;
}

BOOL PASSPORT_CTX::CallbackRegistered(void)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo)
    {
        DWORD_PTR context;

        context = _InternetGetContext(lpThreadInfo);
        if (context == INTERNET_NO_CALLBACK) 
        {
            context = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetContext();
        }

        INTERNET_STATUS_CALLBACK appCallback = 
            ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        if ((appCallback != NULL) && (context != INTERNET_NO_CALLBACK)) 
        {
            return TRUE;
        }
    }

    return FALSE;
}

CHAR g_szPassportDAHost[256];

DWORD PASSPORT_CTX::HandleSuccessfulLogon(
    LPWSTR*  ppwszFromPP,
    PDWORD  pdwFromPP,
    BOOL    fPreAuth
    )
{
    // biaow-todo: I am betting the RU DWORD UrlLength = 1024;
    LPWSTR pwszUrl = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024 * sizeof(WCHAR));
    DWORD dwwUrlLength = 1024;//             won't be too long, but I could be wrong 
    LPSTR pszUrl = (LPSTR) ALLOCATE_FIXED_MEMORY(dwwUrlLength * sizeof(CHAR));
    BOOL fRetrySameUrl;
    DWORD dwRet = ERROR_SUCCESS;

    if (pwszUrl == NULL || pszUrl == NULL)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    *pdwFromPP = 0;

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  NULL, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)
    {
        *ppwszFromPP = new WCHAR[*pdwFromPP];
        if (*ppwszFromPP == NULL)
        {
            dwRet = ERROR_INTERNET_LOGIN_FAILURE;
            goto exit;
        }
    }
    else
    {
        INET_ASSERT(TRUE); // this shouldn't happen
    }
    
    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  *ppwszFromPP, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)
    {
        INET_ASSERT(TRUE); // this shouldn't happen
        dwRet = ERROR_INTERNET_LOGIN_FAILURE;
        goto exit;
    }

    WCHAR wszDAHost[256];
    DWORD dwHostLen = ARRAY_ELEMENTS(wszDAHost);
    if (::PP_GetLogonHost(m_hLogon, wszDAHost, &dwHostLen) == TRUE)
    {
        ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, g_szPassportDAHost, 256, NULL, NULL);
    }

    if (!fRetrySameUrl)
    {
        if (_pRequest->GetMethodType() == HTTP_METHOD_TYPE_GET)
        {
            // DA wanted us to GET to a new Url
            ::WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, pszUrl, 1024, NULL, NULL);
        }
        else
        {
            fRetrySameUrl = TRUE; // *** WinInet supports retry custom verb to same URL only ***
        }
    }
    
    if (fPreAuth)
    {
        if (fRetrySameUrl)
        {
            // Here we are sending and the DA told us to keep Verb & Url,
            // so there is no more needs to be done
            goto exit;
        }
        
        // we are sending. Regardless whether we are asked to handle redirect, we'll need to fake
        // that a 302 just came in. 
        
        // biaow-todo: this is causing problem for QueryHeaders(StatusCode). I don't know why yet...
        /*
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                  "HTTP/1.0 302 Object Moved",
                                  strlen("HTTP/1.0 302 Object Moved")
                                  );
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_LOCATION, 
                                             pszUrl, 
                                             strlen(pszUrl));
        */
        
        if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
        {
            if (!CallbackRegistered())
            {
                _pRequest->SetPPAbort(TRUE);
                dwRet = ERROR_INTERNET_LOGIN_FAILURE;
                goto exit;
            }
        }
        
        ::InternetIndicateStatusString(INTERNET_STATUS_REDIRECT, pszUrl);
    }
    else
    {
        if (!fRetrySameUrl)
        {
            if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
            {
                if (!CallbackRegistered())
                {
                    dwRet = ERROR_INTERNET_LOGIN_FAILURE;
                    goto exit;
                }

                ::InternetIndicateStatusString(INTERNET_STATUS_REDIRECT, pszUrl);
            }
        }
    }
    
    PCSTR lpszRetUrl = NULL;
    
    lpszRetUrl = fRetrySameUrl ? _pRequest->GetURL() : pszUrl;

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    m_lpszRetUrl = new CHAR[strlen(lpszRetUrl) + 1];
    if (m_lpszRetUrl)
    {
        strcpy(m_lpszRetUrl, lpszRetUrl);
    }

exit:
    if (pwszUrl)
    {
        FREE_MEMORY(pwszUrl);
    }
    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }

    return dwRet;
}

DWORD PASSPORT_CTX::SetCreds(BOOL* pfCredSet)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fUseDefaultCreds;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;
    LPSTR  pszPass = NULL;
    
    AuthLock();
    
    if (_pPWC->lpszUser && _pPWC->lpszPass && (pszPass = _pPWC->GetPass()))
    {
        if (_pPWC->lpszUser[0] || (pszPass && pszPass[0])) // either user pass is not blank -> don't use default creds
        {
            fUseDefaultCreds = FALSE;
        }
        else // both user and pass are blank -> use default creds
        {
            fUseDefaultCreds = TRUE;
        }
    }
    else
    {
        fUseDefaultCreds = TRUE;
    }

    if (!fUseDefaultCreds)
    {
        pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pPWC->lpszUser) + 1) * sizeof(WCHAR));
        pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(pszPass) + 1) * sizeof(WCHAR));

        if (pwszUser && pwszPass)
        {
            ::MultiByteToWideChar(CP_ACP, 0, _pPWC->lpszUser, -1, pwszUser, strlen(_pPWC->lpszUser) + 1);
            ::MultiByteToWideChar(CP_ACP, 0, pszPass,         -1, pwszPass, strlen(pszPass) + 1);
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }

        INET_ASSERT(m_pCredTimestamp != NULL);
    }

    AuthUnlock();

    if (dwError == ERROR_SUCCESS)
    {
        *pfCredSet = ::PP_SetCredentials(m_hLogon, m_wRealm, m_wTarget, pwszUser, pwszPass, m_pCredTimestamp);
    }

    if (pwszUser)
        FREE_MEMORY(pwszUser);
    if (pwszPass)
    {
        SecureZeroMemory(pwszPass, wcslen(pwszPass) * sizeof(WCHAR));
        FREE_MEMORY(pwszPass);
    }
    if (pszPass)
    {
        SecureZeroMemory(pszPass, strlen(pszPass));
        FREE_MEMORY(pszPass);
    }
    
    return dwError;
}

DWORD PASSPORT_CTX::ModifyRequestBasedOnRU(void)
{
    DWORD dwError = ERROR_SUCCESS;
    
    INTERNET_SCHEME schemeType;
    INTERNET_SCHEME currentSchemeType;
    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;

    INTERNET_PORT port = 0;
    LPSTR pszHostName;
    DWORD dwHostNameLength = 0;
    LPSTR pszUrlPath;
    DWORD dwUrlPathLength = 0;
    LPSTR extra;
    DWORD extraLength;

    dwError = CrackUrl(m_lpszRetUrl,
             0,
             FALSE, // don't escape URL-path
             &schemeType,
             NULL,  // scheme name, don't care
             NULL,
             &pszHostName,
             &dwHostNameLength,
             &port,
             NULL,  // UserName, don't care
             NULL,  
             NULL,  // Password, don't care
             NULL,
             &pszUrlPath,
             &dwUrlPathLength,
             &extra,
             &extraLength,
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            // newUrlLength -= extraLength;
        } else {
            dwUrlPathLength += extraLength;
        }
    }

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT;
    }

    currentHostPort = _pRequest->GetHostPort();
    currentHostName = _pRequest->GetHostName(&currentHostNameLength);

    if (port != currentHostPort) {
        _pRequest->SetHostPort(port);
    }
    if ((dwHostNameLength != currentHostNameLength)
    || (strnicmp(pszHostName, currentHostName, dwHostNameLength) != 0)) {

        char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
        LPSTR hostValueStr;
        DWORD hostValueSize; 

        CHAR chBkChar = pszHostName[dwHostNameLength]; // save off char

        pszHostName[dwHostNameLength] = '\0';
        _pRequest->SetHostName(pszHostName);

        hostValueSize = dwHostNameLength;
        hostValueStr = pszHostName;            

        if ((port != INTERNET_DEFAULT_HTTP_PORT)
        &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
            if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
            {
                pszHostName[dwHostNameLength] = chBkChar; // put back char
                dwError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            hostValueSize = wsprintf(hostValue, "%s:%d", pszHostName, (port & 0xffff));
            hostValueStr = hostValue;
        }

        pszHostName[dwHostNameLength] = chBkChar; // put back char

        //
        // replace the "Host:" header
        //

        _pRequest->ReplaceRequestHeader(HTTP_QUERY_HOST,
                             hostValueStr,
                             hostValueSize,
                             0, // dwIndex
                             ADD_HEADER
                             );

        //
        // and get the corresponding server info, resolving the name if
        // required
        //

        _pRequest->SetServerInfo(FALSE);

        //
        // Since we are redirecting to a different host, force an update of the origin
        // server.  Otherwise, we will still pick up the proxy info of the first server.
        //
        _pRequest->SetOriginServer(TRUE);
    }

    currentSchemeType = ((INTERNET_FLAG_SECURE & _pRequest->GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    if ( currentSchemeType != schemeType )
    {
        DWORD OpenFlags = _pRequest->GetOpenFlags();

        // Switched From HTTPS to HTTP
        if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

            OpenFlags &= ~(INTERNET_FLAG_SECURE);
        }

        // Switched From HTTP to HTTPS
        else if ( schemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

            OpenFlags |= (INTERNET_FLAG_SECURE);
        }

        _pRequest->SetOpenFlags(OpenFlags);
        _pRequest->SetSchemeType(schemeType);

    }

    _pRequest->SetURL(m_lpszRetUrl);

    if (_pRequest->IsRequestUsingProxy())
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 m_lpszRetUrl,
                                 strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }
    else
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 pszUrlPath, // m_lpszRetUrl,
                                 strlen(pszUrlPath),//strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }

cleanup:

    return dwError;
}

/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pwszFromPP = NULL;
    BOOL bGetCbText;

    // Prefix the header value with the auth type.
    const static BYTE szPassport[] = "Passport1.4 ";
    #define PASSPORT_LEN sizeof(szPassport)-1
    
    if (m_pszFromPP == NULL) 
    {
        if (m_hLogon == NULL)
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto cleanup;
        }

        DWORD dwFromPPLen = 0;
        BOOL fCredSet;
        dwError = SetCreds(&fCredSet);
        if (dwError != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
        m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
        ::InternetSetThreadInfo(m_pNewThreadInfo);

        DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                         FALSE,
                                         0,
                                         NULL,
                                         0);

        ::InternetSetThreadInfo(pCurrentThreadInfo);

        IndicatePrivacyEvents();

        if (dwLogonStatus != PP_LOGON_SUCCESS)
        {
            if (dwLogonStatus == PP_LOGON_REQUIRED)
            {
                m_hBitmap = NULL;

                if (m_pwszReqUserName)
                {
                    delete[] m_pwszReqUserName;
                    m_pwszReqUserName = NULL;
                }
                m_dwReqUserNameLen = 0;

                bGetCbText = (m_pwszCbText == NULL);
                //Get the size of CbText and UserName;
                ::PP_GetChallengeInfo(m_hLogon, 
                    NULL, NULL, NULL, (bGetCbText? &m_dwCbTextLen : NULL), NULL, 0,
                    NULL, &m_dwReqUserNameLen);
                
                if (bGetCbText)
                    m_pwszCbText = new WCHAR[m_dwCbTextLen + 1];

                m_pwszReqUserName = new WCHAR[m_dwReqUserNameLen + 1];

                if ((bGetCbText && !m_pwszCbText) || !m_pwszReqUserName)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }

                ::PP_GetChallengeInfo(m_hLogon, 
                    &m_hBitmap, NULL, (bGetCbText ? m_pwszCbText : NULL), (bGetCbText ? &m_dwCbTextLen : NULL), 
                    m_wRealm, MAX_AUTH_REALM_LEN, m_pwszReqUserName, &m_dwReqUserNameLen);
            }
            else if (dwLogonStatus == PP_LOGON_FAILED)
            {

                m_fPreauthFailed = TRUE;
            }
            
            dwError = ERROR_INTERNET_INTERNAL_ERROR; // need to double check this return error
            // m_fCredsBad = TRUE;
            goto cleanup;
        }

        dwError = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, TRUE);

        if (dwError == ERROR_INTERNET_LOGIN_FAILURE)
        {
            goto cleanup;
        }

        m_pszFromPP = new CHAR [dwFromPPLen];
        if (m_pszFromPP == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
    }

    // check to see if we need to update url

    if (m_lpszRetUrl)
    {
        dwError = ModifyRequestBasedOnRU();

        if (dwError != ERROR_SUCCESS)
        {
            delete [] m_lpszRetUrl;
            m_lpszRetUrl = NULL;
            
            goto cleanup;
        }
        
        delete [] m_lpszRetUrl;
        m_lpszRetUrl = NULL;
    }
    
    // Ticket and profile is already present
    
    // put in the header
    memcpy (pBuf, szPassport, PASSPORT_LEN);
    pBuf += PASSPORT_LEN;
    
    // append the ticket
    strcpy(pBuf, m_pszFromPP);
    *pcbBuf = (DWORD)(PASSPORT_LEN + strlen(m_pszFromPP));

cleanup:
    if (pwszFromPP)
        delete [] pwszFromPP;
    
    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PPEscapeUrl(LPCSTR lpszStringIn,
                 LPSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags);

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwAuthIdx, cbChallenge, dwError;
    LPSTR szChallenge = NULL;

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = NULL;
    LPINTERNET_THREAD_INFO pNewThreadInfo = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get the complete auth header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL, 
        &szChallenge, &cbChallenge, ALLOCATE_BUFFER, dwAuthIdx);

    if (dwError != ERROR_SUCCESS)
    {
        szChallenge = NULL;
        goto exit;
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    {
        LPSTR lpszVerb;
        DWORD dwVerbLength;
        lpszVerb = _pRequest->_RequestHeaders.GetVerb(&dwVerbLength);
        #define MAX_VERB_LENGTH 16
        CHAR szOrgVerb[MAX_VERB_LENGTH] = {0};
        if (dwVerbLength > MAX_VERB_LENGTH - 1)
        {
            goto exit;
        }
        strncpy(szOrgVerb, lpszVerb, dwVerbLength+1);

        // HTTP_METHOD_TYPE tOrgMethod = _pRequest->GetMethodType();
        // PCSTR pszOrgVerb;
        // ::MapHttpMethodType(tOrgMethod, &pszOrgVerb);
        PCSTR pszOrgUrl = _pRequest->GetURL();

        /*
        DWORD dwEscUrlLen = strlen(pszOrgUrl) * 3 + 1;
        DWORD dwEscUrlLenOut;
        PSTR pszEscapedUrl = new CHAR[dwEscUrlLen]; // should be long enough
        if (pszEscapedUrl == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        
        PPEscapeUrl(pszOrgUrl, pszEscapedUrl, &dwEscUrlLenOut, dwEscUrlLen, 0);
        
        EncodeUrlPath(NO_ENCODE_PATH_SEP,
                      SCHEME_HTTP,
                      (PSTR)pszOrgUrl,
                      strlen(pszOrgUrl),
                      pszEscapedUrl, 
                      &dwEscUrlLen);
        */

        const LPWSTR pwszOrgVerbAttr = L",OrgVerb=";
        const LPWSTR pwszOrgUrlAttr =  L",OrgUrl=";

        DWORD dwPartnerInfoLength = cbChallenge 
                                    +::wcslen(pwszOrgVerbAttr)
                                    +::strlen(szOrgVerb)
                                    +::wcslen(pwszOrgUrlAttr)
                                    +::strlen(pszOrgUrl)
                                    + 1; // NULL terminator
        
        DWORD dwSize = 0;
        PWSTR pwszPartnerInfo = NULL;

        m_pwszPartnerInfo = new WCHAR[dwPartnerInfoLength];
        if (m_pwszPartnerInfo == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            // delete [] pszEscapedUrl;
            goto exit;
        }

        pwszPartnerInfo = m_pwszPartnerInfo;

        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szChallenge, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgVerbAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgVerbAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgVerbAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szOrgVerb, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgUrlAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgUrlAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgUrlAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgUrl, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;

        // delete [] pszEscapedUrl;

        dwError = ERROR_SUCCESS;
    }

exit:

    if (szChallenge)
        delete []szChallenge;

    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PASSPORT_CTX::InitLogonContext(void)
{
    PP_CONTEXT hPP = 0; 

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);

    if (!m_hPP)
    {
        hPP = ::PP_InitContext(L"WinInet.Dll", NULL); // the Passport package does not support Async yet, so we'll have to 
        m_hPP = hPP;                                              // create a new Passport Session here.

        PCWSTR pwszRealm = ::wcsstr(m_pwszPartnerInfo, L"srealm");
        if (pwszRealm)
        {
            pwszRealm += ::wcslen(L"srealm");
            if (*pwszRealm == L'=')
            {
                pwszRealm++;
                DWORD i = 0;
                while (*pwszRealm != 0 && *pwszRealm != L',' && i < MAX_AUTH_REALM_LEN-1)
                {
                    m_wRealm[i++] = *pwszRealm++;
                }

                m_wRealm[i] = 0; // null-terminate it
            }
        }

        if (!m_wRealm[0])
        {
            DWORD dwRealmLen = MAX_AUTH_REALM_LEN;
            PP_GetRealm(hPP, m_wRealm, &dwRealmLen);
        }
    }
    
    if (!m_hLogon)
    {
        m_hLogon = ::PP_InitLogonContext(
            hPP,
            m_pwszPartnerInfo,
            (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
            );
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    return (m_hLogon != NULL);
}
/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::PostAuthUser",
        "this=%#x",
        this
        ));

    DWORD dwRet;
    BOOL bGetCbText;

    InitLogonContext();
    
    if (m_fPreauthFailed)
    {
        m_fPreauthFailed = FALSE; // reset the flag

        _pRequest->SetStatusCode(401);

        Transfer401ContentFromPP();
        dwRet = ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;
    
        DEBUG_LEAVE(dwRet);
        return dwRet;
    }

    if (m_hLogon == NULL)
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    /*
    if (_pPWC->lpszUser && _pPWC->lpszPass)
    {
        if (!m_fAuthDeferred)
        {
            dwRet = ERROR_INTERNET_FORCE_RETRY;
            m_fAuthDeferred = TRUE;
        }
        else
        {
            dwRet = ERROR_INTERNET_LOGIN_FAILURE;
        }

        _pRequest->SetStatusCode(401);

        return dwRet;
    }
    */
    
    BOOL fCredSet;
    dwRet = SetCreds(&fCredSet);
    if (dwRet != ERROR_SUCCESS)
    {
        DEBUG_LEAVE(dwRet);
        return dwRet;
    }
    
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                     m_fAnonymous,
                                     0, 
                                     NULL, 
                                     0);

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    IndicatePrivacyEvents();

    if (dwLogonStatus == PP_LOGON_REQUIRED /*|| dwLogonStatus == PP_LOGON_FAILED*/)
    {
        // change from 302 to 401
        _pRequest->ReplaceResponseHeader(HTTP_QUERY_STATUS_CODE,
                                        "401", strlen("401"),
                                        0, HTTP_ADDREQ_FLAG_REPLACE);

        // biaow-todo: 1) nice to replace the status text as well; weird to have "HTTP/1.1 401 object moved"
        // for example 2) remove the Location: header
        _pRequest->SetStatusCode(401);

        BOOL fPrompt;

        m_hBitmap = NULL;

        bGetCbText = (m_pwszCbText == NULL);

        if (m_pwszReqUserName)
        {
            delete[] m_pwszReqUserName;
            m_pwszReqUserName = NULL;
        }
        m_dwReqUserNameLen = 0;

        //Get the size of CbText and UserName;
        ::PP_GetChallengeInfo(m_hLogon, 
            NULL, NULL, NULL, (bGetCbText ? &m_dwCbTextLen : NULL), NULL, 0,
            NULL, &m_dwReqUserNameLen);
        
        if (bGetCbText)
            m_pwszCbText = new WCHAR[m_dwCbTextLen + 1];

        m_pwszReqUserName = new WCHAR[m_dwReqUserNameLen + 1];

        if (!m_pwszCbText || !m_pwszReqUserName)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
            ::PP_GetChallengeInfo(m_hLogon, 
                &m_hBitmap, &fPrompt, (bGetCbText ? m_pwszCbText : NULL), (bGetCbText ? &m_dwCbTextLen : NULL),
                m_wRealm, MAX_AUTH_REALM_LEN, m_pwszReqUserName, &m_dwReqUserNameLen);

        if (/*::PP_SetCredentials(m_hLogon, m_wRealm, m_wTarget, NULL, NULL, NULL) == FALSE ||*/
            fPrompt)
        {
            dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
        }
        else
        {

            if (m_fAnonymous)
            {
                if (fCredSet)
                {
                    dwRet = ERROR_INTERNET_FORCE_RETRY;
                }
                else
                {
                    dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
                }

                m_fAnonymous = FALSE;
            }
            else
            {
                dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
            }
        }
        /*
        else
        {
            // we are not forced to prompt AND we have a cached credentials.

            if (m_fCredsBad)
            {
                dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
            }
            else
            {
                dwRet = ERROR_INTERNET_FORCE_RETRY;
            }
        }
        */

        if (dwRet == ERROR_INTERNET_INCORRECT_PASSWORD)
        {
            Transfer401ContentFromPP();
        }
        // dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
        // Transfer401ContentFromPP();
    }
    else if (dwLogonStatus == PP_LOGON_SUCCESS)
    {
        DWORD dwFromPPLen = 0;
        LPWSTR pwszFromPP = NULL;

        dwRet = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, FALSE);
        if (dwRet != ERROR_INTERNET_LOGIN_FAILURE)
        {
            if (m_pszFromPP)
            {
                delete [] m_pszFromPP;
            }

            m_pszFromPP = new CHAR [dwFromPPLen];
            if (m_pszFromPP)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
            }
        }
        if (pwszFromPP)
        {
            delete [] pwszFromPP;
        }

        m_fAnonymous = FALSE;
    }
    else
    {
        _pRequest->SetStatusCode(401);

        Transfer401ContentFromPP();

        dwRet = ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;
    }

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

BOOL PASSPORT_CTX::Transfer401ContentFromPP(void)
{
    DWORD ContentLength = 0;
    ::PP_GetChallengeContent(m_hLogon, 
                             NULL,
                             &ContentLength);
    if (ContentLength > 0)
    {
        LPBYTE pContent = (LPBYTE)ALLOCATE_FIXED_MEMORY(ContentLength);
        if (pContent == NULL)
        {
            return FALSE;
        }

        if (::PP_GetChallengeContent(m_hLogon, 
                             pContent,
                             &ContentLength) == TRUE)
        {
            BOOL fDrained;
            
            // play with socket mode to force DrainResponse to return synchronously

            ICSocket* pSocket = _pRequest->_Socket;
            if (pSocket)
            {
                BOOL fSocketModeSet = FALSE;
                if (pSocket->IsNonBlocking())
                {
                    pSocket->SetNonBlockingMode(FALSE);
                    fSocketModeSet = TRUE;
                }

                INET_ASSERT(pSocket->IsNonBlocking() == FALSE);

                _pRequest->DrainResponse(&fDrained);

                if (fSocketModeSet)
                {
                    pSocket->SetNonBlockingMode(TRUE);
                }
            }

            _pRequest->_ResponseHeaders.FreeHeaders();
            _pRequest->FreeResponseBuffer();
            _pRequest->ResetResponseVariables();
            _pRequest->_ResponseHeaders.Initialize();

            // _pRequest->_dwCurrentStreamPosition = 0;

            _pRequest->CloneResponseBuffer(pContent, ContentLength);
        }
        FREE_MEMORY(pContent);
    }

    return TRUE;
}

/*---------------------------------------------------------------------------
PASSPORT_CTX::PromptForCreds
---------------------------------------------------------------------------*/
BOOL PASSPORT_CTX::PromptForCreds(HBITMAP* phBitmap, PWSTR pwszCbText, PDWORD pdwTextLen, 
                                  PWSTR pwszReqUserName, PDWORD pdwReqUserNameLen )
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::PromptForCreds",
        "this=%#x",
        this
        ));

    if (phBitmap)
    {
        *phBitmap = m_hBitmap;
        m_hBitmap = NULL;
    }

    if (pdwTextLen)
    {
        if (pwszCbText && *pdwTextLen >= m_dwCbTextLen)
        {
            wcsncpy(pwszCbText, m_pwszCbText, *pdwTextLen);
            delete[] m_pwszCbText;
            m_pwszCbText = NULL;
            m_dwCbTextLen = 0;
        }
        else
            *pdwTextLen = m_dwCbTextLen;
    }

    if (pdwReqUserNameLen)
    {
        if (pwszReqUserName && m_dwReqUserNameLen && *pdwReqUserNameLen >= m_dwReqUserNameLen)
        {
            wcsncpy(pwszReqUserName, m_pwszReqUserName, *pdwReqUserNameLen); 
        }

        *pdwReqUserNameLen = m_dwReqUserNameLen;
    }

    DEBUG_LEAVE((DWORD) TRUE);
    return (DWORD) TRUE;
}


void PASSPORT_CTX::IndicatePrivacyEvents(void)
{
    PLIST_ENTRY pEventList = ::PP_GetPrivacyEvents(m_hLogon);
    INET_ASSERT(pEventList);

    while (!IsListEmpty(pEventList)) 
    {
        PLIST_ENTRY pEntry = RemoveHeadList(pEventList);
        PRIVACY_EVENT* pEvent = (PRIVACY_EVENT*)pEntry;
        
        InternetIndicateStatus(pEvent->dwStatus, pEvent->lpvInfo, pEvent->dwInfoLength);
        
        if (pEvent->dwStatus == INTERNET_STATUS_COOKIE_SENT)
        {
            delete [] ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }
        else
        {
            delete [] ((IncomingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }

        delete [] pEvent->lpvInfo;

        delete pEvent;
    }
}

//Determine if the character is unsafe under the URI RFC document
inline BOOL PPIsUnsafeUrlChar(TCHAR chIn) throw()
{
        unsigned char ch = (unsigned char)chIn;
        switch(ch)
        {
                case ';': case '\\': case '?': case '@': case '&':
                case '=': case '+': case '$': case ',': case ' ':
                case '<': case '>': case '#': case '%': case '\"':
                case '{': case '}': case '|':
                case '^': case '[': case ']': case '`':
                        return TRUE;
                default:
                {
                        if (ch < 32 || ch > 126)
                                return TRUE;
                        return FALSE;
                }
        }
}

BOOL PPEscapeUrl(LPCSTR lpszStringIn,
                 LPSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags)
{
    TCHAR ch;
    DWORD dwLen = 0;
    BOOL bRet = TRUE;
    BOOL bSchemeFile = FALSE;
    DWORD dwColonPos = 0;
    DWORD dwFlagsInternal = dwFlags;
    while((ch = *lpszStringIn++) != '\0')
    {
        //if we are at the maximum length, set bRet to FALSE
        //this ensures no more data is written to lpszStringOut, but
        //the length of the string is still updated, so the user
        //knows how much space to allocate
        if (dwLen == dwMaxLength)
        {
            bRet = FALSE;
        }

        //if we are encoding and it is an unsafe character
        if (PPIsUnsafeUrlChar(ch))
        {
            {
                //if there is not enough space for the escape sequence
                if (dwLen >= (dwMaxLength-3))
                {
                        bRet = FALSE;
                }
                if (bRet)
                {
                        //output the percent, followed by the hex value of the character
                        *lpszStringOut++ = '%';
                        sprintf(lpszStringOut, "%.2X", (unsigned char)(ch));
                        lpszStringOut+= 2;
                }
                dwLen += 2;
            }
        }
        else //safe character
        {
            if (bRet)
                *lpszStringOut++ = ch;
        }
        dwLen++;
    }

    if (bRet)
        *lpszStringOut = '\0';
    *pdwStrLen = dwLen;
    return  bRet;
}

/////////////////
// MD5 Hash code

const CHAR g_rgchHexNumMap[] =
{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};


PSTR 
GetMD5Key(PSTR pszChallengeInfo, PSTR pszPassword)
{
	int cbChallengeInfo = lstrlenA(pszChallengeInfo);
	int cbPassword = lstrlenA(pszPassword);

	PBYTE pbData = new BYTE[cbChallengeInfo + cbPassword + 1];
	
	if (!pbData)
	{
		return NULL;
	}

	PBYTE pCurrent = pbData;

	::CopyMemory(pCurrent, pszChallengeInfo, cbChallengeInfo);
	pCurrent += cbChallengeInfo;
	::CopyMemory(pCurrent, pszPassword, cbPassword);
	pCurrent += cbPassword;
	*pCurrent = '\0';

	return (PSTR)pbData;
}


//------------------------------------------------------------------------------------
//
//	Method: 	CAuthentication::GetMD5Result()
//
//	Synopsis:	Compute the MD5 hash result based on the ChallengeInfo and password.
//
//  pbHexHash must be at least MD5DIGESTLEN * 2 + 1 in size
//
//------------------------------------------------------------------------------------
BOOL 
GetMD5Result(PSTR pszChallengeInfo, PSTR pszPassword, PBYTE pbHexHash)
{

	BOOL bRetVal = FALSE;
	PSTR pMD5Key = GetMD5Key(pszChallengeInfo, pszPassword);

	if (pMD5Key)
	{
		MD5_CTX MD5Buffer;
		MD5Init(&MD5Buffer);
		MD5Update(&MD5Buffer, (const unsigned char*)pMD5Key, lstrlenA(pMD5Key));
		MD5Final(&MD5Buffer);

		PBYTE pbHash = MD5Buffer.digest;

//		pbHexHash = new BYTE[MD5DIGESTLEN * 2 + 1];
//		pbHexHash = (BYTE*)HeapAlloc (  GetProcessHeap(), HEAP_ZERO_MEMORY, MD5DIGESTLEN * 2 + 1);
		if (pbHexHash)
		{
			bRetVal = TRUE;
			PBYTE pCurrent = pbHexHash;

			// Convert the hash data to hex string.
			for (int i = 0; i < MD5DIGESTLEN; i++)
			{
				*pCurrent++ = g_rgchHexNumMap[pbHash[i]/16];
				*pCurrent++ = g_rgchHexNumMap[pbHash[i]%16];
			}

			*pCurrent = '\0';
		}

		delete pMD5Key;
	}

	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\uudec.c ===
#include <stdio.h>
#include "htuu.h"

int main (int argc, char **argv)
{
    char outbuf[500];
    char *pOut = outbuf;
    int cbOut = (strlen(argv[1]) * 3) / 4;

    if (argc != 2)
    {
        fprintf (stderr, "usage: uudec <base64-string>\n");
        exit (1);
    }
    
    HTUU_decode (argv[1], pOut, sizeof(outbuf));

    while (cbOut--)
    {
        printf ("%02x %c\n", (unsigned char) *pOut, *pOut);
        pOut++;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\sspi.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sspi.c

Abstract:

    This file contains the implementation for SSPI Authentication 

    The following functions are exported by this module:

    UnloadAuthenticateUser
	AuthenticateUser
	PreAuthenticateUser
    AuthenticateUserUI

Author:

    Sudheer Koneru	(SudK)	Created	2/17/96

Revision History:


--*/

#include "msnspmh.h"
#ifdef DEBUG_WINSSPI
#include <stdio.h>
#endif

#include "auth.h"


LPSTR StrChrA(LPCSTR lpStart, WORD wMatch); // from shlwapi.h

DWORD g_cSspiContexts;
#ifdef UNIX_SHMEM_CREDS
/* On Unix: once a user puts in his credentials, we want to save
 * it in Shared memory so that other processes can use this data.
 * The login/password/domain are saved encrypted and you need the
 * routines in libntlmssp.so to unencrypt them.
 * When the process exits, the shared memory is cleaned up. If the
 * credentials are outdated during a session, we ask the user for
 * new credentials and try again.
 */
static BOOL g_fNeedNewCreds = FALSE;
static FARPROC g_UXPCEFn = NULL;
#endif

#define NAME_SEPERATOR  0x5c    // this is a backslash character which 
                                // seperates the domain name from user name

VOID
WINAPI
UnloadAuthenticateUser(LPVOID *lppvContext,
					   LPSTR lpszScheme,
					   LPSTR lpszHost)
{

	PWINCONTEXT		pWinContext = (PWINCONTEXT) (*lppvContext);

    if (!SSPI_InitGlobals())
        return;

	if (*lppvContext == NULL)	{
		return;
	}

    if (pWinContext->pInBuffer != NULL && 
        pWinContext->pInBuffer != pWinContext->szInBuffer)
    {
        LocalFree (pWinContext->pInBuffer);
    }
    pWinContext->pInBuffer = NULL;
    pWinContext->dwInBufferLength = 0;

    // Free SSPI security context
    //
	if (pWinContext->pSspContextHandle != NULL)
		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);

    //  Free SSPI credential handle
    //
    if (pWinContext->pCredential)
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);

    pWinContext->pCredential = NULL;
    pWinContext->pSspContextHandle = NULL;

 
	if ( (pWinContext->lpszServerName != NULL) &&
		 (pWinContext->lpszServerName != pWinContext->szServerName) )
	{
		LocalFree(pWinContext->lpszServerName);
	}


	LocalFree(pWinContext);

	*lppvContext = NULL;

	g_cSspiContexts--;

	return;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveServerName
//
//  Synopsis:   This function saves the destination server name in this
//              connection context for AuthenticateUserUI
//
//  Arguments:  [lpszServerName] - points to the target server name
//              [pWinContext] - points to the connection context
//
//  Returns:    TRUE if server name is successfully saved in connection context.
//              Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
SaveServerName (
	LPSTR 			lpszServerName,
	PWINCONTEXT		pWinContext
    )
{
	DWORD dwLen = lstrlen(lpszServerName);

	if (dwLen < DEFAULT_SERVER_NAME_LEN)
	{
		lstrcpy(pWinContext->szServerName, lpszServerName);
		pWinContext->lpszServerName = pWinContext->szServerName;
	}
	else
	{   //
        //  Server name is longer, need to allocate memory for the name
        //

        //  Free already allocated memory if any
		if (pWinContext->lpszServerName && 
			pWinContext->lpszServerName != pWinContext->szServerName)
		{
			LocalFree (pWinContext->lpszServerName);
		}

		pWinContext->lpszServerName = (char *) LocalAlloc(0, dwLen+1);

		if (pWinContext->lpszServerName == NULL)
			return FALSE;

		lstrcpy(pWinContext->lpszServerName, lpszServerName);
	}

    return TRUE;
}

//  Function bHasExtendedChars
//  Check if an ANSI string contains extended characters
BOOL bHasExtendedChars(char const *str)
{
    signed char const *p;

    for (p = (signed char const *)str; *p; p++)
        if ( *p < 0)
            return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildNTLMauthData
//
//  Synopsis:   This function builds SEC_WINNT_AUTH_IDENTITY structure 
//              from the user name and password specified.  If domain name 
//              is not specified in the user name, the Domain field in 
//              the structure is set to NULL.  NOTE: This structure is 
//              specific to the NTLM SSPI package.
//              This function allocates a chunck of memory big enough for 
//              storing user name, domain, and password. Then setup 
//              pointers in pAuthData to use sections of this memory.
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//              [lpszUserName] - points to the user name, which may also 
//                               include user's domain name.
//              [lpszPassword] - points to user's password
//
//  Returns:    TRUE if SEC_WINNT_AUTH_IDENTITY structure is successfully 
//              initialized and built.  Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
BuildNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData, 
	LPTSTR       lpszUserName,
	LPTSTR       lpszPassword
    )
{
    DWORD  dwUserLen, dwDomainLen, dwPwdLen;
    LPTSTR pName;
    LPTSTR pDomain = NULL;
    BOOL bUnicodeAuth = FALSE;

    // SEC_WINNT_AUTH_IDENTITY_UNICODE is supported on Windows NT/2000
    if ( GetVersion() < 0x80000000 && (bHasExtendedChars(lpszUserName) || bHasExtendedChars(lpszPassword)))
        bUnicodeAuth = TRUE;

    pAuthData->Flags = bUnicodeAuth ? SEC_WINNT_AUTH_IDENTITY_UNICODE : SEC_WINNT_AUTH_IDENTITY_ANSI;

    //
    //  Check to see if domain name is specified in lpszUserName
    //
    pName = StrChrA (lpszUserName, NAME_SEPERATOR);

    if (pName)  // Domain name specified
    {
        // Make sure that we don't change the original string in lpszUserName 
        // because that it would be reused for other connections

        // Calculate no. of bytes in domain name
        dwDomainLen = (int)(pName - lpszUserName);

        // Convert to no. of characters
        pAuthData->DomainLength = dwDomainLen / sizeof(TCHAR);

        pDomain = lpszUserName;
        pName++;
    }
    else        // No domain specified
    {
        pName = lpszUserName;
        pAuthData->Domain = NULL;
        pDomain = NULL;
        dwDomainLen = pAuthData->DomainLength = 0;
    }

    dwUserLen = pAuthData->UserLength = lstrlen (pName);
    dwPwdLen = pAuthData->PasswordLength = lstrlen (lpszPassword);

    //
    //  Allocate memory for all: name, domain, and password
    //  The memory block is big enough for Unicode. Some bytes will be wasted in the ANSI case
    //
    pAuthData->User = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, (dwUserLen + dwDomainLen + dwPwdLen + 3)*sizeof(wchar_t));
	
    if (pAuthData->User == NULL)
        return (FALSE);

    if (bUnicodeAuth)
    {
        // Convert the user name into Unicode and store in pAuthData->User
        if (0 == MultiByteToWideChar(CP_ACP, 0, pName, -1, (LPWSTR)(pAuthData->User), dwUserLen+1))
            return FALSE;
    }
    else
        CopyMemory (pAuthData->User, pName, dwUserLen);

    //  Setup memory pointer for password
    //
    pAuthData->Password = pAuthData->User + (dwUserLen + 1) * sizeof(wchar_t);

    if (bUnicodeAuth)
    {
        if (0 == MultiByteToWideChar(CP_ACP, 0, lpszPassword, -1, (LPWSTR)(pAuthData->Password), dwPwdLen+1))
            return FALSE;
    }
    else
        CopyMemory (pAuthData->Password, lpszPassword, dwPwdLen);

    if (pAuthData->DomainLength > 0)
    {
        //  Setup memory pointer for domain
        //
        pAuthData->Domain = pAuthData->Password + (dwPwdLen + 1) * sizeof(wchar_t);
        if (bUnicodeAuth)
        {
            // pDomain is not null terminated, so provide the length
            if (0 == MultiByteToWideChar(CP_ACP, 0, pDomain, dwDomainLen, (LPWSTR)(pAuthData->Domain), dwDomainLen))
                return FALSE;
        }
        else
            CopyMemory (pAuthData->Domain, pDomain, dwDomainLen);

        // Need not to zero terminate pAuthData->Domain, since the memory contents were initialized to zero.
    }
    else
    {
       pAuthData->Domain = NULL;
    }

    return (TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeNTLMauthData
//
//  Synopsis:   This function frees memory allocated for the 
//              SEC_WINNT_AUTH_IDENTITY structure
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//
//  Returns:    void.
//
//----------------------------------------------------------------------------
VOID
FreeNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData
    )
{
    //
    //  Free User which points to memory for all domain, name, and password
    //
    if (pAuthData->User)
        LocalFree (pAuthData->User);
}

//+---------------------------------------------------------------------------
//
//  Function:   NewWinContext
//
//  Synopsis:   This function creates a new context and a new credential 
//              handle for this connection.  If a user name/password is 
//              specified, the credential handle is created for the 
//              specified user.  Otherwise, the credential handle is created 
//              for the local logon user.
//
//  Arguments:  [pkgId] - the package ID (index into SSPI package list)
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [ppCtxt] - this returns the pointer of the created context 
//                         to the caller.
//              [lpszUserName] - the name of a specific user to be used 
//                               for authentication. If this is NULL, the 
//                               credential of the currently logon user is 
//                               used for authentication.
//              [lpszPassword] - the password of the specified user, if any.
//
//  Returns:    ERROR_SUCCESS - if the new context is created successfully
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_PARAMETER - the SSPI call for creating the 
//                              security credential handle failed
//
//----------------------------------------------------------------------------
DWORD
NewWinContext (
    INT         pkgId, 
	LPSTR       lpszScheme,
    PWINCONTEXT *ppCtxt,
    BOOL        fCanUseLogon,
	LPSTR       lpszUserName,
	LPSTR       lpszPassword
    )
{
    SECURITY_STATUS ss;
    TimeStamp   Lifetime;
    PWINCONTEXT pWinContext;
    SEC_WINNT_AUTH_IDENTITY  AuthData;
    PSEC_WINNT_AUTH_IDENTITY pAuthData;
    DWORD Capabilities ;

    DWORD SecurityBlobSize;


    //
    // need space for maxtoken size for in+out, + base64 encoding overhead for each.
    // really 1.34 overhead, but just round up to 1.5
    //
    SecurityBlobSize = GetPkgMaxToken(pkgId);
    SecurityBlobSize += (SecurityBlobSize/2);

    //
    // note: for compatibility sake, make the buffer size the MAX_BLOB_SIZE at the minimum
    // consider removing this once we're convinced all packages return good cbMaxToken values.
    //

    if( SecurityBlobSize < MAX_BLOB_SIZE )
    {
        SecurityBlobSize = MAX_BLOB_SIZE;
    }


    pWinContext = (PWINCONTEXT) LocalAlloc(
                        0,
                        sizeof(WINCONTEXT) +
                        (SecurityBlobSize*2)
                        );
	if (pWinContext == NULL)
		return (ERROR_NOT_ENOUGH_MEMORY);
		
    //  Initialize context
    //

    ZeroMemory( pWinContext, sizeof(WINCONTEXT) );
    pWinContext->pkgId = (DWORD)pkgId;


    pWinContext->szOutBuffer = (char*)(pWinContext+1);
    pWinContext->cbOutBuffer = SecurityBlobSize;

    pWinContext->szInBuffer = pWinContext->szOutBuffer + pWinContext->cbOutBuffer;
    pWinContext->cbInBuffer = SecurityBlobSize;



    //
    // Get bitmask representing the package capabilities
    //

    Capabilities = GetPkgCapabilities( pkgId );

    if ( ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        // Always used cached credential for msn, dpa, etc.
        pAuthData = NULL;
    }
    else if (lpszUserName && lpszPassword)
    {
        // App Compat fix -- always use the app specified creds when available

        if ((lpszUserName[0] == '\0') && (lpszPassword[0] == '\0'))
        {
            if(fCanUseLogon)
            {
                pAuthData = NULL;
            }
            else
            {
                return ERROR_INTERNET_INCORRECT_PASSWORD;
            }
        }
        else
        {
            //  Build AuthData from the specified user name/password
            if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
                return (ERROR_NOT_ENOUGH_MEMORY);

            pAuthData = &AuthData;
        }
    }
#ifdef UNIX_SHMEM_CREDS
    else if (fCanUseLogon && UnixCachedCredentialExists())
    {
        pAuthData = NULL;
    }
#else
    else if (fCanUseLogon)
    {
        // The zone policy allows silent use of the logon credential.
        pAuthData = NULL;
    }
#endif /* UNIX_SHMEM_CREDS */
    else
    {
        // We must prompt the user for credentials.
        return ERROR_INTERNET_INCORRECT_PASSWORD;
    }

    //
    //  Call SSPI function acquire security credential for this package
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       pAuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    if (pAuthData)
        FreeNTLMauthData (pAuthData);

    if (ss != STATUS_SUCCESS)
    {
        LocalFree (pWinContext);
#ifdef UNIX_SHMEM_CREDS //If NTLM failed due to bad shared mem creds, prompt the user again...
        if (lstrcmpi(lpszScheme, "NTLM") == 0)
        {
            g_fNeedNewCreds = TRUE;
            return ERROR_INTERNET_INCORRECT_PASSWORD;
        }
        else
#endif
		return (ERROR_INVALID_PARAMETER);
    }

#ifdef UNIX_SHMEM_CREDS // if NTLM, the credentials were valid...
    if (lstrcmpi(lpszScheme, "NTLM") == 0)
        g_fNeedNewCreds = FALSE;
#endif

    pWinContext->pCredential = &pWinContext->Credential;

    *ppCtxt = pWinContext;

    g_cSspiContexts++;

    return (ERROR_SUCCESS);
}

#ifdef UNIX_SHMEM_CREDS
BOOL
UnixCachedCredentialExists(
    )
{
    BOOL fCached;
    
    if (g_fNeedNewCreds)
        return FALSE;

    if (!g_UXPCEFn)
        g_UXPCEFn = GetProcAddress(GetModuleHandle("ntlmssp"), "UnixXProcCredExists");
    
    fCached = g_UXPCEFn();

    return fCached;
}
#endif /* UNIX_SHMEM_CREDS */

//+---------------------------------------------------------------------------
//
//  Function:   RedoNTLMAuth4User
//
//  Synopsis:   This function recreates a NTLM credential handle for the 
//              specified user and generate a NEGOTIATE message in 
//              the provided buffer with the new credential handle.
//
//  Arguments:  [pWinContext] - points to the connection context
//              [pkgId] - specifies the SSPI pkg to be used for authentication
//              [lpszUserName] - the name of the specific user to be used 
//                               for authentication. 
//              [lpszPassword] - the password of the specified user,
//              [lpszServerName] - the target server name
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [lpOutBuffer] - points to the buffer for the new authorization 
//                              header including the UUENCODED NEGOTIATE msg
//              [lpdwOutBufferLength] - returns the length of the generated 
//                                      authorization header.
//
//  Returns:    ERROR_SUCCESS - if the new authorization header is successfully 
//                              created for the new user name/password
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_HANDLE - the SSPI call for generating the 
//                              new NEGOTIATE msg failed
//
//----------------------------------------------------------------------------
DWORD
RedoNTLMAuth4User (
	PWINCONTEXT	pWinContext, 
    INT         pkgId, 
	LPSTR       lpszUserName,
	LPSTR       lpszPassword, 
	LPSTR       lpszServerName,
	LPSTR       lpszScheme,
	LPSTR       lpOutBuffer,
	LPDWORD     lpdwOutBufferLength,
    PCSTR       lpszUrl,
	SECURITY_STATUS *pssResult
    )
{
    SECURITY_STATUS             ss;
    DWORD                       dwStatus;
    TimeStamp                   Lifetime;
    SEC_WINNT_AUTH_IDENTITY     AuthData;
    PSEC_WINNT_AUTH_IDENTITY    pAuthData = NULL;
    ULONG                       fContextReq = ISC_REQ_DELEGATE;
    DWORD                       dwMaxLen;
    //BOOL                        fCanUseCredMgr = FALSE;

   	if (pWinContext->pSspContextHandle)
   	{
		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
   	    pWinContext->pSspContextHandle = NULL;
	}

    //  Free existing credential handle
    //
    if (pWinContext->pCredential)
    {
    	(*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
        pWinContext->pCredential = NULL;
    }

    // App Compat fix -- always use the app specified creds when available
    

    if ((lpszUserName[0] == '\0') && (lpszPassword[0] == '\0'))
    {
        pAuthData = NULL;
    }
    else
    {
        //
        //  Build the NTLM SSPI AuthData from the specified user name/password
        //
        if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
            return (ERROR_NOT_ENOUGH_MEMORY);

        pAuthData = &AuthData;
    }

    //
    //  Call SSPI function acquire security credential for this user
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       pAuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    // if (!fCanUseCredMgr)
    if (pAuthData)
    {
        FreeNTLMauthData (&AuthData);   // don't need it any more
    }

    if (ss != STATUS_SUCCESS)
    {
		return (ERROR_INVALID_HANDLE);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    dwMaxLen = *lpdwOutBufferLength;

    //
    //  Generate NEGOTIATE message in the provided buffer for this user 
    //
    dwStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                NULL, 
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                NULL,
                                0,
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                lpszServerName,
                                TRUE,
                                lpszScheme,
                                lpszUrl,
                                pssResult);
    
    if (dwStatus != SPM_STATUS_OK)
    {
        *lpdwOutBufferLength = 0; // no exchange blob generated
        return(ERROR_INVALID_HANDLE);
    }

    pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);

    //
    //  If we are not in the initial state, continue to a RESPONSE message
    //
    if (pWinContext->pInBuffer != NULL && pWinContext->dwInBufferLength > 0)
    {
        *lpdwOutBufferLength = dwMaxLen;
        ZeroMemory( lpOutBuffer, dwMaxLen );

        dwStatus = GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pWinContext->pkgId,
                                pWinContext->pSspContextHandle,
                                (PCtxtHandle) &(pWinContext->SspContextHandle),
                                fContextReq,
                                pWinContext->pInBuffer, 
                                pWinContext->dwInBufferLength, 
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                pWinContext->lpszServerName,
                                TRUE,
                                lpszScheme,
                                lpszUrl,
                                pssResult);

        //  Clear out the input exchange blob
        //
        if (pWinContext->pInBuffer != NULL)
        {
            if (pWinContext->pInBuffer != pWinContext->szInBuffer)
                LocalFree (pWinContext->pInBuffer);
            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;
        }

        if (dwStatus != SPM_STATUS_OK)
        {
            *lpdwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }
    }

    return (ERROR_SUCCESS);
}

//
// functions
//

/*++

Routine Description:

    Generates a Basic User Authentication string for WinINet or 
	other callers can use

Arguments:

	lpContext               - if the package accepts the request & authentication
					requires multiple transactions, the package will supply
					a context value which will be used in subsequent calls,
					Currently this contains a pointer to a pointer of a 
					User defined Void Pointer.  Can be Assume to be NULL
					if this is the first instance of a Realm - Host Combo

	lpszServerName  - the name of the server we are performing 
					authentication for. We may want to supply the full URL
					
	lpszScheme              - the name of the authentication scheme we are seeking, e.g. "MSN", in case the package supports multiple schemes

	dwFlags                 - on input, flags modifying how the package should behave,
					e.g. "only authenticate if you don't have to get user 
					information"  On output contains flags relevant to
					future HTTP requests, e.g. "don't cache any data from 
					this connection". Note, this information should not be 
					specific to HTTP - we may want to use the same flags 
					for FTP, etc.
	
	lpszInBuffer              - pointer to the string containing the response from
					the server (if any)

	dwInBufferLength - number of bytes in lpszInBuffer. No CR-LF sequence, no terminating NUL

	lpOutBuffer -   pointer to a buffer where the challenge response will be written by the 
					package if it can handle the request

	lpdwOutBufferLength - on input, contains the size of lpOutBuffer. On output, contains the
						  number of bytes to return to the server in the next GET request 
						  (or whatever). If lpOutBuffer is too small, the package should 
						  return ERROR_INSUFFICIENT_BUFFER and set *lpdwOutBufferLength to be
						  the required length

	We will keep a list of the authentication packages and the schemes they support, 
	along with the entry point name (should be the same for all packages) in the registry. 

	Wininet should keep enough information such that it can make a reasonable guess as to
	whether we need to authenticate a connection attempt, or whether we can use previously 
	authenticated information


Return Value:

    DWORD
	Success - non-zero 
	Failure - 0. Error status is available by calling GetLastError()

--*/
DWORD
WINAPI
AuthenticateUser(
	IN OUT LPVOID *lppvContext,
	IN LPSTR lpszServerName,
	IN LPSTR lpszScheme,
	IN BOOL  fCanUseLogon,
	IN LPSTR lpszInBuffer,
	IN DWORD dwInBufferLength,
	IN LPSTR lpszUserName,
	IN LPSTR lpszPassword,
    IN PCSTR lpszUrl,
	OUT SECURITY_STATUS *pssResult
	)
{
	PWINCONTEXT		pWinContext;
    LPSTR           pServerBlob = NULL;
	int		        pkgId;
    DWORD           SPMStatus;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    BOOL            bNonBlock = TRUE;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	
    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1) 
        return (ERROR_INVALID_PARAMETER);

	if (*lppvContext == NULL)   // a new connection
    {
        char msg[1024];
        DWORD dwStatus;

		//
		// First time we are getting called here, there should be no input blob
		//
        if (dwInBufferLength != 0)
			return (ERROR_INVALID_PARAMETER);

        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext,
            fCanUseLogon, lpszUserName, lpszPassword);
		if (dwStatus != ERROR_SUCCESS)
			return (dwStatus);

		(*lppvContext) = (LPVOID) pWinContext;
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, "AuthenticateUser> Scheme= %s  Server= '%s'\n", 
                       lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
	}
	else
	{
		pWinContext = (PWINCONTEXT) (*lppvContext);

		//
		// The package Id better be the same. Cant just switch packageId 
		// arbitrarily
		//
		if (pWinContext->pkgId != (DWORD)pkgId)
			return (ERROR_INVALID_PARAMETER);
		
		pServerBlob = lpszInBuffer;

		//++(pWinContext->dwCallId);		// Increment Call Id

		//
		// BUGBUG: Hack for now to know when auth failed
		// The only time we get lpszInBuffer to be empty is when 
		// Web server failed the authentication request
		//
        if (dwInBufferLength == 0)
        {
			//
			// This means auth has failed as far as NTLM/MSN are concerned.
			// Will result in UI being done again for new passwd
			//

			// Make sure we should have the same server name as before
			//
			if ( pWinContext->lpszServerName != NULL &&  
				 lstrcmp (pWinContext->lpszServerName, lpszServerName) != 0 )
			{
				return(ERROR_INVALID_PARAMETER);
			}

            if (!SaveServerName (lpszServerName, pWinContext))
			    return (ERROR_NOT_ENOUGH_MEMORY);

			//
			//	Delete the original SSPI context handle and 
			//	let UI recreate one.
			//
			if (pWinContext->pSspContextHandle)
			{
				(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
        		pWinContext->pSspContextHandle = NULL;
			}

            if (pWinContext->pInBuffer != NULL && 
                pWinContext->pInBuffer != pWinContext->szInBuffer)
            {
                LocalFree (pWinContext->pInBuffer);
            }

            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;

            //
            //  clear buffer length for the exchange blob
            //
		    pWinContext->dwOutBufferLength = 0;

            //
            //  The following is a temporary workaround for bugs in IE3
            //  Should remove this special case for DPA package once IE3 
            //  bug is fixed (or once we move to new Wininet interface.
            //
            //***** BUGBUG *** Begin Special Case for DPA
            if (lstrcmpi (lpszScheme, "DPA") == 0)
            {
                fContextReq |= ISC_REQ_PROMPT_FOR_CREDS;
            }
            //***** BUGBUG *** End Special Case for DPA
            else
                return (ERROR_INTERNET_INCORRECT_PASSWORD);
		}
	}

    //
    //  Setup dwOutBufferLength to represent max. memory in szOutBuffer
    //
    pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
    ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);

    //
    // This will generate an authorization header with UUEncoded blob from SSPI.
    // BUGBUG: Better make sure outbuf buffer is big enough for this.
    //
    SPMStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                pWinContext->pSspContextHandle,
                                &(pWinContext->SspContextHandle),
                                fContextReq,
								pServerBlob, 
                       			dwInBufferLength,
                                pWinContext->szOutBuffer,
                                &pWinContext->dwOutBufferLength,
                                lpszServerName,
                                bNonBlock,
                                lpszScheme,
                                lpszUrl,
                                pssResult);

    if (SPMStatus != SPM_STATUS_OK)             // Fail to generate blob
    {
        pWinContext->dwOutBufferLength = 0;     // no exchange blob generated

        //
        //  if SSPI is requesting an opportunity to prompt for user credential
        //
		if (SPMStatus == SPM_STATUS_WOULD_BLOCK)
		{
			if (!SaveServerName (lpszServerName, pWinContext))
				return (ERROR_NOT_ENOUGH_MEMORY);

            //  If there is a exchange blob, this is not the first call
            //
            if (pServerBlob && dwInBufferLength > 0)
            {
                //  Save the exchange blob in the connection context
                //  so we can call SSPI again with the exchange blob
                if (dwInBufferLength > MAX_BLOB_SIZE)
                {
                	pWinContext->pInBuffer = (PCHAR) LocalAlloc(0, 
                                                    dwInBufferLength);
                    if (pWinContext->pInBuffer == NULL)
	        			return (ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                    pWinContext->pInBuffer = pWinContext->szInBuffer;

                CopyMemory( pWinContext->szInBuffer, pServerBlob, 
                            dwInBufferLength );
                pWinContext->dwInBufferLength = dwInBufferLength;
            }
            else
            {
    			//
	    		//	Delete the original SSPI context handle and 
		    	//	let UI recreate one.
			    //
    			if (pWinContext->pSspContextHandle)
	    		{
		    		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
        	    	pWinContext->pSspContextHandle = NULL;
			    }

                //
                //  clear buffer length for the exchange blob
                //
                if (pWinContext->pInBuffer != NULL && 
                    pWinContext->pInBuffer != pWinContext->szInBuffer)
                {
                    LocalFree (pWinContext->pInBuffer);
                }

                pWinContext->pInBuffer = NULL;
                pWinContext->dwInBufferLength = 0;
            }
            pWinContext->dwOutBufferLength = 0;

			return(ERROR_INTERNET_INCORRECT_PASSWORD);
		}

        return (ERROR_INTERNET_LOGIN_FAILURE);
    }
    else if (pWinContext->pSspContextHandle == NULL)
    {   
        //  This means that we've just created a security context
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

	return (ERROR_INTERNET_FORCE_RETRY);
}


DWORD
WINAPI
PreAuthenticateUser(
	IN OUT LPVOID *lppvContext,
	IN LPSTR lpszServerName,
	IN LPSTR lpszScheme,
	IN DWORD dwFlags,
	OUT LPSTR lpOutBuffer,
	IN OUT LPDWORD lpdwOutBufferLength,
	IN LPSTR lpszUserName,
	IN LPSTR lpszPassword,
    IN PCSTR lpszUrl,
    SECURITY_STATUS *pssResult
	)
{
    INT             pkgId;
    DWORD           dwStatus;
    PWINCONTEXT		pWinContext;
	BOOL			bNonBlock = TRUE;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    DWORD Capabilities ;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	if (lpszServerName == NULL || *lpszServerName == '\0')
        return(ERROR_INVALID_PARAMETER);

    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1)    {
        return(ERROR_INVALID_PARAMETER);
    }

    Capabilities = GetPkgCapabilities( pkgId );

    //
    //  If this is for an existing connection
    //
	if (*lppvContext != NULL)
    {
    	pWinContext = (PWINCONTEXT) (*lppvContext);

    	if ((DWORD)pkgId != pWinContext->pkgId)
	    	return(ERROR_INVALID_PARAMETER);

        //
        //  For package that does not handle its own UI, if there is no 
        //  generated blob, it means that we have just collected 
        //  user name/password.
        //
        if ( ( pWinContext->dwOutBufferLength == 0 ) &&
                ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) )
        {
            if (lpszUserName == NULL || lpszPassword == NULL)
            {
    	    	return(ERROR_INVALID_PARAMETER);
            }

            //
            // Need to recreate a credential handle and 
            // generate a new NEGOTIATE message in lpOutBuffer
            //
            dwStatus = RedoNTLMAuth4User (pWinContext, 
                                         pkgId,
                                         lpszUserName,
                                         lpszPassword, 
                                         lpszServerName ,
                                         lpszScheme,
                                         lpOutBuffer,
                                         lpdwOutBufferLength,
                                         lpszUrl,
                                         pssResult);

            if (dwStatus != ERROR_SUCCESS)
                return (dwStatus);

        	return(ERROR_SUCCESS);
        }
	    else if (pWinContext->dwOutBufferLength == 0)
        //
        //  For other packages, If there is no generated blob, 
        //  something is wrong 
        //
	    	return(ERROR_INVALID_PARAMETER);

    }
    // If not NTLM, don't pre-auth.
    else if ( (Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        return (ERROR_INVALID_HANDLE);
    }
    else
    {
        // probably sending 1st request on a new connection for the same URL
        //  Create a new context and SSPI credential handle for this connection
        //
        // Set fCanUseLogon to TRUE : we would not be pre-authing
        // unless we have a valid pwc which means we already checked
        // zone policy for silent logon.
        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext, 
                                  TRUE, lpszUserName, lpszPassword);
		if (dwStatus != ERROR_SUCCESS)
			return (dwStatus);
		
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, 
            "PreAuthenticateUser> New Context for Scheme= %s  Server= '%s'\n", 
            lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
        pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
        ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);
		
        //
        // This will generate an authorization header with the 
        // UUEncoded blob from SSPI. 
        // BUGBUG: Better make sure outbuf buffer is big enough for this.
        //
        dwStatus =  GetSecAuthMsg( g_pSspData,
                                    pWinContext->pCredential,
                                    pkgId,
                                    NULL, 
                                    &(pWinContext->SspContextHandle),
                                    fContextReq,
                                    NULL,
                                    0,
                                    pWinContext->szOutBuffer,
                                    &pWinContext->dwOutBufferLength,
                                    lpszServerName,
                                    bNonBlock,
                                    lpszScheme,
                                    lpszUrl,
                                    pssResult);
    
        if (dwStatus != SPM_STATUS_OK)
        {
            //  This is a rare case
            //
            pWinContext->dwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }

		(*lppvContext) = (LPVOID) pWinContext;

        //  Save the pointer of the created security ctxt
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
	}

	//
    //  Copy exchange blob to the output buffer
	//	Make sure output buffer provided is big enough
	//
	if (*lpdwOutBufferLength < pWinContext->dwOutBufferLength)
	{
	    *lpdwOutBufferLength = pWinContext->dwOutBufferLength + 1;
		return(ERROR_INSUFFICIENT_BUFFER);
	}

	CopyMemory (lpOutBuffer, pWinContext->szOutBuffer, 
				pWinContext->dwOutBufferLength);
	if (*lpdwOutBufferLength > pWinContext->dwOutBufferLength)
        lpOutBuffer[pWinContext->dwOutBufferLength] = '\0';

    *lpdwOutBufferLength = pWinContext->dwOutBufferLength;

    //
    //  The exchange blob has being copied to request header, so clear its len
    //

    pWinContext->dwOutBufferLength = 0;

	return(ERROR_SUCCESS);
}

DWORD
WINAPI
AuthenticateUserUI(
	IN OUT LPVOID*		lppvContext,
	IN	HWND			hWnd,
	IN	DWORD			dwError,
	IN	DWORD			dwFlags,
	IN OUT InvalidPassType* pAuthInfo,
	IN LPSTR                lpszScheme,
    IN PCSTR                lpszUrl,
	OUT SECURITY_STATUS*    pssResult
)
{
    DWORD           SPMStatus;
	PWINCONTEXT		pWinContext = NULL;
	BOOL			bNonBlock = FALSE;
    ULONG           fContextReq = ISC_REQ_PROMPT_FOR_CREDS | ISC_REQ_DELEGATE;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	if (*lppvContext == NULL)	{
		return(ERROR_INVALID_PARAMETER);
	}

	pWinContext = (PWINCONTEXT) (*lppvContext);

	if (pWinContext->lpszServerName == NULL)
		return(ERROR_INVALID_PARAMETER);

    pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
    ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);

	//
	// Now make the password logon happen by calling GetSecAuthMsg (without
	// context handle) with the ISC_REQ_PROMPT_FOR_CREDS flag set
	//	
	// After this will it call PreAuthenticateUser
	//

    SPMStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pWinContext->pkgId,
                                pWinContext->pSspContextHandle,
                                (PCtxtHandle) &(pWinContext->SspContextHandle),
                                fContextReq,
                                pWinContext->pInBuffer, 
                                pWinContext->dwInBufferLength, 
                                pWinContext->szOutBuffer,
                                &pWinContext->dwOutBufferLength,
                                pWinContext->lpszServerName,
                                bNonBlock,
                                lpszScheme,
                                lpszUrl,
                                pssResult);

    //  Clear out the input exchange blob
    //
    if (pWinContext->pInBuffer != NULL)
    {
        if (pWinContext->pInBuffer != pWinContext->szInBuffer)
            LocalFree (pWinContext->pInBuffer);
        pWinContext->pInBuffer = NULL;
        pWinContext->dwInBufferLength = 0;
    }

    if (SPMStatus != SPM_STATUS_OK) {   	 
		pWinContext->dwOutBufferLength = 0;
        return (ERROR_CANCELLED);
    }

    if (pWinContext->pSspContextHandle == NULL)
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);

	//
	// BUGBUG
	// Setup the UserName and Password to be " " to work around bugs in Wininet
	//

    lstrcpy (pAuthInfo->lpszUsername, " ");
    lstrcpy (pAuthInfo->lpszPassword, " ");

	return (ERROR_INTERNET_FORCE_RETRY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\plug.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"
#include "winctxt.h"

extern "C"
{
    extern SspData  *g_pSspData;
}
/*-----------------------------------------------------------------------------
    PLUG_CTX
-----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Load
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::Load()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::Load",
        "this=%#x",
        this
        ));

    INET_ASSERT(_pSPMData == _pPWC->pSPM);

    DWORD_PTR dwAuthCode = 0;


    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Pointer,
        "SSPI_InitScheme",
        "%s",
        GetScheme()
        ));

    dwAuthCode = SSPI_InitScheme (GetScheme());

    DEBUG_LEAVE(dwAuthCode);


    if (!dwAuthCode)
    {
        _pSPMData->eState = STATE_ERROR;
        DEBUG_LEAVE(ERROR_INTERNET_INTERNAL_ERROR);
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    _pSPMData->eState = STATE_LOADED;
    DEBUG_LEAVE(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}


/*---------------------------------------------------------------------------
    ClearAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::ClearAuthUser(LPVOID *ppvContext, LPSTR szServer)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::ClearAuthUser",
        "this=%#x ctx=%#x server=%.16s",
        this,
        *ppvContext,
        szServer
        ));

    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        AuthLock();

        __try
        {
            DEBUG_ENTER ((
                DBG_HTTPAUTH,
                None,
                "UnloadAuthenticateUser",
                "ctx=%#x server=%s scheme=%s",
                *ppvContext,
                szServer,
                GetScheme()
                ));

            UnloadAuthenticateUser(ppvContext, szServer, GetScheme());

            DEBUG_LEAVE(0);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT(
                HTTPAUTH,
                ERROR,
                ("UnloadAuthenticateUser call down faulted\n")
                );
        }
        ENDEXCEPT

        AuthUnlock();
    }
    *ppvContext = 0;
    DEBUG_LEAVE(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    wQueryHeadersAlloc

Routine Description:

    Allocates a HTTP Header String, and queries the HTTP handle for it.

Arguments:

    hRequestMapped          - An open HTTP request handle
                               where headers can be quiered
    dwQuery                 - The Query Type to pass to HttpQueryHeaders
    lpdwQueryIndex          - The Index of the header to pass to HttpQueryHeaders,
                              make sure to inialize to 0.
    lppszOutStr             - On success, a pointer to Allocated string with header string,
    lpdwSize                - size of the string returned in lppszOutStr

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    On Error, lppszOutStr may still contain an allocated string that will need to be
    freed.
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::wQueryHeadersAlloc
(
    IN HINTERNET hRequestMapped,
    IN DWORD dwQuery,
    OUT LPDWORD lpdwQueryIndex,
    OUT LPSTR *lppszOutStr,
    OUT LPDWORD lpdwSize
)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::wQueryHeadersAlloc",
        "this=%#x request=%#x query=%d queryidx=%#x {%d} ppoutstr=%#x lpdwSize=%#x",
        this,
        hRequestMapped,
        dwQuery,
        lpdwQueryIndex,
        *lpdwQueryIndex,
        lppszOutStr,
        lpdwSize
        ));

    LPSTR lpszRawHeaderBuf = NULL;
    DWORD dwcbRawHeaderBuf = 0;
    DWORD error;
    DWORD length;
    HTTP_REQUEST_HANDLE_OBJECT * pHttpRequest;

    INET_ASSERT(lppszOutStr);
    INET_ASSERT(hRequestMapped);
    INET_ASSERT(lpdwSize);


    *lppszOutStr = NULL;
    error = ERROR_SUCCESS;
    pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    // Attempt to determine whether our header is there.
    length = 0;
    if (pHttpRequest->QueryInfo(dwQuery, NULL, &length, lpdwQueryIndex)
          != ERROR_INSUFFICIENT_BUFFER)
    {
        // no authentication happening, we're done
        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    // Allocate a Fixed Size Buffer
    lpszRawHeaderBuf = (LPSTR) ALLOCATE_MEMORY(LPTR, length);
    dwcbRawHeaderBuf = length;

    if ( lpszRawHeaderBuf == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = pHttpRequest->QueryInfo
        (dwQuery, lpszRawHeaderBuf, &dwcbRawHeaderBuf, lpdwQueryIndex);

    INET_ASSERT(error != ERROR_INSUFFICIENT_BUFFER );
    INET_ASSERT(error != ERROR_HTTP_HEADER_NOT_FOUND );

quit:

    if ( error != ERROR_SUCCESS  )
    {
        dwcbRawHeaderBuf = 0;

        if ( lpszRawHeaderBuf )
            *lpszRawHeaderBuf = '\0';
    }

    *lppszOutStr = lpszRawHeaderBuf;
    *lpdwSize = dwcbRawHeaderBuf;

    DEBUG_LEAVE(error);
    return error;
}

/*-----------------------------------------------------------------------------
    CrackAuthenticationHeader

Routine Description:

    Attempts to decode a HTTP 1.1 Authentication header into its
    components.

Arguments:

    hRequestMapped           - Mapped Request handle
    fIsProxy                 - Whether proxy or server auth
    lpdwAuthenticationIndex  - Index of current HTTP header. ( initally called with 0 )
    lppszAuthHeader          - allocated pointer which should be freed by client
    lppszAuthScheme          - Pointer to Authentication scheme string.
    lppszRealm               - Pointer to Realm string,
    lpExtra                  - Pointer to any Extra String data in the header that is not
                                   part of the Realm
    lpdwExtra                - Pointer to Size of Extra data.
    lppszAuthScheme

  Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_NOT_ENOUGH_MEMORY,
              ERROR_HTTP_HEADER_NOT_FOUND

Comments:
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::CrackAuthenticationHeader
(
    IN HINTERNET hRequestMapped,
    IN BOOL      fIsProxy,
    IN     DWORD dwAuthenticationIndex,
    IN OUT LPSTR *lppszAuthHeader,
    IN OUT LPSTR *lppszExtra,
    IN OUT DWORD *lpdwExtra,
       OUT LPSTR *lppszAuthScheme
    )
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::CrackAuthenticationHeader",
        "this=%#x request=%#x isproxy=%B authidx=%d ppszAuthHeader=%#x ppszExtra=%#x pdwExtra=%#x ppszAuthScheme=%#x",
        this,
        hRequestMapped,
        fIsProxy,
        dwAuthenticationIndex,
        lppszAuthHeader,
        lppszExtra,
        lpdwExtra,
        lppszAuthScheme
        ));

    DWORD error = ERROR_SUCCESS;

    LPSTR lpszAuthHeader = NULL;
    DWORD cbAuthHeader = 0;
    LPSTR lpszExtra = NULL;
    LPSTR lpszAuthScheme = NULL;

    LPDWORD lpdwAuthenticationIndex = &dwAuthenticationIndex;
    INET_ASSERT(lpdwExtra);
    INET_ASSERT(lppszExtra);
    INET_ASSERT(lpdwAuthenticationIndex);

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    error = wQueryHeadersAlloc (hRequestMapped, dwQuery,
        lpdwAuthenticationIndex, &lpszAuthHeader, &cbAuthHeader);

    if ( error != ERROR_SUCCESS )
    {
        INET_ASSERT(*lpdwAuthenticationIndex
            || error == ERROR_HTTP_HEADER_NOT_FOUND );
        goto quit;
    }


    //
    // Parse Header for Scheme type
    //
    lpszAuthScheme = lpszAuthHeader;

    while ( *lpszAuthScheme == ' ' )  // strip spaces
        lpszAuthScheme++;

    lpszExtra = strchr(lpszAuthScheme, ' ');

    if (lpszExtra)
        *lpszExtra++ = '\0';

    if (lstrcmpi(GetScheme(), lpszAuthScheme))
    {
        DEBUG_PRINT(
            HTTPAUTH,
            ERROR,
            ("Authentication: HTTP Scheme has changed!: Scheme=%q\n", lpszAuthScheme)
            );

        goto quit;

    }


    DEBUG_PRINT(
        HTTPAUTH,
        INFO,
        ("Authentication: found in headers: Scheme=%q, Extra=%q\n",
        lpszAuthScheme, lpszExtra)
        );

quit:
    *lppszExtra  = lpszExtra;
    *lpdwExtra   = lpszExtra ? lstrlen(lpszExtra) : 0;
    *lppszAuthHeader = lpszAuthHeader;
    *lppszAuthScheme = lpszAuthScheme;

    DEBUG_LEAVE(error);
    return error;
}


/*---------------------------------------------------------------------------
    ResolveProtocol
---------------------------------------------------------------------------*/
VOID PLUG_CTX::ResolveProtocol()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "PLUG_CTX::ResolveProtocol",
        "this=%#x",
        this
        ));

    SECURITY_STATUS ssResult;
    PWINCONTEXT pWinContext;
    SecPkgContext_NegotiationInfo SecPkgCtxtInfo;

    INET_ASSERT(GetSchemeType() == SCHEME_NEGOTIATE);

    SecPkgCtxtInfo.PackageInfo = NULL;
    
    // Call QueryContextAttributes on the context handle.
    pWinContext = (PWINCONTEXT) (_pvContext);
    ssResult = (*(g_pSspData->pFuncTbl->QueryContextAttributes))
        (pWinContext->pSspContextHandle, SECPKG_ATTR_NEGOTIATION_INFO, &SecPkgCtxtInfo);

    if (ssResult == SEC_E_OK 
        && (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE
            || (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC)))
    {
        // Resolve actual auth protocol from package name.
        // update both the auth context and pwc entry.
        if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "NTLM"))
        {
            _eSubScheme = SCHEME_NTLM;
            _dwSubFlags = PLUGIN_AUTH_FLAGS_NO_REALM;
        }
        else if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "Kerberos"))
        {
            _eSubScheme = SCHEME_KERBEROS;
            _dwSubFlags = PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
        }
        
        DEBUG_PRINT(
            HTTPAUTH,
            INFO,
            ("Negotiate package is using %s\n", SecPkgCtxtInfo.PackageInfo->Name)
            );


    }


    if( SecPkgCtxtInfo.PackageInfo )
    {
        (*(g_pSspData->pFuncTbl->FreeContextBuffer))(SecPkgCtxtInfo.PackageInfo);
    }

    DEBUG_LEAVE(0);
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PLUG_CTX::PLUG_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, PWC* pPWC)
    : AUTHCTX(pSPM, pPWC)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Pointer,
        "PLUG_CTX::PLUG_CTX",
        "this=%#x request=%#x isproxy=%B pSPM=%#x pPWC=%#x",
        this,
        pRequest,
        fIsProxy,
        pSPM,
        pPWC
        ));

    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
    _szAlloc = NULL;
    _szData = NULL;
    _cbData = 0;
    _pRequest->SetAuthState(AUTHSTATE_NONE);
    _fNTLMProxyAuth = _fIsProxy && (GetSchemeType() == SCHEME_NTLM );

    _SecStatus = 0;
    _dwResolutionId = 0;

    DEBUG_LEAVE(this);
}

/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PLUG_CTX::~PLUG_CTX()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "PLUG_CTX::~PLUG_CTX",
        "this=%#x",
        this
        ));

    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        if (_pPWC)
        {
            ClearAuthUser(&_pvContext, _pPWC->lpszHost);
        }
    }
    if (_pRequest)
    {
        _pRequest->SetAuthState(AUTHSTATE_NONE);
    }

    DEBUG_LEAVE(0);
}

PCSTR PLUG_CTX::GetUrl(void) const
{
    return _pRequest->GetURL();
}



/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PreAuthUser(OUT LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::PreAuthUser",
        "this=%#x",
        this
        ));

    INET_ASSERT(_pSPMData == _pPWC->pSPM);

    AuthLock();

    DWORD dwError;
    SECURITY_STATUS ssResult;
    PSTR lpszPass = _pPWC->GetPass();

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
    }

    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;

        DEBUG_ENTER ((
            DBG_HTTPAUTH,
            Dword,
            "PreAuthenticateUser",
            "ctx=%#x host=%s scheme=%s {buf=%x (%.16s...) cbbuf=%d} user=%s pass=%s",
            _pvContext,
            _pPWC->lpszHost,
            InternetMapAuthScheme(GetSchemeType()),
            pBuf,
            pBuf,
            *pcbBuf,
            _pPWC->lpszUser,
            lpszPass
            ));

        LPSTR lpszFQDN = (LPSTR)GetFQDN((LPCSTR)_pPWC->lpszHost);
        LPSTR lpszHostName =  lpszFQDN ? lpszFQDN : _pPWC->lpszHost;
        
        dwError = PreAuthenticateUser(&_pvContext,
                               lpszHostName,
                               GetScheme(),
                               0, // dwFlags
                               pBuf,
                               pcbBuf,
                               _pPWC->lpszUser,
                               lpszPass,
                               GetUrl(),
                               &ssResult);

        DEBUG_PRINT(HTTPAUTH, INFO, ("ssres: %#x [%s]\n", ssResult, InternetMapError(ssResult)));
        DEBUG_LEAVE(dwError);

        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.

            if ((GetSchemeType() == SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }
        }
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTPAUTH, ERROR, ("PreAuthenticateUser call down faulted\n"));
        _pSPMData->eState = STATE_ERROR;
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    }

    ENDEXCEPT

    DEBUG_PRINT(
        HTTPAUTH,
        INFO,
            (
            "request %#x [%s] now in %s using %s\n",
            _pRequest,
            _pPWC->lpszHost,
            InternetMapAuthState(_pRequest->GetAuthState()),
            InternetMapAuthScheme(GetSchemeType())
            )
        );

exit:
    if (lpszPass)
    {
        memset(lpszPass, 0, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }

    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}


/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::UpdateFromHeaders",
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwError, cbExtra, dwAuthIdx;
    LPSTR szAuthHeader, szExtra, szScheme;

    AuthLock();

    // Get the auth header index corresponding to the scheme of this ctx.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto quit;

    // Get the scheme and any extra data.
    if ((dwError = CrackAuthenticationHeader(pRequest, fIsProxy, dwAuthIdx,
        &szAuthHeader, &szExtra, &cbExtra, &szScheme)) != ERROR_SUCCESS)
        goto quit;
    
    if (!cbExtra)
        _pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);

    // Check if auth scheme requires keep-alive.
    if (!(GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED))
    {
        // if in negotiate phase check if we are going via proxy.
        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            // BUGBUG: if via proxy, we are not going to get keep-alive
            // connection to the server.  It would be nice if we knew
            // a priori the whether proxy would allow us to tunnel to
            // http port on the server.  Otherwise if we try and fail,
            // we look bad vs. other browsers who are ignorant of ntlm
            // and fall back to basic.
            CHAR szBuffer[64];
            DWORD dwBufferLength = sizeof(szBuffer);
            DWORD dwIndex = 0;
            BOOL fSessionBasedAuth = FALSE;
            if (pRequest->QueryResponseHeader(HTTP_QUERY_PROXY_SUPPORT, 
                                          szBuffer, &dwBufferLength, 
                                          0, &dwIndex) == ERROR_SUCCESS)
            {
                if (!_stricmp(szBuffer, "Session-Based-Authentication"))
                {
                    fSessionBasedAuth = TRUE;
                }
            }
            if (!fIsProxy && pRequest->IsRequestUsingProxy()
                && !pRequest->IsTalkingToSecureServerViaProxy() && !fSessionBasedAuth)
            {
                // Ignore NTLM via proxy since we won't get k-a to server.
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

        // Else if in challenge phase, we require a persistent connection.
        else
        {
            // If we don't have a keep-alive connection ...
            if (!(pRequest->IsPersistentConnection (fIsProxy)) && !(pRequest->IsRequestUsingProxy()))
            {
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

    } // end if keep-alive required

    quit:

    if (dwError == ERROR_SUCCESS)
    {
        // If no password cache is set in the auth context,
        // find or create one and set it in the handle.
        if (!_pPWC)
        {
            _pPWC = FindOrCreatePWC(pRequest, fIsProxy, _pSPMData, NULL);

            if (!_pPWC)
            {
                INET_ASSERT(FALSE);
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
            }
            else
            {
                INET_ASSERT(_pPWC->pSPM == _pSPMData);
                _pPWC->nLockCount++;
            }
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        // Point to allocated data.
        _szAlloc = szAuthHeader;
        _szData = szExtra;
        _cbData = cbExtra;
    }
    else
    {
        // Free allocated data.
        if (_szAlloc)
            delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
        _cbData = 0;
    }

    DEBUG_PRINT(
        HTTPAUTH,
        INFO,
            (
            "request %#x [%s] now in %s using %s\n",
            _pRequest,
            _pPWC->lpszHost,
            InternetMapAuthState(_pRequest->GetAuthState()),
            InternetMapAuthScheme(GetSchemeType())
            )
        );

    // Return of non-success will cancel auth session.
    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PLUG_CTX::PostAuthUser",
        "this=%#x",
        this
        ));

    INET_ASSERT(_pSPMData == _pPWC->pSPM);

    AuthLock();

    DWORD dwError;
    PSTR lpszPass = _pPWC->GetPass();
    
    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy || _pRequest->GetCredPolicy()
        == URLPOLICY_CREDENTIALS_SILENT_LOGON_OK;

    SECURITY_STATUS ssResult;
    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;


        DEBUG_ENTER ((
            DBG_HTTPAUTH,
            Dword,
            "AuthenticateUser",
            "ctx=%#x host=%s scheme=%s {data=%#x (%.16s...) cbdata=%d} user=%s pass=%s",
            _pvContext,
            _pPWC->lpszHost,
            InternetMapAuthScheme(GetSchemeType()),
            _szData,
            _szData,
            _cbData,
            _pPWC->lpszUser,
            lpszPass
            ));

        LPSTR lpszFQDN = (LPSTR)GetFQDN((LPCSTR)_pPWC->lpszHost);
        LPSTR lpszHostName = lpszFQDN ? lpszFQDN : _pPWC->lpszHost;

        dwError = AuthenticateUser(&_pvContext,
                                   lpszHostName,
                                   GetScheme(),
                                   fCanUseLogon,
                                   _szData,
                                   _cbData,
                                   _pPWC->lpszUser,
                                   lpszPass,
                                   GetUrl(),
                                   &ssResult);

        _SecStatus = ssResult;

        DEBUG_PRINT(HTTPAUTH, INFO, ("ssres: %#x [%s]\n", ssResult, InternetMapError(ssResult)));
        DEBUG_LEAVE(dwError);

        // Kerberos package can get into a bad state.
        if (GetSchemeType() == SCHEME_KERBEROS && ssResult == SEC_E_WRONG_PRINCIPAL)
            dwError = ERROR_INTERNET_INCORRECT_PASSWORD;
            
        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.

            if ((GetSchemeType() == SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTPAUTH, ERROR, ("AuthenticateUser faulted!\n"));
        dwError = ERROR_BAD_FORMAT;
        _pSPMData->eState = STATE_ERROR;
    }
    ENDEXCEPT

    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
    }

    _cbData = 0;

    DEBUG_PRINT(
        HTTPAUTH,
        INFO,
            (
            "request %#x [%s] now in %s using %s\n",
            _pRequest,
            _pPWC->lpszHost,
            InternetMapAuthState(_pRequest->GetAuthState()),
            InternetMapAuthScheme(GetSchemeType())
            )
        );

exit:
    if (lpszPass)
    {
        memset(lpszPass, 0, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }

    AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}

LPCSTR PLUG_CTX::GetFQDN(LPCSTR lpszHostName)
{
    if (lstrcmpi(GetScheme(), "Negotiate")) // only need to get FQDN for Kerberos
    {
        return NULL;
    }

    if (_pszFQDN)
    {
        return _pszFQDN;
    }

    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;
    
    
    DWORD TTL;
    LPADDRINFO lpAddrInfo;
    if (lpResolverCacheEntry = QueryResolverCache((LPSTR)lpszHostName, NULL, &lpAddrInfo, &TTL)) 
    {
        _pszFQDN = (lpAddrInfo->ai_canonname ? NewString(lpAddrInfo->ai_canonname) : NULL);
        ReleaseResolverCacheEntry(lpResolverCacheEntry);
        return _pszFQDN;
    }

    /*
    CAddressList TempAddressList;
    DWORD dwResolutionId;
    TempAddressList.ResolveHost((LPSTR)lpszHostName, &_dwResolutionId, SF_FORCE);

    if (lpResolverCacheEntry = QueryResolverCache((LPSTR)lpszHostName, NULL, &lpAddrInfo, &TTL)) 
    {
        _pszFQDN = (lpAddrInfo->ai_canonname ? NewString(lpAddrInfo->ai_canonname) : NULL);
        ReleaseResolverCacheEntry(lpResolverCacheEntry);
        return _pszFQDN;
    }
    */

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\sspspm.c ===
/*#----------------------------------------------------------------------------
**
**  File:           sspspm.c
**
**  Synopsis:   Security Protocol Module for SSPI Authentication providers.
**                  
**      This module contains major funtions of the SEC_SSPI.DLL which 
**      allows the Internet Explorer to use SSPI providers for authentication.
**      The function exported to the Internet Explorer is Ssp_Load() which 
**      passes the address of the Ssp__DownCall() function to the Explorer.
**      Then the Explorer will call Ssp__DownCall() when it needs service from 
**      this SPM DLL.  The two major functions called by Ssp__DownCall() to 
**      service Explorer's request are Ssp__PreProcessRequest() and 
**      Ssp__ProcessResponse().  In brief, Ssp__PreProcessRequest() is 
**      called before the Explorer sends out a request which does not have 
**      any 'Authorization' header yet.  And Ssp__ProcessResponse() is called 
**      whenever the Explorer receives an 401 'Unauthorized' response from the 
**      server.  This SPM DLL supports all SSPI packages which are installed 
**      on the machine.  However, MSN will be given higher priority over the 
**      other SSPI packages if the user already logon to MSN; in that case, 
**      Ssp__PreProcessRequest() will always attach MSN authentication header 
**      to the out-going request.
**
**      This SPM DLL is called by the Internet Explorer only for its
**      The Internet Explorer only calls this SPM DLL when it needs 
**      authentication data in its request/response. In other words, the 
**      Explorer never calls this SPM DLL when an authentication succeeded; 
**      it never calls this DLL when it decide to give up on a connection 
**      because of server response timeout.  Because of this fact, this SPM 
**      DLL never has sufficient information on the state of each server 
**      connection; it only know its state based on the content of the last 
**      request and the content of the current response. For this reason, this 
**      SPM DLL does not keep state information for each host it has visited 
**      unless the information is essential. 
**      The security context handle returned from the first call of  
**      InitializeSecurityContext() for NEGOTIATE message generation is 
**      always the identical for a SSPI package when the same server host is 
**      passed.  Since the server host name is always in the request/response
**      header, the only information essential in generating a NEGOTIATE or 
**      RESPONSE is already available in the header. So unlike most SSPI 
**      application, this DLL will not keep the security context handle which 
**      it received from the SSPI function calls. Whenever it needs to call 
**      the SSPI function for generating a RESPONSE, it will first call the 
**      SSPI function without the CHALLENGE to get a security context handle.
**      Then it calls the SSPI function again with the CHALLENGE to generate 
**      a RESPONSE.
**
**
**      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
**
**  Authors:        LucyC       Created                         25 Sept. 1995
**
**---------------------------------------------------------------------------*/
#include "msnspmh.h"
#include <ntverp.h>
//
// Global variable where all the SSPI Pkgs data is collected
//
SspData  *g_pSspData;
HINSTANCE g_hSecLib;
BOOL g_fIsWhistler = FALSE;
BOOL g_fCanUseCredMgr = FALSE;

/*-----------------------------------------------------------------------------
**
**  Function:   SpmAddSSPIPkg
**
**  Synopsis:   This function adds a SSPI package to the SPM's package list.
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**              pPkgName - package name
**              cbMaxToken - max size of security token
**
**  Returns:    The index in the package list where this new package is added.
**              If failed to add the new package, SSPPKG_ERROR is returned.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
UCHAR
SpmAddSSPIPkg (
    SspData *pData, 
    LPTSTR   pPkgName,
    ULONG    cbMaxToken
    )
{
    if ( !(pData->PkgList[pData->PkgCnt] =
                        LocalAlloc(0, sizeof(SSPAuthPkg))))
    {
        return SSPPKG_ERROR;
    }

    if ( !(pData->PkgList[pData->PkgCnt]->pName = 
                        LocalAlloc(0, lstrlen(pPkgName)+1)))
    {
        LocalFree(pData->PkgList[pData->PkgCnt]);
        pData->PkgList[pData->PkgCnt] = NULL;
        return SSPPKG_ERROR;
    }

    lstrcpy (pData->PkgList[pData->PkgCnt]->pName, pPkgName);
    pData->PkgList[ pData->PkgCnt ]->Capabilities = 0 ;

    pData->PkgList[ pData->PkgCnt ]->cbMaxToken = cbMaxToken;

    //
    // Determine if this package supports anything of interest to
    // us.
    //

    if ( lstrcmpi( pPkgName, NTLMSP_NAME_A ) == 0 )
    {
        //
        // NTLM supports the standard credential structure
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;
    }
    else if ( lstrcmpi( pPkgName, "Negotiate" ) == 0 )
    {
        //
        // Negotiate supports that cred structure too
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;

    }
    else
    {
        //
        // Add more comparisons here, eventually.
        //

        ;
    }

    pData->PkgCnt++;
    return (pData->PkgCnt - 1);
}

/*-----------------------------------------------------------------------------
**
**  Function:   SpmFreePkgList
**
**  Synopsis:   This function frees memory allocated for the package list. 
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**
**  Returns:    void.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
VOID
SpmFreePkgList (
    SspData *pData
    )
{
    int ii;

    for (ii = 0; ii < pData->PkgCnt; ii++)
    {
        LocalFree(pData->PkgList[ii]->pName);

        LocalFree(pData->PkgList[ii]);
    }

    LocalFree(pData->PkgList);
}


/*-----------------------------------------------------------------------------
**
**  Function:   Ssp__Unload
**
**  Synopsis:   This function is called by the Internet Explorer before 
**              the SPM DLL is unloaded from the memory.
**
**  Arguments:  fpUI - From Explorer for making all UI_SERVICE call
**              pvOpaqueOS - From Explorer for making all UI_SERVICE call
**              htspm - the SPM structure which contains the global data 
**                      storage for this SPM DLL.
**
**  Returns:    always returns SPM_STATUS_OK, which means successful.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
DWORD SSPI_Unload()
{
    if (g_pSspData != NULL)
    {
        SpmFreePkgList(g_pSspData);
        LocalFree(g_pSspData);
        g_pSspData = NULL;
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }
        
    return SPM_STATUS_OK;
}



/*-----------------------------------------------------------------------------
**
**  Function:   SspSPM_InitData
**
**  Synopsis:   This function allocates and initializes global data structure 
**              of the SPM DLL.
**
**  Arguments:  
**
**  Returns:    Pointer to the allocated global data structure.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
LPVOID SSPI_InitGlobals(void)
{
    SspData *pData = NULL;
    OSVERSIONINFO   VerInfo;
    UCHAR lpszDLL[SSP_SPM_DLL_NAME_SIZE];
    INIT_SECURITY_INTERFACE    addrProcISI = NULL;

    SECURITY_STATUS sstat;
    ULONG           ii, cntPkg;
    PSecPkgInfo     pPkgInfo = NULL;
    PSecurityFunctionTable    pFuncTbl = NULL;

    if (g_pSspData)
        return g_pSspData;
    
    //
    //  Setup registry to enable MSN authentication package 
    //  MSNSetupSspiReg();
    //

    //
    // Initialize SSP SPM Global Data
    //

    //
    //  Find out which security DLL to use, depending on 
    //  whether we are on NT or Win95
    //
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong
    {
        return (NULL);
    }

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        lstrcpy (lpszDLL, SSP_SPM_NT_DLL);

        if ((VerInfo.dwMajorVersion >= 5) &&
            (VerInfo.dwMinorVersion >= 1))
        {
            DWORD dwMaximumPersist = 0;

            g_fIsWhistler = TRUE;
        }
        else
        {
            g_fIsWhistler = FALSE;
        }
    }
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        lstrcpy (lpszDLL, SSP_SPM_WIN95_DLL);
    }
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_UNIX)
    {
        lstrcpy (lpszDLL, SSP_SPM_UNIX_DLL);
    }
    else
    {
        return (NULL);
    }

    if (!(pData = (SspData *) LocalAlloc(0, sizeof(SspData))))    {
        
        return(NULL);

    }

    //
    //  Keep these information in global SPM
    //
    ZeroMemory (pData, sizeof(SspData));
    pData->MsnPkg = SSPPKG_NO_PKG;

    //
    //  Load Security DLL
    //
    g_hSecLib = LoadLibrary (lpszDLL);
    if (g_hSecLib == NULL)
    {
        // This should never happen.
        goto Cleanup;
    }

#ifdef UNIX

//  A hack to undo the mistake in the sspi.h file. The change should be made
//  to sspi.h

#if !defined(_UNICODE)
#undef SECURITY_ENTRYPOINT_ANSI
#define SECURITY_ENTRYPOINT_ANSI  "InitSecurityInterfaceA"
#endif 

    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( g_hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
#else
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( g_hSecLib, 
                    SECURITY_ENTRYPOINT);       
#endif /* UNIX */
    if (addrProcISI == NULL)
    {
        goto Cleanup;
    }

    //
    // Get the SSPI function table
    //
    pFuncTbl = (*addrProcISI)();

    //
    //  If we already loaded MSNSSPC.DLL explicitly, PkgCnt will not be zero;
    //  in that case, we only support MSN SSPI and do not need to call 
    //  EnumerateSecurityPackages.
    //
    //  So if we did not load MSNSSPC.DLL (i.e. PkgCnt is zero), we need to 
    //  get the list of SSPI packages which we support from 
    //  EnumerateSecurityPackages.
    //
    if (pData->PkgCnt == 0)
    {
        //
        //  Get list of packages supported
        //
        sstat = (*(pFuncTbl->EnumerateSecurityPackages))(&cntPkg, &pPkgInfo);
        if (sstat != SEC_E_OK || pPkgInfo == NULL)
        {
            //
            // ??? Should we give up here ???
            // EnumerateSecurityPackage() failed
            //
            goto Cleanup;
        }

        if (cntPkg)
        {
            //
            //  Create the package list
            //
            if (!(pData->PkgList = (PSSPAuthPkg *)LocalAlloc(0, 
                                                cntPkg*sizeof(PSSPAuthPkg))))
            {
                goto Cleanup;
            }
        }

        for (ii = 0; ii < cntPkg; ii++)
        {
            if (lstrcmp (pPkgInfo[ii].Name, MSNSP_NAME) == 0)
            {
                //DebugTrace(SSPSPMID, "Found MSN SSPI package\n");
                pData->MsnPkg = SpmAddSSPIPkg (
                                        pData,
                                        MSNSP_NAME,
                                        MAX_AUTH_MSG_SIZE // 11000 hard-coded
                                        );
                if (pData->MsnPkg == SSPPKG_ERROR)
                {
                    goto Cleanup;
                }
            }
            else
            {
                //DebugTrace(SSPSPMID, "Found %s SSPI package\n", 
                //                     pPkgInfo[ii].Name);

                if (SpmAddSSPIPkg (pData, 
                                   pPkgInfo[ii].Name,
                                   pPkgInfo[ii].cbMaxToken
                                   ) == SSPPKG_ERROR)
                {
                    goto Cleanup;
                }
            }
        }
    }

    pData->pFuncTbl = pFuncTbl;
    pData->bKeepList = TRUE;    // By default, keep a list of non-MSN servers 

    if (pData->PkgCnt == 0)
    {
        goto Cleanup;
    }

    g_pSspData = pData;
    pData = NULL;

Cleanup:


    if( pPkgInfo != NULL )
    {
        //
        // Free buffer returned by the enumerate security package function
        //

        (*(pFuncTbl->FreeContextBuffer))(pPkgInfo);
    }

    if( pData != NULL )
    {
        SpmFreePkgList (pData);
    }

    return (g_pSspData);
}

INT
GetPkgId(LPTSTR  lpszPkgName)
{

    int ii;

    if ( g_pSspData == NULL )
    {
        return -1;
    }

    for (ii = 0; ii < g_pSspData->PkgCnt; ii++)
    {
#ifdef UNIX
        if (!lstrcmpi(g_pSspData->PkgList[ii]->pName, lpszPkgName))
#else
        if (!lstrcmp(g_pSspData->PkgList[ii]->pName, lpszPkgName))
#endif /* UNIX */
        {
            return(ii);
        }
    }

    return(-1);
}

DWORD
GetPkgCapabilities(
    INT Package
    )
{
    if ( Package < g_pSspData->PkgCnt )
    {
        return g_pSspData->PkgList[ Package ]->Capabilities ;
    }
    else
        return 0 ;
}

ULONG
GetPkgMaxToken(
    INT Package
    )
{
    if ( Package < g_pSspData->PkgCnt )
    {
        return g_pSspData->PkgList[ Package ]->cbMaxToken;
    }
    else {
        // be compatible with old static buffer size
        return MAX_AUTH_MSG_SIZE;
    }
}

//
//  Calls to this function are serialized
//

DWORD_PTR SSPI_InitScheme (LPCSTR lpszScheme)
{
    int ii;

       if (!SSPI_InitGlobals())
           return 0;

    //  Once initialized, check to see if this scheme is installed 
    for (ii = 0; ii < g_pSspData->PkgCnt && 
#ifdef UNIX
        lstrcmpi (g_pSspData->PkgList[ii]->pName, lpszScheme); ii++);
#else
        lstrcmp (g_pSspData->PkgList[ii]->pName, lpszScheme); ii++);
#endif /* UNIX */

    if (ii >= g_pSspData->PkgCnt)
    {
        // This scheme is not installed on this machine
        return (0);
    }
    
    return ((DWORD_PTR)g_pSspData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\sspcalls.c ===
/*#----------------------------------------------------------------------------
**
**  File:           sspcalls.c
**
**      Synopsis:   This module contains SSPI function calls for SSPI SPM DLL.
**
**      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
**
**  Authors:        LucyC       Created                         25 Sept. 1995
**
**---------------------------------------------------------------------------*/

#include "msnspmh.h"
#include <debugmem.h>
#include "urlmon.h"

BOOL g_fUUEncodeData = TRUE;

typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

typedef 
BOOL
(WINAPI * PFN_GET_COMPUTER_NAME_EX)(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

PFN_GET_COMPUTER_NAME_EX g_pfnGetComputerNameExA = NULL;

DWORD GetZoneFromUrl(LPSTR pszUrl);

/*-----------------------------------------------------------------------------
**
**  Function:   GetSecAuthMsg
**
**  Synopsis:   This function generates a SSPI NEGOTIATE or RESPONSE 
**				authorization string for the specified SSPI package.
**				The authorization string generated by this function 
**				follows the format: 
**					"<Package Name> <Package Specific Auth. Data>"
**				If global uuencoding is turned on, this functions will 
**				uuencode the message before building it into an  
**				authorization string; by default, the uuencoding flag is 
**				always on.  
**				This functions calls InitializeSecurityContext() to 
**				generate the NEGOTIATE/RESPONSE message for the authori-
**				zation string. If the SSPI function returns NO_CREDENTIAL, 
**				and if the PROMPT_CREDS flag is not turned on when blocking
**				is permitted, this function will call the SSPI function 
**				again with the PROMPT_CREDS flag set; if SSPI returns 
**				NO_CREDENTIAL again, this SSPI will return ERROR to the 
**				caller.
**
**
**  Arguments:
**
**		pData - pointer to SspData containing the SSPI function table 
**				and the SSPI package list. 
**		pkgID - the package index of the SSPI package to use.
**		pInContext - pointer to a context handle. If NULL is specified, 
**					 this function will use a temporary space for the context
**					 handle and delete the handle before returning to the 
**					 caller. If non-NULL address is specified, the context 
**					 handle created by the SSPI is returned to the caller. 
**					 And the caller will have to delete the handle when it's
**					 done with it.
**		fContextReq - the SSPI request flag to pass to InitializeSecurityContext
**		pBuffIn - pointer to the uudecoded CHALLENGE message if any. 
**				  For generating NEGOTIATE message, this pointer should be NULL.
**		cbBuffIn - length of the CHALLENGE message. This should be zero when  
**				   when pBuffIn is NULL.
**		pFinalBuff - pointer to a buffer for the final authorization string.
**		pszTarget - Server Host Name
**		bNonBlock - a flag which is set if blocking is not permitted.
**
**  Return Value:
**
**		SPM_STATUS_OK	- if an authorization string is generated successfully
**  	SPM_STATUS_WOULD_BLOCK - if generating an authorization string would 
**					cause blocking when blocking is not permitted. 
**		SPM_ERROR - if any problem/error is encountered in generating an 
**					authorization string, including user hitting cancel on 
**					the SSPI dialog prompt for name/password.
**
**---------------------------------------------------------------------------*/
DWORD
GetSecAuthMsg (
    PSspData        pData, 			 
    PCredHandle     pCredential, 
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
	PCtxtHandle		pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn, 
    DWORD           cbBuffIn, 
    char            *pFinalBuff, 
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    UINT            bNonBlock,
    LPSTR           pszScheme,
    PCSTR           lpszUrl,
    SECURITY_STATUS *pssResult
    )
{
//    char                  szDecodedBuf[MAX_BLOB_SIZE];
//    char                  *szDecodedBuf;
//    char                  FastDecodedBuf[MAX_BLOB_SIZE];
    char                  *SlowDecodedBuf = NULL;

    int                   retsize;
    SECURITY_STATUS       SecStat;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;

//    char                  OutBufPlain[MAX_AUTH_MSG_SIZE];
    char                  *SlowOutBufPlain = NULL;

    char                  *pOutMsg = NULL;
    DWORD                 RetStatus;
    long                  maxbufsize;
    CHAR                  szDecoratedTarget[MAX_PATH + 6];
    DWORD                 cbTarget;

    ULONG                 cbMaxToken;


	//
	// BUGBUG: Deal with output buffer not being long enough


    if (pFinalBuff == NULL) {
        return(SPM_ERROR);
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

	OutSecBuff.cbBuffer = MAX_AUTH_MSG_SIZE;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;


    // Always use the slow alloc'ed buf as a quick fix to appease
    // DAV redir stress scenarios, which run in svchost and starts
    // with a 4KB stack limit.
    cbMaxToken = GetPkgMaxToken( pkgID );

    SlowOutBufPlain = (char *) ALLOCATE_FIXED_MEMORY(cbMaxToken);

    if( SlowOutBufPlain == NULL )
    {
        RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }
    OutSecBuff.pvBuffer = SlowOutBufPlain;
    OutSecBuff.cbBuffer = cbMaxToken;

    //
    //  Prepare our Input buffer if a CHALLENGE message is passed in.
    //
    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.BufferType = SECBUFFER_TOKEN;

        //
        // If this is UUENCODED, decode it first
        //
        if ( g_fUUEncodeData)
        {
            DWORD cbDecodedBuf;

            cbDecodedBuf = cbBuffIn;
            SlowDecodedBuf = ALLOCATE_FIXED_MEMORY(cbDecodedBuf);
            if( SlowDecodedBuf == NULL )
            {
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }

            InSecBuff.cbBuffer   = HTUU_decode (pBuffIn, SlowDecodedBuf,
                                                cbDecodedBuf);
            InSecBuff.pvBuffer   = SlowDecodedBuf;
        }
		else
        {
            InSecBuff.cbBuffer   = cbBuffIn;
            InSecBuff.pvBuffer   = pBuffIn;
        }
    }

    // If scheme is Negotiate, set ISC_REQ_MUTUAL_AUTH and decorate
    // the server name indicated by pszTarget by appending a '$' to the
    // server name.
    if (pszScheme && !(lstrcmpi(pszScheme, "Negotiate")))
    {
        fContextReq |= ISC_REQ_MUTUAL_AUTH;
        cbTarget = (pszTarget ? strlen(pszTarget) : 0);
        if (cbTarget && (cbTarget <= MAX_PATH - sizeof( "HTTP/" )))
        {
            memcpy(szDecoratedTarget, "HTTP/", sizeof( "HTTP/" ) - 1 );
            memcpy(szDecoratedTarget + sizeof( "HTTP/" ) - 1, pszTarget, cbTarget + 1);
            pszTarget = szDecoratedTarget;

            // OutputDebugStringA(pszTarget);
        }
    }

	//
	//	Call SSPI function generate the NEGOTIATE/RESPONSE message
	//

    if (fContextReq & ISC_REQ_DELEGATE)
    {
        // we should only request delegation when calling InitializeSecurityContext if 
        // the site is in the intranet or trusted sites zone. Otherwise you will be giving 
        // the user's TGT to any web server that is trusted for delegation.

        DWORD dwZone = GetZoneFromUrl((PSTR)lpszUrl);

        if ((dwZone != URLZONE_INTRANET) && (dwZone != URLZONE_TRUSTED))
        {
            fContextReq &= ~ISC_REQ_DELEGATE;
        }
    }

SspiRetry:

//
// BUGBUG: Same credential handle could be used by multiple threads at the
// same time.
//
    SecStat = (*(pData->pFuncTbl->InitializeSecurityContext))(
                                pCredential, 
                                pInContext,
                                pszTarget,
                                fContextReq,
                                0,
                                SECURITY_NATIVE_DREP,
                                (pBuffIn) ? &InBuffDesc : NULL, 
                                0,
                                pOutContext, 
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );
	*pssResult = SecStat;
	
	//
	//	If SSPI function fails 
	//
    if ( !NT_SUCCESS( SecStat ) )
    {
        RetStatus = SPM_ERROR;

		//
		//	If SSPI do not have user name/password for the secified package,
		//
        if ((SecStat == SEC_E_NO_CREDENTIALS) ||
            (g_fIsWhistler && (SecStat == SEC_E_LOGON_DENIED)))
        {
            //
            //  If we have prompted the user and still get back "No Credential"
            //  error, it means the user does not have valid credential; the 
            //	user hit <CANCEL> on the UI box. If we have supplied a valid 
			//	credential, but get back a "No Credential" error, then something
			//	has gone wrong; we definitely should return to caller with ERROR
            //
            if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) ||
				(fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
			{
                RetStatus = SPM_ERROR;	// return ERROR to caller
            }
            else if (bNonBlock)
            {
				//
				//	Blocking is not permitted, return WOULD_BLOCK to caller
				//
                RetStatus = SPM_STATUS_WOULD_BLOCK;
            }
            else
            {
                //	Blocking is permitted and we have not asked the SSPI to
                //  prompt the user for proper credential, we should call  
                //  the SSPI again with PROMPT_CREDS flag set.
                //
                fContextReq = fContextReq | ISC_REQ_PROMPT_FOR_CREDS;
                goto SspiRetry;
            }
        }
        SetLastError( SecStat );

        goto Cleanup;
    }

    RetStatus = SPM_STATUS_OK;

#if 0
    //
    // note: when support for processing final MUTUAL_AUTH blob is added,
    // will need to allow for non-existent output buffer.
    //

    if( OutSecBuff.cbBuffer == 0 )
    {
        *pcbBuffOut = 0;
        goto Cleanup;
    }
#endif

    //
    //  Only return the SSPI blob if a output buffer is specified
    //
    if (pFinalBuff)
    {
    	//
	    //	Initialize the final buffer to hold the package name followed by 
    	//	a space. And setup the pOutMsg pointer to points to the character 
    	//	following the space so that the final NEGOTIATE/RESPONSE can be 
    	//	copied into the pFinalBuff starting at the character pointed to 
    	//	by pOutMsg. 
    	//
        wsprintf (pFinalBuff, "%s ", pData->PkgList[pkgID]->pName);
        pOutMsg = pFinalBuff + lstrlen(pFinalBuff);

        if ( g_fUUEncodeData)
        {
            maxbufsize = *pcbBuffOut - 
                         lstrlen(pData->PkgList[pkgID]->pName) - 1;
        	//
        	//  uuencode it, but make sure that it fits in the given buffer
        	//
            retsize = HTUU_encode ((BYTE *) OutSecBuff.pvBuffer,
                                   OutSecBuff.cbBuffer,
                                   (CHAR *) pOutMsg, maxbufsize);
            if (retsize > 0)
                *pcbBuffOut = retsize + lstrlen(pData->PkgList[pkgID]->pName)+1;
            else
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
        else if ( *pcbBuffOut >= lstrlen(pData->PkgList[pkgID]->pName) + 
                                 OutSecBuff.cbBuffer + 1 )
        {
            CopyMemory( (CHAR *) pOutMsg, 
                        OutSecBuff.pvBuffer,
                        OutSecBuff.cbBuffer );
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 1 +
                          OutSecBuff.cbBuffer;
        }
        else
        {
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 
                          OutSecBuff.cbBuffer + 1;
            RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
    }

Cleanup:

    if( SlowOutBufPlain != NULL )
    {
        FREE_MEMORY( SlowOutBufPlain );
    }

    if( SlowDecodedBuf != NULL )
    {
        FREE_MEMORY( SlowDecodedBuf );
    }

    return (RetStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\splugin.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    splugin.cxx

Abstract:

    This file contains the implementation for Plug In Authentication

    The following functions are exported by this module:

    AuthOnRequest
    AuthOnResponse
    AuthCtxClose
    AuthInDialog
    AuthNotify
    AuthUnload

Author:

    Arthur Bierer (arthurbi) 25-Dec-1995

Revision History:

    Rajeev Dujari (rajeevd)  01-Oct-1996 overhauled

    Adriaan Canter (adriaanc) 01-03-1998 :
    AUTHCTX now a virtual base class, from which derived classes
    inherit to implement the different authentication protocols:

    BASIC_CTX  (Basic auth),
    PLUG_CTX   (NTLM/Negotiate, MSN, DPA)
    DIGEST_CTX (Digest auth, new)


--*/

#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"
#include <crypt.h>
//
// constants
//

#define WILDCARD 0x05 // don't use '*' since it can appear in an URL
#define INC_WAIT_INFO 10  // number of records to grow array
#define AssertHaveLock() INET_ASSERT(g_dwOwnerId == GetCurrentThreadId())


struct AUTH_WAIT_INFO
{
    PFN_AUTH_NOTIFY  pfnNotify;
    DWORD_PTR        dwContext;
    PWC *            pPWC;
};

//
//  globals
//

PRIVATE AUTH_WAIT_INFO *g_pWaitList = NULL; // array of notification records
PRIVATE DWORD g_cWaitList = 0;    // size of notification record array
PRIVATE DWORD g_cDlgThreads = 0;  // number of threads in dlg or waiting
PRIVATE BOOL  g_fNotifyInProgress = FALSE;    // Indicates if a notification is in progress.
PRIVATE const char szBasic[] = "basic";

// Global authentication providers list and state.
AUTHCTX::SPMState  AUTHCTX::g_eState;
AUTHCTX::SPMData  *AUTHCTX::g_pSPMList = NULL;


/*
Conceptually, we have a three layer structure for server auth.  The top level
is a list of hosts.  For each host, there's a list of realms.  For each realm,
there's a user/pass and a list of directories to preauthenticate.  Also for
each host, there's a list of directories without realm and a user/pass for each.

In actuality, there's a flat list of primary host/realm directories with a
single user/pass for each.  Additional directories, with or without realm,
are kept in an auxiliary list.
*/

PRIVATE PWC* g_pwcRealm = NULL;  // SLL for primary server/realm user/pass
PRIVATE PWC* g_pwcOther = NULL;  // SLL of additional dirs, with or w/o realm
PRIVATE PWC* g_pwcProxy = NULL;  // SLL of proxy  password cache entries


// Global auth crit sect.
CRITICAL_SECTION g_crstAuth;

#ifdef DBG
DWORD g_dwOwnerId = 0;
LONG g_nLockCount = 0;
#endif

extern DWORD GlobalEnableNegotiate;

typedef NTSTATUS
(WINAPI * PFN_RTL_ENCRYPT_MEMORY)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

typedef NTSTATUS
(WINAPI * PFN_RTL_DECRYPT_MEMORY)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

PFN_RTL_ENCRYPT_MEMORY g_pfnEncryptMemory = 0;
PFN_RTL_DECRYPT_MEMORY g_pfnDecryptMemory = 0;

BOOL InitCryptFuncs(void)
{
    if (g_pfnEncryptMemory && g_pfnDecryptMemory)
    {
        return TRUE;
    }
    
    HMODULE hAdvApi32 = LoadLibraryA("Advapi32.dll");
    if (hAdvApi32 == 0)
    {
        return FALSE;
    }

    g_pfnEncryptMemory = (PFN_RTL_ENCRYPT_MEMORY) GetProcAddress(hAdvApi32, "SystemFunction040");
    g_pfnDecryptMemory = (PFN_RTL_DECRYPT_MEMORY) GetProcAddress(hAdvApi32, "SystemFunction041");

    if (g_pfnEncryptMemory && g_pfnDecryptMemory)
    {
        return TRUE;
    }

    return FALSE;
}

//
// private prototypes
//



//-----------------------------------------------------------------------------
//
//  Utilities
//
//

PRIVATE VOID SspiFlush (LPSTR pszDll);
PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename);
PRIVATE LPSTR MakeTemplate (LPSTR docname);
void GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    LPSTR* ppszName, DWORD* pdwPort);
   

PRIVATE BOOL ReadRegKey(
    BYTE * pbRegValue,
    DWORD * pdwNumBytes,
    LPSTR  pszRegKey,
    LPSTR  pszRegValueName,
    DWORD  dwRegTypeExpected);



//-----------------------------------------------------------------------------
//
//
//      PWC functions
//
//          PWC_CREATE
//          PWC_FREE
//          SetUser
//          SetPass
//          FlushPwcList
//

PRIVATE PWC *PWC_Create // PWC constructor
(
    LPSTR lpszHost,     // Host Name to place in structure.
    DWORD nPort,        // destination port of proxy or server
    LPSTR lpszUrl,      // URL to template, and place in the structure.
    LPSTR lpszRealm,    // Realm string to add.
    AUTHCTX::SPMData * pSPM
)
{
    PWC* pwc = (PWC *) ALLOCATE_ZERO_MEMORY(sizeof(*pwc));
    if (!pwc)
        return NULL;

    INET_ASSERT (!pwc->pNext);
    INET_ASSERT (!pwc->nLockCount);
    pwc->lpszHost    = lpszHost?  NewString(lpszHost)   : NULL;
    pwc->nPort       = nPort;
    pwc->lpszUrl     = lpszUrl?   MakeTemplate(lpszUrl) : NULL;
    INET_ASSERT (!pwc->lpszUser);
    INET_ASSERT (!pwc->lpszPass);
    pwc->fPassEncrypted = FALSE;
    pwc->dwPassBlobSize = 0;
    INET_ASSERT (!pwc->fPreAuth);
    pwc->fPreAuth    = FALSE;
    pwc->lpszRealm   = lpszRealm? NewString(lpszRealm)  : NULL;
    pwc->lpszNonce    = NULL;
    pwc->lpszOpaque   = NULL;
    pwc->pSPM         = pSPM;


    if (  (!pwc->lpszHost  && lpszHost)
       || (!pwc->lpszUrl   && lpszUrl)
       || (!pwc->lpszRealm && lpszRealm)
       )
    {
        PWC_Free(pwc);
        return NULL;
    }

    return pwc;
}

PRIVATE VOID PWC_Free(PWC *pwc) // PWC destructor
{
    if ( pwc )
    {
        if (pwc->lpszHost)
            FREE_MEMORY(pwc->lpszHost);
        if (pwc->lpszUrl)
            FREE_MEMORY(pwc->lpszUrl);
        if ( pwc->lpszUser )
            FREE_MEMORY(pwc->lpszUser);
        if ( pwc->lpszPass )
        {
            SecureZeroMemory(pwc->lpszPass, (pwc->fPassEncrypted ? pwc->dwPassBlobSize : strlen(pwc->lpszPass)));
            FREE_MEMORY(pwc->lpszPass);
        }
        if ( pwc->lpszRealm )
            FREE_MEMORY(pwc->lpszRealm);
        if ( pwc->lpszNonce )
            FREE_MEMORY(pwc->lpszNonce);
        if ( pwc->lpszOpaque )
            FREE_MEMORY(pwc->lpszOpaque);
        FREE_MEMORY(pwc);
    }
}

PUBLIC DWORD PWC::SetUser (LPSTR lpszInput)
{
    AssertHaveLock();
    INET_ASSERT (lpszInput);
    if (lpszUser && !lstrcmp (lpszUser, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszUser)
        FREE_MEMORY (lpszUser);
    lpszUser = lpszTemp;
    return ERROR_SUCCESS;
}

PUBLIC DWORD PWC::SetPass (LPSTR lpszInput)
{
    BOOL fEncrypt = (GlobalPlatformWhistler != 0);  // encrypt password on XP and later

    AssertHaveLock();
    INET_ASSERT (lpszInput);
    
    if (!fEncrypt && lpszPass && !lstrcmp (lpszPass, lpszInput))
        return ERROR_SUCCESS; // didn't change

    DWORD dwLen = 0;
    DWORD dwStrLen = (strlen(lpszInput) + 1);
    if (fEncrypt)
    {
        dwLen = dwStrLen + (RTL_ENCRYPT_MEMORY_SIZE - dwStrLen % RTL_ENCRYPT_MEMORY_SIZE);
    }
    else
    {
        dwLen = dwStrLen;
    }

    LPSTR lpszTemp = (LPSTR) ALLOCATE_FIXED_MEMORY(dwLen + 1);

    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(lpszTemp, lpszInput, dwStrLen);

    if (fEncrypt && InitCryptFuncs())
    {
        NTSTATUS status = g_pfnEncryptMemory(lpszTemp, dwLen, 0);
        if (NT_SUCCESS(status))
        {
            fPassEncrypted = TRUE;
            dwPassBlobSize = dwLen;
        }
    }
    else
    {
        fPassEncrypted = FALSE;
        dwPassBlobSize = 0;
    }
    if (lpszPass)
        FREE_MEMORY (lpszPass);

    lpszPass = lpszTemp;
    return ERROR_SUCCESS;
}

LPSTR PWC::GetPass (void) 
{
    if (!fPassEncrypted)
    {
        return lpszPass ? NewString(lpszPass) : NULL;
    }

    if (InitCryptFuncs() == FALSE)
    {
        return NULL;
    }

    INET_ASSERT(dwPassBlobSize % 8 == 0);

    LPSTR lpszClearPass = (LPSTR)ALLOCATE_FIXED_MEMORY(dwPassBlobSize);
    if (lpszClearPass == NULL)
    {
        return NULL;
    }

    memcpy(lpszClearPass, lpszPass, dwPassBlobSize);

    g_pfnDecryptMemory(lpszClearPass, dwPassBlobSize, 0);

    return lpszClearPass;
}



/*++
Delete some entries from a singly linked list.
--*/
PRIVATE void FlushPwcList (PWC **ppList)
{
    AssertHaveLock();

    PWC *pwc = *ppList;
    while (pwc)
    {
        PWC *pwcNext = pwc->pNext;

        if (!pwc->nLockCount)
            PWC_Free (pwc);
        else
        {
            *ppList = pwc;
            ppList = &(pwc->pNext);
        }

        pwc = pwcNext;
    }
    *ppList = NULL;
}


//-----------------------------------------------------------------------------
//
//
//      Auth* functions
//
//          AuthOpen
//          AuthClose
//          AuthLock
//          AuthUnlock
//          AuthInDialog
//          AuthNotify
//          AuthFlush
//
//

BOOL bAuthInitialized = FALSE;

void AuthOpen (void)
{
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
    InitializeCriticalSection (&g_crstAuth);
    bAuthInitialized = TRUE;
}

void AuthClose (void)
{
    if (bAuthInitialized)
    {
        DeleteCriticalSection (&g_crstAuth);
        bAuthInitialized = FALSE;
    }
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
}

void AuthLock (void)
{
    INET_ASSERT(bAuthInitialized);

    EnterCriticalSection (&g_crstAuth);
    DEBUG_ONLY (if (!g_nLockCount++) g_dwOwnerId = GetCurrentThreadId();)
}

void AuthUnlock (void)
{
    INET_ASSERT(bAuthInitialized);
    INET_ASSERT (g_nLockCount > 0);
    DEBUG_ONLY (if (!--g_nLockCount) g_dwOwnerId = 0;)
    LeaveCriticalSection (&g_crstAuth);
}


//
// DIALOG SERIALIZATION
//   AuthInDialog
//   AuthNotify
//

/*++
Description: Checks if a authentication dialog is progress.  If so,
records info to notify waiting threads when the dialog is dismissed.

Return Value: TRUE if a dialog is already in progress, FALSE if not
--*/

PUBLIC BOOL AuthInDialog
    (IN AUTHCTX *pAuthCtx, INTERNET_AUTH_NOTIFY_DATA *pNotify, BOOL * pfMustLock)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Bool,
        "AuthInDialog",
        "ctx=%#x pNotify=%#x pfMustLock=%B",
        pAuthCtx,
        pNotify,
        *pfMustLock
        ));

    INET_ASSERT(!*pfMustLock);

    BOOL fRet = FALSE;

    // Serialize access to globals.
    AuthLock();

    // NOTE - This function can be called reentrantly from AuthNotify.

    // Increment dialog request count.
    g_cDlgThreads++;

    // Check if any dialogs are in progress
    // If only one request is outstanding, service it.
    if (g_cDlgThreads == 1)
        goto done;

    // Otherwise more than one request outstanding.



    // It is possible that AuthInDialog is being called reentrantly by
    // AuthNotify. In this case we do not enqueue this request but
    // service it immediately. We release the lock so that subsequent
    // requests may be serviced and flag that the lock must be re-
    // acquired after the dialog has been dismissed so that AuthNotify
    // is not re-entered and the lock state will be correct (acquired)
    // when control is returned to AuthNotify.
    if (g_fNotifyInProgress)
    {
        // Decrement count since this request
        // will not be enqueued.
        g_cDlgThreads--;

        // Lock must be reacquired after
        // dialog is dismissed.
        *pfMustLock = TRUE;

        // We're about to unlock and service
        // this request. Any other threads
        // calling AuthInDialog will not be
        // reentrant.
        g_fNotifyInProgress = FALSE;

        // Unlock once here and once before
        // exiting function - lock is released.
        AuthUnlock();

        INET_ASSERT(g_nLockCount == 1);

        goto done;
    }

    // This is not a re-entrant call. Enqueue the
    // request.

    // Calculate the next open slot in the array.
    DWORD iWaitList;
    iWaitList = g_cDlgThreads - 2;

    // Grow the array of necessary.

    // NOTE - if a dialog is displayed as a result of a reentrant
    // call by AuthNotify then additional notifications will be
    // placed at the tail. In the case of a fixed number of requests
    // the worst case is that the last notification in the
    // list caused reentrancy and the previous (n-1) notified
    // requests are retried and subsequently queued. The leads to
    // n^2 behavior (n + (n-1) + (n-2) + ...). In the case of
    // additional incoming requests a rare case (auth UI continually
    // invoked, some requests reentrant and g_cDlgThreads never reset
    // to 0) would be that the list grows without bound.
    if (iWaitList >= g_cWaitList)
    {
        HLOCAL hTemp;

        g_cWaitList += INC_WAIT_INFO;

        if (g_cWaitList == INC_WAIT_INFO)
        {
            hTemp = ALLOCATE_FIXED_MEMORY (g_cWaitList * sizeof(*g_pWaitList));
        }
        else
        {
            hTemp = REALLOCATE_MEMORY
                (g_pWaitList, g_cWaitList * sizeof(*g_pWaitList), LMEM_MOVEABLE);
        }
        if (!hTemp)
        {
            INET_ASSERT (!fRet);
            goto done;
        }

        g_pWaitList = (AUTH_WAIT_INFO *) hTemp;
     }

     // Insert the new info at the end of the array.
     g_pWaitList[iWaitList].pfnNotify = pNotify->pfnNotify;
     g_pWaitList[iWaitList].dwContext = pNotify->dwContext;
     g_pWaitList[iWaitList].pPWC      = pAuthCtx->_pPWC;

     pAuthCtx->_pPWC->nLockCount++;

     fRet = TRUE;

done:

    AuthUnlock();
    DEBUG_LEAVE(fRet);
    return fRet;
}

/*++
Description: Notifies all waiting threads that a dialog has been dismissed.
--*/

PUBLIC void AuthNotify (PWC *pwc, DWORD dwErr)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "AuthNotify",
        "pwc=%#x dwErr=%#x",
        pwc,
        dwErr
        ));

    // Serialize access to globals.
    AuthLock();

    if (g_pWaitList)
    {
        INET_ASSERT (g_cDlgThreads >= 2);

        // Loop through the array of notifications.
        AUTH_WAIT_INFO *pWaitItem;

        for (DWORD i = 0; i < g_cDlgThreads - 1; i++)
        {
            // NOTE - Because AuthInDlg can be called reentrantly
            // it is possible that g_pWaitList is reallocated. It is
            // important that pWaitItem is always indexed directly from
            // the global array pointer.
            pWaitItem = g_pWaitList + i;

            // If the thread was waiting for the same PWC, either resend or cancel.
            // Otherwise tell the client to retry InternetErrorDlg.
            INET_ASSERT ((dwErr == ERROR_CANCELLED)
                || (dwErr == ERROR_INTERNET_FORCE_RETRY));
            DWORD dwAction = (pWaitItem->pPWC == pwc)?
                dwErr : ERROR_INTERNET_RETRY_DIALOG;

            pWaitItem->pPWC->nLockCount--;
            DEBUG_ONLY (pWaitItem->pPWC = NULL);

            // Flag that a notification is in progress in case
            // it calls AuthNotify reentrantly. This must be
            // set each time since a reentrant call will clear
            // the flag.
            g_fNotifyInProgress = TRUE;

            (*pWaitItem->pfnNotify) (pWaitItem->dwContext, dwAction, NULL);

        }

        // Notification no longer in progress.
        g_fNotifyInProgress = FALSE;

        // Free the notification array.
        FREE_MEMORY (g_pWaitList);
        g_pWaitList = NULL;
        g_cWaitList = 0;
    }

    g_cDlgThreads = 0;

    AuthUnlock();

    DEBUG_LEAVE(0);
}

/*++
Flush any server and proxy password cache entries not in use.
--*/
PUBLIC void AuthFlush (void)
{
    // Serialize access to globals.
    AuthLock();

    FlushPwcList (&g_pwcRealm);
    FlushPwcList (&g_pwcOther);
    FlushPwcList (&g_pwcProxy);

    TCHAR  pszRegValue[1024];
    DWORD  dwBufLen=sizeof(pszRegValue);

    // Read SecurityProviders regkey.

    if (ReadRegKey((BYTE*) &pszRegValue,//Buffer to store value
                    &dwBufLen, // Length of above buffer
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders"), // Reg Key name
                    TEXT("SecurityProviders"), // Value name
                    REG_SZ) ) // Type expected
    {
        CharUpper(pszRegValue);

        static LPSTR rszDll[] =
            {"MSNSSPC.DLL", "MSNSSPS.DLL", "MSAPSSPC.DLL", "MSAPSSPS.DLL"};

        // Flush any msn/dpa credential cache.
        for (DWORD i=0; i<ARRAY_ELEMENTS(rszDll); i++)
        {
            if (StrStr (pszRegValue, rszDll[i]))
                SspiFlush (rszDll[i]);
        }
    }

    if (!g_cSspiContexts)
        AUTHCTX::UnloadAll();

    DIGEST_CTX::FlushCreds();

    AuthUnlock();
}


PUBLIC void AuthUnload (void)
/*++
Routine Description:
    Frees all Cached URLs, and unloads any loaded DLL authentication modeles.

--*/
{
    if (bAuthInitialized) {
        AuthFlush();
        AuthLock();
        AUTHCTX::UnloadAll();
        AuthUnlock();
    }
}


//-----------------------------------------------------------------------------
//
//
//      Utility Functions:
//
//          SspiFlush
//          TemplateMatch
//          MakeTemplate
//          GetProxyName
//          ReadRegKey
//          TrimQuotes
//          TrimWhiteSpace
//          GetDelimitedToken
//          GetKeyValuePair
//
//


typedef BOOL (WINAPI * SSPI_FLUSH) (VOID) ;

void SspiFlush (LPSTR pszDll)
{
    __try
    {
        HINSTANCE hinst = GetModuleHandle (pszDll);

        if (hinst)
        {
            SSPI_FLUSH pfnFlush = (SSPI_FLUSH)
                GetProcAddress (hinst, "CleanupCredentialCache");

            if (pfnFlush)
            {
                (*pfnFlush) ();
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT (FALSE);
    }
    ENDEXCEPT
}



PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename)

/*++

Routine Description:

    Attempts to match a template URL string with a URL ( FileName )

Arguments:

    lpszTemplate             - Template to match against.
    lpszFilename             - URL to match with the template

Return Value:

    BOOL
    Success - TRUE - match
    Failure - FALSE - no match

Comments:

    Note: This Legacy code from the SpyGlass IE 1.0 browser

--*/

{
    /* code for this routine cloned from HTAA_templateMatch() */

    CHAR *p = lpszTemplate;
    CHAR *q = lpszFilename;
    int m;

    if (!lpszTemplate || !lpszFilename)
        return 0;

    for (; *p && *q && *p == *q; p++, q++)  /* Find first mismatch */
        ;                                                                       /* do nothing else */

    if (!*p && !*q)
        return 1;                                                       /* Equally long equal strings */
    else if (WILDCARD == *p)
    {                                                                               /* Wildcard */
        p++;                                                            /* Skip wildcard character */
        m = strlen(q) - strlen(p);                      /* Amount to match to wildcard */
        if (m < 0)
            return 0;                                               /* No match, filename too short */
        else
        {                                                                       /* Skip the matched characters and compare */
        if (lstrcmp(p, q + m))
                return 0;                                       /* Tail mismatch */
            else
                return 1;                                       /* Tail match */
        }
    }                                                                               /* if wildcard */
    else
        return 0;                                                       /* Length or character mismatch */
}


PRIVATE LPSTR MakeTemplate (LPSTR docname)

/*++
Routine Description:
    Makes a Template String (from a URL) that can later be used to match a range of URLs.

Arguments:
    ppszTemplate             - pointer to pointer of where Template can be stored
    docname                  - URL to create a template with.

Return Value: BOOL
    Success - TRUE - created
    Failure - FALSE - error

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser
--*/

{
    CHAR *pszTemplate = NULL;
    unsigned long k;
    k = 0;

    if (docname)
    {
        CHAR *slash;
        CHAR *first_slash;

        //
        // Ignore everything after first reserved character.
        //

        BYTE chSave = 0;
        LPSTR lpszScan = docname;
        while (*lpszScan)
        {
            if (*lpszScan == '?' || *lpszScan == ';')
            {
                chSave = *lpszScan;
                *lpszScan = 0;
                break;
            }
            lpszScan++;
        }

        slash = strrchr(docname, '/');

        //
        // If there is a "//" and no other slashes,
        //  then make sure not to chop the hostname off
        //  the URL. ex: http://www.netscape.com
        //  should be //www.netscape.com* not //*
        //

        if (slash)
        {
            first_slash = strchr(docname, '/' );
            if ((first_slash+1) == slash)
                k = lstrlen(docname);
            else
                k = (unsigned long)(slash-docname)+1;
        }

        // Restore any reserved character (or rewrite terminating null)
        *lpszScan = chSave;
    }

    pszTemplate = (CHAR *) ALLOCATE_FIXED_MEMORY(k+2);
    if (!pszTemplate)
        return 0;

    memcpy(pszTemplate, docname, k);
    pszTemplate[k]= WILDCARD;
    pszTemplate[k+1]=0;

    DEBUG_PRINT(HTTPAUTH, INFO, ("MakeTemplate: made template [%s] from [%s]\n",
        pszTemplate, docname ));

    return pszTemplate;
}

//------------------------------------------------------------------------
void GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    LPSTR* ppszName, DWORD* pdwPort)
{
    DWORD cbProxy;
    INTERNET_PORT port;
    pRequest->GetProxyName(ppszName, &cbProxy, &port);
    *pdwPort = (DWORD) port;
}

//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//
//   Synopsis: This function reads a registry key.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(
    BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
    DWORD * pdwNumBytes, // Pointer to DWORD conataining
     // the number of bytes in the above buffer - will be
     // set to actual bytes stored.
    LPSTR  pszRegKey, // Reg Key to be opened
    LPSTR  pszRegValueName, // Reg Value to query
    DWORD  dwRegTypeExpected) // Expected type of Value
{
    HKEY   hRegKey;
    DWORD  dwRegType;
    LONG lResult;

     //read registry to find out name of the file
    if ( (lResult = REGOPENKEYEX(HKEY_LOCAL_MACHINE,
                                 pszRegKey, // address of subkey name
                                 0,          // reserved
                                 KEY_READ,   // samDesired
                                 &hRegKey
                                  // address of handle of open key
        )) != ERROR_SUCCESS )
    {
        goto cleanup;
    }


    if ( (lResult =RegQueryValueEx( hRegKey,
                                    pszRegValueName,
                                    0,           // reserved
                                    &dwRegType,// address of buffer
                                     // for value type
                                    pbRegValue,
                                    pdwNumBytes)) != ERROR_SUCCESS )
    {
        REGCLOSEKEY(hRegKey);
        goto cleanup;
    }

    REGCLOSEKEY(hRegKey);

    if ( dwRegType != dwRegTypeExpected )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    return FALSE;

}


/*-----------------------------------------------------------------------------
Inplace trim of one leading and one trailing quote.
-----------------------------------------------------------------------------*/
VOID TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

/*-----------------------------------------------------------------------------
Inplace trim of leading and trailing whitespace.
-----------------------------------------------------------------------------*/
VOID TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

/*-----------------------------------------------------------------------------
Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
-----------------------------------------------------------------------------*/
BOOL GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                       LPSTR* pszTok,   LPDWORD pcbTok,
                       CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;
    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (*pszBuf == pEnd)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    if (fRet)
    {
        *pcbBuf = (DWORD) (pEnd - *pszBuf);
        if (**pszBuf == cDelim)
        {
            *pcbTok = (DWORD)(*pszBuf - *pszTok);
            (*pszBuf)++;
        }
        else
            *pcbTok = (DWORD) (*pszBuf - *pszTok) + 1;
    }

    return fRet;
}


/*-----------------------------------------------------------------------------
Inplace retrieval of key and value from a buffer of form key = <">value<">
-----------------------------------------------------------------------------*/
BOOL GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                     LPSTR* pszK,   LPDWORD pcbK,
                     LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
//
//      Main authentication functions:
//
//          AddAuthorizationHeader
//          AuthOnRequest
//          ProcessResponseHeader
//          AuthOnRequest
//
//



/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PRIVATE void AddAuthorizationHeader
(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    AUTHCTX* pAuthCtx
)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "AddAuthorizationHeader",
        "request=%#x ctx=%#x",
        pRequest,
        pAuthCtx
        ));

    if (!pAuthCtx)
    {
        DEBUG_PRINT(HTTPAUTH, ERROR, ("ctx is NULL!\n"));
        DEBUG_LEAVE(0);
        return;
    }

    INET_ASSERT(pAuthCtx->_pSPMData);

    // AssertHaveLock();

    // Call the auth package.
//    CHAR szHeader[MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2];
    CHAR *szSlowHeader = NULL;
    LPSTR pBuf;
    DWORD cbBuf;
    DWORD dwPlugInError;

    INT PackageId;
    ULONG cbMaxToken;

    //
    // GetPkgMaxToken() will return 10000 if invalid pkg.
    //

    if( (pAuthCtx->_pSPMData) &&
        (pAuthCtx->_pSPMData->szScheme) &&
        ((PackageId = GetPkgId( pAuthCtx->_pSPMData->szScheme )) != -1)
        )
    {
        cbMaxToken = GetPkgMaxToken( PackageId );
    } else {
        cbMaxToken = MAX_AUTH_MSG_SIZE;
    }

    //
    // add space for base64 overhead (33%, but round up)
    //

    cbMaxToken += (cbMaxToken/2);

    szSlowHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(cbMaxToken);

    if( szSlowHeader == NULL )
    {
        // We're always using the slow alloc'ed header as a quick fix
        // to prevent stack overflows under low-mem conditions for clients
        // such as DAV redir, which starts with a tiny stack size.
        //
        // Just return without adding the header.
        return;
    }

    if (pAuthCtx->_fIsProxy)
    {
        memcpy (szSlowHeader, HTTP_PROXY_AUTHORIZATION_SZ, HTTP_PROXY_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_PROXY_AUTHORIZATION_LEN;

        // Don't reuse this keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }
    else
    {
        memcpy (szSlowHeader, HTTP_AUTHORIZATION_SZ, HTTP_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_AUTHORIZATION_LEN;

        // Don't reuse a keep-alive socket after a password cache flush.
        if (!pRequest->IsViaProxy())
            pRequest->SetAuthorized();

        // This item should be marked per user in the cache.
        pRequest->SetPerUserItem(TRUE);
    }

    *pBuf++ = ' ';
    cbBuf = cbMaxToken - HTTP_PROXY_AUTHORIZATION_LEN - 2;
    INET_ASSERT (HTTP_PROXY_AUTHORIZATION_LEN >= HTTP_AUTHORIZATION_LEN);


    dwPlugInError =
        pAuthCtx->PreAuthUser(pBuf, &cbBuf);

    //  If the plug in did not fail, add its header to the outgoing header list
    if (dwPlugInError == ERROR_SUCCESS && pAuthCtx->GetState() != AUTHCTX::STATE_ERROR)
    {
        // Append CR-LF.
        pBuf += cbBuf;
        *pBuf++ = '\r';
        *pBuf++ = '\n';
        *pBuf = 0;
        cbBuf = (DWORD) (pBuf - szSlowHeader);

        AuthLock();
        // Add or replace the (proxy-)authorization header.
        wHttpAddRequestHeaders (pRequest, szSlowHeader, cbBuf,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
        AuthUnlock();

    }

    if( szSlowHeader )
    {
        FREE_MEMORY( szSlowHeader );
    }

    DEBUG_LEAVE(0);
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnRequest (IN HINTERNET hRequestMapped)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "AuthOnRequest",
        "request=%#x",
        hRequestMapped
        ));

    DWORD dwError = ERROR_SUCCESS;
    LPSTR lpszUser, lpszPass = NULL;
    
    // Get username, password, url, and auth context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    LPSTR lpszUrl = pRequest->GetURL();

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    PWC *pwc;
    BOOL fCredsChanged = FALSE;
    DWORD dwAuthState = AUTHSTATE_NONE;
    
    // Serialize access to globals.
    // AuthLock();

    // PROXY AUTHENTICATION
    //
    // CERN proxies should remove proxy-authorization headers before forwarding
    // requests to servers.  Otherwise, don't add proxy authorization headers
    // that would be seen by servers on a direct connect or via SSL tunneling.

    // How the credentials (username + password) are retrieved from handles during
    // authentication
    //
    //             Connect      Request
    //  Server        4     <-     3
    //  Proxy         2     <-     1
    //

    if  (pRequest->IsRequestUsingProxy()
      && !pRequest->IsTalkingToSecureServerViaProxy())
    {
        if (pAuthCtx && pAuthCtx->_fIsProxy)
        {
            // We have a proxy authentication in progress.
            // If a user/pass set on handle, transfer to PWC.

            // First check for proxy credentials and fallback to server
            // for legacy wininet apps. This will invalidate the credentials
            // on the handle they were found for any subsequent calls to
            // GetUserAndPass.
            AuthLock();
            if (pRequest->GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass)
                || (!GlobalIsProcessExplorer && !GlobalIsProcessNtService && pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass)))
            {
                pAuthCtx->_pPWC->SetUser(lpszUser);
                pAuthCtx->_pPWC->SetPass(lpszPass);
            }
            AuthUnlock();

            // Add the authorization header.
            AddAuthorizationHeader (pRequest, pAuthCtx);
        }

        // NO AUTHENTICATION CONTEXT -> SEE IF A PWC EXISTS.
        else  // See if we have a cached proxy user/pass.
        {
            PWC *pPWC;

            LPSTR lpszProxy = NULL;
            DWORD nPort;
            GetProxyName (pRequest, &lpszProxy, &nPort);
            
            if (lpszProxy)
            {
                AuthLock();
                pPWC = AUTHCTX::SearchPwcList
                    (g_pwcProxy, lpszProxy, nPort, NULL, NULL, NULL);
                if (pPWC)
                {
                    pPWC->nLockCount++;    // add a reference before leaving the crisec
                }
                AuthUnlock();
                if (pPWC)
                {
                    // If proxy credentials have been set on the handle, set them
                    // in the password cache entry.
                    // BUGBUG - we don't fallback to server credentials on the handle -
                    // this would invalidate them for a subsequent server auth.
                    AuthLock();
                    if (pRequest->GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
                    {
                        // Check to see if handle credentials differ from pw cache.
                        // Flush authorized sockets since we don't want to pick these up.
                        LPSTR lpszPWCPass = pPWC->GetPass();
                        
                        if (lstrcmpi(lpszUser, pPWC->GetUser())
                            || (lpszPWCPass && lstrcmp(lpszPass, lpszPWCPass)))
                        {
                            PurgeKeepAlives(PKA_AUTH_FAILED);
                        }

                        if (lpszPWCPass)
                        {
                            SecureZeroMemory(lpszPWCPass, strlen(lpszPWCPass));
                            FREE_MEMORY(lpszPWCPass);
                        }

                        pPWC->SetUser(lpszUser);
                        pPWC->SetPass(lpszPass);
                    }
                    AuthUnlock();
                    // This should always create a ctx
                    pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_PROXY, pPWC);
                    INET_ASSERT(pAuthCtx);
                    if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC)
                        AddAuthorizationHeader (pRequest, pAuthCtx);
                    delete pAuthCtx;
                    pAuthCtx = NULL;
                }
                if (pPWC)
                {
                    AuthLock();
                    pPWC->nLockCount--;    // balance the ref count
                    AuthUnlock();
                }
            }
        }
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
        lpszPass = NULL;
    }

    // SERVER AUTHENTICATION
    //
    // Don't send server authorization when initiating SSL tunneling with proxy.
    pAuthCtx = pRequest->GetAuthCtx();

    LPSTR lpszHost = pRequest->GetServerName();
    DWORD nPort    = pRequest->GetHostPort();
    
    if (!pRequest->IsTunnel())
    {
        // See if we have a server authentication in progress
        if (pAuthCtx && !pAuthCtx->_fIsProxy)
        {
            AuthLock();
            // Server authentication in progress.

            // If a user/pass set on handle, transfer to PWC.
            // This will invalidate the credentials on the handle they
            // were found for any subsequent calls to GetUserAndPass.
            pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass);

            if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT)
            {
                PSYSTEMTIME pCredTimestamp = NULL;

                if (lpszUser == NULL && lpszPass == NULL)
                {
                    if (GetUserAndPass(&lpszUser, &lpszPass))
                    {
                        pCredTimestamp = GetCredTimeStamp();
                    }
                }
                else if (lpszUser && lpszPass)
                {
                    pCredTimestamp = pRequest->GetCredTimeStamp();
                }

                if (pCredTimestamp)
                {
                    ((PASSPORT_CTX*)pAuthCtx)->SetCredTimeStamp(pCredTimestamp);
                }
            }

            if (lpszUser && lpszPass)
            {
                pAuthCtx->_pPWC->SetUser(lpszUser);
                pAuthCtx->_pPWC->SetPass(lpszPass);
            }
            AuthUnlock();

            // Add the authorization header.
            AddAuthorizationHeader (pRequest, pAuthCtx);
        }
        else  // See if we have a cached server user/pass.
        {
            // NO AUTHENTICATION CONTEXT -> SEE IF A PWC EXISTS
            // First search the primary host/realm list.
            AuthLock();
            PWC *pPWC;
            pPWC = AUTHCTX::SearchPwcList
                (g_pwcRealm, lpszHost, nPort, lpszUrl, NULL, NULL);
            if (!pPWC)
            {
                // Then search the secondary directory and no-realm list.
                pPWC = AUTHCTX::SearchPwcList
                    (g_pwcOther, lpszHost, nPort, lpszUrl, NULL, NULL);
                if (pPWC && pPWC->lpszRealm)
                {
                    // There's a realm, so this entry is merely to indicate the
                    // directory qualifies for preauthentication...
                    INET_ASSERT (!pPWC->lpszUser && !pPWC->lpszPass);
                    INET_ASSERT (!pPWC->nLockCount && !pPWC->fPreAuth);

                    // but the user/pass should come from the primary entry...
                    pPWC = AUTHCTX::SearchPwcList
                        (g_pwcRealm, lpszHost, nPort, NULL, pPWC->lpszRealm, pPWC->pSPM);

                    // ...which should exist.  The only reason it wouldn't is
                    // a password cache flush, but that would also wipe out any
                    // secondary entries with realm, which are never locked.
                    INET_ASSERT (pPWC);
                }
            }
            if (pPWC)
            {
                pPWC->nLockCount++;    // add a reference before leaving the crisec
            }
            AuthUnlock();

            // No existing auth context. If we found a password cache
            // which allows pre-auth, go ahead and pre-authenticate.
            if (pPWC && pPWC->fPreAuth)
            {
                BOOL fPreauth = FALSE;
                AUTHCTX *pNewAuthCtx = NULL;

                // Basic pre-auth calls AddAuthorizationHeader with a NULL auth context.
                // For NTLM, we create a new auth context, set it in the handle and set handle
                // auth state to AUTHSTATE_NEGOTIATE. This will send out negotiate auth headers
                // on the  first request. NOTE - at this point we don't know if the handle will
                // pick up a pre-authenticated socket. If so, the auth header is still sent out :
                // In this case IIS will recognize that the header (which contain the username
                // in the negotiate header) is identical to that cached on the socket and will
                // not force re-authentication.

                // If server credentials have been set on the handle, set them
                // in the password cache entry.
                AuthLock();
                if (pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass))
                {
                    // Check to see if handle credentials differ from pw cache.
                    // Flush authorized sockets since we don't want to pick these up.
                    
                    LPSTR lpszPWCPass = pPWC->GetPass();

                    if (lstrcmpi(lpszUser, pPWC->GetUser())
                        || (lpszPWCPass && lstrcmp(lpszPass, lpszPWCPass)))
                    {
                        fCredsChanged = TRUE;
                        PurgeKeepAlives(PKA_AUTH_FAILED);
                    }

                    if (lpszPWCPass)
                    {
                        SecureZeroMemory(lpszPWCPass, strlen(lpszPWCPass));
                        FREE_MEMORY(lpszPWCPass);
                    }

                    pPWC->SetUser(lpszUser);
                    pPWC->SetPass(lpszPass);
                }
                AuthUnlock();

                // This should always create a ctx
                dwAuthState = pRequest->GetAuthState();
                pNewAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_SERVER, pPWC);
                INET_ASSERT(pNewAuthCtx);
                if (pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NTLM
                    || pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NEGOTIATE)
                {
                    // NTLM or Negotiate (in which case we don't really know the
                    // protocol yet) - create the auth context, set it in the handle
                    // and set state to AUTHSTATE_NEGOTIATE. Handle now has
                    // a valid auth context and is in the correct auth state
                    // for the remainder of the authorization sequence.

                    // It's possible that the pwc entry was created when no proxy
                    // was in use and the user set a proxy. Check that this is
                    // not the case.
                    if (!pRequest->IsMethodBody() 
                        || (pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NTLM
                            && pRequest->IsDisableNTLMPreauth())
                        || (pRequest->IsRequestUsingProxy()
                            && !pRequest->IsTalkingToSecureServerViaProxy()))
                    {
                        // NTLM preauth disabled or over proxy; no preauth.
                        delete pNewAuthCtx;
                        pNewAuthCtx = NULL;
                        //Winse#20066: In case of NTLM proxy auth, creating new auth ctxt and 
                        //deleting it will reset the Authstate. This will result in pwd dlg prompt.
                        //Set back the old authstate in case we are deleting the new auth ctxt.
                        if(pRequest->IsRequestUsingProxy()
                            && !pRequest->IsTalkingToSecureServerViaProxy())
                        {
                            pRequest->SetAuthState(dwAuthState);
                        }
                    }
                    else
                    {
                        // Set the auth context in the handle and
                        // add the auth header.
                        pRequest->SetAuthCtx(pNewAuthCtx);
                        pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
                        AddAuthorizationHeader (pRequest, pNewAuthCtx);
                        fPreauth = TRUE;
                    }
                }
                else
                {
                    // For Basic and Digest add the header but do not set the
                    // context in the handle since we will delete it next.
                    // In this case we record that we have pre-authenticated which
                    // is necessary state info if the server challenges with a 401
                    // and we are forced to re-authenticate.
                    if ((pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST && !fCredsChanged)
                        || (pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC))
                    {
                        AddAuthorizationHeader (pRequest, pNewAuthCtx);
                        pRequest->SetPWC(pNewAuthCtx->_pPWC);
                        fPreauth = TRUE;
                    }
                }

                if (fPreauth)
                {
                    // Bug # 57742 (Front Page)
                    // Retrieve the credentials to be used for preauthentication,
                    // set them on the handle and mark them invalid by performing
                    // a get. This ensures apps have access to the preauth creds
                    // and that they will not be used internally by wininet.
                    AuthLock();
                    if ((pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC) &&
                        pNewAuthCtx->_pPWC->lpszUser && pNewAuthCtx->_pPWC->lpszPass)
                    {
                        LPSTR pszUser, pszPass = NULL;

                        pRequest->SetUserOrPass(pNewAuthCtx->_pPWC->lpszUser, IS_USER, IS_SERVER);

                        pszPass = pNewAuthCtx->_pPWC->GetPass();

                        if (pszPass)
                        {
                            pRequest->SetUserOrPass(pszPass, IS_PASS, IS_SERVER);
                            SecureZeroMemory(pszPass, strlen(pszPass));
                            FREE_MEMORY(pszPass);
                            pszPass = NULL;
                        }

                        pRequest->GetUserAndPass(IS_SERVER, &pszUser, &pszPass);
                        if (pszPass)
                        {
                            SecureZeroMemory(pszPass, strlen(pszPass));
                            FREE_MEMORY(pszPass);
                        }
                    }
                    AuthUnlock();
                    
                    // Proceed to delete the context if basic or digest.
                    if (pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST
                        || pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC)
                    {
                        delete pNewAuthCtx;
                        pNewAuthCtx = NULL;
                    }
                }
                // For QFE, prevent the auth state from being nulled
                // via the CreateAuthCtx for DPA only.  It turns out
                // that DPA server connections through an NTLM authenticated
                // proxy can end up in a bad auth state that results in
                // unnecessary proxy auth dialogs during a 407->401->407
                // response sequence due to the keep-alive semantics here.
                //
                // At some point, this should be looked at more closely
                // because other scenarios are likely to be susceptible.
                if (pNewAuthCtx && pNewAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DPA)
                {
                    pRequest->SetAuthState(dwAuthState);
                }
            }
            
            if (pPWC)
            {
                AuthLock();
                pPWC->nLockCount--;    // balance the ref count
                AuthUnlock();
            }

        }
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
        lpszPass = NULL;
    }

    DEBUG_PRINT(
        HTTPAUTH,
        INFO,
            (
                "request %#x authstate set to %s using %s\n",
                pRequest,
                InternetMapAuthState(pRequest->GetAuthState()),
                InternetMapAuthScheme( (pRequest->GetAuthCtx() ? pRequest->GetAuthCtx()->GetSchemeType() : 0) )
            )
        );

    // AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
DWORD ProcessResponseHeaders
(
    HINTERNET hRequestMapped,
    BOOL fIsProxy
)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "ProcessResponseHeaders",
        "request=%#x isproxy=%B",
        hRequestMapped,
        fIsProxy
        ));

    // Serialize access to globals.
    // AuthLock();

    DWORD dwError;

    // Get context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest
        = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;
    AUTHCTX* pAuthCtx = pRequest->GetAuthCtx();

    if (pAuthCtx)
    {
        if ((dwError = pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy))
            != ERROR_SUCCESS)
        {
            // Delete the auth context and fail auth 
            // immediately if any other error than
            // scheme has been changed.
            delete pAuthCtx;
            pRequest->SetAuthCtx(NULL);
            if (dwError != ERROR_HTTP_HEADER_NOT_FOUND)
                goto quit;

            // Attempt to create a new auth context using
            // the challenge received from the server.
            // If this fails, we follow logic as commented
            // below.
            pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);        
            if (!pAuthCtx)
            {
                dwError = ERROR_SUCCESS;
                goto quit;
            }
        }
    }
    else
    {
        // CreateAuthCtx returns NULL if auth scheme not
        // supported (fall through from HttpFiltOnResponse
        // in sendreq.cxx) or if scheme is NTLM and the
        // socket is not keep-alive or via proxy.
        // In these cases it is necessary to check for a NULL
        // return value. The correct return code for these cases is
        // ERROR_SUCCESS, which will be returned by AuthOnResponse.
        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);
        if (!pAuthCtx)
        {
            dwError = ERROR_SUCCESS;
            goto quit;
        }
    }


    AuthLock();
    LPSTR lpszUser, lpszPass = NULL;

    // First check for proxy credentials and fallback to server
    // for legacy wininet apps. This will invalidate the credentials
    // on the handle they were found for any subsequent calls to
    // GetUserAndPass.

    // I believe we should be putting the credentials in the
    // password cache at this time. The scenario is that a client
    // sets credentials on a handle, after a successful authentication
    // the pwc will have null credentials. Pre-auth will then pull up
    // credentials for the default user!!!!!!!!!!!
    if ((!pRequest->GetUserAndPass(fIsProxy, &lpszUser, &lpszPass)) 
        && fIsProxy && !GlobalIsProcessExplorer && !GlobalIsProcessNtService)
    {
        pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass);
    }

    if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT)
    {
        PSYSTEMTIME pCredTimestamp = NULL;

        if (lpszUser == NULL && lpszPass == NULL)
        {
            if (GetUserAndPass(&lpszUser, &lpszPass))
            {
                pCredTimestamp = GetCredTimeStamp();
            }
        }
        else if (lpszUser && lpszPass)
        {
            pCredTimestamp = pRequest->GetCredTimeStamp();
        }
        
        if (pCredTimestamp)
        {
            ((PASSPORT_CTX*)pAuthCtx)->SetCredTimeStamp(pCredTimestamp);
        }
    }

    // If we retrieved credentials from the handle set
    // them in the pwc.
    if (lpszUser && lpszPass)
    {
       DEBUG_PRINT(
           HTTPAUTH,
           INFO,
           ("got user/pass from request handle: %s:%s\n", lpszUser, lpszPass)
           );

       if (pAuthCtx->_pPWC)
       {
           pAuthCtx->_pPWC->SetUser(lpszUser);
           pAuthCtx->_pPWC->SetPass(lpszPass);
       }
    }

    AuthUnlock();

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
        lpszPass = NULL;
    }

    // Post authenticate user.
    dwError = pAuthCtx->PostAuthUser();

    AuthLock();
    // Bug # 57742 (Front Page) - Set credentials used for any
    // authentication and invalidate them by performing a get.
    if ((pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC)
        && pAuthCtx->_pPWC->lpszUser && pAuthCtx->_pPWC->lpszPass)
    {
        LPSTR pszUser, pszPass = NULL;
        pRequest->SetUserOrPass(pAuthCtx->_pPWC->lpszUser, IS_USER, IS_SERVER);

        pszPass = pAuthCtx->_pPWC->GetPass();

        if (pszPass)
        {
            pRequest->SetUserOrPass(pszPass, IS_PASS, IS_SERVER);
            SecureZeroMemory(pszPass, strlen(pszPass));
            FREE_MEMORY(pszPass);
            pszPass = NULL;
        }

        pRequest->GetUserAndPass(IS_SERVER, &pszUser, &pszPass);
        if (pszPass)
        {
            SecureZeroMemory(pszPass, strlen(pszPass));
            FREE_MEMORY(pszPass);
        }
    }
    AuthUnlock();

    // Map all unexpected error codes to login failure.
    if (dwError != ERROR_INTERNET_FORCE_RETRY
        && dwError != ERROR_INTERNET_INCORRECT_PASSWORD
        && dwError != ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY)
    {
        dwError = ERROR_INTERNET_LOGIN_FAILURE;
    }

    pRequest->SetAuthCtx(pAuthCtx);

quit:
    // AuthUnlock();
    DEBUG_LEAVE(dwError);
    return dwError;
}

extern CHAR g_szPassportDAHost[];


BOOL IsSameDomain(LPCSTR pszTarget, LPCSTR pszResponse)
{
    LPCSTR pszTargetR = pszTarget + strlen(pszTarget);
    DWORD dwDotsSeen = 0;
    while (--pszTargetR > pszTarget)
    {
        if (*pszTargetR == '.')
        {
            if (++dwDotsSeen == 2)
            {
                break;
            }
        }
    }

    if (dwDotsSeen == 2)
    {
        ++pszTargetR;
        DWORD dwOffsetR = strlen(pszTargetR);
        if (strlen(pszResponse) < dwOffsetR)
        {
            return FALSE;
        }

        LPCSTR pszResponseR = pszResponse + strlen(pszResponse) - dwOffsetR;

        return !strcmp(pszTargetR, pszResponseR);
    }
    else
    {
        return FALSE;
    }
}

VOID CheckForTweenerLogout(HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    DWORD dwIndex = 0;
    DWORD dwError;

    do
    {
        LPSTR szData;
        DWORD cbData;
        dwError = pRequest->FastQueryResponseHeader(HTTP_QUERY_AUTHENTICATION_INFO,
                                                    (LPVOID*) &szData,
                                                    &cbData,
                                                    dwIndex);
        if (dwError == ERROR_SUCCESS)
        {
            BOOL fLogout = FALSE;
            CHAR TempChar = szData[cbData];
            szData[cbData] = '\0';
            if (strstr(szData, "Passport1.4") && strstr(szData, "logout"))
            {
                fLogout = TRUE;
            }
            szData[cbData] = TempChar;
            
            if (fLogout)
            {
                if (IsSameDomain(pRequest->GetServerName(), g_szPassportDAHost))
                {
                    PP_Logout ( NULL, 0 );
                }
                
                break;
            }
        }

        ++dwIndex;

    } while (dwError == ERROR_SUCCESS);
}

/*-----------------------------------------------------------------------------

Routine Description:

    Validates, and Caches Authentication Request headers if needed. If a URL matches a
    cached set of templates it is assumed to require specific authentication information.

Arguments:

    hRequest                - An open HTTP request handle
                              where headers will be added if needed.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    Need to handle mutiple authentication pages.

-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnResponse (HINTERNET hRequestMapped)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "AuthOnResponse",
        "request=%#x",
        hRequestMapped
        ));

    // Get URL and password cache entry from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    DWORD dwStatus = pRequest->GetStatusCode();

    DEBUG_PRINT(
        HTTPAUTH,
        INFO,
        ("ctx=%#x status=%d\n", pAuthCtx, dwStatus)
        );

    if (pAuthCtx)
    {
        if (pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_PROXY_AUTH_REQ)
        {
            // We are done with proxy authentication.

            if ( pAuthCtx->_pfnCredUIConfirmCredentials != NULL )
                (*(pAuthCtx->_pfnCredUIConfirmCredentials))(pRequest->GetServerName(), TRUE );
            
            if (pAuthCtx->_pPWC)
            {
                pAuthCtx->_pPWC->fPreAuth = TRUE;
            }

            delete pAuthCtx;
            pRequest->SetAuthCtx (NULL);
        }
        else if (!pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_DENIED)
        {
            if ((pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT) && dwStatus == HTTP_STATUS_REDIRECT)
            {
                // in the case of Passport Auth, 302 is still not done yet.
            }
            else
            {
                // We are done with server authentication.

                if ( pAuthCtx->_pfnCredUIConfirmCredentials != NULL )
                    (*(pAuthCtx->_pfnCredUIConfirmCredentials))(pRequest->GetServerName(), TRUE );
                
                if (pAuthCtx->_pPWC)
                {
                    pAuthCtx->_pPWC->fPreAuth = TRUE;
                }
                
                delete pAuthCtx;
                pRequest->SetAuthCtx (NULL);
            }
        }
    }

    // Remove any stale authorization headers in case wHttpSendRequest
    // loops, for example, to handle a redirect.  To ignore trailing colon,
    // subtract 1 from header lengths passed to ReplaceRequestHeader.
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_AUTHORIZATION,
                    "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_PROXY_AUTHORIZATION,
            "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);

    DWORD error;

    DWORD dwZone, dwPolicy;

//
// note: Negotiate MUTUAL_AUTH can return dwStatus = 200 with a final
// WWW-Authenticate blob to process.  logic below could be adjusted
// to ProcessResponseHeaders() in this situation, which allows MUTUAL_AUTH
// to be enforced.
//

    switch (dwStatus)
    {
        case HTTP_STATUS_PROXY_AUTH_REQ: // 407
            error = ProcessResponseHeaders(pRequest, IS_PROXY);
            break;

        case HTTP_STATUS_REDIRECT: // 302
            {
                INTERNET_CONNECT_HANDLE_OBJECT* pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent();
                INTERNET_HANDLE_OBJECT * pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

                if (GlobalDisablePassport || pInternet->TweenerDisabled())
                {
                    // biaow-todo: no passport support for down-levels yet

                    pRequest->SetAuthState(AUTHSTATE_NONE);
                    error = ERROR_SUCCESS;

                    break;
                }

                // otherwise, process the header to see whether this is a 302 passport1.4 challenge
            }
        case HTTP_STATUS_DENIED: // 401

            if (pRequest->GetCredPolicy() == URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY)
                error = ERROR_SUCCESS;
            else
                error = ProcessResponseHeaders(pRequest, IS_SERVER);
            break;

        default:
            pRequest->SetAuthState(AUTHSTATE_NONE);
            error = ERROR_SUCCESS;
    }

    CheckForTweenerLogout(pRequest);

    DEBUG_LEAVE(error);
    return error;
}




//-----------------------------------------------------------------------------
//
//
//      AUTHCTX Base class definitions
//
//
//
//      static funcs:
//          Enumerate
//          UnloadAll
//          CreateAuthCtx
//          CreateAuthCtx (using pwc*)
//          GetSPMListState
//          SearchPwcList
//          FindOrCreatePWC
//          GetAuthHeaderData
//
//      base funcs:
//          FindHdrIdxFromScheme
//          GetScheme
//          GetSchemeType - returns enum
//          GetFlags      - returns SPM flags
//          GetState      - returns state of SPM provider
//
//
//      virtual overrides: defined in basic.cxx, plug.cxx and digest.cxx
//          UpdateFromHeaders
//          PreAuthUser
//          PostAuthUser
//
//
//


/*---------------------------------------------------------------------------
AUTHCTX::SPMData constructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::SPMData(LPSTR _szScheme, DWORD _dwFlags)
{
    if (_szScheme)
    {
        szScheme = NewString(_szScheme);
        cbScheme = strlen(_szScheme);
    }
    else
    {
        szScheme = NULL;
        cbScheme = 0;
    }

    if (szScheme)
    {
        if (!lstrcmpi(szScheme, "Basic"))
            eScheme = SCHEME_BASIC;
        else if (!lstrcmpi(szScheme, "NTLM"))
            eScheme = SCHEME_NTLM;
        else if (!lstrcmpi(szScheme, "Digest"))
            eScheme = SCHEME_DIGEST;
        else if (!lstrcmpi(szScheme, "MSN"))
            eScheme = SCHEME_MSN;
        else if (!lstrcmpi(szScheme, "DPA"))
            eScheme = SCHEME_DPA;
        else if (!lstrcmpi(szScheme, "Negotiate"))
            eScheme = SCHEME_NEGOTIATE;
        else if (!lstrcmpi(szScheme, "Passport1.4"))
            eScheme = SCHEME_PASSPORT;
        else
            eScheme = SCHEME_UNKNOWN;

        dwFlags    = _dwFlags;
        eState     = STATE_NOTLOADED;
    }
    else
    {
        dwFlags    = 0;
        eState     = STATE_ERROR;
    }
}

/*---------------------------------------------------------------------------
AUTHCTX::SPMData destructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::~SPMData()
{ delete szScheme; }


/*---------------------------------------------------------------------------
AUTHCTX constructor
---------------------------------------------------------------------------*/
AUTHCTX::AUTHCTX(SPMData *pData, PWC *pPWC)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Pointer,
        "AUTHCTX::AUTHCTX",
        "pData=%#x pPWC=%#x (scheme=%s)",
        pData,
        pPWC,
        pData->szScheme
        ));

    _pSPMData = pData;
    _pPWC = pPWC;
    _pRequest = NULL;
    _fIsProxy = FALSE;
    _pvContext = NULL;
    if (_pPWC)
        _pPWC->nLockCount++;
    _eSubScheme = SCHEME_UNKNOWN;
    _dwSubFlags = 0;


    // Load the CredUI DLL here and find the functions we need:
    _pfnCredUIPromptForCredentials = NULL;
    _pfnCredUIConfirmCredentials = NULL;
    _pfnCredUIPromptForCredentialsW = NULL;

    _hCredUI = NULL; 
    _pszFQDN = NULL;

    DEBUG_LEAVE(this);
}

BOOL AUTHCTX::InitCredUI(void)
{
    if (_hCredUI)
    {
        return TRUE;
    }

    _hCredUI = LoadLibrary("credui.dll");

    if (_hCredUI == NULL)
    {
        return FALSE;
    }
    
    _pfnCredUIPromptForCredentials = (PFN_CREDUI_PROMPTFORCREDENTIALS)
        GetProcAddress(_hCredUI, "CredUIPromptForCredentialsA");

    if (_pfnCredUIPromptForCredentials == NULL)
    {
        FreeLibrary(_hCredUI);
        _hCredUI = NULL;
        goto exit;
    }

    _pfnCredUIPromptForCredentialsW = (PFN_CREDUI_PROMPTFORCREDENTIALS_W)
        GetProcAddress(_hCredUI, "CredUIPromptForCredentialsW");
    if (_pfnCredUIPromptForCredentialsW == NULL)
    {
        FreeLibrary(_hCredUI);
        _hCredUI = NULL;
        goto exit;
    }

    _pfnCredUIConfirmCredentials = NULL;

#if 0    
    _pfnCredUIConfirmCredentials = (PFN_CREDUI_CONFIRMCREDENTIALS)
        GetProcAddress(_hCredUI, "CredUIConfirmCredentialsA");
    if (_pfnCredUIConfirmCredentials == NULL)
    {
        FreeLibrary(_hCredUI);
        _hCredUI = NULL;
        goto exit;
    }
#endif

    return TRUE;

exit:

    if ( _hCredUI == NULL )
    {
        _pfnCredUIPromptForCredentials = NULL;
        _pfnCredUIConfirmCredentials = NULL;
        _pfnCredUIPromptForCredentialsW = NULL;
    }

    return FALSE;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
AUTHCTX::~AUTHCTX()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        None,
        "AUTHCTX::~AUTHCTX",
        "this=%#x",
        this
        ));

    AuthLock();
    if (_pPWC)
        _pPWC->nLockCount--;
    AuthUnlock();

    if ( _hCredUI )
    {
        FreeLibrary(_hCredUI);
        _hCredUI = NULL;
    }

    _pfnCredUIPromptForCredentials = NULL;
    _pfnCredUIConfirmCredentials = NULL;
    _pfnCredUIPromptForCredentialsW = NULL;

    if (_pszFQDN)
    {
        FREE_MEMORY(_pszFQDN);
        _pszFQDN = NULL;
    }


    DEBUG_LEAVE(0);
}


// ------------------------  Static Functions ---------------------------------


/*---------------------------------------------------------------------------
    Enumerate
---------------------------------------------------------------------------*/
VOID AUTHCTX::Enumerate()
{
    struct SchemeFlagsPair
    {
        LPSTR pszScheme;
        DWORD Flags;
    };
    
    SchemeFlagsPair SchemeFlags[] = 
    {
        {"NTLM", PLUGIN_AUTH_FLAGS_NO_REALM},
        {"Basic", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED},
        {"Passport1.4", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED},
        {"Digest", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI},
#ifndef _WIN64
        {"DPA", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI | PLUGIN_AUTH_FLAGS_NO_REALM},
#endif        
        {"Negotiate", PLUGIN_AUTH_FLAGS_NO_REALM}
    };

    SPMData   *pNew;
    g_pSPMList = NULL;
    g_eState = STATE_ERROR;

    AssertHaveLock();

    for (DWORD dwIndex = 0; dwIndex < sizeof(SchemeFlags) / sizeof(SchemeFlagsPair); dwIndex++)
    {
        if ((GlobalPlatformType == PLATFORM_TYPE_WIN95 || !GlobalPlatformVersion5) //  // we don't support Negotiate on NT4 or Win9x
            && !stricmp(SchemeFlags[dwIndex].pszScheme, "Negotiate"))
        {
            continue;
        }

        pNew = (AUTHCTX::SPMData*) new SPMData(SchemeFlags[dwIndex].pszScheme, SchemeFlags[dwIndex].Flags);
        if (!pNew)
            return;

        // Add to head of list.
        if (pNew->eState != STATE_ERROR)
        {
            pNew->pNext = g_pSPMList;
            g_pSPMList = pNew;
        }
    }

    // The list is now in the correct state.
    g_eState = STATE_LOADED;
}


VOID AUTHCTX::UnloadAll()
{
    // BUGBUG - AuthFlush is called when the last browser session
    // is closed. First the global pwc lists are destructed, and
    // then this func (UnloadAll) is called. However, the global
    // pwc lists are not necessarily flushed (they may have out-
    // standing ref counts) and may persist across browser sessions.
    // when we destruct the SPM list in this func, SPMs reference
    // by any surviving pwc entries are bogus and can be used
    // for subsequent authentication, resulting in a fault.
    //
    // The temporary hack here is to not destruct the SPM
    // list if any pwc list is not destructed. We leak the
    // SPM list on process detach but don't fault. Put the
    // SPM destruct code in DllProcessDetach.
    if (g_pwcRealm || g_pwcOther || g_pwcProxy)
        return;

    SPMData *pData = g_pSPMList;
    while (pData)
    {
        SPMData *pNext = pData->pNext;
        delete pData;
        pData = pNext;
    }

    SSPI_Unload();
    g_eState = STATE_NOTLOADED;
    g_pSPMList = NULL;
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX* from headers - initially the authentication context
    is created without a PWC entry. The PWC entry will be found or created
    and possibly updated in UpdateFromHeaders.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT * pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Pointer,
        "AUTHCTX::CreateAuthCtx",
        "request=%#x isproxy=%B",
        pRequest,
        fIsProxy
        ));

    LPSTR szScheme;
    DWORD cbScheme, dwError, dwAuthIdx;
    AUTHCTX *pAuthCtx = NULL;

    dwAuthIdx = 0;
    szScheme = NULL;


    // Get scheme. This is assumed to be the first
    // non-ws token in the auth header info.
    do
    {
        // It is necessary to hold on to the auth index
        // in this loop because we could have gone through
        // more than one scheme.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
            &szScheme, &cbScheme, ALLOCATE_BUFFER | GET_SCHEME, dwAuthIdx);

        if (dwError != ERROR_SUCCESS)
            goto quit;

        // This will create the appropriate authentication context
        // with a NULL password cache. The password cache will be
        // created in the call to UpdateFromHeaders.
        pAuthCtx = CreateAuthCtx(pRequest, fIsProxy, szScheme);

        // If creation of an auth context is successful, update
        // the context from any header info.
        if (pAuthCtx)
        {
            if (pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy) != ERROR_SUCCESS)
            {
                delete pAuthCtx;
                pAuthCtx = NULL;
            }
        }
        dwAuthIdx++;

        delete szScheme;
        szScheme = NULL;

    } while (pAuthCtx == NULL);

quit:

    if (szScheme)
        delete szScheme;

    DEBUG_LEAVE(pAuthCtx);
    return pAuthCtx;
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX without a PWC from scheme
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL fIsProxy, LPSTR szScheme)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Pointer,
        "AUTHCTX::CreateAuthCtx",
        "request=%#x isproxy=%B scheme=%s",
        pRequest,
        fIsProxy,
        szScheme
        ));

    AuthLock();

    AUTHCTX *pNewAuthCtx = NULL;

    // we don't want to create a Passport1.4 context on 401 response (from DA)
    if (!lstrcmpi("Passport1.4", szScheme))
    {
        if (pRequest->GetStatusCode() == HTTP_STATUS_DENIED)
        {
            goto quit;
        }
    }
    else
    {
        // we accept only Passport1.4 in the 302 context.
        if (pRequest->GetStatusCode() == HTTP_STATUS_REDIRECT)
        {
            goto quit;
        }
    }

    if (!lstrcmpi("Negotiate", szScheme))
    {
        if (fIsProxy)
        {
            // categorically disable negotiate auth for proxies
            goto quit;
        }

        if (pRequest->GetAuthFlag() != AUTH_FLAG_ENABLE_NEGOTIATE)
        {
            if (pRequest->GetAuthFlag() == AUTH_FLAG_DISABLE_NEGOTIATE)
            {
                // App called InternetSetOption() to disable Negotiate
                goto quit;
            }
            else if (pRequest->GetAuthFlag() == 0x00000000)
            {
                // either InternetSetOption() is not called, or 
                // an app calls it with AUTH_FLAG_RESET. We will
                // check the registry to decide.

                if (!GlobalEnableNegotiate)
                {
                    // If "Negotiate" is proposed but it is not enabled through
                    // Advanced Options setting, we will not accept it.
                    goto quit;
                }    
            }
            else
            {
                // an app passes some junk value in, sorry, no Negotiate in this case
                goto quit;
            }
        }

        // either 1) app called InternetSetOption() to enable Negotiate, or
        //        2) registry allows the use of Negotiate
    }

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    SPMData *pSPM;
    pSPM = g_pSPMList;

    // Find SPMData to create from scheme.
    while (pSPM)
    {
        if (!lstrcmpi(pSPM->szScheme, szScheme))
            break;

        pSPM = pSPM->pNext;
    }

    if (!pSPM)
    {
        // No matching auth scheme found.
        // Not critical, just no auth.
        goto quit;
    }

    // Create an auth context without pwc
    switch(pSPM->eScheme)
    {
        // Create BASIC_CTX with NULL PWC.
        case SCHEME_BASIC:
            pNewAuthCtx = new BASIC_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        // Create DIGEST_CTX with NULL PWC.
        case SCHEME_DIGEST:
            pNewAuthCtx = new DIGEST_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        case SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pSPM, NULL);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX with NULL PWC.
        case SCHEME_NTLM:
        case SCHEME_MSN:
        case SCHEME_DPA:
        case SCHEME_NEGOTIATE:
        case SCHEME_UNKNOWN:

        default:
            pNewAuthCtx = new PLUG_CTX(pRequest, fIsProxy, pSPM, NULL);

    }


quit:
    AuthUnlock();
    DEBUG_LEAVE(pNewAuthCtx);
    return pNewAuthCtx;
}


/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX from a PWC.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                    BOOL fIsProxy, PWC* pPWC)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Pointer,
        "AUTHCTX::CreateAuthCtx",
        "request=%#x isproxy=%B pPWC=%#x",
        pRequest,
        fIsProxy,
        pPWC
        ));
    AuthLock();

    AUTHCTX *pNewAuthCtx = NULL;

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    // Handle tests (via proxy, is keep-alive)
    // will be done in UpdateFromHeaders. Here
    // we just construct the AUTHCTX.
    switch(pPWC->pSPM->eScheme)
    {
        // Create BASIC_CTX.
        case SCHEME_BASIC:

            pNewAuthCtx = new BASIC_CTX(pRequest, fIsProxy, pPWC->pSPM, pPWC);
            break;

        // Create DIGEST_CTX.
        case SCHEME_DIGEST:
            pNewAuthCtx = new DIGEST_CTX(pRequest, fIsProxy, pPWC->pSPM, pPWC);
            break;


        // Create PLUG_CTX.
        case SCHEME_NTLM:
        case SCHEME_MSN:
        case SCHEME_DPA:
        case SCHEME_NEGOTIATE:
        case SCHEME_UNKNOWN:

        default:
            pNewAuthCtx = new PLUG_CTX(pRequest, fIsProxy, pPWC->pSPM, pPWC);

    }


quit:
    AuthUnlock();
    DEBUG_LEAVE(pNewAuthCtx);
    return pNewAuthCtx;
}

AUTHCTX::SPMState AUTHCTX::GetSPMListState()
    { return g_eState; }


/*-----------------------------------------------------------------------------
    SearchPwcList
-----------------------------------------------------------------------------*/
PWC* AUTHCTX::SearchPwcList
    (PWC* pwc, LPSTR lpszHost, DWORD nPort,
    LPSTR lpszUri, LPSTR lpszRealm, SPMData *pSPM)
/*++

Routine Description:
    Scans the Linked List Cache for URLs, Realms, and Servers.  Also allows
    filter fields, to narrow searches.

Arguments:
    pwc                   - Pointer to first item to search from.
    lpszHost              - Host, or Server name to search on.
    nPort                - Corresponding port to server or proxy
    lpszUri               - URL to search on.
    lpszRealm             - Security Realm to search on
    lpszScheme            - Authentication scheme to search on.
Return Value:

    PWC *
    Success - Pointer to found item.

    Failure - NULL pointer.

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser

    The PWC lists are searched on every request.  Could optimize by keeping
    a hash value of the server/proxy name.

    If an exact match isn't found on a 401 response, the list is walked again
    to search for a realm match.  Could add a parameter to do both at once.
--*/
{
    AssertHaveLock();

    while (pwc)
    {
        if (   (!pSPM || pSPM == pwc->pSPM)
            && (!lpszHost  || !lstrcmpi(pwc->lpszHost,lpszHost))
            && (              (nPort == pwc->nPort))
            && (!lpszRealm || !lstrcmpi(pwc->lpszRealm,lpszRealm))
            && (!lpszUri   || TemplateMatch (pwc->lpszUrl, lpszUri))
           )
        {

            DEBUG_PRINT(HTTPAUTH, INFO, ("Lookup: Found template match [%q]\n",
                pwc->lpszUser));
            return pwc;
        }
        else
        {
            pwc = pwc->pNext;
        }
    }

    return NULL;
}



/*-----------------------------------------------------------------------------
    FindOrCreatePWC
-----------------------------------------------------------------------------*/
PWC* AUTHCTX::FindOrCreatePWC(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL     fIsProxy,
    SPMData *pSPM,
    LPSTR    lpszRealm
)
{
    AssertHaveLock();

    // Find or create a PWC.
    PWC *pwc;
    pwc = NULL;

    if (!pSPM)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // Get URL from request handle.
    LPSTR lpszUrl;
    lpszUrl = pRequest->GetURL();

    // Get host from request handle.
    LPSTR lpszHost;
    DWORD nPort;
    
    if (fIsProxy)
        GetProxyName (pRequest, &lpszHost, &nPort);
    else
    {
        lpszHost = pRequest->GetServerName();
        nPort = pRequest->GetHostPort();
    }

    // For NTLM, use the hostname analagously to basic realm.
    if (pSPM->eScheme == SCHEME_NTLM || pSPM->eScheme == SCHEME_NEGOTIATE)
    {
        INET_ASSERT (!lpszRealm);
        lpszRealm = lpszHost;
    }


    if (fIsProxy)
    {
        //
        // PROXY AUTHENTICATION
        //

        if (lpszHost)
        {
            // See if we have a exact match.
            pwc = SearchPwcList
                (g_pwcProxy, lpszHost, nPort, NULL, lpszRealm, pSPM);
            if (!pwc)
            {
                // If not, create a new one.
                pwc = PWC_Create (lpszHost, nPort, NULL, lpszRealm, pSPM);
                if (!pwc)
                    goto quit;

                // Insert at front of list.
                pwc->pNext = g_pwcProxy;
                g_pwcProxy = pwc;
            }
        }
    }
    else // if (!fIsProxy)
    {
        //
        // SERVER AUTHENTICATION
        //

        if (!lpszRealm)
        {
            // See if we have an exact match.
            pwc = SearchPwcList
                (g_pwcOther, lpszHost, nPort, lpszUrl, NULL, pSPM);
            if (!pwc)
            {
                // If not, create a new one.
                pwc = PWC_Create (lpszHost, nPort, lpszUrl, NULL, pSPM);
                if (!pwc)
                    goto quit;

                // Insert at front of list.
                pwc->pNext = g_pwcOther;
                g_pwcOther = pwc;
            }
        }
        else // if (lpszRealm)
        {
            // First, search the primary host/realm list.
            // We will check whether the URL matches later.
            pwc = SearchPwcList
                (g_pwcRealm, lpszHost, nPort, NULL, lpszRealm, pSPM);
            if (!pwc)
            {
                // If not, create one.
                pwc = PWC_Create (lpszHost, nPort, lpszUrl, lpszRealm, pSPM);
                if (!pwc)
                    goto quit;

                // Insert at front of list.
                pwc->pNext = g_pwcRealm;
                g_pwcRealm = pwc;
            }
            else // if (pwc)
            {
                // Check if the URL matches.
                if (!TemplateMatch(pwc->lpszUrl, lpszUrl))
                {
                    // Create another pwc entry
                    PWC* pwcDir = PWC_Create
                        (lpszHost, nPort, lpszUrl, lpszRealm, pSPM);
                    if (!pwcDir)
                        goto quit;

                    // Insert into secondary list.
                    pwcDir->pNext = g_pwcOther;
                    g_pwcOther = pwcDir;
                }
            }
        }

        INET_ASSERT (pwc);
    }
quit:
    return pwc;
}

/*-----------------------------------------------------------------------------
    GetAuthHeaderData
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::GetAuthHeaderData(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL      fIsProxy,
    LPSTR     szItem,
    LPSTR    *pszData,
    LPDWORD   pcbData,
    DWORD     dwFlags,
    DWORD     dwIndex)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "AUTHCTX::GetAuthHeaderData",
        "request=%#x isproxy=%B szItem=%.8s ppszData=%#x pcbData=%#x dwFlags=%x dwIndex=%d",
        pRequest,
        fIsProxy,
        szItem,
        pszData,
        pcbData,
        dwFlags,
        dwIndex
        ));

    LPSTR szData;
    DWORD cbData, cbItem, dwError = ERROR_SUCCESS;;
    CHAR *szTok, *szKey, *szValue;
    DWORD cbTok, cbKey, cbValue;

    szTok = szKey = szValue = NULL;
    cbTok = cbKey = cbValue = NULL;

    cbItem = szItem ? strlen(szItem) : 0;

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    // NULL item passed in means get up to the first \r\n, or
    // possibly only the scheme is desired depending on dwFlags.
    if (!cbItem)
    {
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szData,
            &cbData,
            dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Only the scheme is desired.
        if (dwFlags & GET_SCHEME)
        {
            CHAR* ptr;
            ptr = szValue = szData;
            cbValue = 0;
            while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
            {
                ptr++;
                cbValue++;
            }
        }
        else
        {
            // The entire header is desired.
            szValue = szData;
            cbValue = cbData;
        }

    }
    else
    {
        // An item was passed in - attempt to parse this
        // from the headers and return the corresponding
        // value.
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
                  (LPVOID*) &szData,
                  &cbData,
                  dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Successfully retrieved header. Parse for the desired item.

        // Point past scheme
        while (!(*szData == ' ' || *szData == '\t' || *szData == '\r' || *szData == '\n'))
        {
            szData++;
            cbData--;
        }

        // Attempt to parse an item of the format 'key = <">value<">'
        // from a comma delmited list of items.
        dwError = ERROR_HTTP_HEADER_NOT_FOUND;
        while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
        {
            if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
            {
                if ((cbItem == cbKey) && !strnicmp(szKey, szItem, cbItem))
                {
                    TrimQuotes(&szValue, &cbValue);
                    dwError = ERROR_SUCCESS;
                    break;
                }
            }
        }

    }

    if (dwError == ERROR_SUCCESS)
    {
        // Allocate buffer containing data
        // or return reference.
        if (dwFlags & ALLOCATE_BUFFER)
        {
            *pszData = new CHAR[cbValue+1];
            if (!*pszData)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(*pszData, szValue, cbValue);
            (*pszData)[cbValue] = '\0';
            *pcbData = cbValue;
        }
        else
        {
            *pszData = szValue;
            *pcbData = cbValue;
        }
    }

quit:

    if (dwError != ERROR_SUCCESS)
    {
        INET_ASSERT(dwIndex || dwError == ERROR_HTTP_HEADER_NOT_FOUND);
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


// ------------------------  Base class funcs---------------------------------




/*-----------------------------------------------------------------------------
FindHdrIdxFromScheme
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::FindHdrIdxFromScheme(LPDWORD pdwIndex)
{
    LPSTR szHeader;
    DWORD cbScheme, cbHeader, dwQuery, dwError;

    dwQuery = _fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    *pdwIndex = 0;

    while ((dwError = _pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szHeader,
            &cbHeader,
            *pdwIndex)) == ERROR_SUCCESS)
    {
        DWORD cb = 0;
        CHAR *ptr = szHeader;
        while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
        {
            ptr++;
            cb++;
        }

        if ((_pSPMData->cbScheme == cb)
            && (!strnicmp(_pSPMData->szScheme, szHeader, cb)))
        {
            break;
        }
        (*pdwIndex)++;
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
    Get funcs.
-----------------------------------------------------------------------------*/
LPSTR AUTHCTX::GetScheme()
    { return _pSPMData->szScheme; }

AUTHCTX::SPMScheme AUTHCTX::GetSchemeType()
{
    if (_pSPMData->eScheme == SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == SCHEME_NTLM || _eSubScheme == SCHEME_KERBEROS)
        {
            return _eSubScheme;
        }
    }
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetFlags()
{
    if (_pSPMData->eScheme == SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == SCHEME_NTLM || _eSubScheme == SCHEME_KERBEROS)
        {
            return _dwSubFlags;
        }
    }
    return _pSPMData->dwFlags;
}

AUTHCTX::SPMState AUTHCTX::GetState()
    { return _pSPMData->eState; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\urlzone.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    urlzone.cxx

Abstract:

    Glue layer to zone security manager, now residing in urlmon.dll

Author:

    Rajeev Dujari (rajeevd)  02-Aug-1997

Contents:

    UrlZonesAttach
    UrlZonesDetach
    GetCredPolicy

--*/


#include <wininetp.h>
#include "urlmon.h"

//
// prototypes
//
typedef HRESULT (*PFNCREATESECMGR)(IServiceProvider * pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);
typedef HRESULT (*PFNCREATEZONEMGR)(IServiceProvider * pSP, IInternetZoneManager **ppZM, DWORD dwReserved);

//
// globals
//
IInternetSecurityManager* g_pSecMgr  = NULL;
IInternetZoneManager*     g_pZoneMgr = NULL;

static BOOL g_bAttemptedInit = FALSE;
static HINSTANCE g_hInstUrlMon = NULL;
static PFNCREATESECMGR  g_pfnCreateSecMgr  = NULL;
static PFNCREATEZONEMGR g_pfnCreateZoneMgr = NULL;

//
// Handy class which uses a stack buffer if possible, otherwise allocates.
//
struct FlexBuf
{
    BYTE Buf[512];
    LPBYTE pbBuf;

    FlexBuf()
    {
        pbBuf = NULL;
    }

    ~FlexBuf()
    {
        if (pbBuf != NULL) {
            delete [] pbBuf;
        }
    }

    LPBYTE GetPtr (DWORD cbBuf)
    {
        if (cbBuf < sizeof(Buf))
            return Buf;
        pbBuf = new BYTE [cbBuf];
        return pbBuf;
    }
};

struct UnicodeBuf : public FlexBuf
{
    LPWSTR Convert (LPCSTR pszUrl)
    {
        DWORD cbUrl = lstrlenA (pszUrl) + 1;
        LPWSTR pwszUrl = (LPWSTR) GetPtr (sizeof(WCHAR) * cbUrl);
        if (!pwszUrl)
            return NULL;
        MultiByteToWideChar
            (CP_ACP, 0, pszUrl, cbUrl, pwszUrl, cbUrl);
        return pwszUrl;
    }
};

//
// Dynaload urlmon and create security manager object on demand.
//

BOOL UrlZonesAttach (void)
{
    EnterCriticalSection(&ZoneMgrCritSec);
    BOOL bRet = FALSE;
    HRESULT hr;

    if (g_bAttemptedInit)
    {
        bRet = (g_pSecMgr != NULL && g_pZoneMgr != NULL);
        goto End;
    }

    g_bAttemptedInit = TRUE;

    g_hInstUrlMon = LoadLibraryA(URLMON_DLL);
    if (!g_hInstUrlMon)
    {
        bRet = FALSE;
        goto End;
    }

    g_pfnCreateSecMgr = (PFNCREATESECMGR)
        GetProcAddress(g_hInstUrlMon, "CoInternetCreateSecurityManager");
    if (!g_pfnCreateSecMgr)
    {
        bRet = FALSE;
        goto End;
    }

    g_pfnCreateZoneMgr = (PFNCREATEZONEMGR)
        GetProcAddress(g_hInstUrlMon, "CoInternetCreateZoneManager");
    if (!g_pfnCreateZoneMgr)
    {
        bRet = FALSE;
        goto End;
    }

    hr = (*g_pfnCreateSecMgr)(NULL, &g_pSecMgr, NULL);
    if( hr != S_OK )
    {
        bRet = FALSE;
        goto End;
    }

    hr = (*g_pfnCreateZoneMgr)(NULL, &g_pZoneMgr, NULL);
    bRet = (hr == S_OK);

End:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return bRet;
}

//
// Clean up upon process detach.
//

STDAPI_(void) UrlZonesDetach (void)
{
    EnterCriticalSection(&ZoneMgrCritSec);

    if (g_pSecMgr)
    {
        g_pSecMgr->Release();
        g_pSecMgr = NULL;
    }
    if (g_pZoneMgr)
    {
        g_pZoneMgr->Release();
        g_pZoneMgr = NULL;
    }
    if (g_hInstUrlMon)
    {
        FreeLibrary(g_hInstUrlMon);
        g_hInstUrlMon = NULL;
    }
    LeaveCriticalSection(&ZoneMgrCritSec);
}

extern "C" DWORD GetZoneFromUrl(LPCSTR pszUrl);
         
DWORD GetZoneFromUrl(LPCSTR pszUrl)
{
    DWORD dwZone;
    dwZone = URLZONE_UNTRUSTED; // null URL indicates restricted zone.

    UnicodeBuf ub;
    EnterCriticalSection(&ZoneMgrCritSec);
    if (!g_pSecMgr && !UrlZonesAttach())
         goto err;
    
    LPWSTR pwszUrl;
    if (!pszUrl)
        pwszUrl = NULL;
    else
    {   
        pwszUrl = ub.Convert (pszUrl);
        if (!pwszUrl)
            goto err;
    }            
    
    if (pszUrl)
    {
        // Otherwise determine the zone for this URL.
        g_pSecMgr->MapUrlToZone (pwszUrl, &dwZone, 0);
    }

err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwZone;
}

//
// Routine to get the Routine to indicate whether ntlm logon credential is allowed.
//

DWORD GetCredPolicy (LPSTR pszUrl)
{
   HRESULT hr;
   DWORD dwPolicy;

   UnicodeBuf ub;
   EnterCriticalSection(&ZoneMgrCritSec);

   if (!UrlZonesAttach())
        goto err;

    LPWSTR pwszUrl;
    if (!pszUrl)
        pwszUrl = NULL;
    else
    {   
        pwszUrl = ub.Convert (pszUrl);
        if (!pwszUrl)
            goto err;
    }            

    hr = g_pSecMgr->ProcessUrlAction (pwszUrl, URLACTION_CREDENTIALS_USE,
        (LPBYTE) &dwPolicy, sizeof(dwPolicy), NULL, 0, PUAF_NOUI, 0);


    // Resolve the ambiguous "Prompt if Intranet zone policy".

    if (dwPolicy == URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT)
    {
        DWORD dwZone;
        dwZone = URLZONE_UNTRUSTED; // null URL indicates restricted zone.

        if (pszUrl)
        {
            // Otherwise determine the zone for this URL.
            hr = g_pSecMgr->MapUrlToZone (pwszUrl, &dwZone, 0);
            if (hr != S_OK)
                goto err;
        }
        
        if (dwZone == URLZONE_INTRANET)
            dwPolicy = URLPOLICY_CREDENTIALS_SILENT_LOGON_OK;
        else
            dwPolicy = URLPOLICY_CREDENTIALS_MUST_PROMPT_USER;
    }
    
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwPolicy;

err:
    INET_ASSERT (FALSE);
    LeaveCriticalSection(&ZoneMgrCritSec);
    return URLPOLICY_CREDENTIALS_MUST_PROMPT_USER;
}

/*
Main-switch for the cookie feature has 3 states.
1. ALLOW: all cookies are accepted/replayed (including leashed ones)
2. QUERY: received cookies are subject to P3P evaluation, 
          leashed cookies are not replayed
3. DISALLOW:no cookies are accepted/replayed.
*/
DWORD   GetCookieMainSwitch(DWORD dwZone) {

    DWORD dwPolicy = URLPOLICY_DISALLOW;

    if (!UrlZonesAttach())
        return dwPolicy;

    EnterCriticalSection(&ZoneMgrCritSec);

    HRESULT hr = g_pZoneMgr->GetZoneActionPolicy(dwZone, URLACTION_COOKIES_ENABLED,
                                                 (LPBYTE)&dwPolicy, sizeof(dwPolicy),
                                                 URLZONEREG_DEFAULT);

    LeaveCriticalSection(&ZoneMgrCritSec);

    return SUCCEEDED(hr) ? dwPolicy : URLPOLICY_ALLOW;
}

DWORD   GetCookieMainSwitch(LPCSTR pszURL) {

    return GetCookieMainSwitch(GetZoneFromUrl(pszURL));
}

DWORD GetCookiePolicy (LPCSTR pszUrl, DWORD dwUrlAction, BOOL fRestricted)
{
    if (GlobalSuppressCookiesPolicy)
    {
        return URLPOLICY_ALLOW;
    }
    
    EnterCriticalSection(&ZoneMgrCritSec);
    UnicodeBuf ub;
    DWORD dwCP;

    if (!UrlZonesAttach())
        goto err;

    // Convert to unicode.
    LPWSTR pwszUrl;
    pwszUrl = ub.Convert (pszUrl);
    if (!pwszUrl)
        goto err;

    DWORD dwPolicy;
    HRESULT hr;
    DWORD dwFlags;
    
    dwFlags = PUAF_NOUI;
    if (fRestricted)
        dwFlags |= PUAF_ENFORCERESTRICTED;
        
    hr = g_pSecMgr->ProcessUrlAction (pwszUrl, dwUrlAction,
            (LPBYTE) &dwPolicy, sizeof(dwPolicy), NULL, 0, dwFlags, 0);

    if (!SUCCEEDED(hr) )
        goto err;

    dwCP = GetUrlPolicyPermissions(dwPolicy);
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwCP;

err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    INET_ASSERT (FALSE);
    return URLPOLICY_QUERY;
}

DWORD GetClientCertPromptPolicy (LPCSTR pszUrl, BOOL fRestricted /* = FALSE */)
{   
    EnterCriticalSection(&ZoneMgrCritSec);
    UnicodeBuf ub;
    DWORD dwCP;
    DWORD dwUrlAction = URLACTION_CLIENT_CERT_PROMPT;
    DWORD dwFlags;

    if (!UrlZonesAttach())
        goto err;

    // Convert to unicode.
    LPWSTR pwszUrl;
    pwszUrl = ub.Convert (pszUrl);
    if (!pwszUrl)
        goto err;

    DWORD dwPolicy;

    dwFlags = PUAF_NOUI;
    if (fRestricted)
        dwFlags |= PUAF_ENFORCERESTRICTED;

    HRESULT hr;

    hr = g_pSecMgr->ProcessUrlAction (pwszUrl, dwUrlAction,
            (LPBYTE) &dwPolicy, sizeof(dwPolicy), NULL, 0, dwFlags, 0);

    if (!SUCCEEDED(hr) )
        goto err;

    dwCP = GetUrlPolicyPermissions(dwPolicy);
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwCP;

err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    INET_ASSERT (FALSE);
    return URLPOLICY_QUERY;
}

VOID SetStopWarning( LPCSTR pszUrl, DWORD dwPolicy, DWORD dwUrlAction)
{
    EnterCriticalSection(&ZoneMgrCritSec);
    UnicodeBuf ub;
    ZONEATTRIBUTES za = {0};

    if (!UrlZonesAttach())
        goto err;

    // Convert to unicode.
    LPWSTR pwszUrl;
    pwszUrl = ub.Convert (pszUrl);
    if (!pwszUrl)
        goto err;

    HRESULT hr;
    DWORD  dwZone;
    hr = g_pSecMgr->MapUrlToZone(pwszUrl, &dwZone, 0);
    if (!SUCCEEDED(hr) )
        goto err;

    DWORD dwZonePolicy;

    hr = g_pZoneMgr->GetZoneActionPolicy(
        dwZone,
        dwUrlAction,
        (LPBYTE)&dwZonePolicy,
        sizeof(dwZonePolicy),
        URLZONEREG_DEFAULT );

    if (!SUCCEEDED(hr) )
        goto err;

    // set the policy back with passed value
    SetUrlPolicyPermissions(dwZonePolicy, dwPolicy);

    hr = g_pZoneMgr->SetZoneActionPolicy(
        dwZone,
        dwUrlAction,
        (LPBYTE) &dwZonePolicy,
        sizeof(dwZonePolicy),
        URLZONEREG_DEFAULT );

    if (!SUCCEEDED(hr) )
        goto err;

    // change the generic zone setting to 'custom' now we've changed something
    za.cbSize = sizeof(ZONEATTRIBUTES);
    g_pZoneMgr->GetZoneAttributes(dwZone, &za);
    za.dwTemplateCurrentLevel = URLTEMPLATE_CUSTOM;
    g_pZoneMgr->SetZoneAttributes(dwZone, &za);


err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return;
}

//
// Set and query no cookies mode
//
BOOL IsNoCookies(DWORD dwZone)
{
    BOOL        fNoCookies = FALSE;
    HRESULT     hr;
    DWORD       dwZonePolicy;

    EnterCriticalSection(&ZoneMgrCritSec);

    if (!UrlZonesAttach())
        goto exit;

    hr = g_pZoneMgr->GetZoneActionPolicy(
                        dwZone,
                        URLACTION_COOKIES_ENABLED,
                        (LPBYTE)&dwZonePolicy,
                        sizeof(dwZonePolicy),
                        URLZONEREG_DEFAULT );

    if(SUCCEEDED(hr))
    {
        dwZonePolicy = GetUrlPolicyPermissions(dwZonePolicy);
        if(URLPOLICY_DISALLOW == dwZonePolicy)
        {
            fNoCookies = TRUE;
        }
    }

exit:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return fNoCookies;
}

void SetNoCookies(DWORD dwZone, DWORD dwNewPolicy)
{
    DWORD   dwZonePolicy;
    HRESULT hr;

    EnterCriticalSection(&ZoneMgrCritSec);

    if (!UrlZonesAttach())
        goto exit;

    hr = g_pZoneMgr->GetZoneActionPolicy(
                        dwZone,
                        URLACTION_COOKIES_ENABLED,
                        (LPBYTE)&dwZonePolicy,
                        sizeof(dwZonePolicy),
                        URLZONEREG_DEFAULT );

    if(SUCCEEDED(hr))
    {
        SetUrlPolicyPermissions(dwZonePolicy, dwNewPolicy);

        g_pZoneMgr->SetZoneActionPolicy(
                        dwZone,
                        URLACTION_COOKIES_ENABLED,
                        (LPBYTE)&dwZonePolicy,
                        sizeof(dwZonePolicy),
                        URLZONEREG_DEFAULT );
    }

exit:
    LeaveCriticalSection(&ZoneMgrCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\sspspm.h ===
//#----------------------------------------------------------------------------
//
//  File:           sspspm.h
//
//      Synopsis:   Definitions specific to SSPI SPM DLL.
//
//      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  Authors:        LucyC       Created                         25 Sept 1995
//
//-----------------------------------------------------------------------------
#ifndef _SSPSPM_H_
#define _SSPSPM_H_

#include <platform.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Names of secruity DLL
//
#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"
#define SSP_SPM_UNIX_DLL    "secur32.dll"

#define SSP_SPM_DLL_NAME_SIZE   16          // max. length of security DLL names

#define MAX_SSPI_PKG        32              // Max. no. of SSPI supported

#define SSPPKG_ERROR        ((UCHAR) 0xff)
#define SSPPKG_NO_PKG       SSPPKG_ERROR
#define MAX_AUTH_MSG_SIZE   10000
#define TCP_PRINT   fprintf
#define DBG_CONTEXT stderr

#define MAX_BLOB_SIZE       13000

//
//  Server host list definition.
//  This list contains server hosts which do not use MSN authentication.
//  The following defines an entry in the server host list.
//
typedef struct _ssp_host_list
{
    struct _ssp_host_list   *pNext;

    unsigned char           *pHostname; // name of server host
    unsigned char           pkgID;      // the package being used for this host

} SspHosts, *PSspHosts;

//
//  List of SSPI packages installed on this machine.
//  The following defines an entry of the SSPI package list.
//
typedef struct _ssp_auth_pkg
{
    LPTSTR       pName;         // package name
    DWORD        Capabilities ; // Interesting capabilities bit
    ULONG        cbMaxToken;    // max size of security token
} SSPAuthPkg, *PSSPAuthPkg;

#define SSPAUTHPKG_SUPPORT_NTLM_CREDS   0x00000001

//
//  The following defines the global data structure which the SPM DLL keeps
//  in the HTSPM structure.
//
typedef struct _ssp_htspm
{
    PSecurityFunctionTable pFuncTbl;

    SSPAuthPkg      **PkgList;          // array of pointers to auth packages
    UCHAR           PkgCnt;

    UCHAR           MsnPkg;             // Index to MSN pkg in the pkg list

    BOOLEAN         bKeepList;          // whether to keep a list of servers
                                        // which use non-MSN SSPI packages
    PSspHosts       pHostlist;

} SspData, *PSspData;

#define SPM_STATUS_OK                   0
#define SPM_ERROR                       1
#define SPM_STATUS_WOULD_BLOCK          2
#define SPM_STATUS_INSUFFICIENT_BUFFER  3

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from sspcalls.c
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetSecAuthMsg (
    PSspData        pData,
    PCredHandle     pCredential,
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle     pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn,
    DWORD           cbBuffIn,
    char            *pFinalBuff,
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    UINT            bNonBlock,
    LPSTR           pszScheme,
    PCSTR           lpszUrl,
	SECURITY_STATUS *pssResult
    );

INT
GetPkgId(LPTSTR  lpszPkgName);

DWORD
GetPkgCapabilities(
    INT Package
    );

ULONG
GetPkgMaxToken(
    INT Package
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from buffspm.c
//
/////////////////////////////////////////////////////////////////////////////

PSspHosts
SspSpmNewHost (
    PSspData pData,
    UCHAR    *pHost,       // name of server host to be added
    UCHAR    Package
    );

VOID
SspSpmDeleteHost(
    SspData     *pData,
    PSspHosts   pDelHost
    );

VOID
SspSpmTrashHostList(
    SspData     *pData
    );

PSspHosts
SspSpmGetHost(
    PSspData pData,
    UCHAR *pHost
    );

#ifdef __cplusplus
} // end extern "C" {
#endif

#endif  /* _SSPSPM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\dllmain.cpp ===
/********************************************************************************
/    This is the base file to the Microsoft JScript Proxy Configuration 
/    This file implements the code to provide the script site and the JSProxy psuedo
/    object for the script engine to call against.
/
/    Created        11/27/96    larrysu
/
/
/
/
/
/
/
/
/
*/

#include "dllmain.h"

CScriptSite    *g_ScriptSite = NULL;
BOOL fOleInited = FALSE;

/*******************************************************************************
*    dll initialization and destruction

********************************************************************************/
EXTERN_C
BOOL APIENTRY DllMain(HMODULE hModule,DWORD ul_reason_for_call,LPVOID lpReserved)
{
    
    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        break;
    case DLL_PROCESS_DETACH:        
        break;
    }
    return TRUE;
}


STDAPI_(BOOL) AUTOCONF_InternetInitializeAutoProxyDll(DWORD dwVersion, 
                                                      LPSTR lpszDownloadedTempFile,
                                                      LPSTR lpszMime,
                                                      AUTO_PROXY_HELPER_APIS *pAutoProxyCallbacks, 
                                                      LPAUTO_PROXY_EXTERN_STRUC lpExtraData)
{
    HRESULT    hr = E_FAIL;
    HANDLE    hFile = 0;
    LPSTR    szScript = NULL;
    DWORD    dwFileSize = 0;
    DWORD    dwBytesRead = 0;
    LPSTR    result;
    LPSTR   szAllocatedScript = NULL;


    if ( !fOleInited ) 
    {
#ifndef unix
        CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
        CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif /* unix */
    }


    // get the script text from the downloaded file!
    // open the file

    if ( lpExtraData == NULL ||
         lpExtraData->dwStructSize != sizeof(AUTO_PROXY_EXTERN_STRUC) ||
         lpExtraData->lpszScriptBuffer == NULL )
    {
        if (!lpszDownloadedTempFile)
            return FALSE;

        hFile = CreateFile((LPCSTR)lpszDownloadedTempFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            return FALSE;

        // Get the size
        dwFileSize = GetFileSize(hFile,NULL);
        // allocate the buffer to hold the data.
        szScript = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwFileSize+1);
        szAllocatedScript = szScript;

        BOOL f = TRUE;
        // if the memory was allocated
        if (szScript)
        {
            // read the data
            f = ReadFile(hFile,(LPVOID) szScript,dwFileSize,&dwBytesRead,NULL);
        }
        CloseHandle(hFile);

        if (!f)
            goto Cleanup;
    }
    else
    {
        szScript = (LPSTR) lpExtraData->lpszScriptBuffer;
    }

    // Create a new CScriptSite object and initiate it with the autoconfig script.
    g_ScriptSite = new CScriptSite;
    if (g_ScriptSite)
        hr = g_ScriptSite->Init(pAutoProxyCallbacks, szScript);
    else
        hr = E_OUTOFMEMORY;

Cleanup:

    if ( szAllocatedScript ) 
    {
        // Free the script text
        GlobalFree(szAllocatedScript);
        szAllocatedScript = NULL;
    }

    if (SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

// This function frees the script engine and destroys the script site.
EXTERN_C BOOL CALLBACK AUTOCONF_InternetDeInitializeAutoProxyDll(LPSTR lpszMime, DWORD dwReserved)
{

    // Release and destroy the CScriptSite object and initiate it with the autoconfig script.
    // DeInit the script site.
    if (g_ScriptSite)
    {
        g_ScriptSite->DeInit();
        g_ScriptSite->Release();
        g_ScriptSite = NULL;
    }

    if ( fOleInited ) 
    {
        CoUninitialize();    
    }

    return TRUE;
}

// This function is called when the host wants to run the script.
EXTERN_C BOOL CALLBACK InternetGetProxyInfo(LPCSTR lpszUrl,
                                            DWORD dwUrlLength,
                                            LPSTR lpszUrlHostName,
                                            DWORD dwUrlHostNameLength,
                                            LPSTR *lplpszProxyHostName,
                                            LPDWORD lpdwProxyHostNameLength)
{
    HRESULT    hr = S_OK;
    LPSTR    szHost;
    
    // The host passed in may be too big.  Copy it an make the 
    // HostLength + 1 position will be slammed with \0.
    szHost = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwUrlHostNameLength+1);
    if (!szHost)
        return FALSE;
    if(lpszUrlHostName && !lstrcpyn(szHost,lpszUrlHostName,dwUrlHostNameLength+1))
    {
        GlobalFree(szHost);
        return FALSE;
    }

    // construct a jscript call with the passed in url and host.
    if (g_ScriptSite)
//        hr = g_ScriptSite->RunScript(lpszUrl,lpszUrlHostName,lplpszProxyHostName);
        hr = g_ScriptSite->RunScript(lpszUrl,szHost,lplpszProxyHostName);

    GlobalFree(szHost);

    if (SUCCEEDED(hr))
    {
        *lpdwProxyHostNameLength = lstrlen(*lplpszProxyHostName) +1;
        return TRUE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\winctxt.h ===
#ifndef _WIN_SIC_CTXT_H_
#define _WIN_SIC_CTXT_H_

#define DEFAULT_SERVER_NAME_LEN     128

typedef struct _WINCONTEXT  {

    //
    //  Buffer for storing exchange blob returned by SSPI before
    //  PreAuthenticateUser is called
    //
    char        *szOutBuffer;
    DWORD       cbOutBuffer;        // bytes associated with allocated szOutBuffer
    DWORD       dwOutBufferLength;

    char        *szInBuffer;
    DWORD       cbInBuffer;         // bytes associated with allocated szInBuffer
    PCHAR       pInBuffer;
    DWORD       dwInBufferLength;

    DWORD       dwCallId;

    DWORD       pkgId;

    CredHandle  Credential;     // SSPI credential handle for this connection
    PCredHandle pCredential;

    //
    // The SSPI Context Handle is stored here
    //
    CtxtHandle  SspContextHandle;
    PCtxtHandle pSspContextHandle;  // before any ctxt is created, this is NULL

    LPSTR       lpszServerName;

    char        szServerName[DEFAULT_SERVER_NAME_LEN];

} WINCONTEXT, *PWINCONTEXT;

#endif  // _WIN_SIC_CTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\crtfree.h ===
#ifndef __CRTFREE_H_
#define __CRTFREE_H_


//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//

void *  __cdecl operator new(size_t nSize)
    {
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
    }


void  __cdecl operator delete(void *pv)
    {
    LocalFree((HLOCAL)pv);
    }

extern "C" int __cdecl _purecall(void) {return 0;}

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\regexp.h ===
#ifndef __REGEXP_H__
#define __REGEXP_H__

#include <windows.h>
#include "utils.h"

#define PAT_START	128	/* Special beginning-of-pattern marker */
#define PAT_END		129	/* Special end-of-pattern marker */
#define PAT_STAR	130	/* Zero or more of any character */
#define PAT_QUES	131	/* Exactly one of any character */
#define PAT_AUGDOT	132	/* Literal '.' or end-of-string */
#define PAT_AUGQUES	133	/* Empty string or non-'.' */
#define PAT_AUGSTAR	134	/* Single character that isn't a '.' */

BOOL test_match(int m, LPSTR target, int pattern[]);
BOOL parse_pattern(LPSTR s, int pattern[]);
BOOL match( LPSTR target, LPSTR regexp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\cscpsite.h ===
#ifndef __CSCPSITE_H__
#define __CSCPSITE_H__

#include <windows.h>
#include <olectl.h>
#include <activscp.h>
#include "jsproxy.h"
#include "utils.h"


/********************************************************************************************/
// ScriptSite Class
//
//
//
class CScriptSite : public IActiveScriptSite,
                    public IServiceProvider,
                    public IInternetHostSecurityManager
{

public:
	CScriptSite();
	~CScriptSite();
	// IUnknown Interface methods.
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObject);

	STDMETHODIMP_(ULONG) AddRef()
	{
		return ++m_refCount;
	}

	STDMETHODIMP_(ULONG) Release()
	{
		if (--m_refCount)
			return m_refCount;

		delete this;
		return 0;
	}

	STDMETHODIMP GetLCID(LCID *plcid);
	STDMETHODIMP GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppTypeInfo);
	STDMETHODIMP GetDocVersionString(BSTR *pstrVersionString);
	STDMETHODIMP OnScriptTerminate(const VARIANT *pvarResult,const EXCEPINFO *pexcepinfo);
	STDMETHODIMP OnStateChange(SCRIPTSTATE ssScriptState);
	STDMETHODIMP OnScriptError(IActiveScriptError *pase);
	STDMETHODIMP OnEnterScript();
	STDMETHODIMP OnLeaveScript();

	STDMETHODIMP Init(AUTO_PROXY_HELPER_APIS* pAPHA, LPCSTR szScript);
	STDMETHODIMP DeInit();
	STDMETHODIMP RunScript(LPCSTR szURL, LPCSTR szHost, LPSTR* result);

    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService( 
        REFGUID guidService,
        REFIID riid,
        void **ppvObject);

    //
    // IInternetHostSecurityManager
    //
    STDMETHODIMP GetSecurityId( 
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved);
    
    STDMETHODIMP ProcessUrlAction( 
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved);
    
    STDMETHODIMP QueryCustomPolicy( 
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved);

private:
	BOOL				m_fInitialized;
	long				m_refCount;
	IActiveScript		*m_pios;
	IActiveScriptParse	*m_pasp;
	CJSProxy			*m_punkJSProxy;
	IDispatch			*m_pScriptDispatch; // Stored dispatch for script
	DISPID				m_Scriptdispid; // DISPID for stored script to facilitate quicker invoke.

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\dllmain.h ===
#include <windows.h>
#include <olectl.h>
#include "cscpsite.h"

#include "crtfree.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\auth\test\httpauth.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <wininet.h>

BOOL g_fAllowCustomUI;
DWORD g_dwConnectFlags;
BOOL g_fPreload;
BOOL g_fMonolithicUpload = TRUE;
LPSTR g_szVerb = NULL;

//==============================================================================
BOOL NeedAuth (HINTERNET hRequest, DWORD *pdwStatus)
{
    // Get status code.
    DWORD dwStatus;
    DWORD cbStatus = sizeof(dwStatus);
    HttpQueryInfo
    (
        hRequest,
        HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);
    *pdwStatus = dwStatus;

    // Look for 401 or 407.
    DWORD dwFlags;
    switch (dwStatus)
    {
        case HTTP_STATUS_DENIED:
            dwFlags = HTTP_QUERY_WWW_AUTHENTICATE;
            break;
        case HTTP_STATUS_PROXY_AUTH_REQ:
            dwFlags = HTTP_QUERY_PROXY_AUTHENTICATE;
            break;            
        default:
            return FALSE;
    }

    // Enumerate the authentication types.
    BOOL fRet;
    char szScheme[64];
    DWORD dwIndex = 0;
    do
    {
        DWORD cbScheme = sizeof(szScheme);
        fRet = HttpQueryInfo
            (hRequest, dwFlags, szScheme, &cbScheme, &dwIndex);
        if (fRet)
            fprintf (stderr, "Found auth scheme: %s\n", szScheme);
    }
        while (fRet);

    return TRUE;
}


//==============================================================================
DWORD DoCustomUI (HINTERNET hRequest, BOOL fProxy)
{
    // Prompt for username and password.
    char  szUser[64], szPass[64];
    fprintf (stderr, "Enter Username: ");
    if (!fscanf (stdin, "%s", szUser))
        return ERROR_INTERNET_LOGIN_FAILURE;
    fprintf (stderr, "Enter Password: ");
    if (!fscanf (stdin, "%s", szPass))
        return ERROR_INTERNET_LOGIN_FAILURE;

    // Set the values in the handle.
    if (fProxy)
    {
        InternetSetOption
            (hRequest, INTERNET_OPTION_PROXY_USERNAME, szUser, sizeof(szUser));
        InternetSetOption
            (hRequest, INTERNET_OPTION_PROXY_PASSWORD, szPass, sizeof(szPass));
    }
    else
    {
        InternetSetOption
            (hRequest, INTERNET_OPTION_USERNAME, szUser, sizeof(szUser));
        InternetSetOption
            (hRequest, INTERNET_OPTION_PASSWORD, szPass, sizeof(szPass));
    }
    
    return ERROR_INTERNET_FORCE_RETRY;
}


//==============================================================================
int RequestLoop (int argc, char **argv)
{
    HINTERNET hInternet = NULL;
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;
    PSTR pPostData = NULL;
    DWORD cbPostData = 0;

    PSTR pszErr = NULL;
    BOOL fRet;
    
#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

    // Parse host:port
    PSTR pszHost     = argv[0];
    DWORD dwPort;
    PSTR pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_INVALID_PORT_NUMBER;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }
    
    PSTR pszObject   = argc >= 2 ? argv[1] : "/";
    PSTR pszUser     = argc >= 3 ? argv[2] : NULL;
    PSTR pszPass     = argc >= 4 ? argv[3] : NULL;
    PSTR pszPostFile = argc >= 5 ? argv[4] : NULL;

    if (pszPostFile)
        g_dwConnectFlags |= INTERNET_FLAG_RELOAD;


//#ifdef MONOLITHIC_UPLOAD

   if(g_fMonolithicUpload) 
   {

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }
  }  // g_fMonolithicUpload
//#endif

    // Initialize wininet.
    hInternet = InternetOpen
    (
        //"HttpAuth Sample",            // user agent
         "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
        INTERNET_OPEN_TYPE_PRECONFIG, // access type
        NULL,                         // proxy server
        0,                            // proxy port
        0                             // flags
    );
    CHECK_ERROR (hInternet, "InternetOpen");


    // Connect to host.
    hConnect = InternetConnect
    (
        hInternet,                    // wininet handle,
        pszHost,                      // host
        (INTERNET_PORT)dwPort,                       // port
        pszUser,                      // user
        NULL,                         // password
        INTERNET_SERVICE_HTTP,        // service
        g_dwConnectFlags,             // flags
        0                             // context
    );
    CHECK_ERROR (hConnect, "InternetConnect");

    // Use SetOption to set the password since it handles empty strings.
    if (pszPass)
    {
        InternetSetOption
            (hConnect, INTERNET_OPTION_PASSWORD, pszPass, lstrlen(pszPass)+1);
    }

    if(!g_szVerb)
    {
    	if (pszPostFile)
		    g_szVerb = "PUT";
	    else
		    g_szVerb = "GET";
    }

    // Create request.
    hRequest = HttpOpenRequest
    (
        hConnect,                     // connect handle
        g_szVerb, // pszPostFile? "PUT" : "GET",  // request method
        pszObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        g_dwConnectFlags              // flags
            | INTERNET_FLAG_KEEP_CONNECTION
            | SECURITY_INTERNET_MASK, // ignore SSL warnings
        0                             // context
    );
    CHECK_ERROR (hRequest, "HttpOpenRequest");
    
resend:

//    if (!pszPostFile || pPostData)
    if (g_fMonolithicUpload)
    {
        // Send request.
        fRet = HttpSendRequest
        (
            hRequest,                     // request handle
            "",                           // header string
            0,                            // header length
            pPostData,                    // post data
            cbPostData                    // post length
        );
    }
    else
    {
        HANDLE hf = CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);

            INTERNET_BUFFERS BufferIn;
            BufferIn.dwStructSize = sizeof( INTERNET_BUFFERSA );
            BufferIn.Next = NULL; 
            BufferIn.lpcszHeader = NULL;
            BufferIn.dwHeadersLength = 0;
            BufferIn.dwHeadersTotal = 0;
            BufferIn.lpvBuffer = NULL;
            BufferIn.dwBufferLength = 0;
            BufferIn.dwBufferTotal = cbPostData;
            BufferIn.dwOffsetLow = 0;
            BufferIn.dwOffsetHigh = 0;

            fRet = HttpSendRequestEx (hRequest, &BufferIn, NULL, 0, 0);
            CHECK_ERROR (fRet, "HttpSendRequestEx");

            while (1)
            {
                CHAR szTemp[512];
                DWORD cbRead;
                fRet = ReadFile (hf, szTemp, sizeof(szTemp), &cbRead, 0);
                CHECK_ERROR (fRet, "ReadFile");

                if (!fRet || !cbRead)
                    break;

                DWORD cbRead2;
                fRet = InternetWriteFile (hRequest, szTemp, cbRead, &cbRead2);
                CHECK_ERROR (fRet, "InternetWriteFile");
            }

            CloseHandle (hf);

            fRet = HttpEndRequest (hRequest, NULL, 0, 0);
            if (!fRet && GetLastError() == ERROR_INTERNET_FORCE_RETRY)
                goto resend;
        }
    }


    DWORD dwStatus;
   
    // Check if the status code is 401 or 407
    if (NeedAuth (hRequest, &dwStatus) && (g_fAllowCustomUI))
    {
        // Prompt for username and password.
        if (DoCustomUI (hRequest, dwStatus != HTTP_STATUS_DENIED))
            goto resend;
    }
    else
    {
        DWORD dwSendErr = fRet? ERROR_SUCCESS : GetLastError();

        DWORD dwDlgErr = InternetErrorDlg(
                GetDesktopWindow(),
                hRequest,  
                dwSendErr,
                FLAGS_ERROR_UI_FILTER_FOR_ERRORS  |     
                    FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
                    FLAGS_ERROR_UI_FLAGS_GENERATE_DATA, 
                NULL
            );
        switch (dwSendErr)
        {
            case ERROR_SUCCESS:
            case ERROR_INTERNET_NAME_NOT_RESOLVED:
            case ERROR_INTERNET_CANNOT_CONNECT:
                if (dwDlgErr == ERROR_INTERNET_FORCE_RETRY)
                    goto resend;
                else
                    break;

            case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION:
            default:
                if (dwDlgErr == ERROR_SUCCESS)
                    goto resend;
                else
                    break;
        }
    }

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;
    DWORD cbRead;
    cbBuf = sizeof(bBuf);
    _setmode( _fileno( stdout ), _O_BINARY );
    while (InternetReadFile (hRequest, bBuf, cbBuf, &cbRead) && cbRead)
        fwrite (bBuf, 1, cbRead, stdout);
    
done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        InternetCloseHandle (hRequest);
    if (hConnect)
        InternetCloseHandle (hConnect);
    if (hInternet)
        InternetCloseHandle (hInternet);
    if (pPostData)
        LocalFree (pPostData);
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
	g_fAllowCustomUI = 0; //FALSE;
    g_dwConnectFlags = 0;
	HMODULE hmodShlwapi = NULL;
	char * port    ;
	// Discard program arg.
    argv++;
    argc--;

    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'c':
                g_fAllowCustomUI = TRUE;
                break;
                
            case 's':
                g_dwConnectFlags = INTERNET_FLAG_SECURE;
                break;
                
            case 'p':
                g_fPreload = TRUE;
                break;
                
            case 'v':
        		port = *argv;
        		port +=2;
        		fprintf(stderr,"Verb: %s\n", port);
                if(port)
        			g_szVerb = port;
                break;
                
            case 'm':
                g_fMonolithicUpload = TRUE;
                break;
                
            default:
                fprintf (stderr, "\nUsage: httpauth [-c] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -c: Custom UI to prompt for user/pass");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -m: Monolithic upload");
                fprintf (stderr, "\n  -o<port#> : Port Number");
                exit (1);
        }
        
        argv++;
        argc--;
    }

	if (g_fPreload)
	{
	//Get the current directory in case the user selects -p to preload shlwapi from current dir 
		char buf[256];
		GetCurrentDirectory((DWORD)256, buf); 
		strcat(buf,"\\shlwapi.dll");
		fprintf(stderr, "\nPreloading shlwapi.dll from %s", buf);
		if (!(hmodShlwapi=LoadLibrary(buf))) fprintf(stderr, "\nPreload of shlwapi.dll failed");
	}

    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: <server> [<object> [<user> [<pass> [<POST-file>]]]]");
        fprintf (stderr, "\n  quit - exit the command loop");
        fprintf (stderr, "\n  flush - flush pwd cache and authenticated sockets");
        
        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);

            if (!lstrcmpi (szIn, "quit"))
                break;
            else if (!lstrcmpi (szIn, "flush"))
            {
                InternetSetOption
                    (NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0);
                continue;
            }
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
        }                
    }

	//unload shlwapi if loaded
	if (hmodShlwapi) FreeLibrary(hmodShlwapi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\jsproxy.h ===
#ifndef __JSPROXY_H__
#define __JSPROXY_H__

#include <windows.h>
#include <olectl.h>
#include "utils.h"
#include "regexp.h"

#define VAL_isPlainHostName			0x01f9
#define VAL_dnsDomainIs				0x01f8
#define VAL_localHostOrDomainIs		0x020b
#define VAL_isResolvable			0x0206
#define VAL_isInNet					0x01e1
#define VAL_dnsResolve				0x01fc
#define VAL_myIpAddress				0x01e0
#define VAL_dnsDomainLevels			0x01f8
#define VAL_shExpMatch				0x0208
#define VAL_weekdayRange			0x0210
#define VAL_dateRange				0x01f0
#define VAL_timeRange				0x0201
#define VAL_alert				0x0218

#define DISPID_isPlainHostName		0x0001
#define DISPID_dnsDomainIs			0x0002
#define DISPID_localHostOrDomainIs	0x0003
#define DISPID_isResolvable			0x0004
#define DISPID_isInNet				0x0005
#define DISPID_dnsResolve			0x0006
#define DISPID_myIpAddress			0x0007
#define DISPID_dnsDomainLevels		0x0008
#define DISPID_shExpMatch			0x0009
#define DISPID_weekdayRange			0x000a
#define DISPID_dateRange			0x000b
#define DISPID_timeRange			0x000c
#define DISPID_alert				0x000d

/************************************************************************************************/
// This class implements the Dispatch interface that will allow the script engine to call the 
// auto-proxy configuration functions.  This interface does not have a typelib and does not provide type
// info.
class CJSProxy : public IDispatch
{

public:

	CJSProxy();
	~CJSProxy();
	// IUnknown Methods
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObject)
	{

#ifdef INET_DEBUG
        OutputDebugString( "IDispatch::QueryInterface\n" );
#endif

		if (riid == IID_IUnknown || 
            riid == IID_IDispatch)
		{
			*ppvObject = (LPVOID)(LPUNKNOWN)this;
            AddRef();
			return S_OK;
		}
		else
		{
			if (riid == IID_IDispatch)
			{
				*ppvObject = (LPVOID)(IDispatch*)this;
                AddRef();
				return S_OK;
			}
			else
			{
				*ppvObject = 0;
				return E_NOINTERFACE;
			}
		}

	}

	STDMETHODIMP_(ULONG) AddRef()
	{
#ifdef INET_DEBUG
        char szBuff[256];

        wsprintf(szBuff, "IDispatch::AddRef ref=%u\n", m_refCount );
        OutputDebugString(szBuff);
#endif

		return ++m_refCount;
	}

	STDMETHODIMP_(ULONG) Release()
	{
#ifdef INET_DEBUG
        char szBuff[256];

        wsprintf(szBuff, "IDispatch::Release ref=%u\n", m_refCount );
        OutputDebugString(szBuff);
#endif

		if (--m_refCount)
			return m_refCount;

		delete this;
		return 0;
	}

	// IDispatch Methods
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
	{
		*pctinfo = 0;
		return S_OK;
	}

    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return TYPE_E_ELEMENTNOTFOUND;
	}

    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid);

    STDMETHODIMP Invoke(
					DISPID dispidMember,
					REFIID riid,
					LCID lcid,
					WORD wFlags,
					DISPPARAMS* pdispparams,
					VARIANT* pvarResult,
					EXCEPINFO* pexcepinfo,
					UINT* puArgErr);

	//  JScript Auto-Proxy config functions.
	STDMETHODIMP isPlainHostName(BSTR host, VARIANT* retval);
	STDMETHODIMP dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval);
	STDMETHODIMP localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval);
	STDMETHODIMP isResolvable(BSTR host, VARIANT* retval);
	STDMETHODIMP isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval);
	STDMETHODIMP dnsResolve(BSTR host, VARIANT* retval);
	STDMETHODIMP myIpAddress(VARIANT* retval);
	STDMETHODIMP dnsDomainLevels(BSTR host, VARIANT* retval);
	STDMETHODIMP shExpMatch(BSTR str, BSTR shexp, VARIANT* retval);
	STDMETHODIMP alert(BSTR message, VARIANT* retval);

	// These are to do last!!!.
	STDMETHODIMP weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval);
	STDMETHODIMP dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval);
	STDMETHODIMP timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval);
	//	ProxyConfig.bindings 

	STDMETHODIMP Init(AUTO_PROXY_HELPER_APIS* pAPHA);
	STDMETHODIMP DeInit();
	
	// JScript private members
private:
	long					m_refCount;
	BOOL					m_fDestroyable;
	BOOL					m_fInitialized;
	AUTO_PROXY_HELPER_APIS*	m_pCallout;
	LPCWSTR					m_strings[13];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\regexp.cpp ===
#include <regexp.h>

BOOL test_match(int m, LPSTR target, int pattern[])     /* m = length of target */
{
    int    *match;
    int     i = -1;     /* Will be advanced to 0 */
    int     j = 0;      /* i = index to pattern, j = index to target */
    BOOL    fResult = FALSE;

    match = new int[INTERNET_MAX_URL_LENGTH];
    if (match == NULL)
        goto Cleanup;

advance:
    ++i;
    if (j > m)
        goto Cleanup;

    switch (pattern[i]) {
    case PAT_START:  if (j != 0) goto Cleanup; match[i] = 0; goto advance;
    case PAT_END:    if (target[j] == 0) {fResult = TRUE; goto Cleanup;} else goto retreat;
    case PAT_STAR:   match[i] = j = m; goto advance;
    case PAT_QUES:   if (j < m) goto match_one; else goto retreat;
    case PAT_AUGDOT: if (target[j] == '.') goto match_one;
             else if (target[j] == 0) goto match_zero;
             else goto retreat;
    case PAT_AUGQUES: if (target[j] && target[j] != '.')
            goto match_one; else goto match_zero;
    case PAT_AUGSTAR: if (target[j] && target[j] != '.') 
            goto match_one; else goto retreat;
    default:          if (target[j] == pattern[i])
            goto match_one; else goto retreat;
    }
match_one: match[i] = ++j; goto advance;
match_zero: match[i] = j; goto advance;

retreat:
    --i;
    switch (pattern[i]) {
    case PAT_START:  goto Cleanup;
    case PAT_END:    goto Cleanup;     /* Cannot happen */
    case PAT_STAR:   if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_QUES:   goto retreat;
    case PAT_AUGDOT: goto retreat;
    case PAT_AUGQUES: if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_AUGSTAR: goto retreat;
    default:          goto retreat;
    }

Cleanup:
    if (match)
        delete [] match;

    return fResult;
}

BOOL parse_pattern(LPSTR s, int pattern[])
{
    int i = 1;

    pattern[0] = PAT_START; /* Can be hard-coded into pattern[] */
    for (;;) {
    switch (*s) {
        case '*':   pattern[i] = PAT_STAR; break;
        case '?':   pattern[i] = PAT_QUES; break;
        case '^':
        switch (*++s) {
        case '.': pattern[i] = PAT_AUGDOT; break;
        case '?': pattern[i] = PAT_AUGQUES; break;
        case '*': pattern[i] = PAT_AUGSTAR; break;
        default: return FALSE;
        }
        break;
        case 0: pattern[i] = PAT_END; return TRUE;
        default:    pattern[i] = *s; break;
    }
    if (++i >= INTERNET_MAX_URL_LENGTH) return FALSE;
    ++s;
    }
}

BOOL match( LPSTR target, LPSTR regexp) 
{
    int *pattern;
    BOOL result;

    pattern = new int[INTERNET_MAX_URL_LENGTH];

    if (!target || (pattern==NULL))
        return FALSE;

    if (!parse_pattern(regexp,pattern)) 
        return FALSE;
    if (lstrlen(target) >= INTERNET_MAX_URL_LENGTH) 
        return FALSE;

    result = test_match(lstrlen(target),target,pattern);
    delete [] pattern;
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\cscpsite.cpp ===
#include "cscpsite.h"
#include <objsafe.h>


/*******************************************************************************
*	CScriptSite Functions
********************************************************************************/
CScriptSite::CScriptSite()
{
	m_refCount = 1;
	m_pios = NULL;
	m_pasp = NULL; 
	m_pScriptDispatch = NULL;
	m_Scriptdispid = -1;
	m_fInitialized = FALSE;

}
CScriptSite::~CScriptSite()
{
	if (m_fInitialized)
		DeInit();
}

STDMETHODIMP CScriptSite::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (riid == IID_IUnknown)
    {            
        *ppvObject = (LPVOID)(LPUNKNOWN)static_cast<IActiveScriptSite *>(this);
    }
    else if (riid == IID_IActiveScriptSite)
    {
        *ppvObject = (LPVOID)static_cast<IActiveScriptSite *>(this);
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObject = (LPVOID)static_cast<IServiceProvider *>(this);
    }
    else if (riid == IID_IInternetHostSecurityManager)
    {
        *ppvObject = (LPVOID)static_cast<IInternetHostSecurityManager *>(this);
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP CScriptSite::Init(AUTO_PROXY_HELPER_APIS* pAPHA, LPCSTR szScript)
{
	CHAR szClassId[64];	
	CLSID clsid;
	HRESULT hr = S_OK;
	BSTR	bstrClsID = NULL;
	BSTR	bstrScriptText = NULL;
	BSTR	rgbstrNames[1] = {L"FindProxyForURL"};
	EXCEPINFO	exceptinfo;
    IObjectSafety * pIObjSafety = NULL;

	// pAPHA can be null - it is checked in the autoproxy object!
	if (!szScript)
		return E_POINTER;

	if (m_fInitialized)
		return hr;
	// CoCreateInstance the JScript engine.

	// Get the class id of the desired language engine
	hr = GetScriptEngineClassIDFromName(
		"JavaScript",
		szClassId,
		sizeof(szClassId)
		);
	if (FAILED(hr)) {
		return E_FAIL;
	}
	//convert CLSID string to clsid

	bstrClsID = BSTRFROMANSI(szClassId);
	if (!bstrClsID)
		goto exit;
	hr = CLSIDFromString(bstrClsID, &clsid);
	SysFreeString(bstrClsID);
	if (FAILED(hr))
		goto exit;

	// Instantiate the script engine
	hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pios);
	if (FAILED(hr))
		goto exit;

	// Get the IActiveScriptParse interface, if any
	hr = m_pios->QueryInterface(IID_IActiveScriptParse, (void**) &m_pasp);
	if (FAILED(hr))
		goto exit;

	hr = m_pasp->InitNew();
	if (FAILED(hr))
		goto exit;

	// SetScriptSite to this
	hr = m_pios->SetScriptSite((IActiveScriptSite *)this);
	if (FAILED(hr))
		goto exit;
	hr = m_pios->SetScriptState(SCRIPTSTATE_INITIALIZED);

    //
    // Inform the script engine that this host implements
    // the IInternetHostSecurityManager interface, which
    // is used to prevent the script code from using any
    // ActiveX objects.
    //
    hr = m_pios->QueryInterface(IID_IObjectSafety, (void **)&pIObjSafety);

    if (SUCCEEDED(hr) && (pIObjSafety != NULL))
    {
        pIObjSafety->SetInterfaceSafetyOptions(IID_NULL, 
                INTERFACE_USES_SECURITY_MANAGER,
                INTERFACE_USES_SECURITY_MANAGER);

        pIObjSafety->Release();
        pIObjSafety = NULL;
    }

	// AddNamedItem for pUnk and set m_punkJSProxy to pUnk.
	// If we added JSProxy to the name space the store away the JSProxy objects punk.
	m_punkJSProxy = new CJSProxy;
	if( !m_punkJSProxy )
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	m_punkJSProxy->Init(pAPHA);
	hr = m_pios->AddNamedItem(L"JSProxy",SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS);
	if (FAILED(hr))
		goto exit;
	
	// Convert the ANSI script text to a bstr.
	bstrScriptText = BSTRFROMANSI(szScript);
	if (!bstrScriptText)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	// Add the script text to the parser
	hr = m_pasp->ParseScriptText(
							 bstrScriptText,
							 NULL,
							 NULL,
							 NULL,
							 0,
							 0,
							 SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE,
							 NULL,
							 &exceptinfo);
	
	SysFreeString(bstrScriptText);
	if (FAILED(hr))
		goto exit;

	hr = m_pios->SetScriptState(SCRIPTSTATE_STARTED);
	if (FAILED(hr))
		goto exit;
	// Now get the script dispatch and find the DISPID for the method just added.  since this is a single use dll
	// I can do this otherwise this would be bad.
	hr = m_pios->GetScriptDispatch(NULL,&m_pScriptDispatch);
	if (FAILED(hr))
		goto exit;
	hr = m_pScriptDispatch->GetIDsOfNames(IID_NULL,rgbstrNames,1,LOCALE_SYSTEM_DEFAULT,&m_Scriptdispid);
	if (FAILED(hr))
		goto exit;

	m_fInitialized = TRUE;

	return hr;

exit: // we come here if something fails  -  release everything and set to null.
	if (m_pios)
	{
		m_pios->Close();
		m_pios->Release();
	}
	if (m_pasp)
		m_pasp->Release();
	if (m_pScriptDispatch)
		m_pScriptDispatch->Release();
	m_pios = NULL;
	m_pasp = NULL;
	m_pScriptDispatch = NULL;
	m_Scriptdispid = -1;
	
	return hr;
}

STDMETHODIMP CScriptSite::DeInit()
{
	HRESULT hr = S_OK;

	if (m_pios)
	{
		hr = m_pios->Close();
		m_pios->Release();
	}
	if (m_pasp)
		m_pasp->Release();
	if (m_pScriptDispatch)
		m_pScriptDispatch->Release();
	m_pios = NULL;
	m_pasp = NULL;
	m_pScriptDispatch = NULL;
	m_Scriptdispid = -1;
	m_fInitialized = FALSE;

	return hr;
}

STDMETHODIMP CScriptSite::RunScript(LPCSTR szURL, LPCSTR szHost, LPSTR* result)
{
	HRESULT		hr = S_OK;
	UINT		puArgErr = 0;
	EXCEPINFO	excep;
	VARIANT		varresult;
	DISPPARAMS	dispparams;
	VARIANT		args[2]; // We always call with 2 args!

	
	if (!szURL || !szHost || !result)
		return E_POINTER;

	VariantInit(&varresult);

    *result = NULL;

	dispparams.cArgs = 2;
	VariantInit(&args[0]);
	VariantInit(&args[1]);

	args[0].vt = VT_BSTR;
	args[1].vt = VT_BSTR;

	args[0].bstrVal = BSTRFROMANSI(szHost);
	args[1].bstrVal = BSTRFROMANSI(szURL);

    if (args[0].bstrVal==NULL || args[1].bstrVal==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

	dispparams.rgvarg = args;

	dispparams.cNamedArgs = 0;	
	dispparams.rgdispidNamedArgs = NULL; 

	// Call invoke on the stored dispid
	hr = m_pScriptDispatch->Invoke(m_Scriptdispid,
								   IID_NULL,LOCALE_SYSTEM_DEFAULT,
								   DISPATCH_METHOD,
								   &dispparams,
								   &varresult,
								   &excep,
								   &puArgErr);

    if (FAILED(hr))
        goto Cleanup;

	// convert result into bstr and return ansi version of the string!
	if (varresult.vt == VT_BSTR)
	{
		MAKE_ANSIPTR_FROMWIDE(rescpy, varresult.bstrVal);
		*result = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,lstrlen(rescpy)+1);
		if (!*result)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}
		lstrcpy(*result,rescpy);

	}
	else
	{
		VARIANT	resvar;

		VariantInit(&resvar);
		hr = VariantChangeType(&resvar,&varresult,NULL,VT_BSTR);
		if (SUCCEEDED(hr))
		{
			MAKE_ANSIPTR_FROMWIDE(rescpy, resvar.bstrVal);
			*result = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,lstrlen(rescpy)+1);
			if (!*result)
			{
				hr = E_OUTOFMEMORY;
				VariantClear(&resvar);
				goto Cleanup;
			}
			lstrcpy(*result,rescpy);
		}
		else
			*result = NULL;
		VariantClear(&resvar);
	}

Cleanup:
    VariantClear(&varresult);
	VariantClear(&args[0]);
	VariantClear(&args[1]);
	
	return hr;
}

STDMETHODIMP CScriptSite::GetLCID(LCID *plcid)
{
    UNREFERENCED_PARAMETER(plcid);
	return E_NOTIMPL;
}
STDMETHODIMP CScriptSite::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppTypeInfo)
{
    UNREFERENCED_PARAMETER(ppTypeInfo);
	if (!pstrName || !ppunkItem)
		return E_POINTER;

	if ((StrCmpW(L"JSProxy",pstrName) == 0) && (dwReturnMask == SCRIPTINFO_IUNKNOWN))
	{
		*ppunkItem = (LPUNKNOWN)(IDispatch*)(CJSProxy*)m_punkJSProxy;
		(*ppunkItem)->AddRef();
		return S_OK;
	}
	else
		return TYPE_E_ELEMENTNOTFOUND;
}
STDMETHODIMP CScriptSite::GetDocVersionString(BSTR *pstrVersionString)
{
    UNREFERENCED_PARAMETER(pstrVersionString);
	return E_NOTIMPL;
}

// I am not interested it the transitioning of state or the status of where we are in
// the executing of the script.
STDMETHODIMP CScriptSite::OnScriptTerminate(const VARIANT *pvarResult,const EXCEPINFO *pexcepinfo)
{
    UNREFERENCED_PARAMETER(pvarResult);
    UNREFERENCED_PARAMETER(pexcepinfo);
	return S_OK;
}
STDMETHODIMP CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
    UNREFERENCED_PARAMETER(ssScriptState);
	return S_OK;
}
STDMETHODIMP CScriptSite::OnScriptError(IActiveScriptError *pase)
{
    UNREFERENCED_PARAMETER(pase);
	return S_OK;
}
STDMETHODIMP CScriptSite::OnEnterScript()
{
	return S_OK;
}
STDMETHODIMP CScriptSite::OnLeaveScript()
{
	return S_OK;
}

//
// IServiceProvider
//
//      Implemented to help wire up the script engine with our
//      IInternetHostSecurityManager interface.
//

STDMETHODIMP CScriptSite::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void ** ppvObject)
{
    if (guidService == SID_SInternetHostSecurityManager)
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        return E_NOINTERFACE;
    }
}


//
// IInternetHostSecurityManager
// 
//      Implemented to prevent the script code from using ActiveX objects.
//

STDMETHODIMP CScriptSite::GetSecurityId( 
    BYTE *      pbSecurityId,
    DWORD *     pcbSecurityId,
    DWORD_PTR   dwReserved)
{
    UNREFERENCED_PARAMETER(pbSecurityId);
    UNREFERENCED_PARAMETER(pcbSecurityId);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_NOTIMPL;
}


STDMETHODIMP CScriptSite::ProcessUrlAction( 
    DWORD   dwAction,
    BYTE *  pPolicy,
    DWORD   cbPolicy,
    BYTE *  pContext,
    DWORD   cbContext,
    DWORD   dwFlags,
    DWORD   dwReserved)
{
    UNREFERENCED_PARAMETER(dwAction);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(cbContext);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwReserved);

    //
    // Deny the script any capabilites. In particular, this
    // will disallow the script code from instantiating 
    // ActiveX objects.
    //

    if (cbPolicy == sizeof(DWORD))
    {
        *(DWORD *)pPolicy = URLPOLICY_DISALLOW;
    }

    return S_FALSE; // S_FALSE means the policy != URLPOLICY_ALLOW.
}


STDMETHODIMP CScriptSite::QueryCustomPolicy( 
    REFGUID guidKey,
    BYTE ** ppPolicy,
    DWORD * pcbPolicy,
    BYTE *  pContext,
    DWORD   cbContext,
    DWORD   dwReserved)
{
    UNREFERENCED_PARAMETER(guidKey);
    UNREFERENCED_PARAMETER(ppPolicy);
    UNREFERENCED_PARAMETER(pcbPolicy);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(cbContext);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\unxutil.cpp ===
#include <windows.h>
#include <winsock.h>
#include <wininet.h>
#undef INTERNET_MAX_URL_LENGTH
#include "autoprox.hxx"

#define INET_ASSERT
#define DEBUG_PRINT(a,b,c)
#define PERF_LOG(a,b)

DWORD
AUTO_PROXY_HELPER_APIS::ResolveHostName(
    IN LPSTR lpszHostName,
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Resolves a HostName to an IP address by using Winsock DNS.
 
Arguments:
 
    lpszHostName   - the host name that should be used.
 
    lpszIPAddress  - the output IP address as a string.
 
    lpdwIPAddressSize - the size of the outputed IP address string.
 
Return Value:
 
    DWORD
        Win32 error code.
 
--*/
 
{
    //
    // figure out if we're being asked to resolve a name or an address. If
    // inet_addr() succeeds then we were given a string respresentation of an
    // address
    //
 
    DWORD ipAddr;
    LPBYTE address;
    LPHOSTENT lpHostent;
    DWORD ttl;
    DWORD dwIPAddressSize;
    BOOL bFromCache = FALSE;
 
    DWORD error = ERROR_SUCCESS;
 
    ipAddr = inet_addr(lpszHostName);
    if (ipAddr != INADDR_NONE)
    {
        dwIPAddressSize = lstrlen(lpszHostName);
 
        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
 
        lstrcpy(lpszIPAddress, lpszHostName);
        goto quit;
    }
 
    ipAddr = 0;
    address = (LPBYTE) &ipAddr;
 
    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //
 
//    if (QueryHostentCache(lpszHostName, address, &lpHostent, &ttl)) {
//        bFromCache = TRUE;
//    } else {
      {
 
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("resolving %q\n",
                    lpszHostName
                    ));
 
        PERF_LOG(PE_NAMERES_START, 0);
 
        lpHostent = gethostbyname(lpszHostName);
 
        PERF_LOG(PE_NAMERES_END, 0);
 
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    lpHostent ? "" : "NOT "
                    ));
 
 
        //
        // if we successfully resolved the name or address then add the
        // information to the cache
        //
 
        if (lpHostent != NULL)
        {
//            CacheHostent(lpszHostName, lpHostent, LIVE_DEFAULT);
        }
    }
 
 
    if ( lpHostent )
    {
        char *pszAddressStr;
        LPBYTE * addressList;
        struct  in_addr sin_addr;
 
        //     *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
        //              ((struct sockaddr_in*)lpSockAddr)->sin_addr
        //                   struct  in_addr sin_addr
 
        addressList         = (LPBYTE *)lpHostent->h_addr_list;
        *(LPDWORD)&sin_addr = *(LPDWORD)addressList[0] ;
 
        pszAddressStr = inet_ntoa (sin_addr);
 
        INET_ASSERT(pszAddressStr);
 
        dwIPAddressSize = lstrlen(pszAddressStr);
 
        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
 
        lstrcpy(lpszIPAddress, pszAddressStr);
 
        goto quit;
 
    }
 
    //
    // otherwise, if we get here its an error
    //
 
    error = ERROR_INTERNET_NAME_NOT_RESOLVED;
 
quit:
 
    if (bFromCache) {
 
        INET_ASSERT(lpHostent != NULL);
 
//        ReleaseHostentCacheEntry(lpHostent);
    }

    return error;
}

BOOL
AUTO_PROXY_HELPER_APIS::IsResolvable(
    IN LPSTR lpszHost
    )
 
/*++
 
Routine Description:
 
    Determines wheter a HostName can be resolved.  Performs a Winsock DNS query,
      and if it succeeds returns TRUE.
 
Arguments:
 
    lpszHost   - the host name that should be used.
 
Return Value:
 
    BOOL
        TRUE - the host is resolved.
 
        FALSE - could not resolve.
 
--*/
 
{
 
    DWORD dwDummySize;
    DWORD error;
 
    error = ResolveHostName(
                lpszHost,
                NULL,
                &dwDummySize
                );
 
    if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        return TRUE;
    }
    else
    {
        INET_ASSERT(error != ERROR_SUCCESS );
        return FALSE;
    }
 
}
DWORD
AUTO_PROXY_HELPER_APIS::GetIPAddress(
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Acquires the IP address string of this client machine WININET is running on.
 
Arguments:
 
    lpszIPAddress   - the IP address of the machine, returned.
 
    lpdwIPAddressSize - size of the IP address string.
 
Return Value:
 
    DWORD
        Win32 Error.
 
--*/
 
{
 
    CHAR szHostBuffer[255];
    int serr;
 
    serr = gethostname(
                szHostBuffer,
                255-1 
                );
 
    if ( serr != 0)
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }
 
    return ResolveHostName(
                szHostBuffer,
                lpszIPAddress,
                lpdwIPAddressSize
                );
 
}

BOOL
AUTO_PROXY_HELPER_APIS::IsInNet(
    IN LPSTR   lpszIPAddress,
    IN LPSTR   lpszDest,
    IN LPSTR   lpszMask
    )
 
/*++
 
Routine Description:
 
    Determines whether a given IP address is in a given dest/mask IP address.
 
Arguments:
 
    lpszIPAddress   - the host name that should be used.
 
    lpszDest        - the IP address dest to check against.
 
    lpszMask        - the IP mask string
 
Return Value:
 
    BOOL
        TRUE - the IP address is in the given dest/mask
 
        FALSE - the IP address is NOT in the given dest/mask
 
--*/
 
{
    DWORD dwDest, dwIpAddr, dwMask;
 
    INET_ASSERT(lpszIPAddress);
    INET_ASSERT(lpszDest);
    INET_ASSERT(lpszMask);
 
    dwIpAddr = inet_addr(lpszIPAddress);
    dwDest = inet_addr(lpszDest);
    dwMask = inet_addr(lpszMask);
 
    if ( dwDest   == INADDR_NONE ||
         dwIpAddr == INADDR_NONE  )
 
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
 
        if ( (dwIpAddr & dwMask) != dwDest)
    {
        return FALSE;
        }
 
    //
    // Pass, its Matches.
    //
 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\jsproxy.cpp ===
/********************************************************************************
/	This is the base file to the Microsoft JScript Proxy Configuration 
/	This file implements the code to provide the script site and the JSProxy psuedo
/	object for the script engine to call against.
/
/	Created		11/27/96	larrysu
/
/
/
/
/
/
/
/
/
*/
#include "jsproxy.h"


/*******************************************************************************
*	JSProxy functions.
********************************************************************************/
CJSProxy::CJSProxy()
{
	m_refCount = 1;
	m_fDestroyable = FALSE;
	m_fInitialized = FALSE;
	m_pCallout = NULL;
}

CJSProxy::~CJSProxy()
{
	if(m_fInitialized)
		DeInit();
}

STDMETHODIMP CJSProxy::Init(AUTO_PROXY_HELPER_APIS* pAPHA)
{

	m_strings[0] = L"isPlainHostName";
	m_strings[1] = L"dnsDomainIs";
	m_strings[2] = L"localHostOrDomainIs";
	m_strings[3] = L"isResolvable";
	m_strings[4] = L"isInNet";
	m_strings[5] = L"dnsResolve";
	m_strings[6] = L"myIpAddress";
	m_strings[7] = L"dnsDomainLevels";
	m_strings[8] = L"shExpMatch";
	m_strings[9] = L"weekdayRange";
	m_strings[10] = L"dateRange";
	m_strings[11] = L"timeRange";
	m_strings[12] = L"alert";
	
	m_pCallout = pAPHA;
	m_fInitialized = TRUE;
	return S_OK;
}

STDMETHODIMP CJSProxy::DeInit()
{
	m_pCallout = NULL;
	m_fInitialized = FALSE;
	return S_OK;
}
//IDispatch functions for JSProxy.  I want these to be light and fast.
STDMETHODIMP CJSProxy::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid)
{
	// Use addition of first 4 chars to make quick cheesy hash of which function wants to be called.
	// These are values are #defined in JSProxy.h
	HRESULT		hr = S_OK;
	long		strval = 0;
	unsigned long		nameindex = 0;
	OLECHAR*	currentName = NULL;

	if (!*rgszNames)
		return E_POINTER;
	if (cNames < 1)
		return E_INVALIDARG;

	while (nameindex < cNames)
	{
		currentName = rgszNames[nameindex];
		if (currentName == NULL)
			break;
		
		strval = currentName[0]+currentName[1]+currentName[2]+currentName[3]+currentName[4];

		switch (strval)
		{

			case VAL_myIpAddress :
					if (StrCmpW(m_strings[6],currentName) == 0)
						rgdispid[nameindex] = DISPID_myIpAddress;
					else
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;

			case VAL_isInNet :
					if (StrCmpW(m_strings[4],currentName) == 0)
						rgdispid[nameindex] = DISPID_isInNet;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_dateRange :
					if (StrCmpW(m_strings[10],currentName) == 0)
						rgdispid[nameindex] = DISPID_dateRange;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_dnsDomainIs : // This is also VAL_dnsDomainLevels check for both strings.
					if (StrCmpW(m_strings[7],currentName) == 0)
						rgdispid[nameindex] = DISPID_dnsDomainLevels;
					else 
					{
						if (StrCmpW(m_strings[1],currentName) == 0)
							rgdispid[nameindex] = DISPID_dnsDomainIs;
						else 
						{
							rgdispid[nameindex] = DISPID_UNKNOWN;
							hr = DISP_E_UNKNOWNNAME;
						}
					}
					break;
			
			case VAL_isPlainHostName :
					if (StrCmpW(m_strings[0],currentName) == 0)
						rgdispid[nameindex] = DISPID_isPlainHostName;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_dnsResolve :
					if (StrCmpW(m_strings[5],currentName) == 0)
						rgdispid[nameindex] = DISPID_dnsResolve;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_timeRange :
					if (StrCmpW(m_strings[11],currentName) == 0)
						rgdispid[nameindex] = DISPID_timeRange;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_isResolvable :
					if (StrCmpW(m_strings[3],currentName) == 0)
						rgdispid[nameindex] = DISPID_isResolvable;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_shExpMatch :
					if (StrCmpW(m_strings[8],currentName) == 0)
						rgdispid[nameindex] = DISPID_shExpMatch;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_localHostOrDomainIs :
					if (StrCmpW(m_strings[2],currentName) == 0)
						rgdispid[nameindex] = DISPID_localHostOrDomainIs;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_weekdayRange :
					if (StrCmpW(m_strings[9],currentName) == 0)
						rgdispid[nameindex] = DISPID_weekdayRange;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_alert :
					if (StrCmpW(m_strings[12],currentName) == 0)
						rgdispid[nameindex] = DISPID_alert;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			default :
					rgdispid[nameindex] = DISPID_UNKNOWN;
					hr = DISP_E_UNKNOWNNAME;
					break;

		}
		nameindex++;
	}
	return hr;
	
}

STDMETHODIMP CJSProxy::Invoke(
				DISPID dispidMember,
				REFIID riid,
				LCID lcid,
				WORD wFlags,
				DISPPARAMS* pdispparams,
				VARIANT* pvarResult,
				EXCEPINFO* pexcepinfo,
				UINT* puArgErr)
{
	HRESULT hr = S_OK;
	
	if (dispidMember > 0x000d)
		return DISP_E_MEMBERNOTFOUND;

	if (!(wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD)))
	{
		return DISP_E_MEMBERNOTFOUND;
	}

	// The big switch based on DISPID!
	switch (dispidMember)
	{
/*****************************************************************************
	Calling isPlainHostName 
*****************************************************************************/
	case DISPID_isPlainHostName :
		{
			// look in the DISPARAMS to make sure the signiture is correct for this function.
			if (pdispparams->cArgs != 1)
				hr = DISP_E_BADPARAMCOUNT;
			if (pdispparams->cNamedArgs > 0)
				hr = DISP_E_NONAMEDARGS;

			if (FAILED(hr))
				break;
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call isPlainHostName.
			hr = isPlainHostName(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling dnsDomainIs
*****************************************************************************/
	case DISPID_dnsDomainIs :
		{
			if (pdispparams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			VARIANT arg2;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg2 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			if (pdispparams->rgvarg[1].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[1];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call dnsDomainIs
			hr = dnsDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling localHostOrDomainIs
*****************************************************************************/
	case DISPID_localHostOrDomainIs :
		{
			if (pdispparams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			VARIANT arg2;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg2 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			if (pdispparams->rgvarg[1].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[1];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call localHostOrDomainIs
			hr = localHostOrDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling isResolvable
*****************************************************************************/
	case DISPID_isResolvable :
		{
			if (pdispparams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call isResolvable
			hr = isResolvable(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling isInNet
*****************************************************************************/
	case DISPID_isInNet :
		{
			int x;

			if (pdispparams->cArgs != 3)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT args[3];
			
			for (x=0;x<3;x++)
			{
				// check the type of the variant in the disparams and if it is a bstr use it
				if (pdispparams->rgvarg[x].vt == VT_BSTR)
					args[x] = pdispparams->rgvarg[x];
				// otherwise change it into one!  if this fails the return an error.
				else
				{
					hr = VariantChangeType(&args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
					if (FAILED(hr))
					{
						hr = DISP_E_TYPEMISMATCH;
						break;
					}
				}
			}
			if (FAILED(hr))
            {
                pvarResult->vt = VT_BOOL;
                pvarResult->boolVal = VARIANT_FALSE;
                hr = S_OK;
				break;
            }
			// call isInNet.  Args need to be reversed
			hr = isInNet(args[2].bstrVal,args[1].bstrVal,args[0].bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling dnsResolve
*****************************************************************************/
	case DISPID_dnsResolve :
		{
			if (pdispparams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call dnsResolve
			hr = dnsResolve(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling myIpAddress
*****************************************************************************/
	case DISPID_myIpAddress :
		// Should have no args and 1 named arg and the name should be DISPATCH_PROPERTYGET!
/*		if (pdispparams->cNamedArgs != 1)
		{
			hr = DISP_E_BADPARAMCOUNT;
			break;
		}
*/
		// call myIpAddress
		hr = myIpAddress(pvarResult);
		break;
/*****************************************************************************
	Calling dnsDomainLevels
*****************************************************************************/
	case DISPID_dnsDomainLevels :
		{
			if (pdispparams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call dnsDomainLevels
			hr = dnsDomainLevels(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling shExpMatch
*****************************************************************************/
	case DISPID_shExpMatch :
		{
			if (pdispparams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			VARIANT arg2;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg2 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			if (pdispparams->rgvarg[1].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[1];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call isPlainHostName.
			hr = shExpMatch(arg1.bstrVal,arg2.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling weekdayRange
*****************************************************************************/
	case DISPID_weekdayRange :
		{
			unsigned int x;

			if ((pdispparams->cArgs > 3) || (pdispparams->cArgs < 1))
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT* args[3] = {NULL,NULL,NULL};
			
			for (x=0;x<pdispparams->cArgs;x++)
			{
				args[x] = new(VARIANT);
                if( !(args[x]) )
                {
                       hr = E_OUTOFMEMORY;
                       break;
                }

				// check the type of the variant in the disparams and if it is a bstr use it
				if (pdispparams->rgvarg[x].vt == VT_BSTR)
					*args[x] = pdispparams->rgvarg[x];
				// otherwise change it into one!  if this fails the return an error.
				else
				{
					hr = VariantChangeType(args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
					if (FAILED(hr))
					{
						hr = DISP_E_TYPEMISMATCH;
						break;
					}
				}
			}
			if (FAILED(hr))
				break;
			// call isInNet.  Args need to be reversed
			switch (pdispparams->cArgs)
			{
			case 1:
				hr = weekdayRange(args[0]->bstrVal,NULL,NULL,pvarResult);
				break;
			case 2:
				if ((args[0]->bstrVal[0] == 'G') || (args[0]->bstrVal[0] == 'g'))
					hr = weekdayRange(args[1]->bstrVal,NULL,args[0]->bstrVal,pvarResult);
				else
					hr = weekdayRange(args[1]->bstrVal,args[0]->bstrVal,NULL,pvarResult);
				break;
			case 3:
				hr = weekdayRange(args[2]->bstrVal,args[1]->bstrVal,args[0]->bstrVal,pvarResult);
				break;
			}
			break;
		}
/*****************************************************************************
	Calling dateRange
*****************************************************************************/
	case DISPID_dateRange :
		break;
/*****************************************************************************
	Calling timeRange
*****************************************************************************/
	case DISPID_timeRange :
		break;
/*****************************************************************************
	Calling alert 
*****************************************************************************/
	case DISPID_alert :
		{
			// look in the DISPARAMS to make sure the signiture is correct for this function.
			if (pdispparams->cArgs != 1)
				hr = DISP_E_BADPARAMCOUNT;
			if (pdispparams->cNamedArgs > 0)
				hr = DISP_E_NONAMEDARGS;

			if (FAILED(hr))
				break;
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call alert.
			hr = alert(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Default returning error code
*****************************************************************************/
	default:
		hr = DISP_E_MEMBERNOTFOUND;
	}

	return hr;
}


//  JScript Auto-Proxy config functions.
STDMETHODIMP CJSProxy::isPlainHostName(BSTR host, VARIANT* retval)
{
	WCHAR	*currentch;
	BOOL	bfound = FALSE;

	if (!host || !retval)
		return E_POINTER;

	retval->vt = VT_BOOL;

	// check to detemine whether this is a plain host name!
	currentch = host;
	while ((*currentch != '\0') && !bfound)
	{
		if (*currentch == '.')
			bfound = TRUE;
		else
			currentch++;
	}

	if (bfound)
		retval->boolVal = VARIANT_FALSE;
	else
		retval->boolVal = VARIANT_TRUE;

	return S_OK;
}

STDMETHODIMP CJSProxy::dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval)
{
	WCHAR *result = NULL;

	if (!host || !domain || !retval)
		return E_POINTER;
	
	result = StrStrW(host,domain);
	retval->vt = VT_BOOL;
	if (result)
		retval->boolVal = VARIANT_TRUE;
	else
		retval->boolVal = VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CJSProxy::localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval)
{
	HRESULT	hr = S_OK;

	if (!host || !hostdom || !retval)
		return E_POINTER;

	// check to see if it is a local host
	hr = isPlainHostName(host,retval);
	if (SUCCEEDED(hr))
	{
		if (retval->boolVal != VARIANT_TRUE)
        {
            //
            // this is a strange function, if its not a local hostname
            //  we do a strait compare against the passed in domain
            //  string.  If its not a direct match, then its FALSE,
            //  even if the root of the domain/hostname are the same.
            //  Blame Netscape for this, we are just following their
            //  behavior and docs.
            //

            if ( StrCmpIW(host, hostdom) == 0 )
            {
                retval->boolVal = VARIANT_TRUE;
            }
            else
            {
                retval->boolVal = VARIANT_FALSE;
            }

        }
	}

	return hr;
}

// Functions that need to call back on wininet.
STDMETHODIMP CJSProxy::isResolvable(BSTR host, VARIANT* retval)
{
	
	if (!host || !retval)
		return E_POINTER;
	// call into wininet provided functions!
	retval->vt = VT_BOOL;
	if (m_pCallout)
	{
		MAKE_ANSIPTR_FROMWIDE(szhost,host);
		if (m_pCallout->IsResolvable(szhost)) 
			retval->boolVal = VARIANT_TRUE;
		else
			retval->boolVal = VARIANT_FALSE;
	}
	else
		retval->boolVal = VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CJSProxy::isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval)
{
	VARIANT	myretval;
	HRESULT	hr = S_OK;
	
	// call into wininet provided functions!
	if (!host || !pattern || !mask || !retval)
		return E_POINTER;
	// call into wininet provided functions!
	retval->vt = VT_BOOL;
	VariantInit(&myretval);

	if (m_pCallout)
	{
		hr = dnsResolve(host,&myretval);
		if (SUCCEEDED(hr))
		{
			if (myretval.vt != VT_BSTR)
			{	
				VariantClear(&myretval);
				retval->boolVal = VARIANT_FALSE;		
				return hr;
			}
		}
		else
		{
			VariantClear(&myretval);
			retval->boolVal = VARIANT_FALSE;
			return hr;	
		}

		// Fallthrough to code to check IP/pattern and mask!
	
		MAKE_ANSIPTR_FROMWIDE(szhost,myretval.bstrVal);
		MAKE_ANSIPTR_FROMWIDE(szpattern,pattern);
		MAKE_ANSIPTR_FROMWIDE(szmask,mask);

		//  Check to see if IP address from dnsResolve matches the pattern/mask!
        if ( m_pCallout->IsInNet(szhost, szpattern, szmask ) ) 
			retval->boolVal = VARIANT_TRUE;
		else
			retval->boolVal = VARIANT_FALSE;
	}
	else
		retval->boolVal = VARIANT_FALSE;
	
	VariantClear(&myretval);
	return S_OK;
}

STDMETHODIMP CJSProxy::dnsResolve(BSTR host, VARIANT* retval)
{
	char ipaddress[16];
	DWORD dwretval;
	DWORD dwipsize = 16;

	if (!host || !retval)
		return E_POINTER;
	// call into wininet provided functions!

	if (m_pCallout)
	{
		MAKE_ANSIPTR_FROMWIDE(szhost,host);
		dwretval = m_pCallout->ResolveHostName(szhost,ipaddress,&dwipsize); 
		if (dwretval == ERROR_SUCCESS)
		{
			retval->vt = VT_BSTR;
			retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
		}
		else
		{
			retval->vt = VT_BOOL;
			retval->boolVal = VARIANT_FALSE;
		}
	}
	else
	{	
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_FALSE;
	}

	return S_OK;
}

STDMETHODIMP CJSProxy::myIpAddress(VARIANT* retval)
{
	char ipaddress[16];
	DWORD dwretval;
	DWORD dwipsize = 16;

	if (!retval)
		return E_POINTER;
	// call into wininet provided functions!

	if (m_pCallout)
	{
		dwretval = m_pCallout->GetIPAddress(ipaddress,&dwipsize);
		if (dwretval == ERROR_SUCCESS)
		{
			retval->vt = VT_BSTR;
			retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
		}
		else
		{
			retval->vt = VT_BOOL;
			retval->boolVal = VARIANT_FALSE;
		}
	}
	else
	{	
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_FALSE;
	}

	return S_OK;
}

// Back to functions implemented here.
STDMETHODIMP CJSProxy::dnsDomainLevels(BSTR host, VARIANT* retval)
{
	WCHAR	*currentch;
	DWORD	dwlevels = 0;

	if (!host || !retval)
		return E_POINTER;

	retval->vt = VT_I4;

	// check to detemine whether this is a plain host name!
	currentch = host;
	while (*currentch != L'\0')
	{
		if (*currentch == L'.')
			dwlevels++;

		currentch++;
	}

	retval->lVal = dwlevels;

	return S_OK;
}

STDMETHODIMP CJSProxy::shExpMatch(BSTR str, BSTR shexp, VARIANT* retval)
{

	if (!str || !shexp || !retval)
		return E_POINTER;

	retval->vt = VT_BOOL;
	// convert BSTR to ansi - these macros allocate memory that is freed when they
	// go out of scope!  No need to free!
	MAKE_ANSIPTR_FROMWIDE(szstr, str);
	MAKE_ANSIPTR_FROMWIDE(szshexp, shexp);
	// Call into the regular expression matching code.
	if (match(szstr,szshexp))
		retval->boolVal = VARIANT_TRUE;
	else
		retval->boolVal = VARIANT_FALSE;

	return S_OK;
}

// These are to do last!!!.
STDMETHODIMP CJSProxy::weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval)
{
	SYSTEMTIME	systime;
	SYSTEMTIME	loctime;
	char		szday[4];
	int			today = -1;
	int			day1 = -1; // days are as follows SUN = 0; MON = 1; ...;SAT = 6.
	int			day2 = -1;  
	BOOL		bIsInRange = FALSE;

	if (!wd1)
		return E_POINTER;
	if (gmt)
		GetSystemTime(&systime);

	GetDateFormat(//LOCALE_SYSTEM_DEFAULT,
					MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT),
					NULL,
					gmt? &systime:NULL,
					"ddd",
					szday,
					4);

	if (szday)
	{
		int lcv;
		//convert all chars to upper if lowercase (don't use runtimes)
		for (lcv=0;lcv<3;lcv++)
		{
			if ((short)szday[lcv] > 90)
				szday[lcv]-=32;
		}

		today = ConvertAnsiDayToInt(szday);
	}
	
	if (today == -1)
		return E_FAIL;
	
	// compare day ranges!
	if (wd2)
	{
		// These are by definition in ALL CAPS
		MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
		MAKE_ANSIPTR_FROMWIDE(szwd2, wd2);
		if (szwd1 && szwd2)
		{
			day1 = ConvertAnsiDayToInt(szwd1);
			day2 = ConvertAnsiDayToInt(szwd2);
		}

		if ((day1 == -1) || (day2 == -1))
			return E_INVALIDARG;

		if (day1 < day2)
		{
			if ((today >= day1) && (today <= day2))
				bIsInRange = TRUE;
			else
				bIsInRange = FALSE;
		}
        else if ( day1 == day2 )
        {
            if (today == day1)
            {
                bIsInRange = TRUE;
            }
            else
            {
                bIsInRange = FALSE;
            }
        }
		else
		{
			if ((today >= day1) || (today <= day2))
                bIsInRange = TRUE;
			else
				bIsInRange = FALSE;
		}

	}
	else // only one day to check!
	{
		MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
		if (lstrcmp(szday,szwd1) == 0)
			bIsInRange = TRUE;
		else
			bIsInRange = FALSE;
	}

	if (bIsInRange)
	{
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_TRUE;
	}
	else
	{
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_FALSE;
	}

	return S_OK;
}

STDMETHODIMP CJSProxy::dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval)
{
	return S_OK;
}
STDMETHODIMP CJSProxy::timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval)
{
	return S_OK;
}

STDMETHODIMP CJSProxy::alert(BSTR message, VARIANT* retval)
{
    if (!message)
        return E_POINTER;

    // Return true if available...not needed?
    if (retval)
    {
	    retval->vt = VT_BOOL;
        retval->vt = VARIANT_TRUE;
    }

    MAKE_ANSIPTR_FROMWIDE(szMessage,message);

    // Display the alert which isn't truly modal to the browser.
    // Getting the appropriate window handle will be quite a chore from here.
    MessageBox(
        NULL,
        szMessage,
        TEXT("Microsoft Internet Explorer"),
        MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST | MB_TASKMODAL
        );

    return S_OK;
}

// don't yet know what to do with ProxyConfig.bindings.
//ProxyConfig.bindings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\utils.cpp ===
#include "utils.h"

//----------------------------------------------------------------------------
// HELPER FUNCTIONS
//----------------------------------------------------------------------------


// Function to get the coclass ClassId of a script engine given its name

HRESULT GetScriptEngineClassIDFromName(
	LPCSTR pszLanguage,
	LPSTR pszBuff,
	UINT cBuffSize)
{
	HKEY hKey = NULL;
	HKEY hKeySub;
	LONG result;
	HRESULT hr;
	LONG cClassIdLen;

	// Open \HKEY_CLASSES_ROOT\[pszLanguage]

	// LONG RegOpenKeyEx(
    //	HKEY	hKey,		// handle of open key
    //	LPCTSTR	lpSubKey,	// address of name of subkey to open
    //	DWORD	ulOptions,	// reserved
    //	REGSAM	samDesired,	// security access mask
    //	PHKEY	phkResult 	// address of handle of open key
	// );	

	result = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszLanguage, 0, KEY_READ, &hKey);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	// Make sure this object supports OLE Scripting

	result = RegOpenKeyEx(hKey, "OLEScript", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	RegCloseKey(hKeySub);

	// Get the class ID

	// LONG RegQueryValueEx(
    //	HKEY	hKey,			// handle of key to query
    //	LPTSTR	lpValueName,	// address of name of value to query
    //	LPDWORD	lpReserved,		// reserved
    //	LPDWORD	lpType,			// address of buffer for value type
    //	LPBYTE	lpData,			// address of data buffer
    //	LPDWORD	lpcbData	 	// address of data buffer size
    // );

	result = RegOpenKeyEx(hKey, "CLSID", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	cClassIdLen = cBuffSize;
	result = RegQueryValue(hKeySub, NULL, pszBuff, &cClassIdLen);

	RegCloseKey(hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	pszBuff[cBuffSize-1] = '\0';

	hr = S_OK;

exit:
	if (hKey) {
		RegCloseKey(hKey);
	}

	return hr;
}


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPCSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr, +1 for terminating null
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        return NULL;
                ;
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

int ConvertAnsiDayToInt(LPSTR szday)
{
	int today = -1;
	if (szday)  // GetDateFormat always returns mixed caps and since this comes from a Win32 API I will
	{			// assume a properly formatted string! :)
		switch (szday[0])
		{
		case 'S' :
			if (lstrcmp(szday,"SUN") == 0)
				today = 0;
			else
			{
				if (lstrcmp(szday,"SAT") == 0)	
					today = 6;
			}
			break;

		case 'M' :
			if (lstrcmp(szday,"MON") == 0)
				today = 1;
			break;

		case 'T' :
			if (lstrcmp(szday,"TUE") == 0)
				today = 2;
			else
			{
				if (lstrcmp(szday,"THU") == 0)	
				today = 4;
			}
			break;

		case 'W' :
			if (lstrcmp(szday,"WED") == 0)
				today = 3;
			break;

		case 'F' :
			if (lstrcmp(szday,"FRI") == 0)
				today = 5;
			break;
		
		}
	}
	return today;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ckcnv\ckcnv.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  ckcnv.cxx

Abstract:
  Upgrades cookies to present urlcache format by enumerating cookie files in the
  cache cookies directory and creates cookie cache index entries in the format of 
  the current wininet.dll. 
    
Author:
    Adriaan Canter (adriaanc) 09-Jan-1997
        Created

    Adriaan Canter (adriaanc) 01-Feb-1997    
        Modified for per-user caches. The class CCookieLoader definition 
        can now be pasted into the urlcache build without re-definition
        and work correctly, as long as the HKLM and HKCU cache keys are
        not modified. BUGBUG - do this.

-----------------------------------------------------------------------------*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wininet.h>
#include "cachedef.h"

#define INET_ASSERT(condition) Assert(condition)

/*-----------------------------------------------------------------------------
    GetHKLMHistoryDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKLMHistoryDirectory(CHAR *szHistoryDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    // Skip the level of indirection for url history.
    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Url History",
        NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szHistoryDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;


exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKCUHistoryDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKCUHistoryDirectory(CHAR *szHistoryDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szHistoryDirRegKey[MAX_PATH];
    strcpy(szHistoryDirRegKey, OLD_CACHE_KEY);
    strcat(szHistoryDirRegKey, "\\");
    strcat(szHistoryDirRegKey, HISTORY_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER, 
        szHistoryDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_PATH_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szHistoryDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}


/*-----------------------------------------------------------------------------
    GetHKLMCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, OLD_CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, CACHE_SPECIAL_PATHS_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKCUCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKCUCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, OLD_CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER, 
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_PATH_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKLMContentDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKLMContentDirectory(CHAR *szContentDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szContentDirRegKey[MAX_PATH];
    strcpy(szContentDirRegKey, CACHE_PATHS_FULL_KEY);

    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        szContentDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szContentDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKCUContentDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKCUContentDirectory(CHAR *szContentDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szContentDirRegKey[MAX_PATH];
    strcpy(szContentDirRegKey, OLD_CACHE_KEY);
    strcat(szContentDirRegKey, "\\");
    strcat(szContentDirRegKey, CONTENT_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER, 
        szContentDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_PATH_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szContentDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}



/*-----------------------------------------------------------------------------
    class CCookieLoader

    Class used to perform cookie conversion
  ----------------------------------------------------------------------------*/
class CCookieLoader
{
public:
    CHAR* ParseNextCookie(CHAR*, CHAR**, FILETIME*, FILETIME*);    
    DWORD LoadCookies(BOOL);
};


// Debug assert code.
#if DBG
#define Assert(Predicate) \
    { \
        if (!(Predicate)) \
            AssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
AssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else
#define Assert(_x_)
#endif // DBG


/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0 
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;
   
    __try
    {
        // Get the first token (cookie name).
        pszName           = strtok(ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = strtok(NULL, "\n");      // Cookie value.
        *ppszHash         = strtok(NULL, "\n");      // Combo of domain and path.
        pszFlags          = strtok(NULL, "\n");      // Cookie flags.
        pszExpireTimeLow  = strtok(NULL, "\n");      // Expire time.
        pszExpireTimeHigh = strtok(NULL, "\n");             
        pszLastTimeLow    = strtok(NULL, "\n");      // Last Modified time.
        pszLastTimeHigh   = strtok(NULL, "\n");
        pszDelimiter      = strtok(NULL, "\n");      // Delimiter should be "*"

    
        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            INET_ASSERT(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);        

        pszNextCookie = pszDelimiter+2;
    }
    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        pszNextCookie = 0;
        goto exit;
    }

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(BOOL fConvertToPerUser)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szHKCUCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],    
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];
                    
    CHAR               *pszHash, *ptr, *pszCookiesPath,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE bCacheEntryInfoBuffer[2 * PAGE_SIZE];
    INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer;

    // Strictly enforced syntax: requires this to be initialized
    // before the try block is entered.
    szBuffer = 0;

    __try
    {   

        // Check to see if we are upgrading cookies
        // from local machine to per user.
        if (fConvertToPerUser)
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.            
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            if (dwError = GetHKLMCookiesDirectory(szHKLMCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);

            // Get the cookies directory as specified by HKCU.
            if (dwError = GetHKCUCookiesDirectory(szHKCUCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            strcat(szCookieFileNamePattern, "\\");
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");
        
            // Enumerate the users cache files        
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind == INVALID_HANDLE_VALUE)
            {
                // OK, No cookie files to upgrade.
                dwError = ERROR_SUCCESS;
                goto exit;
            }    
        
            // One or more cookie files exist.
            do
            {
                // Construct absolute path from HKLM to cookies file.
                strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                strcat(szHKLMCookieFileName, "\\");
                strcat(szHKLMCookieFileName, FindData.cFileName);
                
                // Construct absolute path from HKCU to cookies file.
                strcpy(szHKCUCookieFileName, szHKCUCookiesPath);
                strcat(szHKCUCookieFileName, "\\");
                strcat(szHKCUCookieFileName, FindData.cFileName);
            
                // Copy the file to the per-user directory.
                CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);

            } while (FindNextFile(hFind, &FindData)); 
        
            // Close the Find handle.
            if (hFind != INVALID_HANDLE_VALUE)
            {
                FindClose(hFind);        
                hFind = INVALID_HANDLE_VALUE;
            }

        } // Per-user upgrade.
        else
        {
            // No per-user upgrade. szCookieFileNamePattern will look like
            // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, "\\*@*.txt");
        }

        // We now have the appropriate cookie filename pattern, also need a copy
        // of the cookies directory associated with the current user.
        pszCookiesPath = (fConvertToPerUser ? szHKCUCookiesPath : szHKLMCookiesPath);
        
        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }    

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            strcpy(szCookieFileName, pszCookiesPath);
            strcat(szCookieFileName, "\\");
            strcat(szCookieFileName, FindData.cFileName);
            
            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );                   

            // File handle must be valid.
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? -> 
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                INET_ASSERT(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie, 
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"            
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);
                        ptr = strstr(szCookieName, "@");
                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (INTERNET_CACHE_ENTRY_INFO*) bCacheEntryInfoBuffer;
                        cbCacheEntryInfoBuffer = sizeof(bCacheEntryInfoBuffer);

                        dwError = GetUrlCacheEntryInfo(szCookieName, pCacheEntryInfo, 
                            &cbCacheEntryInfoBuffer);

                        if (dwError == ERROR_SUCCESS 
                            && CompareFileTime(&pCacheEntryInfo->LastModifiedTime, &ftLast) > 0)
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or 
                            // it was found and the last modified time on it is 
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.
                            BOOL bCommit;
                            bCommit = CommitUrlCacheEntry(
                                szCookieName,           // cookie:user@foobar.com.
                                szCookieFileName,       // c:\winnt\cookies\user@foobar.txt.
                                ftExpire,               // Expire time.
                                ftLast,                 // Last modified time.
                                0,                      // CacheEntryType.
                                0,                      // HeaderInfo.
                                0,                      // HeaderSize.
                                0,                      // FileExtension.
                                0);                     // Reserved.

                            INET_ASSERT(bCommit);
                        } 

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.
                    
        } while (FindNextFile(hFind, &FindData)); 

        
        // No more cookie files or an error occured.        
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);

        return dwError;

    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
                
        INET_ASSERT(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
        return dwError;
    }

}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DWORD dwError;
    CHAR szFilename[MAX_PATH];
    CHAR szHistoryIndexFile[MAX_PATH];
    CHAR szCookiesIndexFile[MAX_PATH];
    CHAR szContentIndexFile[MAX_PATH];
    CCookieLoader cc;

    __try
    {
    
        // Convert cookies. Note, for ckcnv, we never
        // upgrade to per-user.
        dwError = cc.LoadCookies(FALSE);

        // Nuke all index.dat files so that re-installations will init properly.
        // Take care of HKLM entries only.

        // Content
        if (GetHKLMContentDirectory(szContentIndexFile) == ERROR_SUCCESS)
        {
            strcat(szContentIndexFile, "\\");
            strcat(szContentIndexFile, MEMMAP_FILE_NAME);
            DeleteFile(szContentIndexFile);
        }

        // Cookies
        if (GetHKLMCookiesDirectory(szCookiesIndexFile) == ERROR_SUCCESS)
        {
            strcat(szCookiesIndexFile, "\\");
            strcat(szCookiesIndexFile, MEMMAP_FILE_NAME);
            DeleteFile(szCookiesIndexFile);
        }

        // History
        if (GetHKLMHistoryDirectory(szHistoryIndexFile) == ERROR_SUCCESS)
        {
            strcat(szHistoryIndexFile, "\\");
            strcat(szHistoryIndexFile, MEMMAP_FILE_NAME);
            DeleteFile(szHistoryIndexFile);
        }

        // See if we're supposed to delete this
        // executable after the user reboots.
        if (!_strnicmp(lpCmdLine, "/D", sizeof("/D")))
        {

            // Got this filename?
            if (GetModuleFileName(NULL, szFilename, MAX_PATH))
            {
                OSVERSIONINFO osVersionInfo;
                osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
                if (GetVersionEx(&osVersionInfo))
                {
                    // Two different methods of deleting this file
                    // depending on the platform ID.
                    if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
                    {
                        // Platform is Windows NT.
                        MoveFileEx(szFilename, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                    }
                    else
                    {
                        // Platform is Windows 95.
                        CHAR szString[MAX_PATH];
                        strcpy(szString, "NUL=");
                        strcat(szString, szFilename);
                        WritePrivateProfileSection("Rename", szString, "wininit.ini");

                    }
                }
            }
        }
    }
    

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_EXTENDED_ERROR;
    }

    return (dwError == ERROR_SUCCESS ? 0 : 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\autoconf\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

#include <windows.h>
#include <olectl.h>
#include <shlwapi.h>

// BUGBUG - remove and include wininet.h
#include "autoprox.hxx"

/********************************************************************************************/
// ClassID and GUID helpers
HRESULT GetScriptEngineClassIDFromName(LPCSTR pszLanguage,LPSTR pszBuff,UINT cBuffSize);

/********************************************************************************************/
// String Helper functions and macros
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? (char *)&m_szTmpBuf : (new(char[cBytes]));
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) delete m_pBuf;
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

LPWSTR MakeWideStrFromAnsi( LPCSTR, BYTE bType);
#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)

int ConvertAnsiDayToInt(LPSTR szday);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\buffer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains code to impliment a double buffering class used in SSL/PCT (secure channel)
        transactions.


Author:

    Arthur L Bierer (arthurbi) 20-March-1996

Revision History:

    20-March-1996 arthurbi
        Created

--*/

#include <wininetp.h>


BOOL
DBLBUFFER::InitBuffer(
    BOOL fDblBufferMode
    )

/*++

Routine Description:

    Allocates, and initalizes internal buffers.

Arguments:

    fDblBufferMode  - TRUE if we are to maintain to buffers,
                      FALSE if we treat the output and input buffers the same

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, not enough memory to allocate buffers.

Comments:


--*/

{
    DEBUG_ENTER((DBG_BUFFER,
                 Bool,
                 "DBLBUFFER::InitBuffer",
                 "%B",
                 fDblBufferMode
                 ));

    INET_ASSERT(_lpBuffer == NULL);
    INET_ASSERT(_dwInitDefaultBufferSize > 0 );

    _lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(_dwInitDefaultBufferSize);

    DEBUG_PRINT(API,
                INFO,
                ("allocated %d byte buffer %#x\n",
                _dwInitDefaultBufferSize,
                _lpBuffer
                ));

    BOOL success = FALSE;

    if (_lpBuffer != NULL) {

        INET_ASSERT(_dwBufferOut == 0);
        INET_ASSERT(_dwBufferIn == 0);

        _fDblBufferMode = fDblBufferMode;

        _dwBufferLength = _dwInitDefaultBufferSize ;
        _lpBufferOut = _lpBuffer + _dwBufferLength;
        _lpBufferIn      = _lpBuffer + _dwBufferLength;

        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}

DWORD
DBLBUFFER::GetInputBufferRemaining(
    VOID
    )

/*++

Routine Description:

    Determines the amount of free bytes availble for reading into the input buffer.
        Will attempt to push current data to the front of the buffer, to make the
        most room in the currently allocated buffer.

Arguments:

    none.

Return Value:

    DWORD
        Number of bytes free.

Comments:

        Assumed to only be called in DblBuffer mode.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Int,
                 "DBLBUFFER::GetInputBufferRemaining",
                 NULL
                 ));


    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );


    BOOL fIsInputBufferCompressed = (_lpBufferIn == _lpBuffer);

    if ( ! fIsInputBufferCompressed )
    {
        BOOL fIsSuccess;

        fIsSuccess = CompressInputBufferUsage( ) ;

        INET_ASSERT(fIsSuccess);
    }

    INET_ASSERT(_lpBufferIn == _lpBuffer );

    DEBUG_LEAVE((DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) ));

    return (DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) );
}

BOOL
DBLBUFFER::CopyIn(
    IN LPBYTE lpBuffer,
    IN DWORD dwBufferSize
    )
{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyIn",
                 "%x, %d",
                 lpBuffer,
                 dwBufferSize
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(dwBufferSize > 0);

    LPBYTE pbPointer;
    DWORD  dwCurInputSize;

    //
    // Get the current input buffer size
    //

    dwCurInputSize = GetInputBufferSize();

    if ( ! ResizeBufferIfNeeded(dwBufferSize) )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    pbPointer = GetInputBufferPointer()+dwCurInputSize;
    SetInputBufferSize(dwBufferSize+dwCurInputSize);


    CopyMemory(
        pbPointer,             // dest
        lpBuffer,              // src
        dwBufferSize           // size
        );


    DEBUG_LEAVE(TRUE);

    return TRUE;

}

BOOL
DBLBUFFER::CopyOut(
    OUT LPBYTE     lpBuffer,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN OUT LPDWORD lpdwBytesRead
    )

/*++

Routine Description:

    Fills passed in buffer with the contents of the output buffer.

Arguments:

    lpBuffer                    -       Buffer to fill with output buffer bytes

        lpdwBufferRemaining -   Number of bytes remaining in Buffer to fill.

        lpdwBytesReceived       -       Number of bytes currently in Buffer to fill.

        lpdwBytesRead           -       Current total of bytes copied into Buffer to fill.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:


--*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyOut",
                 "%x, %u, %u, %u",
                 lpBuffer,
                 (lpdwBufferRemaining ? *lpdwBufferRemaining : 0),
                 (lpdwBytesReceived ? *lpdwBytesReceived : 0),
                 (lpdwBytesRead ? *lpdwBytesRead : 0)
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(lpdwBufferRemaining);
    INET_ASSERT(lpdwBytesReceived);
    INET_ASSERT(lpdwBytesRead);

    //
    // Figure out the max number of bytes we can copy into our user's buffer
    //      We need to make sure it will fit into the user's buffer.
    //

    DWORD dwBytesToCopy = (*lpdwBufferRemaining  >= _dwBufferOut)
            ? _dwBufferOut : *lpdwBufferRemaining;


    DEBUG_PRINT(API,
                INFO,
                ("DBLBUFFER::CopyOut: Copying ( to: %x bytes-to-copy=%d )\n",
                (lpBuffer+*lpdwBytesReceived),
                dwBytesToCopy
                ));


    //
    // Transfer Data to User's buffer.
    //

    CopyMemory ((lpBuffer+*lpdwBytesReceived),
                            _lpBufferOut,
                            dwBytesToCopy);


    //
    // Update the number of bytes we copied to the user buffer
    //

    *lpdwBytesRead                  += dwBytesToCopy;
    *lpdwBytesReceived              += dwBytesToCopy;
    *lpdwBufferRemaining    -= dwBytesToCopy;

    //
    // Update Our Internal Vars
    //

    _dwBufferOut                    -= dwBytesToCopy;
    _lpBufferOut                    += dwBytesToCopy;

    UpdateVars();

    //
    // We always succeed for now !
    //

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::CompressInputBufferUsage(
    VOID
    )
/*++

Routine Description:

        Moves the input buffer to the begining of the internal allocated buffer.
        This produces a larger block of internal free space.

Arguments:

        none.

Return Value:

    BOOL
    Success - TRUE

    Success     - FALSE, there was no need to compress the buffer.

Comments:

  Assumed to be called only if DblBufferMode is enabled.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CompressInputBufferUsage",
                 NULL
                 ));

    BOOL bResult = FALSE;

    //
    // Maximize use of buffer by moving input data to the front
    // of the buffer.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0);
    INET_ASSERT(_fDblBufferMode);

    if (_lpBufferIn > _lpBuffer) {

        DEBUG_PRINT(API,
                    INFO,
                    ("compressing input buffer %d (%#x) @ %#x => %#x\n",
                    _dwBufferIn,
                    _dwBufferIn,
                    _lpBufferIn,
                    _lpBuffer
                    ));

        MoveMemory(_lpBuffer,
                   _lpBufferIn,
                   _dwBufferIn
                   );

        //
        // Input Buffer now starts at the begining of the allocated buffer
        //

        _lpBufferIn = _lpBuffer;
        bResult = TRUE;
    }

    DEBUG_LEAVE(bResult);

    return bResult;
}



BOOL
DBLBUFFER::ConcatenateOutputBufferUsage(
    IN LPBYTE lpSecondOutputBuffer,
    IN DWORD  dwSecondOutputBufferSize
    )

/*++

Routine Description:

    Combines the current output buffer with the contents of a new buffer.
    (Note: intented for use in combining decrypted data which may be seperated by
    header or trailer data)

Arguments:

    lpSecondOutputBuffer        - New Buffer to combine with internal output buffer.

    dwSecondOutputBufferSize    - Size of New Buffer in bytes.


Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    If the internal buffer is sized 0, the new buffer replaces the internal buffer.
    Its assumed that the New buffer is a former input buffer turned output by
    some external operation, such as a block decryption operation.
--*/

{


    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ConcatenateOutputBufferUsage",
                 "%x, %u",
                 lpSecondOutputBuffer,
                 dwSecondOutputBufferSize
                 ));


    //
    // Combinate Two buffers into one.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_fDblBufferMode );
    INET_ASSERT(lpSecondOutputBuffer);
    INET_ASSERT(dwSecondOutputBufferSize);

    INET_ASSERT(_lpBufferOut < _lpBufferIn );
    INET_ASSERT(lpSecondOutputBuffer >= _lpBuffer && lpSecondOutputBuffer <=_lpEndOfBuffer );



    if ( _dwBufferOut != 0 )
    {
        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ConcatenateOutputBufferUsage: Combining new data with output buffer\n"
                    ));

        MoveMemory((_lpBufferOut+_dwBufferOut),
                   lpSecondOutputBuffer,
                   dwSecondOutputBufferSize);
        //
        // Output Buffer is now bigger ( sum of orginal + new buffer size )
        //

        _dwBufferOut += dwSecondOutputBufferSize;

    }
    else
    {
        //
        // No previous output buffer, new buffer becomes output buffer
        //

        INET_ASSERT(_lpBufferOut == _lpEndOfBuffer );

        _lpBufferOut = lpSecondOutputBuffer;
        _dwBufferOut = dwSecondOutputBufferSize;

    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}


BOOL
DBLBUFFER::ResizeBufferIfNeeded(
    IN DWORD dwAddlBufferNeeded
    )

/*++

Routine Description:

    ReSizes internal buffer space to extend size of the buffer by dwAddlBufferNeeded.
    If the additional bytes can be made availble by compressing currently stored
    into one place ( ie the start of the buffer ), the reallocation of the buffer
    will not be done.

Arguments:

    dwAddlBufferNeeded  - Number of additional bytes to resize

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, the reallocation failed due to lack of memory.

Comments:

    Its assumed the caller will only use this function in dbl buffering mode.

 --*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ResizeBufferIfNeeded",
                 "%u",
                 dwAddlBufferNeeded
                 ));

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DWORD dwInputBytesFree = GetInputBufferRemaining();

    INET_ASSERT(_lpBuffer == _lpBufferIn );

    //
    // #bytes needed > #bytes left free in Buffer.
    //

    if ( dwAddlBufferNeeded > dwInputBytesFree )
    {
        HLOCAL hBuffer;

        hBuffer = (HLOCAL) _lpBuffer;

        //
        // length increases by (bytes needed - current bytes free[in old buffer])
        //

        _dwBufferLength += (dwAddlBufferNeeded - dwInputBytesFree);

        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ResizeBufferIfNeeded: Resizing Buffer to %d, addl=%d, free=%d\n",
                    _dwBufferLength,
                    dwAddlBufferNeeded,
                    dwInputBytesFree
                    ));

        INET_ASSERT(_dwBufferLength < DBLBUFFER_MAX_SIZE);

        //
        // Do Resize, and store result
        //

        _lpBuffer = (LPBYTE)ResizeBuffer(hBuffer, _dwBufferLength, FALSE);

        DEBUG_PRINT(BUFFER,
                    INFO,
                    ("resized %#x => %#x, %d bytes\n",
                    hBuffer,
                    _lpBuffer,
                    _dwBufferLength
                    ));

        if ( ! _lpBuffer )
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("DBLBUFFER::ResizeBufferIfNeeded: Failed while Resizing, Out of Mem?\n"
                        ));

            DEBUG_LEAVE(FALSE);

            return FALSE;  // failing due to NOT_ENOUGH_MEMORY
        }

        //
        // Update ReSized Buffer pointers
        //

        _lpBufferIn = _lpBuffer;

        UpdateVars();
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::SetOutputInputBuffer(
    IN LPBYTE lpNewOutputBuffer,
    IN DWORD  dwNewOutputBufferSize,
    IN LPBYTE lpNewInputBuffer,
    IN DWORD  dwNewInputBufferSize,
    IN BOOL   fConcatenatePreviousOutput
    )

/*++

Routine Description:

    Allows caller to specify new addresses for input and output buffer.
    If fConcatenatePreviousOutput is set, SetOutputInputBuffer will combine
    the passed in output buffer with any internal output buffer.
    Also allows size changes to buffers.

Arguments:

    lpNewOutputBuffer           - New Output Buffer.

    dwNewOutputBufferSize       - Size of New Output Buffer.

    lpNewInputBuffer            - New Input Buffer.

    dwNewInputBufferSize        - New Input Buffer Size.

    fConcatenatePreviousOutput  - TRUE if we are to combine internal output buffer
                                  with (passed in) new output buffer
                                  FALSE if we are to just replace output buffer pointers.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    Assumed to be called from double buffering mode.

--*/


{

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(lpNewOutputBuffer >= _lpBuffer && lpNewOutputBuffer <= _lpEndOfBuffer );
    INET_ASSERT((lpNewInputBuffer >= _lpBuffer && lpNewInputBuffer <= _lpEndOfBuffer) || dwNewInputBufferSize == 0);
    INET_ASSERT(fConcatenatePreviousOutput || _dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DEBUG_PRINT(API,
         INFO,
         ("DBLBUFFER::SetOutputInputBuffer: Getting New Output( %x, size=%d ) New Input( %x, size=%d)\n",
         lpNewOutputBuffer,
         dwNewOutputBufferSize,
         lpNewInputBuffer,
         dwNewInputBufferSize
         ));


    if ( fConcatenatePreviousOutput )
    {
        ConcatenateOutputBufferUsage(
                    lpNewOutputBuffer,
                    dwNewOutputBufferSize
                    );
    }
    else
    {
        _lpBufferOut = lpNewOutputBuffer;
        _dwBufferOut = dwNewOutputBufferSize;
    }


    _lpBufferIn = lpNewInputBuffer;
    _dwBufferIn = dwNewInputBufferSize;

    UpdateVars();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\bgtask.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgtask.cxx

Abstract:

    Contains background task and support functions 

    Contents:
        LoadBackgroundTaskMgr
        UnloadBackgroundTaskMgr
        NotifyBackgroundTaskMgr
        CreateAndQueueBackgroundWorkItem

        BackgroundTaskMgr::QueueBackgroundWorkItem
        BackgroundTaskMgr::DeQueueAndRunBackgroundWorkItem 
        BackgroundTaskMgr::CreateBackgroundFsm
        BackgroundTaskMgr::Release
        BackgroundTaskMgr::HasBandwidth

        CFsm_BackgroundTask::RunSM
        CFsm_BackgroundTask::DoSendReq
        CFsm_BackgroundTask::~CFsm_BackgroundTask
Author:

    Danpo Zhang (danpoz) 06-26-98

Environment:

    Win32 user-mode

Revision History:

    06-26-1998 danpoz 
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

BackgroundTaskMgr* g_BGTaskMgr = NULL;

//
// API: Init global BackgroundTaskManager
//
BOOL
LoadBackgroundTaskMgr()
{
    if( g_BGTaskMgr )
        return TRUE;

    BackgroundTaskMgr* bgMgr = NULL;
    bgMgr = new BackgroundTaskMgr();
    if( !bgMgr)
        return FALSE;

    g_BGTaskMgr = bgMgr;

    return TRUE;
}

//
// API: Unload global BackgroundTaskManager
//
void
UnloadBackgroundTaskMgr()
{
    if( g_BGTaskMgr )
    {
        //BUGBUG
        //what to do with unfinished task?
        delete g_BGTaskMgr;
    }

    g_BGTaskMgr = NULL;
}


//
// API: Select thread notifis now is a good time to do background task 
//
DWORD
NotifyBackgroundTaskMgr()
{
    DWORD error;

    // can we run another background item?
    if( !g_BGTaskMgr->HasBandwidth() )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    // get a background FSM if there is any 
    g_BGTaskMgr->DeQueueAndRunBackgroundWorkItem();

    error = ERROR_SUCCESS;
quit:
    return error;
}


//
// create a background task (fsm) and queue it on the background task
// list, the task item will be picked up later by a free async worker
// thread
//
DWORD
CreateAndQueueBackgroundWorkItem(
    IN  LPCSTR  szUrl
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CreateAndQueueBackgroundWorkItem",
                 "%q",
                 szUrl 
                 ));

    DWORD   error;
    CFsm*   pFsm = NULL;

    INET_ASSERT( szUrl );

    // get new fsm
    pFsm = g_BGTaskMgr->CreateBackgroundFsm(szUrl);
    if( !pFsm )
    {
        error = ERROR_NOT_ENOUGH_MEMORY; 
        goto quit;
    }

    // queue fsm
    error = g_BGTaskMgr->QueueBackgroundWorkItem(pFsm);
    if( error != ERROR_SUCCESS )
    {
        // delete the fsm to avoid leak
        delete pFsm;
    }

quit:
    DEBUG_LEAVE(error);
    return error;

}

DWORD
BackgroundTaskMgr::QueueBackgroundWorkItem(
    IN CFsm* pFsm
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueBackgroundWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    INET_ASSERT(lpThreadInfo != NULL);

    if( lpThreadInfo != NULL )
    {
        _bgTaskQueue.Acquire();
        _bgTaskQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        _bgTaskQueue.Release();

        error = ERROR_SUCCESS;

        if (g_bHibernating)
        {
            InterruptSelect();
        }
    }

    DEBUG_LEAVE(error);
    return error;
}



DWORD 
BackgroundTaskMgr::DeQueueAndRunBackgroundWorkItem()
{

    // LOCK list
    _bgTaskQueue.Acquire();
    
    // check the list to see if it is empty
    if( _bgTaskQueue.Head() != _bgTaskQueue.Self() )
    {
        PLIST_ENTRY pEntry = NULL;
        PLIST_ENTRY pPrev = NULL;
        
        pPrev = _bgTaskQueue.Self();
        pEntry = ((CPriorityListEntry*)pPrev)->Next();

        CFsm* pFsm = ContainingFsm(pEntry);
        INET_ASSERT(pFsm);

        // deQueued, we can remove the task item from the queue 
        // remove from the blocked list
        _bgTaskQueue.Remove((CPriorityListEntry *)pFsm);

        // increment the active running fsm count
        InterlockedIncrement(&_lActiveFsm);

        // this fsm will be picked up by a waken worker thread
        pFsm->QueueWorkItem();
    }

    // UNLOCK list
    _bgTaskQueue.Release();

    return ERROR_SUCCESS;
}

CFsm*
BackgroundTaskMgr::CreateBackgroundFsm(LPCSTR szUrl)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    // HACK - HACK for TESTING... 
    // correct solution is when lpThreadInfo->Fsm != NULL
    // we do not create a fsm so that we always make sure
    // there is one fsm on the select thread 
    //
    if( lpThreadInfo != NULL )
    {
        lpThreadInfo->Fsm = NULL;
    }

    return new CFsm_BackgroundTask(this, szUrl);
}
    

BOOL
BackgroundTaskMgr::HasBandwidth()
{
    // only one fsm can be picked at anytime
    return !_lActiveFsm;  
}


BackgroundTaskMgr::BackgroundTaskMgr() 
    : _lActiveFsm(0)
{
}

void 
BackgroundTaskMgr::NotifyFsmDone()
{
    InterlockedDecrement(&_lActiveFsm);
}



DWORD 
CFsm_BackgroundTask::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm_BackgroundTask::RunSM",
                 "%#x",
                 Fsm
                 ));

    
    CFsm_BackgroundTask* fsm = (CFsm_BackgroundTask*) Fsm;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL fIsAsyncWorkerThread = TRUE;

    if( lpThreadInfo )
    {
        fIsAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
        lpThreadInfo->IsAsyncWorkerThread = FALSE;
    }

    switch( fsm->GetState() ) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        fsm->DoSendReq();

    default:
        break;
    }

    fsm->SetDone(0);
    if( lpThreadInfo )
    {
        lpThreadInfo->IsAsyncWorkerThread = fIsAsyncWorkerThread;
    }
    DEBUG_LEAVE(0);
    return 0;
}


typedef HRESULT (WINAPI * pfnObtainUA)(DWORD, LPSTR, DWORD*);

DWORD
CFsm_BackgroundTask::DoSendReq()
{
    HINTERNET hInternet = NULL;
    HINTERNET hRequest = NULL;
    CHAR szBuffer[4000];
    DWORD dwBytesRead;
    BOOL  fSuccess;

    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;
    BOOL  fUAFromUrlmon = FALSE;


    CHAR*  pszUA = NULL;

    HINSTANCE hinst = GetModuleHandle(URLMON_DLL);
    if( hinst )
    {
        pfnObtainUA pfnUA = (pfnObtainUA)
            GetProcAddress(hinst, "ObtainUserAgentString");

        if( pfnUA )
        {
            DWORD dwSize = MAX_PATH;
            pszUA = new CHAR[dwSize];
            if( pszUA )
            {
                HRESULT hr = (*pfnUA)(0, pszUA, &dwSize);
            
                if( S_OK == hr )
                {
                    fUAFromUrlmon = TRUE;
                }
                else if( E_OUTOFMEMORY == hr )
                {
                    // the original pszUA is allocated too small
                    // we need bigger buffer size (returned by dwSize)
                    delete [] pszUA;
            
                    pszUA = new CHAR[dwSize];
                    if( pszUA )
                    { 
                        hr = (*pfnUA)(0, pszUA, &dwSize);
                        if( S_OK == hr )
                        {
                            fUAFromUrlmon = TRUE;
                        }
                    } 
                } // original buffer too small, create bigger one
            }  
        } // get the pFN to UA agent
    } // urlmon is loaded

    if( fUAFromUrlmon && pszUA)
    {
        hInternet = InternetOpen(
                pszUA, 
                INTERNET_OPEN_TYPE_PRECONFIG,
                NULL,
                NULL,
                0 );
    }
    else
    {
        hInternet = InternetOpen(
                gszDefaultUserAgent,
                INTERNET_OPEN_TYPE_PRECONFIG,
                NULL,
                NULL,
                0 );
    }

    if( !hInternet )
    {
        goto quit;
    }

    hRequest = InternetOpenUrl(
                hInternet,
                m_lpszUrl,
                "Accept: */*\r\n", 
                (DWORD) -1,
                INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_BGUPDATE | INTERNET_FLAG_KEEP_CONNECTION,
                INTERNET_NO_CALLBACK
                );

    if( !hRequest )
    {
        DWORD dwLastErr = 0;
        dwLastErr = GetLastError();
        goto quit;
    }

    
    do {
        dwBytesRead = 0;

        fSuccess = InternetReadFile(
                        hRequest,
                        szBuffer,
                        sizeof(szBuffer)-1,
                        &dwBytesRead
                        );

        if( !fSuccess )
        {
            goto quit;
        }

    } while ( dwBytesRead != 0 );        

    error = ERROR_SUCCESS;

quit:
    if( hRequest )
        InternetCloseHandle(hRequest);
    if( hInternet )
        InternetCloseHandle(hInternet);

    if( fUAFromUrlmon && pszUA )
        delete [] pszUA;

    return error;
}

CFsm_BackgroundTask::~CFsm_BackgroundTask()
{
    DELETE_MANDATORY_PARAM(m_lpszUrl);
    m_pMgr->NotifyFsmDone();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\caddrlst.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    caddrlst.cxx

Abstract:

    Contains CAddressList class definition

    Contents:
        CAddressList::FreeList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::GetNextAddress
        CAddressList::InvalidateAddress
        CAddressList::ResolveHost
        CFsm_ResolveHost::RunSM
        (CAddressList::IPAddressToAddressList)
        (CAddressList::HostentToAddressList)
        (CAddressList::AddrInfoToAddressList)

Author:

    Richard L Firth (rfirth) 19-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    19-Apr-1997 rfirth
        Created

    28-Jan-1998 rfirth
        No longer randomly index address list. NT5 and Win98 are modified to
        return the address list in decreasing order of desirability by RTT/
        route

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <autodial.h>

//#define TEST_CODE

//
// methods
//

VOID
CAddressList::FreeList(
    VOID
    )

/*++

Routine Description:

    Free address list

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_Addresses != NULL) {
        m_Addresses = (LPRESOLVED_ADDRESS)FREE_MEMORY((HLOCAL)m_Addresses);

        INET_ASSERT(m_Addresses == NULL);

        m_AddressCount = 0;
        m_BadAddressCount = 0;
        m_CurrentAddress = 0;
    }
}


DWORD
CAddressList::SetList(
    IN DWORD dwIpAddress
    )

/*++

Routine Description:

    Sets the list contents from the IP address

Arguments:

    dwIpAddress - IP address from which to create list contents

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    Acquire();
    FreeList();

    DWORD error = IPAddressToAddressList(dwIpAddress);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Sets the list contents from the hostent

Arguments:

    lpHostent   - pointer to hostent containing resolved addresses to add

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    Acquire();
    FreeList();

    DWORD error = HostentToAddressList(lpHostent);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Sets the list contents from the addrinfo.  Basically just a wrapper
    around AddrInfoToAddressList() that also grabs the critical section.

Arguments:

    lpAddrInfo  - Pointer to addrinfo containing resolved addresses to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    Acquire();
    FreeList();

    DWORD error = AddrInfoToAddressList(lpAddrInfo);

    Release();

    return error;
}


BOOL
CAddressList::GetNextAddress(
    OUT LPDWORD lpdwResolutionId,
    IN OUT LPDWORD lpdwIndex,
    IN INTERNET_PORT nPort,
    OUT LPCSADDR_INFO lpAddressInfo
    )

/*++

Routine Description:

    Get next address to use when connecting. If we already have a preferred
    address, use that. We make a copy of the address to use in the caller's
    data space

Arguments:

    lpdwResolutionId    - used to determine whether the address list has been
                          resolved between calls

    lpdwIndex           - IN: current index tried; -1 if we want to try default
                          OUT: index of address address returned if successful

    nPort               - which port we want to connect to

    lpAddressInfo       - pointer to returned address if successful

Return Value:

    BOOL
        TRUE    - lpResolvedAddress contains resolved address to use

        FALSE   - need to (re-)resolve name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CAddressList::GetNextAddress",
                 "%#x [%d], %#x [%d], %d, %#x",
                 lpdwResolutionId,
                 *lpdwResolutionId,
                 lpdwIndex,
                 *lpdwIndex,
                 nPort,
                 lpAddressInfo
                 ));

    PERF_ENTER(GetNextAddress);

    BOOL bOk = TRUE;

    //
    // if we tried all the addresses and failed already, re-resolve the name
    //

    Acquire();
    if (m_BadAddressCount < m_AddressCount) {
        if (*lpdwIndex != (DWORD)-1) {

            INET_ASSERT(m_BadAddressCount < m_AddressCount);

            INT i = 0;

            m_CurrentAddress = *lpdwIndex;

            INET_ASSERT((m_CurrentAddress >= 0)
                        && (m_CurrentAddress < m_AddressCount));

            if ((m_CurrentAddress < 0) || (m_CurrentAddress >= m_AddressCount)) {
                m_CurrentAddress = 0;
            }
            do {
                NextAddress();
                if (++i == m_AddressCount) {
                    bOk = FALSE;
                    break;
                }
            } while (!IsCurrentAddressValid());
        }

        //
        // check to make sure this address hasn't expired
        //

        //if (!CheckHostentCacheTtl()) {
        //    bOk = FALSE;
        //}
    } else {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("exhausted %d addresses\n",
                    m_BadAddressCount
                    ));

        bOk = FALSE;
    }
    if (bOk) {

        DWORD dwLocalLength = LocalSockaddrLength();
        LPBYTE lpRemoteAddr = (LPBYTE)(lpAddressInfo + 1) + dwLocalLength;

        memcpy(lpAddressInfo + 1, LocalSockaddr(), dwLocalLength);
        memcpy(lpRemoteAddr, RemoteSockaddr(), RemoteSockaddrLength());
        lpAddressInfo->LocalAddr.lpSockaddr = (LPSOCKADDR)(lpAddressInfo + 1);
        lpAddressInfo->LocalAddr.iSockaddrLength = dwLocalLength;
        lpAddressInfo->RemoteAddr.lpSockaddr = (LPSOCKADDR)lpRemoteAddr;
        lpAddressInfo->RemoteAddr.iSockaddrLength = RemoteSockaddrLength();
        lpAddressInfo->iSocketType = SocketType();
        lpAddressInfo->iProtocol = Protocol();
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) ==
                    offsetof(SOCKADDR_IN6, sin6_port));
        ((LPSOCKADDR_IN)lpAddressInfo->RemoteAddr.lpSockaddr)->sin_port =
            _I_htons((unsigned short)nPort);
        *lpdwIndex = m_CurrentAddress;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("current address = %d.%d.%d.%d\n",
                    ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[7] & 0xff
                    ));

//dprintf("returning address %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        m_ResolutionId,
//        m_CurrentAddress
//        );
    }
    *lpdwResolutionId = m_ResolutionId;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("ResolutionId = %d, Index = %d\n",
                m_ResolutionId,
                m_CurrentAddress
                ));

    Release();

    PERF_LEAVE(GetNextAddress);

    DEBUG_LEAVE(bOk);

    return bOk;
}


VOID
CAddressList::InvalidateAddress(
    IN DWORD dwResolutionId,
    IN DWORD dwAddressIndex
    )

/*++

Routine Description:

    We failed to create a connection. Invalidate the address so other requests
    will try another address

Arguments:

    dwResolutionId  - used to ensure coherency of address list

    dwAddressIndex  - which address to invalidate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CAddressList::InvalidateAddress",
                 "%d, %d",
                 dwResolutionId,
                 dwAddressIndex
                 ));
//dprintf("invalidating %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        dwResolutionId,
//        dwAddressIndex
//        );
    Acquire();

    //
    // only do this if the list is the same age as when the caller last tried
    // an address
    //

    if (dwResolutionId == m_ResolutionId) {

        INET_ASSERT(((INT)dwAddressIndex >= 0)
                    && ((INT)dwAddressIndex < m_AddressCount));

        if (dwAddressIndex < (DWORD)m_AddressCount) {
            m_Addresses[dwAddressIndex].IsValid = FALSE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("invalidated address %d.%d.%d.%d\n",
                        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[7] & 0xff
                        ));

            INET_ASSERT(m_BadAddressCount <= m_AddressCount);

            if (m_BadAddressCount < m_AddressCount) {
                ++m_BadAddressCount;
                if (m_BadAddressCount < m_AddressCount) {
                    for (int i = 0;
                         !IsCurrentAddressValid() && (i < m_AddressCount);
                         ++i) {
                        NextAddress();
                    }
                }
            }
        }
    }
    Release();

    DEBUG_LEAVE(0);
}


DWORD
CAddressList::ResolveHost(
    IN LPSTR lpszHostName,
    IN OUT LPDWORD lpdwResolutionId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resolves host name (or (IP-)address)

    BUGBUG: Ideally, we don't want to keep hold of worker threads if we are in
            the blocking gethostbyname() call. But correctly handling this is
            difficult, so we always block the thread while we are resolving.
            For this reason, an async request being run on an app thread should
            have switched to a worker thread before calling this function.

Arguments:

    lpszHostName        - host name (or IP-address) to resolve

    lpdwResolutionId    - used to determine whether entry changed

    dwFlags             - controlling request:

                            SF_INDICATE - if set, make indications via callback

                            SF_FORCE    - if set, force (re-)resolve

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Name successfully resolved

        Failure - ERROR_INTERNET_NAME_NOT_RESOLVED
                    Couldn't resolve the name

                  ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory for the FSM
--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost",
                 "%q, %d, %#x",
                 lpszHostName,
                 *lpdwResolutionId,
                 dwFlags
                 ));

    DWORD error;

    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    error = DoFsm(new CFsm_ResolveHost(lpszHostName,
                                       lpdwResolutionId,
                                       dwFlags,
                                       this
                                       ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ResolveHost::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_ResolveHost::RunSM",
                 "%#x",
                 Fsm
                 ));

    CAddressList * pAddressList = (CAddressList *)Fsm->GetContext();
    CFsm_ResolveHost * stateMachine = (CFsm_ResolveHost *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pAddressList->ResolveHost_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        Fsm->SetDone();
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Fsm(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Fsm",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_OBJECT * pHandle = fsm.GetMappedHandleObject();
    DWORD error = ERROR_SUCCESS;

    //
    // BUGBUG - RLF 04/23/97
    //
    // This is sub-optimal. We want to block worker FSMs and free up the worker
    // thread. Sync client threads can wait. However, since a clash is not very
    // likely, we'll block all threads for now and come up with a better
    // solution later (XTLock).
    //
    // Don't have time to implement the proper solution now
    //

    Acquire();

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId != m_ResolutionId) {
        goto done;
    }

    //
    // if we're an app thread making an async request then go async now rather
    // than risk blocking the app thread. This will be the typical scenario for
    // IE, and we care about little else
    //
    // BUGBUG - RLF 05/20/97
    //
    // We should really lock & test the cache first, but let's do that after
    // Beta2 (its perf work)
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
        && pHandle->IsAsyncHandle()
        && (fsm.GetAppContext() != INTERNET_NO_CALLBACK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("async request on app thread - jumping to hyper-drive\n"
                    ));

        error = Fsm->QueueWorkItem();
        goto done;
    }

    //
    // throw out current list (if any)
    //

    FreeList();

    //
    // let the app know we are resolving the name
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatusString(INTERNET_STATUS_RESOLVING_NAME,
                                     lpszHostName
                                     );
    }

//dprintf("resolving %q\n", lpszHostName);

    //
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo with the AI_NUMERICHOST flag succeeds then we were
    // given a string representation of an IPv6 or IPv4 address.  Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }

        //
        // An IP address (either v4 or v6) was passed in.
        // Simply convert to address list representation and quit.
        //
        // NOTE: Previous versions of this code had a function here to
        // make sure the string didn't contain additional info that would
        // invalidate the string.  For example, "111.111.111.111 .msn.com"
        // would allow the navigation to succeed, but the cookies for
        // .msn.com would be retrievable, violating cross-domain security.
        // We no longer need this check because getaddrinfo is far pickier
        // than inetaddr was - getaddrinfo with the AI_NUMERICHOST flag set
        // will only accept a string that parses *exactly* as an IP address
        // literal.  No extra data is allowed.
        //

        error = SetList(lpAddrInfo);
        _I_freeaddrinfo(lpAddrInfo);
        goto quit;
    }

    //
    // 255.255.255.255 (or 65535.65535 or 16777215.255) would never work anyway
    //

    INET_ASSERT(lstrcmp(lpszHostName, "255.255.255.255"));

    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //

    DWORD ttl;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    if (!(dwFlags & SF_FORCE)
    && (lpResolverCacheEntry=QueryResolverCache(lpszHostName, NULL, &lpAddrInfo, &ttl))) {
        error = SetList(lpAddrInfo);
        ReleaseResolverCacheEntry(lpResolverCacheEntry);
        ++m_ResolutionId;
    } else
        {
        if (dwFlags & SF_FORCE) {
            //ThrowOutResolverCacheEntry(lpszHostName);
        }

        //
        // If we call winsock getaddrinfo() then we don't get to find out the
        // time-to-live as returned by DNS, so we have to use the default value
        // (LIVE_DEFAULT)
        //

        Hints.ai_flags = AI_CANONNAME;

        LPSTR lpszUTF8HostName = NULL;
        LPSTR lpszTempHostName;
        if (GlobalUseUTF8ServerForNameRes)
        {
            DWORD dwUTF8StrLen;
            if (lpszUTF8HostName = ConvertMBCSToUTF8(lpszHostName, 
                                                    lstrlen(lpszHostName), 
                                                    GetACP(),
                                                    &dwUTF8StrLen,
                                                    FALSE))
            {
                lpszTempHostName = lpszHostName;
                lpszHostName = lpszUTF8HostName;
            }
        }            
                    
        error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    error ? "NOT " : ""
                    ));

        if (lpszUTF8HostName)
        {
            delete [] lpszUTF8HostName;
            lpszHostName = lpszTempHostName;
        }
        
        if (error == 0) {
            error = SetList(lpAddrInfo);
            AddResolverCacheEntry(lpszHostName, lpAddrInfo, LIVE_DEFAULT);
            ++m_ResolutionId;
        } else {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
        }
    }

quit:

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // inform the app that we have resolved the name
        //

        InternetIndicateStatusAddress(INTERNET_STATUS_NAME_RESOLVED,
                                      RemoteSockaddr(),
                                      RemoteSockaddrLength()
                                      );
    }
    *lpdwResolutionId = m_ResolutionId;

done:

    Release();

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        //PERF_LEAVE(ResolveHost);
    }

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
CAddressList::IPAddressToAddressList(
    IN DWORD ipAddr
    )

/*++

Routine Description:

    Converts an IP-address to a RESOLVED_ADDRESS

Arguments:

    ipAddr  - IP address to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    LPRESOLVED_ADDRESS address = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                        LMEM_FIXED,
                                                        sizeof(RESOLVED_ADDRESS)

                                                        //
                                                        // 1 local and 1 remote
                                                        // socket address
                                                        //

                                                        + 2 * sizeof(SOCKADDR)
                                                        );
    if (address == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPBYTE lpVariable;
    LPSOCKADDR_IN lpSin;

    lpVariable = (LPBYTE)address + (sizeof(RESOLVED_ADDRESS));

    //
    // For this IP address, build a CSADDR_INFO structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value and the IP address
    // presented in the arguments
    //

    address->AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = ipAddr;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.iSocketType = SOCK_STREAM;
    address->AddrInfo.iProtocol = IPPROTO_TCP;
    address->IsValid = TRUE;

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = 1;
    m_BadAddressCount = 0;
    m_Addresses = address;
    m_CurrentAddress = 0;   // only one to choose from
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CAddressList::HostentToAddressList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Converts a HOSTENT structure to an array of RESOLVED_ADDRESSs

Arguments:

    lpHostent   - pointer to HOSTENT to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpHostent != NULL);

    LPBYTE * addressList = (LPBYTE *)lpHostent->h_addr_list;

    INET_ASSERT(addressList[0]);

    //
    // first off, figure out how many addresses there are in the hostent
    //

    int nAddrs;

    if (fDontUseDNSLoadBalancing) {
        nAddrs = 1;
    } else {
        for (nAddrs = 0; addressList[nAddrs] != NULL; ++nAddrs) {
            /* NOTHING */
        }
#ifdef TEST_CODE
        nAddrs = 4;
#endif
    }

    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                LMEM_FIXED,
                                                nAddrs * (sizeof(RESOLVED_ADDRESS)

                                                //
                                                // need 1 local and 1 remote socket
                                                // address for each
                                                //

                                                + 2 * sizeof(SOCKADDR))
                                                );
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // for each IP address in the hostent, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value, and the IP address from
    // the hostent presented in the arguments
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));
    LPSOCKADDR_IN lpSin;

    for (int i = 0; i < nAddrs; ++i) {

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
        *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));
        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
#ifdef TEST_CODE
        //if (i) {
            *(LPDWORD)&lpSin->sin_addr = 0x04030201;
            //*(LPDWORD)&lpSin->sin_addr = 0x1cfe379d;
        //}
#else
        *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
#endif
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

        addresses[i].AddrInfo.iSocketType = SOCK_STREAM;
        addresses[i].AddrInfo.iProtocol = IPPROTO_TCP;
        addresses[i].IsValid = TRUE;
    }
#ifdef TEST_CODE
    *((LPDWORD)&((LPSOCKADDR_IN)addresses[3].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = *(LPDWORD)addressList[0];
    //((LPSOCKADDR_IN)addresses[7].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr = ((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr;
    //*((LPDWORD)&((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = 0x04030201;
#endif

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}



PRIVATE
DWORD
CAddressList::AddrInfoToAddressList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Converts an addrinfo structure(s) to an array of RESOLVED_ADDRESSes.

Arguments:

    lpAddrInfo  - pointer to AddrInfo chain to convert.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpAddrInfo != NULL);

    struct addrinfo *lpCurrentInfo = lpAddrInfo;

    //
    // First off, figure out how many addrinfo structs are on the chain.
    // And how much memory we'll need to hold them as RESOLVED_ADDRESSes.
    // Note we also need space to hold the actual local and remote sockaddrs,
    // the RESOLVED_ADDRESS struct only contains the pointers to them.
    //

    int SpaceNeeded = 0;
    int nAddrs = 0;

    for (; lpCurrentInfo != NULL; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        SpaceNeeded += sizeof(RESOLVED_ADDRESS) + 
            2 * lpCurrentInfo->ai_addrlen;

        nAddrs++;

        if (fDontUseDNSLoadBalancing)
            break;  // Leave after one.
    }

    //
    // Allocate enough memory to hold these as RESOLVED_ADDRESSes.
    //
    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)
        ALLOCATE_MEMORY(LMEM_FIXED, SpaceNeeded);
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // For each IP address in the chain, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family,
    // everything else is zeroed; create a remote SOCKADDR containing all
    // the values from the addrinfo structure.
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));

    lpCurrentInfo = lpAddrInfo;
    for (int i = 0; i < nAddrs; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memset(lpVariable, 0, lpCurrentInfo->ai_addrlen);
        addresses[i].AddrInfo.LocalAddr.lpSockaddr->sa_family = 
            (unsigned short)lpCurrentInfo->ai_family;

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memcpy(lpVariable, lpCurrentInfo->ai_addr, lpCurrentInfo->ai_addrlen);

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.iSocketType = lpCurrentInfo->ai_socktype;
        addresses[i].AddrInfo.iProtocol = lpCurrentInfo->ai_protocol;
        addresses[i].IsValid = TRUE;

        i++;
    }

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains functions to allocate and deallocate handle values for various
    Windows Internet Extensions DLL 'objects'

    Functions in this module generate pseudo-handle values and free them when
    no longer required. Each handle value is generated from its position within
    a (2K) bitmap (== 16K handles max.). We also maintain an array that is used
    to map the generated handle to the address of the handle object that it
    represents

    Contents:
        HandleInitialize
        HandleTerminate
        AllocateHandle
        FreeHandle
        MapHandleToAddress
        DereferenceObject
        (BitToIndex)

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    11-Jan-1996 rfirth
        Use fixed memory instead of moveable (Win95 has a bug w/ LocalUnlock)

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>

//
// manifests
//

#define BASE_HANDLE_VALUE       0x00cc0000
#define HANDLE_INCREMENT        4
#define BITS_PER_BYTE           8
#define BITS_IN_DWORD           (sizeof(DWORD) * BITS_PER_BYTE)
#define FULL_DWORD              ((DWORD)-1)
#define MAXIMUM_HANDLE_NUMBER   (64 K)
#define MAXIMUM_HANDLE_COUNT    ((MAXIMUM_HANDLE_NUMBER / HANDLE_INCREMENT) - 1)
#define MAXIMUM_DWORD_INDEX     ((MAXIMUM_HANDLE_COUNT + BITS_IN_DWORD - 1) / BITS_IN_DWORD)
#define MINIMUM_HANDLE_VALUE    (BASE_HANDLE_VALUE + HANDLE_INCREMENT)
#define MAXIMUM_HANDLE_VALUE    (BASE_HANDLE_VALUE + MAXIMUM_HANDLE_NUMBER - HANDLE_INCREMENT)
#define INITIAL_MAP_LENGTH      16  // 512 handles == 2048 bytes
#define HANDLE_MAP_INCREMENT    16

// Warning: In order for 64-bit compatibility, the range of handle
// values must be restricted to quantities representable by 32-bits.
// If maximum handle value >= 4GB the implementation has to change 
// use 64-bit integral types internally.

//
// macros
//

#define NEXT_HANDLE_VALUE(d, i) (BASE_HANDLE_VALUE + ((d) * BITS_IN_DWORD + ((i) + 1)) * HANDLE_INCREMENT)

//
// private prototypes
//

PRIVATE
inline
DWORD
BitToIndex(
    IN DWORD Bit
    );

//
// private data
//

PRIVATE CRITICAL_SECTION HandleMapCritSec;  // protects access to following variables
PRIVATE LPDWORD HandleMap = NULL;           // bitmap of allocated handles
PRIVATE DWORD HandleMapLength;              // number of DWORDs in HandleMap
PRIVATE DWORD NextHandleMapDword = 0;       // first bitmap DWORD to check
PRIVATE DWORD NextHandleMapBit = 1;         // map of first bit to check
PRIVATE DWORD NextHandleMapBitIndex = 0;    // position of first bit in first DWORD
PRIVATE DWORD NextHandleValue = MINIMUM_HANDLE_VALUE;
PRIVATE DWORD NextHandleIndex = 0;
PRIVATE BOOL Initialized = FALSE;
PRIVATE LPVOID * MapArray = NULL;
PRIVATE DWORD MapArrayLength = 0;

//
// functions
//

DWORD
HandleInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "HandleInitialize",
                NULL
                ));

    InitializeCriticalSection(&HandleMapCritSec);
    HandleMapLength = INITIAL_MAP_LENGTH;

    DWORD error;

    //
    // ResizeBuffer() doesn't use LMEM_ZEROINIT
    //

    HandleMap = (LPDWORD)ALLOCATE_MEMORY(LMEM_ZEROINIT,
                                         HandleMapLength * sizeof(DWORD)
                                         );
    if (HandleMap != NULL) {
        MapArrayLength = INITIAL_MAP_LENGTH * BITS_IN_DWORD;
        MapArray = (LPVOID *)ALLOCATE_MEMORY(LMEM_ZEROINIT,
                                             MapArrayLength * sizeof(LPVOID)
                                             );
        if (MapArray != NULL) {
            Initialized = TRUE;
            error = ERROR_SUCCESS;
        }
    }

    if (!HandleMap || !MapArray) {
        error = GetLastError();
        HandleTerminate();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HandleTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of HandleInitialize - frees any system resources allocated by
    HandleInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                None,
                "HandleTerminate",
                NULL
                ));

    if (Initialized) {

        //
        // there shouldn't be any other threads active when this function is
        // called but we'll grab the critical section anyway, just to make sure
        //

        EnterCriticalSection(&HandleMapCritSec);

        //
        // free up the memory occupied by the handle bitmap and map array
        //

        if (HandleMap != NULL) {
            HandleMap = (LPDWORD)FREE_MEMORY((HLOCAL)HandleMap);
        }

        INET_ASSERT(HandleMap == NULL);

        if (MapArray != NULL) {
            MapArray = (LPVOID *)FREE_MEMORY((HLOCAL)MapArray);
        }

        INET_ASSERT(MapArray == NULL);

        //
        // no longer initialized
        //

        Initialized = FALSE;

        //
        // and reset the variables
        //

        HandleMapLength = 0;
        NextHandleMapDword = 0;
        NextHandleMapBit = 1;
        NextHandleMapBitIndex = 0;
        NextHandleValue = MINIMUM_HANDLE_VALUE;
        NextHandleIndex = 0;
        MapArrayLength = 0;

        LeaveCriticalSection(&HandleMapCritSec);

        //
        // delete the critical section
        //

        DeleteCriticalSection(&HandleMapCritSec);
    }

    DEBUG_LEAVE(0);
}


DWORD
AllocateHandle(
    IN LPVOID Address,
    OUT LPHINTERNET lpHandle
    )

/*++

Routine Description:

    Generic handle allocator function which generates a unique handle value for
    any object. The handle value is simply a number, slightly massaged to give a
    value that can be easily differentiated from other Win32 handle ranges (for
    debugging purposes mainly, and also to protect against illegal use of
    handles (such as treating as a pointer and dereferencing it)).

    The range of handles are kept in a bitmap, composed of DWORDs. The next
    allocated handle is simply the index of the next free bit in the map. The
    map is extended if we run out of handles (up to 16K-1 handles (== 2K bytes)).

    If the map needs to be extended we don't go to the trouble to reduce it
    again. For the sake of 2K bytes max (currently), its not worth the effort.

    This function does not rely on knowing the type of object for which the
    handle is being generated, and only requires serialization via a critical
    section.

    This function can increase the values of these variables:

        NextHandleMapDword
        NextHandleMapBit
        NextHandleMapBitIndex
        NextHandleValue
        NextHandleIndex

Arguments:

    Address     - the (object address) value which will be associated with the
                  returned handle

    lpHandle    - place to return the allocated handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OUT_OF_HANDLES
                    16K-1 (currently) handles are outstanding!

                  ERROR_NOT_ENOUGH_MEMORY etc.
                    problems with Win32 memory/heap management?

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "AllocateHandle",
                "%#x, %#x",
                Address,
                lpHandle
                ));

    DWORD error;

    //
    // can't associate a NULL address with the generated handle
    //

    INET_ASSERT(Address != NULL);

    //
    // default returned handle
    //

    *lpHandle = NULL;

    //
    // in case this function is being called before we have initialized this
    // module, or after we have terminated it, return an error
    //

    if (!Initialized) {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    error = ERROR_INTERNET_OUT_OF_HANDLES;

    EnterCriticalSection(&HandleMapCritSec);

    if (HandleMap == NULL) {

        //
        // don't ever expect this?
        //

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto unlock_exit;
    }

    while (NextHandleMapDword != MAXIMUM_DWORD_INDEX) {

        //
        // if we reached the end of the map the last time, we must reallocate
        //

        if (NextHandleMapDword == HandleMapLength) {

            HLOCAL newHandleMap;

            newHandleMap = REALLOCATE_MEMORY((HLOCAL)HandleMap,
                                             (HandleMapLength + HANDLE_MAP_INCREMENT)
                                             * sizeof(DWORD),
                                             LMEM_MOVEABLE | LMEM_ZEROINIT
                                             );

            HLOCAL newMapArray;

            newMapArray = REALLOCATE_MEMORY((HLOCAL)MapArray,
                                            (HandleMapLength + HANDLE_MAP_INCREMENT)
                                            * BITS_IN_DWORD
                                            * sizeof(LPVOID),
                                            LMEM_MOVEABLE | LMEM_ZEROINIT
                                            );
            if ((newHandleMap != NULL) && (newMapArray != NULL)) {
                HandleMapLength += HANDLE_MAP_INCREMENT;
                HandleMap = (LPDWORD)newHandleMap;
                MapArrayLength += HANDLE_MAP_INCREMENT * BITS_IN_DWORD;
                MapArray = (LPVOID *)newMapArray;

                DEBUG_PRINT(HANDLE,
                            INFO,
                            ("re-allocated %d DWORDs: HandleMap = %#x MapArray = %#x\n",
                            HandleMapLength,
                            HandleMap,
                            MapArray
                            ));

            } else {

                error = GetLastError();

                DEBUG_PRINT(HANDLE,
                            ERROR,
                            ("REALLOCATE_MEMORY() returns %d\n",
                            error
                            ));

                break;
            }
        } else if (NextHandleValue <= MAXIMUM_HANDLE_VALUE) {
            HandleMap[NextHandleMapDword] |= NextHandleMapBit;

            //
            // first handle value returned is 0x00cc0004
            //

            DEBUG_PRINT(HANDLE,
                        INFO,
                        ("handle = %#x, index = %d\n",
                        NextHandleValue,
                        NextHandleIndex
                        ));

            *lpHandle = (HINTERNET)(DWORD_PTR)NextHandleValue;

            //
            // store it in the map array at the specified index
            //

            INET_ASSERT(MapArray[NextHandleIndex] == NULL);

            MapArray[NextHandleIndex] = Address;

            error = ERROR_SUCCESS;

            //
            // find the next available bit for the next caller. Search up
            // to the end of the currently allocated map. If we don't find
            // it, the next caller will attempt to allocate a new DWORD
            // (unless a lower handle gets freed meantime)
            //

            while (NextHandleMapDword < HandleMapLength) {
                if (HandleMap[NextHandleMapDword] != FULL_DWORD) {
                    while (HandleMap[NextHandleMapDword] & NextHandleMapBit) {
                        NextHandleMapBit <<= 1;
                        ++NextHandleMapBitIndex;
                        NextHandleValue += HANDLE_INCREMENT;
                        ++NextHandleIndex;
                    }
                } else {
                    NextHandleMapBit = 0;
                }
                if (NextHandleMapBit != 0) {
                    break;
                } else {

                    //
                    // reached the end of a DWORD. Start the next
                    //

                    ++NextHandleMapDword;
                    NextHandleMapBit = 1;
                    NextHandleMapBitIndex = 0;

                    //
                    // recalculate the next handle value
                    //

                    NextHandleValue = NEXT_HANDLE_VALUE(NextHandleMapDword,
                                                        NextHandleMapBitIndex
                                                        );

                    //
                    // and map array index
                    //

                    NextHandleIndex = NextHandleMapDword * BITS_IN_DWORD;
                }
            }
            break;
        } else {

            //
            // reached maximum handle value - return error
            //

            break;
        }
    }

unlock_exit:

    LeaveCriticalSection(&HandleMapCritSec);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
FreeHandle(
    IN HINTERNET Handle
    )

/*++

Routine Description:

    The obverse function to AllocateHandle. Frees up a previously allocated
    handle value. If this handle has a lower index than the currently selected
    next index (Dword and Bit) then the next index is modified

    This function can reduce the values of these variables:

        NextHandleMapDword
        NextHandleMapBit
        NextHandleMapBitIndex
        NextHandleValue
        NextHandleIndex

Arguments:

    Handle  - handle value previously allocated via AllocateHandle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    We don't think this handle was generated by AllocateHandle
                    or the corresponding bit in the map is already 0

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "FreeHandle",
                "%#x",
                Handle
                ));

    DWORD error;

    //
    // ensure that we are in the correct state
    //

    if (!Initialized) {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    error = ERROR_INVALID_HANDLE;

    //
    // error if 0x00cc0000 > Handle > 0x00ccfffc
    //

    if ((PtrToUlong(Handle) < MINIMUM_HANDLE_VALUE)
     || (PtrToUlong(Handle) > MAXIMUM_HANDLE_VALUE)) {
        goto quit;
    }

    //
    // get the map DWORD index and bit mask from the handle
    //
    DWORD index;

    index = (PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / (BITS_IN_DWORD * HANDLE_INCREMENT);

    DWORD bit;

    bit = 1 << (((PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / HANDLE_INCREMENT) & (BITS_IN_DWORD - 1));

    DWORD mapIndex;

    mapIndex = (PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / HANDLE_INCREMENT;

    EnterCriticalSection(&HandleMapCritSec);

    //
    // the index may be in range, but greater than the currently allocated
    // map length, in which case its an error
    //

    if (index < HandleMapLength) {
        if (HandleMap != NULL) {
            if (HandleMap[index] & bit) {

                BOOL recalc = FALSE;

                DEBUG_PRINT(HANDLE,
                            INFO,
                            ("handle = %#x, index = %d, address = %#x\n",
                            Handle,
                            mapIndex,
                            MapArray[mapIndex]
                            ));

                HandleMap[index] &= ~bit;
                MapArray[mapIndex] = NULL;

                error = ERROR_SUCCESS;

                //
                // if we have cleared a bit lower in the bitmap than the current
                // index and bit indicators, then reset the indicators to the
                // new position
                //

                if (index < NextHandleMapDword) {

                    //
                    // new DWORD is lower than current: change all variables
                    // to those for this handle
                    //

                    NextHandleMapDword = index;
                    recalc = TRUE;
                } else if ((index == NextHandleMapDword) && (bit < NextHandleMapBit)) {

                    //
                    // same DWORD index, lower bit position
                    //

                    recalc = TRUE;
                }
                if (recalc) {
                    NextHandleMapBit = bit;
                    NextHandleMapBitIndex = BitToIndex(bit);

                    //
                    // recalculate the next handle value
                    //

                    NextHandleValue = NEXT_HANDLE_VALUE(NextHandleMapDword,
                                                        NextHandleMapBitIndex
                                                        );

                    //
                    // and map array index
                    //

                    NextHandleIndex = (NextHandleMapDword * BITS_IN_DWORD)
                                    + NextHandleMapBitIndex;
                }
            } else {

                DEBUG_PRINT(HANDLE,
                            ERROR,
                            ("Handle = %#x. HandleMap[%d].%#x not set\n",
                            Handle,
                            index,
                            bit
                            ));
            }
        } else {

            //
            // don't ever expect this to happen
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("Handle = %#x, index = %d, HandleMapLength = %d\n",
                    Handle,
                    index,
                    HandleMapLength
                    ));

    }

    LeaveCriticalSection(&HandleMapCritSec);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    )

/*++

Routine Description:

    Given a handle, retrieve its associated address from the map array. The
    handle object represented by Handle is referenced

    Assumes:    1. only HINTERNETs visible at the API are presented to this
                   function. Even though we AllocateHandle() for arbitrary
                   objects (e.g. gopher views) we never map their addresses

Arguments:

    Handle      - handle value generated by AllocateHandle()

    lpAddress   - place to store mapped address. If the handle has been closed
                  and unmapped, NULL is returned. If the handle is still
                  mapped, even though it has been invalidated, its address will
                  be returned, and its reference count incremented

    Invalidate  - TRUE if we are invalidating this handle

Return Value:

    LPVOID
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    if *lpAddress == NULL then the handle has been closed and
                    unmapped, else it is still mapped, but invalidated. In
                    this case, we incremented the reference count

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "MapHandleToAddress",
                "%#x, %#x, %B",
                Handle,
                lpAddress,
                Invalidate
                ));

    LPVOID address = NULL;
    DWORD error = ERROR_INVALID_HANDLE;

    //
    // error if 0x00cc0000 > Handle > 0x00ccfffc
    //

    if ((PtrToUlong(Handle) >= MINIMUM_HANDLE_VALUE)
    &&  (PtrToUlong(Handle) <= MAXIMUM_HANDLE_VALUE)
    && !InDllCleanup) {

        DWORD index = (PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / HANDLE_INCREMENT;

        //
        // the caller could have supplied a value which has the correct range
        // but may not yet have been generated, causing us to index past the
        // end of the array
        //

        if (index < MapArrayLength) {

            //
            // we have to acquire the critical section in case another thread
            // is reallocating the array
            //

            EnterCriticalSection(&HandleMapCritSec);

            address = MapArray[index];

            DEBUG_PRINT(HANDLE,
                        INFO,
                        ("Handle %#x mapped to address %#x\n",
                        Handle,
                        address
                        ));

            if (address != NULL) {

                //
                // although we store addresses of arbitrary structures (e.g.
                // FTP_SESSION_INFO), we are only calling this function to map
                // pseudo-handles to object addresses at the API. Therefore it
                // should be safe to assume that the pointer references a handle
                // object
                // However, there's nothing to stop an app passing in a random
                // handle value that just happens to map to an FTP or gopher
                // session or gopher view, and since we don't want to treat that
                // as a handle object, we must make this test full-time
                //

                if (((HANDLE_OBJECT *)address)->IsValid(TypeWildHandle) == ERROR_SUCCESS) {

                    //
                    // this is also a very good time to increment the reference
                    // count. We are using the fact that we are serialized on the
                    // handle map critical section here. If Reference() returns
                    // ERROR_INVALID_HANDLE then the handle object has been
                    // invalidated, but its reference count will have been
                    // incremented. The caller should perform as little work as
                    // necessary and get out.
                    //
                    // If Refrerence() returns ERROR_ACCESS_DENIED, then the object
                    // is being destroyed (refcount already went to zero).
                    //
                    // If the reference count is incremented to 1 then there is
                    // another thread waiting to finish deleting this handle. It
                    // is virtually deleted, and if we return its address, the
                    // caller will have a deleted object
                    //

                    if (((HANDLE_OBJECT *)address)->ReferenceCount() == 0) {

                        DEBUG_PRINT(HANDLE,
                                    ERROR,
                                    ("handle %#x [%#x] about to be deleted\n",
                                    Handle,
                                    address
                                    ));

                        address = NULL;
                    } else {
                        error = ((HANDLE_OBJECT *)address)->Reference();
                        if (error == ERROR_SUCCESS) {
                            if (Invalidate) {

                                //
                                // we were called from a handle close API.
                                // Subsequent API calls will discover that the
                                // handle is already invalidated and will quit
                                //

                                ((HANDLE_OBJECT *)address)->Invalidate();
                            }
                        } else if (error == ERROR_ACCESS_DENIED) {
                            //
                            // if we get ERROR_ACCESS_DENIED, this means that the object is 
                            // being destructed, so we *have* to return NULL.
                            //
                            DEBUG_PRINT(HANDLE,
                                        ERROR,
                                        ("Reference() failed - handle %#x [%#x] about to be deleted\n",
                                        Handle,
                                        address
                                        ));
                            address = NULL;
                        } else {
                            DEBUG_PRINT(HANDLE,
                                        ERROR,
                                        ("Reference() returns %d\n",
                                        error
                                        ));

                            //
                            // if invalid and reference count already zero, we
                            // didn't increment ref count: handle already being
                            // deleted
                            //

                            if (((HANDLE_OBJECT *)address)->ReferenceCount() == 0) {
                                address = NULL;
                            }
                        }
                    }
                } else {

                    //
                    // we still want to know about it in debug version
                    //

                    DEBUG_PRINT(HANDLE,
                                ERROR,
                                ("invalid handle object: %#x [%#x]\n",
                                Handle,
                                address
                                ));

                    IF_DEBUG(INVALID_HANDLES) {
                        //INET_ASSERT(FALSE);
                    }
                }
            } else {

                //
                // lets also catch this one (NULL address)
                //

                DEBUG_PRINT(HANDLE,
                            ERROR,
                            ("NULL handle: %#x\n",
                            Handle
                            ));

                IF_DEBUG(INVALID_HANDLES) {
                    //INET_ASSERT(FALSE);
                }
            }
            LeaveCriticalSection(&HandleMapCritSec);
        }
    } else if (InDllCleanup) {
        error = ERROR_INTERNET_SHUTDOWN;
    } else {

        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("bad handle value: %#x\n",
                    Handle
                    ));

        IF_DEBUG(INVALID_HANDLES) {
            //INET_ASSERT(FALSE);
        }
    }

    *lpAddress = address;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
DereferenceObject(
    IN LPVOID lpObject
    )

/*++

Routine Description:

    Undoes the reference added to the handle object by MapHandleToAddress(). May
    result in the handle object being deleted

Arguments:

    lpObject    - address of object to dereference. This MUST be the mapped
                  object address as returned by MapHandleToAddress()

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The handle object was destroyed

        Failure - ERROR_INVALID_HANDLE
                    The object was not a valid handle

                  ERROR_INTERNET_HANDLE_EXISTS
                    The handle is still alive

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "DereferenceObject",
                "%#x",
                lpObject
                ));

    INET_ASSERT(lpObject != NULL);

    HANDLE_OBJECT * object = (HANDLE_OBJECT *)lpObject;
    DWORD error = object->IsValid(TypeWildHandle);

    if (error == ERROR_SUCCESS) {
        if (!object->Dereference()) {
            error = ERROR_INTERNET_HANDLE_EXISTS;
        }
    } else {

        //
        // IsValid() should never return an error if the reference counts
        // are correct
        //

        INET_ASSERT(FALSE);

    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
inline
DWORD
BitToIndex(
    IN DWORD Bit
    )

/*++

Routine Description:

    Returns the index of the first bit set in a DWORD

Arguments:

    Bit - bitmap

Return Value:

    DWORD   - 0..(BITS_IN_DWORD - 1) if bit found, else BITS_IN_DWORD

--*/

{
    if (Bit == 0) {
        return BITS_IN_DWORD;
    } else {

        DWORD index;
        DWORD testBit;

        for (index = 0, testBit = 1; !(Bit & testBit); ++index, testBit <<= 1) {
            ;
        }
        return index;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\icasync.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icasync.cxx

Abstract:

    Contains async socket (select) thread and support functions. Work items now
    processed by SHLWAPI/KERNEL32 thread pool

    Contents:
        InitializeAsyncSupport
        TerminateAsyncSupport
        QueueSocketWorkItem
        BlockWorkItem
        UnblockWorkItems
        CheckForBlockedWorkItems
        ICAsyncThread::~ICAsyncThread
        ICAsyncThread::QueueSocketWorkItem
        ICAsyncThread::BlockWorkItem
        ICAsyncThread::UnblockWorkItems
        ICAsyncThread::CheckForBlockedWorkItems
        ICAsyncThread::SelectThreadWrapper
        ICAsyncThread::SelectThread
        (ICAsyncThread::CreateSelectSocket)
        (ICAsyncThread::DestroySelectSocket)
        (ICAsyncThread::RecreateSelectSocket)
        (ICAsyncThread::InterruptSelect)
        (ICAsyncThread::DrainSelectSocket)

Author:

    Richard L Firth (rfirth) 04-Mar-1998

Environment:

    Win32 user-mode

Revision History:

    04-Mar-1998 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>


//
// private classes
//

class ICAsyncThread {

#define DEFAULT_ASYNC_THREAD_TIMEOUT    5000

private:

    CPriorityList m_BlockedQueue;
    SOCKET m_SelectSocket;
    LONG m_lSelectInterrupts;
    BOOL m_bTerminating;
    DWORD m_dwError;
    HANDLE m_hThread;

public:

    ICAsyncThread() {

        DEBUG_ENTER((DBG_ASYNC,
                     None,
                     "ICAsyncThread::ICAsyncThread",
                     NULL
                     ));

        m_SelectSocket = INVALID_SOCKET;
        m_lSelectInterrupts = -1;
        m_bTerminating = FALSE;
        m_dwError = ERROR_SUCCESS;

        DWORD dwThreadId;

        m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)ICAsyncThread::SelectThreadWrapper,
                    (LPVOID)this,
                    0,
                    &dwThreadId
                    );
        if (m_hThread == NULL) {
            SetError();
        }

        DEBUG_LEAVE(0);
    }

    ~ICAsyncThread();

    DWORD GetError(VOID) const {
        return m_dwError;
    }

    VOID SetError(DWORD dwError = GetLastError()) {
        m_dwError = dwError;
    }

    BOOL IsTerminating(VOID) const {
        return m_bTerminating;
    }

    VOID SetTerminating(VOID) {
        m_bTerminating = TRUE;
    }

    DWORD
    QueueSocketWorkItem(
        IN CFsm * pFsm
        );

    DWORD
    BlockWorkItem(
        IN CFsm * WorkItem,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwTimeout = TP_NO_TIMEOUT
        );

    DWORD
    UnblockWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwError,
        IN LONG lPriority = TP_NO_PRIORITY_CHANGE
        );

    DWORD
    CheckForBlockedWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId
        );

    static
    DWORD
    SelectThreadWrapper(
        IN ICAsyncThread * pThread
        );

    DWORD
    SelectThread(
        VOID
        );

    DWORD
    CreateSelectSocket(
        VOID
        );

    PRIVATE
    VOID
    DestroySelectSocket(
        VOID
        );

    VOID
    RecreateSelectSocket(
        VOID
        );

    VOID
    InterruptSelect(
        VOID
        );

    BOOL
    DrainSelectSocket(
        VOID
        );
};

//
// private data
//

PRIVATE ICAsyncThread * p_AsyncThread = NULL;

//
// functions
//


DWORD
InitializeAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Create async select thread object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS


        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "InitializeAsyncSupport",
                 NULL
                 ));

    DWORD error = ERROR_INTERNET_SHUTDOWN;

    if (!InDllCleanup) {
        EnterCriticalSection(&GeneralInitCritSec);
        if (!InDllCleanup) {
            if (p_AsyncThread == NULL) {
                p_AsyncThread = new ICAsyncThread();
                if (p_AsyncThread == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    error = p_AsyncThread->GetError();
                    if (error != ERROR_SUCCESS) {
                        TerminateAsyncSupport();
                    }
                }
            } else {
                error = ERROR_SUCCESS;
            }
        }
        LeaveCriticalSection(&GeneralInitCritSec);
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
TerminateAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Terminates async support

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "TerminateAsyncSupport",
                 NULL
                 ));

    ICAsyncThread * pThread;

    pThread = (ICAsyncThread *)InterlockedExchangePointer((PVOID*)&p_AsyncThread,
                                                   (PVOID)NULL
                          );

    if (pThread != NULL) {
        delete pThread;
    }

    DEBUG_LEAVE(0);
}


DWORD
QueueSocketWorkItem(
    IN CFsm * pFsm,
    IN SOCKET Socket
    )

/*++

Routine Description:

    Adds a blocked socket operation/work item to the blocked queue

Arguments:

    pFsm    - in-progress socket operation (FSM)

    Socket  - socket handle to wait on

Return Value:

    DWORD
        Success - ERROR_IO_PENDING

        Failure - ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "QueueSocketWorkItem",
                 "%#x, %#x",
                 pFsm,
                 Socket
                 ));

    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        pFsm->SetSocket(Socket);
        error = p_AsyncThread->QueueSocketWorkItem(pFsm);
        if (error == ERROR_SUCCESS) {
            error = ERROR_IO_PENDING;
        }
    }

    INET_ASSERT(error != ERROR_INTERNET_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item

Arguments:

    pFsm        - work item to block

    dwBlockId   - block on this id

    dwTimeout   - for this number of milliseconds

Return Value:

    DWORD
        Error   - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockWorkItem",
                 "%#x, %#x, %d",
                 pFsm,
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        error = p_AsyncThread->BlockWorkItem(pFsm, dwBlockId, dwTimeout);
    }

    INET_ASSERT(error != ERROR_INTERNET_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblocks 1 or more work items

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - that are blocked on this id

    dwError     - with this error

    lPriority   - new priority unless default value of TP_NO_PRIORITY_CHANGE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (p_AsyncThread != NULL) {
        dwUnblocked = p_AsyncThread->UnblockWorkItems(dwCount,
                                                      dwBlockId,
                                                      dwError,
                                                      lPriority
                                                      );
    }

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Checks if there are any items blocked on dwBlockId

Arguments:

    dwCount     - number of items to look for

    dwBlockId   - blocked on this id

Return Value:

    DWORD
        Number of blocked items found

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (p_AsyncThread != NULL) {
        dwFound = p_AsyncThread->CheckForBlockedWorkItems(dwCount, dwBlockId);
    }

    DEBUG_LEAVE(dwFound);

    return dwFound;
}

//
// private functions
//

//
// ICAsyncThread methods
//


ICAsyncThread::~ICAsyncThread(
    VOID
    )

/*++

Routine Description:

    ICAsyncThread destructor. If we are being dynamically unloaded, signal the
    selecter thread and allow it to cleanup. Else the thread is already dead and
    we just need to reclaim the resources

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::~ICAsyncThread",
                 NULL
                 ));

    SetTerminating();
    if (GlobalDynaUnload) {
        InterruptSelect();

        //
        // Assuming the async thread was successfully created, the above clean-up
        // will have put it in a state where it's going to exit.  Need to wait
        // for it to exit before returning from here so it doesn't get scheduled
        // after wininet has been unloaded.
        //
        if(m_hThread)
        {
            DWORD dwRes = WaitForSingleObject(m_hThread, 5 * 1000);
            INET_ASSERT(dwRes == WAIT_OBJECT_0);
        }
    }
    DestroySelectSocket();

    if(m_hThread)
    {
        CloseHandle(m_hThread);
    }

    DEBUG_LEAVE(0);
}


DWORD
ICAsyncThread::QueueSocketWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Add the work-item waiting on a blocked socket to the blocked queue.
    Interrupt the SelectThread to alert it to new work

Arguments:

    pFsm    - blocked work-item to queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueSocketWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->StartTimer();
        m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        InterruptSelect();
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item (FSM)

Arguments:

    pFsm        - work item (FSM) to block

    dwBlockId   - block on this

    dwTimeout   - for this amount of time (mSec)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::BlockWorkItem",
                 "%#x [%d], %#x, %d",
                 pFsm,
                 pFsm->GetPriority(),
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = error = ERROR_INTERNET_INTERNAL_ERROR;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->SetBlockId(dwBlockId);
        pFsm->SetTimeout(dwTimeout);

        RESET_FSM_OWNED(pFsm);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("!!! FSM %#x unowned\n",
                    pFsm
                    ));

        m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
ICAsyncThread::UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblock a nunber of work items waiting on a block id

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

    dwError     - unblock work items with this error code

    lPriority   - if not TP_NO_PRIORITY_CHANGE, change priority to this value

Return Value:

    DWORD
        Number of work items unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    m_BlockedQueue.Acquire();

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        //CHECK_FSM_UNOWNED(pFsm);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetError(dwError);
            if (lPriority != TP_NO_PRIORITY_CHANGE) {
                pFsm->SetPriority(lPriority);
            }
//dprintf("UNBLOCKED %s FSM %#x state %s socket %#x\n", pFsm->MapType(), pFsm, pFsm->MapState(), pFsm->GetSocket());
            pFsm->QueueWorkItem();
            ++dwUnblocked;
            --dwCount;
        } else {
            pPrev = pCur;
        }
        pCur = (CPriorityListEntry *)pPrev->Next();
    }
    m_BlockedQueue.Release();

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
ICAsyncThread::CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Examines to see if a blocked FSM is still blocked in order to prevent
        wasted processing if it isn't.

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

Return Value:

    DWORD
        Number of work items that are currently blocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    m_BlockedQueue.Acquire();

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            ++dwFound;
            --dwCount;
        }
        pCur = (CPriorityListEntry *)pCur->Next();
    }
    m_BlockedQueue.Release();

    DEBUG_LEAVE(dwFound);

    return dwFound;
}


DWORD
ICAsyncThread::SelectThreadWrapper(
    IN ICAsyncThread * pThread
    )

/*++

Routine Description:

    Kicks off select thread as member function of pThread object

Arguments:

    pThread - pointer to thread object

Return Value:

    DWORD
        return code from SelectThread (not used)

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThreadWrapper",
                 "%#x",
                 pThread
                 ));

    DWORD error = pThread->SelectThread();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::SelectThread(
    VOID
    )

/*++

Routine Description:

    Waits for completed items on blocked queue to finish, either due to timeout,
    invalidated request handle or successful or error completion of the socket
    operation.

    Completed items are put on the work queue and a worker signalled to process
    it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    //
    // we need thread info for debug output
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(ASYNC,
                    FATAL,
                    ("Can't get thread info block\n"
                    ));

        INET_ASSERT(FALSE);

        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThread",
                 NULL
                 ));

    //
    // have to create select socket in this thread or winsock blocks main thread
    // on Win95 when autodial enabled
    //

    DWORD error = CreateSelectSocket();

    if (error != ERROR_SUCCESS) {

        DEBUG_LEAVE(error);

        return error;
    }

    DWORD ticks = GetTickCountWrap();

    while (!IsTerminating()) {

        //
        // run through the blocked items finding sockets to wait on and minimum
        // time to wait. If we find any items already timed out or invalidated
        // then remove them and put on the work queue
        //

        m_BlockedQueue.Acquire();

        PLIST_ENTRY pEntry;
        PLIST_ENTRY pPrev;

        pPrev = m_BlockedQueue.Self();

        //
        // BUGBUG - queue limited by size of FD_SET
        //

        struct fd_set read_fds;
        struct fd_set write_fds;
        struct fd_set except_fds;
        int n = 0;
        BOOL bLazy = FALSE;
        DWORD timeout = 0xffffffff;
        DWORD timeNow = GetTickCountWrap();

        FD_ZERO(&read_fds);
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);

        FD_SET(m_SelectSocket, &read_fds);
        ++n;

        CFsm * pFsm;

        for (pEntry = m_BlockedQueue.Head();
             pEntry != m_BlockedQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

            pFsm = ContainingFsm((LPVOID)pEntry);
            if (pFsm->IsInvalid() || pFsm->IsTimedOut(timeNow)) {

                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_BlockedQueue.Remove((CPriorityListEntry *)pEntry);
                pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_INTERNET_OPERATION_CANCELLED
                                        : ERROR_INTERNET_TIMEOUT
                                        );
                pFsm->ResetSocket();
                pFsm->QueueWorkItem();
                continue;
            } else if (pFsm->IsActive()) {

                SOCKET sock = pFsm->GetSocket();

                if (pFsm->GetAction() == FSM_ACTION_RECEIVE) {

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("FSM %#x READ waiting on socket %#x\n",
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &read_fds);
                } else {

                    //
                    // connect() & send()
                    //

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x WRITE waiting on socket %#x\n",
                                pFsm->MapType(),
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &write_fds);
                }

                //
                // all sockets are checked for exception
                //

                FD_SET(sock, &except_fds);
                ++n;
//DWORD t;
//if ((t = pFsm->GetElapsedTime()) > 10) {
//    dprintf("%s FSM %#x socket %#x on queue %d mSec times-out in %d\n",
//    pFsm->MapType(),
//    pFsm,
//    sock,
//    t,
//    pFsm->GetTimeout() - GetTickCount());
//}
            }

            DWORD interval = pFsm->GetTimeout() - timeNow;

            if (interval < timeout) {
                timeout = interval;
//dprintf("min timeout = %d\n", timeout);
            }
            pPrev = pEntry;
        }

        m_BlockedQueue.Release();

        //
        // BUGBUG - wait for default (5 secs) timeout if nothing currently on
        //          list
        //

        if (n == 1) {
            timeout = g_bHibernating ? INFINITE : DEFAULT_ASYNC_THREAD_TIMEOUT;
            bLazy = TRUE;
        }

        INET_ASSERT(n <= FD_SETSIZE);

        struct timeval to;

        to.tv_sec = timeout / 1000;
        to.tv_usec = (timeout % 1000) * 1000;

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    to.tv_sec,
                    to.tv_usec,
                    n
                    ));

        //SuspendCAP();

        if (IsTerminating()) {
            break;
        }
        n = PERF_Select(n, &read_fds, &write_fds, &except_fds, &to);
        if (IsTerminating()) {
            break;
        }

        //ResumeCAP();

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        //
        // if the only thing that's happened is that a new request has been
        // added to the list then rebuild the list and re-select
        //

        if ((n == 1) && FD_ISSET(m_SelectSocket, &read_fds)) {
            if (!DrainSelectSocket() && !IsTerminating()) {
                RecreateSelectSocket();
            }
            continue;
        }

        //
        // if any items are completed (either successfully or with an error)
        // or timed out or invalidated then put them on the work queue
        //

        if (n >= 0) {
            m_BlockedQueue.Acquire();

            pPrev = m_BlockedQueue.Self();
            timeNow = GetTickCountWrap();

            for (pEntry = m_BlockedQueue.Head();
                 pEntry != m_BlockedQueue.Self();
                 pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

                DWORD dwEntryError;
                BOOL bComplete = FALSE;
                LONG lPriority = TP_NO_PRIORITY_CHANGE;

                pFsm = ContainingFsm((LPVOID)pEntry);
                if (pFsm->IsInvalid()) {

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x invalid\n",
                                pFsm->MapType(),
                                pFsm
                                ));

                    dwEntryError = ERROR_INTERNET_OPERATION_CANCELLED;
                    bComplete = TRUE;
                } else if (pFsm->IsTimedOut(timeNow)) {

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x timed out\n",
                                pFsm->MapType(),
                                pFsm
                                ));

                    dwEntryError = ERROR_INTERNET_TIMEOUT;
                    bComplete = TRUE;
                } else if (pFsm->IsActive()) {

                    SOCKET sock = pFsm->GetSocket();

                    if (FD_ISSET(sock, &except_fds)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x socket %#x exception\n",
                                    pFsm->MapType(),
                                    pFsm,
                                    sock
                                    ));

                        switch (pFsm->GetAction()) {
                        case FSM_ACTION_CONNECT:
                            dwEntryError = ERROR_INTERNET_CANNOT_CONNECT;
                            break;

                        case FSM_ACTION_SEND:
                        case FSM_ACTION_RECEIVE:
                            dwEntryError = ERROR_INTERNET_CONNECTION_RESET;
                            break;

                        default:

                            INET_ASSERT(FALSE);

                            break;
                        }
                        bComplete = TRUE;
                    } else if (FD_ISSET(sock, &read_fds)
                    || FD_ISSET(sock, &write_fds)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x socket %#x completed\n",
                                    pFsm->MapType(),
                                    pFsm,
                                    sock
                                    ));

                        dwEntryError = ERROR_SUCCESS;
                        bComplete = TRUE;

                        //
                        // BUGBUG - the priority needs to be boosted
                        //

                    }
                }
                if (bComplete) {
                    m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
                    if (dwEntryError != ERROR_SUCCESS) {
                        pFsm->SetErrorState(dwEntryError);
                    } else {
                        pFsm->SetError(ERROR_SUCCESS);
                        pFsm->SetState(pFsm->GetNextState());
                    }
                    pFsm->SetPriority(lPriority);

//dprintf("%s FSM %#x socket %#x signalled, time on queue = %d\n", pFsm->MapType(), pFsm, pFsm->GetSocket(), pFsm->StopTimer());
                    //
                    // no longer waiting on this socket handle
                    //

                    pFsm->ResetSocket();

                    //
                    // BUGBUG - if the next operation will complete quickly
                    //          (FSM_HINT_QUICK) then we should run it here
                    //          instead of queuing to another thread
                    //

                    pFsm->QueueWorkItem();
                } else {
                    pPrev = pEntry;
                }
            }
            m_BlockedQueue.Release();
        } else {
            error = _I_WSAGetLastError();

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("select() returns %d (%s)\n",
                        error,
                        InternetMapError(error)
                        ));

            //
            // WSAENOTSOCK can happen if the socket was cancelled just
            // before we waited on it. We can also get WSAEINTR if
            // select() is terminated early (by APC)
            //

            INET_ASSERT((error == WSAENOTSOCK) || (error == WSAEINTR) || (error == WSAEBADF));

            if (error == WSAEINTR) {
                continue;
            }

            //
            // when running on a portable (& probably desktops also), if we
            // suspend & resume, the select socket can be invalidated. We
            // need to recognize this situation and handle it
            //

            if (error == WSAENOTSOCK) {

                //
                // the select socket may be dead. Throw it away & create a new
                // one. We should pick up any blocked requests that tried
                // unsuccessfully to interrupt the old select socket
                //

                RecreateSelectSocket();
            } else {

                //
                // some socket(s) other than the select socket has become
                // invalid. Cancel the corresponding request(s)
                //
            }
        }

        //
        // perform timed events
        //

        if ((GetTickCountWrap() - ticks) >= DEFAULT_ASYNC_THREAD_TIMEOUT) {
            if( bLazy == TRUE && !InDllCleanup && !IsTerminating())
            {
                //
                // wake background task mgr
                // this may involve one of the background workitem
                // to be queued and get executed
                //
                NotifyBackgroundTaskMgr();
            }
            PurgeServerInfoList(FALSE);
            ticks = GetTickCountWrap();
        }
    }
    TerminateAsyncSupport();

    DEBUG_LEAVE(error);
//dprintf("!!! Waiter FSM is done\n");
    return error;
}


DWORD
ICAsyncThread::CreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    In order to not have to keep inefficiently polling select() with a short
    time-out, we create a 'trick' datagram socket that we can use to interrupt
    select() with: this is a local socket, and if we send something to ourself
    then select() will complete (assuming one of the sockets we are waiting on
    is the one we create here)

    N.B. Sockets support must be initialized by the time we get here

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - mapped socket error

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::CreateSelectSocket",
                 NULL
                 ));

    INET_ASSERT(m_SelectSocket == INVALID_SOCKET);

    DWORD error;
    SOCKET sock;

    sock = _I_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("socket() failed\n"
                    ));

        goto socket_error;
    }

    SOCKADDR_IN sockAddr;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 0;
    *(LPDWORD)&sockAddr.sin_addr = _I_htonl(INADDR_LOOPBACK);
    memset(&sockAddr.sin_zero, 0, sizeof(sockAddr.sin_zero));

    int rc;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("binding socket %#x to address %d.%d.%d.%d\n",
                sock,
                ((LPBYTE)&sockAddr.sin_addr)[0] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[1] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[2] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[3] & 0xff
                ));

    rc = _I_bind(sock, (LPSOCKADDR)&sockAddr, sizeof(sockAddr));
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("bind() failed\n"
                    ));

        goto socket_error;
    }

    int namelen;
    SOCKADDR sockname;
    namelen = sizeof(sockname);

    rc = _I_getsockname(sock, &sockname, &namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("getsockname() failed\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(ASYNC,
                INFO,
                ("connecting to address %d.%d.%d.%d\n",
                ((LPBYTE)&sockname.sa_data)[2] & 0xff,
                ((LPBYTE)&sockname.sa_data)[3] & 0xff,
                ((LPBYTE)&sockname.sa_data)[4] & 0xff,
                ((LPBYTE)&sockname.sa_data)[5] & 0xff
                ));

    rc = _I_connect(sock, &sockname, namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("connect() failed\n"
                    ));

        goto socket_error;
    }

    m_SelectSocket = sock;
    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    DestroySelectSocket();
    goto quit;
}


VOID
ICAsyncThread::DestroySelectSocket(
    VOID
    )

/*++

Routine Description:

    Just closes SelectSocket (if we think its open)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::DestroySelectSocket",
                 NULL
                 ));

    if (m_SelectSocket != INVALID_SOCKET) {
        _I_closesocket(m_SelectSocket);
        m_SelectSocket = INVALID_SOCKET;
    }

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::RecreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    Attempt to destroy & recreate select socket. Required when socket is killed
    due to suspend, e.g.

    Since the underlying net components may take a while to restart, we loop up
    to 12 times, waiting up to ~16 secs (~32 secs cumulative)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::RecreateSelectSocket",
                 NULL
                 ));

    DestroySelectSocket();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("current interrupt count = %d\n",
                m_lSelectInterrupts
                ));

    m_lSelectInterrupts = -1;

    int iterations = 12;
    DWORD time = 8;
    DWORD error;

    do {
        error = CreateSelectSocket();
        if (error != ERROR_SUCCESS) {
            PERF_Sleep(time);
            time <<= 1;
        }
    } while ((error != ERROR_SUCCESS) && --iterations);

    DEBUG_LEAVE(0);
}

VOID 
InterruptSelect(
    VOID
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "InterruptSelect",
                 NULL
                 ));

    __try 
    {
        if (p_AsyncThread != NULL) 
        {
            p_AsyncThread->InterruptSelect();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    ENDEXCEPT

    DEBUG_LEAVE(0);

    return;
}


VOID
ICAsyncThread::InterruptSelect(
    VOID
    )

/*++

Routine Description:

    We interrupt a waiting select() by sending a small amount of data to ourself
    on the 'trick datagram socket'

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::InterruptSelect",
                 NULL
                 ));

    //
    // if the async select socket is already created then interrupt it. If it is
    // not yet created then it probably means that the async scheduler thread
    // hasn't gotten around to it yet, ipso facto the async scheduler can't be
    // stuck in a select(), hence its okay to skip
    //

    if (m_SelectSocket != INVALID_SOCKET) {
        if (InterlockedIncrement(&m_lSelectInterrupts) == 0) {
            if (_I_send != NULL) {
#if INET_DEBUG
                int nSent =
#endif
                _I_send(m_SelectSocket, gszBang, 1, 0);

#if INET_DEBUG
                if (nSent < 0) {

                    DWORD error = _I_WSAGetLastError();

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("send(%#x) returns %s (%d)\n",
                                m_SelectSocket,
                                InternetMapError(error),
                                error
                                ));

                }

                INET_ASSERT(!InDllCleanup ? (nSent == 1) : TRUE);
#endif
            }
        } else {
            InterlockedDecrement(&m_lSelectInterrupts);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("select() already interrupted, count = %d\n",
                        m_lSelectInterrupts
                        ));

        }
    } else {

        DEBUG_PRINT(ASYNC,
                    WARNING,
                    ("select socket not yet created\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


BOOL
ICAsyncThread::DrainSelectSocket(
    VOID
    )

/*++

Routine Description:

    Just reads the data written to the async select socket in order to wake up
    select()

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - successfully drained

        FALSE   - error occurred

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Bool,
                 "ICAsyncThread::DrainSelectSocket",
                 NULL
                 ));

    BOOL bSuccess = TRUE;

    if (m_SelectSocket != INVALID_SOCKET) {

        //
        // reduce the interrupt count. Threads making async requests will cause
        // the select() to be interrupted again
        //

        InterlockedDecrement(&m_lSelectInterrupts);

        char buf[32];
        int nReceived;

        nReceived = _I_recv(m_SelectSocket, buf, sizeof(buf), 0);

#ifdef unix
        if(nReceived > -1)
        {
#endif /* unix */

        //INET_ASSERT(nReceived == 1);
        //INET_ASSERT(buf[0] == '!');

#ifdef unix
        }
#endif /* unix */

        if (nReceived < 0) {

            DWORD error = _I_WSAGetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("recv() returns %s [%d]\n",
                        InternetMapError(error),
                        error
                        ));

            bSuccess = FALSE;
        }
    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("m_SelectSocket == INVALID_SOCKET\n"
                    ));

        bSuccess = FALSE;
    }

    DEBUG_LEAVE(bSuccess);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\fsm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    fsm.cxx

Abstract:

    Contains CFsm class implementation

    Contents:
        ContainingFsm
        DoFsm
        CFsm::CFsm
        CFsm::~CFsm
        CFsm::Push
        CFsm::Pop
        CFsm::QueueWorkItem
        CFsm::RunWorkItem
        CFsm::Run
        [CFsm::MapType]
        [CFsm::StateName]

Author:

     Richard L Firth (rfirth) 11-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    11-Apr-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

#ifdef USE_DINARES_FSM_ALLOC_CACHE

CRITICAL_SECTION        FsmAllocCritSec;
void *                  FsmAllocList;
size_t                  FsmAllocSize;

#endif

#if INET_DEBUG

struct { int size; char* name; } class_sizes[] = {
    sizeof(CFsm), "CFsm",
    sizeof(CFsm_ResolveHost), "CFsm_ResolveHost",
    sizeof(CFsm_FtpConnect), "CFsm_FtpConnect",
    sizeof(CFsm_FtpFindFirstFile), "CFsm_FtpFindFirstFile",
    sizeof(CFsm_FtpGetFile), "CFsm_FtpGetFile",
    sizeof(CFsm_FtpPutFile), "CFsm_FtpPutFile",
    sizeof(CFsm_FtpDeleteFile), "CFsm_FtpDeleteFile",
    sizeof(CFsm_FtpRenameFile), "CFsm_FtpRenameFile",
    sizeof(CFsm_FtpOpenFile), "CFsm_FtpOpenFile",
    sizeof(CFsm_FtpCreateDirectory), "CFsm_FtpCreateDirectory",
    sizeof(CFsm_FtpRemoveDirectory), "CFsm_FtpRemoveDirectory",
    sizeof(CFsm_FtpSetCurrentDirectory), "CFsm_FtpSetCurrentDirectory",
    sizeof(CFsm_FtpGetCurrentDirectory), "CFsm_FtpGetCurrentDirectory",
    sizeof(CFsm_GopherFindFirstFile), "CFsm_GopherFindFirstFile",
    sizeof(CFsm_GopherOpenFile), "CFsm_GopherOpenFile",
    sizeof(CFsm_GopherGetAttribute), "CFsm_GopherGetAttribute",
    sizeof(CFsm_InternetParseUrl), "CFsm_InternetParseUrl",
    sizeof(CFsm_InternetFindNextFile), "CFsm_InternetFindNextFile",
    sizeof(CFsm_InternetQueryDataAvailable), "CFsm_InternetQueryDataAvailable",
    sizeof(CFsm_InternetWriteFile), "CFsm_InternetWriteFile",
    sizeof(CFsm_InternetReadFile), "CFsm_InternetReadFile",
    sizeof(CFsm_SocketConnect), "CFsm_SocketConnect",
    sizeof(CFsm_SocketSend), "CFsm_SocketSend",
    sizeof(CFsm_SocketReceive), "CFsm_SocketReceive",
    //sizeof(CFsm_SocketDataAvailable), "CFsm_SocketDataAvailable",
    sizeof(CFsm_SecureConnect), "CFsm_SecureConnect",
    sizeof(CFsm_SecureHandshake), "CFsm_SecureHandshake",
    sizeof(CFsm_SecureNegotiate), "CFsm_SecureNegotiate",
    sizeof(CFsm_NegotiateLoop), "CFsm_NegotiateLoop",
    sizeof(CFsm_SecureSend), "CFsm_SecureSend",
    sizeof(CFsm_SecureReceive), "CFsm_SecureReceive",
    sizeof(CFsm_GetConnection), "CFsm_GetConnection",
    sizeof(CFsm_HttpSendRequest), "CFsm_HttpSendRequest",
    sizeof(CFsm_MakeConnection), "CFsm_MakeConnection",
    sizeof(CFsm_OpenConnection), "CFsm_OpenConnection",
    sizeof(CFsm_OpenProxyTunnel), "CFsm_OpenProxyTunnel",
    sizeof(CFsm_SendRequest), "CFsm_SendRequest",
    sizeof(CFsm_ReceiveResponse), "CFsm_ReceiveResponse",
    sizeof(CFsm_HttpReadData), "CFsm_HttpReadData",
    sizeof(CFsm_HttpWriteData), "CFsm_HttpWriteData",
    sizeof(CFsm_ReadData), "CFsm_ReadData",
    sizeof(CFsm_HttpQueryAvailable), "CFsm_HttpQueryAvailable",
    sizeof(CFsm_DrainResponse), "CFsm_DrainResponse",
    sizeof(CFsm_Redirect), "CFsm_Redirect",
    sizeof(CFsm_ReadLoop), "CFsm_ReadLoop",
    sizeof(CFsm_ParseHttpUrl), "CFsm_ParseHttpUrl",
    sizeof(CFsm_OpenUrl), "CFsm_OpenUrl",
    sizeof(CFsm_ParseUrlForHttp), "CFsm_ParseUrlForHttp",
    sizeof(CFsm_ReadFile), "CFsm_ReadFile",
    sizeof(CFsm_ReadFileEx), "CFsm_ReadFileEx",
    //sizeof(CFsm_WriteFile), "CFsm_WriteFile",
    sizeof(CFsm_BackgroundTask), "CFsm_BackgroundTask",
    sizeof(CFsm_QueryAvailable), "CFsm_QueryAvailable"
};

void dump_class_sizes() {
    for (int i = 0; i < ARRAY_ELEMENTS(class_sizes); ++i) {
        DEBUG_PRINT(ASYNC,INFO,("%s = %d\n", class_sizes[i].name, class_sizes[i].size));
    }
}

#endif

//
// functions
//

//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


VOID
FsmInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmInitialize",
                NULL
                ));

    InitializeCriticalSection(&FsmAllocCritSec);

    FsmAllocSize = sizeof(CFsm);
    if (FsmAllocSize < sizeof(CFsm_ResolveHost))
        FsmAllocSize = sizeof(CFsm_ResolveHost);
    if (FsmAllocSize < sizeof(CFsm_SocketConnect))
        FsmAllocSize = sizeof(CFsm_SocketConnect);
    if (FsmAllocSize < sizeof(CFsm_SocketSend))
        FsmAllocSize = sizeof(CFsm_SocketSend);
    if (FsmAllocSize < sizeof(CFsm_SocketReceive))
        FsmAllocSize = sizeof(CFsm_SocketReceive);
    if (FsmAllocSize < sizeof(CFsm_SecureConnect))
        FsmAllocSize = sizeof(CFsm_SecureConnect);
    if (FsmAllocSize < sizeof(CFsm_SecureHandshake))
        FsmAllocSize = sizeof(CFsm_SecureHandshake);
    if (FsmAllocSize < sizeof(CFsm_SecureNegotiate))
        FsmAllocSize = sizeof(CFsm_SecureNegotiate);
    if (FsmAllocSize < sizeof(CFsm_NegotiateLoop))
        FsmAllocSize = sizeof(CFsm_NegotiateLoop);
    if (FsmAllocSize < sizeof(CFsm_SecureSend))
        FsmAllocSize = sizeof(CFsm_SecureSend);
    if (FsmAllocSize < sizeof(CFsm_SecureReceive))
        FsmAllocSize = sizeof(CFsm_SecureReceive);
    if (FsmAllocSize < sizeof(CFsm_GetConnection))
        FsmAllocSize = sizeof(CFsm_GetConnection);
    if (FsmAllocSize < sizeof(CFsm_HttpSendRequest))
        FsmAllocSize = sizeof(CFsm_HttpSendRequest);
    if (FsmAllocSize < sizeof(CFsm_MakeConnection))
        FsmAllocSize = sizeof(CFsm_MakeConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenConnection))
        FsmAllocSize = sizeof(CFsm_OpenConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenProxyTunnel))
        FsmAllocSize = sizeof(CFsm_OpenProxyTunnel);
    if (FsmAllocSize < sizeof(CFsm_SendRequest))
        FsmAllocSize = sizeof(CFsm_SendRequest);
    if (FsmAllocSize < sizeof(CFsm_ReceiveResponse))
        FsmAllocSize = sizeof(CFsm_ReceiveResponse);
    if (FsmAllocSize < sizeof(CFsm_HttpReadData))
        FsmAllocSize = sizeof(CFsm_HttpReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpWriteData))
        FsmAllocSize = sizeof(CFsm_HttpWriteData);
    if (FsmAllocSize < sizeof(CFsm_ReadData))
        FsmAllocSize = sizeof(CFsm_ReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpQueryAvailable))
        FsmAllocSize = sizeof(CFsm_HttpQueryAvailable);
    if (FsmAllocSize < sizeof(CFsm_DrainResponse))
        FsmAllocSize = sizeof(CFsm_DrainResponse);
    if (FsmAllocSize < sizeof(CFsm_Redirect))
        FsmAllocSize = sizeof(CFsm_Redirect);
    if (FsmAllocSize < sizeof(CFsm_ReadLoop))
        FsmAllocSize = sizeof(CFsm_ReadLoop);
    if (FsmAllocSize < sizeof(CFsm_ParseHttpUrl))
        FsmAllocSize = sizeof(CFsm_ParseHttpUrl);
    if (FsmAllocSize < sizeof(CFsm_OpenUrl))
        FsmAllocSize = sizeof(CFsm_OpenUrl);
    if (FsmAllocSize < sizeof(CFsm_ParseUrlForHttp))
        FsmAllocSize = sizeof(CFsm_ParseUrlForHttp);
    if (FsmAllocSize < sizeof(CFsm_ReadFile))
        FsmAllocSize = sizeof(CFsm_ReadFile);
    if (FsmAllocSize < sizeof(CFsm_ReadFileEx))
        FsmAllocSize = sizeof(CFsm_ReadFileEx);
    if (FsmAllocSize < sizeof(CFsm_QueryAvailable))
        FsmAllocSize = sizeof(CFsm_QueryAvailable);

    //
    // Pre-allocate a pool of state-machines for locality of reference
    //

    for (int cPreAlloc = 8192 / FsmAllocSize; cPreAlloc > 0; --cPreAlloc)
    {
        void * pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);

        if (pFsm == NULL)
            break;

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;
    }
}


VOID
FsmTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of FsmInitialize - frees any system resources allocated by
    FsmInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmTerminate",
                NULL
                ));

    //
    // there shouldn't be any other threads active when this function is called
    // but we'll grab the critical section anyway, just to make sure
    //

    EnterCriticalSection(&FsmAllocCritSec);

    while (FsmAllocList)
    {
        void * pFsm = FsmAllocList;
        FsmAllocList = *(void **)pFsm;
        FREE_MEMORY((HLOCAL)pFsm);
    }

    LeaveCriticalSection(&FsmAllocCritSec);

    //
    // delete the critical section
    //

    DeleteCriticalSection(&FsmAllocCritSec);

    DEBUG_LEAVE(0);
}

#endif


CFsm *
ContainingFsm(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of CFsm object, including vtable

Arguments:

    lpAddress   - pointer to list inside CFsm object

Return Value:

    CFsm *  - pointer to start of object

--*/

{
    return CONTAINING_RECORD(lpAddress, CFsm, m_ListEntry);
}


//DWORD
//RunAll(
//    VOID
//    )
//{
//    DWORD error;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//    if (lpThreadInfo != NULL) {
//        while (lpThreadInfo->Fsm != NULL) {
//            lpThreadInfo->Fsm->Run();
//        }
//    } else {
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//    }
//    return error;
//}


DWORD
DoFsm(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Common FSM run processing

Arguments:

    pFsm    - FSM to run (maybe NULL if new failed)

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        if (pFsm != NULL) {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                error = pFsm->Run(lpThreadInfo, NULL, NULL);
            } else {

                INET_ASSERT(FALSE);

                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_INTERNET_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// methods
//


//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs. Not used right now.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


void *
CFsm::operator new(
    IN size_t Size
    )

/*++

Routine Description:

    Allocates memory for the new state-machine from a special memory pool.

Arguments:

    Size        - size of the state-machine

Return Value:

    None.

--*/

{
    VOID * pFsm;

    EnterCriticalSection(&FsmAllocCritSec);

    pFsm = FsmAllocList;

    if (pFsm)
    {
        FsmAllocList = *(void **)pFsm;
    }

    LeaveCriticalSection(&FsmAllocCritSec);

    if (pFsm == NULL)
    {
        INET_ASSERT(Size <= FsmAllocSize);

        pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);
    }

    return(pFsm);
}


VOID
CFsm::operator delete(
    IN VOID * pFsm
    )

/*++

Routine Description:

    Deallocates memory for the state-machine by adding it to a special
    memory pool.

Arguments:

    pFsm        - pointer to the state-machine

Return Value:

    None.

--*/

{
    if (pFsm)
    {
        EnterCriticalSection(&FsmAllocCritSec);

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;

        LeaveCriticalSection(&FsmAllocCritSec);
    }
}
#endif


CFsm::CFsm(
    IN DWORD (* lpfnHandler)(CFsm *),
    IN LPVOID lpvContext
    ) : CPriorityListEntry(0)

/*++

Routine Description:

    CFsm constructor. This gets called many times since its the base of all the
    derived FSMs

Arguments:

    lpfnHandler - state-machine handler

    lpvContext  - callee context

Return Value:

    None.

--*/

{
#if INET_DEBUG
    static bool b = TRUE;
    if (b) {
        dump_class_sizes();
        b=FALSE;
    }
#endif

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::CFsm",
                 "{%#x}",
                 this
                 ));

    INIT_FSM();

    m_lpThreadInfo = InternetGetThreadInfo();
    if (m_lpThreadInfo == NULL) {

        INET_ASSERT(m_lpThreadInfo != NULL);

        SetError(ERROR_INTERNET_INTERNAL_ERROR);

        DEBUG_LEAVE(0);

        return;
    }
    m_dwContext = m_lpThreadInfo->Context;
    m_hObject = m_lpThreadInfo->hObject;
    m_hObjectMapped = (INTERNET_HANDLE_OBJECT *)m_lpThreadInfo->hObjectMapped;
    m_dwMappedErrorCode = m_lpThreadInfo->dwMappedErrorCode;
    m_State = FSM_STATE_INIT;
    m_NextState = FSM_STATE_CONTINUE;
    m_FunctionState = FSM_STATE_BAD;
    m_lpfnHandler = lpfnHandler;
    m_lpvContext = lpvContext;
    SetError(ERROR_SUCCESS);
    Push();
    m_Hint = FSM_HINT_SLOW;
    m_Socket = INVALID_SOCKET;
    m_Action = FSM_ACTION_NONE;
    m_dwBlockId = 0;
    m_dwTimeout = INFINITE;
    m_fTimeoutWraps = FALSE;
    m_dwTimer = 0;
    m_bTimerStarted = FALSE;
    m_bIsBlockingFsm = FALSE;
    m_bIsApi = FALSE;
    m_ApiType = ApiType_None;
    m_dwApiData = 0;
    m_ApiResult.Handle = NULL;

    DEBUG_LEAVE(0);
}


CFsm::~CFsm()

/*++

Routine Description:

    CFsm desctructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::~CFsm",
                 "{%#x}",
                 this
                 ));

    CHECK_FSM();
    CHECK_OWNED();

    Pop();    

#ifdef STRESS_BUG_DEBUG
    m_Link = (CFsm *) (DWORD_PTR)-3;
    m_dwError = 0xFEFEFEFE;
    m_lpThreadInfo = (LPINTERNET_THREAD_INFO) (DWORD_PTR)-3;
    m_dwContext = 0xFEFEFEFE;
    m_hObject = (HINTERNET)(DWORD_PTR)-3;
#endif

    DEBUG_LEAVE(0);
}


VOID
CFsm::Push(
    VOID
    )

/*++

Routine Description:

    Adds this FSM to the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Push",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    CHECK_FSM();
    CHECK_UNOWNED();
    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);

    m_Link = m_lpThreadInfo->Fsm;
    m_lpThreadInfo->Fsm = this;

    CHECK_FSM_OWNED(m_Link);
    RESET_FSM_OWNED(m_Link);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x unowned\n", m_Link
                ));

    SET_OWNED();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                this,
                GetCurrentThreadId()
                ));

    DEBUG_LEAVE(0);
}


VOID
CFsm::Pop(
    VOID
    )

/*++

Routine Description:

    Puts the next FSM (if any) at the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Pop",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);
    CHECK_FSM();
    CHECK_OWNED();
    CHECK_FSM_UNOWNED(m_Link);

    CFsm * pNextFsm = m_Link;

    m_lpThreadInfo->Fsm = pNextFsm;

    SET_FSM_OWNED(pNextFsm);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                pNextFsm,
                GetCurrentThreadId()
                ));

    if (pNextFsm != NULL) {
        pNextFsm->SetState(pNextFsm->GetNextState());
        pNextFsm->SetError(GetError());

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("next FSM %#x (%s), state %s, function-state %s\n",
                    pNextFsm,
                    pNextFsm->MapType(),
                    pNextFsm->MapState(),
                    pNextFsm->MapFunctionState()
                    ));

    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("last FSM\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


DWORD
CFsm::QueueWorkItem(
    VOID
    )

/*++

Routine Description:

    Queues this FSM to worker thread for processing. Worker thread callback is
    CFsm::RunWorkItem

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from SHQueueUserWorkItem

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::QueueWorkItem",
                 "{%#x [%s, socket %#x, block id %#x, timeout %#x, error %d, state %s:%s]}",
                 this,
                 MapType(),
                 GetSocket(),
                 GetBlockId(),
                 GetTimeout(),
                 GetError(),
                 MapState(),
                 MapFunctionState()
                 ));

    DWORD error = ERROR_IO_PENDING;

    RESET_OWNED();

    if (SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)RunWorkItem,
                            this,
                            0,
                            (DWORD_PTR)0,
                            (DWORD_PTR *)NULL,
                            NULL,
                            0)) {

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        INET_ASSERT(lpThreadInfo != NULL);

        if (lpThreadInfo != NULL) {
            lpThreadInfo->Fsm = NULL;
        }
    } else {
        error = GetLastError();
    }

    INET_ASSERT(error == ERROR_IO_PENDING);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::RunWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Run the current work item to the next block state or completion. This
    (class static) function is called in the context of a system thread pool
    callback function

Arguments:

    pFsm    - pointer to FSM to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    lpThreadInfo->IsAsyncWorkerThread = TRUE;

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "RunWorkItem",
                 "%#x",
                 pFsm
                 ));

    PERF_ENTER(Worker);

    DWORD error;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("%s Fsm %#x: socket %#x, block id %#x, timeout %#x, error %d\n",
                pFsm->MapType(),
                pFsm,
                pFsm->GetSocket(),
                pFsm->GetBlockId(),
                pFsm->GetTimeout(),
                pFsm->GetError()
                ));

    while (TRUE) {

        INET_ASSERT(pFsm != NULL);

        BOOL bIsApi = pFsm->IsApi();
        API_TYPE apiType = pFsm->GetApiType();

        lpThreadInfo->Fsm = pFsm;

        SET_FSM_OWNED(pFsm);

        DWORD   dwResult=0;
        DWORD   dwApiData=0;

        if (pFsm->IsInvalid())
        {
            pFsm->SetErrorState(ERROR_INTERNET_OPERATION_CANCELLED);
            pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }
        else
        {
            error = pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
        }

        //
        // We should follow the following rules for this.
        //
        //  1)  If Operation Failed
        //
        //      error != ERROR_SUCCESS && dwResult == 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      INTERNET_ASYNC_RESULT.dwResult = 0
        //      INTERNET_ASYNC_RESULT.dwError = error
                
        //  2) If operation Succeeded
        //
        //  error == ERROR_SUCCESS && dwResult != 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      if( ApiReturnType == HINTERNET )
        //          INTERNET_ASYNC_RESULT.dwResult = (HINTERNET)dwApiResult
        //      else
        //          if( ApiReturnType == BOOL )
        //              INTERNET_ASYNC_RESULT.dwResult = TRUE
        //          endif
        //      endif
        //
        //      INTERNET_ASYNC_RESULT.dwError = dwApiData

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("dwResult = %d [%#x], dwApiData=%d [%#x], apiType = %s, error = %d\n",
                    dwResult, dwResult,
                    dwApiData, dwApiData,
                    (apiType==ApiType_Handle)?"HANDLE":"BOOL",
                    error));



        if (error == ERROR_IO_PENDING) {
            break;
        }
        pFsm = lpThreadInfo->Fsm;
        if (pFsm == NULL) {
            if (bIsApi
            && ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                ->IsAsyncHandle()) {

                INET_ASSERT((apiType == ApiType_Handle)
                            || (apiType == ApiType_Bool));

                INTERNET_ASYNC_RESULT asyncResult;


		/*
                asyncResult.dwResult = (apiType == ApiType_Handle)
                                     ? dwResult
                                     : (BOOL)(error == ERROR_SUCCESS);
		*/

                asyncResult.dwResult = (error == ERROR_SUCCESS
                                            ?((apiType == ApiType_Handle)
                                                ? dwResult
                                                : TRUE)
                                            :0);

                //
                // InternetQueryDataAvailable uses dwApiData to return the
                // number of bytes available, in addition to returning the
                // the value through the lpdwNumberOfBytesAvailable parameter
                //

                asyncResult.dwError = (error == ERROR_SUCCESS)
                                        ? dwApiData
                                        : error;
                SetLastError(error);

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                InternetIndicateStatus(INTERNET_STATUS_REQUEST_COMPLETE,
                                       (LPVOID)&asyncResult,
                                       sizeof(asyncResult)
                                       );

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
            }
            break;
        } else if (bIsApi) {

            //
            // completing an async API that is not the last in the chain.
            // Typically, HttpSendRequest() within InternetOpenUrl()
            //

            DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
        }
    }

    lpThreadInfo->IsAsyncWorkerThread = FALSE;

    PERF_LEAVE(Worker);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::Run(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    OUT DWORD  *lpdwApiResult OPTIONAL,
    OUT DWORD  *lpdwApiData OPTIONAL
    )

/*++

Routine Description:

    Runs the state handler for this FSM

Arguments:

    lpThreadInfo    - INTERNET_THREAD_INFO for this thread

    lpdwApiResult   - where optional API result is written

    lpdwApiData     - where optional API data iswritten

Return Value:

    DWORD   - return code from state handler

--*/

{

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::Run",
                 "%#x, %#x [%#x], %#x [%#x]",
                 lpThreadInfo,
                 lpdwApiResult,
                 (lpdwApiResult?*lpdwApiResult:NULL),
                 lpdwApiData,
                 (lpdwApiData?*lpdwApiData:NULL)
                 ));

    CHECK_FSM();
    CHECK_OWNED();
    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->Fsm != NULL);

    DWORD error = ERROR_SUCCESS;

    lpThreadInfo->Context = m_dwContext;
    _InternetSetObjectHandle(lpThreadInfo, m_hObject, m_hObjectMapped);

    m_lpThreadInfo = lpThreadInfo;

    while (TRUE) {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s Fsm %#x state %s (%d) function-state %s (%d) error %s (%d)\n",
                    MapType(),
                    this,
                    MapState(),
                    GetState(),
                    MapFunctionState(),
                    GetFunctionState(),
                    InternetMapError(GetError()),
                    GetError()
                    ));

        error = (*m_lpfnHandler)(this);

        if (error == ERROR_IO_PENDING) {
            break;
        }
        SetError(error);
        SetMappedError(lpThreadInfo->dwMappedErrorCode);
        if (IsDone()) {

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s Fsm %#x done, next is %s %#x\n",
                        MapType(),
                        this,
                        m_Link ? m_Link->MapType() : "",
                        m_Link
                        ));

            if (lpdwApiResult != NULL) {
                *lpdwApiResult = GetApiResult();
            }
            if (lpdwApiData != NULL) {
                *lpdwApiData = GetApiData();
            }


            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("Fsm %#x finished with lpdwApiResult = %#x[%#x], lpdwApiData = %#x[%#x]\n",
                        this,
                		lpdwApiResult,
                		(lpdwApiResult == NULL)?NULL:*lpdwApiResult,
                		lpdwApiData,
                		(lpdwApiData == NULL)?NULL:*lpdwApiData
                		));
            delete this;
            break;
        }
        SetState(GetNextState());
    }

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

#if !defined(CASE_OF)
#define CASE_OF(x) case x: return #x
#endif

DEBUG_FUNCTION
LPSTR
CFsm::MapType(
    VOID
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    case FSM_TYPE_FTP_CONNECT:              return "FTP_CONNECT";
    case FSM_TYPE_FTP_FIND_FIRST_FILE:      return "FTP_FIND_FIRST_FILE";
    case FSM_TYPE_FTP_GET_FILE:             return "FTP_GET_FILE";
    case FSM_TYPE_FTP_PUT_FILE:             return "FTP_PUT_FILE";
    case FSM_TYPE_FTP_DELETE_FILE:          return "FTP_DELETE_FILE";
    case FSM_TYPE_FTP_RENAME_FILE:          return "FTP_RENAME_FILE";
    case FSM_TYPE_FTP_OPEN_FILE:            return "FTP_OPEN_FILE";
    case FSM_TYPE_FTP_CREATE_DIRECTORY:     return "FTP_CREATE_DIRECTORY";
    case FSM_TYPE_FTP_REMOVE_DIRECTORY:     return "FTP_REMOVE_DIRECTORY";
    case FSM_TYPE_FTP_SET_CURRENT_DIRECTORY:    return "FTP_SET_CURRENT_DIRECTORY";
    case FSM_TYPE_FTP_GET_CURRENT_DIRECTORY:    return "FTP_GET_CURRENT_DIRECTORY";
    case FSM_TYPE_GOPHER_FIND_FIRST_FILE:   return "GOPHER_FIND_FIRST_FILE";
    case FSM_TYPE_GOPHER_OPEN_FILE:         return "GOPHER_OPEN_FILE";
    case FSM_TYPE_GOPHER_GET_ATTRIBUTE:     return "GOPHER_GET_ATTRIBUTE";
    case FSM_TYPE_INTERNET_PARSE_URL:       return "INTERNET_PARSE_URL";
    case FSM_TYPE_INTERNET_FIND_NEXT_FILE:  return "INTERNET_FIND_NEXT_FILE";
    case FSM_TYPE_INTERNET_QUERY_DATA_AVAILABLE:    return "INTERNET_QUERY_DATA_AVAILABLE";
    case FSM_TYPE_INTERNET_WRITE_FILE:      return "INTERNET_WRITE_FILE";
    case FSM_TYPE_INTERNET_READ_FILE:       return "INTERNET_READ_FILE";
    }
    return "?";
}

DEBUG_FUNCTION
LPSTR
CFsm::StateName(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\icstring.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    icstring.cxx

Abstract:

    Contains ICSTRING class methods. Split from ICSTRING.HXX (inline methods)

    Contents:
        ICSTRING::ICSTRING(ICSTRING&)
        ICSTRING::~ICSTRING()
        ICSTRING::operator=(LPSTR)
        ICSTRING::operator=(ICSTRING&)
        ICSTRING::operator+=(LPSTR)
        ICSTRING::operator+=(char)
        ICSTRING::strncat(LPVOID, DWORD)
        ICSTRING::CreateStringBuffer(LPVOID, DWORD, DWORD)
        ICSTRING::CreateOffsetString(DWORD, DWORD)
        ICSTRING::CopyTo(LPSTR)
        ICSTRING::CopyTo(LPSTR, LPSTR)
        ICSTRING::CopyTo(LPSTR, DWORD)
        ICSTRING::CopyTo(LPSTR, LPDWORD)

Author:

    Richard L Firth (rfirth) 18-Dec-1995

Revision History:

    18-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>

//
// methods
//

//
//ICSTRING::ICSTRING(
//    IN ICSTRING& String
//    )
//
///*++
//
//Routine Description:
//
//    copy constructor. We now create an entirely new string (used to be just a
//    reference of the rvalue)
//
//Arguments:
//
//    String  - to copy
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    //
//    // can't already have string in lvalue, & rvalue mustn't be an offset string
//    //
//
//    INET_ASSERT(!HaveString());
//    INET_ASSERT(!String.IsOffset());
//    INET_ASSERT(!String.IsError());
//
//    *this = String.StringAddress();
//}


ICSTRING::~ICSTRING(
    VOID
    )

/*++

Routine Description:

    destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // can only free the string if it is not a reference. Offset type
    // implies reference
    //

    if (!IsReference() && (_String != NULL)) {

        INET_ASSERT(!IsOffset());

        (VOID)ResizeBuffer((HLOCAL)_String, 0, FALSE);
        _String = NULL;
    }
}


ICSTRING&
ICSTRING::operator=(
    IN LPSTR String
    )

/*++

Routine Description:

    Copy/assigment. Copies a string to this object. If NULL, frees up the
    current buffer

Arguments:

    String  - to be assigned

Return Value:

    ICSTRING&

--*/

{
    //
    // if this is an offset string then there's not much to do
    //

    if (IsOffset()) {
        Initialize();
        return *this;
    }

    //
    // string MUST NOT be a copy (we'll free the real string pointer, owned
    // by another object) and SHOULD NOT be copied itself (the objects with
    // copies of the string will potentially have a bad pointer)
    //

    INET_ASSERT((String == NULL) ? TRUE : !IsReference());
    INET_ASSERT(!IsReferenced());

    //
    // if the pointer is NULL or the string is empty then we are freeing the
    // string pointer
    //

    DWORD len;

    if (String == NULL) {
        len = 0;
    } else {
        len = ::strlen(String);
        if (len != 0) {
            INET_ASSERT(len < 0xffffffff);
            ++len;
        }
    }

    //
    // free or grow the buffer, depending on requirements
    //

    if ((len > _BufferLength) || ((len == 0) && (_String != NULL))) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, len, FALSE);
        _BufferLength = (_String != NULL) ? len : 0;
    }
    if (_String != NULL) {

        INET_ASSERT(len != 0);

        memcpy((LPVOID)_String, (LPVOID)String, len);
        _StringLength = len - 1;
        SetHaveString(TRUE);
        SetError(FALSE);
    } else {
        _StringLength = 0;
        SetHaveString(FALSE);
        SetError(len != 0); // an error might have occurred
    }
    return *this;
}


ICSTRING&
ICSTRING::operator=(
    IN ICSTRING& String
    )

/*++

Routine Description:

    Copy/assignment. Makes new copy of object (used to just make a reference)

Arguments:

    String  - ICSTRING object to be assigned

Return Value:

    ICSTRING&

--*/

{
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!String.IsReferenced());
    INET_ASSERT(!String.IsError());

    //
    // if we're copying an offset, make sure that any string we may already
    // have is freed
    //

    if (String.IsOffset()) {
        if (_String != NULL) {
            ResizeBuffer(_String, 0, FALSE);
        }
        _String = String._String;
        _StringLength = String._StringLength;
        _BufferLength = String._BufferLength;
        _Union.Dword = String._Union.Dword;
    } else {

        INET_ASSERT(!IsOffset() && !String.IsOffset());

        //
        // use string assignment to correctly setup this object
        //

        *this = String.StringAddress();
    }
    return *this;
}


VOID
ICSTRING::operator+=(
    IN LPSTR String
    )

/*++

Routine Description:

    Concatenates a string to the buffer. Reallocates it if necessary. String
    CANNOT be NULL

Arguments:

    String  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());
    INET_ASSERT(String != NULL);

    if (IsError()) {
        return;
    }

    if (*String == '\0') {
        return;
    }

    DWORD len = ::strlen(String);
    DWORD newlen = _StringLength + len + 1;

    INET_ASSERT ((newlen > _StringLength) && (newlen > len));

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        memcpy((LPVOID)((LPBYTE)_String + _StringLength),
               (LPVOID)String,
               len + 1
               );
        _StringLength += len;
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::operator+=(
    IN char Ch
    )

/*++

Routine Description:

    Concatenates a character to the buffer. Reallocates it if necessary. Ch
    CAN be '\0'

Arguments:

    Ch  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());

    if (IsError()) {
        return;
    }

    DWORD newlen = _StringLength + 2;

    INET_ASSERT (newlen > _StringLength);

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        _String[_StringLength] = Ch;
        ++_StringLength;
        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::Strncat(
    IN LPVOID Pointer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies Length characters from Pointer to the end of _String

Arguments:

    Pointer - place to copy from

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    if (IsError()) {
        return;
    }

    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(Length != 0);
    INET_ASSERT(_String != NULL);
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());

    DWORD newLength;

    newLength = _StringLength + Length + 1;

    INET_ASSERT ((newLength > _StringLength) && (newLength > Length));

    if (_BufferLength < newLength) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newLength, FALSE);
        _BufferLength = newLength;
    }
    if (_String != NULL) {
        memcpy((LPVOID)&_String[_StringLength], Pointer, Length);
        _StringLength += Length;

        INET_ASSERT(_StringLength < _BufferLength);

        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateStringBuffer(
    IN LPVOID Pointer,
    IN DWORD StringLength,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    In order to avoid reallocations, if we know the size of the buffer we
    want for several strcat()'s, e.g., we can allocate it once, copy the
    initial string here, then perform multiple concatenate operations (+=)

Arguments:

    Pointer         - place to start copying from

    StringLength    - length of string

    BufferLength    - length of buffer required

Return Value:

    None.

--*/

{
    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(BufferLength > StringLength);
    INET_ASSERT(BufferLength != 0);

    //
    // if we currently have an offset string then initialize to a non-offset
    //

    if (IsOffset()) {
        Initialize();
    }
    _String = (LPSTR)ResizeBuffer(_String, BufferLength, FALSE);
    if (_String != NULL) {
        _StringLength = StringLength;
        _BufferLength = BufferLength;
        memcpy((LPVOID)_String, Pointer, _StringLength);
        _String[_StringLength] = '\0';
        SetHaveString(TRUE);
        SetReference(FALSE);
        SetReferenced(FALSE);
        SetOffset(FALSE);
        SetError(FALSE);
    } else {
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateOffsetString(
    IN DWORD Offset,
    IN DWORD Length
    )

/*++

Routine Description:

    Create a reference ICSTRING that is an offset within another buffer

Arguments:

    Offset  - offset into buffer

    Length  - of string

Return Value:

    None.

--*/

{
    _String = (LPSTR)(DWORD_PTR)Offset;
    _StringLength = Length;
    _BufferLength = Length;
    ZapFlags();
    SetHaveString(TRUE);    // ICSTRING initialized with non-NULL
    SetReference(TRUE);     // reference to another string buffer
    SetOffset(TRUE);        // offset from base
    SetError(FALSE);
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies source _String to destination Buffer

Arguments:

    Buffer  - place to copy to

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    memcpy((LPVOID)Buffer, (LPVOID)_String, _StringLength);
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Base,
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies a based (offset) string from source Base + _String to destination
    Buffer

Arguments:

    Base    - value for base

    Buffer  - place to write string

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    //INET_ASSERT(IsOffset() ? (Base != NULL) : (Base == NULL));

    memcpy((LPVOID)Buffer,
           IsOffset() ? (Base + (DWORD_PTR)_String) : _String,
           _StringLength
           );
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies at most Length characters from source _String to destination
    Buffer

Arguments:

    Buffer  - place to write string

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Copies at most *Length characters from source _String to destination
    Buffer. Updates *Length to be number of characters copied, not including
    terminating NUL

Arguments:

    Buffer  - place to write string

    Length  - IN: length of buffer
              OUT: number of characters copied

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(*Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
    *Length = length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\iwinsock.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    iwinsock.cxx

Abstract:

    Contains functions to load sockets DLL and entry points. Functions and data
    in this module take care of indirecting sockets calls, hence _I_ in front
    of the function name

    Contents:
        IwinsockInitialize
        IwinsockTerminate
        LoadWinsock
        UnloadWinsock
        SafeCloseSocket

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Added support for Socks Firewalls.

    05-Mar-1998 rfirth
        Moved SOCKS support into ICSocket class. Removed SOCKS library
        loading/unloading from this module (revert to pre-SOCKS)

--*/

#include <wininetp.h>

#if defined(__cplusplus)
extern "C" {
#endif


#if INET_DEBUG

#if defined(RETAIL_LOGGING)
#define DPRINTF (void)
#else
#define DPRINTF dprintf
#endif

VOID
InitDebugSock(
    VOID
    );

VOID
TerminateDebugSock(
    VOID
    );

#else
#define DPRINTF (void)
#endif

//
// private types
//

typedef struct {
#if defined(unix)
    LPSTR FunctionOrdinal;
#else
    DWORD FunctionOrdinal;
#endif /* unix */
    FARPROC * FunctionAddress;
} SOCKETS_FUNCTION;


//
// global data
//

GLOBAL
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    ) = NULL;

GLOBAL
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    const char FAR * lpHostName
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getpeername)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

GLOBAL
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    ) = NULL;

GLOBAL
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    ) = NULL;

GLOBAL
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSACleanup)(
    void
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    ) = NULL;

GLOBAL
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getaddrinfo)(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    ) = NULL;

GLOBAL
void
(PASCAL FAR * _I_freeaddrinfo)(
    IN struct addrinfo *ai
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getnameinfo)(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    ) = NULL;


GLOBAL
int
(PASCAL FAR * _I_WSALookupServiceBeginW)(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    ) = NULL;


GLOBAL
int
(PASCAL FAR * _I_WSALookupServiceNextW)(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSALookupServiceEnd)(
    IN HANDLE  hLookup
    ) = NULL;


GLOBAL
int
(PASCAL FAR * _I_WSANSPIoctl)(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    ) = NULL;

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// private data
//

//
// InitializationLock - protects against multiple threads loading WSOCK32.DLL
// and entry points
//

PRIVATE CRITICAL_SECTION InitializationLock = {0};

//
// hWinsock - NULL when WSOCK32.DLL is not loaded
// hWs2_32 - NULL when WS2_32.DLL is not loaded.
// hAddrResLib - NULL when WS2_32.DLL/WSHIPV6.DLL is not loaded
//      If WS2_32.DLL is loaded in the process and it has IPv6 entry points,
//      hAddrResLib==hWs2_32, otherwise it is handle to WSHIPV6.DLL if
//      the latter is present and usable (IPv6 is present).
//

PRIVATE HINSTANCE hWinsock = NULL;
PRIVATE HINSTANCE hWs2_32 = NULL;
PRIVATE HINSTANCE hAddrResLib = NULL;

//
// WinsockLoadCount - the number of times we have made calls to LoadWinsock()
// and UnloadWinsock(). When this reaches 0 (again), we can unload the Winsock
// DLL for real
//

PRIVATE DWORD WinsockLoadCount = 0;

//
// SocketsFunctions - this is the list of entry points in WSOCK32.DLL that we
// need to load for WININET.DLL
//

#if !defined(unix)

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    1,      (FARPROC*)&_I_accept,
    2,      (FARPROC*)&_I_bind,
    3,      (FARPROC*)&_I_closesocket,
    4,      (FARPROC*)&_I_connect,
    5,      (FARPROC*)&_I_getpeername,
    6,      (FARPROC*)&_I_getsockname,
    7,      (FARPROC*)&_I_getsockopt,
    8,      (FARPROC*)&_I_htonl,
    9,      (FARPROC*)&_I_htons,
    10,     (FARPROC*)&_I_inet_addr,
    11,     (FARPROC*)&_I_inet_ntoa,
    12,     (FARPROC*)&_I_ioctlsocket,
    13,     (FARPROC*)&_I_listen,
    15,     (FARPROC*)&_I_ntohs,
    16,     (FARPROC*)&_I_recv,
    17,     (FARPROC*)&_I_recvfrom,
    18,     (FARPROC*)&_I_select,
    19,     (FARPROC*)&_I_send,
    20,     (FARPROC*)&_I_sendto,
    21,     (FARPROC*)&_I_setsockopt,
    22,     (FARPROC*)&_I_shutdown,
    23,     (FARPROC*)&_I_socket,
    52,     (FARPROC*)&_I_gethostbyname,
    57,     (FARPROC*)&_I_gethostname,
    111,    (FARPROC*)&_I_WSAGetLastError,
    112,    (FARPROC*)&_I_WSASetLastError,
    115,    (FARPROC*)&_I_WSAStartup,
    116,    (FARPROC*)&_I_WSACleanup,
    151,    (FARPROC*)&_I___WSAFDIsSet
};

#else

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    "MwAccept",         (FARPROC*)&_I_accept,
    "MwBind",           (FARPROC*)&_I_bind,
    "closesocket",      (FARPROC*)&_I_closesocket,
    "MwConnect",        (FARPROC*)&_I_connect,
    "MwGetpeername",    (FARPROC*)&_I_getpeername,
    "MwGetsockname",    (FARPROC*)&_I_getsockname,
    "MwGetsockopt",     (FARPROC*)&_I_getsockopt,
    "MwHtonl",          (FARPROC*)&_I_htonl,
    "MwHtons",          (FARPROC*)&_I_htons,
    "MwInet_addr",      (FARPROC*)&_I_inet_addr,
    "MwInet_ntoa",      (FARPROC*)&_I_inet_ntoa,
    "ioctlsocket",      (FARPROC*)&_I_ioctlsocket,
    "MwListen",         (FARPROC*)&_I_listen,
    "MwNtohs",          (FARPROC*)&_I_ntohs,
    "MwRecv",           (FARPROC*)&_I_recv,
    "MwRecvfrom",       (FARPROC*)&_I_recvfrom,
    "MwSelect",         (FARPROC*)&_I_select,
    "MwSend",           (FARPROC*)&_I_send,
    "MwSendto",         (FARPROC*)&_I_sendto,
    "MwSetsockopt",     (FARPROC*)&_I_setsockopt,
    "MwShutdown",       (FARPROC*)&_I_shutdown,
    "MwSocket",         (FARPROC*)&_I_socket,
    "MwGethostbyname",  (FARPROC*)&_I_gethostbyname,
    "MwGethostname",    (FARPROC*)&_I_gethostname,
    "WSAGetLastError",  (FARPROC*)&_I_WSAGetLastError,
    "WSASetLastError",  (FARPROC*)&_I_WSASetLastError,
    "WSAStartup",       (FARPROC*)&_I_WSAStartup,
    "WSACleanup",       (FARPROC*)&_I_WSACleanup,
#if 0
    "",                 (FARPROC*)&_I___WSAFDIsSet
#endif
};

#endif /* unix */

//
// private prototypes
//

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

int
PASCAL FAR
LimitedGetAddrInfo(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

void
PASCAL FAR
LimitedFreeAddrInfo(
    IN struct addrinfo *ai
    );

int
PASCAL FAR
LimitedGetNameInfo(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    );

//
// functions
//


VOID
IwinsockInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization/resource allocation for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // initialize the critical section that protects against multiple threads
    // trying to initialize Winsock
    //

    InitializeCriticalSection(&InitializationLock);

#if INET_DEBUG
    InitDebugSock();
#endif
}


VOID
IwinsockTerminate(
    VOID
    )

/*++

Routine Description:

    Performs termination & resource cleanup for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    DeleteCriticalSection(&InitializationLock);

#if INET_DEBUG
    TerminateDebugSock();
#endif
}


DWORD
LoadWinsock(
    VOID
    )

/*++

Routine Description:

    Dynamically loads Windows sockets library

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error
                    e.g. LoadLibrary() failure

                  WSA error
                    e.g. WSAStartup() failure

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "LoadWinsock",
                NULL
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    EnterCriticalSection(&InitializationLock);

    if (hWinsock == NULL) {

        BOOL failed = FALSE;

        DPRINTF("Attempting to load winsock\n");

        //
        // Even though we attempt to load WinSock 2 (ws2_32.dll) below,
        // we still load WinSock 1 (wsock32.dll) here because some of the
        // supposedly identical ordinal numbers were changed between
        // versions, thus breaking pure binary compatibility.
        //

        hWinsock = LoadLibrary("wsock32");
        if (hWinsock != NULL) {

            //
            // Load function entry points from the WinSock library.
            //

            FARPROC farProc;

            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {

                farProc = GetProcAddress(
                                hWinsock,
                                (LPCSTR)(DWORD_PTR)SocketsFunctions[i].FunctionOrdinal
                                );
                if (farProc == NULL) {
                    failed = TRUE;
                    DPRINTF("Can't find entry %d in function array\n", i);
                    break;
                }
                *SocketsFunctions[i].FunctionAddress = farProc;
            }
            if (!failed) {

                //
                // although we need a WSADATA for WSAStartup(), it is an
                // expendible structure (not required for any other sockets
                // calls)
                //

                WSADATA wsaData;

                error = _I_WSAStartup(0x0101, &wsaData);
                if (error == ERROR_SUCCESS) {

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("winsock description: %q\n",
                                wsaData.szDescription
                                ));

                    int stringLen;

                    stringLen = lstrlen(wsaData.szDescription);
                    if (strnistr(wsaData.szDescription, "novell", stringLen)
                    && strnistr(wsaData.szDescription, "wsock32", stringLen)) {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("running on Novell Client32 stack\n"
                                    ));

                        GlobalRunningNovellClient32 = TRUE;
                    }
#if INET_DEBUG
                    SetupSocketsTracing();
#endif

                    //
                    // We may need to load ws2_32 for several purposes.
                    // If the functionality is actually not available,
                    // we do not want to keep around unnecessarily.
                    // This refcount will help us decide.
                    //
                    INT ws2_32RefCount = 0;

                    //
                    // Attempt load ws2_32.dll.  
                    //
                    DPRINTF("Checking for presence of ws2_32\n");
                    hWs2_32 = LoadLibrary ("ws2_32");
                    if (hWs2_32!=NULL) {
                        //
                        // Try to locate name resolution API
                        // necessary to access Network Location Awareness
                        // service (available on Whistler).
                        //
                        if (GlobalPlatformWhistler) {
                            farProc = GetProcAddress (hWs2_32,
                                                        "WSALookupServiceBeginW");
                            if (farProc!=NULL) {
                                *(FARPROC *)&_I_WSALookupServiceBeginW = farProc;
                                farProc = GetProcAddress (hWs2_32,
                                                        "WSALookupServiceEnd");
                                if (farProc!=NULL) {
                                    *(FARPROC *)&_I_WSALookupServiceEnd = farProc;
                                    farProc = GetProcAddress (hWs2_32,
                                                        "WSALookupServiceNextW");
                                    if (farProc!=NULL) {
                                        *(FARPROC *)&_I_WSALookupServiceNextW = farProc;
                                        farProc = GetProcAddress (hWs2_32,
                                                        "WSANSPIoctl");
                                        if (farProc!=NULL) {
                                            *(FARPROC *)&_I_WSANSPIoctl = farProc;
                                        }
                                    }
                                }
                            }

                            if (farProc!=NULL) {
                                //
                                // Increment ws2_32 ref count for
                                // the purpose of NLA
                                //
                                ws2_32RefCount += 1;
                            }
                            else {
                                _I_WSALookupServiceBeginW = NULL;
                                _I_WSALookupServiceEnd = NULL;
                                _I_WSALookupServiceNextW = NULL;
                                _I_WSANSPIoctl = NULL;
                            }
                        }

                        //
                        // Try to locate the address family independent name
                        // resolution routines (i.e. getaddrinfo, getnameinfo).
                        // In Whistler and beyond, these will be present in
                        // the WinSock 2 library (ws2_32.dll).
                        //

                        // Restricting to Whistler only.
                        if (GlobalPlatformWhistler) 
                        {
                            DPRINTF("Looking in ws2_32 for getaddrinfo\n");
                            farProc = GetProcAddress(hWs2_32, "getaddrinfo");
                            if (farProc != NULL) {
                                //
                                // Increment ws2_32 ref count for
                                // the purpose of IPv6 address resolution.
                                //
                                ws2_32RefCount += 1;
                                hAddrResLib = hWs2_32;
                            }
                        }
                    }

                    // Restricting to Whistler only.
                    if ((hAddrResLib == NULL) 
                        && GlobalPlatformWhistler) 
                    {
                        //
                        // In the IPv6 Technology Preview, the address family
                        // independent name resolution calls are snuck in via
                        // the IPv6 WinSock helper library (wship6.dll).
                        // So look there next.
                        //
                        DPRINTF("Looking in wship6 for getaddrinfo\n");
                        hAddrResLib = LoadLibrary("wship6");
                        if (hAddrResLib != NULL) {
                            farProc = GetProcAddress(hAddrResLib,
                                                     "getaddrinfo");
                            if (farProc == NULL) {
                                FreeLibrary(hAddrResLib);
                                hAddrResLib = NULL;

                            } else {
                                //
                                // The Tech Preview version of the address
                                // family independent APIs doesn't check that
                                // an IPv6 stack is present before returning
                                // IPv6 addresses.  So we need to check for it.
                                //
                                SOCKET Test;
                                struct sockaddr_in6 TestSA;

                                DPRINTF("Checking for active IPv6 stack\n");
                                error = SOCKET_ERROR;
                                Test = _I_socket(PF_INET6, 0, 0);
                                if (Test != INVALID_SOCKET) {
                                    memset(&TestSA, 0, sizeof(TestSA));
                                    TestSA.sin6_family = AF_INET6;
                                    TestSA.sin6_addr.s6_addr[15] = 1;
                                    error = _I_bind(Test, (LPSOCKADDR)&TestSA,
                                                    sizeof(TestSA));
                                    _I_closesocket(Test);
                                }
                                if (error != 0) {
                                    DPRINTF("IPv6 stack is not active\n");
                                    FreeLibrary(hAddrResLib);
                                    hAddrResLib = NULL;
                                    error = 0;
                                }
                            }
                        }
                    }

                    if (hAddrResLib != NULL) {
                        //
                        // Use routines from this library.  Since getaddrinfo
                        // is here, we expect the others to be also, but will
                        // fall back to IPv4-only if any of them is missing.
                        //
                        *(FARPROC *)&_I_getaddrinfo = farProc;
                        farProc = GetProcAddress(hAddrResLib, "freeaddrinfo");
                        if (farProc != NULL) {
                            *(FARPROC *)&_I_freeaddrinfo = farProc;
                            farProc = GetProcAddress(hAddrResLib,
                                                     "getnameinfo");
                            if (farProc != NULL)
                                *(FARPROC *)&_I_getnameinfo = farProc;
                        }
                        if (farProc == NULL) {
                            if (hAddrResLib!=hWs2_32) {
                                FreeLibrary(hAddrResLib);
                            }
                            else {
                                ws2_32RefCount -= 1;
                            }
                            hAddrResLib = NULL;
                        }
                    }

                    if (hAddrResLib == NULL) {
                        //
                        // If we can't find getaddrinfo lying around on the
                        // system somewhere, assume we're still in the
                        // IPv4-only dark ages.
                        //
                        DPRINTF("Using IPv4-only name res functions\n");
                        _I_getaddrinfo = LimitedGetAddrInfo;
                        _I_freeaddrinfo = LimitedFreeAddrInfo;
                        _I_getnameinfo = LimitedGetNameInfo;
                    }

                    //
                    // Check if we actually used ws2_32 for anything
                    // and unload it if not.
                    //
                    if (ws2_32RefCount==0 && hWs2_32!=NULL) {
                        FreeLibrary (hWs2_32);
                        hWs2_32 = NULL;
                    }

                } else {
                    DPRINTF("Winsock failed to start\n");
                    failed = TRUE;
                }
            }
        } else {
            DPRINTF("Couldn't load the winsock library\n");
            failed = TRUE;
        }

        //
        // if we failed to find an entry point or WSAStartup() returned an error
        // then unload the library
        //

        if (failed) {

            //
            // important: there should be no API calls between determining the
            // failure and coming here to get the error code
            //
            // if error == ERROR_SUCCESS then we have to get the last error, else
            // it is the error returned by WSAStartup()
            //

            if (error == ERROR_SUCCESS) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

            }
            DPRINTF("Unloading winsock due to error 0x%x\n", error);
            UnloadWinsock();
        }
    } else {

        //
        // just increment the number of times we have called LoadWinsock()
        // without a corresponding call to UnloadWinsock();
        //

        ++WinsockLoadCount;
    }

    LeaveCriticalSection(&InitializationLock);

    //
    // if we failed for any reason, need to report that TCP/IP not available
    //

    if (error != ERROR_SUCCESS) {
        error = ERROR_INTERNET_TCPIP_NOT_INSTALLED;
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
UnloadWinsock(
    VOID
    )

/*++

Routine Description:

    Unloads winsock DLL and prepares hWinsock and SocketsFunctions[] for reload

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "UnloadWinsock",
                 NULL
                 ));

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    EnterCriticalSection(&InitializationLock);

    //
    // only unload the DLL if it has been mapped into process memory
    //

    if (hWinsock != NULL) {

        //
        // and only if this is the last load instance
        //

        if (WinsockLoadCount == 0) {

            INET_ASSERT(_I_WSACleanup != NULL);

            if (_I_WSACleanup != NULL) {

                //
                // need to terminate async support too - it is reliant on
                // Winsock
                //

                TerminateAsyncSupport();

                int serr = _I_WSACleanup();

                if (serr != 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("WSACleanup() returns %d; WSA error = %d\n",
                                serr,
                                (_I_WSAGetLastError != NULL)
                                    ? _I_WSAGetLastError()
                                    : -1
                                ));

                }
            }
            if (hAddrResLib != NULL) {
                *(FARPROC *)&_I_getaddrinfo = (FARPROC)NULL;
                *(FARPROC *)&_I_freeaddrinfo = (FARPROC)NULL;
                *(FARPROC *)&_I_getnameinfo = (FARPROC)NULL;
                if (hAddrResLib!=hWs2_32) {
                    FreeLibrary(hAddrResLib);
                }
                hAddrResLib = NULL;
            }
            if (hWs2_32!=NULL) {
                *(FARPROC *)&_I_WSALookupServiceBeginW = (FARPROC)NULL;
                *(FARPROC *)&_I_WSALookupServiceEnd = (FARPROC)NULL;
                *(FARPROC *)&_I_WSALookupServiceNextW = (FARPROC)NULL;
                *(FARPROC *)&_I_WSANSPIoctl = (FARPROC)NULL;
                FreeLibrary (hWs2_32);
                hWs2_32 = NULL;
            }
            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {
                *SocketsFunctions[i].FunctionAddress = (FARPROC)NULL;
            }
            FreeLibrary(hWinsock);
            hWinsock = NULL;
        } else {

            //
            // if there have been multiple virtual loads, then just reduce the
            // load count
            //

            --WinsockLoadCount;
        }
    }

    LeaveCriticalSection(&InitializationLock);

    DEBUG_LEAVE(0);
}

//
// Following is v4-only version of getaddrinfo and friends.
//
// Note that we use LocalAlloc/LocalFree instead of malloc/free
// to avoid introducing a dependency on msvcrt.dll.
//


//* LimitedFreeAddrInfo - Free an addrinfo structure (or chain of structures).
//
//  As specified in RFC 2553, Section 6.4.
//
void WSAAPI
LimitedFreeAddrInfo(
    struct addrinfo *Free)  // Structure (chain) to free.
{
    struct addrinfo *Next;

    for (Next = Free; Next != NULL; Free = Next) {
        if (Free->ai_canonname != NULL)
            LocalFree(Free->ai_canonname);
        if (Free->ai_addr != NULL)
            LocalFree(Free->ai_addr);
        Next = Free->ai_next;
        LocalFree(Free);
    }
}


//* NewAddrInfo - Allocate an addrinfo structure and populate some fields.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns a partially filled-in addrinfo struct, or NULL if out of memory.
//
static struct addrinfo *
NewAddrInfo(
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    struct addrinfo *New;

    //
    // Allocate a new addrinfo structure.
    //
    New = (struct addrinfo *)LocalAlloc(0, sizeof(struct addrinfo));
    if (New == NULL)
        return NULL;

    //
    // Fill in the easy stuff.
    //
    New->ai_flags = 0;
    New->ai_family = PF_INET;
    New->ai_socktype = SocketType;
    New->ai_protocol = Protocol;
    New->ai_addrlen = sizeof(struct sockaddr_in);
    New->ai_canonname = NULL;
    New->ai_addr = (LPSOCKADDR)LocalAlloc(0, New->ai_addrlen);
    if (New->ai_addr == NULL) {
        LocalFree(New);
        return NULL;
    }
    New->ai_next = NULL;

    //
    // Link this one onto the end of the chain.
    //
    **Prev = New;
    *Prev = &New->ai_next;

    return New;
}


//* LookupNode - Resolve a nodename and add any addresses found to the list.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns 0 on success, an EAI_* style error value otherwise.
//
static int
LookupNode(
    const char *NodeName,     // Name of node to resolve.
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    int Flags,                // Flags.
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    struct addrinfo *CurrentInfo;
    struct sockaddr_in *sin;
    struct hostent *hA;
    char **addrs;
    int Error = 0;

    hA = _I_gethostbyname(NodeName);
    if (hA != NULL) {
        if ((hA->h_addrtype == AF_INET) &&
            (hA->h_length == sizeof(struct in_addr))) {

            //
            // Loop through all the addresses returned by gethostbyname,
            // allocating an addrinfo structure and filling in the address
            // field for each.
            //
            for (addrs = hA->h_addr_list; *addrs != NULL; addrs++) {

                CurrentInfo = NewAddrInfo(SocketType, Protocol, Prev);
                if (CurrentInfo == NULL) {
                    Error = EAI_MEMORY;
                    break;
                }

                //
                // We fill in the ai_canonname field in the first addrinfo
                // structure that we return if we've been asked to do so.
                //
                if (Flags & AI_CANONNAME) {
                    if (hA->h_name != NULL) {
                        int NameLength;

                        NameLength = strlen(hA->h_name) + 1;
                        CurrentInfo->ai_canonname = (char *)LocalAlloc(0, NameLength);
                        if (CurrentInfo->ai_canonname == NULL) {
                            Error = EAI_MEMORY;
                            break;
                        }
                        memcpy(CurrentInfo->ai_canonname, hA->h_name, NameLength);
                    }

                    // Turn off flag so we only do this once.
                    Flags &= ~AI_CANONNAME;
                }

                //
                // We're returning IPv4 addresses.
                //
                sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
                sin->sin_family = AF_INET;
                sin->sin_port = 0;
                memcpy(&sin->sin_addr, (struct in_addr *)*addrs, sizeof sin->sin_addr);
                memset(sin->sin_zero, 0, sizeof sin->sin_zero);
            }
        }
    } else {

        Error = _I_WSAGetLastError();
        if (Error == WSANO_DATA) {
            Error = EAI_NODATA;
        } else if (Error == WSAHOST_NOT_FOUND) {
            Error = EAI_NONAME;
        } else {
            Error = EAI_FAIL;
        }
    }

    return Error;
}


//* ParseV4Address
//
//  Helper function for parsing a literal v4 address, because
//  WSAStringToAddress is too liberal in what it accepts.
//  Returns FALSE if there is an error, TRUE for success.
//
//  The syntax is a.b.c.d, where each number is between 0 - 255.
//
static int
ParseV4Address(const char *String, struct in_addr *Addr)
{
    u_int Number;
    int NumChars;
    char Char;
    int i;

    for (i = 0; i < 4; i++) {
        Number = 0;
        NumChars = 0;
        for (;;) {
            Char = *String++;
            if (Char == '\0') {
                if ((NumChars > 0) && (i == 3))
                    break;
                else
                    return FALSE;
            }
            else if (Char == '.') {
                if ((NumChars > 0) && (i < 3))
                    break;
                else
                    return FALSE;
            }
            else if (('0' <= Char) && (Char <= '9')) {
                if ((NumChars != 0) && (Number == 0))
                    return FALSE;
                else if (++NumChars <= 3)
                    Number = 10 * Number + (Char - '0');
                else
                    return FALSE;
            } else
                return FALSE;
        }
        if (Number > 255)
            return FALSE;
        ((u_char *)Addr)[i] = (u_char)Number;
    }

    return TRUE;
}


//* LimitedGetAddrInfo - Protocol-independent name-to-address translation.
//
//  As specified in RFC 2553, Section 6.4.
//
//  This is the hacked version that only supports IPv4.
//
//  Returns zero if successful, an EAI_* error code if not.
//
int WSAAPI
LimitedGetAddrInfo(
    const char *NodeName,          // Node name to lookup.
    const char *ServiceName,       // Service name to lookup.
    const struct addrinfo *Hints,  // Hints about how to process request.
    struct addrinfo **Result)      // Where to return result.
{
    struct addrinfo *CurrentInfo, **Next;
    int ProtocolId = 0;
    u_short ProtocolFamily = PF_UNSPEC;
    int SocketType = 0;
    int Flags = 0;
    int Error;
    struct sockaddr_in *sin;
    struct in_addr TempAddr;

    //
    // This special cut-down version for wininet doesn't do service lookup.
    // So the request must be for nodename lookup.
    //
    INET_ASSERT(ServiceName == NULL);
    INET_ASSERT(NodeName != NULL);

    //
    // In case we have to bail early, make it clear to our caller
    // that we haven't allocated an addrinfo structure.
    //
    *Result = NULL;
    Next = Result;

    //
    // Validate hints argument.
    //
    if (Hints != NULL) {
        //
        // Wininet can be trusted to call us correctly.
        //
        INET_ASSERT((Hints->ai_addrlen == 0) &&
                    (Hints->ai_canonname == NULL) &&
                    (Hints->ai_addr == NULL) &&
                    (Hints->ai_next == NULL));

        Flags = Hints->ai_flags;
        INET_ASSERT(!((Flags & AI_CANONNAME) && (Flags & AI_NUMERICHOST)));

        ProtocolFamily = (u_short)Hints->ai_family;
        INET_ASSERT((ProtocolFamily == PF_UNSPEC) ||
                    (ProtocolFamily == PF_INET));

        SocketType = Hints->ai_socktype;
        INET_ASSERT((SocketType == 0) ||
                    (SocketType == SOCK_STREAM) ||
                    (SocketType == SOCK_DGRAM));

        ProtocolId = Hints->ai_protocol;
    }

    //
    // We have a node name (either alpha or numeric) we need to look up.
    //

    //
    // First, see if this is a numeric string address that we can
    // just convert to a binary address.
    //
    if (ParseV4Address(NodeName, &TempAddr)) {
        //
        // Conversion from IPv4 numeric string to binary address
        // was sucessfull.  Create an addrinfo structure to hold it,
        // and return it to the user.
        //
        CurrentInfo = NewAddrInfo(SocketType, ProtocolId, &Next);
        if (CurrentInfo == NULL) {
            Error = EAI_MEMORY;
            goto Bail;
        }
        sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
        sin->sin_family = AF_INET;
        sin->sin_port = 0;
        sin->sin_addr = TempAddr;
        memset(sin->sin_zero, 0, sizeof sin->sin_zero);

        return 0;  // Success!
    }

    //
    // It's not a numeric string address.  If our caller only wants us
    // to convert numeric addresses, give up now.
    //
    if (Flags & AI_NUMERICHOST) {
        Error = EAI_NONAME;
        goto Bail;
    }

    //
    // Since it's non-numeric, we have to do a regular node name lookup.
    //
    Error = LookupNode(NodeName, SocketType, ProtocolId, Flags, &Next);
    if (Error != 0)
        goto Bail;

    return 0;  // Success!

  Bail:
    if (*Result != NULL) {
        LimitedFreeAddrInfo(*Result);
        *Result = NULL;
    }
    return Error;
}


//* LimitedGetNameInfo - Protocol-independent address-to-name translation.
//
//  As specified in RFC 2553, Section 6.5.
//
//  This is a special version for wininet that only supports IPv4.
//  All extraneous checks have been removed, only the specific calls
//  that wininet makes are supported.
//
//  Note that unless the IE team decides to attempt the FTP EPRT command
//  for IPv4 as well as IPv6 (see comments in ftp\protocol.cxx), this
//  routine will never be called.
//
int WSAAPI
LimitedGetNameInfo(
    const struct sockaddr *SocketAddress,  // Socket address to translate.
    socklen_t SocketAddressLength,         // Length of above socket address.
    char *NodeName,                        // Where to return the node name.
    size_t NodeBufferSize,                 // Size of above buffer.
    char *ServiceName,                     // Where to return the service name.
    size_t ServiceBufferSize,              // Size of above buffer.
    int Flags)                             // Flags of type NI_*.
{
    //
    // Wininet doesn't do service lookup.
    //
    INET_ASSERT((ServiceName == NULL) && (ServiceBufferSize == 0));

    //
    // Wininet can be trusted to call us correctly.
    //
    INET_ASSERT((NodeName != NULL) && (SocketAddress != NULL) &&
                (SocketAddressLength == sizeof(struct sockaddr_in)));

    //
    // This version is IPv4 only.
    //
    INET_ASSERT(SocketAddress->sa_family == AF_INET);

    //
    // Wininet will only call this routine to translate the given address
    // to an IPv4 address literal.
    //
    INET_ASSERT(Flags & NI_NUMERICHOST);
    INET_ASSERT(NodeBufferSize >= sizeof("255.255.255.255"));
    strcpy(NodeName, _I_inet_ntoa(((struct sockaddr_in *)SocketAddress)->sin_addr));

    return 0;
}



DWORD
SafeCloseSocket(
    IN SOCKET Socket
    )

/*++

Routine Description:

    closesocket() call protected by exception handler in case winsock DLL has
    been unloaded by system before Wininet DLL unloaded

Arguments:

    Socket  - socket handle to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - socket error mapped to ERROR_INTERNET_ error

--*/

{
    int serr;

    __try {
        serr = _I_closesocket(Socket);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        serr = 0;
    }
    ENDEXCEPT
    return (serr == SOCKET_ERROR)
        ? MapInternetError(_I_WSAGetLastError())
        : ERROR_SUCCESS;
}

#if INET_DEBUG

//
// debug data types
//

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    );

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    );

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

GLOBAL
SOCKET
(PASCAL FAR * _P_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _P_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _P_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

#define MAX_STACK_TRACE     5
#define MAX_SOCK_ENTRIES    1000

typedef struct _DEBUG_SOCK_ENTRY {
    SOCKET Socket;
    DWORD StackTraceLength;
    PVOID StackTrace[ MAX_STACK_TRACE ];
} DEBUG_SOCK_ENTRY, *LPDEBUG_SOCK_ENTRY;

CRITICAL_SECTION DebugSockLock;
DEBUG_SOCK_ENTRY GlobalSockEntry[MAX_SOCK_ENTRIES];

DWORD GlobalSocketsCount = 0;


#define LOCK_DEBUG_SOCK()   EnterCriticalSection( &DebugSockLock )
#define UNLOCK_DEBUG_SOCK() LeaveCriticalSection( &DebugSockLock )

HINSTANCE NtDllHandle;

typedef USHORT (*RTL_CAPTURE_STACK_BACK_TRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

RTL_CAPTURE_STACK_BACK_TRACE pRtlCaptureStackBackTrace;

VOID
InitDebugSock(
    VOID
    )
{
    InitializeCriticalSection( &DebugSockLock );
    memset( GlobalSockEntry, 0x0, sizeof(GlobalSockEntry) );
    GlobalSocketsCount = 0;
    return;
}

VOID
TerminateDebugSock(
    VOID
    )
{
    DeleteCriticalSection(&DebugSockLock);
}

VOID
SetupSocketsTracing(
    VOID
    )
{
    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }
    if (!IsPlatformWinNT()) {
        return ;
    }
    if ((NtDllHandle = LoadLibrary("ntdll.dll")) == NULL) {
        return ;
    }
    if ((pRtlCaptureStackBackTrace =
        (RTL_CAPTURE_STACK_BACK_TRACE)
            GetProcAddress(NtDllHandle, "RtlCaptureStackBackTrace")) == NULL) {
        FreeLibrary(NtDllHandle);
        return ;
    }

//#ifdef DONT_DO_FOR_NOW
    _P_accept = _I_accept;
    _I_accept = _II_accept;
    _P_closesocket = _I_closesocket;
    _I_closesocket = _II_closesocket;
    _P_socket = _I_socket;
    _I_socket = _II_socket;
//#endif
}

VOID
AddSockEntry(
    SOCKET S
    )
{
    DWORD i;
    DWORD Hash;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    //
    // search for a free entry.
    //

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == 0 ) {

            DWORD Hash;

            //
            // found a free entry.
            //

            GlobalSockEntry[i].Socket = S;

            //
            // get caller stack.
            //

#if i386
            Hash = 0;

            GlobalSockEntry[i].StackTraceLength =
                pRtlCaptureStackBackTrace(
                    2,
                    MAX_STACK_TRACE,
                    GlobalSockEntry[i].StackTrace,
                    &Hash );
#else // i386
            GlobalSockEntry[i].StackTraceLength = 0;
#endif // i386


            GlobalSocketsCount++;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket count = %ld\n",
                        GlobalSocketsCount
                        ));

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

    //
    // we have reached a high handle limit, which is unusal, needs to be
    // debugged.
    //

    INET_ASSERT( FALSE );
    UNLOCK_DEBUG_SOCK();

    return;
}

VOID
RemoveSockEntry(
    SOCKET S
    )
{
    DWORD i;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == S ) {

            //
            // found the entry. Free it now.
            //

            memset( &GlobalSockEntry[i], 0x0, sizeof(DEBUG_SOCK_ENTRY) );

            GlobalSocketsCount--;

#ifdef IWINSOCK_DEBUG_PRINT

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("count(%ld), RemoveSock(%lx)\n",
                        GlobalSocketsCount,
                        S
                        ));

#endif // IWINSOCK_DEBUG_PRINT

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

#ifdef IWINSOCK_DEBUG_PRINT

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("count(%ld), UnknownSock(%lx)\n",
                GlobalSocketsCount,
                S
                ));

#endif // IWINSOCK_DEBUG_PRINT

    //
    // socket entry is not found.
    //

    // INET_ASSERT( FALSE );

    UNLOCK_DEBUG_SOCK();
    return;
}

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    )
{
    SOCKET S;

    S = _P_socket( af, type, protocol );
    AddSockEntry( S );
    return( S );
}

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    )
{
    int Ret;

    RemoveSockEntry( s );
    Ret = _P_closesocket( s );
    return( Ret );
}

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    )
{
    SOCKET S;

    S = _P_accept( s, addr, addrlen );
    AddSockEntry( S );
    return( S );

}

VOID
IWinsockCheckSockets(
    VOID
    )
{
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("GlobalSocketsCount = %d\n",
                GlobalSocketsCount
                ));

    for (DWORD i = 0; i < MAX_SOCK_ENTRIES; ++i) {

        SOCKET sock;

        if ((sock = GlobalSockEntry[i].Socket) != 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Socket %#x\n",
                        sock
                        ));

        }
    }
}

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\icsocket.cxx ===
/*++


Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    icsocket.cxx

Abstract:

    Contains sockets functions and ICSocket methods

    Contents:
        ContainingICSocket
        MapNetAddressToName
        ICSocket::ICSocket
        ICSocket::~ICSocket
        ICSocket::Destroy
        ICSocket::Reference
        ICSocket::Dereference
        ICSocket::EnableSocks
        ICSocket::Connect
        CFsm_SocketConnect::RunSM
        ICSocket::Connect_Start
        ICSocket::Connect_Continue
        ICSocket::Connect_Error
        ICSocket::Connect_Finish
        ICSocket::SocksConnect
        ICSocket::Disconnect
        ICSocket::Close
        ICSocket::Abort
        ICSocket::Shutdown
        ICSocket::IsReset
        ICSocket::SetTimeout
        ICSocket::SetLinger
        ICSocket::SetNonBlockingMode
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID)
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID, LPDWORD)
        ICSocket::SetBufferLength
        ICSocket::SetSendCoalescing
        SetSourcePort
        ICSocket::Send
        CFsm_SocketSend::RunSM
        ICSocket::Send_Start
        ICSocket::SendTo
        ICSocket::Receive
        CFsm_SocketReceive::RunSM
        ICSocket::Receive_Start
        ICSocket::Receive_Continue
        ICSocket::AllocateQueryBuffer
        //ICSocket::FreeQueryBuffer
        //ICSocket::ReceiveFrom
        ICSocket::DataAvailable
        //ICSocket::DataAvailable2
        ICSocket::WaitForReceive
        //ICSocket::GetBytesAvailable
        ICSocket::CreateSocket
        ICSocket::GetSockName
        ICSocket::GetPeerName
        ICSocket::Listen
        ICSocket::DirectConnect
        ICSocket::SelectAccept

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "autodial.h"

//
// private prototypes
//

//
// functions
//

#if INET_DEBUG

PRIVATE LPSTR MapFamily(int family) {
    switch (family) {
    case AF_UNSPEC:     return "AF_UNSPEC";
    case AF_UNIX:       return "AF_UNIX";
    case AF_INET:       return "AF_INET";
    case AF_IMPLINK:    return "AF_IMPLINK";
    case AF_PUP:        return "AF_PUP";
    case AF_CHAOS:      return "AF_CHAOS";
    case AF_IPX:        return "AF_IPX";
    case AF_OSI:        return "AF_OSI";
    case AF_ECMA:       return "AF_ECMA";
    case AF_DATAKIT:    return "AF_DATAKIT";
    case AF_CCITT:      return "AF_CCITT";
    case AF_SNA:        return "AF_SNA";
    case AF_DECnet:     return "AF_DECnet";
    case AF_DLI:        return "AF_DLI";
    case AF_LAT:        return "AF_LAT";
    case AF_HYLINK:     return "AF_HYLINK";
    case AF_APPLETALK:  return "AF_APPLETALK";
    case AF_NETBIOS:    return "AF_NETBIOS";
#if defined(AF_VOICEVIEW)
    case AF_VOICEVIEW:  return "AF_VOICEVIEW";
#endif /* AF_VOICEVIEW */
#if defined(AF_FIREFOX)
    case AF_FIREFOX:    return "AF_FIREFOX";
#endif /* AF_FIREFOX */
#if defined(AF_UNKNOWN1)
    case AF_UNKNOWN1:   return "AF_UNKNOWN1";
#endif /* AF_UNKNOWN1 */
#if defined(AF_BAN)
    case AF_BAN:        return "AF_BAN";
#endif /* AF_BAN */
#if defined(AF_INET6)
    case AF_INET6:      return "AF_INET6";
#endif /* AF_INET6 */
    }
    return "?";
}

PRIVATE LPSTR MapSock(int sock) {
    switch (sock) {
    case SOCK_STREAM:       return "SOCK_STREAM";
    case SOCK_DGRAM:        return "SOCK_DGRAM";
    case SOCK_RAW:          return "SOCK_RAW";
    case SOCK_RDM:          return "SOCK_RDM";
    case SOCK_SEQPACKET:    return "SOCK_SEQPACKET";
    }
    return "?";
}

PRIVATE LPSTR MapProto(int proto) {
    switch (proto) {
    case IPPROTO_IP:    return "IPPROTO_IP";
    case IPPROTO_ICMP:  return "IPPROTO_ICMP";
    case IPPROTO_IGMP:  return "IPPROTO_IGMP";
    case IPPROTO_GGP:   return "IPPROTO_GGP";
    case IPPROTO_TCP:   return "IPPROTO_TCP";
    case IPPROTO_PUP:   return "IPPROTO_PUP";
    case IPPROTO_UDP:   return "IPPROTO_UDP";
    case IPPROTO_IDP:   return "IPPROTO_IDP";
    case IPPROTO_ND:    return "IPPROTO_ND";
    }
    return "?";
}

#endif // INET_DEBUG



ICSocket *
ContainingICSocket(
    LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of ICSocket (i.e. vtable) given address of list

Arguments:

    lpAddress   - address of m_List part of ICSocket

Return Value:

    ICSocket *  - address of start of ICSocket object (also ICSecureSocket)

--*/

{
    return CONTAINING_RECORD(lpAddress, ICSocket, m_List);
}

//
// ICSocket methods
//


ICSocket::ICSocket(
    VOID
    )

/*++

Routine Description:

    ICSocket constructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::ICSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_ICSOCKET();

    m_List.Flink = NULL;
    m_List.Blink = NULL;
    m_dwTimeout = 0;
    m_fTimeoutWraps = 0;
    m_Socket = INVALID_SOCKET;
    m_dwFlags = 0;
    m_bAborted = FALSE;
    m_SocksAddress = 0;
    m_SocksPort = 0;
    m_ReferenceCount = 1;
    m_fExemptConnLImit = FALSE;

    DEBUG_LEAVE(0);
}


ICSocket::~ICSocket()

/*++

Routine Description:

    ICSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::~ICSocket",
                 "{%#x [sock=%#x, port=%d, ref=%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 ReferenceCount()
                 ));

    CHECK_ICSOCKET();

    INET_ASSERT(!IsOnList());
    INET_ASSERT(m_ReferenceCount == 0);

    if (IsOpen()) {
        Close();
    }

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Destroy(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::Destroy",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    INET_ASSERT(ReferenceCount() == 1);

    m_ReferenceCount = 0;
    delete this;

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Reference(
    VOID
    )

/*++

Routine Description:

    Just increases the reference count

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_ICSOCKET();

    InterlockedIncrement(&m_ReferenceCount);
}


BOOL
ICSocket::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count. If it goes to zero, the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - object deleted

        FALSE   - object still alive

--*/

{
    CHECK_ICSOCKET();

    if (InterlockedDecrement(&m_ReferenceCount) == 0) {

        INET_ASSERT(m_ReferenceCount == 0);

        delete this;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
DWORD
ICSocket::EnableSocks(
    IN LPSTR lpSocksHost,
    IN INTERNET_PORT ipSocksPort
    )

/*++

Routine Description:

    Set SOCKS gateway IP address and port in this socket object

Arguments:

    lpSocksHost - IP address or host name of SOCKS host

    ipSocksPort - port address of SOCKS host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_NAME_NOT_RESOLVED
                    failed to resolve SOCKS host name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::EnableSocks",
                 "{%#x/%d} %q, %d",
                 GetSocket(),
                 GetSourcePort(),
                 lpSocksHost,
                 ipSocksPort
                 ));

    DWORD error = ERROR_SUCCESS;

    m_SocksPort = ipSocksPort;
    m_SocksAddress = _I_inet_addr(lpSocksHost);
    if (m_SocksAddress == INADDR_NONE) {    // 0xffffffff

        LPHOSTENT lpHostent = _I_gethostbyname(lpSocksHost);

        if (lpHostent != NULL) {
            m_SocksAddress = **(LPDWORD*)&lpHostent->h_addr_list[0];
        } else {
            m_SocksAddress = 0;
            error = ERROR_INTERNET_NAME_NOT_RESOLVED;
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("SOCKS address = %d.%d.%d.%d:%d\n",
                ((BYTE*)&m_SocksAddress)[0] & 0xff,
                ((BYTE*)&m_SocksAddress)[1] & 0xff,
                ((BYTE*)&m_SocksAddress)[2] & 0xff,
                ((BYTE*)&m_SocksAddress)[3] & 0xff,
                m_SocksPort
                ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SocketConnect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags,
    IN CServerInfo *pServerInfo
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

    pServerInfo - Server Info to connect with

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SocketConnect",
                 "{%#x [%#x]} %d, %d, %#x, %x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags,
                 pServerInfo
                 ));


    DWORD error;

    CFsm_SocketConnect * pFsm;

    pFsm = new CFsm_SocketConnect(Timeout, Retries, dwFlags, this);

    if ( pFsm )
    {
        pFsm->SetServerInfo(pServerInfo);
    }

    error = DoFsm(pFsm);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ICSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

#ifdef TEST_CODE
    Timeout *= 20;
    Retries *= 20;
#endif

    DWORD error;

    error = DoFsm(new CFsm_SocketConnect(Timeout, Retries, dwFlags, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketConnect::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketConnect state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketConnect * stateMachine = (CFsm_SocketConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Connect_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pSocket->Connect_Continue(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = pSocket->Connect_Error(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Start(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Starts a socket connect operation - creates a socket and connects it to a
    server using the address information returned by GetServiceAddress(). There
    may be several addresses to try. We return as soon as we successfully
    generate a connection, or after we have tried <Retries> attempts, or until
    <Timeout> milliseconds have elapsed

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Start",
                 "{%#x [%#x]}, %#x(%d, %d, %#x)",
                 this,
                 m_Socket,
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Start);

    CFsm_SocketConnect & fsm = *Fsm;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    DWORD error = ERROR_SUCCESS;
    int serr = SOCKET_ERROR;

    INET_ASSERT(IsClosed());

    //
    // ensure the next state is CONTINUE. It may be INIT because we could have
    // been looping through bad addresses (if sufficient timeout & retries)
    //

    if(Fsm->GetState() == FSM_STATE_INIT)
    {
        fsm.SetErrorState(error);
    }

    fsm.SetNextState(FSM_STATE_CONTINUE);

    //
    // if we are offline then quit now - we can't make any network requests
    //
    InternetAutodialIfNotLocalHost(NULL, fsm.m_pServerInfo->GetHostName());
    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    //
    // get address to use. If exhausted, re-resolve
    //


    if (fsm.GetFunctionState() == FSM_STATE_2) {
        fsm.SetFunctionState(FSM_STATE_1);
        goto resolve_continue;
    }
    if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                           &fsm.m_dwAddressIndex,
                                           GetPort(),
                                           fsm.m_pAddress
                                           )) {
        if (fsm.m_bResolved) {
            error = ERROR_INTERNET_CANNOT_CONNECT;
        } else {
            fsm.SetFunctionState(FSM_STATE_2);
            fsm.SetNextState(FSM_STATE_INIT);
            error = fsm.m_pServerInfo->ResolveHost(&fsm.m_dwResolutionId,
                                                   fsm.m_dwFlags
                                                   );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

resolve_continue:

            fsm.m_bResolved = TRUE;
            if (error == ERROR_SUCCESS) {
                if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                                       &fsm.m_dwAddressIndex,
                                                       GetPort(),
                                                       fsm.m_pAddress
                                                       )) {
                    error = ERROR_INTERNET_CANNOT_CONNECT;
                }
            }
            else if (error == ERROR_INTERNET_NAME_NOT_RESOLVED)
            {
                fsm.SetNextState(FSM_STATE_CONTINUE);
                goto quit; // exit out NOW with ERROR_INTERNET_NAME_NOT_RESOLVED, instead of CANNOT_CONNECT
            }
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // name resolution failed - done
        //

        goto quit;
    }

    //
    // Update port for keep-alive info.
    //
    // The port number field is in the same location in both a
    // sockaddr_in and a sockaddr_in6, so it is safe to cast the
    // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
    //
    INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) == offsetof(SOCKADDR_IN6, sin6_port));
    SetPort(_I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port));

    //
    // BUGBUG - this code was supplying AF_UNSPEC to socket(), which should
    //          be okay, but because of a bug in the Win95 wsipx driver
    //          which manifests itself when we call bind(), we must send in
    //          the address family supplied in the local socket address by
    //          GetAddressByName()
    //

    int protocol;
    DWORD dwConnFlags;

    protocol = fsm.m_pAddress->iProtocol;

#if defined(SITARA)

    //
    // Only enable Sitara if we're connected via modem
    //

//dprintf("connect_start: IsSitara = %B, IsModemConn=%B\n",GlobalEnableSitara, GlobalHasSitaraModemConn);

    if (GlobalEnableSitara && GlobalHasSitaraModemConn) {
        protocol = (int)GetSitaraProtocol();
    }

#endif // SITARA

    m_Socket = _I_socket(fsm.m_pAddress->LocalAddr.lpSockaddr->sa_family,
                         fsm.m_pAddress->iSocketType,
                         protocol
                         );
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto check_socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    //
    // inform the app that we are connecting to the server (but only on the
    // first attempt)
    //

    //if ((fsm.m_dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(INTERNET_STATUS_CONNECTING_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    //
    // if requested to, put the socket in non-blocking mode
    //

    if (fsm.m_dwFlags & SF_NON_BLOCKING
    && (GlobalRunningNovellClient32 ? GlobalNonBlockingClient32 : TRUE)) {
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) {
            fsm.SetErrorState(error);
            goto quit;
        }
    }

    //
    // bind the socket to the local address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("binding to local address %d.%d.%d.%d, port %d, index %d\n",
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->LocalAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    serr = _I_bind(m_Socket,
                   fsm.m_pAddress->LocalAddr.lpSockaddr,
                   fsm.m_pAddress->LocalAddr.iSockaddrLength
                   );
    if (serr == SOCKET_ERROR) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to bind socket %#x\n",
                    m_Socket
                    ));

        goto check_socket_error;
    }

    //
    // record source port (useful for matching with net sniff)
    //

    SetSourcePort();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("socket %#x bound to port %d (%#x)\n",
                m_Socket,
                m_SourcePort,
                m_SourcePort
                ));

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->SetAbortHandle(this);
    }

    //
    // try to connect to the next address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting %#x/%d to remote address %d.%d.%d.%d, port %d, index %d\n",
                m_Socket,
                m_SourcePort,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    fsm.SetNextState(FSM_STATE_CONTINUE);
    fsm.StartTimer();

#ifdef TEST_CODE
    SetLastError(-1);
    serr = -1;
#else
    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr,
                            fsm.m_pAddress->RemoteAddr.iSockaddrLength
                            );
    } else {
        serr = _I_connect(m_Socket,
                          fsm.m_pAddress->RemoteAddr.lpSockaddr,
                          fsm.m_pAddress->RemoteAddr.iSockaddrLength
                          );
    }
#endif

    //
    // here if a socket operation failed, in which case serr will be SOCKET_ERROR
    //

check_socket_error:

    if (serr == 0) {

        //
        // successful (probably synchronous) connect completion
        //

        //
        // in the sync case, we just call the continue handler. No need to
        // return to the state handler
        //

        Connect_Continue(Fsm);
        goto quit;
    }

    //
    // here if a socket operation failed. We have to read the socket error in
    // this thread before doing anything else or we'll lose the error. We handle
    // it in Connect_Error()
    //

    error = _I_WSAGetLastError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect(%#x) returns %d\n",
                m_Socket,
                error
                ));

    //
    // if we are using non-blocking sockets then we need to wait until the
    // connect has completed, or an error occurs.
    // If we got any status other than WSAEWOULDBLOCK then we have to handle
    // the error
    //

    if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("connect() blocked, socket %#x, port %d\n",
                    m_Socket,
                    m_SourcePort
                    ));

        fsm.SetAction(FSM_ACTION_CONNECT);

        DWORD timeout = GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT);
        INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

        if (pObject != NULL) {
            if (pObject->IsFromCacheTimeoutSet()
            && (pObject->GetObjectType() == TypeHttpRequestHandle)
            && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                timeout = GetTimeoutValue(INTERNET_OPTION_FROM_CACHE_TIMEOUT);

                DWORD connectTime = fsm.m_pServerInfo->GetConnectTime();

                if (connectTime == 0) {
                    connectTime = timeout;
                }
                timeout += connectTime;
            }
        }
        fsm.SetTimeout(timeout);
        fsm.SetNextState(FSM_STATE_CONTINUE);

        //
        // after we set the state to waiting, and get ERROR_IO_PENDING from
        // QueueSocketWorkItem() then we can no longer touch this FSM until
        // it completes asynchronously
        //

        //
        // perf - test the socket. If this completes quickly we don't take a
        // context switch
        //

        //error = WaitForReceive(0);
        //if (error == ERROR_INTERNET_TIMEOUT) {
            error = QueueSocketWorkItem(Fsm, m_Socket);
        //}
        if (error == ERROR_SUCCESS) {

            //
            // in the unlikely event the request completed quickly and
            // successfully
            //

            serr = 0;
            goto check_socket_error;
        } else if (error == ERROR_IO_PENDING) {

            //
            // the request is pending. We already set waiting state
            //

            goto quit;
        }

        //
        // if here then QueueSocketWorkItem() returned some other error
        //

    } else {

        //
        // some other socket error occurred. Convert to INTERNET error
        //

        fsm.SetErrorState(MapInternetError(error));
        error = Connect_Continue(Fsm);
    }

    fsm.SetErrorState(error);

quit:

    //
    // we are done if not pending AND we will not re-enter this state in order
    // to re-do the name resolution/find another address
    //

    if ((error != ERROR_IO_PENDING) && (fsm.GetNextState() != FSM_STATE_INIT)) {
        fsm.SetDone();

        PERF_LEAVE(Connect_Start);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Continue(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Performs common processing after connect completion or failure

Arguments:

    Fsm - reference to socket connect finite state machine

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Continue",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Continue);

    CFsm_SocketConnect & fsm = *Fsm;
    fsm.StopTimer();

//    INET_ASSERT((fsm.GetMappedHandleObject() != NULL)
//        ? (fsm.GetMappedHandleObject()->GetAbortHandle() != NULL)
//        : TRUE);

    DWORD error = fsm.GetError();

    //INET_ASSERT(error != SOCKET_ERROR);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect() resumed, socket %#x, port %d\n",
                m_Socket,
                m_SourcePort
                ));

    //
    // check for aborted request
    //

    if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
        error = ERROR_INTERNET_CANNOT_CONNECT;
    }
    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x/port %d connected; time = %d mSec\n",
                    m_Socket,
                    m_SourcePort,
                    fsm.ReadTimer()
                    ));

        error = Connect_Finish(Fsm);
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to connect socket %#x/port %d: error %s\n",
                    m_Socket,
                    m_SourcePort,
                    InternetMapError(error)
                    ));

        fsm.SetError(error);
        error = Connect_Error(Fsm);
    }

    PERF_LEAVE(Connect_Continue);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Error(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called to handle a connect error. Either causes the FSM to terminate or
    prepares the FSM to try another connection

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Error",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Error);

    CFsm_SocketConnect & fsm = *Fsm;

    fsm.StopTimer();

    if (fsm.IsInvalid()) 
    {
        fsm.SetDone(ERROR_INTERNET_OPERATION_CANCELLED);
        return ERROR_INTERNET_OPERATION_CANCELLED;
    }


    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(pObject != NULL);

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    DWORD error = fsm.GetError();
    BOOL bRestartable = FALSE;

    //INET_ASSERT(error != SOCKET_ERROR);
    INET_ASSERT(error != ERROR_SUCCESS);

    //
    // check for aborted request - this overrides any socket error
    //

    if (IsAborted() || error == ERROR_INTERNET_OPERATION_CANCELLED) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (fsm.IsCountedOut()
               || fsm.IsTimedOut()  // entire request timeout
               || (error == ERROR_INTERNET_TIMEOUT)) {  // just this request t/o

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("counted out or timed out\n"
                    ));

        //
        // CANNOT_CONNECT takes precedence over TIMEOUT
        //

        if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
            error = ERROR_INTERNET_CANNOT_CONNECT;
        } else if (fsm.IsTimedOut()) {
            error = ERROR_INTERNET_TIMEOUT;
        } else if (fsm.IsCountedOut()) {
            error = ERROR_INTERNET_CANNOT_CONNECT;
        }
    } else if (error != ERROR_INTERNET_OFFLINE) {

        //
        // not aborted, timed-out, counted-out, or offline. We can try again
        //

        bRestartable = TRUE;
    }

    //
    // if the socket is open, close it and try the next connection. Invalidate
    // the address we tried
    //

    if (IsOpen()) {
        Close();
    }

    DWORD mappedError = fsm.GetMappedError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped error = %d [%s]\n",
                mappedError,
                InternetMapError(mappedError)
                ));

    //
    // don't invalidate address if from-cache-if-net-fail timeout
    //

    BOOL bInvalidate = TRUE;

    if ((pObject != NULL) && pObject->IsFromCacheTimeoutSet()) {
        bInvalidate = FALSE;
    }
    if ((mappedError == WSAENETUNREACH)
        || (mappedError == WSAETIMEDOUT)
        || ((error == ERROR_INTERNET_TIMEOUT) && bInvalidate)
        || (error == ERROR_INTERNET_CANNOT_CONNECT)
#ifdef TEST_CODE
        || (error == (DWORD)-1)
#endif
        ) {
        fsm.m_pServerInfo->InvalidateAddress(fsm.m_dwResolutionId,
                                             fsm.m_dwAddressIndex
                                             );
    }

    //
    // if the operation was cancelled or we lost connectivity then quit
    //

    if (bRestartable) {
        fsm.SetNextState(FSM_STATE_INIT);
    } else {
        fsm.SetDone(error);

        PERF_LEAVE(Connect_Error);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Finish(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called when the connection has been successfully established

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Finish",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Finish);

    CFsm_SocketConnect & fsm = *Fsm;

    INET_ASSERT(IsOpen());

    //
    // store the average connect time to this server in our CServerInfo
    //

    if (fsm.m_pServerInfo != NULL) {
        fsm.m_pServerInfo->UpdateConnectTime(fsm.ReadTimer());
    }
    if (fsm.m_pOriginServer != NULL) {
        fsm.m_pOriginServer->UpdateConnectTime(fsm.ReadTimer());
    }

#ifdef TEST_CODE
    BOOL optval;
    int optlen = sizeof(optval);
    int serr = _I_getsockopt(GetSocket(),
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (char FAR *)&optval,
                             &optlen
                             );

    if (serr != 0) {
        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("getsockopt(TCP_NODELAY) returns %s (%d)\n",
                    InternetMapError(_I_WSAGetLastError()),
                    _I_WSAGetLastError()
                    ));
    }
#endif

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->ResetAbortHandle();
    }

    //
    // set the send & receive buffer sizes if not -1 (meaning don't change)
    //

    DWORD bufferLength;

    bufferLength = GetBufferLength(ReceiveBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(ReceiveBuffer, bufferLength);
    }
    bufferLength = GetBufferLength(SendBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(SendBuffer, bufferLength);
    }

    //
    // disable send coalescing
    //

    SetSendCoalescing(FALSE);

    //
    // let the app know we connected to the server successfully
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(INTERNET_STATUS_CONNECTED_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    fsm.SetDone();

    PERF_LEAVE(Connect_Finish);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


int
ICSocket::SocksConnect(
    IN LPSOCKADDR_IN pSockaddr,
    IN INT nLen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

    N.B. Irrespective of whether we are non-blocking, this function executes
    in blocking mode (we expect that we are on an intranet and complete quickly)

Arguments:

    pSockaddr   - address of remote host (on other side of SOCKS firewall)

    nLen        - length of *pSockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::SocksConnect",
                 "{%#x} %#x, %d",
                 GetSocket(),
                 pSockaddr,
                 nLen
                 ));

    //
    // BUGBUG - should check if the socket type is SOCK_STREAM or if we have
    //          already connected this socket. This code was part of original
    //          general purpose solution. We don't need it
    //

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_port = _I_htons(m_SocksPort);
    sin.sin_addr.s_addr = m_SocksAddress;
    memset(&sin.sin_zero, 0, sizeof(sin.sin_zero));

    //
    // initialize SOCKS request packet
    //

    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = pSockaddr->sin_port;
    request.DSTIP = pSockaddr->sin_addr.s_addr;

    DWORD length = sizeof(request.UserId);

    GlobalUserName.Get(request.UserId, &length);

    length += 8 + 1; // 8 == sizeof fixed portion of request;
                     // +1 for additional '\0'

    //
    // put socket into blocking mode
    //

    BOOL non_blocking = IsNonBlocking();

    if (non_blocking) {
        SetNonBlockingMode(FALSE);
    }

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    int serr = _I_connect(m_Socket, (LPSOCKADDR)&sin, sizeof(sin));

    if (serr != SOCKET_ERROR) {
        serr = _I_send(m_Socket, (char *)&request, length, 0);
        if (serr == (int)length) {

            char response[256];


            serr = _I_recv(m_Socket, (char *)response, sizeof(response), 0);
            if( serr == 1 ) {
                // need to read at least 2 bytes
                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("need to read one more byte\n"));
                serr = _I_recv(  
                    m_Socket, (char *)(&response[1]), sizeof(response) - 1, 0);
            }

            if (serr != SOCKET_ERROR) {
                if (response[1] != 90) {
                    serr = SOCKET_ERROR;
                }

            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv(%#x) returns %d\n",
                            m_Socket,
                            _I_WSAGetLastError()
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("send(%#x) returns %d\n",
                        m_Socket,
                        _I_WSAGetLastError()
                        ));

            serr = SOCKET_ERROR;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("connect(%#x) returns %d\n",
                    m_Socket,
                    _I_WSAGetLastError()
                    ));

    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (non_blocking) {
        SetNonBlockingMode(TRUE);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if (serr == SOCKET_ERROR) {
        _I_WSASetLastError(WSAECONNREFUSED);
    }

    DEBUG_LEAVE(serr);

    return serr;
}


DWORD
ICSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Disconnect",
                 "{%#x/%d} %#x",
                 GetSocket(),
                 GetSourcePort(),
                 dwFlags
                 ));

    //
    // let the app know we are closing the connection
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatus(INTERNET_STATUS_CLOSING_CONNECTION, NULL, 0);
    }

    DWORD error = Close();

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // let the app know the connection is closed
        //

        InternetIndicateStatus(INTERNET_STATUS_CONNECTION_CLOSED, NULL, 0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Close(
    VOID
    )

/*++

Routine Description:

    Closes a connected socket. Assumes that any linger or shutdown etc.
    requirements have already been applied to the socket

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Close",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {
//dprintf("**** closing %#x\n", m_Socket);

        int serr;

        __try {
            serr = _I_closesocket(m_Socket);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            serr = 0;
        }
        ENDEXCEPT
        error = (serr == SOCKET_ERROR)
            ? MapInternetError(_I_WSAGetLastError())
            : ERROR_SUCCESS;
    }

    //
    // the socket is now closed
    //

    m_Socket = INVALID_SOCKET;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Abort(
    VOID
    )

/*++

Routine Description:

    Aborts a socket by simply closing it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Abort",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = Close();

    if (error == ERROR_SUCCESS) {
        SetAborted();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Shutdown(
    IN DWORD dwControl
    )

/*++

Routine Description:

    Stops any more send/receives from the socket

Arguments:

    dwControl   - 0 to stop receives, 1 to stop sends, 2 to stop both

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Shutdown",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {

        int serr = _I_shutdown(m_Socket, dwControl);

        if (serr == SOCKET_ERROR) {

            //
            // map any sockets error to WinInet error
            //

            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICSocket::IsReset(
    VOID
    )

/*++

Routine Description:

    Determines if the socket has been closed. We peek the socket for 1 byte. If
    the socket is in blocking mode, we temporarily switch to non-blocking to
    perform the test - we don't want to block, nor remove any data from the
    socket

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - socket reset (closed by server)

        FALSE   - socket alive

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ICSocket::IsReset",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_ICSOCKET();

    BOOL bReset = FALSE;
    BOOL bSetBlocking = FALSE;

    if (IsOpen()) {
        if (!IsNonBlocking()) {
            SetNonBlockingMode(TRUE);
            bSetBlocking = TRUE;
        }

        char ch;
#ifndef unix
        int n = _I_recv(m_Socket, &ch, 1, MSG_PEEK);
        if (n < 0) {

            DWORD error = _I_WSAGetLastError();

            if (error != WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() returns %s (%d)\n",
                            InternetMapError(error),
                            error
                            ));

                n = 0;
            }
        }
        if (n == 0) {
#else
        DWORD dwAvail = 0;
        int n = _I_ioctlsocket(m_Socket,FIONREAD,&dwAvail);
        if (n != 0) {
#endif /* unix */
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x/port %d is reset\n",
                        m_Socket,
                        m_SourcePort
                        ));

            bReset = TRUE;
        }
        if (bSetBlocking) {
            SetNonBlockingMode(FALSE);
        }
    } else {
        bReset = TRUE;
    }

    DEBUG_LEAVE(bReset);

    return bReset;
}


DWORD
ICSocket::SetTimeout(
    IN DWORD Type,
    IN int Timeout
    )

/*++

Routine Description:

    Sets a timeout value for a connected socket

Arguments:

    Type            - type of timeout to set - send, or receive

    Timeout         - timeout value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetTimeout",
                 "{%#x/%d} %s (%d), %d",
                 GetSocket(),
                 GetSourcePort(),
                 (Type == SEND_TIMEOUT) ? "SEND_TIMEOUT"
                    : (Type == RECEIVE_TIMEOUT) ? "RECEIVE_TIMEOUT"
                    : "?",
                 Type,
                 Timeout
                 ));

    INET_ASSERT((Type == SEND_TIMEOUT) || (Type == RECEIVE_TIMEOUT));

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             (Type == SEND_TIMEOUT)
                                ? SO_SNDTIMEO
                                : SO_RCVTIMEO,
                             (const char FAR *)&Timeout,
                             sizeof(Timeout)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetLinger(
    IN BOOL Linger,
    IN int Timeout
    )

/*++

Routine Description:

    Sets the linger option for a connected socket

Arguments:

    Linger  - FALSE if the caller wants immediate shutdown of the socket
              when closed, or TRUE if we are to wait around until
              queued data has been sent

    Timeout - timeout value to use if Linger is TRUE

Return Value:

    DWORD
        Success - ERROR_SUCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetLinger",
                 "{%#x/%d} %B, %d",
                 GetSocket(),
                 GetSourcePort(),
                 Linger,
                 Timeout
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (IsOpen()) {

        LINGER linger;

        INET_ASSERT(Timeout <= USHRT_MAX);

        linger.l_onoff = (u_short)(Linger ? 1 : 0);
        linger.l_linger = (u_short)Timeout;


        //
        // in some shutdown situations, we are hitting exception in winsock
        // on win95 (!). Handle exception
        //

        __try {
            if (_I_setsockopt(m_Socket,
                              SOL_SOCKET,
                              SO_LINGER,
                              (const char FAR *)&linger,
                              sizeof(linger)
                              ) == SOCKET_ERROR) {
                error = MapInternetError(_I_WSAGetLastError());
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // do nothing except catch exception in retail
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("exception closing socket %#x/%d\n",
                        GetSocket(),
                        GetSourcePort()
                        ));

            INET_ASSERT(IsOpen());

        }
        ENDEXCEPT
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetNonBlockingMode(
    IN BOOL bNonBlocking
    )

/*++

Routine Description:

    Sets socket non-blocking/blocking mode

Arguments:

    bNonBlocking    - TRUE if non-blocking, FALSE if blocking

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetNonBlockingMode",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bNonBlocking
                 ));

    u_long on = (bNonBlocking) ? 1 : 0;
    DWORD error = ERROR_SUCCESS;

    if (_I_ioctlsocket(m_Socket, FIONBIO, &on) == 0) {
        if (on) {
            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            m_dwFlags &= ~SF_NON_BLOCKING;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to put socket %#x/port %d into %sblocking mode\n",
                    m_Socket,
                    m_SourcePort,
                    on ? "non-" : ""
                    ));

        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId
    )

/*++

Routine Description:

    Returns the send or receive buffer length for this socket object

Arguments:

    SocketBufferId  - which buffer length to return

Return Value:

    DWORD

--*/

{
    //
    // BUGBUG - RLF 04/29/96
    //
    // This function should access first the current object, then the parent
    // object, then the globals for this data
    //

    HINTERNET hInternet;
    DWORD dwBufferLength = (DWORD)-1;
    DWORD error;
    switch (SocketBufferId) 
    {
    case ReceiveBuffer:

        dwBufferLength = GlobalSocketReceiveBufferLength;
        break;
        
    case SendBuffer:

        hInternet = InternetGetMappedObjectHandle();
        
        if (hInternet != NULL) 
        {
            //
            // ensure the handle is valid
            //
            error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeHttpRequestHandle);
            if (error == ERROR_SUCCESS) 
            {
                dwBufferLength = ((HTTP_REQUEST_HANDLE_OBJECT*)hInternet)->GetSocketSendBufferLength();
            }
        }
        if (dwBufferLength == (DWORD)-1)
        {
            dwBufferLength =  GlobalSocketSendBufferLength;
        }
        break;
        
    default:
        dwBufferLength = (DWORD)-1;
    }
    
    return dwBufferLength;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the socket send or receive buffer length (if supported)

Arguments:

    SocketBufferId      - which buffer to set

    lpdwBufferLength    - where to write length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::GetBufferLength",
                 "{%#x/%d} %s, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : ((SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?")
                 ));

    DWORD size = sizeof(*lpdwBufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (char FAR *)lpdwBufferLength,
                             (int FAR *)&size
                             );

    DWORD error;

    if (serr != SOCKET_ERROR) {
        error = ERROR_SUCCESS;
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the socket send or receive buffer length

Arguments:

    SocketBufferId  - which buffer to set

    dwBufferLength  - length to set it to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetBufferLength",
                 "{%#x/%d} %s, %d",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : (SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?",
                 dwBufferLength
                 ));

    INET_ASSERT((int)dwBufferLength >= 0);

    DWORD size = sizeof(dwBufferLength);

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (const char FAR *)&dwBufferLength,
                             (int)size
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetSendCoalescing(
    IN BOOL bOnOff
    )

/*++

Routine Description:

    Enables or disables Nagle algorithm

Arguments:

    bOnOff  - FALSE to disable, TRUE to enable

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetSendCoalescing",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bOnOff
                 ));

    int optval = bOnOff ? 0 : 1;
    int serr = _I_setsockopt(m_Socket,
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (const char FAR *)&optval,
                             sizeof(optval)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
ICSocket::SetSourcePort(
    VOID
    )

/*++

Routine Description:

    Record the port we are connected to locally. Useful for debugging & matching
    up socket with net sniff

Arguments:

    None.

Return Value:

    None.

--*/

{
    sockaddr_storage address;  // Large enough for any address family.
    int namelen = sizeof(address);

    if (_I_getsockname(GetSocket(), (LPSOCKADDR)&address, &namelen) == 0) {
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) == offsetof(SOCKADDR_IN6, sin6_port));
        m_SourcePort = (INTERNET_PORT)_I_ntohs(((LPSOCKADDR_IN)&address)->sin_port);
    } else {
        m_SourcePort = 0;
    }
}


DWORD
ICSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over connected socket

Arguments:

    lpBuffer        - pointer to buffer containing data to send

    dwBufferLength  - length of lpBuffer in bytes

    dwFlags         - flags controlling send:

                        SF_INDICATE     - make status callbacks to the app when
                                          we are starting to send data and when
                                          we finish

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send",
                 "{%#x [%#x/%d]} %#x, %d, %#x",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error = DoFsm(new CFsm_SocketSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketSend state

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketSend * stateMachine = (CFsm_SocketSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Send_Start(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Send_Start(
    IN CFsm_SocketSend * Fsm
    )

/*++

Routine Description:

    Continues send request - sends the data

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send_Start",
                 "{%#x [%#x/%d]} %#x(%#x, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lpBuffer,
                 Fsm->m_dwBufferLength,
                 Fsm->m_dwFlags
                 ));

    CFsm_SocketSend & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (fsm.IsInvalid()) 
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

    if (error != ERROR_SUCCESS) {
        if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
            error = ERROR_INTERNET_CONNECTION_RESET;
        }
        goto quit;
    }
    if (state == FSM_STATE_INIT) {
        if (!(m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))) {

            DEBUG_DUMP_API(SOCKETS,
                           "sending data:\n",
                           fsm.m_lpBuffer,
                           fsm.m_dwBufferLength
                           );

        }

        if (pObject != NULL) {
            pObject->SetAbortHandle(this);
        }

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST, NULL, 0);
        }

        fsm.StartTimer();
    }
    while (fsm.m_dwBufferLength != 0) {

        //
        // if we are offline then quit now - we can't make any network
        // requests
        //

        if (IsOffline()) {
            error = ERROR_INTERNET_OFFLINE;
            break;
        }

        //
        // the socket may have already been aborted
        //

        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
            break;
        }

        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        int nSent = _I_send(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            fsm.m_dwBufferLength,
                            0
                            );
        if (nSent != SOCKET_ERROR) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("sent %d bytes @ %#x to socket %#x/port %d\n",
                        nSent,
                        fsm.m_lpBuffer,
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.m_iTotalSent += nSent;
            fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
            fsm.m_dwBufferLength -= nSent;
        } else {

            //
            // check first to see if the error was due to the socket being
            // closed as a result of the request being cancelled
            //

            if (IsAborted()) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
                break;
            } else {
                error = _I_WSAGetLastError();
            }
            if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("send() blocked, socket %#x, port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));
//dprintf("!!! send() blocked - socket %#x\n", m_Socket);
                fsm.SetAction(FSM_ACTION_SEND);

                DWORD timeout = GetTimeoutValue(INTERNET_OPTION_SEND_TIMEOUT);

                if (pObject != NULL) {
                    if (pObject->IsFromCacheTimeoutSet()
                    && (pObject->GetObjectType() == TypeHttpRequestHandle)
                    && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                        timeout = GetTimeoutValue(INTERNET_OPTION_FROM_CACHE_TIMEOUT);

                        DWORD RTT = fsm.m_pOriginServer->GetRTT();

                        if (RTT == 0) {
                            RTT = timeout;
                        }
                        timeout += RTT;
                    }
                }
                fsm.SetTimeout(timeout);
                error = QueueSocketWorkItem(Fsm, m_Socket);
                if (error != ERROR_SUCCESS) {
                    break;
                }
            } else {

                //
                // map any sockets error to WinInet error and terminate this
                // request
                //

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("send() returns %d (%s)\n",
                            error,
                            InternetMapError(error)
                            ));

                error = MapInternetError(error);
                break;
            }
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.StopTimer();
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->ResetAbortHandle();
        }
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else if (error == ERROR_SUCCESS) {
            if (fsm.m_dwFlags & SF_INDICATE) {
                InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
                                       &fsm.m_iTotalSent,
                                       sizeof(fsm.m_iTotalSent)
                                       );
            }
            if (fsm.m_pServerInfo != NULL) {
                //fsm.m_pServerInfo->UpdateSendTime(fsm.ReadTimer());
            }
        }
        fsm.SetDone(error);
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::SendTo(
//    IN LPSOCKADDR lpDestination,
//    IN DWORD dwDestinationLength,
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesSent,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for sendto()
//
//Arguments:
//
//    lpDestination       - pointer to remote address to send to
//
//    dwDestinationLength - length of *lpDestination
//
//    lpBuffer            - pointer to buffer containing data to send
//
//    dwBufferLength      - number of bytes to send from lpBuffer
//
//    lpdwBytesSent       - number of bytes sent to destination
//
//    dwWinsockFlags      - flags to pass through to sendto()
//
//    dwFlags             - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_INTERNET_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_INTERNET_TIMEOUT
//                    The operation timed out
//
//                  ERROR_INTERNET_CONNECTION_RESET
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::SendTo",
//                 "{%#x} %#x, %d, %#x, %d, %#x, %#x, %#x",
//                 m_Socket,
//                 lpDestination,
//                 dwDestinationLength,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesSent,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesSent != NULL);
//
//    int totalSent = 0;
//    DWORD error = ERROR_SUCCESS;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL fNonBlocking;
//
//    //
//    // if we are offline then quit now - we can't make any network requests
//    //
//
//    if (IsOffline()) {
//        error = ERROR_INTERNET_OFFLINE;
//        goto quit;
//    }
//
//    if (IsAborted()) {
//        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//
//    //
//    // set the cancel socket in the object
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, m_Socket, SEND);
//    }
//
//    if (dwFlags & SF_INDICATE) {
//
//        //
//        // let the app know we are starting to send data
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST,
//                               NULL,
//                               0
//                               );
//    }
//
//    DEBUG_DUMP(SOCKETS,
//               "sending data:\n",
//               lpBuffer,
//               dwBufferLength
//               );
//
//    int nSent;
//
//    //
//    // loop until all data sent
//    //
//
//    do {
//
//        nSent = _I_sendto(m_Socket,
//                          (char FAR *)lpBuffer + totalSent,
//                          dwBufferLength,
//                          dwWinsockFlags,
//                          lpDestination,
//                          dwDestinationLength
//                          );
//        if (nSent != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("sent %d bytes @ %#x on socket %#x\n",
//                        nSent,
//                        (LPBYTE)lpBuffer + totalSent,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nSent > 0);
//
//            totalSent += nSent;
//            dwBufferLength -= nSent;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) would block\n",
//                            m_Socket
//                            ));
//
//                lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                SwitchToAsyncScheduler(m_Socket);
//
//                error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) resumed, returns %s\n",
//                            m_Socket,
//                            InternetMapError(error)
//                            ));
//
//                if (error != ERROR_SUCCESS) {
//                    if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
//                        error = ERROR_INTERNET_CONNECTION_RESET;
//                    }
//                }
//            } else {
//
//                //
//                // some other error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//
//        INET_ASSERT((int)dwBufferLength >= 0);
//
//    } while ((dwBufferLength != 0) && (error == ERROR_SUCCESS));
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//
//        //
//        // let the app know we have finished sending
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
//                               &totalSent,
//                               sizeof(totalSent)
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know that we no longer require this socket
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, SEND);
//    }
//
//quit:
//
//    *lpdwBytesSent = totalSent;
//
//    //
//    // no longer performing operation on this socket
//    //
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_INTERNET_OPERATION_CANCELLED;
//        }
//    }
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::Receive(
    IN OUT LPVOID * lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

    This function returns user data, so if the stream we are receiving from is
    encrypted, we must decrypt the data before returning. This may require
    receiving more data than the user expects because we have to decrypt at
    message boundaries

    This function is intended to be called in a loop. The buffer pointer and
    buffer sizes are intended to be updated by each successive call to this
    function, and should therefore have the same values the next time this
    function is called

Arguments:

    lplpBuffer          - pointer to pointer to users buffer. If supplied, the
                          buffer should be LMEM_FIXED

    lpdwBufferLength    - size of buffer

    lpdwBufferRemaining - number of bytes left in the buffer

    lpdwBytesReceived   - number of bytes received

    dwExtraSpace        - number of additional bytes caller wants at end of
                          buffer (only useful if resizing AND only applied at
                          end of receive)

    dwFlags             - flags controlling receive:

                            SF_EXPAND       - lpBuffer can be expanded to fit
                                              data

                            SF_COMPRESS     - if set, we will shrink the buffer
                                              to compress out any unused space

                            SF_RECEIVE_ALL  - if set, this function will loop
                                              until all data received, or the
                                              supplied buffer is filled

                            SF_INDICATE     - if set, we will make status
                                              callbacks to the app when we are
                                              starting to receive data, and when
                                              we finish

                            SF_WAIT         - (used with SF_NON_BLOCKING). Even
                                              though the socket is non-blocking,
                                              the caller wants us to not
                                              relinquish control under the
                                              request has been satisfied

    lpbEof              - TRUE if we got end-of-connection indication
                          (recv() returns 0)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate/grow buffer

                  ERROR_INSUFFICIENT_BUFFER
                    The initial buffer was insufficient (i.e. caller supplied
                    buffer pointer was NULL, or we ran out of buffer space and
                    are not allowed to resize it)

                  WSA error
                    Sockets error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    INET_ASSERT((int)*lpdwBufferLength >= 0);
    INET_ASSERT((int)*lpdwBufferRemaining >= 0);
    INET_ASSERT((int)*lpdwBytesReceived >= 0);

#define SF_MUTEX_FLAGS  (SF_RECEIVE_ALL | SF_NO_WAIT)

    INET_ASSERT((dwFlags & SF_MUTEX_FLAGS) != SF_MUTEX_FLAGS);

    DWORD error = DoFsm(new CFsm_SocketReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketReceive state

Arguments:

    Fsm - socket receive FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketReceive * stateMachine = (CFsm_SocketReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Receive_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Receive_Continue(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Start(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Initiates a receive request - grows the buffer if required and kicks off the
    first receive operation

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Start",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer, fsm.m_dwBufferLength, FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error == ERROR_SUCCESS) {
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->SetAbortHandle(this);
        }

        //
        // keep the app informed (if requested to do so)
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE, NULL, 0);
        }

        //
        // kick off the receive request. If we complete synchronously (with
        // an error or successfully), then call the finish handler here
        //

        error = Receive_Continue(Fsm);
    } else {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Continue(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Continue",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (fsm.IsInvalid() && fsm.GetState() == FSM_STATE_ERROR) 
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto error_exit;
    }

    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;

    //
    // receive some data
    //

    do {
        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        INET_ASSERT((int)fsm.m_dwBufferLeft > 0);

        int nRead = _I_recv(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            (int)fsm.m_dwBufferLeft,
                            0
                            );

        //
        // hackorama # 95, subparagraph 13
        //
        // RLF 07/15/96
        //
        // On Win95 (wouldn't you know it?) in low-memory conditions, we can get
        // into a situation where one or more pages of our receive buffer is
        // filled with zeroes.
        //
        // The reason this happens is that the winsock VxD creates an alias to
        // our buffer, locks the buffer & writes into it, then marks the alias
        // dirty, but not the original buffer. If the buffer is paged out then
        // back in, one or more pages are zeroed because the O/S didn't know
        // they had been written to; it decides to initialize the pages with
        // zeroes.
        //
        // We try to circumvent this by immediately probing each page (we read
        // a byte then write it back).
        //
        // This doesn't fix the problem, just makes the window a lot smaller.
        // However, apart from writing a device driver or modifying the VxD,
        // there's not much else we can do
        //

        ProbeWriteBuffer(fsm.m_lpBuffer, fsm.m_dwBufferLeft);

        if (nRead == 0) {

            //
            // done
            //

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("EOF connection %#x/port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.m_bEof = TRUE;
            break;
        } else if (nRead > 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("received %d bytes from socket %#x/port %d\n",
                        nRead,
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.m_dwBytesReceived += nRead;
            fsm.m_dwBytesRead += nRead;
            fsm.m_lpBuffer += nRead;
            fsm.m_dwBufferLeft -= nRead;

            //
            // if SF_RECEIVE_ALL is not set then the caller just wants us to
            // perform a single receive. We're done
            //

            if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) {
                break;
            }

            //
            // if we've filled the current buffer, then either we're done, or
            // the caller wants us to receive the entire response, in which
            // case we attempt to grow the buffer and receive the next part
            // of the message. Note that we may have already received the
            // entire response if it just happened to be the same size as our
            // buffer
            //

            // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
            //  We need to handle expanding the buffer.
            //

            if (fsm.m_dwBufferLeft == 0) {

                //
                // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                //

                if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) {
                    break;
                } else {

                    //
                    // BUGBUG - the buffer increment should come from the handle
                    //          object
                    //

                    fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                    fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("resizing %#x to %d\n",
                                fsm.m_hBuffer,
                                fsm.m_dwBufferLength
                                ));

                    fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                 fsm.m_dwBufferLength,
                                                 FALSE
                                                 );
                    if (fsm.m_hBuffer != NULL) {
                        fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                    } else {
                        error = GetLastError();

                        INET_ASSERT(error != ERROR_SUCCESS);

                        fsm.m_dwBytesReceived = 0;
                        fsm.m_dwBufferLength = 0;
                        fsm.m_dwBufferLeft = 0;
                    }
                }
            }
        } else {
            error = _I_WSAGetLastError();
            if ((error != WSAEWOULDBLOCK) || (fsm.m_dwFlags & SF_NO_WAIT)) {

                //
                // a real error occurred. We need to get out
                //

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv() on socket %#x/port %d returns %d\n",
                            m_Socket,
                            m_SourcePort,
                            error
                            ));

                if (!(fsm.m_dwFlags & SF_NO_WAIT)) {
                    error = MapInternetError(error);
                }
                break;
            }

            //
            // socket would block. If SF_NON_BLOCKING is set then the caller is
            // expecting that we complete asynchronously. If SF_WAIT is set then
            // the caller wants to force synchronous behaviour, so we wait here
            // until the socket unblocks. If neither is set then the caller just
            // wants us to return what we have
            //

            if (IsNonBlocking()) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() blocked, socket %#x/port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.SetAction(FSM_ACTION_RECEIVE);

                DWORD timeout = GetTimeoutValue(INTERNET_OPTION_RECEIVE_TIMEOUT);

                if (pObject != NULL) {
                    if (pObject->IsFromCacheTimeoutSet()
                    && (pObject->GetObjectType() == TypeHttpRequestHandle)
                    && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                        timeout = GetTimeoutValue(INTERNET_OPTION_FROM_CACHE_TIMEOUT);

                        DWORD RTT = fsm.m_pOriginServer->GetRTT();

                        if (RTT == 0) {
                            RTT = timeout;
                        }
                        timeout += RTT;
                    }
                }
                fsm.SetTimeout(timeout);
                error = QueueSocketWorkItem(Fsm, m_Socket);
                if (error != ERROR_SUCCESS) {
                    break;
                }

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() resumed, socket %#x/port %d, returns %s\n",
                            m_Socket,
                            m_SourcePort,
                            InternetMapError(error)
                            ));

            } else if (fsm.m_dwFlags & SF_WAIT) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("waiting for socket %#x/port %d to become unblocked\n",
                            m_Socket,
                            m_SourcePort
                            ));

                //error = WaitForReceive(INFINITE);
            } else {

                //
                // return what we have (non-blocking, non-waiting read). But we
                // *should* have read *something*
                //

                if (fsm.m_dwBytesRead == 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("bogus - 0 bytes read from non-blocking recv(). Waiting\n"
                                ));

                    //
                    // AOL problem:
                    //

                    //error = WaitForReceive(INFINITE);
                } else {
                    error = ERROR_SUCCESS;
                    break;
                }
            }
        }
    } while (error == ERROR_SUCCESS);

error_exit:

    //
    // get correct error based on settings
    //

    if (error == ERROR_IO_PENDING) {
        goto done;
    } else if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
    } else if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
        error = ERROR_INTERNET_CONNECTION_RESET;
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
                                   &fsm.m_dwBytesRead,
                                   sizeof(fsm.m_dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE
                                         );

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("read %d bytes @ %#x from socket %#x/port %d\n",
                    fsm.m_dwBytesRead,
                    (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                    m_Socket,
                    m_SourcePort
                    ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    } else if (fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {

        //
        // if we failed but allocated a buffer then we need to free it (we were
        // leaking this buffer if the request was cancelled)
        //

        fsm.m_hBuffer = FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;
    *fsm.m_lpbEof = fsm.m_bEof;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone(error);
    }

done:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::ReceiveFrom(
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesReceived,
//    OUT LPSOCKADDR lpDestination OPTIONAL,
//    IN OUT LPDWORD lpdwDestinationLength OPTIONAL,
//    IN DWORD dwTimeout,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for recvfrom()
//
//Arguments:
//
//    lpBuffer                - pointer to buffer where data returned
//
//    dwBufferLength          - size of lpBuffer in bytes
//
//    lpdwBytesReceived       - pointer to returned number of bytes received
//
//    lpDestination           - pointer to returned destination address
//
//    lpdwDestinationLength   - IN: size of lpDestination buffer
//                              OUT: length of returned destination address info
//
//    dwTimeout               - number of milliseconds to wait for response
//
//    dwWinsockFlags          - flags to pass through to recvfrom()
//
//    dwFlags                 - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_INTERNET_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_INTERNET_TIMEOUT
//                    The operation timed out
//
//                  ERROR_INTERNET_CONNECTION_RESET
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::ReceiveFrom",
//                 "{%#x} %#x, %d, %#x, %#x, %#x [%d], %d, %#x, %#x",
//                 m_Socket,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesReceived,
//                 lpDestination,
//                 lpdwDestinationLength,
//                 lpdwDestinationLength ? *lpdwDestinationLength : 0,
//                 dwTimeout,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    //INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesReceived != NULL);
//
//    //
//    // most ICSocket flags not allowed for this operation
//    //
//
//    INET_ASSERT(!(dwFlags
//                  & (SF_ENCRYPT
//                     | SF_DECRYPT
//                     | SF_EXPAND
//                     | SF_COMPRESS
//                     | SF_SENDING_DATA
//                     | SF_SCH_REDO
//                     )
//                  )
//                );
//
//    DWORD error = ERROR_SUCCESS;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL bStopOfflineTimer = FALSE;
//    BOOL fNonBlocking;
//    DWORD bytesReceived;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    //
//    // the socket may have already been aborted
//    //
//
//    if (IsAborted()) {
//        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    //
//    // if we are offline then quit now - we can't make any network requests
//    //
//
//    if (IsOffline()) {
//        error = ERROR_INTERNET_OFFLINE;
//        goto quit;
//    }
//
//    //
//    // let another thread know the socket to cancel if it wants to kill this
//    // operation
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // keep the app informed (if requested to do so)
//    //
//
//    if (dwFlags & SF_INDICATE) {
//        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
//                               NULL,
//                               0
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION_TIMEOUT(lpThreadInfo->lpArb,
//                                         m_Socket,
//                                         RECEIVE,
//                                         dwTimeout
//                                         );
//
//        DWORD timerError = StartOfflineTimerForArb(lpThreadInfo->lpArb);
//
//        INET_ASSERT(timerError == ERROR_SUCCESS);
//
//        bStopOfflineTimer = (timerError == ERROR_SUCCESS) ? TRUE : FALSE;
//    }
//
//    int nBytes;
//
//    bytesReceived = 0;
//
//    do {
//
//        nBytes = _I_recvfrom(m_Socket,
//                             (char FAR *)lpBuffer + bytesReceived,
//                             dwBufferLength,
//                             dwWinsockFlags,
//                             lpDestination,
//                             (int FAR *)lpdwDestinationLength
//                             );
//        if (nBytes != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("received %d bytes from socket %#x\n",
//                        nBytes,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nBytes > 0);
//
//            bytesReceived += nBytes;
//            dwBufferLength -= nBytes;
//
//            //
//            // for recvfrom(), we quit as soon as we get some data
//            //
//
//            error = ERROR_SUCCESS;
//            break;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                //
//                // if this function is called expedited (we expect the request
//                // to complete quickly) then we test to see if it already
//                // completed before switching to the async scheduler
//                //
//
//                BOOL switchFiber = TRUE;
//
//                if (dwFlags & SF_EXPEDITED) {
//                    error = WaitForReceive(1);
//
//                    //
//                    // if the socket is already readable then we don't switch
//                    // fibers (only to virtually immediately come back here,
//                    // incurring a couple of thread switches
//                    //
//
//                    if (error == ERROR_SUCCESS) {
//                        switchFiber = FALSE;
//
//                        //
//                        // use this error to go round loop once again
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//                if (switchFiber) {
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) blocked\n",
//                                m_Socket
//                                ));
//
//                    lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                    SwitchToAsyncScheduler(m_Socket);
//
//                    error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) resumed, returns %s\n",
//                                m_Socket,
//                                InternetMapError(error)
//                                ));
//
//                    if (error != ERROR_SUCCESS) {
//                        if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
//                            error = ERROR_INTERNET_CONNECTION_RESET;
//                        }
//                    } else {
//
//                        //
//                        // use this error to force another loop now we believe
//                        // we have the data
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//            } else {
//
//                //
//                // real error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//    } while (error == WSAEWOULDBLOCK);
//
//    if (error == ERROR_SUCCESS) {
//
//        DEBUG_DUMP(SOCKETS,
//                   "received data:\n",
//                   lpBuffer,
//                   bytesReceived
//                   );
//
//    }
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, RECEIVE);
//
//        if (bStopOfflineTimer) {
//            StopOfflineTimerForArb(lpThreadInfo->lpArb);
//        }
//    }
//
//    //
//    // inform the app that we finished, and tell it how much we received this
//    // time
//    //
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
//                               &bytesReceived,
//                               sizeof(bytesReceived)
//                               );
//    }
//
//    *lpdwBytesReceived = bytesReceived;
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_INTERNET_OPERATION_CANCELLED;
//        }
//    }
//
//quit:
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::DataAvailable(
    OUT LPDWORD lpdwBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    lpdwBytesAvailable  - pointer to returned data available


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DataAvailable",
                 "%#x",
                 lpdwBytesAvailable
                 ));

    //
    // sanity check parameters
    //

    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(lpdwBytesAvailable != NULL);

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if we are offline then quit now - we can't make any network requests
    //

    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    //
    // the socket may already be aborted
    //

    if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // if we're in async mode, we have to perform a zero-length receive in order
    // to get the information from the socket
    //

    int nRead;

    //
    // we actually have to peek a non-zero number of bytes because on Win95,
    // attempting to perform a receive of 0 bytes (to put the socket in blocked
    // read mode) results in zero bytes being returned, and the socket never
    // blocks
    //

    nRead = _I_recv(m_Socket, NULL, 0, 0);

    //
    // N.B. buf[] will only ever be used if there is data to peek right now
    //

    char buf[1];

    PERF_LOG(PE_PEEK_RECEIVE_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    nRead = _I_recv(m_Socket, buf, sizeof(buf), MSG_PEEK);
    if (nRead == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
        if ((error == WSAEWOULDBLOCK) && (m_dwFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) blocked, socket %#x\n",
                        m_Socket
                        ));

            PERF_LOG(PE_PEEK_RECEIVE_END,
                     m_Socket,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) resumed, socket %#x, returns %s\n",
                        m_Socket,
                        InternetMapError(error)
                        ));

            if (error != ERROR_SUCCESS) {
                if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
                    error = ERROR_INTERNET_CONNECTION_RESET;
                }
            }
        }
    /*} else if ((nRead == 0) && !(m_dwFlags & SF_NON_BLOCKING)) {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nothing to peek right now. If the socket is in blocking mode then
        // we wait here until there is something to receive
        //

        error = WaitForReceive(INFINITE);*/
    } else {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nRead == 0 but non-blocking, or nRead > 0
        //

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("peek(1) returns %d\n",
                    nRead
                    ));

        error = ERROR_SUCCESS;
    }

    if (error == ERROR_SUCCESS) {

        //
        // now we can get the amount from the socket
        //

        error = (DWORD)_I_ioctlsocket(m_Socket,
                                      FIONREAD,
                                      (u_long FAR *)lpdwBytesAvailable
                                      );

        //
        // N.B. assumes ioctlsocket() returns 0 on success == ERROR_SUCCESS
        //

        if (error == SOCKET_ERROR) {
            error = _I_WSAGetLastError();
        } else {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("ioctlsocket(FIONREAD) returns %d\n",
                        *lpdwBytesAvailable
                        ));

        }
    }

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::DataAvailable2(
//    OUT LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines the amount of data available to be read on the socket
//
//Arguments:
//
//    lplpBuffer          - pointer to pointer to buffer where data read
//
//    dwBufferLength      - size of the buffer
//
//    lpdwBytesAvailable  - pointer to returned data available
//
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - WSA error
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::DataAvailable2",
//                 "%#x, %d, %#x",
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesAvailable
//                 ));
//
//    //
//    // sanity check parameters
//    //
//
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // we're about to receive data from the socket. The amount of data currently
//    // on hand must be 0
//    //
//
//    INET_ASSERT(*lpdwBytesAvailable == 0);
//    INET_ASSERT(lpBuffer != NULL);
//
//    DWORD error;
//
//    //
//    // new scheme: actually read the data from sockets into our buffer. This is
//    // the only way on Win95 to determine the correct number of bytes available.
//    // We only perform a single receive
//    //
//
//    DWORD bufferLeft = dwBufferLength;
//    BOOL eof;
//
//    error = Receive(&lpBuffer,
//                    &dwBufferLength,
//                    &bufferLeft,  // don't care about this
//                    lpdwBytesAvailable,
//                    0,
//                    0,
//                    &eof          // don't care about this either
//                    );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::WaitForReceive(
    IN DWORD Timeout
    )

/*++

Routine Description:

    Waits until a receive socket becomes unblocked (readable)

Arguments:

    Timeout - milliseconds to wait, or INFINITE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    sockets error

                  ERROR_INTERNET_TIMEOUT
                    Receive timed out

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::WaitForReceive",
                 "{%#x} %d",
                 m_Socket,
                 Timeout
                 ));

    struct fd_set read_fds;
    struct fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);

    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    int n;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("waiting on socket %#x\n",
                m_Socket
                ));

    TIMEVAL timeout;
    LPTIMEVAL lpTimeout;

    if (Timeout != INFINITE) {
        timeout.tv_sec  = Timeout / 1000;
        timeout.tv_usec = (Timeout % 1000) * 1000;
        lpTimeout = &timeout;
    } else {
        lpTimeout = NULL;
    }

    n = _I_select(0, &read_fds, NULL, &except_fds, lpTimeout);

    DWORD error;

    if (n == SOCKET_ERROR) {

        //
        // real error?
        //

        error = _I_WSAGetLastError();

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("select() returns %d\n",
                    error
                    ));

        INET_ASSERT(FALSE);

        error = MapInternetError(error);
    } else if (n != 0) {
        if (FD_ISSET(m_Socket, &except_fds)) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("socket %#x exception\n",
                        m_Socket
                        ));

            error = ERROR_INTERNET_CONNECTION_RESET;
        } else {

            //
            // it *must* be unblocked (i.e. readable)
            //

            INET_ASSERT(FD_ISSET(m_Socket, &read_fds));

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x unblocked\n",
                        m_Socket
                        ));

            error = ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("timed out\n"
                    ));

        error = ERROR_INTERNET_TIMEOUT;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::AllocateQueryBuffer(
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Allocates a query buffer for the socket

Arguments:

    lplpBuffer          - returned pointer to allocated query buffer

    lpdwBufferLength    - returned length of allocated query buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::AllocateQueryBuffer",
                 "{%#x/%d} %#x, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 lplpBuffer,
                 lpdwBufferLength
                 ));

    DWORD error;
    DWORD bufferLength;
    DWORD size = sizeof(bufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SO_RCVBUF,
                             (char FAR *)&bufferLength,
                             (int FAR *)&size
                             );
    if (serr != SOCKET_ERROR) {
        bufferLength = min(bufferLength, DEFAULT_SOCKET_QUERY_BUFFER_LENGTH);
        if (bufferLength == 0) {
            bufferLength = DEFAULT_SOCKET_QUERY_BUFFER_LENGTH;
        }
        *lplpBuffer = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, bufferLength);
        if (*lplpBuffer != NULL) {
            *lpdwBufferLength = bufferLength;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//VOID
//ICSocket::FreeQueryBuffer(
//    IN LPVOID lpBuffer
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    lpBuffer    -
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    lpBuffer = (LPVOID)FREE_MEMORY((HLOCAL)lpBuffer);
//
//    INET_ASSERT(lpBuffer == NULL);
//}

//
//DWORD
//ICSocket::GetBytesAvailable(
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines amount of data available to be read from socket
//
//Arguments:
//
//    lpdwBytesAvailable  - pointer to returned available length
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::GetBytesAvailable",
//                 "{%#x} %#x",
//                 m_Socket,
//                 lpdwBytesAvailable
//                 ));
//
//    //INET_ASSERT(m_Socket != INVALID_SOCKET);
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // get the amount from the socket. If the socket has been reset or shutdown
//    // by the server then we expect to get an error, else 0 (== ERROR_SUCCESS)
//    //
//
//    DWORD error = (DWORD)_I_ioctlsocket(m_Socket,
//                                        FIONREAD,
//                                        (u_long FAR *)lpdwBytesAvailable
//                                        );
//    if (error == SOCKET_ERROR) {
//        error = _I_WSAGetLastError();
//    } else {
//
//        DEBUG_PRINT(SOCKETS,
//                    INFO,
//                    ("ioctlsocket(FIONREAD) returns %d\n",
//                    *lpdwBytesAvailable
//                    ));
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::CreateSocket(
    IN DWORD dwFlags,
    IN int nAddressFamily,
    IN int nType,
    IN int nProtocol
    )

/*++

Routine Description:

    Opens a socket handle for this ICSocket object

Arguments:

    dwFlags         - flags to use for new socket

    nAddressFamily  - parameter to socket()

    nType           - parameter to socket()

    nProtocol       - parameter to socket()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::CreateSocket",
                 "%#x, %s (%d), %s (%d), %s (%d)",
                 dwFlags,
                 MapFamily(nAddressFamily),
                 nAddressFamily,
                 MapSock(nType),
                 nType,
                 MapProto(nProtocol),
                 nProtocol
                 ));

    INET_ASSERT(m_Socket == INVALID_SOCKET);

    int serr;
    DWORD error;
    DWORD dwConnFlags;

#if defined(SITARA)

    //
    // Only enable Sitara if we're connected via modem
    //

//dprintf("create socket: IsSitara = %B, IsModemConn=%B\n",GlobalEnableSitara, GlobalHasSitaraModemConn);
    if (GlobalEnableSitara && GlobalHasSitaraModemConn) {
        nProtocol = (int)GetSitaraProtocol();
    }

#endif

    m_Socket = _I_socket(nAddressFamily, nType, nProtocol);
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    if (dwFlags & SF_NON_BLOCKING) {
        INET_ASSERT(FALSE);

        error = SetNonBlockingMode(TRUE);
        if (error == ERROR_SUCCESS) {

            //
            //  ICSocket is non-blocking socket object
            //

            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            goto close_socket;
        }
    }

    //
    // bind our data socket to an endpoint, so that we know an address to
    // tell the FTP server
    //

    struct sockaddr_storage ourDataAddr;

    ourDataAddr.ss_family = (short)nAddressFamily;

    if (nAddressFamily == AF_INET6) {
        struct in_addr6 in6addr_any = IN6ADDR_ANY_INIT;

        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_port = 0;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_flowinfo = 0;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_addr = in6addr_any;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_scope_id = 0;
    } else {
        ((LPSOCKADDR_IN)&ourDataAddr)->sin_port = 0;
        ((LPSOCKADDR_IN)&ourDataAddr)->sin_addr.s_addr = INADDR_ANY;
    }

    serr = _I_bind(m_Socket,
                   (PSOCKADDR)&ourDataAddr,
                   sizeof(ourDataAddr)
                   );

    if (serr == SOCKET_ERROR) {
        goto socket_error;
    }

    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());

close_socket:

    Close();
    m_dwFlags &= ~SF_NON_BLOCKING;
    goto quit;
}


DWORD
ICSocket::GetSockName(
    IN PSOCKADDR psaSockName,
    IN int SockNameSize
    )
/*++

Routine Description:

    Returns the socket address for this socket.

Arguments:

    psaSocketName    - pointer to sockaddr buffer to fill in.

    SockNameSize - size of sockaddr buffer;

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);
    INET_ASSERT(SockNameSize >= sizeof(SOCKADDR));

    int serr;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    serr = _I_getsockname(m_Socket,
                          psaSockName,
                          &SockNameSize
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::GetPeerName(
    IN PSOCKADDR psaSockName,
    IN int SockNameSize
    )
/*++

Routine Description:

    Returns the socket address for this socket's connected peer.

Arguments:

    psaSocketName    - pointer to sockaddr buffer to fill in.

    SockNameSize - size of sockaddr buffer;

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);
    INET_ASSERT(SockNameSize >= sizeof(SOCKADDR));

    int serr;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    serr = _I_getpeername(m_Socket,
                          psaSockName,
                          &SockNameSize
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::Listen(
    VOID
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error = ERROR_SUCCESS;

    //
    // Listen on the socket.
    //

    if (_I_listen(m_Socket, 1) == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
    }
    return error;
}


DWORD
ICSocket::DirectConnect(
    PSOCKADDR psaRemoteSock
    )

/*++

Routine Description:

    Connects a ICSocket to the remote address

Arguments:

    psaRemoteSock   - pointer to remote socket address (TCP/IP!)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DirectConnectSocket",
                 "{%#x} %#x",
                 m_Socket,
                 psaRemoteSock
                 ));

    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error;
    BOOL bStopOfflineTimer = FALSE;

    //
    // we need the thread info for async processing
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if we are offline then quit now - we can't make any network requests
    //

    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    BOOL isAsync;

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

    //
    // BUGBUG - this is essentially common to ConnectSocket()
    //

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INTERNET_HANDLE_OBJECT * pObject;

    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
    if (pObject != NULL) {
        pObject->SetAbortHandle(this);
    }

#if defined(UNIX) && defined(ux10)
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[0],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[1],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[2],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[3],
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#else
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b1,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b2,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b3,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b4,
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#endif

    DWORD connectTime;

    connectTime = GetTickCountWrap();

    int serr;

    PERF_LOG(PE_CONNECT_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    if (IsSocks()) {
        // BUGBUG: We only support IPv4 Socks.
        serr = SocksConnect((LPSOCKADDR_IN)psaRemoteSock, sizeof(SOCKADDR_IN));
    } else {
        int RemoteSockSize;

        if (psaRemoteSock->sa_family == AF_INET6) {
            RemoteSockSize = sizeof(SOCKADDR_IN6);
        } else {
            RemoteSockSize = sizeof(SOCKADDR_IN);
        }
        serr = _I_connect(m_Socket, psaRemoteSock, RemoteSockSize);
    }
    if (serr != 0) {
        error = _I_WSAGetLastError();

        //
        // if we are using non-blocking sockets then we need to wait until
        // the connect has completed, or an error occurs
        //

        if (isAsync) {
            if (error == WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() blocked, socket %#x\n",
                            m_Socket
                            ));

                PERF_LOG(PE_CONNECT_END,
                         m_Socket,
                         lpThreadInfo->ThreadId,
                         lpThreadInfo->hObject
                         );

                connectTime = (GetTickCountWrap() - connectTime);

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() resumed, socket %#x, returns %s\n",
                            m_Socket,
                            InternetMapError(error)
                            ));

                if (error != ERROR_SUCCESS) {
                    if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
                        error = ERROR_INTERNET_CANNOT_CONNECT;
                    }
                }
            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("failed to connect non-blocking socket %#x, error %d\n",
                            m_Socket,
                            error
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("failed to connect blocking socket %#x, error %d\n",
                        m_Socket,
                        error
                        ));

        }
    } else {

        PERF_LOG(PE_CONNECT_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        connectTime = (GetTickCountWrap() - connectTime);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x connected, time = %d mSec\n",
                    m_Socket,
                    connectTime
                    ));

        error = ERROR_SUCCESS;
    }

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();

        //
        // if the operation has been cancelled, then this error overrides any
        // other
        //

        if (pObject->IsInvalidated()) {
            error = pObject->GetError();
            if (error == ERROR_SUCCESS) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }
        }
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }
    }

quit:

    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SelectAccept(
    IN ICSocket & acceptSocket,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Wait until listening socket has connection to accept. We use the socket
    handle in this ICSocket object to accept a connection & create a socket
    handle in another ICSocket object (in acceptSocket)

Arguments:

    acceptSocket    - socket object to wait on

    dwTimeout       - number of milliseconds to wait

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SelectAccept",
                 "%#x, %d",
                 &acceptSocket,
                 dwTimeout
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    fd_set read_fds;
    fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);
    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    TIMEVAL timeout;

    timeout.tv_sec  = dwTimeout / 1000;
    timeout.tv_usec = dwTimeout % 1000;

    int n;

    n = _I_select(0, &read_fds, NULL, &except_fds, &timeout);
    if (n == 1) {
        if (FD_ISSET(m_Socket, &read_fds)) {
            error = ERROR_SUCCESS;
        } else if (FD_ISSET(m_Socket, &except_fds)) {
            error = ERROR_INTERNET_CANNOT_CONNECT;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("select(): listening socket %#x in error (%d)\n",
                        m_Socket,
                        error
                        ));

            INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);
        }
    } else if (n == 0) {

        //
        // timeout
        //

        error = ERROR_INTERNET_TIMEOUT;

        DEBUG_PRINT(FTP,
                    WARNING,
                    ("select() timed out (%d.%d)\n",
                    timeout.tv_sec,
                    timeout.tv_usec
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

    } else {

        //
        // socket error
        //

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("select() returns %d\n",
                    _I_WSAGetLastError()
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

        goto socket_error;
    }

    //
    // if we have a success indication then accept the connection; it may still
    // fail
    //

    if (error == ERROR_SUCCESS) {
        acceptSocket.m_Socket = _I_accept(m_Socket, NULL, NULL);
        if (acceptSocket.m_Socket != INVALID_SOCKET) {

            //
            // copy non-blocking indication to new socket
            //

            INET_ASSERT(!(m_dwFlags & SF_NON_BLOCKING));
            //acceptSocket.m_dwFlags |= (m_dwFlags & SF_NON_BLOCKING);
        } else {

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("accept() returns %d\n",
                        error
                        ));

            goto socket_error;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    goto quit;
}


LPSTR
MapNetAddressToName(
    IN LPSTR lpszAddress,
    OUT LPSTR * lplpszMappedName
    )

/*++

Routine Description:

    Given a network address, tries to map it to the corresponding host name. We
    consult the name resolution cache to determine this

Arguments:

    lpszAddress         - pointer to network address to map

    lplpszMappedName    - pointer to pointer to mapped name. Caller must free

Return Value:

    LPSTR
        Success - pointer to mapped name

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Pointer,
                "MapNetAddressToName",
                "%q, %#x",
                lpszAddress,
                lplpszMappedName
                ));

    INET_ASSERT(lpszAddress != NULL);
    INET_ASSERT(lplpszMappedName != NULL);

    LPSTR lpszMappedName = NULL;

    //
    // now try to find the address in the cache. If it's not in the cache then
    // we don't resolve it, simply return the address
    //

    //
    // BUGBUG - if required, we need to resolve the name, but we need to know
    //          whether the address can be resolved on the intranet
    //

    //
    // If getaddrinfo with the AI_NUMERICHOST flag succeeds then we were
    // given a string representation of an IPv6 or IPv4 address.
    //

    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.

    if (_I_getaddrinfo(lpszAddress, NULL, &Hints, &lpAddrInfo) == 0) {

        //
        // An IP address literal (either v4 or v6) was passed in.
        // See if we have a name cached that maps to it.
        //

        DWORD ttl;
        LPADDRINFO CachedAddrInfo;
        LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

        if ((lpResolverCacheEntry=QueryResolverCache(NULL, lpAddrInfo->ai_addr, &CachedAddrInfo, &ttl))) {

            INET_ASSERT(CachedAddrInfo != NULL);

            if (CachedAddrInfo->ai_canonname != NULL)
                lpszAddress = lpszMappedName = NewString(CachedAddrInfo->ai_canonname);
            ReleaseResolverCacheEntry(lpResolverCacheEntry);
        }

        _I_freeaddrinfo(lpAddrInfo);
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped name is %q\n",
                lpszAddress
                ));

    DEBUG_LEAVE(lpszAddress);

    *lplpszMappedName = lpszMappedName;

    return lpszAddress;
}


DWORD
AUTO_PROXY_HELPER_APIS::ResolveHostName(
    IN LPSTR lpszHostName,
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )

/*++

Routine Description:

    Resolves a HostName to an IP address literal by using Winsock DNS.

Arguments:

    lpszHostName   - the host name that should be used.

    lpszIPAddress  - the output IP address as a string.

    lpdwIPAddressSize - the size of the outputed IP address string.

Return Value:

    DWORD
        Win32 error code.

--*/

{
    //
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo() with the AI_NUMERICHOST flag succeeds then we were
    // given a string respresentation of an IPv6 or IPv4 address. Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    DWORD dwIPAddressSize;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry = NULL;
    BOOL bResolved = FALSE;
    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;
    DWORD error;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }

        //
        // An IP address (either v4 or v6) was passed in.
        // This is precisely what we want, so if we have the room,
        // just copy it back out.
        //

        _I_freeaddrinfo(lpAddrInfo);

        dwIPAddressSize = lstrlen(lpszHostName);

        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }

        lstrcpy(lpszIPAddress, lpszHostName);
        goto quit;
    }

    //
    // now try to find the name in the cache. If it's not in the
    // cache then resolve it
    //

    DWORD ttl;

    if (!(lpResolverCacheEntry=QueryResolverCache(lpszHostName, NULL, &lpAddrInfo, &ttl))) 
    {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("resolving %q\n",
                    lpszHostName
                    ));

        PERF_LOG(PE_NAMERES_START, 0);

        Hints.ai_flags = 0;  // No special treatment this time.

        error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

        PERF_LOG(PE_NAMERES_END, 0);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    (error == 0) ? "" : "NOT "
                    ));


        //
        // if we successfully resolved the name then remember to add the
        // information to the cache when we're done with it
        //

        if (error == 0) {
            bResolved = TRUE;
        } else {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }
    }

    INET_ASSERT(lpAddrInfo != NULL);

    //
    // We have an addrinfo struct for lpszHostName.
    // Convert its IP address into a string.
    //

    //
    // BUGBUG: Until our caller can deal with IPv6 addresses, we'll only
    // return IPv4 addresses here, regardless of what may be in the cache.
    // Step through chain until we find an IPv4 address.
    //

    LPADDRINFO IPv4Only;

    IPv4Only = lpAddrInfo;
    while (IPv4Only->ai_family != AF_INET) {

        IPv4Only = IPv4Only->ai_next;
        if (IPv4Only == NULL) {
            error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }
    }

    error = _I_getnameinfo(IPv4Only->ai_addr, IPv4Only->ai_addrlen,
                           lpszIPAddress, *lpdwIPAddressSize, NULL, 0,
                           NI_NUMERICHOST);
    if (error != 0) {
        error = ERROR_INTERNET_NAME_NOT_RESOLVED;
    }

quit:

    if (lpResolverCacheEntry) {

        INET_ASSERT(!bResolved);
        INET_ASSERT(lpAddrInfo != NULL);

        ReleaseResolverCacheEntry(lpResolverCacheEntry);

    } else if (bResolved) {

        INET_ASSERT(lpAddrInfo != NULL);

        AddResolverCacheEntry(lpszHostName, lpAddrInfo, LIVE_DEFAULT);
    }

    return error;
}

BOOL
AUTO_PROXY_HELPER_APIS::IsResolvable(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Determines wheter a HostName can be resolved.  Performs a Winsock DNS query,
      and if it succeeds returns TRUE.

Arguments:

    lpszHost   - the host name that should be used.

Return Value:

    BOOL
        TRUE - the host is resolved.

        FALSE - could not resolve.

--*/

{

    char szDummy[] = "1111:2222:3333:4444:5555:6666:255.255.255.255%4294967295";
    DWORD dwDummySize = sizeof(szDummy);
    DWORD error;

    error = ResolveHostName(
                lpszHost,
                szDummy,
                &dwDummySize
                );

    if (error == 0)
    {
        return TRUE;
    }
    else
    {
        INET_ASSERT(error != ERROR_SUCCESS );
        return FALSE;
    }

}

DWORD
AUTO_PROXY_HELPER_APIS::GetIPAddress(
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )

/*++

Routine Description:

    Acquires the IP address string of this client machine WININET is running on.

Arguments:

    lpszIPAddress   - the IP address of the machine, returned.

    lpdwIPAddressSize - size of the IP address string.

Return Value:

    DWORD
        Win32 Error.

--*/

{

    CHAR szHostBuffer[255];
    int serr;

    serr = _I_gethostname(
                szHostBuffer,
                ARRAY_ELEMENTS(szHostBuffer)-1
                );

    if ( serr != ERROR_SUCCESS)
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    return ResolveHostName(
                szHostBuffer,
                lpszIPAddress,
                lpdwIPAddressSize
                );

}


BOOL
AUTO_PROXY_HELPER_APIS::IsInNet(
    IN LPSTR   lpszIPAddress,
    IN LPSTR   lpszDest,
    IN LPSTR   lpszMask
    )

/*++

Routine Description:

    Determines whether a given IP address is in a given dest/mask IP address.

Arguments:

    lpszIPAddress   - the host name that should be used.

    lpszDest        - the IP address dest to check against.

    lpszMask        - the IP mask string

Return Value:

    BOOL
        TRUE - the IP address is in the given dest/mask

        FALSE - the IP address is NOT in the given dest/mask

--*/

{
    DWORD dwDest, dwIpAddr, dwMask;

    INET_ASSERT(lpszIPAddress);
    INET_ASSERT(lpszDest);
    INET_ASSERT(lpszMask);

    dwIpAddr = _I_inet_addr(lpszIPAddress);
    dwDest = _I_inet_addr(lpszDest);
    dwMask = _I_inet_addr(lpszMask);

    if ( dwDest   == INADDR_NONE ||
         dwIpAddr == INADDR_NONE  )

    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

        if ( (dwIpAddr & dwMask) != dwDest)
    {
        return FALSE;
        }

    //
    // Pass, its Matches.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\reslock.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reslock.cxx

Abstract:

    Contains methods for RESOURCE_LOCK class

    Contents:
        RESOURCE_LOCK::Acquire()
        RESOURCE_LOCK::Release()

Author:

    Richard L Firth (rfirth) 18-Jun-1996

Revision History:

    18-Jun-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// class members
//

#ifdef OLD_VERSION


BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )

/*++

Routine Description:

    Acquires the resource protected by this lock. Acquires for non-exclusive
    (read) or exclusive (write) ownership

Arguments:

    bExclusiveMode  - TRUE if we are acquiring the resource for exclusive
                      (write) ownership

Return Value:

    BOOL
        TRUE    - resource is acquired

        FALSE   - failed to acquire resource (timeout?)

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    BOOL acquired = TRUE;

    //EnterCriticalSection(&_CritSect);
    if (bExclusiveMode) {

        //
        // acquired for exclusive ownership (write access). Set the owning
        // thread id and wait for the last current reader to release. Note
        // that if we're being re-entered, EnterCriticalSection() has already
        // done the work of checking the thread id and updating re-entrancy
        // counts, so if its already not zero, we know it must be us
        //

        ++_WriteCount;
        if (_ThreadId == 0) {
            _ThreadId = GetCurrentThreadId();
#if INET_DEBUG
            INET_ASSERT(_ThreadId != _ThreadIdReader);
#endif
            acquired = Wait(_hWriteEvent);
            EnterCriticalSection(&_CritSect);
        } else {

            INET_ASSERT(_ThreadId == GetCurrentThreadId());

        }
    } else {

        //
        // don't allow re-entry if already held for exclusive access
        //

        INET_ASSERT(_ThreadId == 0);

        //
        // acquired for non-exclusive ownership (read access). Just increase
        // the number of active readers. If this is the first then inhibit the
        // writer
        //

        if (InterlockedIncrement(&_Readers) == 0) {
#if INET_DEBUG
            if (_ThreadIdReader == 0) {
                _ThreadIdReader = GetCurrentThreadId();
            }
#endif
            ResetEvent(_hWriteEvent);
        }

        //
        // reader doesn't need to keep hold of critical section
        //

        //LeaveCriticalSection(&_CritSect);
    }

    DEBUG_LEAVE(acquired);

    return acquired;
}


VOID
RESOURCE_LOCK::Release(
    VOID
    )

/*++

Routine Description:

    Releases a resource previously acquired by RESOURCE_LOCK::Acquire()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(0);

        return;
    }

    if ((_ThreadId != 0) && (_ThreadId == GetCurrentThreadId())) {

        INET_ASSERT(_WriteCount > 0);

        if (--_WriteCount == 0) {

            //
            // we acquired _hWriteEvent; signal it to allow next writer to continue
            //

            SetEvent(_hWriteEvent);

            //
            // this resource no longer owned for exclusive access
            //

            _ThreadId = 0;
        }
        LeaveCriticalSection(&_CritSect);
    } else if (InterlockedDecrement(&_Readers) < 0) {

        INET_ASSERT(_Readers >= -1);

        //
        // we are last currently active reader; allow waiting writer to continue
        //

#if INET_DEBUG
        if (_ThreadIdReader == GetCurrentThreadId()) {
            _ThreadIdReader = 0;
        }
#endif
        SetEvent(_hWriteEvent);
    }

    DEBUG_LEAVE(0);
}

#else

BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    if (bExclusiveMode) {
        do {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Waiting on WriteEvent\n")
                        );

            if (_ThreadId != GetCurrentThreadId()) {
                Wait(_hWriteEvent);
            }
            EnterCriticalSection(&_CritSect);

            INET_ASSERT((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()));

            if ((_Readers == -1)
                && ((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()))) {
                _ThreadId = GetCurrentThreadId();
                if (++_WriteCount == 1) {
                    ResetEvent(_hWriteEvent);
                }
                break;
            }

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("trying again\n")
                        );

            LeaveCriticalSection(&_CritSect);
        } while ( 1 );
    } else {
        EnterCriticalSection(&_CritSect);
        if (++_Readers == 0) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Resetting WriteEvent\n")
                        );

            ResetEvent(_hWriteEvent);
        }
        LeaveCriticalSection(&_CritSect);
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

VOID
RESOURCE_LOCK::Release(
    VOID
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    if (IsInitialized()) {
        if (_ThreadId == GetCurrentThreadId()) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Clearing writer\n")
                        );

            if (--_WriteCount == 0) {
                _ThreadId = 0;
                SetEvent(_hWriteEvent);
            }
            LeaveCriticalSection(&_CritSect);
        } else {
            EnterCriticalSection(&_CritSect);
            if (--_Readers == -1) {

                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Setting WriteEvent\n")
                            );

                SetEvent(_hWriteEvent);
            }
            LeaveCriticalSection(&_CritSect);
        }
    }

    DEBUG_LEAVE(0);
}

#endif // OLD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\priolist.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    priolist.cxx

Abstract:

    Contains prioritized, serialized list class implementation

    Contents:
        CPriorityList::Insert
        CPriorityList::Remove

Author:

    Richard L Firth (rfirth) 03-May-1997

Notes:

    Properly, the CPriorityList class should extend a CSerializedList class, but
    we don't currently have one, just a serialized list type (common\serialst.cxx).

    WARNING: Code in this module makes assumptions about the contents of a
    SERIALIZED_LIST

Revision History:

    03-May-1997 rfirth
        Created

--*/

#include <wininetp.h>

//
// class methods
//


VOID
CPriorityList::Insert(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Insert prioritized list entry into prioritized, serialized list

Arguments:

    pEntry  - pointer to prioritized list entry to add

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Insert",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    Acquire();

    INET_ASSERT(!IsOnSerializedList(&m_List, pEntry->List()));
    INET_ASSERT(pEntry->Next() == NULL);
    INET_ASSERT(pEntry->Prev() == NULL);

    CPriorityListEntry * pCur;

    for (pCur = (CPriorityListEntry *)m_List.List.Flink;
         pCur != (CPriorityListEntry *)&m_List.List.Flink;
         pCur = (CPriorityListEntry *)pCur->Next()) {

        if (pCur->GetPriority() < pEntry->GetPriority()) {
            break;
        }
    }
    InsertHeadList(pCur->Prev(), pEntry->List());
    ++m_List.ElementCount;
    Release();

    DEBUG_LEAVE(0);
}


VOID
CPriorityList::Remove(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Remove entry from prioritized serialized list

Arguments:

    pEntry  - address of entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Remove",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    Acquire();

    INET_ASSERT(IsOnSerializedList(&m_List, pEntry->List()));

    pEntry->Remove();
    --m_List.ElementCount;
    Release();

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\rescache.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.cxx

Abstract:

    Contains functions which manipulate resolver cache for winsock
    name resolution calls

    Contents:
        InitializeResolverCache
        TerminateResolverCache
        QueryResolverCache
        AddResolverCacheEntry
        FlushResolverCache
        ReleaseResolverCacheEntry
        (RemoveCacheEntry)
        (ResolverCacheHit)
        (AddrInfoMatch)
        (CreateCacheEntry)

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Environment:

    Win-16/32 user level

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// includes
//

#include "wininetp.h"

//
// private manifests
//

//
// private macros
//

#define SET_EXPIRATION_TIME(cacheEntry)

//
// private data
//

PRIVATE BOOL ResolverCacheInitialized = FALSE;

//
// DnsCachingEnabled - caching is enabled by default
//

PRIVATE BOOL DnsCachingEnabled = TRUE;

//
// DnsCacheTimeout - number of seconds before a cache entry expires. This value
// is added to the current time (in seconds) to get the expiry time
//

PRIVATE DWORD DnsCacheTimeout = DEFAULT_DNS_CACHE_TIMEOUT;

//
// MaximumDnsCacheEntries - the maximum number of RESOLVER_CACHE_ENTRYs in the
// cache before we start throwing out the LRU
//

PRIVATE INT MaximumDnsCacheEntries = DEFAULT_DNS_CACHE_ENTRIES;

//
// CurrentDnsCacheEntries - the number of RESOLVER_CACHE_ENTRYs currently in the
// cache
//

PRIVATE INT CurrentDnsCacheEntries = 0;

//
// ResolverCache - serialized list of RESOLVER_CACHE_ENTRYs, kept in MRU order.
// We only need to remove the tail of the list to remove the LRU entry
//

PRIVATE SERIALIZED_LIST ResolverCache = {0};

//
// private prototypes
//

PRIVATE
VOID
RemoveCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    );

PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    );

PRIVATE
BOOL
AddrInfoMatch(
    IN LPADDRINFO AddrInfo,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    );

PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive
    );

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(
    IN DWORD Time
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheAddrInfoStr(
    IN LPADDRINFO AddrInfo
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapSockAddress(
    IN LPSOCKADDR Address
    );

#endif

//
// functions
//


VOID
InitializeResolverCache(
    VOID
    )

/*++

Routine Description:

    Initializes the resolver cache:

        * Initializes the cache list anchor
        * loads the cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "InitializeResolverCache",
                 NULL
                 ));


    if (!(BOOL)InterlockedExchange((LPLONG)&ResolverCacheInitialized, TRUE)) {
        InternetReadRegistryDword("DnsCacheEnabled", (LPDWORD)&DnsCachingEnabled);
        InternetReadRegistryDword("DnsCacheEntries", (LPDWORD)&MaximumDnsCacheEntries);
        InternetReadRegistryDword("DnsCacheTimeout", &DnsCacheTimeout);
        InitializeSerializedList(&ResolverCache);

        //
        // if the size of the cache in the registry is 0 then its the same as
        // no caching
        //

        if (MaximumDnsCacheEntries == 0) {
            DnsCachingEnabled = FALSE;
        }
    } else {

        //
        // shouldn't be calling this more than once
        //

        INET_ASSERT(FALSE);

    }

    DEBUG_LEAVE(0);
}


VOID
TerminateResolverCache(
    VOID
    )

/*++

Routine Description:

    Free up all resources allocated by InitializeResolverCache()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "TerminateResolverCache",
                 NULL
                 ));

    if (InterlockedExchange((LPLONG)&ResolverCacheInitialized, FALSE)) {

        //
        // short-circuit any other cache attempts (shouldn't be any by now)
        //

        DnsCachingEnabled = FALSE;

        //
        // and clear out the list
        //

        FlushResolverCache();

        //
        // we are done with the serialized list
        //

        TerminateSerializedList(&ResolverCache);
    }

    DEBUG_LEAVE(0);
}


LPRESOLVER_CACHE_ENTRY
QueryResolverCache(
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL,
    OUT LPADDRINFO * AddrInfo,
    OUT LPDWORD TimeToLive
    )

/*++

Routine Description:

    Checks if Name is stored in the last resolved name cache. If the entry is
    found, but has expired then it is removed from the cache

Arguments:

    Name        - pointer to name string

    Address     - pointer to IP address (in sockaddr format)

    AddrInfo    - pointer to returned pointer to addrinfo

    TimeToLive  - pointer to returned time to live

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "QueryResolverCache",
                 "%q, %s, %#x, %#x",
                 Name,
                 CacheMapSockAddress(Address),
                 AddrInfo,
                 TimeToLive
                 ));

    LPRESOLVER_CACHE_ENTRY lpEntry;

    if (!DnsCachingEnabled) {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled\n"
                    ));

        *AddrInfo = NULL;
        lpEntry = NULL;
        goto quit;
    }

    LockSerializedList(&ResolverCache);

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;
    DWORD timeNow;

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(&ResolverCache);
    timeNow = (DWORD)time(NULL);

    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache)) {

        //
        // on every cache lookup, purge any stale entries. LIVE_FOREVER means
        // that we don't expect the entry's net address to expire, but it
        // DOESN'T mean that we can't throw out the entry if its the LRU and
        // we're at maximum cache capacity. We can't do this if the item is
        // still in-use. In this case, we mark it stale
        //

        if ((cacheEntry->ExpirationTime != LIVE_FOREVER)
        && (cacheEntry->ExpirationTime <= timeNow)) {

            //
            // if reference count not zero then another thread is using
            // this entry - mark as stale else delete it
            //

            if (cacheEntry->ReferenceCount != 0) {

                INET_ASSERT(cacheEntry->State == ENTRY_IN_USE);

                cacheEntry->State = ENTRY_DELETE;
            } else {

                //
                // this entry is stale; throw it out
                // "my hovercraft is full of eels"
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out stale DNS entry %q, expiry = %s\n",
                            cacheEntry->AddrInfo->ai_canonname,
                            CacheTimestr(cacheEntry->ExpirationTime)
                            ));

                //
                // BUGBUG - what happens if ExpirationTime == timeNow?
                //

                previousEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
                RemoveCacheEntry(cacheEntry);
                cacheEntry = previousEntry;
            }
        } else if (ResolverCacheHit(cacheEntry, Name, Address)
        && ((cacheEntry->State == ENTRY_UNUSED)
        || (cacheEntry->State == ENTRY_IN_USE))) {

            //
            // we found the entry, and it still has time to live. Make it the
            // head of the list (MRU first), set the state to in-use and increase
            // the reference count
            //

            RemoveFromSerializedList(&ResolverCache, &cacheEntry->ListEntry);
            InsertAtHeadOfSerializedList(&ResolverCache, &cacheEntry->ListEntry);
            cacheEntry->State = ENTRY_IN_USE;
            ++cacheEntry->ReferenceCount;
            *AddrInfo = cacheEntry->AddrInfo;
            lpEntry = cacheEntry;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("entry found in DNS cache\n"
                        ));

            goto done;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }

    *AddrInfo = NULL;
    lpEntry = NULL;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("didn't find entry in DNS cache\n"
                ));

done:

    UnlockSerializedList(&ResolverCache);

quit:

    DEBUG_LEAVE(lpEntry);
    return lpEntry;
}


VOID
AddResolverCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive
    )

/*++

Routine Description:

    Adds an addrinfo pointer to the cache. Creates a new entry to hold it
    and links it into the cache list, displacing the LRU entry if required.
    If we cannot create the entry, the addrinfo is freed, no errors returned

    N.B.: Calling this routine gives the resolver cache "ownership" of the
    addrinfo chain. Caller should not use AddrInfo pointer afterwards.

Arguments:

    lpszHostName    - the name we originally requested be resolved. May be
                      different than the names returned by the resolver, e.g.
                      "proxy" => "proxy1.microsoft.com, proxy2.microsoft.com"

    AddrInfo        - pointer to addrinfo chain to add to the cache

    TimeToLive      - amount of time this information has to live. Can be:

                        LIVE_FOREVER    - don't timeout (but can be discarded)

                        LIVE_DEFAULT    - use the default value

                        anything else   - number of seconds to live

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "AddResolverCacheEntry",
                 "%q, %#x, %d",
                 lpszHostName,
                 AddrInfo,
                 TimeToLive
                 ));

    BOOL bAdded = FALSE;

    if (!DnsCachingEnabled) {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled\n"
                    ));

        goto quit;
    }

    LockSerializedList(&ResolverCache);

    //
    // check that the entry is not already in the cache - 2 or more threads may
    // have been simultaneously resolving the same name
    //

    LPADDRINFO lpAddrInfo;
    DWORD ttl;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    INET_ASSERT(lpszHostName != NULL);

    if (!(lpResolverCacheEntry = QueryResolverCache(lpszHostName, NULL, &lpAddrInfo, &ttl))) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        //
        // remove as many entries as we can beginning at the tail of the list.
        // We try to remove enough to get the cache size back below the limit.
        // This may consist of removing expired entries or entries marked as
        // DELETE. If there are expired, in-use entries then we mark them as
        // DELETE. This may result in the cache list growing until those threads
        // which have referenced cache entries release them
        //

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)TailOfSerializedList(&ResolverCache);

        while ((CurrentDnsCacheEntries >= MaximumDnsCacheEntries)
        && (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache))) {

            //
            // cache has maximum entries: throw out the Least Recently Used (its
            // the one at the back of the queue, ma'am) but only if no-one else
            // is currently accessing it
            //

            if ((cacheEntry->State != ENTRY_IN_USE)
            && (cacheEntry->ReferenceCount == 0)) {

                INET_ASSERT((cacheEntry->State == ENTRY_UNUSED)
                            || (cacheEntry->State == ENTRY_DELETE));

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out LRU %q\n",
                            cacheEntry->AddrInfo->ai_canonname
                            ));

                LPRESOLVER_CACHE_ENTRY nextEntry;

                nextEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
                RemoveCacheEntry(cacheEntry);
                cacheEntry = nextEntry;
            } else if (cacheEntry->State == ENTRY_IN_USE) {

                //
                // this entry needs to be freed when it is released
                //

                cacheEntry->State = ENTRY_DELETE;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
        }

        //
        // add the entry at the head of the queue - it is the Most Recently Used
        // after all. If we fail to allocate memory, its no problem: it'll just
        // take a little longer if this entry would have been hit before we needed
        // to throw out another entry
        //

        if (cacheEntry = CreateCacheEntry(lpszHostName, AddrInfo, TimeToLive)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("caching %q, expiry = %s\n",
                        CacheAddrInfoStr(cacheEntry->AddrInfo),
                        CacheTimestr(cacheEntry->ExpirationTime)
                        ));

            InsertAtHeadOfSerializedList(&ResolverCache, &cacheEntry->ListEntry);
            ++CurrentDnsCacheEntries;
            bAdded = TRUE;
        }

    } else {

        //
        // this entry is already in the cache. 2 or more threads must have been
        // resolving the same name simultaneously. We just bump the expiration
        // time to the more recent value
        //

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("found %q already in the cache!?\n",
                    lpszHostName
                    ));

        ReleaseResolverCacheEntry(lpResolverCacheEntry);
    }

    UnlockSerializedList(&ResolverCache);

quit:

    if (!bAdded) {
        //
        // failed to add this entry to the cache, so free it
        //
        _I_freeaddrinfo(AddrInfo);
    }

    DEBUG_LEAVE(0);
}


VOID
FlushResolverCache(
    VOID
    )

/*++

Routine Description:

    Removes all entries in DNS resolver cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "FlushResolverCache",
                 NULL
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;

    LockSerializedList(&ResolverCache);

    previousEntry = (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache);
    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(&ResolverCache);
    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache)) {
        if (cacheEntry->State == ENTRY_UNUSED) {
            RemoveCacheEntry(cacheEntry);
        } else {

            DEBUG_PRINT(SOCKETS,
                        WARNING,
                        ("cache entry %#x (%q) still in-use\n",
                        cacheEntry->HostName
                        ));

            cacheEntry->State = ENTRY_DELETE;
            previousEntry = cacheEntry;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)previousEntry->ListEntry.Flink;
    }

    UnlockSerializedList(&ResolverCache);

    DEBUG_LEAVE(0);
}


VOID
ReleaseResolverCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY cacheEntry
    )

/*++

Routine Description:

    Either mark a entry unused or if it is stale, delete it

Arguments:

    lpAddrInfo   - pointer to AddrInfo field of entry to free

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ReleaseResolverCacheEntry",
                 "%#x, %#x",
                 cacheEntry, (cacheEntry ? cacheEntry->AddrInfo : NULL)
                 ));
                 
    LockSerializedList(&ResolverCache);

    //
    // reference count should never go below zero!
    //

    INET_ASSERT(cacheEntry->ReferenceCount > 0);

    if (--cacheEntry->ReferenceCount <= 0) {

        //
        // last releaser gets to decide what to do - mark unused or delete
        //

        if (cacheEntry->State == ENTRY_IN_USE) {
            cacheEntry->State = ENTRY_UNUSED;
        } else if (cacheEntry->State == ENTRY_DELETE) {

            //
            // entry is already stale - throw it out
            //

            RemoveCacheEntry(cacheEntry);
        } else {

            //
            // unused? or bogus value? Someone changed state while refcount
            // not zero?
            //

            INET_ASSERT((cacheEntry->State == ENTRY_IN_USE)
                        || (cacheEntry->State == ENTRY_DELETE));

        }
    }

    UnlockSerializedList(&ResolverCache);

    DEBUG_LEAVE(0);
}


VOID
ThrowOutResolverCacheEntry(
    IN LPADDRINFO lpAddrInfo
    )

/*++

Routine Description:

    Removes this entry from the DNS cache, based on the host name. We assume
    that the entry came from the cache, so unless it has been already purged,
    we should be able to throw it out

Arguments:

    lpAddrInfo  - pointer to addrinfo field with name of entry to throw out

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ThrowOutResolverCacheEntry",
                 "%#x [%q]",
                 lpAddrInfo,
                 lpAddrInfo->ai_canonname
                 ));

    if (DnsCachingEnabled) {
        LockSerializedList(&ResolverCache);

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(&ResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache)) {
            if (AddrInfoMatch(cacheEntry->AddrInfo, lpAddrInfo->ai_canonname, NULL)) {

                //
                // if the entry is unused then we can delete it, else we have
                // to leave it to the thread with the last reference
                //

                if (cacheEntry->State == ENTRY_UNUSED) {
                    RemoveCacheEntry(cacheEntry);
                } else {
                    cacheEntry->State = ENTRY_DELETE;
                }
                break;
            }
        }

        UnlockSerializedList(&ResolverCache);
    } else {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


PRIVATE
VOID
RemoveCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    )

/*++

Routine Description:

    Takes a cache entry off the list and frees it

    N.B.: This function must be called with the resolver cache serialized list
    already locked

Arguments:

    lpCacheEntry    - currently queued entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "RemoveCacheEntry",
                 "%#x",
                 lpCacheEntry
                 ));

    RemoveFromSerializedList(&ResolverCache, &lpCacheEntry->ListEntry);

    INET_ASSERT(lpCacheEntry->ReferenceCount == 0);
    INET_ASSERT((lpCacheEntry->State == ENTRY_UNUSED)
                || (lpCacheEntry->State == ENTRY_DELETE));

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("throwing out %q, expiry = %s\n",
                CacheAddrInfoStr(lpCacheEntry->AddrInfo),
                CacheTimestr(lpCacheEntry->ExpirationTime)
                ));

    _I_freeaddrinfo(lpCacheEntry->AddrInfo);
    lpCacheEntry = (LPRESOLVER_CACHE_ENTRY)FREE_MEMORY((HLOCAL)lpCacheEntry);

    INET_ASSERT(lpCacheEntry == NULL);

    --CurrentDnsCacheEntries;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("CurrentDnsCacheEntries = %d\n",
                CurrentDnsCacheEntries
                ));

    INET_ASSERT((CurrentDnsCacheEntries >= 0) 
                && (CurrentDnsCacheEntries <= MaximumDnsCacheEntries));

    DEBUG_LEAVE(0);
}


PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    )

/*++

Routine Description:

    Checks this RESOLVER_CACHE_ENTRY for a match with Name or Address. If Name,
    can match with ai_canonname in addrinfo, or with originally resolved name

Arguments:

    lpCacheEntry    - pointer to RESOLVER_CACHE_ENTRY to check

    Name            - optional name to check

    Address         - optional server address to check

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ResolverCacheHit",
                 "%#x, %q, %s",
                 lpCacheEntry,
                 Name,
                 CacheMapSockAddress(Address)
                 ));

    BOOL found;

    if ((Name != NULL)
    && (lpCacheEntry->HostName != NULL)
    && (lstrcmpi(lpCacheEntry->HostName, Name) == 0)) {

        DEBUG_PRINT(SOCKETS,
        INFO,
        ("matched name %q\n",
        lpCacheEntry->HostName
        ));

        found = TRUE;
    } else {
       found = FALSE;
       Name = NULL;
    }    
    
    if (!found && Address) {
        found = AddrInfoMatch(lpCacheEntry->AddrInfo, Name, Address);
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
AddrInfoMatch(
    IN LPADDRINFO AddrInfo,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    )

/*++

Routine Description:

    Compares a getaddrinfo result for a match with a host name or address

Arguments:

    AddrInfo - pointer to addrinfo chain to compare

    Name     - pointer to name string

    Address  - pointer to IP address (as a sockaddr)

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "AddrInfoMatch",
                 "%#x, %q, %s",
                 AddrInfo,
                 Name,
                 CacheMapSockAddress(Address)
                 ));

    BOOL found = FALSE;

    if (Name) {
        if ((AddrInfo->ai_canonname != NULL) &&
        (lstrcmpi(AddrInfo->ai_canonname, Name) == 0))
            found = TRUE;
    } else {

        INET_ASSERT(Address != NULL);

        do {
            if ((AddrInfo->ai_addr->sa_family == Address->sa_family)
            && (memcmp(AddrInfo->ai_addr, Address, AddrInfo->ai_addrlen) == 0)) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("matched %s\n",
                            CacheMapSockAddress(Address)
                            ));

                found = TRUE;
                break;
            }

        } while (AddrInfo = AddrInfo->ai_next);
    }

    if (found) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("addrinfo = %q\n",
                    CacheAddrInfoStr(AddrInfo)
                    ));

    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive
    )

/*++

Routine Description:

    Allocates a RESOLVER_CACHE_ENTRY and packs it with the addrinfo information
    and sets the ExpirationTime

Arguments:

    lpszHostName    - name we resolved

    AddrInfo        - pointer to addrinfo chain to store in new entry

    TimeToLive      - amount of time before this entry expires

Return Value:

    LPRESOLVER_CACHE_ENTRY

--*/

{
    LPRESOLVER_CACHE_ENTRY cacheEntry;

    INET_ASSERT(lpszHostName != NULL);

    //
    // only copy lpszHostName if it is different from the name in addrinfo
    //

    UINT hostNameSize;

    if ((AddrInfo->ai_canonname != NULL)
    && lstrcmpi(AddrInfo->ai_canonname, lpszHostName) != 0) 
    {
        hostNameSize = lstrlen(lpszHostName) + 1;
    }
    else if (AddrInfo->ai_canonname == NULL)
    {
        // if ap_canonname is null, we have to save the lpszHoatName
        hostNameSize = lstrlen(lpszHostName) + 1;
    }
    else 
    {
        hostNameSize = 0;
    }

    //
    // allocate space for the cache entry
    //

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)ALLOCATE_MEMORY(LMEM_FIXED,
                                                         sizeof(RESOLVER_CACHE_ENTRY)
                                                         + hostNameSize
                                                         );
    if (cacheEntry != NULL) {

        //
        // cache the getaddrinfo result
        //

        cacheEntry->AddrInfo = AddrInfo;

        //
        // copy the host name to the end of the buffer if required
        //

        if (hostNameSize != 0) {
            cacheEntry->HostName = (LPSTR)(cacheEntry + 1);
            RtlCopyMemory(cacheEntry->HostName, lpszHostName, hostNameSize);
        } else {
            cacheEntry->HostName = NULL;
        }

        //
        // calculate the expiration time as the current time (in seconds since
        // 1/1/70) + number of seconds to live OR indefinite if TimeToLive is
        // specified as LIVE_FOREVER, which is what we use if the host
        // information didn't originate from DNS
        //

        cacheEntry->ExpirationTime = (DWORD)((TimeToLive == LIVE_FOREVER)
                                        ? LIVE_FOREVER
                                        : time(NULL)
                                            + ((TimeToLive == LIVE_DEFAULT)
                                                ? DnsCacheTimeout
                                                : TimeToLive) );

        //
        // the entry state is initially unused
        //

        cacheEntry->State = ENTRY_UNUSED;

        //
        // and reference is zero
        //

        cacheEntry->ReferenceCount = 0;
    }

    return cacheEntry;
}

#if INET_DEBUG

//
// CAVEAT - can only call these functions once per printf() etc. because of
//          static buffers (but still thread-safe)
//

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(IN DWORD Time) {

    //
    // previous code - writes formatted human-sensible date/time to buffer
    //

    //LPSTR p;
    //
    ////
    //// remove the LF from the time string returned by ctime()
    ////
    //
    //p = ctime((const time_t *)&Time);
    //p[strlen(p) - 1] = '\0';
    //return p;

    //
    // abbreviated CRT version - just write # seconds since 1970 to buffer
    //

    static char buf[16];

    wsprintf(buf, "%d", Time);
    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheAddrInfoStr(IN LPADDRINFO AddrInfo) {

    static char buf[2048];
    LPSTR p;
    int Count;

    p = buf;

    for (Count = 1; AddrInfo != NULL; AddrInfo = AddrInfo->ai_next) {
        p += wsprintf(p, "AddrInfo #%u:\n", Count++);
        p += wsprintf(p, "ai_flags = %u\n", AddrInfo->ai_flags);
        p += wsprintf(p, "ai_family = %u\n", AddrInfo->ai_family);
        p += wsprintf(p, "ai_socktype = %u\n", AddrInfo->ai_socktype);
        p += wsprintf(p, "ai_protocol = %u\n", AddrInfo->ai_protocol);
        p += wsprintf(p, "ai_addrlen = %u\n", AddrInfo->ai_addrlen);
        p += wsprintf(p, "ai_canonname = %s\n", AddrInfo->ai_canonname ? AddrInfo->ai_canonname : "NULL");
        p += wsprintf(p, "ai_addr:\n%s\n", CacheMapSockAddress(AddrInfo->ai_addr));
    }

    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapSockAddress(IN LPSOCKADDR Address) {

    if (!Address) {
        return "<null>";
    }

    static char buf[1024];
    LPSTR p;

    p = buf;
    if (Address->sa_family == AF_INET) {
        struct sockaddr_in *sin;

        sin = (struct sockaddr_in *)Address;
        p += wsprintf(p, "sin_family = %u\n", sin->sin_family);
        p += wsprintf(p, "sin_port = %u\n", _I_ntohs(sin->sin_port));
        p += wsprintf(p, "sin_addr = %s\n", _I_inet_ntoa(sin->sin_addr));

    } else if (Address->sa_family == AF_INET6) {
        struct sockaddr_in6 *sin6;

        sin6 = (struct sockaddr_in6 *)Address;
        p += wsprintf(p, "sin6_family = %u\n", sin6->sin6_family);
        p += wsprintf(p, "sin6_port = %u\n", _I_ntohs(sin6->sin6_port));
        p += wsprintf(p, "sin6_flowinfo = %u\n", sin6->sin6_flowinfo);
        p += wsprintf(p, "sin6_scope_id = %u\n", sin6->sin6_scope_id);
        p += wsprintf(p, "sin6_addr = %2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x\n",
             sin6->sin6_addr.u.Byte[0],
             sin6->sin6_addr.u.Byte[1],
             sin6->sin6_addr.u.Byte[2],
             sin6->sin6_addr.u.Byte[3],
             sin6->sin6_addr.u.Byte[4],
             sin6->sin6_addr.u.Byte[5],
             sin6->sin6_addr.u.Byte[6],
             sin6->sin6_addr.u.Byte[7],
             sin6->sin6_addr.u.Byte[8],
             sin6->sin6_addr.u.Byte[9],
             sin6->sin6_addr.u.Byte[10],
             sin6->sin6_addr.u.Byte[11],
             sin6->sin6_addr.u.Byte[12],
             sin6->sin6_addr.u.Byte[13],
             sin6->sin6_addr.u.Byte[14],
             sin6->sin6_addr.u.Byte[15]);

    } else {
        p += wsprintf(p, "sa_family = %u\n", Address->sa_family);
    }

    return (LPSTR)buf;
}

#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.c

Abstract:

    Contains name resolution cache

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

//
//BUGBUG: This include should be removed, duplicate of above
//
#ifndef SPX_SUPPORT
#include <wininetp.h>
#endif


//
// private manifests
//

#define NAMERES_CACHE_USED            0x00000001
#define NAMERES_CACHE_USES_GUID       0x00000002

#define ENTERCRIT_NAMERESCACHE()  EnterCriticalSection(&vcritNameresCache)
#define LEAVECRIT_NAMERESCACHE()  LeaveCriticalSection(&vcritNameresCache)
#define IS_EMPTY(indx)            ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USED) == 0)
#define USES_GUID(indx)           ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USES_GUID))

// number of cache entries
#define DEFAULT_NAMERES_CACHE_ENTRIES   10

// expiry time for an addresslist
#define DEFAULT_EXPIRY_DELTA            (24 * 60 * 60 * (LONGLONG)10000000)


//
//  structure definition
//

typedef struct tagNAMERES_CACHE {
    DWORD               dwFlags;       // general flags to be used as needed
    DWORD               dwNameSpace;   // namespace ??
    GUID                sGuid;         // GUID describing service type
    LPSTR               lpszName;      // ptr to name that needs resolution
    FILETIME            ftLastUsedTime;    // last accesstime, mainly for purging
    FILETIME            ftCreationTime;// When it was created
    ADDRESS_INFO_LIST   sAddrList;     // List of address (defined in ixport.h)
} NAMERES_CACHE, far *LPNAMERES_CACHE;





//
// private variables for name resolution cache
//


// Name cache size allocated in init
LPNAMERES_CACHE vlpNameresCache = NULL;

// Number of elements allowed in the nameres cache
int vcntNameresCacheEntries = DEFAULT_NAMERES_CACHE_ENTRIES;


// time in 100ns after which an address is expired
LONGLONG vftExpiryDelta = DEFAULT_EXPIRY_DELTA;

BOOL vfNameresCacheInited = FALSE;

// serialization
CRITICAL_SECTION vcritNameresCache;

//
// private function prototypes
//


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    INT     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
);


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
);


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
);


PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
);

PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
);


PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
);

//
// functions
//


DWORD
InitNameresCache(
    VOID
)
/*++

Routine Description:

    Init name resolution cache. This routine a) allocates a table of
    name cache entries b)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{


    if (vfNameresCacheInited) {
        return (ERROR_SUCCESS);
    }

    // first try to alloc the memory, if it fails just quit
    vlpNameresCache = (LPNAMERES_CACHE)ALLOCATE_MEMORY(
                        LPTR,
                        vcntNameresCacheEntries * sizeof(NAMERES_CACHE)
                        );

    if (!vlpNameresCache) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    InitializeCriticalSection(&vcritNameresCache);

    ENTERCRIT_NAMERESCACHE();

    vfNameresCacheInited = TRUE;

    LEAVECRIT_NAMERESCACHE();

    return (ERROR_SUCCESS);

}


DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_SUCCESS;

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTERCRIT_NAMERESCACHE();

    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);

    // if indx is valid, delete the entry, do some purging too
    if (indx != -1) {
        DeleteNameresCacheEntry(indx);
        PurgeEntries(FALSE);
    }
    else {
        // create atleast one hole
        indx = PurgeEntries(TRUE);
    }

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    dwError = CreateNameresCacheEntry(indx,
                            dwNameSpace,
                            lpGuid,
                            lpName,
                            cntAddresses,
                            lpCsaddrInfo);

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}




DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {

        ENTERCRIT_NAMERESCACHE();

        indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpszName);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND; //yuk
        }

        LEAVECRIT_NAMERESCACHE();
    }
    return (dwError);
}


#ifdef MAYBE

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {
        ENTERCRIT_NAMERESCACHE();

        indx = FindNameresCacheEntryByAddr(cntAddresses, lpCsaddrInfo);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND;
        }

        LEAVECRIT_NAMERESCACHE();
    }
    return (dwError);

}
#endif //MAYBE

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfo
)
/*++

Routine Description:

    This routine looks up the cache and returns the list of addresses
    corresponding to lpGuid/lpName.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD   dwError = ERROR_FILE_NOT_FOUND; // poor error

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTERCRIT_NAMERESCACHE();

    // is this entry already cached?
    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);


    if (indx != -1) {
        // yes, let use give back the info

        *lpcntAddresses = vlpNameresCache[indx].sAddrList.AddressCount;

        if ((dwError = CopyCsaddr(vlpNameresCache[indx].sAddrList.Addresses, *lpcntAddresses, lplpCsaddrInfo))
            != ERROR_SUCCESS) {

            goto bailout;
        }
        // update the last used time, we will use this to
        // age out the entries

        GetCurrentGmtTime(&(vlpNameresCache[indx].ftLastUsedTime));
        dwError = ERROR_SUCCESS;
    }

bailout:

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}


DWORD
DeinitNameresCache(
    VOID
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    if (vfNameresCacheInited) {
        ENTERCRIT_NAMERESCACHE();

        for (i = 0; i < vcntNameresCacheEntries; ++i) {
            if (!IS_EMPTY(i)) {
                DeleteNameresCacheEntry(i);
            }
        }

        FREE_MEMORY(vlpNameresCache);

        vlpNameresCache = NULL;

        vfNameresCacheInited = FALSE;

        LEAVECRIT_NAMERESCACHE();
        DeleteCriticalSection(&vcritNameresCache);
    }
    return (ERROR_SUCCESS);
}


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    int     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    INET_ASSERT(IS_EMPTY(indx));


    memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));

    // we could get a name or a guid
    // do it for name first before doing it for GUID

    // BUGBUG in future we should consider name+GUID+port
    if (lpszName) {
       vlpNameresCache[indx].lpszName = (LPSTR)ALLOCATE_MEMORY(LPTR, lstrlen(lpszName)+1);
       if (!vlpNameresCache[indx].lpszName) {
           goto bailout;
       }
       strcpy(vlpNameresCache[indx].lpszName, lpszName);
    }
    else if (lpGuid) {
        INET_ASSERT(FALSE); // rigth now. In future this should go away
        memcpy(&(vlpNameresCache[indx].sGuid), lpGuid, sizeof(GUID));
        vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USES_GUID;
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    INET_ASSERT(cntAddresses > 0);

    if (CopyCsaddr(lpCsaddrInfo, cntAddresses, &(vlpNameresCache[indx].sAddrList.Addresses))
        != ERROR_SUCCESS) {
        goto bailout;
    }

    vlpNameresCache[indx].sAddrList.AddressCount = cntAddresses;

    // mark this as being non-empty
    vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USED;

    // set the creation and last-used times as now

    GetCurrentGmtTime(&(vlpNameresCache[indx].ftCreationTime));
    vlpNameresCache[indx].ftLastUsedTime = vlpNameresCache[indx].ftCreationTime ;

    dwError = ERROR_SUCCESS;

bailout:

    if (dwError != ERROR_SUCCESS) {
        if (vlpNameresCache[indx].sAddrList.Addresses) {
            FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);
            vlpNameresCache[indx].sAddrList.Addresses = NULL;
        }
        if (vlpNameresCache[indx].lpszName) {
            FREE_MEMORY(vlpNameresCache[indx].lpszName);
            vlpNameresCache[indx].lpszName = NULL;
        }
        memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));
    }

    return (dwError);
}


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    INET_ASSERT((indx >=0) && (indx < vcntNameresCacheEntries));

    if (vlpNameresCache[indx].lpszName) {
        FREE_MEMORY(vlpNameresCache[indx].lpszName);
    }

    INET_ASSERT(vlpNameresCache[indx].sAddrList.Addresses);

    FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);

    memset(&vlpNameresCache[indx], 0, sizeof(NAMERES_CACHE));

    return (ERROR_SUCCESS);
}

#ifdef MAYBE

PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i) && // not empty
            (vlpNameresCache[i].sAddrList.AddressCount == cntAddr) && // count is the same
            (!memcmp(vlpNameresCache[i].sAddrList.Addresses,    // list matches
                     lpCsaddrInfo,
                     cntAddr * sizeof(CSADDR_INFO)))) {
            return (i);
        }
    }
    return (-1);
}
#endif //MAYBE


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {
            if (vlpNameresCache[i].dwNameSpace == dwNameSpace) {
                if (!USES_GUID(i)) {

                    INET_ASSERT(vlpNameresCache[i].lpszName);

                    if (lpszName &&
                        !lstrcmpi(lpszName, vlpNameresCache[i].lpszName)) {
                        return (i);
                    }
                }
                else{

                    if (lpGuid && !memcmp(lpGuid, &vlpNameresCache[i].sGuid, sizeof(GUID))) {
                        return (i);
                    }
                }
            }
        }
    }
    return (-1);
}


PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
)
/*++

Routine Description:


Arguments:


Return Value:

    index of a free entry

--*/
{
    int i, indxlru = -1, indxHole=-1;
    FILETIME ft;
    BOOL fFoundHole = FALSE;

    GetCurrentGmtTime(&ft);

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {

            // purge stale entries
            if ( (FT2LL(ft) - FT2LL(vlpNameresCache[i].ftCreationTime))
                    > FT2LL(vftExpiryDelta)) {
                DeleteNameresCacheEntry(i);
                indxHole = i;
            }
            else if (FT2LL(vlpNameresCache[i].ftLastUsedTime) <= FT2LL(ft)) {
                ft = vlpNameresCache[i].ftLastUsedTime;
                indxlru = i; // LRU entry if we need to purge it
            }
        }
        else {
            indxHole = i;
        }
    }

    // if there is no hole, purge the LRU entry if forced
    if (indxHole == -1) {

        INET_ASSERT(indxlru != -1);

        if (fForce) {
            DeleteNameresCacheEntry(indxlru);
            indxHole = indxlru;
        }
    }
    return (indxHole);
}

PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
)
{
    int i;
    LPCSADDR_INFO lpDst;
    UINT uSize;


    // BUGBUG assumes the way Compressaddress (ixport.cxx) allocates memory
    uSize = LocalSize(lpSrc);
    if (!uSize) {
        return (GetLastError());
    }

    *lplpDst = (LPCSADDR_INFO)ALLOCATE_MEMORY(LPTR, uSize);

    if (!*lplpDst) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    lpDst = *lplpDst;


    memcpy(lpDst, lpSrc, uSize);

    // now start doing fixups
    for (i=0; i<cntAddr; ++i) {
        lpDst[i].LocalAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].LocalAddr.lpSockaddr) - (DWORD)lpSrc));
        lpDst[i].RemoteAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].RemoteAddr.lpSockaddr) - (DWORD)lpSrc));
    }
    return (ERROR_SUCCESS);
}

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\secinit.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    secinit.cxx

Abstract:

    Contains load function for security.dll on NT and secur32.dll on win95
    Also handles WinTrust.dll function loading.

Author:

    Sophia Chung (sophiac)  6-Feb-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#include <wininetp.h>

//
// InitializationLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//

CRITICAL_SECTION InitializationSecLock = {0};

CRITICAL_SECTION InitFortezzaLock = {0};

HCRYPTPROV  GlobalFortezzaCryptProv;

//
// GlobalSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTable GlobalSecFuncTable = NULL;

//
// pWinVerifyTrust - Pointer to Entry Point in WINTRUST.DLL
//

WIN_VERIFY_TRUST_FN pWinVerifyTrust;
WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

//
// pSslCrackCertificate - Pointer to SCHANNEL.dll utility function that
//      is used for parsing X509 certificates.
//

SSL_CRACK_CERTIFICATE_FN pSslCrackCertificate;

//
// pSslFreeCertificate - Pointer to Schannel.dll function for freeing Certs
//

SSL_FREE_CERTIFICATE_FN  pSslFreeCertificate;

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE hSecurity = NULL;

//
// hWinTrust - NULL when WinTrust DLL is not loaded.
//

HINSTANCE hWinTrust = NULL;
BOOL g_fDoSpecialMagicForSGCCerts = FALSE;

HCERTSTORE g_hMyCertStore = NULL;
BOOL  g_bOpenMyCertStore = FALSE;

BOOL g_bFortezzaInstalled = FALSE;
BOOL g_bCheckedForFortezza = FALSE;
BOOL g_bAttemptedFortezzaLogin = FALSE;

CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext = NULL;
CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext = NULL;
CERT_FIND_CHAIN_IN_STORE_FN g_CertFindChainInStore = NULL;
CERT_FREE_CERTIFICATE_CHAIN_FN g_CertFreeCertificateChain = NULL;

#define LOCK_FORTEZZA()   EnterCriticalSection( &InitFortezzaLock )
#define UNLOCK_FORTEZZA() LeaveCriticalSection( &InitFortezzaLock )

DWORD
LoadWinTrust(
    VOID
    )

/*++

Routine Description:

    This function loads the WinTrust.DLL and binds a pointer to a function
    that is needed in the WinTrust DLL.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD error = ERROR_SUCCESS;

    LOCK_SECURITY();

    if( hWinTrust == NULL )
    {
        LPSTR lpszDllFileName = WINTRUST_DLLNAME;
        pWinVerifyTrust = NULL;

        //
        // Load the DLL
        //

        hWinTrust       = LoadLibrary(lpszDllFileName);

        if ( hWinTrust )
        {
            pWinVerifyTrust = (WIN_VERIFY_TRUST_FN)
                            GetProcAddress(hWinTrust, WIN_VERIFY_TRUST_NAME);
            pWTHelperProvDataFromStateData = (WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN)
                            GetProcAddress(hWinTrust, WT_HELPER_PROV_DATA_FROM_STATE_DATA_NAME);
        }


        if ( !hWinTrust || !pWinVerifyTrust )
        {
            error = GetLastError();

            if ( error == ERROR_SUCCESS )
            {
                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        }
        {
            // To show SGC certificates we need to do some special magic (see schnlui.cxx) which 
            // depends on some fixes in Wintrust.dll. We have 
            // Figure out the version info for WinTrust.dll
            TCHAR rgchWinTrustFileName[MAX_PATH];
            
            g_fDoSpecialMagicForSGCCerts = FALSE;

            if (GetModuleFileName(hWinTrust, rgchWinTrustFileName, ARRAY_ELEMENTS(rgchWinTrustFileName)) != 0)
            {
                DWORD cbFileVersionBufSize;
                DWORD dwTemp = 0;

                if ((cbFileVersionBufSize = GetFileVersionInfoSize(rgchWinTrustFileName, &dwTemp)) != 0)
                {
                    BYTE* pVerBuffer = NULL;

                    pVerBuffer = (BYTE *) _alloca(cbFileVersionBufSize);
                     
                    if ( (pVerBuffer != NULL) && 
                         (GetFileVersionInfo(rgchWinTrustFileName, 0, cbFileVersionBufSize, pVerBuffer) != 0))
                    {
                        VS_FIXEDFILEINFO *lpVSFixedFileInfo;
                        unsigned uiLength;

                        if( VerQueryValue( pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) != 0
                            && uiLength != 0)
                        {
                            // NT5 Beta3 wintrust version is 5.131.2001.0 which is the Min version we need.
                            // 0x50083 ==> 5.131
                            // 0x7db0000 ==> 2001.0
                            if ((lpVSFixedFileInfo->dwFileVersionMS > 0x50083) 
                                || (lpVSFixedFileInfo->dwFileVersionMS == 0x50083 && lpVSFixedFileInfo->dwFileVersionLS >= 0x07db0000))
                                g_fDoSpecialMagicForSGCCerts = TRUE;
                        }
                    }
                }
            }
        }
            
    }

    INET_ASSERT(pWinVerifyTrust);


    if ( error != ERROR_SUCCESS )
    {
        if (hWinTrust)
        {
            FreeLibrary(hWinTrust);
            hWinTrust = NULL;
        }
    }

    UNLOCK_SECURITY();

    return error;
}



VOID
SecurityInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    InitializeCriticalSection( &InitializationSecLock );
    InitializeCriticalSection( &InitFortezzaLock );
}

VOID
SecurityTerminate(
    VOID
    )
/*++

Routine Description:

    This function Deletes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    DeleteCriticalSection(&InitializationSecLock);
    DeleteCriticalSection(&InitFortezzaLock);
}


VOID
UnloadSecurity(
    VOID
    )

/*++

Routine Description:

    This function terminates the global data required for the security
    pkgs and dynamically unloads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD i;

    LOCK_SECURITY();

    //
    //  free all security pkg credential handles
    //

    for (i = 0; SecProviders[i].pszName != NULL; i++) {
         if (SecProviders[i].fEnabled)  {
             if (SecProviders[i].pCertCtxt == NULL && !IsCredClear(SecProviders[i].hCreds)) {
                // Beta1 Hack. Because of some circular dependency between dlls
                // both crypt32 and schannel's PROCESS_DETACH gets called before wininet.
                // This is catastrophic if we have a cert context attached to the credentials
                // handle. In this case we will just leak the handle since the process is dying
                // anyway. We really need to fix this.
                g_FreeCredentialsHandle(&SecProviders[i].hCreds);
            }
         }
#if 0 // See comments above.
         if (SecProviders[i].pCertCtxt != NULL) {
            CertFreeCertificateContext(SecProviders[i].pCertCtxt);
            SecProviders[i].pCertCtxt = NULL;
        }
#endif

    }

    //
    // close cert store. Protect against fault if DLL already unloaded
    //

    __try {
        if (g_hMyCertStore != NULL) {
            CertCloseStore(g_hMyCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    ENDEXCEPT
    g_hMyCertStore = NULL;
    g_bOpenMyCertStore = FALSE;

    // IMPORTANT : Don't free GlobalFortezzaCryptProv. When we free the cert context
    // from the SecProviders[] array above it gets freed automatically.
    if (GlobalFortezzaCryptProv != NULL)
    {
        GlobalFortezzaCryptProv = NULL;
    }


    //
    // unload dll
    //

    if (hSecurity != NULL) {
        FreeLibrary(hSecurity);
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

}

//  
DWORD
ReopenMyCertStore(
        VOID
        )
{
    DWORD Error = ERROR_SUCCESS;
    LOCK_SECURITY();

    if (g_hMyCertStore == NULL) {

        //
        // CRYPT32.DLL is delayloaded. Need SEH in case it fails
        //

        __try {
            g_hMyCertStore = CertOpenSystemStore(0, "MY");
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Error = GetLastError();
        }
        ENDEXCEPT
    }

    UNLOCK_SECURITY();
    return Error;

}

DWORD
CloseMyCertStore(
	VOID
	)
{
    DWORD Error = ERROR_SUCCESS;

    LOCK_SECURITY();

    //
    // close cert store. Protect against fault if DLL already unloaded
    //

    __try {
        if (g_hMyCertStore != NULL) {
            CertCloseStore(g_hMyCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    ENDEXCEPT
    g_hMyCertStore = NULL;
	
	UNLOCK_SECURITY();
	return Error;
}

DWORD
LoadSecurity(
    VOID
    )
/*++

Routine Description:

    This function dynamically loads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    LOCK_SECURITY();

    if (g_hMyCertStore == NULL) {

        //
        // CRYPT32.DLL is delayloaded. Need SEH in case it fails
        //

        __try {
            g_hMyCertStore = CertOpenSystemStore(0, "MY");
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Error = GetLastError();
        }
        ENDEXCEPT
    }
    if( g_hMyCertStore != NULL)
        g_bOpenMyCertStore = TRUE; 

    if (Error == ERROR_SUCCESS) {
        Error = LoadWinTrust();
    }
    if ( Error != ERROR_SUCCESS )
    {
        goto quit;
    }

    if( hSecurity != NULL )
    {
        goto quit;
    }

        //
        // load dll.
        //

       //
       // This is better for performance. Rather than call through
       //    SSPI, we go right to the DLL doing the work.
       //

       hSecurity = LoadLibrary( "schannel" );

        if ( hSecurity == NULL ) {
            Error = GetLastError();
            goto quit;
        }

        //
        // get function addresses.
        //

#ifdef UNICODE
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceW" );
#else
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceA" );
#endif


        if ( pfInitSecurityInterface == NULL )
        {
             Error = GetLastError();
             goto quit;
        }

    //
    // Get SslCrackCertificate func pointer,
    //  utility function declared in SCHANNEL that
    //  is used for parsing X509 certificates.
    //

        pSslCrackCertificate =
            (SSL_CRACK_CERTIFICATE_FN) GetProcAddress( hSecurity,
                                                     SSL_CRACK_CERTIFICATE_NAME );


    if ( pSslCrackCertificate == NULL )
    {
        Error = GetLastError();
        goto quit;
    }



        pSslFreeCertificate =
            (SSL_FREE_CERTIFICATE_FN) GetProcAddress( hSecurity,
                                                     SSL_FREE_CERTIFICATE_NAME );


    if ( pSslFreeCertificate == NULL )
    {
        Error = GetLastError();
        goto quit;
    }

    GlobalSecFuncTable = (SecurityFunctionTable*) ((*pfInitSecurityInterface) ());

    if ( GlobalSecFuncTable == NULL ) {
         Error = GetLastError(); // BUGBUG does this work?
         goto quit;
    }

    HMODULE hCrypt32;
    hCrypt32 = GetModuleHandle("crypt32");

    INET_ASSERT(hCrypt32 != NULL);

    // We don't error out here because not finding these entry points
    // just affects Fortezza. The rest will still work fine.
    if (hCrypt32)
    {
        if (FALSE == GlobalPlatformVersion5)
        {
            TCHAR rgchCrypt32FileName[MAX_PATH];

            g_fDoSpecialMagicForSGCCerts = FALSE;

            if (GetModuleFileName(hCrypt32, rgchCrypt32FileName, ARRAY_ELEMENTS(rgchCrypt32FileName)) != 0)
            {
                DWORD cbFileVersionBufSize;
                DWORD dwTemp = 0;

                if ((cbFileVersionBufSize = GetFileVersionInfoSize(rgchCrypt32FileName, &dwTemp)) != 0)
                {
                    BYTE* pVerBuffer = NULL;

                    pVerBuffer = (BYTE *) _alloca(cbFileVersionBufSize);
                 
                    if ( (pVerBuffer != NULL) && 
                         (GetFileVersionInfo(rgchCrypt32FileName, 0, cbFileVersionBufSize, pVerBuffer) != 0))
                    {
                        VS_FIXEDFILEINFO *lpVSFixedFileInfo;
                        unsigned uiLength;

                        if( VerQueryValue( pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) != 0
                            && uiLength != 0)
                        {
                            // Crypt32.dll version is 5.131.1877.9 which is the Min version we need.
                            // 0x50083 ==> 5.131
                            // 0x07550009 ==> 1877.9
                            if ((lpVSFixedFileInfo->dwFileVersionMS > 0x50083) 
                                || (lpVSFixedFileInfo->dwFileVersionMS == 0x50083 && lpVSFixedFileInfo->dwFileVersionLS >= 0x07550009))
                                g_fDoSpecialMagicForSGCCerts = TRUE;
                        }
                    }
                }
            }
        }

        g_CryptInstallDefaultContext = (CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_INSTALL_DEFAULT_CONTEXT_NAME);

        g_CryptUninstallDefaultContext = (CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME);

        g_CertFindChainInStore = (CERT_FIND_CHAIN_IN_STORE_FN)
                                    GetProcAddress(hCrypt32, CERT_FIND_CHAIN_IN_STORE_NAME);

        g_CertFreeCertificateChain = (CERT_FREE_CERTIFICATE_CHAIN_FN)
                                    GetProcAddress(hCrypt32, CERT_FREE_CERTIFICATE_CHAIN_NAME);
    }

quit:

    if ( Error != ERROR_SUCCESS )
    {
        FreeLibrary( hSecurity );
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

    return( Error );
}



// Fortezza related functionality.


//Private functions used by the Fortezza implementation.
static PCCERT_CONTEXT GetCurrentFortezzaCertContext();
static BOOL SetCurrentFortezzaCertContext(PCCERT_CONTEXT);
static DWORD AcquireFortezzaCryptProv(HWND, HCRYPTPROV *);
static DWORD ReleaseFortezzaCryptProv(HCRYPTPROV, BOOL);
static DWORD AcquireFortezzaCertContext(HCRYPTPROV, PCCERT_CONTEXT*);


// Should we do anything regarding Fortezza.
BOOL IsFortezzaInstalled ( )
{
    LOCK_FORTEZZA( );

    if (!g_bCheckedForFortezza)
    {
        g_bCheckedForFortezza = TRUE;
        g_bFortezzaInstalled = FALSE;

        // Try and get the Fortezza CSP context to see if it is present.
        HCRYPTPROV hCryptProv = NULL;
        if (GlobalEnableFortezza)
        {
            if (CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_FORTEZZA, CRYPT_SILENT))
            {
                // Weird: we should not be allowed to get the context without putting up UI.
                // But we will assume Fortezza is enabled.
                g_bFortezzaInstalled = TRUE;
                CryptReleaseContext(hCryptProv, 0);
            }
            else
            {
                DWORD dwError = GetLastError();

                // If the last error was NTE_PROV_TYPE_NOT_DEF it means that Fortezza CSP is not
                // installed and we should not be trying to get a Fortezza context.
                g_bFortezzaInstalled = ((dwError != NTE_PROV_TYPE_NOT_DEF) && (dwError != NTE_PROV_TYPE_NO_MATCH));

            }
        }
    }

    UNLOCK_FORTEZZA( );

    return g_bFortezzaInstalled;
}


BOOL AttemptedFortezzaLogin( )
{
    BOOL bRet ;

    LOCK_FORTEZZA();
    bRet = g_bAttemptedFortezzaLogin;
    UNLOCK_FORTEZZA();

    return bRet;
}


// Log's on to the fortezza card. Returns success if you are already logged on.  
DWORD FortezzaLogOn(HWND hwnd)
{
    DWORD dwError;
    LOCK_FORTEZZA();

    // If we are already logged on, don't bother. Just succeed.
    if (GetCurrentFortezzaCertContext() != NULL)
    {
        INET_ASSERT(g_bAttemptedFortezzaLogin);
        INET_ASSERT(GlobalFortezzaCryptProv);
        dwError = ERROR_SUCCESS;
    }
    else
    {
        HCRYPTPROV hProv;
        g_bAttemptedFortezzaLogin = TRUE;

        INET_ASSERT(GlobalFortezzaCryptProv == NULL);

        dwError = AcquireFortezzaCryptProv(hwnd, &GlobalFortezzaCryptProv);

        if (dwError == ERROR_SUCCESS)
        {
            INET_ASSERT(GlobalFortezzaCryptProv != NULL);
            PCCERT_CONTEXT pCertContext = NULL;
            
            dwError = AcquireFortezzaCertContext(GlobalFortezzaCryptProv, &pCertContext);

            if (dwError == ERROR_SUCCESS)
            {
                //Logged in succesfully.
                SetCurrentFortezzaCertContext(pCertContext);
            }
        }
    
        if (dwError != ERROR_SUCCESS && GlobalFortezzaCryptProv != NULL)    
        {
            ReleaseFortezzaCryptProv(GlobalFortezzaCryptProv, FALSE);
            GlobalFortezzaCryptProv = NULL;
        }
        
    }

    if (dwError == ERROR_SUCCESS)
    {
        INET_ASSERT(GetCurrentFortezzaCertContext());
        INET_ASSERT(GlobalFortezzaCryptProv != NULL);
    } 
                   
    UNLOCK_FORTEZZA( );
    
    return dwError;                  

}


DWORD FortezzaLogOff(HWND /* hwnd */)
{
    LOCK_FORTEZZA();

    BOOL bGotCertContext = (GetCurrentFortezzaCertContext() != NULL);
    SetCurrentFortezzaCertContext(NULL);
    ReleaseFortezzaCryptProv(GlobalFortezzaCryptProv, bGotCertContext);
    GlobalFortezzaCryptProv = NULL;

    UNLOCK_FORTEZZA( );

    return ERROR_SUCCESS;
}


DWORD FortezzaChangePersonality(HWND hwnd)
{
    DWORD dwError = ERROR_SUCCESS;

    LOCK_FORTEZZA( );
    
    PCCERT_CONTEXT pOldCertContext = GetCurrentFortezzaCertContext( );
    
    if (pOldCertContext != NULL)
    {
        INET_ASSERT(GlobalFortezzaCryptProv != NULL);
        HCRYPTPROV hNewCryptProv = NULL;
        PCCERT_CONTEXT pNewCertContext = NULL;
        
        // For the change personality to work we need to get a new handle to a 
        // Fortezza crypt provider without freeing the old one. ,
        // If we free the old one first it will re-prompt the user for the password.

        dwError = AcquireFortezzaCryptProv(hwnd, &hNewCryptProv);
        if (dwError == ERROR_SUCCESS)
        {
            dwError = AcquireFortezzaCertContext(hNewCryptProv, &pNewCertContext);

            if (dwError == ERROR_SUCCESS)
            {
                // free up the old CryptProv context
                ReleaseFortezzaCryptProv(GlobalFortezzaCryptProv, TRUE);
                GlobalFortezzaCryptProv = hNewCryptProv;
                // This will automatically free the old cert context.
                SetCurrentFortezzaCertContext(pNewCertContext);
            }
            else 
            {
                ReleaseFortezzaCryptProv(hNewCryptProv, FALSE);
            }
        }
    }
    else
    {
        // We are trying to change personalities when not logged on.
        // This is not allowed.                         

        dwError = ERROR_INVALID_PARAMETER;
    }

    UNLOCK_FORTEZZA( );
    
    return dwError;
}


// Entry points exported outside wininet.
INTERNETAPI_(BOOL) InternetQueryFortezzaStatus(DWORD * pdwStatus, DWORD_PTR dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryFortezzaStatus",
                     "%#x %#x",
                     pdwStatus, dwReserved
                     ));

    BOOL bRet;
    DWORD dwError = ERROR_SUCCESS;

    // Initialize the GlobalData since this is an exported entry point.
    if (dwReserved!=0)
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    else if (!GlobalDataInitialized)
    {
        dwError = GlobalDataInitialize( );
    }
    
    if (dwError != ERROR_SUCCESS)
    {
        bRet = FALSE;
    }
    else if (pdwStatus == NULL)
    {
        bRet = FALSE;
        dwError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if (IsFortezzaInstalled( ))
        {
            *pdwStatus |= (FORTSTAT_INSTALLED);
        }
        
        if (GetCurrentFortezzaCertContext() != NULL)
        {
            *pdwStatus |= (FORTSTAT_LOGGEDON);
        }
        bRet = TRUE;
    }

    if (!bRet)
    {
        SetLastError(dwError);
        DEBUG_ERROR(INET, dwError);
    }
    DEBUG_LEAVE_API(bRet);
    return bRet;
}
                        

INTERNETAPI_(BOOL) InternetFortezzaCommand(DWORD dwCommand, HWND hwnd, DWORD_PTR dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetFortezzaCommand",
                     "%d, %#x, %#x",
                     dwCommand, hwnd, dwReserved
                     ));

    BOOL bRet = TRUE;
    DWORD dwError = ERROR_SUCCESS;

    // Initialize the GlobalData since this is an exported entry point.
    if (dwReserved!=0)
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    else if (!GlobalDataInitialized)
    {
        dwError = GlobalDataInitialize( );
    }
    
    // Next make sure that the security dlls are loaded.
    if (dwError == ERROR_SUCCESS)
        dwError = LoadSecurity( );

    // If all is fine, then try the actual command.
    if (dwError == ERROR_SUCCESS)
    {
        // Dispatch based on the command.
        switch (dwCommand) 
        {
            case FORTCMD_LOGON:
                dwError = FortezzaLogOn(hwnd);
                break;
            case FORTCMD_LOGOFF:
                dwError = FortezzaLogOff(hwnd);
                break;
            case FORTCMD_CHG_PERSONALITY:
                dwError = FortezzaChangePersonality(hwnd);
                break;
            default:
                dwError = ERROR_INVALID_PARAMETER;
        }
    }            

    if (dwError != ERROR_SUCCESS)
    {
        bRet = FALSE;
        DEBUG_ERROR(INET, dwError);
        SetLastError(dwError);
    }
    else
    {
        LOCK_SECURITY( );

        // If we were successful to this point we should re-init the security packages so 
        // we acquire a credentials handle with the new cert context selected correctly.

        // The Last error will be set by SecurityPkgInitialize if it fails.
        bRet = SecurityPkgInitialize(TRUE);

        UNLOCK_SECURITY( );
    }

    DEBUG_LEAVE_API(bRet);
    return bRet;
}



/*++
    Gets the cert context being used for Fortezza connections.
    
Routine description
    
Returns:

    pCertContext if one is in use. NULL otherwise.
*/            
    
PCCERT_CONTEXT GetCurrentFortezzaCertContext()
{
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwIndex;

    LOCK_FORTEZZA( );

    // Find the unified service provider entry.
    for ( dwIndex = 0 ; SecProviders[dwIndex].pszName != NULL ; dwIndex++ )
    {
        if (0 == stricmp(UNISP_NAME, SecProviders[dwIndex].pszName))
        {
            pCertContext = SecProviders[dwIndex].pCertCtxt ;

            break;
        }
    }
    // Something is wrong if we didn't find the Unified Service provider in our list.

    INET_ASSERT(SecProviders[dwIndex].pszName != NULL);

    UNLOCK_FORTEZZA( );
    
    return pCertContext;
}

               
/*++
    Sets the passed in cert context to be the one that is used for Fortezza 
    connections.
    
Routine description
    This function simply takes a Fortezza context and remembers it on the unified 
    secure providers table. 
    
Arguments:

    pCertContext - The cert context to be saved away.
*/            

BOOL SetCurrentFortezzaCertContext(PCCERT_CONTEXT pCertContext)
{
    DWORD dwIndex;

    LOCK_FORTEZZA( );

    // Find the unified service provider entry.
    for ( dwIndex = 0 ; SecProviders[dwIndex].pszName != NULL ; dwIndex++ )
    {
        if (0 == stricmp(UNISP_NAME, SecProviders[dwIndex].pszName))
        {
            if (SecProviders[dwIndex].pCertCtxt)
                CertFreeCertificateContext(SecProviders[dwIndex].pCertCtxt);

            SecProviders[dwIndex].pCertCtxt = pCertContext;

            break;
        }
    }
    
    // Something is wrong if we didn't find the Unified Service provider in our list.

    INET_ASSERT(SecProviders[dwIndex].pszName != NULL);

    UNLOCK_FORTEZZA( );

    return TRUE;
}



/*++
    Acquire a fortezza crypt provider.

Routine Description
    This function calls the Fortezza CSP which might prompt the end-user for 
    the PIN # to read the certificates of the Fortezza card. If the user is 
    already logged on to the card the logon UI will not be shown. 

Arguments:

    hwnd - used to put up the pin UI.

    pCryptProv - returns a handle to a crypt provider if succesful.

Return Value:
    
    WINDOWS Error Code.

--*/
DWORD AcquireFortezzaCryptProv(HWND hwnd, HCRYPTPROV *pCryptProv)
{
    DWORD dwError = NOERROR;
    BOOL bResethwnd = FALSE;

    if (pCryptProv == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Set up to do the UI.

    if ( CryptSetProvParam(NULL, PP_CLIENT_HWND, (BYTE *)&hwnd, 0))
    {
        bResethwnd = TRUE;
    }

    //
    // Attempt to log on to Fortezza card. This call will typically
    // display a dialog box.
    //
    // Note that within the CryptAcquireContext function, the Fortezza
    // CSP populated the MY store with the Fortezza certificate chain.
    // At least, it will once it's finished.
    //

    if(!CryptAcquireContext(pCryptProv, NULL, NULL, PROV_FORTEZZA, 0))
    {
        dwError = GetLastError();
    }

    if (bResethwnd)
    {
        CryptSetProvParam(NULL, PP_CLIENT_HWND, NULL, 0);
    }

    return(dwError);
}        


/*++
    Releases the Fortezza Crypt Provider

Routine Description:
    Frees the crypt provider if the second argument is FALSE. 
    Does nothing if the second argument is TRUE.
    The crypto API has this strange behavior ( i am being gracious 
    in my description here) where when a hCryptProv is passed into 
    CertSetCertificateContextProperty it holds on to the pointer but does not increment the 
    refcount. When the cert context is freed it does free the hCryptProv. 
    To workaround this behavior we never free the hCryptProv, just the Fortezza cert context.

Arguments:
    hCryptProv - The CryptProv to free.
    bGotCertContext - did we get a Fortezza Cert Context using this provider. 
**/

DWORD ReleaseFortezzaCryptProv(HCRYPTPROV hCryptProv, BOOL bGotCertContext )
{
    DWORD dwError;

    if (hCryptProv==NULL)
    {
        dwError = NOERROR;
    }
    else
    {
        if (!CryptReleaseContext(hCryptProv, 0))
            dwError = GetLastError();
        else
            dwError = NOERROR;
    }

    return dwError;
}
        


DWORD AcquireFortezzaCertContext(HCRYPTPROV hFortezzaCryptProv, PCCERT_CONTEXT *ppCertContext)                                               
/*++

Routine Description:

    This function calls the Fortezza CSP which will prompt the
    user for the PIN # to read the certificates off the Fortezza
    card.

Arguments:

    [IN]    hCryptProv - Handle to the Fortezza Crypt Provider.
    [OUT]   ppCertContext - will have the cert context if returns succesfully.
Return Value:

    WINDOWS Error Code.

--*/
{
    DWORD error = ERROR_SUCCESS;   // Return code.
    DWORD status = ERROR_SUCCESS;  // Error value if one of the crypto APIs failed.
    CRYPT_HASH_BLOB HashBlob;
    BYTE            rgbHash[20];
    DWORD           cbHash;
    PBYTE           pbChain = NULL;
    DWORD           cbChain;
    PBYTE           pbCert;
    DWORD           cbCert;
    PCCERT_CONTEXT  pCertContext = NULL;
    BOOL            bResethwnd = FALSE;
    DWORD           dwIndex;

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AcquireFortezzaContext",
                 "%#x",
                 hFortezzaCryptProv
                 ));

    if (hFortezzaCryptProv == NULL || ppCertContext == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    LOCK_FORTEZZA();

    if (!IsFortezzaInstalled( ))
    {
        INET_ASSERT(FALSE); // Should not get called if Fortezza is not installed.
        goto done;       // Just ignore the request.
    }


    if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
        ReopenMyCertStore();

    if(g_hMyCertStore == NULL)
    {
        status = SEC_E_NO_CREDENTIALS;
        goto done;
    }

    //
    // Read the appropriate leaf certificate from the card, and
    // obtain its MD5 thumbprint.
    //

    // Get length of certificate chain.
    if(!CryptGetProvParam(hFortezzaCryptProv, PP_CERTCHAIN, NULL, &cbChain, 0))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x reading certificate from CSP\n",
                    status
                    ));
        goto done;
    }

    // Allocate memory for certificate chain.
    pbChain = (BYTE *)ALLOCATE_MEMORY(LMEM_FIXED | LMEM_ZEROINIT, cbChain);
    if(pbChain == NULL)
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Out of memory\n"));
        goto done;
    }

    // Download certificate chain from CSP.
    if(!CryptGetProvParam(hFortezzaCryptProv, PP_CERTCHAIN, pbChain, &cbChain, 0))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x reading certificate from CSP\n",
                    status
                    ));
        goto done;
    }

    // Parse out the leaf certificate.
    cbCert = *(PDWORD)pbChain;
    pbCert = pbChain + sizeof(DWORD);

    // Decode the leaf certificate.
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                pbCert,
                                                cbCert);
    if(pCertContext == NULL)
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x parsing certificate\n",
                    status
                    ));
        goto done;
    }

    // Get thumbprint of certificate.
    cbHash = sizeof(rgbHash);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_MD5_HASH_PROP_ID,
                                          rgbHash,
                                          &cbHash))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x reading MD5 property\n",
                    status
                    ));
        goto done;
    }

    // Free certificate chain.
    FREE_MEMORY(pbChain);
    pbChain = NULL;

    // Free certificate context.
    CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;


    //
    // Search the "MY" certificate store for the certificate with
    // the matching thumbprint.
    //

    HashBlob.cbData = cbHash;
    HashBlob.pbData = rgbHash;
    if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
        ReopenMyCertStore();
    pCertContext = CertFindCertificateInStore(g_hMyCertStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_MD5_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Leaf certificate not found in MY store\n"));

        status = SEC_E_NO_CREDENTIALS;
        goto done;
    }


    //
    // Attach the Fortezza hProv to the certificate context.
    //

    if(!CertSetCertificateContextProperty(
            pCertContext,
            CERT_KEY_PROV_HANDLE_PROP_ID,
            0,
            (PVOID)hFortezzaCryptProv))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x setting KEY_PROV_HANDLE property\n",
                    status
                    ));
        goto done;
    }


    INET_ASSERT(pCertContext != NULL);

    *ppCertContext = pCertContext;
    pCertContext = NULL;

    status = SEC_E_OK;

done:

    if(pbChain) FREE_MEMORY(pbChain);
    if(pCertContext) CertFreeCertificateContext(pCertContext);

    UNLOCK_FORTEZZA();
    DEBUG_LEAVE(error);
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\parsers.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.cxx

Abstract:

    Common text parsing functions (generally moved here from other protocols)

    Contents:
        ExtractWord
        ExtractDword
        ExtractInt
        SkipWhitespace
        SkipSpaces
        SkipLine
        FindToken
        NiceNum

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned short
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    WORD number;
    BOOL exact;
    LPSTR string;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("65535") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    number = 0;
    string = *pString;
    while (NumberLength && isdigit(*string)) {
        number = number * 10 + (WORD)((BYTE)(*string++) - (BYTE)'0');
        --NumberLength;
    }
    *pConvertedNumber = number;
    *pString = string;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned long
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    DWORD number;
    BOOL exact;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("4294967295") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength--; ) {
        number = number * 10 + (DWORD)((BYTE)*((*pString)++) - (BYTE)'0');
    }
    *pConvertedNumber = number;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an signed integer (32-bits)

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    int number;
    int sign;
    BOOL exact;

    if ((**pString == '-') || (**pString == '+')) {
        sign = (**pString == '-') ? -1 : +1;
        if (NumberLength) {
            --NumberLength;
        }
        ++*pString;
    } else {
        sign = 1;
    }

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("2147483647") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength; ) {
        number = number * 10 + (INT)(((BYTE)**pString) - (BYTE)'0');
        ++*pString;
        --NumberLength;
    }
    *pConvertedNumber = number * sign;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any whitespace characters

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any space characters. We only look for the actual space character

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer == ' ')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Positions text pointer at start of next non-empty line

Arguments:

    lpBuffer        - pointer to string. Updated on output

    lpBufferLength  - pointer to remaining length of string. Updated on output

Return Value:

    BOOL
        TRUE    - found start of next non-empty line

        FALSE   - ran out of buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer != '\r') && (**lpBuffer != '\n')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && ((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


#undef  isspace
#define isspace(ch) ((ch==0x20) || ((ch >= 0x09) && (ch <= 0x0d)))

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Moves over the current token, past any spaces, and to the start of the next
    token

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && !isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    )

/*++

Routine Description:

    Converts a number to a string. The string is very human-sensible (i.e.
    1,234,567 instead of 1234567. Sometimes its hard to make out these numbers
    when your salary is so large)

Arguments:

    Buffer      - place to put resultant string

    Number      - to convert

    FieldWidth  - maximum width of the field, or 0 for "don't care"

Return Value:

    LPSTR
        pointer to Buffer

--*/

{
    int i;

    if (Number == 0) {
        if (FieldWidth == 0) {
            Buffer[0] = '0';
            Buffer[1] = '\0';
        } else {
            memset(Buffer, ' ', FieldWidth);
            Buffer[FieldWidth - 1] = '0';
            Buffer[FieldWidth] = '\0';
        }
    } else {

        //
        // if the caller specified zero for the field width then work out how
        // many characters the string will occupy
        //

        if (FieldWidth == 0) {

            SIZE_T n;

            n = Number;
            ++FieldWidth;
            while (n >= 10) {
                n /= 10;
                ++FieldWidth;
            }

            FieldWidth += (FieldWidth / 3) - (((FieldWidth % 3) == 0) ? 1 : 0);
        }

        //
        // now create the representation
        //

        Buffer[FieldWidth] = '\0';
        Buffer += FieldWidth;
        i = 0;
        while (Number && FieldWidth) {
            *--Buffer = (char)((Number % 10) + '0');
            --FieldWidth;
            Number /= 10;
            if ((++i == 3) && FieldWidth) {
                if (Number) {
                    *--Buffer = ',';
                    --FieldWidth;
                    i = 0;
                }
            }
        }
        while (FieldWidth--) {
            *--Buffer = ' ';
        }
    }
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains function to return number of open handles owned by this process

    Contents:
        InternetHandleCount

Author:

    Richard L Firth (rfirth) 02-May-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private types
//

typedef (*NT_QUERY_SYSTEM_INFORMATION)(ULONG, PVOID, ULONG, PULONG);

//
// functions
//


DWORD
InternetHandleCount(
    VOID
    )

/*++

Routine Description:

    Gets the number of system handles owned by this process. We LoadLibrary()
    NTDLL.DLL so that the debug version of this DLL still works on Win95

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    static HINSTANCE hNtdll = NULL;
    static NT_QUERY_SYSTEM_INFORMATION _NtQuerySystemInformation;

    if (IsPlatformWin95()) {
        return 0;
    }

    if (hNtdll == NULL) {
        hNtdll = LoadLibrary("ntdll");
        if (hNtdll == NULL) {
            return 0;
        }
        _NtQuerySystemInformation = (NT_QUERY_SYSTEM_INFORMATION)GetProcAddress(hNtdll, "NtQuerySystemInformation");
        if (_NtQuerySystemInformation == 0) {
            FreeLibrary(hNtdll);
            hNtdll = NULL;
        }
    }

    if (_NtQuerySystemInformation) {

        DWORD idProcess;
        NTSTATUS status;
        ULONG outputLength;
        BYTE buffer[32768];
        PSYSTEM_PROCESS_INFORMATION info;

        status = _NtQuerySystemInformation(SystemProcessInformation,
                                           (PVOID)buffer,
                                           sizeof(buffer),
                                           &outputLength
                                           );
        if (!NT_SUCCESS(status)) {
            return 0;
        }
        info = (PSYSTEM_PROCESS_INFORMATION)buffer;
        idProcess = GetCurrentProcessId();
        while (TRUE) {
            if ((DWORD_PTR)info->UniqueProcessId == idProcess) {
                return info->HandleCount;
            }
            if (info->NextEntryOffset == 0) {
                return 0;
            }
            info = (PSYSTEM_PROCESS_INFORMATION)((PCHAR)info + info->NextEntryOffset);
        }
    }
    return 0;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\servinfo.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    servinfo.cxx

Abstract:

    Class implementation for global server info list

    Contents:
        GetServerInfo
        FindServerInfo
        FindNearestServer
        ReleaseServerInfo
        PurgeServerInfoList
        PingServerInfoList
        LoadServerInfoDatabase
        SaveServerInfoDatabase
        CServerInfo::CServerInfo
        CServerInfo::~CServerInfo
        CServerInfo::Reference
        CServerInfo::Dereference
        CServerInfo::ResolveHostName
        CServerInfo::UpdateConnectTime
        CServerInfo::UpdateRTT
        CServerInfo::UpdateDownloadRate
        CServerInfo::UpdateUploadRate
        CServerInfo::GetConnection
        CFsm_GetConnection::RunSM
        CServerInfo::GetConnection_Fsm
        CServerInfo::ReleaseConnection
        CServerInfo::RemoveWaiter
        (CServerInfo::FindKeepAliveConnection)
        (CServerInfo::KeepAliveWaiters)
        (CServerInfo::RunOutOfConnections)
        (CServerInfo::UpdateConnectionLimit)
        CServerInfo::PurgeKeepAlives
        ContainingServerInfo

Author:

    Richard L Firth (rfirth) 07-Oct-1996

Revision History:

    07-Oct-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private macros
//

//#define CHECK_CONNECTION_COUNT() \
//    INET_ASSERT(!UnlimitedConnections() \
//        ? (TotalAvailableConnections() <= ConnectionLimit()) : TRUE)

#define CHECK_CONNECTION_COUNT()    /* NOTHING */

//#define RLF_DEBUG   1

#if INET_DEBUG
#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif
#else
#define DPRINTF (void)
#endif

//
// functions
//


DWORD
GetServerInfo(
    IN LPSTR lpszHostName,
    IN DWORD dwServiceType,
    IN BOOL bDoResolution,
    OUT CServerInfo * * lplpServerInfo
    )

/*++

Routine Description:

    Finds or creates a CServerInfo entry

Arguments:

    lpszHostName    - pointer to server name to get info for

    dwServiceType   - type of service for which CServerInfo requested

    bDoResolution   - TRUE if we are to resolve host name

    lplpServerInfo  - pointer to created/found CServerInfo if successful

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create the CServerInfo

                  ERROR_INTERNET_NAME_NOT_RESOLVED
                    We were asked to resolve the name, but failed

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "GetServerInfo",
                 "%q, %s (%d), %B, %#x",
                 lpszHostName,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 bDoResolution,
                 lplpServerInfo
                 ));

    ICSTRING hostName(lpszHostName);
    CServerInfo * lpServerInfo;
    BOOL bCreated = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hostName.HaveString()) {
        hostName.MakeLowerCase();

        LPSTR lpszHostNameLower = hostName.StringAddress();

        LockSerializedList(&GlobalServerInfoList);

        lpServerInfo = FindServerInfo(lpszHostNameLower);

        if (lpServerInfo == NULL) {
            lpServerInfo = new CServerInfo(lpszHostNameLower,
                                           &error,
                                           dwServiceType
                                           );
            if (lpServerInfo != NULL) {
                if (error != ERROR_SUCCESS) {
                    delete lpServerInfo;
                    lpServerInfo = NULL;
                }
                else {
                    bCreated = TRUE;
                    // Reference this to keep it alive beyond the unlock/
                    lpServerInfo->Reference();
                }
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        UnlockSerializedList(&GlobalServerInfoList);
    } else {

        //
        // failed to create ICSTRING
        //

        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        lpServerInfo = NULL;
    }

    //
    // if we created a new CServerInfo and we are instructed to resolve the host
    // name then do it now, outside of the global server info list lock. This
    // operation may take some time
    //

    if (bDoResolution && (lpServerInfo != NULL)) {
        //error = lpServerInfo->ResolveHostName();
        if (error != ERROR_SUCCESS) {
            ReleaseServerInfo(lpServerInfo);
            lpServerInfo = NULL;
        }
    }

    *lplpServerInfo = lpServerInfo;

    DEBUG_LEAVE(error);

    return error;
}


CServerInfo *
FindServerInfo(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Walks the server info list looking for the requested server

Arguments:

    lpszHostName    - pointer to server name to find (IN LOWER CASE!)

Return Value:

    CServerInfo *
        Success - pointer to found list entry

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindServerInfo",
                 "%q",
                 lpszHostName
                 ));

    DWORD hashHostName = CalculateHashValue(lpszHostName);

    CServerInfo * lpServerInfo;
    BOOL found = FALSE;

    LockSerializedList(&GlobalServerInfoList);

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->Match(hashHostName, lpszHostName)) {
            found = TRUE;
            break;
        }
    }

    if (!found) 
    {
        lpServerInfo = NULL;
    }

    // Need to keep this alive beyond the lock.
    if (lpServerInfo)
    {
        lpServerInfo->Reference();
    }
    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(lpServerInfo);
    return lpServerInfo;
}


CServerInfo *
FindNearestServer(
    VOID
    )

/*++

Routine Description:

    Returns pointer to the CServerInfo which has the shortest connect time.
    Returned info is referenced, so caller must call ReleaseServerInfo() when
    done

Arguments:

    None.

Return Value:

    CServerInfo *
        Success - valid pointer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindNearestServer",
                 NULL
                 ));

    CServerInfo * lpServerInfo;
    CServerInfo * lpsiResult = NULL;
    DWORD connectTime = (DWORD)-1;

    LockSerializedList(&GlobalServerInfoList);

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->GetConnectTime() < connectTime) {
            lpsiResult = lpServerInfo;
            connectTime = lpServerInfo->GetConnectTime();
        }
    }

    // We used to reference this in the caller, which is a bad idea, since it 
    // can get deleted between unlocking the serialized list and getting to the addref.
    if(lpsiResult) 
    {
        lpsiResult->Reference();
    }

    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(lpsiResult);

    return lpsiResult;
}


VOID
ReleaseServerInfo(
    IN CServerInfo * lpServerInfo
    )

/*++

Routine Description:

    Release a CServerInfo by dereferencing it. If the reference count goes to
    zero, the CServerInfo will be destroyed

Arguments:

    lpServerInfo    - pointer to CServerInfo to release

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "ReleaseServerInfo",
                 "%#x [%q]",
                 lpServerInfo,
                 lpServerInfo->GetHostName()
                 ));

    lpServerInfo->Dereference();

    DEBUG_LEAVE(0);
}


VOID
PurgeServerInfoList(
    IN BOOL bForce
    )

/*++

Routine Description:

    Throw out any CServerInfo entries that have expired or any KEEP_ALIVE
    entries (for any CServerInfo) that have expired

Arguments:

    bForce  - TRUE if we forcibly remove entries which have not yet expired but
              which have a reference count of 1, else FALSE to remove only
              entries that have expired

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeServerInfoList",
                 "%B",
                 bForce
                 ));

    BOOL bActivate = FALSE;
    
    LockSerializedList(&GlobalServerInfoList);

    PLIST_ENTRY pEntry = HeadOfSerializedList(&GlobalServerInfoList);
    PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&GlobalServerInfoList);

    while (TRUE) {
        if (pEntry == (PLIST_ENTRY)SlSelf(&GlobalServerInfoList)) {
            break;
        }

        CServerInfo * pServerInfo;

        //pServerInfo = (CServerInfo *)pEntry;
        //pServerInfo = CONTAINING_RECORD(pEntry, CONNECTION_LIMIT, m_List);
        pServerInfo = ContainingServerInfo(pEntry);

        BOOL deleted = FALSE;

        if (pServerInfo->ReferenceCount() == 1) {
            if (bForce || pServerInfo->Expired()) {
//dprintf("purging server info entry for %q\n", pServerInfo->GetHostName());
                deleted = pServerInfo->Dereference();
            } else {
                pServerInfo->PurgeKeepAlives(PKA_NO_FORCE);
                bActivate = TRUE;
            }
        }
        if (!deleted) {
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    UnlockSerializedList(&GlobalServerInfoList);

    if (bActivate && g_bHibernating)
    {
        InterruptSelect();
    }

    DEBUG_LEAVE(0);
}


VOID
PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Throw out any KEEP_ALIVE entries from any CServerInfo that have expired or
    which have failed authentication or which are unused, depending on dwForce

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeKeepAlives",
                 "%s [%d]",
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    LockSerializedList(&GlobalServerInfoList);

    PLIST_ENTRY pEntry = HeadOfSerializedList(&GlobalServerInfoList);

    while (pEntry != (PLIST_ENTRY)SlSelf(&GlobalServerInfoList)) {

        CServerInfo * lpServerInfo = ContainingServerInfo(pEntry);

        lpServerInfo->PurgeKeepAlives(dwForce);
        pEntry = pEntry->Flink;
    }

    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(0);
}

//
//DWORD
//PingServerInfoList(
//    OUT LPBOOL lpbUnreachable
//    )
//
///*++
//
//Routine Description:
//
//    Determines online/offline state by attempting to ping a known server address.
//    If any ping succeeds, this function succeeds. If all pings fail, then this
//    function fails
//
//    Assumes:    1. global ping object has been instantiated
//
//Arguments:
//
//    lpbUnreachable  - TRUE if one or more servers were unreachable (the network
//                      seems to be alive, just that we couldn't reach one or more
//                      servers. Useful to indicate that an address we are in the
//                      process of resolving is bad
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//                    at least one address pinged
//
//        Failure - ERROR_INTERNET_NO_KNOWN_SERVERS (internal)
//                    There are no known server addresses (there may be items in
//                    the list, but the addresses are not yet resolved)
//
//                  ERROR_INTERNET_PING_FAILED (internal)
//                    We have (resolved) addresses, but couldn't successfully ping
//                    any. We believe we have connectivity
//
//                  ERROR_INTERNET_NO_PING_SUPPORT (internal)
//                    We couldn't ping any addresses because ping support is not
//                    loaded, or globally disabled
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "PingServerInfoList",
//                 "%#x",
//                 lpbUnreachable
//                 ));
//
//    DWORD error;
//
//    *lpbUnreachable = FALSE;
//
//    CServerInfo * lpServerInfo;
//
//    error = ERROR_INTERNET_NO_KNOWN_SERVERS;
//
//    LockSerializedList(&GlobalServerInfoList);
//
//    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
//        lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
//        lpServerInfo = lpServerInfo->Next()) {
//
//        DWORD err;
//        DWORD dwIpAddress;
//        DWORD addressLength = sizeof(dwIpAddress);
//
//        //
//        // just use first address from each address list
//        //
//
//        err = DestinationAddressFromAddressList(lpServerInfo->GetAddressList(),
//                                                0,
//                                                (LPBYTE)&dwIpAddress,
//                                                &addressLength
//                                                );
//
//        INET_ASSERT(IS_VALID_NON_LOOPBACK_IP_ADDRESS(dwIpAddress));
//
//        if ((err == ERROR_SUCCESS)
//        && IS_VALID_NON_LOOPBACK_IP_ADDRESS(dwIpAddress)) {
//            error = Ping(dwIpAddress);
//            if (error == ERROR_SUCCESS) {
//
//                //
//                // ping succeeded, net is alive. All we need to know for now
//                //
//
//                lpServerInfo->SetReachable();
//                break;
//            } else if (error == ERROR_INTERNET_SERVER_UNREACHABLE) {
//
//                //
//                // our equivalent of net unreachable
//                //
//
//                lpServerInfo->SetUnreachable();
//                *lpbUnreachable = TRUE;
//
//                //
//                // although the server is unreachable, we still have
//                // connectivity (the ping would have failed completely
//                // otherwise)
//                //
//
//                error = ERROR_SUCCESS;
//            } else if (error == ERROR_INTERNET_NO_PING_SUPPORT) {
//
//                //
//                // can't ping - no ping support. quit
//                //
//
//                break;
//            }
//        }
//    }
//
//    UnlockSerializedList(&GlobalServerInfoList);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//LoadServerInfoDatabase(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Populates the server info database from the registry. This allows us to
//    avoid server capability negotiation each time we start IE/Wininet
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    return ERROR_SUCCESS;
//}
//
//
//DWORD
//SaveServerInfoDatabase(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Copies the contents of the current server info database to the registry.
//    This information is read the next time we start IE/Wininet
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    return ERROR_SUCCESS;
//}

//
// methods
//


CServerInfo::CServerInfo(
    IN LPSTR lpszHostName,
    OUT LPDWORD pdwError,
    IN DWORD dwService,
    IN DWORD dwMaxConnections
    )

/*++

Routine Description:

    CServerInfo constructor

Arguments:

    lpszHostName        - server for which to create CServerInfo

    pdwError            - return status in case a failure occurs during init

    dwService           - which service to create CServerInfo for

    dwMaxConnections    - maximum number of simultaneous connections to this
                          server

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::CServerInfo",
                 "%q, %s (%d), %d",
                 lpszHostName,
                 InternetMapService(dwService),
                 dwService,
                 dwMaxConnections
                 ));

    INIT_SERVER_INFO();

    //GlobalServerInfoAllocCount++;
    *pdwError = ERROR_SUCCESS;

    InitializeListHead(&m_List);
    m_Expires = 0;
    m_Wrap = 0;
    m_ReferenceCount = 1;
    m_HostName = lpszHostName;
    if (!m_HostName.StringAddress())
    {
        *pdwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    m_HostName.MakeLowerCase();
    m_Hash = CalculateHashValue(m_HostName.StringAddress());
    m_Services.Word = 0;
    m_HttpSupport.Word = 0;
    m_Flags.Word = 0;
    m_ProxyLink = NULL;

    switch (dwService) {
    case INTERNET_SERVICE_HTTP:
        SetHTTP();
        break;

    case INTERNET_SERVICE_FTP:
        SetFTP();
        break;

    case INTERNET_SERVICE_GOPHER:
        SetGopher();
        break;

    default:

        INET_ASSERT(FALSE);

    }

    //
    // only initialize the keep-alive and connection limit lists if we are
    // creating the server info entry for a HTTP server (or CERN proxy)
    //

    //
    // BUGBUG - we only want to do this on demand
    //

    //if (IsHTTP()) {
        InitializeSerializedList(&m_KeepAliveList);
        InitializeSerializedList(&m_PipelinedList);
        //InitializeSerializedList(&m_Waiters);
        SetKeepAliveListInitialized();

        //
        // the maximum number of connections per server is initialized to the
        // default (registry) value unless overridden by the caller
        //

if (dwMaxConnections == 0) {
    dwMaxConnections = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
}
        m_ConnectionLimit = dwMaxConnections;
    //} else {
    //    m_ConnectionLimit = UNLIMITED_CONNECTIONS;
    //}
//dprintf("*** %s: limit = %d\n", GetHostName(), m_ConnectionLimit);
    //
    // BUGBUG - only create event if limiting connections. Need method to manage
    //          connection limit count/event creation
    //

    m_NewLimit = m_ConnectionLimit;
    m_ConnectionsAvailable = m_ConnectionLimit;
    //m_ActiveConnections = 0;
    m_LastActiveTime = 0;
    m_ConnectTime = (DWORD)-1;
    m_RTT = 0;
    m_DownloadRate = 0;
    m_UploadRate = 0;
    m_dwError = ERROR_SUCCESS;

    //
    // add to the global list. We are assuming here that the caller has already
    // checked for dupes
    //

    InsertAtHeadOfSerializedList(&GlobalServerInfoList, &m_List);

quit:
    DEBUG_LEAVE(0);
}


CServerInfo::~CServerInfo()

/*++

Routine Description:

    CServerInfo destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::~CServerInfo",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();

    //GlobalServerInfoDeAllocCount++;

    // unlink if we have a nested obj
    if ( m_ProxyLink ) {
        CServerInfo *pDerefObj;

        LockSerializedList(&GlobalServerInfoList);        
        pDerefObj = m_ProxyLink;
        m_ProxyLink = NULL;
        UnlockSerializedList(&GlobalServerInfoList);        

        if (pDerefObj) {
            pDerefObj->Dereference();
        }
    }


    RemoveFromSerializedList(&GlobalServerInfoList, &m_List);

    INET_ASSERT(m_ReferenceCount == 0);

    if (IsKeepAliveListInitialized()) {
        LockSerializedList(&m_KeepAliveList);
        while (!IsSerializedListEmpty(&m_KeepAliveList)) {
//dprintf("%#x ~S-I killing K-A %#x\n", GetCurrentThreadId(), HeadOfSerializedList(&m_KeepAliveList));

            LPVOID pEntry = SlDequeueHead(&m_KeepAliveList);

            INET_ASSERT(pEntry != NULL);

            if (pEntry != NULL) {

                ICSocket * pSocket = ContainingICSocket(pEntry);

//dprintf("~CServerInfo: destroying socket %#x\n", pSocket->GetSocket());
                pSocket->Destroy();
            }
        }
        UnlockSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_PipelinedList);
        //TerminateSerializedList(&m_Waiters);
    }

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::Reference(
    VOID
    )

/*++

Routine Description:

    Increments the reference count for the CServerInfo

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Reference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    InterlockedIncrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    DEBUG_LEAVE(0);
}


BOOL
CServerInfo::Dereference(
    VOID
    )

/*++

Routine Description:

    Dereferences the SESSION_INFO. If the reference count goes to zero then this
    entry is deleted. If the reference count goes to 1 then the expiry timer is
    started

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - entry was deleted

        FALSE   - entry was not deleted

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Dereference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    //
    // we need to grab the list - we may be removing this entry or updating
    // the reference count and expiry fields which must be done atomically
    //

    LockSerializedList(&GlobalServerInfoList);

    LONG result = InterlockedDecrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    BOOL deleted = FALSE;

    if (result == 0) {
        delete this;
        deleted = TRUE;
    } else if (result == 1) {

        //
        // start expiration proceedings...
        //

        SetExpiryTime();
    }

    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD    
CServerInfo::SetCachedProxyServerInfo(
    IN CServerInfo * pProxyServer,
    IN DWORD dwProxyVersion,
    IN BOOL fUseProxy,
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    IN INTERNET_SCHEME ProxyScheme,
    IN INTERNET_PORT ProxyPort
    )
/*++

Routine Description:

    If the Version information match up, copies
     the proxy information and links this server object
     to the appopriate proxy server object

    Assumes that this is called on successful use of the proxy
      object.

Arguments:

    None.

Return Value:

    DWORD
        ERROR_SUCCESS

        FALSE   - entry was not deleted

--*/


{
    DWORD error=ERROR_SUCCESS;

    LockSerializedList(&GlobalServerInfoList);            

    if ( dwProxyVersion != GlobalProxyVersionCount ) 
    {
        SetProxyScriptCached(FALSE);
        goto quit; // bail, we don't accept out of date additions to the cache
    }

    if ( m_ProxyLink )
    {
        if ( IsProxyScriptCached() && 
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort &&
             fUseProxy )
        {
            if ( pProxyServer == m_ProxyLink ) {            
                INET_ASSERT(dwProxyVersion == GlobalProxyVersionCount);
                m_dwProxyVersion = dwProxyVersion; // we're now up to date
                goto quit; // match, no version or host changes
            }

            INET_ASSERT(pProxyServer != m_ProxyLink );            
        }
        //
        // unlink, because we have a new entry to save,
        //  and the previous entry is bad
        //
        m_ProxyLink->Dereference();
        m_ProxyLink = NULL;
    }

    //
    // Add new cached entry
    //

    SetProxyScriptCached(TRUE);

    m_HostScheme     = HostScheme;
    m_HostPort       = HostPort;

    m_dwProxyVersion = dwProxyVersion; // we're now up to date

    if ( fUseProxy )
    {
        INET_ASSERT(this != pProxyServer);

        m_ProxyLink = pProxyServer;
        m_ProxyLink->Reference();

        m_ProxyLink->m_HostScheme = ProxyScheme;
        m_ProxyLink->m_HostPort   = ProxyPort;

        switch (ProxyScheme)
        {
            case INTERNET_SCHEME_HTTP:
                m_ProxyLink->SetCernProxy();
                break;
            case INTERNET_SCHEME_SOCKS: 
                m_ProxyLink->SetSocksGateway();
                break;
            case INTERNET_SCHEME_FTP:
                m_ProxyLink->SetFTPProxy();
                break;
        }
    }

quit:

    UnlockSerializedList(&GlobalServerInfoList);        

    return error;
}

CServerInfo * 
CServerInfo::GetCachedProxyServerInfo(
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    OUT BOOL *pfCachedEntry
    )

/*++

Routine Description:

   Retrieves a cached server object, that indicates
    a probable proxy to use

   On Success, the return has an additional increment
    on its ref count, assumition that caller derefs

Arguments:

    None.

Return Value:

    CServerInfo *     
        NULL on failure

--*/

{
    CServerInfo *pProxyServer = NULL;

    LockSerializedList(&GlobalServerInfoList);        

    *pfCachedEntry = FALSE; 

    if ( IsProxyScriptCached() )
    {        
        //
        // Examine Version Count
        //

        if ( GlobalProxyVersionCount == m_dwProxyVersion &&
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort
             )
        {
            *pfCachedEntry = TRUE;

            if ( m_ProxyLink ) {
                // matched cached entry
                m_ProxyLink->Reference();
                pProxyServer = m_ProxyLink;                    
            }
        }
        else
        {
            // version is expired, remove reference
            SetProxyScriptCached(FALSE);
            if ( m_ProxyLink ) {                
                m_ProxyLink->Dereference();
                m_ProxyLink = NULL;
            }
        }            
    }
        
    UnlockSerializedList(&GlobalServerInfoList);        
    return pProxyServer;
}

BOOL    
CServerInfo::CopyCachedProxyInfoToProxyMsg(
    IN OUT AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )

/*++

Routine Description:

   Retrieves Cached Proxy info from object

Arguments:

    None.

Return Value:

    BOOL
        TRUE - sucess

--*/

{
    BOOL fSuccess = FALSE;

    // really only need to lock to proctect m_HostPort && m_HostScheme
    LockSerializedList(&GlobalServerInfoList);        

    pQueryForProxyInfo->SetUseProxy(FALSE);
    pQueryForProxyInfo->_lpszProxyHostName =  
        m_HostName.StringAddress() ? 
        NewString(m_HostName.StringAddress()) :
        NULL;

    if ( pQueryForProxyInfo->_lpszProxyHostName != NULL ) {
        // copy out cached entry to proxy message structure
        pQueryForProxyInfo->_nProxyHostPort        = m_HostPort;
        pQueryForProxyInfo->_tProxyScheme          = m_HostScheme;
        pQueryForProxyInfo->_bFreeProxyHostName    = TRUE;
        pQueryForProxyInfo->_dwProxyHostNameLength = 
            strlen((pQueryForProxyInfo)->_lpszProxyHostName);
        pQueryForProxyInfo->SetUseProxy(TRUE);
        fSuccess = TRUE; // success
    }

    UnlockSerializedList(&GlobalServerInfoList);        
    return fSuccess;
}



//
//DWORD
//CServerInfo::ResolveHostName(
//    IN BOOL bForce
//    )
//
///*++
//
//Routine Description:
//
//    Resolves the host name for a CServerInfo. If we already have a resolved
//    name for this info then it is freed. There can be only one thread updating
//    or using the host name info
//
//Arguments:
//
//    bForce  - TRUE if we need to force a re-resolution
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::ResolveHostName",
//                 "{%q} %B",
//                 GetHostName(),
//                 bForce
//                 ));
//
//    DWORD error = ERROR_SUCCESS;
//
//    if (bForce || IsAddressListEmpty(&m_AddressList)) {
//        EnterCriticalSection(&m_AddressListCritSec);
//
//        //
//        // BUGBUG - ideally, we want to test TTL here if bForce is TRUE to stop
//        //          multiple simultaneous forced requests re-resolving the same
//        //          info
//        //
//
//        if (bForce || IsAddressListEmpty(&m_AddressList)) {
//
//            //
//            // FreeAddressList() checks for an empty list
//            //
//
//            FreeAddressList(&m_AddressList);
//
//            //
//            // resolve the name & generate an address list. Since we don't know
//            // the port address we want to talk to right now, we will generate a
//            // list containing a default port number (0) which we must override
//            // when we really connect to the server
//            //
//
//            error = ::GetServiceAddress(GetHostName(),
//                                        NULL, // service name
//                                        NULL, // service guid
//                                        NS_DEFAULT,
//                                        INTERNET_INVALID_PORT_NUMBER,
//                                        0,    // protocol characteristics
//                                        &m_AddressList
//                                        );
//        }
//        LeaveCriticalSection(&m_AddressListCritSec);
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


VOID
CServerInfo::UpdateConnectTime(
    IN DWORD dwConnectTime
    )

/*++

Routine Description:

    Calculates average connect time

Arguments:

    dwConnectTime   - current connect time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectTime",
                 "{%q} %d",
                 GetHostName(),
                 dwConnectTime
                 ));

    DWORD connectTime = m_ConnectTime;

    if (connectTime == (DWORD)-1) {
        connectTime = dwConnectTime;
    } else {
        connectTime = (connectTime + dwConnectTime) / 2;
    }
//dprintf("%s: connect time = %d, ave = %d\n", GetHostName(), dwConnectTime, connectTime);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average connect time = %d mSec\n",
                connectTime
                ));

    InterlockedExchange((LPLONG)&m_ConnectTime, connectTime);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateRTT(
    IN DWORD dwRTT
    )

/*++

Routine Description:

    Calculates rolling average round-trip time

Arguments:

    dwRTT   - current round-trip time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateRTT",
                 "{%q} %d",
                 GetHostName(),
                 dwRTT
                 ));

    DWORD RTT = m_RTT;

    if (RTT == 0) {
        RTT = dwRTT;
    } else {
        RTT = (RTT + dwRTT) / 2;
    }
//dprintf("%s: RTT = %d, ave = %d\n", GetHostName(), dwRTT, RTT);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average round trip time = %d mSec\n",
                RTT
                ));

    InterlockedExchange((LPLONG)&m_RTT, RTT);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateDownloadRate(
    IN DWORD dwBytesPerSecond
    )

/*++

Routine Description:

    Calculates average download rate

Arguments:

    dwBytesPerSecond    - current download rate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateDownloadRate",
                 "{%q} %d",
                 GetHostName(),
                 dwBytesPerSecond
                 ));

    DWORD downloadRate = m_DownloadRate;

    if (downloadRate == 0) {
        downloadRate = dwBytesPerSecond;
    } else {
        downloadRate = (downloadRate + dwBytesPerSecond) / 2;
    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("average download rate = %d bytes/second\n",
                downloadRate
                ));

    InterlockedExchange((LPLONG)&m_DownloadRate, downloadRate);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateUploadRate(
    IN DWORD dwBytesPerSecond
    )

/*++

Routine Description:

    Calculates average upload rate

Arguments:

    dwBytesPerSecond    - current upload rate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateUploadRate",
                 "{%q} %d",
                 GetHostName(),
                 dwBytesPerSecond
                 ));

    DWORD uploadRate = m_UploadRate;

    if (uploadRate == 0) {
        uploadRate = dwBytesPerSecond;
    } else {
        uploadRate = (uploadRate + dwBytesPerSecond) / 2;
    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("average upload rate = %d bytes/second\n",
                uploadRate
                ));

    InterlockedExchange((LPLONG)&m_UploadRate, uploadRate);

    DEBUG_LEAVE(0);
}

//
//DWORD
//CServerInfo::GetConnection(
//    IN DWORD dwSocketFlags,
//    IN INTERNET_PORT nPort,
//    IN DWORD dwTimeout,
//    OUT ICSocket * * lplpSocket
//    )
//
///*++
//
//Routine Description:
//
//    Combines connection limiting and keep-alive list management. If keep-alive
//    connection requested and one is available, it is given out. If we can create
//    a connection, the connection count is increased (actually decremented) and
//    an OK-to-continue indication returned to the caller. If all connections are
//    currently in use, we wait for one to become available. If this is a sync
//    operation, we block waiting for the waiter event. If this is an async
//    operation, we return ERROR_IO_PENDING and pick up the request on a worker
//    thread when it becomes unblocked or times out proper
//
//Arguments:
//
//    dwSocketFlags   - flags identifying what type of connection we want:
//
//                        SF_SECURE       - we want https connection
//
//                        SF_KEEP_ALIVE   - we want persistent connection
//
//                        SF_NON_BLOCKING - we want non-blocking (async) socket
//
//    nPort           - required port
//
//    dwTimeout       - number of milliseconds we are willing to wait for
//                      connection to become available
//
//    lplpSocket      - returned pointer to ICSocket. ONLY used if the request is
//                      for a keep-alive socket and we had one available
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//                    Depending on *lplpSocket, we either returned the socket to
//                    use, or its okay to create a new connection
//
//                  ERROR_IO_PENDING
//                    Request will complete asynchronously
//
//        Failure - ERROR_INTERNET_TIMEOUT
//                    Failed to get connection in time allowed
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::GetConnection",
//                 "{%q} %#x, %d, %d, %#x",
//                 GetHostName(),
//                 dwSocketFlags,
//                 nPort,
//                 dwTimeout,
//                 lplpSocket
//                 ));
//
//    *lplpSocket = NULL;
//
//    DWORD error = DoFsm(new CFsm_GetConnection(dwSocketFlags,
//                                               nPort,
//                                               dwTimeout,
//                                               lplpSocket,
//                                               this
//                                               ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
CFsm_GetConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_GetConnection state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
//dprintf("%#x: %s FSM %#x state %s\n", GetCurrentThreadId(), Fsm->MapType(), Fsm, Fsm->MapState());
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_GetConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    CServerInfo * pServerInfo = (CServerInfo *)Fsm->GetContext();
    CFsm_GetConnection * stateMachine = (CFsm_GetConnection *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        stateMachine->StartTimer();

        //
        // fall through
        //

    case FSM_STATE_CONTINUE:

#ifdef NEW_CONNECTION_SCHEME
    case FSM_STATE_ERROR:
#endif
        error = pServerInfo->GetConnection_Fsm(stateMachine);
        break;

#ifndef NEW_CONNECTION_SCHEME

    case FSM_STATE_ERROR:

        INET_ASSERT((Fsm->GetError() == ERROR_INTERNET_TIMEOUT)
                    || (Fsm->GetError() == ERROR_INTERNET_OPERATION_CANCELLED));

        pServerInfo->RemoveWaiter((DWORD_PTR)Fsm);
        error = Fsm->GetError();
        Fsm->SetDone();
//dprintf("%#x: FSM_STATE_ERROR - %d\n", GetCurrentThreadId(), error);
        break;

#endif

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifdef NEW_CONNECTION_SCHEME
//
//
//DWORD
//CServerInfo::GetConnection_Fsm(
//    IN CFsm_GetConnection * Fsm
//    )
//
///*++
//
//Routine Description:
//
//    Tries to get a connection of requested type for caller. If no connection is
//    available then one of the following happens:
//
//        * If there are available keep-alive connections of a different type then
//          one is closed and the caller allowed to create a new connection
//
//        * If this is an async request, the FSM is blocked and the thread returns
//          to the pool if a worker, or back to the app if an app thread
//
//        * If this is a sync request, we wait on an event for a conneciton to be
//          made available, or the connect timeout to elapse
//
//        * In the situation where we are being run out of connections (number of
//          active connections >= connection limit AND no activity has taken place
//          on any connection in the last dwLimitTimeout mSec (in FSM)) then we
//          allow a new connection to be created
//
//Arguments:
//
//    Fsm - get connection FSM
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//                    Depending on *lplpSocket, we either returned the socket to
//                    use, or its okay to create a new connection
//
//                  ERROR_IO_PENDING
//                    Request will complete asynchronously
//
//        Failure - ERROR_INTERNET_TIMEOUT
//                    Failed to get connection in time allowed
//
//                  ERROR_INTERNET_INTERNAL_ERROR
//                    Something unexpected happened
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::GetConnection_Fsm",
//                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d, %d)",
//                 GetHostName(),
//                 AvailableConnections(),
//                 KeepAliveConnections(),
//                 ConnectionLimit(),
//                 Fsm,
//                 Fsm->m_dwSocketFlags,
//                 Fsm->m_nPort,
//                 Fsm->m_dwTimeout,
//                 Fsm->m_dwLimitTimeout
//                 ));
//
//    DEBUG_PRINT(SESSION,
//                INFO,
//                ("FSM %#x state %s elapsed %d\n",
//                Fsm,
//                Fsm->MapState(),
//                Fsm->GetElapsedTime()
//                ));
//
//    DPRINTF("%#x: FSM %#x state %s elapsed %d\n",
//            GetCurrentThreadId(),
//            Fsm,
//            Fsm->MapState(),
//            Fsm->GetElapsedTime()
//            );
//
//    PERF_ENTER(GetConnection);
//
//    CFsm_GetConnection & fsm = *Fsm;
//    DWORD error = fsm.GetError();
//    FSM_STATE state = fsm.GetState();
//    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
//    ICSocket * pSocket = NULL;
//    BOOL bUnlockList = FALSE;
//    BOOL bKeepAliveWaiters;
//
//    *fsm.m_lplpSocket = NULL;
//
//    //
//    // FSM_STATE_ERROR processing. Typically a timeout has occurred. We now want
//    // to force a new connection instead of timing out
//    //
//
//    if (error != ERROR_SUCCESS) {
//        RemoveWaiter((DWORD)Fsm);
//    }
//
//    //
//    // timeout error is OK - we just try again until we get cancelled out or hit
//    // the retry limit. Any other error causes failure. We should not be getting
//    // ERROR_SUCCESS (test put here for defensive purposes only)
//    //
//
//    if ((state == FSM_STATE_ERROR)
//    && (error != ERROR_INTERNET_TIMEOUT)
//    && (error != ERROR_SUCCESS)) {
//
//        DPRINTF("%#x: FSM %#x FSM_STATE_ERROR, error = %d\n",
//                GetCurrentThreadId(),
//                Fsm,
//                error
//                );
//
//        DEBUG_PRINT(SESSION,
//                    ERROR,
//                    ("FSM %#x FSM_STATE_ERROR, error = %s (%d)\n",
//                    Fsm,
//                    InternetMapError(error),
//                    error
//                    ));
//
//        INET_ASSERT(error != ERROR_SUCCESS);
//
//        goto quit;
//    }
//
//    INET_ASSERT(lpThreadInfo != NULL);
//    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
//
//    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    BOOL bAsyncRequest;
//
//    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
//                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
//                        IsAsyncHandle();
//
//    //
//    // before we do anything, check if we've been run out of connections. If we
//    // don't do this check here and we are out, then we'll wait unnecessarily
//    // (assuming connections are not returned)
//    //
//
//    if ((state == FSM_STATE_INIT) && RunOutOfConnections()) {
//
//        DPRINTF("%#x: out of connections on first attempt: %d+%d/%d\n",
//                GetCurrentThreadId(),
//                AvailableConnections(),
//                KeepAliveConnections(),
//                ConnectionLimit()
//                );
//
//        DEBUG_PRINT(SESSION,
//                    ERROR,
//                    ("out of connections on first attempt: %d+%d/%d\n",
//                    AvailableConnections(),
//                    KeepAliveConnections(),
//                    ConnectionLimit()
//                    ));
//
//        error = ERROR_SUCCESS;
//        pSocket = NULL;
//        goto quit;
//    }
//
//try_again:
//
//    bUnlockList = TRUE;
//
//    //
//    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
//    // from within m_Waiters
//    //
//
//    LockSerializedList(&m_Waiters);
//    bKeepAliveWaiters = KeepAliveWaiters();
//    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {
//
//        //
//        // maintain requester order - if there are already waiters then queue
//        // this request, else try to satisfy the requester. HOWEVER, only check
//        // for existing requesters the FIRST time through. If we're here with
//        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
//        // waiters that came after us
//        //
//
//        if ((state == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("continuing or no current waiters for K-A connections\n"
//                        ));
//
//            while (pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags, fsm.m_nPort)) {
//                if (pSocket->IsReset()) {
//
//                    DPRINTF("%#x: ********* socket %#x is closed already\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket()
//                            );
//
//                    DEBUG_PRINT(SESSION,
//                                INFO,
//                                ("K-A connection %#x [%#x] is closed\n",
//                                pSocket,
//                                pSocket->GetSocket()
//                                ));
//
//                    pSocket->SetLinger(FALSE, 0);
//                    pSocket->Shutdown(2);
////dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
//                    pSocket->Destroy();
//                    if (!UnlimitedConnections()) {
//                        ++m_ConnectionsAvailable;
//                    }
//                    CHECK_CONNECTION_COUNT();
//                } else {
//
//                    DPRINTF("%#x: *** matched %#x, %#x\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket(),
//                            pSocket->GetFlags()
//                            );
//
//                    break;
//                }
//            }
//            if (pSocket == NULL) {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("no available K-A connections\n"
//                            ));
//
//                /*
//                //
//                // if all connections are in use as keep-alive connections then
//                // since we're here, we want a keep-alive connection that doesn't
//                // match the currently available keep-alive connections. Terminate
//                // the oldest keep-alive connection (at the head of the queue)
//                // and generate a new connection
//                //
//
//                LockSerializedList(&m_KeepAliveList);
//                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
//                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
//                    pSocket->SetLinger(FALSE, 0);
//                    pSocket->Shutdown(2);
//                    pSocket->Destroy();
//                    if (!UnlimitedConnections()) {
//                        ++m_ConnectionsAvailable;
//                    }
//                    CHECK_CONNECTION_COUNT();
//                }
//                UnlockSerializedList(&m_KeepAliveList);
//                */
//            }
//        } else {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("%d waiters for K-A connection to %q\n",
//                        ElementsOnSerializedList(&m_KeepAliveList),
//                        GetHostName()
//                        ));
//
//        }
//    }
//
//    //
//    // if we found a matching keep-alive connection or we are not limiting
//    // connections then we're done
//    //
//
//    if ((pSocket != NULL) || UnlimitedConnections()) {
//
//        INET_ASSERT(error == ERROR_SUCCESS);
//
//        error = ERROR_SUCCESS;
//        goto exit;
//    }
//
//    //
//    // no keep-alive connections matched, or there are already waiters for
//    // keep-alive connections
//    //
//
//    INET_ASSERT((AvailableConnections() >= 0)
//                && (AvailableConnections() <= ConnectionLimit()));
//
//    if (AvailableConnections() > 0) {
//
//        //
//        // can create a connection
//        //
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("%s: OK to create new connection: %d/%d\n",
//                    GetHostName(),
//                    AvailableConnections(),
//                    ConnectionLimit()
//                    ));
//
//        DPRINTF("%#x: *** %s: OK to create connection: %d/%d\n",
//                GetCurrentThreadId(),
//                GetHostName(),
//                AvailableConnections(),
//                ConnectionLimit()
//                );
//
//        INET_ASSERT(error == ERROR_SUCCESS);
//        INET_ASSERT(pSocket == NULL);
//
//        --m_ConnectionsAvailable;
//    //} else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
//    //    error = ERROR_INTERNET_TIMEOUT;
//    } else {
//
//        //
//        // if there are keep-alive connections but no keep-alive waiters
//        // then either we don't want a keep-alive connection, or the ones
//        // available don't match our requirements.
//        // If we need a connection of a different type - e.g. SSL when all
//        // we have is non-SSL then close a connection & generate a new one.
//        // If we need a non-keep-alive connection then its okay to return
//        // a current keep-alive connection, the understanding being that the
//        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
//        // will add Connection: Close header (HTTP 1.1)
//        //
//
//        //
//        // BUGBUG - what about waiters for non-keep-alive connections?
//        //
//        // scenario - limit of 1 connection:
//        //
//        //  A. request for k-a
//        //      continue & create connection
//        //  B. request non-k-a
//        //      none available; wait
//        //  C. release k-a connection; unblock sync waiter B
//        //  D. request non-k-a
//        //      k-a available; return it; caller converts to non-k-a
//        //  E. unblocked waiter B request non-k-a
//        //      none available; wait
//        //
//        // If this situation continues, eventually B will time-out, whereas it
//        // could have had the connection taken by D. Request D is younger and
//        // therefore can afford to wait while B continues with the connection
//        //
//
//        BOOL fHaveConnection = FALSE;
//
//        if (!bKeepAliveWaiters) {
//            LockSerializedList(&m_KeepAliveList);
//            if (KeepAliveConnections() != 0) {
//                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
//                fHaveConnection = TRUE;
//
//#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE)
//
//                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
//                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;
//
//                if (dwSocketTypeFlags ^ dwRequestTypeFlags) {
//
//                    DEBUG_PRINT(SESSION,
//                                INFO,
//                                ("different socket types requested: %#x, %#x\n",
//                                fsm.m_dwSocketFlags,
//                                pSocket->GetFlags()
//                                ));
//
//                    DPRINTF("%#x: *** closing socket %#x: %#x vs. %#x\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket(),
//                            pSocket->GetFlags(),
//                            fsm.m_dwSocketFlags
//                            );
//
//                    pSocket->SetLinger(FALSE, 0);
//                    pSocket->Shutdown(2);
////dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
//                    pSocket->Destroy();
//                    pSocket = NULL;
//                } else {
//
//                    DPRINTF("%#x: *** returning k-a connection %#x as non-k-a\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket()
//                            );
//
//                }
//                CHECK_CONNECTION_COUNT();
//            }
//            UnlockSerializedList(&m_KeepAliveList);
//            if (fHaveConnection) {
//                goto exit;
//            }
//        }
//
//        //
//        // about to wait for a connection. If it looks as though we're being run
//        // out of connections, then create a new one
//        //
//
//        if (RunOutOfConnections()) {
//            pSocket = NULL;
//            error = ERROR_SUCCESS;
//            goto exit;
//        }
//
//        DPRINTF("%#x: blocking %s FSM %#x state %s %d/%d elapsed: %d mSec\n",
//                GetCurrentThreadId(),
//                Fsm->MapType(),
//                Fsm,
//                Fsm->MapState(),
//                AvailableConnections(),
//                ConnectionLimit(),
//                Fsm->GetElapsedTime()
//                );
//
//        //
//        // we have to wait for a connection to become available. If we are an
//        // async request then we queue this FSM & return the thread to the pool
//        // or, if app thread, return pending indication to the app. If this is
//        // a sync request (in an app thread) then we block on an event waiting
//        // for a connection to become available
//        //
//
//        HANDLE hEvent = NULL;
//
//        if (!bAsyncRequest) {
//
//            //
//            // create unnamed, initially unsignalled, auto-reset event
//            //
//
//            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
//            if (hEvent == NULL) {
//                error = GetLastError();
//                goto exit;
//            }
//        }
//
//        CConnectionWaiter * pWaiter;
//
//#if INET_DEBUG
//
//        for (pWaiter = (CConnectionWaiter *)HeadOfSerializedList(&m_Waiters);
//             pWaiter != (CConnectionWaiter *)SlSelf(&m_Waiters);
//             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {
//
//            INET_ASSERT(pWaiter->Id() != (DWORD)(bAsyncRequest ? (DWORD)Fsm : lpThreadInfo->ThreadId));
//        }
//#endif
//
//        pWaiter = new CConnectionWaiter(&m_Waiters,
//                                        !bAsyncRequest,
//                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
//                                            ? TRUE
//                                            : FALSE,
//                                        bAsyncRequest
//                                            ? (DWORD)Fsm
//                                            : lpThreadInfo->ThreadId,
//                                        hEvent);
//        if (pWaiter == NULL) {
//            error = ERROR_NOT_ENOUGH_MEMORY;
//            goto exit;
//        }
//        if (bAsyncRequest) {
//
//            //
//            // ensure that when the FSM is unblocked normally, the new state
//            // is STATE_CONTINUE
//            //
//
//            DWORD dwWaitTime = min(fsm.m_dwLimitTimeout, fsm.m_dwTimeout);
//
//            ////
//            //// make wait time elastic: we don't want to time out after the
//            //// connect timeout value elapses. We keep expanding the wait time
//            //// for a connection until we get one, or the request is cancelled
//            ////
//            //
//            //fsm.m_dwTimeout += dwWaitTime;
//            //if (fsm.m_dwTimeout == 0xffffffff) {
//            //    --fsm.m_dwTimeout;
//            //}
//            fsm.SetState(FSM_STATE_CONTINUE);
//            fsm.SetNextState(FSM_STATE_CONTINUE);
//            error = BlockWorkItem(Fsm, (DWORD)pWaiter, dwWaitTime);
//            if (error == ERROR_SUCCESS) {
//                error = ERROR_IO_PENDING;
//            }
//        } else {
//            UnlockSerializedList(&m_Waiters);
//            bUnlockList = FALSE;
//
//            DPRINTF("%#x: %s FSM %#x %s waiting %d mSec\n",
//                    GetCurrentThreadId(),
//                    Fsm->MapType(),
//                    Fsm,
//                    Fsm->MapState(),
//                    fsm.m_dwTimeout
//                    );
//
//            //DWORD dwWaitTime = fsm.m_dwTimeout - fsm.GetElapsedTime();
//            DWORD dwWaitTime = fsm.m_dwTimeout;
//
//            if ((int)dwWaitTime <= 0) {
//
//                DEBUG_PRINT(SESSION,
//                            ERROR,
//                            ("SYNC wait timed out (%d mSec)\n",
//                            fsm.m_dwTimeout
//                            ));
//
//                error = ERROR_INTERNET_TIMEOUT;
//            } else {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("waiting %d mSec for SYNC event %#x\n",
//                            dwWaitTime,
//                            hEvent
//                            ));
//
//                //
//                // we'd better not be doing a sync wait if we are in the
//                // context of an app thread making an async request
//                //
//
//                INET_ASSERT(!lpThreadInfo->IsAsyncWorkerThread
//                            && !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
//                                hObjectMapped)->IsAsyncHandle());
//
//                //INET_ASSERT(dwWaitTime <= 60000);
//
//                DWORD dwDeltaWaitTime = min(dwWaitTime, fsm.m_dwLimitTimeout);
//                DWORD dwTimeStarted = GetTickCount();
//
//                do {
//
//                    DPRINTF("%#x: sync wait %d mSec\n",
//                            GetCurrentThreadId(),
//                            dwDeltaWaitTime
//                            );
//
//                    error = WaitForSingleObject(hEvent, dwDeltaWaitTime);
//                    if (error == STATUS_TIMEOUT) {
//                        if (RunOutOfConnections()) {
//
//                            DPRINTF("%#x: run out of connections\n",
//                                    GetCurrentThreadId()
//                                    );
//
//                            break;
//                        }
//                    }
//                } while (((GetTickCount() - dwTimeStarted) < dwWaitTime)
//                         && (error == STATUS_TIMEOUT));
//
//                DPRINTF("%#x: sync waiter unblocked - error = %d\n",
//                        GetCurrentThreadId(),
//                        error
//                        );
//
//            }
//            if (error == STATUS_TIMEOUT) {
//
//                DPRINTF("%#x: %s %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
//                        GetCurrentThreadId(),
//                        GetHostName(),
//                        AvailableConnections(),
//                        KeepAliveConnections(),
//                        ConnectionLimit(),
//                        GetCurrentThreadId(),
//                        Fsm->MapType(),
//                        Fsm,
//                        Fsm->MapState()
//                        );
//
//                RemoveWaiter(lpThreadInfo->ThreadId);
//                //bUnlockList = FALSE;
//                /*
//                LockSerializedList(&m_Waiters);
//                for (pWaiter = (CConnectionWaiter *)HeadOfSerializedList(&m_Waiters);
//                     pWaiter != (CConnectionWaiter *)SlSelf(&m_Waiters);
//                     pWaiter = (CConnectionWaiter *)pWaiter->Next()) {
//
//                    if (pWaiter->Id() == lpThreadInfo->ThreadId) {
//                        RemoveFromSerializedList(&m_Waiters, pWaiter->List());
//                        delete pWaiter;
//                        break;
//                    }
//                }
//                */
//                error = RunOutOfConnections()
//                        ? WAIT_OBJECT_0
//                        : ERROR_INTERNET_TIMEOUT;
//            //} else {
//            //    bUnlockList = FALSE;
//            }
//
//            BOOL bOk;
//
//            bOk = CloseHandle(hEvent);
//
//            INET_ASSERT(bOk);
//
//            if (error == WAIT_OBJECT_0) {
//
//                DPRINTF("%#x: sync requester trying again\n",
//                        GetCurrentThreadId()
//                        );
//
//                fsm.SetState(FSM_STATE_CONTINUE);
//                goto try_again;
//            }
//        }
//    }
//
//exit:
//
//    //
//    // if we are returning a (keep-alive) socket that has a different blocking
//    // mode from that requested, change it
//    //
//
//    if (pSocket != NULL) {
//        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
//            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("different blocking modes requested: %#x, %#x\n",
//                        fsm.m_dwSocketFlags,
//                        pSocket->GetFlags()
//                        ));
//
//            DPRINTF("%#x: *** changing socket %#x to %sBLOCKING\n",
//                    GetCurrentThreadId(),
//                    pSocket->GetSocket(),
//                    fsm.m_dwSocketFlags & SF_NON_BLOCKING
//                        ? "NON-"
//                        : ""
//                    );
//
//            pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags
//                                        & SF_NON_BLOCKING);
//        }
//        *fsm.m_lplpSocket = pSocket;
//    }
//
//    if (bUnlockList) {
//        UnlockSerializedList(&m_Waiters);
//    }
//
//quit:
//
//    if (error != ERROR_IO_PENDING) {
//        fsm.SetDone();
//    }
//
//    DPRINTF("%#x: %s %d+%d/%d: get: %d, %#x, %d\n",
//            GetCurrentThreadId(),
//            GetHostName(),
//            AvailableConnections(),
//            KeepAliveConnections(),
//            ConnectionLimit(),
//            error,
//            pSocket ? pSocket->GetSocket() : 0,
//            ElementsOnSerializedList(&m_Waiters)
//            );
//
//    PERF_LEAVE(GetConnection);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//CServerInfo::ReleaseConnection(
//    IN ICSocket * lpSocket OPTIONAL
//    )
//
///*++
//
//Routine Description:
//
//    Returns a keep-alive connection to the pool, or allows another requester to
//    create a connection.
//
//    If we will break the connection limit then we assume we created an additional
//    connection when we were being starved, and we discard this one
//
//Arguments:
//
//    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DPRINTF("%#x: rls %#x %d+%d/%d\n",
//            GetCurrentThreadId(),
//            lpSocket ? lpSocket->GetSocket() : 0,
//            AvailableConnections(),
//            KeepAliveConnections(),
//            ConnectionLimit()
//            );
//
//    //return ERROR_SUCCESS;
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::ReleaseConnection",
//                 "{%q [%d+%d/%d]} %#x [%#x]",
//                 GetHostName(),
//                 AvailableConnections(),
//                 KeepAliveConnections(),
//                 ConnectionLimit(),
//                 lpSocket,
//                 lpSocket ? lpSocket->GetSocket() : 0
//                 ));
//
//    PERF_ENTER(ReleaseConnection);
//
//    DWORD error = ERROR_SUCCESS;
//    BOOL bRelease = FALSE;
//
//    LockSerializedList(&m_Waiters);
//
//    //
//    // quite often (at least with catapult proxy based on IIS) the server may
//    // drop the connection even though it indicated it would keep it open. This
//    // typically happens on 304 (frequent) and 302 (less so) responses. If we
//    // determine the server has dropped the connection then throw it away and
//    // allow the app to create a new one
//    //
//
//    if (lpSocket != NULL) {
//        if (TotalAvailableConnections() >= ConnectionLimit()) {
//
//            DPRINTF("%#x: !!! too many K-A connections %d+%d/%d - discarding %#x\n",
//                    GetCurrentThreadId(),
//                    AvailableConnections(),
//                    KeepAliveConnections(),
//                    ConnectionLimit(),
//                    lpSocket->GetSocket()
//                    );
//
//            //
//            // trying to return keep-alive socket would overflow limit (if we
//            // are not already over). If we have less than the max. keep-alive
//            // connections, we will keep this one else close it
//            //
//
//            if (KeepAliveConnections() >= ConnectionLimit()) {
//
//                INET_ASSERT(KeepAliveConnections() == ConnectionLimit());
//
//                //
//                // BUGBUG - discarding k-a connection: it should be the oldest
//                //          (if oldest not this one)
//                //
//
//                DPRINTF("%#x: closing k-a %#x\n",
//                        GetCurrentThreadId(),
//                        lpSocket->GetSocket()
//                        );
//
//                lpSocket->Close();
//            } else {
//
//                INET_ASSERT(AvailableConnections() > 0);
//
//                if (AvailableConnections() > 0) {
//                    --m_ConnectionsAvailable;
//                }
//            }
//        }
//        if (lpSocket->IsClosed() || lpSocket->IsReset()) {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("socket %#x already dead - throwing it out\n",
//                        lpSocket->GetSocket()
//                        ));
//
//            DPRINTF("%#x: socket %#x: already reset\n",
//                    GetCurrentThreadId(),
//                    lpSocket->GetSocket()
//                    );
//
////dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
//
//            BOOL bDestroyed = lpSocket->Dereference();
//
//            INET_ASSERT(bDestroyed);
//
//            lpSocket = NULL;
//        } else {
//
//            //
//            // if we are returning a keep-alive socket, put it in non-blocking
//            // mode if not already. Typically, Internet Explorer uses non-blocking
//            // sockets. In the infrequent cases where we want a blocking socket
//            // - mainly when doing java downloads - we will convert the socket
//            // to blocking mode when we get it from the pool
//            //
//
//            if (!lpSocket->IsNonBlocking()) {
//
//                DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
//                        GetCurrentThreadId(),
//                        lpSocket->GetSocket()
//                        );
//
//                lpSocket->SetNonBlockingMode(TRUE);
//            }
//        }
//    }
//    if (lpSocket != NULL) {
//
//        DPRINTF("%#x: releasing K-A %#x (%d/%d)\n",
//                GetCurrentThreadId(),
//                lpSocket ? lpSocket->GetSocket() : 0,
//                AvailableConnections(),
//                ConnectionLimit()
//                );
//
//        INET_ASSERT(lpSocket->IsOpen());
//        INET_ASSERT(!lpSocket->IsOnList());
//        //INET_ASSERT(!lpSocket->IsReset());
//
//        lpSocket->SetKeepAlive();
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("releasing keep-alive socket %#x\n",
//                    lpSocket->GetSocket()
//                    ));
//
//        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);
//
//        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));
//
//        InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List());
//
//        INET_ASSERT(UnlimitedConnections()
//                    ? TRUE
//                    : (KeepAliveConnections() <= ConnectionLimit()));
//
//        bRelease = TRUE;
//    } else {
//
//        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
//                GetCurrentThreadId(),
//                AvailableConnections(),
//                KeepAliveConnections(),
//                ConnectionLimit()
//                );
//
//        if (!UnlimitedConnections()) {
//            if (AvailableConnections() < ConnectionLimit()) {
//                ++m_ConnectionsAvailable;
//            } else {
//
//                DPRINTF("%#x: !!! not increasing avail cons (%d+%d) - at limit (%d)\n",
//                        GetCurrentThreadId(),
//                        AvailableConnections(),
//                        KeepAliveConnections(),
//                        ConnectionLimit()
//                        );
//
//            }
//        }
//
//        CHECK_CONNECTION_COUNT();
//
//        bRelease = TRUE;
//    }
//    if (bRelease && !UnlimitedConnections()) {
//
//        CHECK_CONNECTION_COUNT();
//
//        CConnectionWaiter * pWaiter;
//        BOOL bFreed = FALSE;
//
//        //
//        // loop here until we free a waiter or until there are no waiters left.
//        // The reason we do this is that we must free a waiter if there are any
//        // but the waiter corresponding to pWaiter may have been concurrently
//        // timed out and cannot be unblocked by us
//        //
//
//        do {
//            pWaiter = (CConnectionWaiter *)SlDequeueHead(&m_Waiters);
//            if (pWaiter != NULL) {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("unblocking %s waiter %#x\n",
//                            pWaiter->IsSync() ? "Sync" : "Async",
//                            pWaiter->Id()
//                            ));
//
//                DPRINTF("%#x: Unblocking %s connection waiter %#x\n",
//                        GetCurrentThreadId(),
//                        pWaiter->IsSync() ? "Sync" : "Async",
//                        pWaiter->Id()
//                        );
//
//                if (pWaiter->IsSync()) {
//                    pWaiter->Signal();
//                    bFreed = TRUE;
//                } else {
//
//                    int n = (int)UnblockWorkItems(1, (DWORD)pWaiter, ERROR_SUCCESS);
//
//                    if (n >= 1) {
//
//                        //
//                        // should never be > 1
//                        //
//
//                        INET_ASSERT(n == 1);
//
//                        bFreed = TRUE;
//
//                        DPRINTF("%#x: unblocked waiting FSM %#x\n",
//                                GetCurrentThreadId(),
//                                pWaiter->Id()
//                                );
//
//                        DEBUG_PRINT(SESSION,
//                                    INFO,
//                                    ("unblocked waiting FSM %#x\n",
//                                    pWaiter->Id()
//                                    ));
//
//                    } else {
//
//                        //
//                        // should never be < 0
//                        //
//
//                        INET_ASSERT(n == 0);
//
//                        DPRINTF("%#x: ********* waiting FSM %#x NOT UNBLOCKED\n",
//                                GetCurrentThreadId(),
//                                pWaiter->Id()
//                                );
//
//                        DEBUG_PRINT(SESSION,
//                                    ERROR,
//                                    ("waiting FSM %#x not unblocked\n",
//                                    pWaiter->Id()
//                                    ));
//
//                    }
//                }
//                delete pWaiter;
//            } else {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("no waiters\n"
//                            ));
//
//                DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
//                        GetCurrentThreadId()
//                        );
//
//            }
//        } while ((pWaiter != NULL) && !bFreed);
//    } else {
//
//        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
//                GetCurrentThreadId()
//                );
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("bRelease = %B, UnlimitedConnections() = %B\n",
//                    bRelease,
//                    UnlimitedConnections()
//                    ));
//
//    }
//
//    if (TotalAvailableConnections() >= ConnectionLimit()) {
//        ResetLastActiveTime();
//    }
//
//    DEBUG_PRINT(SESSION,
//                INFO,
//                ("avail+k-a/limit = %d+%d/%d\n",
//                AvailableConnections(),
//                KeepAliveConnections(),
//                ConnectionLimit()
//                ));
//
//    UnlockSerializedList(&m_Waiters);
//
//    PERF_LEAVE(ReleaseConnection);
//
//    DEBUG_LEAVE(error);
//
//    DPRINTF("%#x: %s %d+%d/%d: rls %#x: %d, %d\n",
//            GetCurrentThreadId(),
//            GetHostName(),
//            AvailableConnections(),
//            KeepAliveConnections(),
//            ConnectionLimit(),
//            lpSocket ? lpSocket->GetSocket() : 0,
//            error,
//            ElementsOnSerializedList(&m_Waiters)
//            );
//
//    return error;
//}
//
#else


DWORD
CServerInfo::GetConnection_Fsm(
    IN CFsm_GetConnection * Fsm
    )

/*++

Routine Description:

    Tries to get a connection of requested type for caller. If no connection is
    available then one of the following happens:

        * If there are available keep-alive connections of a different type then
          one is closed and the caller allowed to create a new connection

        * If this is an async request, the FSM is blocked and the thread returns
          to the pool if a worker, or back to the app if an app thread

        * If this is a sync request, we wait on an event for a connection to be
          made available, or the connect timeout to elapse

Arguments:

    Fsm - get connection FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Depending on *lplpSocket, we either returned the socket to
                    use, or its okay to create a new connection

                  ERROR_IO_PENDING
                    Request will complete asynchronously

        Failure - ERROR_INTERNET_TIMEOUT
                    Failed to get connection in time allowed

                  ERROR_INTERNET_INTERNAL_ERROR
                    Something unexpected happened

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::GetConnection_Fsm",
                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d)",
                 GetHostName(),
                 m_ConnectionsAvailable,
                 ElementsOnSerializedList(&m_KeepAliveList),
                 m_ConnectionLimit,
                 Fsm,
                 Fsm->m_dwSocketFlags,
                 Fsm->m_nPort,
                 Fsm->m_dwTimeout
                 ));

    PERF_ENTER(GetConnection);

    BOOL bFound = FALSE;
    DWORD error = ERROR_SUCCESS;
    CFsm_GetConnection & fsm = *Fsm;
    ICSocket * pSocket = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    HANDLE hEvent = NULL;
    BOOL bUnlockList = TRUE;
    BOOL bKeepAliveWaiters;
    BOOL fExemptConnLimit = FALSE;

    if (fsm.IsInvalid()) 
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }


    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                GetHandleType() == TypeHttpRequestHandle);

    fExemptConnLimit = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->ConnLimitExempted();

    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    BOOL bAsyncRequest;

    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                        IsAsyncHandle();

    *fsm.m_lplpSocket = NULL;

try_again:

    bUnlockList = TRUE;

    //
    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
    // from within m_Waiters
    //

    m_Waiters.Acquire();
    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }
    bKeepAliveWaiters = KeepAliveWaiters();
    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {

        //
        // maintain requester order - if there are already waiters then queue
        // this request, else try to satisfy the requester. HOWEVER, only check
        // for existing requesters the FIRST time through. If we're here with
        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
        // waiters that came after us
        //

        if ((fsm.GetState() == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no current waiters for K-A connections\n"
                        ));

            while (pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags,
                                                     fsm.m_nPort,
                                                     fsm.m_lpszSecureTunnelHost)) {
                if (pSocket->IsReset() || pSocket->HasExpired()) {

                    DPRINTF("%#x: %#x: ********* socket %#x is closed already\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("K-A connection %#x [%#x/%d] is reset (%B) or expired (%B)\n",
                                pSocket,
                                pSocket->GetSocket(),
                                pSocket->GetSourcePort(),
                                pSocket->IsReset(),
                                pSocket->HasExpired()
                                ));

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                } else {

                    DPRINTF("%#x: %#x: *** matched %#x, %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags()
                            );

                    break;
                }
            }
            if (pSocket == NULL) {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("no available K-A connections\n"
                            ));

                /*
                //
                // if all connections are in use as keep-alive connections then
                // since we're here, we want a keep-alive connection that doesn't
                // match the currently available keep-alive connections. Terminate
                // the oldest keep-alive connection (at the head of the queue)
                // and generate a new connection
                //

                LockSerializedList(&m_KeepAliveList);
                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
                    pSocket->Destroy();
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                }
                UnlockSerializedList(&m_KeepAliveList);
                */
            }
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("%d waiters for K-A connection to %q\n",
                        ElementsOnSerializedList(&m_KeepAliveList),
                        GetHostName()
                        ));

        }
    }

    //
    // if we found a matching keep-alive connection or we are not limiting
    // connections then we're done
    //

    if ((pSocket != NULL) || UnlimitedConnections()) {

        INET_ASSERT(error == ERROR_SUCCESS);

        if (pSocket != NULL && fExemptConnLimit)
        {
            // Passport grabs a connection from the pool, so we need to bump up the availabilty to let 
            // others get one more. Effectively we excempt the passport connection
            if (!UnlimitedConnections() /*&& !pSocket->ConnLimitExempted()*/) 
            {
                // we convert a connection that is subjecting to connection limit to one that isn't,
                // therefore, we need to up the availability by 1.
                pSocket->ExemptConnLimit();
                ++m_ConnectionsAvailable;
            }
        }
        goto exit;
    }

    //
    // no keep-alive connections matched, or there are already waiters for
    // keep-alive connections
    //

    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

    if (m_ConnectionsAvailable > 0) {

        if (fsm.m_lpszSecureTunnelHost)
            goto exit;  // don't create a connection here for SSL tunneling

        //
        // can create a connection
        //

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("OK to create new connection\n"
                    ));

        DPRINTF("%#x: %#x: *** %s OK to create connection %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                GetHostName(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        if (!fExemptConnLimit) // make this a freeby for passport connection
        {
            --m_ConnectionsAvailable;
        }

    } else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
        error = ERROR_INTERNET_TIMEOUT;
    } else {
        
        //
        // if there are keep-alive connections but no keep-alive waiters
        // then either we don't want a keep-alive connection, or the ones
        // available don't match our requirements.
        // If we need a connection of a different type - e.g. SSL when all
        // we have is non-SSL then close a connection & generate a new one.
        // If we need a non-keep-alive connection then its okay to return
        // a current keep-alive connection, the understanding being that the
        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
        // will add Connection: Close header (HTTP 1.1)
        //

        //
        // BUGBUG - what about waiters for non-keep-alive connections?
        //
        // scenario - limit of 1 connection:
        //
        //  A. request for k-a
        //      continue & create connection
        //  B. request non-k-a
        //      none available; wait
        //  C. release k-a connection; unblock sync waiter B
        //  D. request non-k-a
        //      k-a available; return it; caller converts to non-k-a
        //  E. unblocked waiter B request non-k-a
        //      none available; wait
        //
        // If this situation continues, eventually B will time-out, whereas it
        // could have had the connection taken by D. Request D is younger and
        // therefore can afford to wait while B continues with the connection
        //

        BOOL fHaveConnection = FALSE;

        if (!bKeepAliveWaiters || (fsm.GetState() == FSM_STATE_CONTINUE)) {

            LockSerializedList(&m_KeepAliveList);
            if (ElementsOnSerializedList(&m_KeepAliveList) != 0) {
                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                fHaveConnection = TRUE;

#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE | SF_TUNNEL)

                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;

                if ((dwSocketTypeFlags ^ dwRequestTypeFlags)
                    || (fsm.m_nPort != pSocket->GetPort())) {

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("different socket types (%#x, %#x) or ports (%d, %d) requested\n",
                                fsm.m_dwSocketFlags,
                                pSocket->GetFlags(),
                                fsm.m_nPort,
                                pSocket->GetPort()
                                ));

                    DPRINTF("%#x: %#x: *** closing socket %#x: %#x vs. %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags(),
                            fsm.m_dwSocketFlags
                            );

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    // If we were trying to wait for established SSL tunnel,
                    // but one wasn't found, then this connection is open
                    // for anyone.
                    if (!UnlimitedConnections() && fsm.m_lpszSecureTunnelHost) {
                        ++m_ConnectionsAvailable;
                    }
                } else {

                    DPRINTF("%#x: %#x: *** returning k-a connection %#x as non-k-a\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );
                }
                CHECK_CONNECTION_COUNT();
                if (fExemptConnLimit)
                {
                    if (!UnlimitedConnections() /*&& !pSocket->ConnLimitExempted()*/) 
                    {
                        // we convert a connection that is subjecting to connection limit to one that isn't,
                        // therefore, we need to up the availability by 1.
                        
                        if (pSocket)
                        {
                            pSocket->ExemptConnLimit();
                        }
                        
                        ++m_ConnectionsAvailable;
                    }
                }
            }
            UnlockSerializedList(&m_KeepAliveList);
            if (fHaveConnection) {
                goto exit;
            }
        }

        DPRINTF("%#x: %#x: blocking %s FSM %#x state %s %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                Fsm->MapType(),
                Fsm,
                Fsm->MapState(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        //
        // we have to wait for a connection to become available. If we are an
        // async request then we queue this FSM & return the thread to the pool
        // or, if app thread, return pending indication to the app. If this is
        // a sync request (in an app thread) then we block on an event waiting
        // for a connection to become available
        //

        if (fExemptConnLimit)
        {
            goto exit;
        }

        if (!bAsyncRequest) {

            //
            // create unnamed, initially unsignalled, auto-reset event
            //

            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (hEvent == NULL) {
                error = GetLastError();
                goto exit;
            }
        }

        CConnectionWaiter * pWaiter;

#if INET_DEBUG

        for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
             pWaiter != (CConnectionWaiter *)m_Waiters.Self();
             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

            INET_ASSERT(pWaiter->Id() != (DWORD_PTR)(bAsyncRequest ? (DWORD_PTR)Fsm : lpThreadInfo->ThreadId));
        }
#endif

        pWaiter = new CConnectionWaiter(&m_Waiters,
                                        !bAsyncRequest,
                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                                            ? TRUE
                                            : FALSE,
                                        bAsyncRequest
                                            ? (DWORD_PTR)Fsm
                                            : lpThreadInfo->ThreadId,
                                        hEvent,

                                        //
                                        // priority in request handle object
                                        // controls relative position in list
                                        // of waiters
                                        //

                                        ((HTTP_REQUEST_HANDLE_OBJECT *)
                                            lpThreadInfo->hObjectMapped)->
                                                GetPriority()
                                        );

        DPRINTF("%#x: %#x: new waiter %#x: as=%B, K-A=%B, id=%#x, hE=%#x, pri=%d, sf=%#x, preq=%#x ssl=%s, url=%s\n",
                GetCurrentThreadId(),
                Fsm,
                pWaiter,
                bAsyncRequest,
                (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                    ? TRUE
                    : FALSE,
                bAsyncRequest
                    ? (DWORD_PTR)Fsm
                    : lpThreadInfo->ThreadId,
                hEvent,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                    GetPriority(),
                fsm.m_dwSocketFlags,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped),
                fsm.m_lpszSecureTunnelHost ? fsm.m_lpszSecureTunnelHost : "",
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetOriginalUrl()
                );

        if (pWaiter == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        if (bAsyncRequest) {

            //
            // ensure that when the FSM is unblocked normally, the new state
            // is STATE_CONTINUE
            //

            Fsm->SetState(FSM_STATE_CONTINUE);
            error = BlockWorkItem(Fsm,
                                  (DWORD_PTR)pWaiter,
                                  fsm.m_dwTimeout
                                  );
            if (error == ERROR_SUCCESS) {
                error = ERROR_IO_PENDING;
            }
        } else {
            m_Waiters.Release();
            bUnlockList = FALSE;

            DPRINTF("%#x: %#x: %s FSM %#x %s waiting %d msec\n",
                    GetCurrentThreadId(),
                    Fsm,
                    Fsm->MapType(),
                    Fsm,
                    Fsm->MapState(),
                    fsm.m_dwTimeout
                    );

            DWORD dwWaitTime = fsm.m_dwTimeout - fsm.GetElapsedTime();

            if ((int)dwWaitTime <= 0) {

                DEBUG_PRINT(SESSION,
                            ERROR,
                            ("SYNC wait timed out (%d mSec)\n",
                            fsm.m_dwTimeout
                            ));

                error = ERROR_INTERNET_TIMEOUT;
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("waiting %d mSec for SYNC event %#x\n",
                            dwWaitTime,
                            hEvent
                            ));

                //
                // we'd better not be doing a sync wait if we are in the
                // context of an app thread making an async request
                //

                INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                            || !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
                                hObjectMapped)->IsAsyncHandle());

                //INET_ASSERT(dwWaitTime <= 60000);

                error = WaitForSingleObject(hEvent, dwWaitTime);

                DPRINTF("%#x: %#x: sync waiter unblocked - error = %d\n",
                        GetCurrentThreadId(),
                        Fsm,
                        error
                        );

            }
            if (error == STATUS_TIMEOUT) {

                DPRINTF("%#x: %#x: %s: %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
                        GetCurrentThreadId(),
                        Fsm,
                        GetHostName(),
                        m_ConnectionsAvailable,
                        ElementsOnSerializedList(&m_KeepAliveList),
                        m_ConnectionLimit,
                        GetCurrentThreadId(),
                        Fsm->MapType(),
                        Fsm,
                        Fsm->MapState()
                        );

                RemoveWaiter(lpThreadInfo->ThreadId);
                error = ERROR_INTERNET_TIMEOUT;
            }

            BOOL bOk;

            bOk = CloseHandle(hEvent);

            INET_ASSERT(bOk);

            if (error == WAIT_OBJECT_0) {

                DPRINTF("%#x: %#x: sync requester trying again\n",
                        GetCurrentThreadId(),
                        Fsm
                        );

                fsm.SetState(FSM_STATE_CONTINUE);
                goto try_again;
            }
        }
    }

exit:

    //
    // if we are returning a (keep-alive) socket that has a different blocking
    // mode from that requested, change it
    //

    if (pSocket != NULL) {
        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("different blocking modes requested: %#x, %#x\n",
                        fsm.m_dwSocketFlags,
                        pSocket->GetFlags()
                        ));

            DPRINTF("%#x: %#x: *** changing socket %#x to %sBLOCKING\n",
                    GetCurrentThreadId(),
                    Fsm,
                    pSocket->GetSocket(),
                    fsm.m_dwSocketFlags & SF_NON_BLOCKING ? "NON-" : ""
                    );

            if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags & SF_NON_BLOCKING);
            }
        }
        *fsm.m_lplpSocket = pSocket;
    }

    if (bUnlockList) {
        m_Waiters.Release();
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DPRINTF("%#x: %#x: %s: %d+%d/%d: get: %d, %#x, %d\n",
            GetCurrentThreadId(),
            Fsm,
            GetHostName(),
            m_ConnectionsAvailable,
            ElementsOnSerializedList(&m_KeepAliveList),
            m_ConnectionLimit,
            error,
            pSocket ? pSocket->GetSocket() : 0,
            m_Waiters.Count()
            );

    PERF_LEAVE(GetConnection);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CServerInfo::ReleaseConnection(
    IN ICSocket * lpSocket OPTIONAL,
    IN BOOL fExemptConnLimit
    )

/*++

Routine Description:

    Returns a keep-alive connection to the pool, or allows another requester to
    create a connection

Arguments:

    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::ReleaseConnection",
                 "{%q [%d+%d/%d]} %#x [%#x]",
                 GetHostName(),
                 AvailableConnections(),
                 KeepAliveConnections(),
                 ConnectionLimit(),
                 lpSocket,
                 lpSocket ? lpSocket->GetSocket() : 0
                 ));

    PERF_ENTER(ReleaseConnection);

    DWORD error = ERROR_SUCCESS;
    BOOL bRelease = FALSE;

    m_Waiters.Acquire();

    //
    // quite often (at least with catapult proxy based on IIS) the server may
    // drop the connection even though it indicated it would keep it open. This
    // typically happens on 304 (frequent) and 302 (less so) responses. If we
    // determine the server has dropped the connection then throw it away and
    // allow the app to create a new one
    //

    if (lpSocket != NULL) {
        if (lpSocket->IsClosed() || lpSocket->IsReset()) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("socket %#x already dead - throwing it out\n",
                        lpSocket->GetSocket()
                        ));

            DPRINTF("%#x: socket %#x: already reset\n",
                    GetCurrentThreadId(),
                    lpSocket->GetSocket()
                    );

//dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
            BOOL bDestroyed = lpSocket->Dereference();

            INET_ASSERT(bDestroyed);

            lpSocket = NULL;
        } else {

            //
            // if we are returning a keep-alive socket, put it in non-blocking
            // mode if not already. Typically, Internet Explorer uses non-blocking
            // sockets. In the infrequent cases where we want a blocking socket
            // - mainly when doing java downloads - we will convert the socket
            // to blocking mode when we get it from the pool
            //

            if (!lpSocket->IsNonBlocking()) {

                DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
                        GetCurrentThreadId(),
                        lpSocket->GetSocket()
                        );

                if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                    lpSocket->SetNonBlockingMode(TRUE);
                }
            }
        }
    }
    if (lpSocket != NULL) {

        DPRINTF("%#x: releasing K-A %#x (%d+%d/%d)\n",
                GetCurrentThreadId(),
                lpSocket ? lpSocket->GetSocket() : 0,
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        INET_ASSERT(lpSocket->IsOpen());
        INET_ASSERT(!lpSocket->IsOnList());
        //INET_ASSERT(!lpSocket->IsReset());

        lpSocket->SetKeepAlive();

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("releasing keep-alive socket %#x\n",
                    lpSocket->GetSocket()
                    ));

        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);

        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));

        InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List());

        if (lpSocket->ConnLimitExempted())
        {
            lpSocket->ResetExemptFlag();
            --m_ConnectionsAvailable;
        
            if (KeepAliveConnections() > ConnectionLimit())
            {
                INET_ASSERT(KeepAliveConnections() - ConnectionLimit() == 1);

                ICSocket* pOldestSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                pOldestSocket->SetLinger(FALSE, 0);
                pOldestSocket->Shutdown(2);
                pOldestSocket->Destroy();
                pOldestSocket = NULL;
            }
        }

        lpSocket = NULL;

        INET_ASSERT(UnlimitedConnections()
           ? TRUE
           : (KeepAliveConnections() <= ConnectionLimit()));

        bRelease = TRUE;
    } else {

        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
                GetCurrentThreadId(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        if (!UnlimitedConnections() && !fExemptConnLimit) {
            ++m_ConnectionsAvailable;
        }

        CHECK_CONNECTION_COUNT();

        bRelease = TRUE;
    }
    if (bRelease && !UnlimitedConnections() && !fExemptConnLimit) {

        CHECK_CONNECTION_COUNT();

        CConnectionWaiter * pWaiter = (CConnectionWaiter *)m_Waiters.RemoveHead();

        if (pWaiter != NULL) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("unblocking %s waiter %#x, pri=%d\n",
                        pWaiter->IsSync() ? "SYNC" : "ASYNC",
                        pWaiter->Id(),
                        pWaiter->GetPriority()
                        ));

            DPRINTF("%#x: Unblocking %s connection waiter %#x, pri=%d\n",
                    GetCurrentThreadId(),
                    pWaiter->IsSync() ? "Sync" : "Async",
                    pWaiter->Id(),
                    pWaiter->GetPriority()
                    );

            if (pWaiter->IsSync()) {
                pWaiter->Signal();
            } else {

                DWORD n = UnblockWorkItems(1, (DWORD_PTR)pWaiter, ERROR_SUCCESS);

                //INET_ASSERT(n == 1);
            }
            delete pWaiter;
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no waiters\n"
                        ));

            DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
                    GetCurrentThreadId()
                    );

        }
    } else {

        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
                GetCurrentThreadId()
                );

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("bRelease = %B, UnlimitedConnections() = %B\n",
                    bRelease,
                    UnlimitedConnections()
                    ));

    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("avail+k-a/limit = %d+%d/%d\n",
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }

    m_Waiters.Release();

    PERF_LEAVE(ReleaseConnection);

    DEBUG_LEAVE(error);

    DPRINTF("%#x: %s: %d+%d/%d: rls %#x: %d, %d\n",
            GetCurrentThreadId(),
            GetHostName(),
            AvailableConnections(),
            KeepAliveConnections(),
            ConnectionLimit(),
            lpSocket ? lpSocket->GetSocket() : 0,
            error,
            m_Waiters.Count()
            );

    return error;
}

#endif // NEW_CONNECTION_SCHEME


VOID
CServerInfo::RemoveWaiter(
    IN DWORD_PTR dwId
    )

/*++

Routine Description:

    Removes a CConnectionWaiter corresponding to the FSM

Arguments:

    dwId    - waiter id to match

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::RemoveWaiter",
                 "%#x",
                 dwId
                 ));

    m_Waiters.Acquire();

    CConnectionWaiter * pWaiter;
    BOOL found = FALSE;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->Id() == dwId) {
            m_Waiters.Remove((CPriorityListEntry *)pWaiter);
            delete pWaiter;
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

    //INET_ASSERT(found);

    DEBUG_LEAVE(0);
}

//
// private CServerInfo methods
//


ICSocket *
CServerInfo::FindKeepAliveConnection(
    IN DWORD dwSocketFlags,
    IN INTERNET_PORT nPort,
    IN LPSTR pszTunnelServer
    )

/*++

Routine Description:

    Find a keep-alive connection with the requested attributes and port number

Arguments:

    dwSocketFlags   - socket type flags (e.g. SF_SECURE)

    nPort           - port to server

    pszTunnelServer - hostname of server through SSL tunnel, or
                      NULL if not checked.

Return Value:

    ICSocket *

--*/

{
    DPRINTF("%#x: *** looking for K-A connection\n", GetCurrentThreadId());

    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "CServerInfo::FindKeepAliveConnection",
                 "{%q} %#x, %d",
                 GetHostName(),
                 dwSocketFlags,
                 nPort
                 ));

    ICSocket * pSocket = NULL;
    BOOL bFound = FALSE;

    //
    // don't check whether socket is non-blocking - we only really want to match
    // on secure/non-secure. Possible flags to check on are:
    //
    //  SF_ENCRYPT          - should be subsumed by SF_SECURE
    //  SF_DECRYPT          - should be subsumed by SF_SECURE
    //  SF_NON_BLOCKING     - this isn't criterion for match
    //  SF_CONNECTIONLESS   - not implemented?
    //  SF_AUTHORIZED       - must be set if authorized & in pool
    //  SF_SECURE           - opened for SSL/PCT if set
    //  SF_KEEP_ALIVE       - must be set
    //  SF_TUNNEL           - must be set if we're looking for a CONNECT tunnel to proxy
    //

    dwSocketFlags &= ~SF_NON_BLOCKING;

    LockSerializedList(&m_KeepAliveList);

    PLIST_ENTRY pEntry;

    for (pEntry = HeadOfSerializedList(&m_KeepAliveList);
         pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
         pEntry = pEntry->Flink) {

        pSocket = ContainingICSocket(pEntry);

        INET_ASSERT(pSocket->IsKeepAlive());

        //
        // We make sure the socket we request is the correct socket,
        //  Match() is a bit confusing and needs a bit of explaining,
        //  Match IS NOT AN EXACT MATCH, it mearly checks to make sure 
        //  that the requesting flags (dwSocketFlags) are found in the 
        //  socket flags.  So this can lead to a secure socket being returned
        //  on a non-secure open request, now realistically this doesn't happen
        //  because of the port number.  But in the case of tunnelling this may be
        //  an issue, so we add an additional check to make sure that we only
        //  get a tunneled socket to a proxy if we specifically request one.
        //

        if (pSocket->Match(dwSocketFlags)
        && (pSocket->GetPort() == nPort)
        &&  pSocket->MatchTunnelSemantics(dwSocketFlags, pszTunnelServer)) {
            RemoveFromSerializedList(&m_KeepAliveList, pSocket->List());

            INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, pSocket->List()));

            bFound = TRUE;

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("returning keep-alive socket %#x\n",
                        pSocket->GetSocket()
                        ));

            DPRINTF("%#x: *** %s keep-alive connection %#x (%d/%d), wantf=%#x, gotf=%#x\n",
                    GetCurrentThreadId(),
                    GetHostName(),
                    pSocket->GetSocket(),
                    AvailableConnections(),
                    ConnectionLimit(),
                    dwSocketFlags,
                    pSocket->GetFlags()
                    );

            break;
        }
    }
    UnlockSerializedList(&m_KeepAliveList);
    if (!bFound) {
        pSocket = NULL;
    }

    DEBUG_LEAVE(pSocket);

    return pSocket;
}


BOOL
CServerInfo::KeepAliveWaiters(
    VOID
    )

/*++

Routine Description:

    Determine if any of the waiters on the list are for keep-alive connections

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "CServerInfo::KeepAliveWaiters",
                 NULL
                 ));

    BOOL found = FALSE;
    CConnectionWaiter * pWaiter;

    m_Waiters.Acquire();
    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->IsKeepAlive()) {
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

    DEBUG_LEAVE(found);

    return found;
}

#ifdef NEW_CONNECTION_SCHEME
//
//
//BOOL
//CServerInfo::RunOutOfConnections(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Determines whether we have been run out of connections. Criteria for being
//    out of connections is: no available connections or keep-alive connections
//    and no recorded connection activity within GlobalConnectionInactiveTimeout
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    BOOL
//        TRUE    - we are out of connections
//
//        FALSE   - not
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Bool,
//                 "CServerInfo::RunOutOfConnections",
//                 NULL
//                 ));
//
//    BOOL bOut = FALSE;
//
//    if ((TotalAvailableConnections() == 0)
//    && (GetLastActiveTime() != 0)
//    && !ConnectionActivity()) {
//
//        DPRINTF("%#x: >>>>>>>> Run out of connections. Last activity %d mSec ago. Create new\n",
//                GetCurrentThreadId(),
//                (GetLastActiveTime() == 0)
//                    ? -1
//                    : (GetTickCount() - GetLastActiveTime())
//                );
//
//        INET_ASSERT(!UnlimitedConnections());
//
//        DEBUG_PRINT(SESSION,
//                    WARNING,
//                    ("out of connections! Last activity %d mSec ago. Creating new\n",
//                    (GetLastActiveTime() == 0)
//                        ? -1
//                        : (GetTickCount() - GetLastActiveTime())
//                    ));
//
//        bOut = TRUE;
//    } else if (TotalAvailableConnections() == 0) {
//
//        DPRINTF("%#x: no connections, last activity %d mSec ago\n",
//                GetCurrentThreadId(),
//                (GetLastActiveTime() == 0)
//                    ? -1
//                    : (GetTickCount() - GetLastActiveTime())
//                );
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("no connections, last activity %d mSec ago\n",
//                    (GetLastActiveTime() == 0)
//                        ? -1
//                        : (GetTickCount() - GetLastActiveTime())
//                    ));
//
//    }
//
//    DEBUG_LEAVE(bOut);
//
//    return bOut;
//}
//
#endif // NEW_CONNECTION_SCHEME


VOID
CServerInfo::UpdateConnectionLimit(
    VOID
    )

/*++

Routine Description:

    Change connection limit to new limit

    Assumes: 1. Caller has acquired this object before calling this function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectionLimit",
                 "{%q: %d=>%d (%d+%d)}",
                 GetHostName(),
                 ConnectionLimit(),
                 GetNewLimit(),
                 AvailableConnections(),
                 KeepAliveConnections()
                 ));

    LONG difference = GetNewLimit() - ConnectionLimit();

    //
    // BUGBUG - only handling increases in limit for now
    //

    INET_ASSERT(difference > 0);

    if (difference > 0) {
        m_ConnectionsAvailable += difference;
    }
    m_ConnectionLimit = m_NewLimit;

    DEBUG_PRINT(SESSION,
                INFO,
                ("%q: new: %d+%d/%d\n",
                GetHostName(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Purges any timed-out keep-alive connections

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
//dprintf("%#x PurgeKeepAlives(%d)\n", GetCurrentThreadId(), dwForce);
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::PurgeKeepAlives",
                 "{%q [ref=%d, k-a=%d]} %s [%d]",
                 GetHostName(),
                 ReferenceCount(),
                 KeepAliveConnections(),
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (IsKeepAliveListInitialized()) {

        INET_ASSERT(ReferenceCount() >= 1);

        m_Waiters.Acquire();
        LockSerializedList(&m_KeepAliveList);

        PLIST_ENTRY last = (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
        DWORD ticks = GetTickCountWrap();

        for (PLIST_ENTRY pEntry = HeadOfSerializedList(&m_KeepAliveList);
            pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
            pEntry = last->Flink) {

            ICSocket * pSocket = ContainingICSocket(pEntry);
            BOOL bDelete;

            if (pSocket->IsReset()) {
//dprintf("%q: socket %#x/%d CLOSE-WAIT\n", GetHostName(), pSocket->GetSocket(), pSocket->GetSourcePort());
                bDelete = TRUE;
            } else if (dwForce == PKA_NO_FORCE) {
                bDelete = pSocket->HasExpired(ticks);
            } else if (dwForce == PKA_NOW) {
                bDelete = TRUE;
            } else if (dwForce == PKA_AUTH_FAILED) {
                bDelete = pSocket->IsAuthorized();
            }
            if (bDelete) {
//dprintf("%q: socket %#x/%d. Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
//        GetHostName(),
//        pSocket->GetSocket(),
//        pSocket->GetSourcePort(),
//        pSocket->IsReset(),
//        pSocket->HasExpired(ticks),
//        (dwForce == PKA_NOW),
//        (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
//        );

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("purging keep-alive socket %#x/%d: Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->IsReset(),
                            pSocket->HasExpired(ticks),
                            (dwForce == PKA_NOW),
                            (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
                            ));

                RemoveFromSerializedList(&m_KeepAliveList, pEntry);

                BOOL bDestroyed;

                bDestroyed = pSocket->Dereference();

                INET_ASSERT(bDestroyed);

                if (!UnlimitedConnections()) {
                    ++m_ConnectionsAvailable;

                    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

                }

            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("socket %#x/%d expires in %d mSec\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->GetExpiryTime() - ticks
                            ));

                last = pEntry;
            }
        }

        UnlockSerializedList(&m_KeepAliveList);
        m_Waiters.Release();
    }

    DEBUG_LEAVE(0);
}

//
// friend functions
//


CServerInfo *
ContainingServerInfo(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of CServerInfo given address of m_List

Arguments:

    lpAddress   - address of m_List

Return Value:

    CServerInfo *

--*/

{
    return CONTAINING_RECORD(lpAddress, CServerInfo, m_List);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\serialst.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>

#if INET_DEBUG

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    InitializeCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        INET_ASSERT(IsListEmpty(&SerializedList->List));

    }
    DeleteCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->LockCount >= 0);

    EnterCriticalSection(&SerializedList->Lock);
    if (SerializedList->LockCount != 0) {

        INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());

    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    INET_ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    LeaveCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, FALSE);
    }
    InsertHeadList(&SerializedList->List, Entry);
    ++SerializedList->ElementCount;

    INET_ASSERT(SerializedList->ElementCount > 0);

    UnlockSerializedList(SerializedList);
}


DEBUG_FUNCTION
VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, FALSE);
    }
    InsertTailList(&SerializedList->List, Entry);
    ++SerializedList->ElementCount;

    INET_ASSERT(SerializedList->ElementCount > 0);

    UnlockSerializedList(SerializedList);
}


VOID
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    None.

--*/

{
    INET_ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, TRUE);
    }

    INET_ASSERT(SerializedList->ElementCount > 0);

    RemoveEntryList(Entry);
    --SerializedList->ElementCount;
    Entry->Flink = NULL;
    Entry->Blink = NULL;
    UnlockSerializedList(SerializedList);
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    LockSerializedList(SerializedList);

    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    BOOL empty;

    if (IsListEmpty(&SerializedList->List)) {

        INET_ASSERT(SerializedList->ElementCount == 0);

        empty = TRUE;
    } else {

        INET_ASSERT(SerializedList->ElementCount != 0);

        empty = FALSE;
    }

    UnlockSerializedList(SerializedList);

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    LockSerializedList(SerializedList);

    BOOL result;

    __try {
        result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(SERIALST,
                    FATAL,
                    ("List @ %#x (%d elements) is bad\n",
                    SerializedList,
                    SerializedList->ElementCount
                    ));

        result = FALSE;
    }
    ENDEXCEPT
    UnlockSerializedList(SerializedList);

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#endif // INET_DEBUG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            entry = (LPVOID)HeadOfSerializedList(SerializedList);
            RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
        } else {
            entry = NULL;
        }
        UnlockSerializedList(SerializedList);
    } else {
        entry = NULL;
    }
    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            entry = (LPVOID)TailOfSerializedList(SerializedList);
            RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
        } else {
            entry = NULL;
        }
        UnlockSerializedList(SerializedList);
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                entry != (PLIST_ENTRY)SlSelf(SerializedList);
                entry = entry->Flink) {

                if (entry == Entry) {
                    onList = TRUE;
                    break;
                }
            }
        }
        UnlockSerializedList(SerializedList);
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\ssocket.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ssocket.cxx

Abstract:

    Contains secure sockets functions and ICSecureSocket methods

    Contents:
        SecurityPkgInitialize
        ReadCertificateIntoCertInfoStruct
        ChkCertificateCommonNameIsValid
        ChkCertificateExpired
        ICSecureSocket::ICSecureSocket
        ICSecureSocket::~ICSecureSocket
        ICSecureSocket::Connect
        CFsm_SecureConnect::RunSM
        ICSecureSocket::Connect_Fsm
        ICSecureSocket::SecureHandshakeWithServer
        CFsm_SecureHandshake::RunSM
        ICSecureSocket::SecureHandshake_Fsm
        ICSecureSocket::NegotiateSecConnection
        CFsm_SecureNegotiate::RunSM
        ICSecureSocket::SecureNegotiate_Fsm
        ICSecureSocket::SSPINegotiateLoop
        CFsm_NegotiateLoop::RunSM
        ICSecureSocket::NegotiateLoop_Fsm
        ICSecureSocket::Disconnect
        ICSecureSocket::Send
        CFsm_SecureSend::RunSM
        ICSecureSocket::Send_Fsm
        ICSecureSocket::Receive
        CFsm_SecureReceive::RunSM
        ICSecureSocket::Receive_Fsm
        ICSecureSocket::SetHostName
        (ICSecureSocket::EncryptData)
        (ICSecureSocket::DecryptData)
        (ICSecureSocket::TerminateSecConnection)
        ICSecureSocket::GetCertInfo

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <ierrui.hxx>

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <softpub.h>

}

//
//
//  List of encryption packages:  PCT, SSL, etc
//

//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//

// BUGBUG:  Don't change the order of the packages below.  some old SSL2 sites deny the UNISP
// provider, and if we walk down the list to PCT1 or SSL3, things hang.
struct _SEC_PROVIDER SecProviders[] =
{
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT | ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_CLIENTS, NULL,
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL2_CLIENT, NULL,
//    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_PCT1_CLIENT, NULL,
//    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL3_CLIENT, NULL,
    NULL,        INVALID_CRED_VALUE , FALSE,        FALSE, 0
};



//
// dwEncFlags - Global Status of calling and initalizing the SCHANNEL and various
//   other encyrption support DLL & APIs.  Failure in the process will
//   cause this to be set to an error state, success prevents re-initalizaiton
//

DWORD dwEncFlags = 0;

//
// GlobalSecureProtocolsCopy - Copy of the current protocols the user wants to use
//   changing them allows us to restrict to specific protocols
//
DWORD GlobalSecureProtocolsCopy = DEFAULT_SECURE_PROTOCOLS;


#ifdef SECPKG_ATTR_PROTO_INFO
PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo);
#endif

//
// general security package functions
//
BOOL
SecurityPkgInitialize(
    BOOL fForce
    )
/*++

Routine Description:

    This function finds a list of security packages that are supported
    on the client's machine, check if pct or ssl is supported, and
    create a credential handle for each supported pkg.

Arguments:

    None

Return Value:

    TRUE if at least one security pkg is found; otherwise FALSE

--*/
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;

    SCHANNEL_CRED DefaultCredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     SP_PROT_CLIENTS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                    };

    //
    // Set new DWORD for our copy of the global protocol settings.
    //
    bool    fSame = (GlobalSecureProtocolsCopy==GlobalSecureProtocols);
    GlobalSecureProtocolsCopy = GlobalSecureProtocols;

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //

    if ( dwEncFlags == ENC_CAPS_NOT_INSTALLED )
       return FALSE;
    else if ((dwEncFlags&ENC_CAPS_TYPE_MASK) && fSame && !fForce)
       return TRUE;

    //
    //  Initialize dwEncFlags
    //

    dwEncFlags = ENC_CAPS_NOT_INSTALLED;

    //
    //  Check if at least one security package is supported
    //


    scRet = g_EnumerateSecurityPackages( &cPackages,
                                         &pPackageInfo );

    if ( scRet != STATUS_SUCCESS )
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("EnumerateSecurityPackages failed, error %lx\n",
                    scRet
                    ));

        SetLastError( scRet );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  Use only if the package name is the PCT/SSL package
        //

        fCapabilities = pPackageInfo[i].fCapabilities;

        if ( fCapabilities & SECPKG_FLAG_STREAM )
        {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //

            if ( fCapabilities & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCapabilities & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Check if the pkg matches one of our known packages
            //

            for ( j = 0; SecProviders[j].pszName != NULL; j++ )
            {
                if ( !stricmp( pPackageInfo[i].Name, SecProviders[j].pszName ) )
                {
                    CredHandle OldCred;
                    PVOID pCredData = NULL;

                    //
                    //  Create a credential handle for each supported pkg
                    //

                    INET_ASSERT((SecProviders[j].dwFlags & ENC_CAPS_SCHANNEL_CREDS));

                    pCredData = &DefaultCredData;

                    if (SecProviders[j].pCertCtxt != NULL) {
                        DefaultCredData.cCreds = 1;
                        DefaultCredData.paCred = &SecProviders[j].pCertCtxt;
                    }

                    //
                    // Enable Supported protocols in the Default Cred Data, then acquire the Credential
                    //

                    DefaultCredData.grbitEnabledProtocols = (GlobalSecureProtocols & SecProviders[j].dwProtocolFlags);

                    OldCred.dwUpper = SecProviders[j].hCreds.dwUpper;
                    OldCred.dwLower = SecProviders[j].hCreds.dwLower;

                    // Zero out previous credentials
                    SecProviders[j].hCreds.dwUpper = SecProviders[j].hCreds.dwLower = 0;

                    scRet = g_AcquireCredentialsHandle(
                                      NULL,
                                      SecProviders[j].pszName, // Package
                                      SECPKG_CRED_OUTBOUND,
                                      NULL,
                                      pCredData,
                                      NULL,
                                      NULL,
                                      &(SecProviders[j].hCreds), // Handle
                                      &tsExpiry );

                    if(!IS_CRED_INVALID(&OldCred))
                    {
                        g_FreeCredentialsHandle(&OldCred);
                    }

                    DefaultCredData.cCreds = 0;
                    DefaultCredData.paCred = NULL;

                    if ( scRet != STATUS_SUCCESS )
                    {
                        DEBUG_PRINT(API,
                                    WARNING,
                                    ("AcquireCredentialHandle failed, error %lx\n",
                                    scRet
                                    ));

                        SecProviders[j].fEnabled = FALSE;

                        SecProviders[j].hCreds.dwUpper = 0xffffffff;
                        SecProviders[j].hCreds.dwLower = 0xffffffff;


                    }
                    else
                    {
                        DEBUG_PRINT(
                             API,
                             INFO,
                             ("AcquireCredentialHandle() supports %s, acquires %x:%x\n",
                             SecProviders[j].pszName,
                             SecProviders[j].hCreds.dwUpper,
                             SecProviders[j].hCreds.dwLower
                             ));

                        SecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        dwEncFlags |= SecProviders[j].dwFlags;
                    }
                }
            }
        }
    }

    if ( !cProviders )
    {
        //
        //  No security packages were found, return FALSE to caller
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("No security packages were found, error %lx\n",
                    SEC_E_SECPKG_NOT_FOUND
                    ));

        g_FreeContextBuffer( pPackageInfo );

        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        return FALSE;
    }

    //
    //  Successfully found a security package(s)
    //

    return TRUE;
}


DWORD
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo)
{
    SECURITY_STATUS      scRet;

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     &pInfo->pCertificate );

    if (scRet != ERROR_SUCCESS)
    {

        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet);

    }

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_CONNECTION_INFO,
                                     &pInfo->dwProtocol );

    if (scRet != ERROR_SUCCESS)
    {

        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet);
    }

    pInfo->dwSize = sizeof(INTERNET_SECURITY_INFO);

    return ERROR_SUCCESS;
}

// Helper function to detect Fortezza connections.
BOOL IsCertificateFortezza(PCCERT_CONTEXT pCertContext)
{
    INET_ASSERT(pCertContext != NULL);
    if (pCertContext == NULL)
        return FALSE;

    LPSTR pszOid = pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if (pszOid)
    {
        if (strcmp(pszOid, szOID_INFOSEC_mosaicUpdatedSig) == 0 ||
             strcmp(pszOid, szOID_INFOSEC_mosaicKMandUpdSig) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


LONG WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD)
/*++

Routine Description:

    Wininet's wrapper for secure channel WinVerifyTrust calls.

Arguments:

    hWnd - in case WinVerifyTrust needs to do UI.
    pWTD - pointer to WINTRUST_DATA containing details about the
           secure channel. Passed to WinVerifyTrust.
Return Value:

    WIN32 error code.

--*/
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    LONG  lResult;
    BOOL  bFortezza;
    GUID  gHTTPS = HTTPSPROV_ACTION;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }
    bFortezza = IsCertificateFortezza(pWTD->pCert->psCertContext);

    if (bFortezza && g_CryptInstallDefaultContext == NULL)
    {
        // HACK: we have no way to verify a connection without
        // a crypt32 which has the new APIs exposed. Till IE5 picks up
        // the new crypto bits we will assume Fortezza connections
        // verify correctly.
        lResult = ERROR_SUCCESS;
    }
    else
    {
        HCRYPTDEFAULTCONTEXT hCryptDefaultContext = NULL;

        if (bFortezza)
        {
            if (!g_CryptInstallDefaultContext(
                        GlobalFortezzaCryptProv,
                        CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                        szOID_INFOSEC_mosaicUpdatedSig,         // check with John Banes
                        0,                                      // dwFlags
                        NULL,                                   // pvReserved
                        &hCryptDefaultContext
                        ))
            {
                lResult = GetLastError();
                goto quit;
            }
        }

        lResult = g_WinVerifyTrust(hwnd, &gHTTPS, pWTD);

        DEBUG_PUT(("WinVerifyTrust returned: %x\n", lResult));

        if (hCryptDefaultContext)
        {
            // Ignore error code while freeing since we can't do anything
            // meaningful about it here.
            BOOL bResult;
            bResult = g_CryptUninstallDefaultContext(
                        hCryptDefaultContext,
                        0,
                        NULL);
            INET_ASSERT(bResult);
        }
    }

quit:

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }
    return lResult;
}


//
// ICSecureSocket methods
//


ICSecureSocket::ICSecureSocket(
    IN DWORD dwErrorFlags,
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    ICSecureSocket constructor

Arguments:

    tScheme - which protocol scheme we are creating the socket for

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::ICSecureSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_SECURE_SOCKET();

    m_hContext.dwLower = m_hContext.dwUpper = 0;
    m_dwProviderIndex = 0;
    m_dwFlags |= SF_SECURE;
    m_dwErrorFlags = dwErrorFlags;
    m_lpszHostName = NULL;
    m_pdblbufBuffer = NULL;
    m_pSecurityInfo = NULL;

    DEBUG_LEAVE(0);
}


ICSecureSocket::~ICSecureSocket()

/*++

Routine Description:

    ICSecureSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::~ICSecureSocket",
                 "{%#x [%q, sock=%#x, port=%d]}",
                 this,
                 GetHostName(),
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_SECURE_SOCKET();
    INET_ASSERT(IsSecure());

    if (m_pdblbufBuffer != NULL) {
        delete m_pdblbufBuffer;
    }

    // Free security context associated with this object if it's
    // still allocated.
    TerminateSecConnection();


    /* SCLE ref */
    SetSecurityEntry(NULL);
    if (m_lpszHostName != NULL) {
        m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);
        INET_ASSERT(m_lpszHostName == NULL);
    }
    //if ( _pCertChainList )
    //    delete _pCertChainList;

    DEBUG_LEAVE(0);
}


DWORD
ICSecureSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate secure connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureConnect(Timeout,
                                               Retries,
                                               dwFlags,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureConnect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureConnect * stateMachine = (CFsm_SecureConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Connect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Connect_Fsm(
    IN CFsm_SecureConnect * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureConnect & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto connect_continue;

        case FSM_STATE_3:
            goto negotiate_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    m_dwProviderIndex = 0;
    //SetNonSecure();

    //
    // Hack for SSL2 Client Hello, set to FALSE,
    //  but if we fail on the first recv, fReOpenSocket
    //  is set to TRUE.
    //

    do {

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Connect(fsm.m_Timeout, fsm.m_Retries, fsm.m_dwFlags);

connect_continue:

        if (error != ERROR_SUCCESS) {
            break;
        }
        if (m_dwFlags & SF_ENCRYPT) {
            fsm.SetFunctionState(FSM_STATE_3);
            error = SecureHandshakeWithServer(fsm.m_dwFlags, &fsm.m_bAttemptReconnect);
            if (error == ERROR_IO_PENDING) {
                break;
            }

negotiate_continue:

            //
            // SSL2 hack for old IIS servers.
            //  We re-open the socket, and call again.
            //

            if ((error != ERROR_SUCCESS) && fsm.m_bAttemptReconnect) {
                Disconnect(fsm.m_dwFlags);
            }
        }
    } while (fsm.m_bAttemptReconnect);

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        if ((error != ERROR_SUCCESS) && IsOpen()) {
            Disconnect(fsm.m_dwFlags);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshakeWithServer(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    For SSL/PCT or some secure channel this function attempts to use
    an arbitrary Socket for handshaking with a server. The assumption
    is made that caller can recall this function on failure

Arguments:

    dwFlags             -

    lpbAttemptReconnect -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "ICSecureSocket::SecureHandshakeWithServer",
                "%#x, %#x [%B]",
                dwFlags,
                lpbAttemptReconnect,
                *lpbAttemptReconnect
                ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureHandshake(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureHandshake::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureHandshake::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureHandshake * stateMachine = (CFsm_SecureHandshake *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureHandshake_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshake_Fsm(
    IN CFsm_SecureHandshake * Fsm
    )
{


    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureHandshake_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureHandshake & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSecureFlags;
    DWORD dwCertFlags;
    BOOL fErrorInvalidCa;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //INET_ASSERT(fsm.m_dwFlags & SF_ENCRYPT);
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    *fsm.m_lpbAttemptReconnect = FALSE;

    error = ERROR_SUCCESS;

    //
    // Save Off Flags in our Internal Object.
    //   Treat SF_ENCRYPT just like SF_DECRYPT
    //

    m_dwFlags |= SF_DECRYPT;
    m_dwFlags |= fsm.m_dwFlags;

    INET_ASSERT(!(m_dwFlags
                & ~(SF_NON_BLOCKING
                    | SF_SECURE
                    | SF_ENCRYPT
                    | SF_DECRYPT
                    | SF_INDICATE
                    | SF_SENDING_DATA
                    )));

    //
    // Allocate Internal Buffer for SSL/PCT data.
    //

    if (m_pdblbufBuffer == NULL) {

        BOOL fInitSuccess;

        m_pdblbufBuffer = new DBLBUFFER();
        if (m_pdblbufBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        fInitSuccess = m_pdblbufBuffer->InitBuffer(TRUE);
        if (!fInitSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    // First make sure the security dlls are loaded.
    error = LoadSecurity();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    // If the user has the Fortezza CSP but has not logged on to the card yet.
    // return back an error to indicate that we need to put up additional UI.

    // if (IsFortezzaInstalled( ) && !AttemptedFortezzaLogin( ))
    //{
    //    error = ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED;
    //    goto quit;
    //}

    //
    //  dwEncFlags is a global flag set to the
    //  supported security pkg mask
    //

    LOCK_SECURITY();

    if (dwEncFlags == ENC_CAPS_NOT_INSTALLED) {
         error = (DWORD)SEC_E_SECPKG_NOT_FOUND;
    } else if (dwEncFlags == 0) {


         //
         //  first time thru, do the load.
         //

         DEBUG_PRINT(SOCKETS,
                     INFO,
                     ("Loading security dll\n"
                     ));

        if ( !SecurityPkgInitialize() ) {
             error = GetLastError();
             UNLOCK_SECURITY();
             goto quit;
        }
    }

    UNLOCK_SECURITY();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    //
    // If we succeed in loading or and initalizing the Security DLLs, we
    //      attempt to negotiate the connection
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Negotiate secure channel\n"
                ));

    //
    // Turn of Encryption/Decryption before the handshake,
    // since the NegotiateSecConnection does its own Send and Recvs
    // of specialized data.
    //

    m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
    fsm.SetFunctionState(FSM_STATE_2);
    error = NegotiateSecConnection(fsm.m_dwFlags,
                                   fsm.m_lpbAttemptReconnect
                                   );
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_continue:

    m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    //  Find out what size Key we're using, and set the flags
    //   acordingly.
    //

    dwSecureFlags = 0;
    if ((m_pSecurityInfo && !m_pSecurityInfo->InCache()) || !IsValidCacheEntry()) {
        error = VerifyTrust();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }
    else if (m_pSecurityInfo)
    {
        // RAID 752640: Here we are sure we are talking to the same server whose certificate
        // we've verified before. However it's possible that the certificate has expired or
        // been revoked since last time we checked. Therefore if the user/app cares about 
        // certifciate expiration or revocation checking, we need to re-verify the trust.
        if (!(m_pSecurityInfo->GetSecureFlags() & 
            (SECURITY_FLAG_IGNORE_CERT_DATE_INVALID | DLG_FLAGS_SEC_CERT_DATE_INVALID)))
        {

#define SECURITY_FLAG_CHECK_EXPIRATION 0x00040000

#ifdef DBG
            OutputDebugStringA("WinInet: re-verify certificate expiration\n");
#endif
            error = ReVerifyTrust(SECURITY_FLAG_CHECK_EXPIRATION);
            if (error != ERROR_SUCCESS) 
            {
                goto quit;
            }
        }

        if (GlobalEnableRevocation && 
            !(m_pSecurityInfo->GetSecureFlags() & DLG_FLAGS_SEC_CERT_REV_FAILED))
        {
#define SECURITY_FLAG_CHECK_REVOCATION 0x00020000

#ifdef DBG
            OutputDebugStringA("WinInet: re-verify certificate revocation\n");
#endif
            error = ReVerifyTrust(SECURITY_FLAG_CHECK_REVOCATION);
            if (error != ERROR_SUCCESS) 
            {
                goto quit;
            }
        }
    }

    //
    // we've got a secure connection, set the flags.
    //

    SetSecure();

    if(m_pSecurityInfo)
    {
        INTERNET_SECURITY_INFO ciInfo;
        m_pSecurityInfo->CopyOut(ciInfo);

        if(ciInfo.dwCipherStrength < 56)
        {
            SetSecureFlags(SECURITY_FLAG_STRENGTH_WEAK);
        }
        else if (ciInfo.dwCipherStrength==80 &&
                 (ciInfo.aiCipher == CALG_SKIPJACK || ciInfo.aiCipher==CALG_TEK))
        {
            SetSecureFlags(SECURITY_FLAG_FORTEZZA);
        }
        else if(ciInfo.dwCipherStrength < 96)
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_MEDIUM);
        }
        else
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_STRONG);
        }
        if(ciInfo.pCertificate)
        {
            CertFreeCertificateContext(ciInfo.pCertificate);
            ciInfo.pCertificate = NULL;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL ICSecureSocket:: IsValidCacheEntry()
{

    INTERNET_SECURITY_INFO ciCert;
    INTERNET_SECURITY_INFO ciInfo;
    DWORD error;
    BOOL fRet = FALSE;

    ciCert.pCertificate = NULL;
    ciInfo.pCertificate = NULL;
    
    error = QuerySecurityInfo(&m_hContext, &ciCert);

    if( (error == ERROR_SUCCESS) && ciCert.pCertificate && m_pSecurityInfo)
    {
        m_pSecurityInfo->CopyOut(ciInfo);
        if(ciInfo.pCertificate->cbCertEncoded  != ciCert.pCertificate->cbCertEncoded ||
            memcmp(ciInfo.pCertificate->pbCertEncoded , ciCert.pCertificate->pbCertEncoded , ciInfo.pCertificate->cbCertEncoded))
        {
            GlobalCertCache.Remove(GetHostName());
            SECURITY_CACHE_LIST_ENTRY* pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
            (*m_ppSecurityInfo)->Release();
            *m_ppSecurityInfo = pSecurityInfo;
            pSecurityInfo->AddRef();
            SetSecurityEntry(&pSecurityInfo);
        }
        else
            fRet = TRUE;
    }

    if (ciCert.pCertificate)
    {
        CertFreeCertificateContext(ciCert.pCertificate);
    }
    
    if (ciInfo.pCertificate)
    {
        CertFreeCertificateContext(ciInfo.pCertificate);
    }
    
    return fRet;
}

DWORD ICSecureSocket::ReVerifyTrust(
    DWORD dwRecheckFlag // either SECURITY_FLAG_CHECK_EXPIRATION or 
                        //        SECURITY_FLAG_CHECK_REVOCATION
    )
{
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD error = ERROR_SUCCESS;

    HINTERNET  hInternet = NULL;
    HINTERNET  hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    DWORD dwFlags = 0;    // HTTPS policy flags to ignore errors

    INTERNET_SECURITY_INFO ciInfo;
    ciInfo.pCertificate = NULL;
    m_pSecurityInfo->CopyOut(ciInfo);

    INET_ASSERT(ciInfo.pCertificate);

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct      = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext = (CERT_CONTEXT *)ciInfo.pCertificate;
    sWTCI.chStores      = 1;
    sWTCI.pahStores     = (HCERTSTORE *)&ciInfo.pCertificate->hCertStore;

    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct   =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    
    // this function only re-validate two cert properties (exipiry & revocation), so we ask CryptNet
    // to ignore irrelavant errors here.
    polHttps.fdwChecks  = SECURITY_FLAG_IGNORE_UNKNOWN_CA |
                          SECURITY_FLAG_IGNORE_CERT_CN_INVALID |
                          ((dwRecheckFlag == SECURITY_FLAG_CHECK_EXPIRATION) ? 
                          0 : 
                          SECURITY_FLAG_IGNORE_CERT_DATE_INVALID);

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct            = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice          = WTD_UI_NONE;
    sWTD.pPolicyCallbackData = (LPVOID)&polHttps;
    sWTD.dwUnionChoice       = WTD_CHOICE_CERT;
    sWTD.pCert               = &sWTCI;
    sWTD.pwszURLReference    = NULL;
    
    if (dwRecheckFlag == SECURITY_FLAG_CHECK_REVOCATION)
    {
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
        sWTD.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL)
    {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }

    error = WinVerifySecureChannel(NULL, &sWTD);
    
    error = MapInternetError(error);

    if (lpThreadInfo != NULL) 
    {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    // Handle revocation problem as special case
    if (ERROR_INTERNET_SEC_CERT_REV_FAILED == error)
        dwFlags |= DLG_FLAGS_SEC_CERT_REV_FAILED;

    if (ERROR_SUCCESS != error &&
        (m_dwErrorFlags & INTERNET_ERROR_MASK_COMBINED_SEC_CERT))
    {
        BOOL  fCertError = FALSE;

        if (error != ERROR_INTERNET_SECURITY_CHANNEL_ERROR)
        {
            if (!(polHttps.fdwChecks & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
            {
                if (ERROR_INTERNET_SEC_CERT_DATE_INVALID == error)
                {
                    dwFlags |= DLG_FLAGS_SEC_CERT_DATE_INVALID;
                    fCertError = TRUE;
                }
                else
                {
                    // we are checking cert expiration; therefore we only expect the CERT_DATE_INVALID
                    // error if WinVerifyTrust fails.
                    INET_ASSERT(FALSE);
                }
            }
            else if (sWTD.fdwRevocationChecks == WTD_REVOKE_WHOLECHAIN)
            {
                if (ERROR_INTERNET_SEC_CERT_REVOKED == error)
                {
                    dwFlags = 0;
                }
                else if (ERROR_INTERNET_SEC_CERT_REV_FAILED == error)
                {
                    dwFlags = DLG_FLAGS_SEC_CERT_REV_FAILED;
                }
                else
                {
                    // we are checking cert revocation; therefore we only expect the CERT_REV_FAILED
                    // or CERT_REVOKED error if WinVerifyTrust fails.
                    INET_ASSERT(FALSE);
                }
            }
            else
            {
                // this function only re-validate two cert properties (exipiry & revocation)
                INET_ASSERT(FALSE);
            }
        }

        //
        // Change the error only if one of the known certifciate errors was
        // encountered.
        //

        if (fCertError)
        {
            error = ERROR_INTERNET_SEC_CERT_ERRORS;
            m_pSecurityInfo->SetSecureFlags(dwFlags);
        }
        else if (dwFlags & DLG_FLAGS_SEC_CERT_REV_FAILED)
        {
            INET_ASSERT(dwFlags==DLG_FLAGS_SEC_CERT_REV_FAILED);
            error = ERROR_INTERNET_SEC_CERT_REV_FAILED;
            m_pSecurityInfo->SetSecureFlags(DLG_FLAGS_SEC_CERT_REV_FAILED);
        }
   }

    if (ciInfo.pCertificate)
    {
        CertFreeCertificateContext(ciInfo.pCertificate);
    }

    if (error != ERROR_SUCCESS)
    {
        GlobalCertCache.Remove(GetHostName());
    }

    return error;
}


DWORD
ICSecureSocket::VerifyTrust(
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/
{

    // We've done our handshake, now update the security info
    INTERNET_SECURITY_INFO ciCert;
    DWORD dwCertFlags = 0;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD error;
    HINTERNET  hInternet;
    HINTERNET  hInternetMapped;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    DWORD dwFlags = 0;    // HTTPS policy flags to ignore errors

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::VerifyTrust",
                 "{%#x",
                 this
                 ));

    // HACK HACK: 67640
    // WinVerifyTrust can do a nested HttpSendRequest which causes the hObject's on the 
    // thread to get messed up. This happens only when the ceritificate has a URL for 
    // a CRL in it. We save and restore these values to workaround the problem.
    // Need to work out a better solution to handle this but it is too close to ship to 
    // try anything with greater code impact. 
    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }


    error = QuerySecurityInfo(&m_hContext, &ciCert);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if(m_pSecurityInfo)
    {
        *m_pSecurityInfo = &ciCert;
        dwCertFlags = m_pSecurityInfo->GetSecureFlags();
    }
    if (ciCert.pCertificate == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;
    if (GlobalEnableRevocation && !(dwCertFlags & DLG_FLAGS_SEC_CERT_REV_FAILED))
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;


    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)ciCert.pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&ciCert.pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;

    // Check for everything if looping.
    // 
    // This only incurs a perf hit in cases where ignore flags are set.
    // The sacrifice is made so the UI won't lie since the pass/fail
    // status in the UI is grouped.
    polHttps.fdwChecks = (m_dwErrorFlags &
                          INTERNET_ERROR_MASK_COMBINED_SEC_CERT) ?
                                 dwFlags : dwCertFlags;
    
    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, NULL, 0);

    polHttps.pwszServerName = new WCHAR[cbServerName+1];

    if(polHttps.pwszServerName == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    sWTCI.pcwszDisplayName      = polHttps.pwszServerName;

    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, polHttps.pwszServerName, cbServerName);

    error = LoadWinTrust();
    if(ERROR_SUCCESS == error)
    {
        error = WinVerifySecureChannel(NULL, &sWTD);
    }

    error = MapInternetError(error);


    // Handle revocation problem as special case
    if (ERROR_INTERNET_SEC_CERT_REV_FAILED == error)
        dwFlags |= DLG_FLAGS_SEC_CERT_REV_FAILED;

    // Revocation failed is separate, so it should be ignored.
    // Revoked will kill the request altogether.
    if (!(dwCertFlags & ~DLG_FLAGS_SEC_CERT_REV_FAILED))
    {
        // We're going to loop through all errors
        // (doesn't count revocation)
        m_pSecurityInfo->SetFullyValidated(TRUE);
    }

    //
    // If there was problem with the certificate and the caller requested
    // combined SSL errors cycle through all possible certificate errors.
    //

    if (ERROR_SUCCESS != error &&
        (m_dwErrorFlags & INTERNET_ERROR_MASK_COMBINED_SEC_CERT) &&
        m_pSecurityInfo)
    {
        BOOL  fCertError = FALSE;
 
        dwCertFlags = m_pSecurityInfo->GetSecureFlags();
        do
        {
            if (ERROR_INTERNET_INVALID_CA == error)
            {
                polHttps.fdwChecks |=  DLG_FLAGS_IGNORE_INVALID_CA;
                dwFlags |= DLG_FLAGS_INVALID_CA;
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_UNKNOWN_CA))
                    fCertError = TRUE;
            }
            else if (ERROR_INTERNET_SEC_CERT_CN_INVALID == error)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_CN_INVALID;
                if (GlobalWarnOnBadCertRecving &&
                      !(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_CN_INVALID))
                    fCertError = TRUE;
            }
            else if (ERROR_INTERNET_SEC_CERT_DATE_INVALID == error)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_DATE_INVALID;
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
                    fCertError = TRUE;
            }
            else if (ERROR_INTERNET_SEC_CERT_REVOKED == error)
            {
                // During this loop revoked comes after the untrusted
                // root error.  Clean up and break out with the revoked
                // error since it should take precedence.
                fCertError = FALSE;
                dwFlags = 0;
                break;
            }
            else if (ERROR_INTERNET_SEC_CERT_REV_FAILED == error)
            {
                // Break out and give precedence for rev failed cases, too.
                dwFlags = DLG_FLAGS_SEC_CERT_REV_FAILED;
                fCertError = FALSE;
                break;
            }
            else
            {
                //
                // Pass all other errors through.
                //

                break;
            }

            error = WinVerifySecureChannel(NULL, &sWTD);

            error = MapInternetError(error);

        } while (ERROR_SUCCESS != error);

        //
        // Change the error only if one of the known certifciate errors was
        // encountered.
        //

        if (fCertError)
        {
            error = ERROR_INTERNET_SEC_CERT_ERRORS;
            m_pSecurityInfo->SetSecureFlags(dwFlags);
        }
        else if (dwFlags & DLG_FLAGS_SEC_CERT_REV_FAILED)
        {
            INET_ASSERT(dwFlags==DLG_FLAGS_SEC_CERT_REV_FAILED);
            error = ERROR_INTERNET_SEC_CERT_REV_FAILED;
            m_pSecurityInfo->SetSecureFlags(DLG_FLAGS_SEC_CERT_REV_FAILED);
        }
    }

    delete [] polHttps.pwszServerName;

    if(ciCert.pCertificate)
    {
        CertFreeCertificateContext(ciCert.pCertificate);
    }

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // Only cache if we weren't supposed to ignore any results.
    // For security reasons, it may be important next time.
    if(m_pSecurityInfo && (!m_pSecurityInfo->InCache()) &&
       m_pSecurityInfo->GetFullyValidated())
    {
        // Add it to the cache if it's not already there.
        /* SCLE ref */
        GlobalCertCache.Add(m_pSecurityInfo);

    }

quit:                                 
    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateSecConnection(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Arguments:

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    lpbAttemptReconnect - on return, if this value is TRUE, the caller should call
                          this function again, and it will try another protocol.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateSecConnection",
                 "{%#x [%#x]} %#x, %#x [%B]",
                 this,
                 m_Socket,
                 dwFlags,
                 lpbAttemptReconnect,
                 *lpbAttemptReconnect
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureNegotiate(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureNegotiate::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureNegotiate::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureNegotiate * stateMachine = (CFsm_SecureNegotiate *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureNegotiate_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureNegotiate_Fsm(
    IN CFsm_SecureNegotiate * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureNegotiate_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureNegotiate & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSSPIFlags = 0;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto send_continue;

        case FSM_STATE_3:
            goto negotiate_loop_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    *fsm.m_lpbAttemptReconnect = FALSE;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    if(GlobalSecureProtocols != GlobalSecureProtocolsCopy)
    {
        LOCK_SECURITY();
        //ReInit the credentials if our settings have changed.
        SecurityPkgInitialize();
        UNLOCK_SECURITY();
    }

    //
    // Pick the provider we're going to use.
    //

    while ((SecProviders[GetProviderIndex()].pszName != NULL)
           && ( !SecProviders[GetProviderIndex()].fEnabled
             || !(SecProviders[GetProviderIndex()].dwProtocolFlags & GlobalSecureProtocols) ) ) {

        //
        // Next provider
        //

        SetProviderIndex(GetProviderIndex() + 1);
    }

    if (SecProviders[GetProviderIndex()].pszName == NULL) {

        //
        // BUGBUG shouldn't we error out here?
        //

        SetProviderIndex(0);
        goto error_exit;
    }

    DWORD i;

    i = GetProviderIndex();

    DEBUG_PRINT(API,
                INFO,
                ("Starting handshake protocol with pkg %d - %s\n",
                i,
                SecProviders[i].pszName
                ));


    //
    // 1. initiate a client HELLO message and generate a token
    //

    fsm.m_OutBuffers[0].pvBuffer = NULL;
    fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    SECURITY_STATUS scRet;
    DWORD ContextAttr;
    TimeStamp tsExpiry;

    fsm.m_bDoingClientAuth = FALSE;

    // Resynchronize the certificate store to catch
    // recently installed certificates
    if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
        ReopenMyCertStore();
    if (g_hMyCertStore)
        CertControlStore(g_hMyCertStore, 0, CERT_STORE_CTRL_AUTO_RESYNC, NULL);

    //
    // We need a credential handle,
    //  if we're doing client do the magic to get a specialized
    //  one otherwise use the standard global one.
    //

    if ( IsCredClear(fsm.m_hCreds) )
    {
        fsm.m_hCreds = SecProviders[i].hCreds;

        if (GetCertContextArray())
        {
            if (GetCertContextArray()->GetSelectedCertContext())
            {
                error = CliAuthSelectCredential(
                            &m_hContext,
                            SecProviders[i].pszName,
                            GetCertContextArray(),
                            &fsm.m_hCreds);

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_bDoingClientAuth = TRUE;
            }

            dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
        }
        else if (m_pSecurityInfo && m_pSecurityInfo->GetForceNewSession())
        {
            // Force new session to be negotiated because
            // the user flushed client auth certs for the session.
            // Clear the force flag after we enter the loop.
            dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;
        }
    }

    scRet = g_InitializeSecurityContext(&fsm.m_hCreds,
                                        NULL,
                                        (LPSTR)GetHostName(),
                                        ISC_REQ_SEQUENCE_DETECT
                                        | ISC_REQ_REPLAY_DETECT
                                        | ISC_REQ_CONFIDENTIALITY
                                        | ISC_REQ_ALLOCATE_MEMORY
                                        | dwSSPIFlags,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        NULL,       // default, don't do hack.
                                        0,
                                        &m_hContext,
                                        &fsm.m_OutBuffer, // address where output data go
                                        &ContextAttr,
                                        &tsExpiry
                                        );

    DEBUG_PRINT(API,
                INFO,
                ("1. InitializeSecurityContext returned %s [%x]. hContext = %#x:%#x\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet,
                m_hContext.dwUpper,
                m_hContext.dwLower
                ));

    if (scRet == SEC_E_INVALID_HANDLE) {
         SecProviders[i].fEnabled = FALSE;
    }
    if (scRet == SEC_E_INVALID_TOKEN) {
        error = ERROR_INTERNET_CANNOT_CONNECT;
    } else {

        //
        // Turn the error in to one we understand */
        //

        error = MapInternetError((DWORD)scRet);
    }
    if (scRet != SEC_I_CONTINUE_NEEDED) {
        goto error_exit;
    }

    DEBUG_PRINT(API,
                INFO,
                ("1. OutBuffer is <%x, %d, %x>\n",
                fsm.m_OutBuffers[0].pvBuffer,
                fsm.m_OutBuffers[0].cbBuffer,
                fsm.m_OutBuffers[0].BufferType
                ));

    if ((fsm.m_OutBuffers[0].cbBuffer != 0)
    && (fsm.m_OutBuffers[0].pvBuffer != NULL)) {

        //
        // Send response to server if there is one
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                               fsm.m_OutBuffers[0].cbBuffer,
                               0
                               );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

send_continue:

        g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
        fsm.m_OutBuffers[0].pvBuffer = NULL;
        if (error != ERROR_SUCCESS) {

            //
            // We should deal with this better
            //

            goto error_exit;
        }
    }

    fsm.SetFunctionState(FSM_STATE_3);
    error = SSPINegotiateLoop(NULL, fsm.m_dwFlags, fsm.m_hCreds, TRUE, fsm.m_bDoingClientAuth);

    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_loop_continue:
error_exit:

    //
    // We're not actually deleting the handle, rather we're no longer keeping
    //  a reference to the Credential handle in our fsm after we hand it off
    //

    if ( fsm.m_bDoingClientAuth )
    {
        ClearCreds(fsm.m_hCreds);
        fsm.m_bDoingClientAuth = FALSE;
    }

    if (error == ERROR_INTERNET_CANNOT_CONNECT) {

        //
        // error was a CANNOT_CONNECT, so try the next protocol.
        //

        SetProviderIndex(GetProviderIndex() + 1);

        if (SecProviders[GetProviderIndex()].pszName == NULL) {
            SetProviderIndex(0);
            *fsm.m_lpbAttemptReconnect = FALSE;
        } else {
            *fsm.m_lpbAttemptReconnect = TRUE;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SSPINegotiateLoop(
    OUT DBLBUFFER * pdblbufBuffer,
    IN DWORD dwFlags,
    CredHandle hCreds,
    IN BOOL bDoInitialRead,
    IN BOOL bDoingClientAuth
    )

/*++

Routine Description:

    This function completes the handshakes needed to establish a
    security protocol.  The initial handshakes are either generated
    by NegotiateSecureConnection, when generating a new connection, or
    during a receive when a REDO request is received.

Arguments:

    pdblbufBuffer - an input buffer into which to put any Extra data left over
                    after the handshake.  This data is assumed to be application
                    data, and will be decrypted later.

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    bDoInitialRead - if TRUE, this function will do a read before calling
                     InitializeSecurityContext, otherwise, it passes in 0 bytes of data.

Return Value:

    ERROR_SUCCESS - we successfully completed our connection.
    ERROR_INTERNET_CANNOT_CONNECT - The connection was dropped on us, possibly because we used a bad
                                    protocol.  Try the next protocol.

    ERROR_*                       - Other internet error, disconnect.


Comments:

    BUGBUG (hack alert) [arthurbi]
    Do to a bug in IIS 1.0 Servers we cannot connect because
    we send a "Client SSL 3 Message".  This message confuses the
    server and causes it to close the socket.  The fix is to
    reopen the socket and send a "Client SSL 2 Message."  Newer
    versions of the server will be fixed.


--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SSPINegotiateLoop",
                 "{%#x [%#x]} %#x, %#x, %B",
                 this,
                 m_Socket,
                 pdblbufBuffer,
                 dwFlags,
                 bDoInitialRead
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_NegotiateLoop(pdblbufBuffer,
                                               dwFlags,
                                               bDoInitialRead,
                                               bDoingClientAuth,
                                               hCreds,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_NegotiateLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_NegotiateLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_NegotiateLoop * stateMachine = (CFsm_NegotiateLoop *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->NegotiateLoop_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateLoop_Fsm(
    IN CFsm_NegotiateLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_NegotiateLoop & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto receive_continue;

        case FSM_STATE_3:
            goto send_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    fsm.m_dwProviderIndex = GetProviderIndex();

    fsm.m_dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT
                      | ISC_REQ_REPLAY_DETECT
                      | ISC_REQ_CONFIDENTIALITY
                      | ISC_REQ_ALLOCATE_MEMORY
                      | ISC_RET_EXTENDED_ERROR;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // If we have a selected cert chain, then try to
    // generate a credential from that list.
    //

    if (IsCredClear(fsm.m_hCreds))
    {
        fsm.m_hCreds = SecProviders[fsm.m_dwProviderIndex].hCreds;

        if ( GetCertContextArray() &&
             GetCertContextArray()->GetSelectedCertContext() )
        {
            error = CliAuthSelectCredential(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        GetCertContextArray(),
                        &fsm.m_hCreds);

            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            fsm.m_bDoingClientAuth = TRUE;
        }
        else if (m_pSecurityInfo && m_pSecurityInfo->GetForceNewSession())
        {
            // Force new session to be negotiated because
            // the user flushed client auth certs for the session.
            fsm.m_dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;
            m_pSecurityInfo->SetForceNewSession(FALSE);
        }
    }

    if (fsm.m_bDoingClientAuth ||
        GetCertContextArray() )
    {
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
    }

    fsm.m_scRet = SEC_I_CONTINUE_NEEDED;

    while (fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
           fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE ||
           fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

        //
        //  send to target server
        //  if we've got a SEC_E_INCOMPLETE_MESSAGE we need to do a read
        //  again because we didn't get the entire message we expected from
        //  the server.
        //


        //
        //  receive response from server and pass token into security pkg
        //    BUT only if we haven't already received extra data
        //    from SSPI which we need to process in lu of actual data
        //    data from WinSock, and if the package has not returned
        //    one of the defined warnings that indicates that we should
        //    pass the previous buffer again.
        //


        // Make sure fsm.m_lpszBuffer holds the input data to be passed
        // to initialize security context.  There are 4 cases:
        // 1) We have Extra Data, so we don't need to do a socket receive
        // 2) We were called during a re-negotiate, so if this is the first
        //    time through the loop, we have 0 bytes.
        // 3) We are recovering from a SEC_I_INCOMPLETE_CREDENTIALS, so
        //    use the same buffer again.
        // 4) We do a SocketReceive
        // We'll indicate 1 and 3 by having the fsm.m_dwBytesReceived count being the number of bytes
        // left in the buffer to be re-sent or sent to the sspi call.
        // If bytes-received is zero, then either we are doing a Redo, or we need to receive
        // data.  fsm.m_bDoRead let's us know if for some reason we should do or not do this read



        if ((0 == fsm.m_dwBytesReceived) || (fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE)) {
            if (fsm.m_bDoRead) {
                fsm.SetFunctionState(FSM_STATE_2);
                error = ICSocket::Receive((LPVOID *)&fsm.m_lpszBuffer,
                                          &fsm.m_dwBufferLength,
                                          &fsm.m_dwBufferLeft,
                                          &fsm.m_dwBytesReceived,
                                          0,
                                          SF_EXPAND,
                                          &fsm.m_bEofReceive
                                          );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

receive_continue:

                if ((error != ERROR_SUCCESS) || fsm.m_bEofReceive) {

                    DEBUG_PRINT(API,
                                ERROR,
                                ("SocketReceive failed\n"
                                ));

                    if (error == ERROR_SUCCESS) {
                        error = ERROR_INTERNET_CANNOT_CONNECT;
                    }
                    break;
                }
            } else {
                fsm.m_bDoRead = TRUE;
            }
        }

        if (fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

            CERT_CONTEXT_ARRAY* pCertContextArray;

            //
            // If've already done Client Auth, and it fails again
            //  then we fail.
            //

            if (fsm.m_bDoingClientAuth) {
                error = ERROR_CANCELLED;
                goto quit;
            }

            //
            // If we don't already have a cert chain list,
            // then get one, and make our selection
            //

            INET_ASSERT(!GetCertContextArray());

            pCertContextArray = NULL;

            //delete pCertChainList;
            //SetCertChainList(NULL);

            error = CliAuthAcquireCertContexts(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        &pCertContextArray
                        );

            SetCertContextArray(pCertContextArray);

            if (error == ERROR_SUCCESS) {
                error = ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED;
            }

            fsm.m_scRet = error;
            break;
        }

        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        fsm.m_InBuffers[0].pvBuffer   = fsm.m_lpszBuffer;
        fsm.m_InBuffers[0].cbBuffer   = fsm.m_dwBytesReceived;
        fsm.m_InBuffers[0].BufferType = SECBUFFER_TOKEN;

        fsm.m_InBuffers[1].pvBuffer   = NULL;
        fsm.m_InBuffers[1].cbBuffer   = 0;
        fsm.m_InBuffers[1].BufferType = SECBUFFER_EMPTY;

        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        fsm.m_OutBuffers[0].pvBuffer   = NULL;
        fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        fsm.m_OutBuffers[0].cbBuffer   = 0;

        SecBufferDesc InBuffer;

        InBuffer.cBuffers        = 2;
        InBuffer.pBuffers        = fsm.m_InBuffers;
        InBuffer.ulVersion       = SECBUFFER_VERSION;

        DWORD ContextAttr;
        TimeStamp tsExpiry;

        fsm.m_scRet = g_InitializeSecurityContext(&fsm.m_hCreds,
                                                  &m_hContext,
                                                  NULL,
                                                  fsm.m_dwSSPIFlags,
                                                  0,
                                                  SECURITY_NATIVE_DREP,
                                                  &InBuffer,
                                                  0,
                                                  NULL,
                                                  &fsm.m_OutBuffer,
                                                  &ContextAttr,
                                                  &tsExpiry
                                                  );

        DEBUG_PRINT(API,
                    INFO,
                    ("3. InitializeSecurityContext returned %s [%x]\n",
                    InternetMapSSPIError((DWORD)fsm.m_scRet),
                    fsm.m_scRet
                    ));

        if (fsm.m_scRet == STATUS_SUCCESS ||
             fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
             (FAILED(fsm.m_scRet) && (0 != (ContextAttr & ISC_RET_EXTENDED_ERROR))))
        {
            if  (fsm.m_OutBuffers[0].cbBuffer != 0    &&
                 fsm.m_OutBuffers[0].pvBuffer != NULL )
            {

                //
                // Send response to server if there is one
                //

                fsm.SetFunctionState(FSM_STATE_3);
                error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                                       fsm.m_OutBuffers[0].cbBuffer,
                                       0
                                       );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

send_continue:

                g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
                fsm.m_OutBuffers[0].pvBuffer = NULL;
            }
        }


        if ( fsm.m_scRet == STATUS_SUCCESS )
        {
            DEBUG_PRINT(API,
                     INFO,
                    ("NegotiateSecConnection succeeded.\n"));


            if (fsm.m_pdblbufBuffer)
            {
                if ( fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA )
                {

                    fsm.m_pdblbufBuffer->CopyIn(
                        (LPBYTE) (fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer)),
                        fsm.m_InBuffers[1].cbBuffer
                        );

                }
                else
                {
                    fsm.m_pdblbufBuffer->SetInputBufferSize(0);
                }
            }



            //
            // Bail out to quit
            //

            break;
        }
        else if (FAILED(fsm.m_scRet) && (fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE))
        {

             //
             //  free security context handle and delete the local
             //  data structures associated with the handle and
             //  try another pkg if available
             //

             DEBUG_PRINT(API,
                         INFO,
                         ("3. InitializeSecurityContext failed, %lx\n",
                         fsm.m_scRet
                         ));


             // Turn the error in to one we understand */
             error = MapInternetError((DWORD)fsm.m_scRet);

             TerminateSecConnection();
             /* Break out to try next protocol */
             break;
        }

        if ((fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE)
        && (fsm.m_scRet != SEC_I_INCOMPLETE_CREDENTIALS)) {

            DEBUG_PRINT(API,
                        INFO,
                        ("3. OutBuffer is <%x, %d, %x>\n",
                        fsm.m_OutBuffers[0].pvBuffer,
                        fsm.m_OutBuffers[0].cbBuffer,
                        fsm.m_OutBuffers[0].BufferType
                        ));

            if (fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA) {

                //
                // skip next recv and set up buffers
                //  so InitalizeSecurityContext pulls its
                //  info from the Extra it returned previously.
                //

                DEBUG_PRINT(API,
                         INFO,
                         ("Got SECBUFFER_EXTRA, moving %d bytes to front of buffer\n",
                         fsm.m_InBuffers[1].cbBuffer
                         ));

                INET_ASSERT(fsm.m_InBuffers[1].cbBuffer > 0);

                MoveMemory(
                        fsm.m_lpszBuffer,             // dest
                        fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer),
                        fsm.m_InBuffers[1].cbBuffer   // size
                        );

                fsm.m_dwBytesReceived = fsm.m_InBuffers[1].cbBuffer;
                fsm.m_dwBufferLeft   = fsm.m_dwBufferLength - fsm.m_dwBytesReceived;
            } else {

                //
                // prepare for next receive
                //

                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;
                fsm.m_dwBytesReceived = 0;
            }
        }
    }

quit:

    if (fsm.m_lpszBuffer != NULL) {
         fsm.m_lpszBuffer = (LPSTR)FREE_MEMORY(fsm.m_lpszBuffer);
         INET_ASSERT(fsm.m_lpszBuffer == NULL);
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Disconnect",
                 "{%#x} %#x",
                 m_Socket,
                 dwFlags
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = ICSocket::Disconnect(dwFlags);

    //
    // delete security context handle for the connection
    //

    if ((m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))
    && dwEncFlags != ENC_CAPS_NOT_INSTALLED) {
        TerminateSecConnection();
    }

    //
    // Zero out the pending input buffer
    //

    if (m_pdblbufBuffer != NULL) {
        m_pdblbufBuffer->SetInputBufferSize(0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over a secure connection

Arguments:

    lpBuffer        - pointer to user data to send

    dwBufferLength  - length of user data

    dwFlags         - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send",
                 "{%#x [%#x]} %#x, %d, %#x",
                 this,
                 m_Socket,
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);
    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureSend * stateMachine = (CFsm_SecureSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Send_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send_Fsm(
    IN CFsm_SecureSend * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureSend & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        //
        // Log The Data BEFORE we Encrypt It ( if we do )
        //

        DEBUG_DUMP_API(SOCKETS,
                       "sending data:\n",
                       fsm.m_lpBuffer,
                       fsm.m_dwBufferLength
                       );

    }

    while (((int)fsm.m_dwBufferLength > 0) && (error == ERROR_SUCCESS)) {

        LPVOID lpBuffer;
        DWORD dwLength;
        DWORD dwBytes;

        if (m_dwFlags & SF_ENCRYPT) {

            DWORD dwBytesEncrypted;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Encrypting data..\n"
                        ));

            error = EncryptData(fsm.m_lpBuffer,
                                fsm.m_dwBufferLength,
                                &fsm.m_lpCryptBuffer,
                                &fsm.m_dwCryptBufferLength,
                                &dwBytesEncrypted
                                );
            if (error != ERROR_SUCCESS) {
                break;
            }

            INET_ASSERT(fsm.m_lpCryptBuffer != NULL);
            INET_ASSERT((int)fsm.m_dwCryptBufferLength > 0);
            INET_ASSERT(dwBytesEncrypted <= fsm.m_dwBufferLength);

            lpBuffer = fsm.m_lpCryptBuffer;
            dwLength = fsm.m_dwCryptBufferLength;
            dwBytes = dwBytesEncrypted;
        } else {
            lpBuffer = fsm.m_lpBuffer;
            dwLength = fsm.m_dwBufferLength;
            dwBytes = dwLength;
        }

        fsm.m_lpBuffer = (LPVOID)((LPBYTE)fsm.m_lpBuffer + dwBytes);
        fsm.m_dwBufferLength -= dwBytes;

        error = ICSocket::Send(lpBuffer, dwLength, fsm.m_dwFlags);
        if (error != ERROR_SUCCESS) {
            break;
        }
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // Free Encryption Buffer if doing SSL/PCT
        //

        if (fsm.m_lpCryptBuffer != NULL ) {
            fsm.m_lpCryptBuffer = (LPVOID)FREE_MEMORY(fsm.m_lpCryptBuffer);
            INET_ASSERT(fsm.m_lpCryptBuffer == NULL);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive(
    IN OUT LPVOID* lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives and decrypts data from a secure connection

Arguments:

    lplpBuffer          - see ICSocket::Receive
    lpdwBufferLength    -
    lpdwBufferRemaining -
    lpdwBytesReceived   -
    dwExtraSpace        -
    dwFlags             -
    lpbEof              -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT((*lpdwBufferLength == 0) ? (dwFlags & SF_EXPAND) : TRUE);
    INET_ASSERT(IsSecure());

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    DWORD error = DoFsm(new CFsm_SecureReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureReceive * stateMachine = (CFsm_SecureReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Receive_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive_Fsm(
    IN CFsm_SecureReceive * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive_Fsm",
                 "%#x",
                 Fsm
                 ));

    //INET_ASSERT(m_dwFlags & SF_DECRYPT);

    CFsm_SecureReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPVOID * lplpBuffer;
    LPDWORD lpdwBufferLength;
    LPDWORD lpdwBufferLeft;
    LPDWORD lpdwBytesReceived;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        case FSM_STATE_3:
            goto receive_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // keep the app informed (if requested to do so)
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
                               NULL,
                               0
                               );
    }

    fsm.m_dwReadFlags = fsm.m_dwFlags;

    //
    // Loop Through our Reads, assembling enough unencrypted bytes
    //  to return back to the client.  In the non-SSL/PCT case, we should
    //  be able to quit after one iteration.
    //

    do {

        LPVOID * lplpReadBuffer;
        LPDWORD lpdwReadBufferLength;
        LPDWORD lpdwReadBufferLeft;
        LPDWORD lpdwReadBufferReceived;

        //
        // If we're attempting to read SSL/PCT data, we need examine, whether
        // we have all the bytes decrypted and read already in our scratch buffer.
        //

        if (m_dwFlags & SF_DECRYPT) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Decrypting data..\n"
                        ));

            if (m_pdblbufBuffer != NULL) {

                DEBUG_DUMP_API(SOCKETS,
                               "About to decrypt this data:\n",
                               (LPBYTE)m_pdblbufBuffer->GetInputBufferPointer(),
                               m_pdblbufBuffer->GetInputBufferSize()
                               );

            }

            fsm.m_dwDecryptError = DecryptData(&fsm.m_dwInputBytesLeft,
                                               (LPBYTE)fsm.m_hBuffer,
                                               &fsm.m_dwBufferLeft,
                                               &fsm.m_dwBytesReceived,
                                               &fsm.m_dwBytesRead
                                               );

            if (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE &&
                fsm.m_bEof &&
                m_pdblbufBuffer->GetInputBufferSize() > 0) {

                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
                goto error_exit;

            }
            else if (fsm.m_dwDecryptError == SEC_I_RENEGOTIATE) {

                CredHandle hDummyCreds;

                //
                // BUGBUG - don't have to do this - Receive() called from
                //          SSPINegotiateLoop() won't come back through here
                //

                m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
                ClearCreds(hDummyCreds);

                fsm.SetFunctionState(FSM_STATE_2);
                error = SSPINegotiateLoop(m_pdblbufBuffer,
                                          fsm.m_dwFlags,
                                          hDummyCreds,
                                          FALSE,
                                          FALSE);
                if (error == ERROR_IO_PENDING) {
                    goto error_exit;
                }

negotiate_continue:

                m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);

                if (error != ERROR_SUCCESS) {
                    break;
                }

                fsm.m_dwDecryptError = (ULONG)SEC_E_INCOMPLETE_MESSAGE;

                //
                // If there was extra data, and it was shoved back into
                // dblbuffer, then we should redo the decryption, since
                // it now has extra input data to process.
                //

                if (m_pdblbufBuffer->GetInputBufferSize() > 0) {
                    continue;
                }

                //
                // Okay, here we've received 0 bytes, so so we have to
                // receive more data, and process it.  Do this by zero-ing
                // out the input buffer, and setting the decrypt_error to be
                // Incomplete.
                //

            }

            //
            // If we have no buffer left to fill, or the caller ask for a single recv
            // and we've managed to read something into the buffer, then return by breaking.
            //

            if ((fsm.m_dwBufferLeft == 0)
            || (!(fsm.m_dwFlags & SF_RECEIVE_ALL) && (fsm.m_dwBytesRead > 0))) {
                break;  // we're done.
            }

            INET_ASSERT(error == ERROR_SUCCESS);

            //
            // BUGBUG [arthurbi] GetInputBufferSize needs to be called before getting
            //   the pointer, because the pointer may be moved around while generating
            //   the size.
            //

            DWORD remaining;
            DWORD inputSize;

            inputSize = m_pdblbufBuffer->GetInputBufferSize();
            remaining = m_pdblbufBuffer->GetInputBufferRemaining();
            fsm.m_dwBufferLengthDummy = inputSize + remaining;
            fsm.m_dwBufferLeftDummy = remaining;
            fsm.m_dwBufferReceivedDummy = inputSize;
            fsm.m_lpBufferDummy = m_pdblbufBuffer->GetInputBufferPointer();

            //
            // We need to be careful, and only recv one block of data at a time
            // if we're not we break keep-alive by doing too many reads.
            //
            // So unless we know ( by the non-0 return ) exactly how many bytes
            // to read, we shut off SF_RECEIVE_ALL.
            //

            fsm.m_dwReadFlags &= ~(SF_RECEIVE_ALL
                                   | SF_INDICATE
                                   | SF_EXPAND
                                   | SF_COMPRESS
                                   );

            if (fsm.m_dwInputBytesLeft != 0) {

                //
                // don't add RECEIVE_ALL if NO_WAIT already set by caller - they
                // are mutually exclusive
                //

                if (!(fsm.m_dwReadFlags & SF_NO_WAIT)) {
                    fsm.m_dwReadFlags |= SF_RECEIVE_ALL;
                }
                fsm.m_dwBufferLeftDummy = min(fsm.m_dwInputBytesLeft,
                                              fsm.m_dwBufferLeftDummy);
            }
            lplpReadBuffer = (LPVOID *)&fsm.m_lpBufferDummy;
            lpdwReadBufferLength = &fsm.m_dwBufferLengthDummy;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeftDummy;
            lpdwReadBufferReceived = &fsm.m_dwBufferReceivedDummy;
        } else {
            lplpReadBuffer = &fsm.m_hBuffer;
            lpdwReadBufferLength = &fsm.m_dwBufferLength;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeft;
            lpdwReadBufferReceived = &fsm.m_dwBytesReceived;
        }

        //
        // receive some data, assuming the socket is not closed.
        //

        if (!fsm.m_bEof) {
            //fsm.m_dwBytesReceivedPre = *lpdwReadBufferReceived;
            fsm.SetFunctionState(FSM_STATE_3);
            error = ICSocket::Receive(lplpReadBuffer,
                                      lpdwReadBufferLength,
                                      lpdwReadBufferLeft,
                                      lpdwReadBufferReceived,
                                      fsm.m_dwExtraSpace,
                                      fsm.m_dwReadFlags,
                                      &fsm.m_bEof
                                      );
            if (error == ERROR_IO_PENDING) {
                goto error_exit;
            }

receive_continue:

            //fsm.m_dwBytesRead += fsm.m_dwByReceived - fsm.m_dwDCBufferRecvPre;
            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            //
            // Once again, for SSL/PCT we need to update our input buffer after the read.
            //

            if (m_dwFlags & SF_DECRYPT) {
                m_pdblbufBuffer->SetInputBufferSize(fsm.m_dwBufferReceivedDummy);
            }
        }
    } while ((m_dwFlags & SF_DECRYPT)
             && (error == ERROR_SUCCESS)
             && (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE)
             && (!fsm.m_bEof || (m_pdblbufBuffer->GetInputBufferSize() > 0)));

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
                                   &fsm.m_dwBytesRead,
                                   sizeof(fsm.m_dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT_API(SOCKETS,
                        INFO,
                        ("read %d bytes @ %#x from socket %#x\n",
                        fsm.m_dwBytesRead,
                        (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                        m_Socket
                        ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    }

quit:

    //
    // if we failed but allocated a buffer then we need to free it (we were
    // leaking this buffer if the request was cancelled)
    //

    if ((error != ERROR_SUCCESS) && fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {
//dprintf("SocketReceive() freeing allocated buffer %#x\n", hBuffer);
        fsm.m_hBuffer = (HLOCAL)FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;

    //
    // Hack, we hide eof's from caller, since we may have buffered data sitting around
    //

    if ((m_dwFlags & SF_DECRYPT) && (fsm.m_dwBytesRead != 0)) {
        fsm.m_bEof = FALSE;
    }

    *fsm.m_lpbEof = fsm.m_bEof;

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

error_exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SetHostName(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Set name of server we are connected to. Find or create a security cache
    entry for this name

Arguments:

    lpszHostName    - name to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SetHostName",
                 "{%#x [%q %#x/%d]} %q",
                 this,
                 m_lpszHostName,
                 GetSocket(),
                 GetSourcePort(),
                 lpszHostName
                 ));

    INET_ASSERT(IsSecure());
    INET_ASSERT((lpszHostName != NULL) || (m_lpszHostName == NULL));

    DWORD error = ERROR_SUCCESS;

    if (lpszHostName != NULL) {
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);

            INET_ASSERT(m_lpszHostName == NULL);

        }
        m_lpszHostName = NewString(lpszHostName);
        if (m_lpszHostName == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        } else if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            m_pSecurityInfo = GlobalCertCache.Find(lpszHostName);
            if (m_pSecurityInfo == NULL) {
                /* SCLE ref */
                m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(lpszHostName);
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private ICSecureSocket methods
//


DWORD
ICSecureSocket::EncryptData(
    IN LPVOID lpBuffer,
    IN DWORD dwInBufferLen,
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwOutBufferLen,
    OUT LPDWORD lpdwInBufferBytesEncrypted
    )

/*++

Routine Description:

    This function encrypts data in the lplpbuffer.

Arguments:

    lpBuffer         - pointer to buffer containing unencrypted user data

    dwInBufferLen    - length of input buffer

    lplpBuffer       - pointer to pointer to encrypted user buffer

    lpdwOutBufferLen - pointer to length of output lplpbuffer

    lpdwInBufferBytesEncrypted - pointer to length of bytes read and encrypted in output buffer

Return Value:

    Error Code

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::EncryptData",
                 "%#x, %d, %#x, %#x, %#x",
                 lpBuffer,
                 dwInBufferLen,
                 lplpBuffer,
                 lpdwOutBufferLen,
                 lpdwInBufferBytesEncrypted
                 ));

    SECURITY_STATUS scRet = STATUS_SUCCESS;
    SecBufferDesc Buffer;
    SecBuffer Buffers[3];
    HLOCAL hBuffer;
    DWORD error;
    DWORD dwMaxDataBufferSize;
    DWORD dwExtraInputBufferLen;
    SecPkgContext_StreamSizes Sizes;

    INET_ASSERT(IsSecure());
    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(dwInBufferLen != 0);
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwOutBufferLen != NULL);
    INET_ASSERT(lpdwInBufferBytesEncrypted != NULL);

    hBuffer = (HLOCAL) *lplpBuffer;
    *lpdwOutBufferLen = 0;
    *lpdwInBufferBytesEncrypted = 0;

    //INET_ASSERT(hBuffer == NULL );

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(&m_hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned, %s [%x] (%s)\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet,
                    InternetMapError(scRet)
                    ));

        error = MapInternetError((DWORD) scRet);
        goto quit;
    } else {

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned header=%d, trailer=%d, maxmessage=%d\n",
                    Sizes.cbHeader,
                    Sizes.cbTrailer,
                    Sizes.cbMaximumMessage
                    ));
    }

    INET_ASSERT(Sizes.cbMaximumMessage > (Sizes.cbHeader + Sizes.cbTrailer));

    //
    // Figure out the max SSL packet we can send over the wire.
    //  If the data is too big to send, then remeber how much
    //  we did send, and how much we didn't send.
    //

    dwMaxDataBufferSize = Sizes.cbMaximumMessage - (Sizes.cbHeader + Sizes.cbTrailer);

    dwExtraInputBufferLen =
            (dwMaxDataBufferSize < dwInBufferLen ) ?
                (dwInBufferLen - dwMaxDataBufferSize) : 0;

    dwInBufferLen =
            ( dwExtraInputBufferLen > 0 ) ?
            dwMaxDataBufferSize :
            dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("resizing %#x to %d\n",
                hBuffer,
                dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer
                ));

    hBuffer = ResizeBuffer(hBuffer,
                           dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer,
                           FALSE );

    if (hBuffer == (HLOCAL)NULL) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        goto quit;
    }

    //
    // prepare data for SecBuffer
    //

    Buffers[0].pvBuffer = hBuffer;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader;
    memcpy(Buffers[1].pvBuffer,
           lpBuffer,
           dwInBufferLen);

    Buffers[1].cbBuffer = dwInBufferLen;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //

    if ( Sizes.cbTrailer ) {
         Buffers[2].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader + dwInBufferLen;
         Buffers[2].cbBuffer = Sizes.cbTrailer;
         Buffers[2].BufferType = SECBUFFER_TOKEN;
    } else {
         Buffers[2].pvBuffer = NULL;
         Buffers[2].cbBuffer = 0;
         Buffers[2].BufferType = SECBUFFER_EMPTY;
    }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(&m_hContext,
                          0,
                          &Buffer,
                          0);

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned, %s [%x]\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet
                ));


    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("SealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));

        error = MapInternetError((DWORD) scRet);

        if (hBuffer != NULL) {
            FREE_MEMORY(hBuffer);
        }
        goto quit;
    } else {
        error = ERROR_SUCCESS;
    }

    *lplpBuffer = Buffers[0].pvBuffer;
    *lpdwOutBufferLen = Sizes.cbHeader + Buffers[1].cbBuffer +
                        Buffers[2].cbBuffer;
    *lpdwInBufferBytesEncrypted = dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes=%d\n",
                *lplpBuffer,
                *lpdwOutBufferLen,
                dwInBufferLen
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


#define SSLPCT_SMALLESTHEADERCHUNK      3


DWORD
ICSecureSocket::DecryptData(
    OUT DWORD * lpdwBytesNeeded,
    OUT LPBYTE lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLeft,
    IN OUT LPDWORD lpdwOutBufferReceived,
    IN OUT LPDWORD lpdwOutBufferBytesRead
    )

/*++

Routine Description:

    This function decrypts data into the lpOutBuffer. It attempts to fill lpOutBuffer.
    If it fails, it may do so because more bytes are
    needed to fill lplpEncDecBuffer or lplpEndDecBuffer is not big enough to fully
    contain a complete server generated SSL/PCT message.


Return Value:

    Error Code

--*/

{
    INET_ASSERT(IsSecure());
    INET_ASSERT(lpOutBuffer);
    INET_ASSERT(lpdwOutBufferBytesRead);
    INET_ASSERT(lpdwBytesNeeded);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::DecryptData",
                 "{%#x [%#x:%#x], %#x} %#x [%d], %#x, %#x [%d], %#x [%d], %#x [%d]",
                 &m_hContext,
                 m_hContext.dwUpper,
                 m_hContext.dwLower,
                 m_pdblbufBuffer,
                 lpdwBytesNeeded,
                 *lpdwBytesNeeded,
                 lpOutBuffer,
                 lpdwOutBufferLeft,
                 *lpdwOutBufferLeft,
                 lpdwOutBufferReceived,
                 *lpdwOutBufferReceived,
                 lpdwOutBufferBytesRead,
                 *lpdwOutBufferBytesRead
                 ));

    SecBufferDesc Buffer;
    SecBuffer Buffers[4];   // the 4 buffers are: header, data, trailer, extra
    DWORD scRet = ERROR_SUCCESS;

    *lpdwBytesNeeded = 0;

    //
    //  HOW THIS THING WORKS:
    //  We sit in a loop, attempting to fill our passed in buffer with
    //  decrypted data.  If there is no decrypted data we check to
    //  see if there is encrypted data sitting in our buffer.
    //
    //  Assuming there is enough we decrypt a chunk, and place it in the
    //  output buffer of our double buffer class. We reloop and try to
    //  copy it to our passed in byffer.
    //
    //  If there is more encrypted data, and more space to fill in
    //  the user buffer, we attempt to decrypt the next chunk of this.
    //
    //  If we do not have enough data, we return with an error, and
    //  expect a network read to be done.
    //

    do {

        //
        // Check to see if we can fill up User buffer.
        //

        m_pdblbufBuffer->CopyOut(
            lpOutBuffer,
            lpdwOutBufferLeft,
            lpdwOutBufferReceived,
            lpdwOutBufferBytesRead
        );

        //
        // If we've filled our output buffer, than exit with ERROR_SUCCESS
        //

        if ( *lpdwOutBufferLeft == 0)
        {
            break;
        }

        //
        // If we've got less than ~3 bytes return so we can read more data.
        //

        if (m_pdblbufBuffer->GetInputBufferSize() < SSLPCT_SMALLESTHEADERCHUNK) {
            scRet = (DWORD) SEC_E_INCOMPLETE_MESSAGE;
            break;
        }

        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //

        Buffers[0].pvBuffer = m_pdblbufBuffer->GetInputBufferPointer( );
        Buffers[0].cbBuffer = m_pdblbufBuffer->GetInputBufferSize(); // # of bytes to decrypt
        Buffers[0].BufferType = SECBUFFER_DATA;

        int i;

        for ( i = 1; i < 4; i++ )
        {
            //
            // clear other 3 buffers for receving result from SSPI package
            //

            Buffers[i].pvBuffer = NULL;
            Buffers[i].cbBuffer = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
        }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //

        scRet = g_UnsealMessage(&m_hContext,
                                &Buffer,
                                0,
                                NULL );

        DEBUG_PRINT(API,
                    INFO,
                    ("UnsealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));



        if ( scRet != ERROR_SUCCESS &&
             scRet != SEC_I_RENEGOTIATE)
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("UnsealMessage failed, error %lx\n",
                        scRet
                        ));

            INET_ASSERT( scRet != SEC_E_MESSAGE_ALTERED );

            if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
            {
                DWORD dwAddlBufferNeeded = Buffers[1].cbBuffer;

                DEBUG_PRINT(API,
                             INFO,
                             ("UnsealMessage short of %d bytes\n",
                             dwAddlBufferNeeded
                             ));

                 //
                 // If we're missing data, return to get the missing data.
                 // But make sure we have enough room first!
                 //

                if (!m_pdblbufBuffer->ResizeBufferIfNeeded(dwAddlBufferNeeded)) {
                    scRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                *lpdwBytesNeeded = dwAddlBufferNeeded;
                break;
            }
            else if ( scRet == 0x00090317 /*SEC_I_CONTEXT_EXPIRED*/)
            {
                //
                // Ignore this error and treat this like a simple terminator
                //  to end the connection.
                //

                scRet = ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }



        //
        // Success we decrypted a block
        //

        LPBYTE  lpExtraBuffer;
        DWORD   dwExtraBufferSize;
        LPBYTE  lpDecryptedBuffer;
        DWORD   dwDecryptedBufferSize;


        lpDecryptedBuffer       =   (LPBYTE) Buffers[1].pvBuffer;
        dwDecryptedBufferSize   =   Buffers[1].cbBuffer;

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //

        if ( Buffers[2].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[2].pvBuffer;
            dwExtraBufferSize = Buffers[2].cbBuffer;
        }
        else if ( Buffers[3].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[3].pvBuffer;
            dwExtraBufferSize = Buffers[3].cbBuffer;
        }
        else
        {
            lpExtraBuffer = NULL;
            dwExtraBufferSize = 0;
        }


        m_pdblbufBuffer->SetOutputInputBuffer(
            lpDecryptedBuffer,
            dwDecryptedBufferSize,
            lpExtraBuffer,
            dwExtraBufferSize,
            FALSE // don't combine.
        );

        if ( dwDecryptedBufferSize == 0 )
            break;  // No more data to process

        INET_ASSERT( *lpdwOutBufferLeft );  // don't expect to get here this way.

    } while ( *lpdwOutBufferLeft && scRet == ERROR_SUCCESS );



    DEBUG_PRINT(API,
         INFO,
         ("DecryptData returning, "
          "OutBuffer = %x, DecryptBytesRecv = %d\n",
         lpOutBuffer,
         *lpdwOutBufferBytesRead
         ));

    DEBUG_LEAVE((DWORD)scRet);

    return ( scRet );
}


VOID
ICSecureSocket::TerminateSecConnection(
    VOID
    )

/*++

Routine Description:

    This function deletes the security context handle which result
    in deleting the local data structures with which they are associated.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ICSecureSocket::TerminateSecConnection",
                 "{%#x [%#x:%#x]}",
                 this,
                 m_hContext.dwUpper,
                 m_hContext.dwLower
                 ));

    INET_ASSERT(IsSecure());

    //INET_ASSERT(m_hContext.dwLower != 0);
    //INET_ASSERT(m_hContext.dwUpper != 0);

    if (GlobalSecFuncTable) {
        if (!((m_hContext.dwLower == 0) && (m_hContext.dwUpper == 0))) {
            // There are cases where because of circular dependencies
            // schannel could get unloaded before wininet. In that case
            // this call could fault. This usually happens when the process 
            // is shutting down.
            __try {
                g_DeleteSecurityContext(&m_hContext);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
            }
            ENDEXCEPT

            m_hContext.dwLower = m_hContext.dwUpper = 0;
        }
    } else {

        DEBUG_PRINT(API,
                    ERROR,
                    ("Attempting to Delete a security context, with a NULL SSPI func table!(missing SCHANNEL.DLL?)\n"
                    ));

    }

    DEBUG_LEAVE(0);
}

#ifdef SECPKG_ATTR_PROTO_INFO
/*++

ProtoInfoToString:

    This routine converts an SSPI SecPkgContext_ProtoInfo structure into a
    string.  The returned string must be released via LocalFree.

Arguments:

    pProtoInfo supplies the SecPkgContext_ProtoInfo structure to be converted to
    string representation.

Return Value:

    Non-NULL is the address of the returned string.  This must be freed via
        LocalFree once it is no longer needed.

    NULL implies no memory is available.

Author:

    Doug Barlow (dbarlow) 4/23/1996

--*/


PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo)
{
    TCHAR
        szValue[32],
        szSep[8];
    LPTSTR
        szFinal
            = NULL;
    DWORD
        length;

    length = GetLocaleInfo(
                LOCALE_USER_DEFAULT,
                LOCALE_SDECIMAL,
                szSep,
                sizeof(szSep) / sizeof(TCHAR));
    if (0 >= length)
        lstrcpy(szSep, TEXT("."));

    length = wsprintf(
                szValue,
                TEXT("%d%s%d"),
                pProtoInfo->majorVersion,
                szSep,
                pProtoInfo->minorVersion);
    INET_ASSERT(sizeof(szValue) / sizeof(TCHAR) > length);

    length = lstrlen(pProtoInfo->sProtocolName);
    length += 2;                    // Space and Trailing NULL
    length += lstrlen(szValue);
    szFinal = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, length * sizeof(TCHAR));
    if (NULL != szFinal)
    {
        lstrcpy(szFinal, pProtoInfo->sProtocolName);
        lstrcat(szFinal, TEXT(" "));
        lstrcat(szFinal, szValue);
    }
    return szFinal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\rprintf.h ===
/*****************************************************************************
 *
 *  RPRINTF.C   RLF 06/15/89
 *
 *  CONTENTS    rprintf     limited re-entrant version of printf
 *              rsprintf    limited re-entrant version of sprintf
 *              _sprintf    routine which does the work
 *
 *  NOTES       Tab Stops = 4
 *
 *  $Log:   T:/pvcs/h/rprintf.h_v  $
 *
 *    Rev 1.1   29 Oct 1989 11:50:16   Richard Firth
 * Added defines for PRINTF and SPRINTF to allow easy modification when MS gets
 * the real thing working for multi-threaded programs
 *
 *    Rev 1.0   29 Aug 1989 20:04:40   RICHARDF
 * Initial revision.
 *
 ****************************************************************************/

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif
int cdecl rsprintf(char*, char*, ...);
int cdecl _sprintf(char*, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

//#define rsprintf wsprintf
//#define _sprintf wsprintf

#define RPRINTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\debugmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.cxx

Abstract:

    Debug memory allocator

    Contents:
        InternetDebugMemInitialize
        InternetDebugMemTerminate
        InternetDebugAllocMem
        InternetDebugFreeMem
        InternetDebugReAllocMem
        InternetDebugSizeMem
        InternetDebugCheckMemFreed
        InternetDebugMemReport
        (InternetDebugCheckMemBlock)
        (DebugFillMem)
        (InternetAlloc)
        (InternetFree)
        (InternetReAlloc)
        (InternetSize)
        (InternetHeapAlloc)
        (InternetHeapReAlloc)
        (InternetHeapFree)
        (InternetHeapSize)
        (InternetDebugMemTest)
        (ReportMemoryUsage)
        (ReportMemoryBlocks)
        (DumpDeferredFreeList)
        (DumpMemoryList)
        (FindAndDumpDeferredBlock)
        (DumpBlock)
        (DumpDebugMemoryHeader)
        (DumpDebugMemoryFooter)
        (DumpUserData)
        (MapLastAccessOperation)
        (MapMemoryFlags)
        (DbgMemGetDebugSymbol)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if defined(USE_DEBUG_MEMORY)

//
// manifests
//

#define DEFAULT_INITIAL_HEAP_SIZE   (64 K)
#define DEFAULT_MAXIMUM_HEAP_SIZE   (1 M)
#define DEFAULT_HEADER_GUARD_SIZE   32
#define DEFAULT_FOOTER_GUARD_SIZE   32
#define DEFAULT_ALLOC_ALIGNMENT     4
#define HEADER_SIGNATURE            0x414d454d  // "MEMA"
#define FOOTER_SIGNATURE            0x434f4c4c  // "LLOC"
#define DWORD_ALLOC_FILL            0xc5c5c5c5
#define BYTE_ALLOC_FILL             0xc5
#define BYTE_ALLOC_FILL_EXTRA       0x88
#define GUARD_DWORD_FILL            0x44524147  // "GARD"
#define DWORD_FREE_FILL             0xb7b7b7b7
#define BYTE_FREE_FILL              0xb7
#define DEFAULT_MAX_BLOCKS_DUMPED   1024
#define DEFAULT_MAX_DATA_DUMPED     65536
#define DEFAULT_BACKTRACE_DEPTH     2

//
// only perform stack dump for x86 (or other stack-based processors)
//

#if defined(i386)
#define DUMP_STACK  1
#else
#define DUMP_STACK  0
#endif

//
// just using one stack these days
//

#define ONE_STACK   1

//
// private types
//

typedef enum {
    MemAllocate = 0x6f6c6c41,   // "Allo"
    MemReallocate = 0x6c416552, // "ReAl"
    MemLock = 0x6b636f4c,       // "Lock"
    MemUnlock = 0x6f6c6e55,     // "Unlo"
    MemFree = 0x65657246,       // "Free"
    MemSize = 0x657a6953        // "Size"
} MEMORY_ACTION;

typedef enum {
    HEAP_COMPACT_NEVER = 0,
    HEAP_COMPACT_ON_ALLOC_FAIL,
    HEAP_COMPACT_ON_FREE
} HEAP_COMPACT_TYPE;

typedef enum {
    HEAP_VALIDATE_NEVER = 0,
    HEAP_VALIDATE_ON_ALLOC,
    HEAP_VALIDATE_ON_FREE
} HEAP_VALIDATE_TYPE;

//
// DEBUG_MEMORY_HEADER - keeps debug memory on list
//

typedef struct {
    LIST_ENTRY List;
    DWORD ThreadId;
    LPSTR CreatedFile;
    DWORD CreatedLine;
    LPSTR AccessedFile;
    DWORD AccessedLine;
    SIZE_T RequestedLength;
    SIZE_T BlockLength;
    SIZE_T ActualLength;
    DWORD Signature;
    DWORD Flags;
    DWORD TimeDeferred;
    LONG ClashTest;
    MEMORY_ACTION LastAccessOperation;
#if DUMP_STACK
#if ONE_STACK
    LPVOID Stack[8];    // should be variable
#else
    LPVOID CreateStack[4];
    LPVOID LastAccessStack[4];
#endif // ONE_STACK
#endif // DUMP_STACK
    DWORD Guard[2];

    //
    // sizeof(MEMORY_SIGNATURE) currently 24 DWORDs in Win32
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

//
// DEBUG_MEMORY_FOOTER - used to check for overwrites
//

typedef struct {
    DWORD Guard[4];
    DWORD Signature;
    SIZE_T BlockLength;  // should be the same as the header
    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs in Win32
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// private data
//

PRIVATE BOOL MemoryPackageInitialized = FALSE;

//
// InternetDebugMemFlags - bitfield of flags controlling debug memory usage.
// The default is no debug alloc (don't create header + footers) and to use
// LocalAlloc() etc.
//

//
// BUGBUG - I'm making an assumption that the compiler thinks the bits have the
//          same values as I think they have. If not, it could mess up the
//          registry/environment flags
//

PRIVATE struct {                                            // default value
    DWORD bNoDebugAlloc             : 1;    //  0x00000001          TRUE
    DWORD bUseLocalAlloc            : 1;    //  0x00000002          TRUE
    DWORD bUseSymbols               : 1;    //  0x00000004          FALSE
    DWORD bAssertOnMemoryErrors     : 1;    //  0x00000008          FALSE
    DWORD bFillMemoryOnAlloc        : 1;    //  0x00000010          FALSE
    DWORD bFillMemoryOnFree         : 1;    //  0x00000020          FALSE
    DWORD bReportMemoryUsage        : 1;    //  0x00000040          FALSE
    DWORD bReportUnfreedBlocks      : 1;    //  0x00000080          FALSE
    DWORD bReportMemoryFooters      : 1;    //  0x00000100          FALSE
    DWORD bReportUserData           : 1;    //  0x00000200          FALSE
    DWORD bStopDumpIfBadBlock       : 1;    //  0x00000400          FALSE
    DWORD bLimitUnfreedBlocks       : 1;    //  0x00000800          FALSE
    DWORD bLimitUserData            : 1;    //  0x00001000          FALSE
    DWORD bDumpAsDwords             : 1;    //  0x00002000          FALSE
    DWORD bHeapNoSerialize          : 1;    //  0x00004000          FALSE
    DWORD bHeapGenerateExceptions   : 1;    //  0x00008000          FALSE
    DWORD bHeapIsGrowable           : 1;    //  0x00010000          FALSE
    DWORD bDeferFree                : 1;    //  0x00020000          FALSE
    DWORD bDumpToFile               : 1;    //  0x00040000          FALSE
} InternetDebugMemFlags = {
    TRUE,   // no debug alloc
    TRUE,   // use LocalAlloc()
    FALSE,  // don't load debug symbols
    FALSE,  // don't assert on memory errors
    FALSE,  // don't fill memory on alloc
    FALSE,  // don't fill memory on free
    FALSE,  // don't report memory usage (stats)
    FALSE,  // don't report unfreed blocks
    FALSE,  // don't report memory footers (irrelevant)
    FALSE,  // don't report user data (irrelevant)
    FALSE,  // don't stop dump if bad block (irrelevant)
    FALSE,  // don't limit dump of unfreed blocks (irrelevant)
    FALSE,  // don't limit dump of user data (irrelevant)
    FALSE,  // don't dump user data as DWORDs (irrelevant)
    FALSE,  // serialize access to heap (irrelevant)
    FALSE,  // don't generate heap exceptions (irrelevant)
    TRUE,   // heap is growable (irrelevant)
    FALSE,  // don't defer frees
    FALSE   // don't dump to wininet log file
};

//
// defines to make using InternetDebugMemFlags easier
//

#define bNoDebugAlloc           InternetDebugMemFlags.bNoDebugAlloc
#define bUseLocalAlloc          InternetDebugMemFlags.bUseLocalAlloc
#define bUseSymbols             InternetDebugMemFlags.bUseSymbols
#define bAssertOnMemoryErrors   InternetDebugMemFlags.bAssertOnMemoryErrors
#define bFillMemoryOnAlloc      InternetDebugMemFlags.bFillMemoryOnAlloc
#define bFillMemoryOnFree       InternetDebugMemFlags.bFillMemoryOnFree
#define bReportMemoryUsage      InternetDebugMemFlags.bReportMemoryUsage
#define bReportUnfreedBlocks    InternetDebugMemFlags.bReportUnfreedBlocks
#define bReportMemoryFooters    InternetDebugMemFlags.bReportMemoryFooters
#define bReportUserData         InternetDebugMemFlags.bReportUserData
#define bStopDumpIfBadBlock     InternetDebugMemFlags.bStopDumpIfBadBlock
#define bLimitUnfreedBlocks     InternetDebugMemFlags.bLimitUnfreedBlocks
#define bLimitUserData          InternetDebugMemFlags.bLimitUserData
#define bDumpAsDwords           InternetDebugMemFlags.bDumpAsDwords
#define bHeapNoSerialize        InternetDebugMemFlags.bHeapNoSerialize
#define bHeapGenerateExceptions InternetDebugMemFlags.bHeapGenerateExceptions
#define bHeapIsGrowable         InternetDebugMemFlags.bHeapIsGrowable
#define bDeferFree              InternetDebugMemFlags.bDeferFree
#define bDumpToFile             InternetDebugMemFlags.bDumpToFile

PRIVATE DWORD MaxBlocksDumped = DEFAULT_MAX_BLOCKS_DUMPED;
PRIVATE DWORD MaxUserDataDumped = DEFAULT_MAX_DATA_DUMPED;
PRIVATE DWORD StackBacktraceDepth = DEFAULT_BACKTRACE_DEPTH;

//
// heap variables
//

PRIVATE HANDLE hDebugHeap = NULL;
PRIVATE DWORD InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
PRIVATE DWORD MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
PRIVATE HEAP_COMPACT_TYPE HeapCompactControl = HEAP_COMPACT_NEVER;
PRIVATE HEAP_VALIDATE_TYPE HeapValidateControl = HEAP_VALIDATE_NEVER;

//
// debug mem signatures etc.
//

PRIVATE DWORD AllocAlignment = DEFAULT_ALLOC_ALIGNMENT;
PRIVATE DWORD HeaderGuardSize = DEFAULT_HEADER_GUARD_SIZE;
PRIVATE DWORD FooterGuardSize = DEFAULT_FOOTER_GUARD_SIZE;
PRIVATE DWORD AllocMemoryFiller = DWORD_ALLOC_FILL;
PRIVATE DWORD FreeMemoryFiller = DWORD_FREE_FILL;

//
// usage variables - access using some sort of lock (critsec/interlocked)
//

PRIVATE CRITICAL_SECTION MemoryVarsCritSec;
PRIVATE SIZE_T TotalActualMemoryAllocated = 0;  // cumulative
PRIVATE SIZE_T TotalBlockMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalRealMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalActualMemoryFreed = 0;      //     "
PRIVATE SIZE_T TotalBlockMemoryFreed = 0;        //     "
PRIVATE SIZE_T TotalRealMemoryFreed = 0;         //     "
PRIVATE SIZE_T ActualMemoryAllocated = 0;        // difference
PRIVATE SIZE_T BlockLengthAllocated = 0;         //     "
PRIVATE SIZE_T RealLengthAllocated = 0;          //     "
PRIVATE DWORD MemoryAllocations = 0;            // cumulative
PRIVATE DWORD GoodMemoryAllocations = 0;        //     "
PRIVATE DWORD MemoryReAllocations = 0;          //     "
PRIVATE DWORD GoodMemoryReAllocations = 0;      //     "
PRIVATE DWORD MemoryFrees = 0;                  //     "
PRIVATE DWORD GoodMemoryFrees = 0;              //     "
PRIVATE SIZE_T LargestBlockRequested = 0;
PRIVATE SIZE_T LargestBlockAllocated = 0;
PRIVATE LPSTR LargestBlockRequestedFile = NULL;
PRIVATE DWORD LargestBlockRequestedLine = 0;
PRIVATE SIZE_T SmallestBlockRequested = (SIZE_T)-1;
PRIVATE SIZE_T SmallestBlockAllocated = (SIZE_T)-1;
PRIVATE LPSTR SmallestBlockRequestedFile = NULL;
PRIVATE DWORD SmallestBlockRequestedLine = 0;
PRIVATE DWORD DeferFreeTime = 0;

//
// lists
//

PRIVATE SERIALIZED_LIST AllocatedBlockList;
PRIVATE SERIALIZED_LIST DeferredFreeList;

//
// macros
//

#define MEMORY_ASSERT(x) \
    if (bAssertOnMemoryErrors) { \
        INET_ASSERT(x); \
    } else { \
        /* NOTHING */ \
    }

//
// private prototypes
//

PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    );

PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    );

PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
VOID
InternetDebugMemTest(
    VOID
    );

PRIVATE
VOID
ReportMemoryUsage(
    VOID
    );

PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    );

PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    );

PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    );

PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    );

PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    );

PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    );

PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

//
// functions
//


VOID
InternetDebugMemInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes debug memory allocator

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL init;

    init = (BOOL)InterlockedExchange((LPLONG)&MemoryPackageInitialized, TRUE);
    if (init) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

        return;
    }

    InitializeSerializedList(&AllocatedBlockList);
    InitializeSerializedList(&DeferredFreeList);
    InitializeCriticalSection(&MemoryVarsCritSec);

    //
    // sleaze: disable any debug output until we finish this. Debug log
    // routines want to allocate memory(!). InternetReadRegistryDword()
    // (called from InternetGetDebugVariable()) wants to perform DEBUG_ENTER
    // etc.
    //

    DWORD debugControlFlags = InternetDebugControlFlags;

    InternetDebugControlFlags = DBG_NO_DEBUG;

    //
    // if "WininetMem" is set then we set up to use debug memory - we use our
    // own heap, full debugging & reporting etc. (basically max memory debugging
    // as defined by me)
    //

    DWORD useDefaultDebugMemoryFlags = FALSE;

    InternetGetDebugVariable("WininetMem",
                             &useDefaultDebugMemoryFlags
                             );
    if (useDefaultDebugMemoryFlags) {
        bNoDebugAlloc = FALSE;          // use full debug allocator (header + footers, etc.)
        bUseLocalAlloc = FALSE;         // use our own heap
        bUseSymbols = FALSE;            // don't load debug symbols
        bAssertOnMemoryErrors = TRUE;   // assert to debugger/log if memory errors
        bFillMemoryOnAlloc = TRUE;      // fill user data w/ signature if not zeroinit
        bFillMemoryOnFree = TRUE;       // fill freed memory (useful on Win95/non-debug on NT)
        bReportMemoryUsage = TRUE;      // dump memory usage stats
        bReportUnfreedBlocks = TRUE;    // dump unfreed blocks (headers)
        bReportMemoryFooters = TRUE;    // dump unfreed block footers
        bReportUserData = TRUE;         // dump unfreed block user data
        bStopDumpIfBadBlock = TRUE;     // stop dumping if error occurs
        bLimitUnfreedBlocks = TRUE;     // limit block dump in case of loop in list
        bLimitUserData = TRUE;          // limit user data dump in case of bad length
        bDumpAsDwords = TRUE;           // dump data in dc format vs. db
        bHeapNoSerialize = FALSE;       // heap functions are serialized
        bHeapGenerateExceptions = FALSE;// heap functions return errors
        bHeapIsGrowable = FALSE;        // limit heap to maximum size (1 Meg)
        if (useDefaultDebugMemoryFlags == 2) {
            bDumpToFile = TRUE;
        }
    } else {

        //
        // no use-debug-mem override, see if there are any specific flags set
        //

        InternetGetDebugVariable("WininetDebugMemFlags",
                                 (LPDWORD)&InternetDebugMemFlags
                                 );
    }

    //
    // we used to load IMAGEHLP.DLL here and not use its functions until we were
    // dumping still in-use memory during DLL shutdown. Problem is that the
    // system has probably already freed IMAGEHLP.DLL by the time we come to use
    // it, resulting in GPF, so now we only load it at the time we're about to
    // use it
    //

    //if (bUseSymbols) {
    //    InitSymLib();
    //}

    if (!bUseLocalAlloc) {

        //
        // not using LocalAlloc(), using HeapAlloc(). Create heap
        //

        InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
        InternetGetDebugVariable("WininetDebugHeapInitialSize",
                                 &InitialHeapSize
                                 );

        MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
        InternetGetDebugVariable("WininetDebugHeapMaximumSize",
                                 &MaximumHeapSize
                                 );

        if (bHeapIsGrowable) {
            MaximumHeapSize = 0;
        }

        hDebugHeap = HeapCreate((bHeapGenerateExceptions
                                    ? HEAP_GENERATE_EXCEPTIONS
                                    : 0)
                                | (bHeapNoSerialize
                                    ? HEAP_NO_SERIALIZE
                                    : 0),
                                InitialHeapSize,
                                MaximumHeapSize
                                );
        if (hDebugHeap == NULL) {

            DEBUG_PUT(("HeapCreate() failed - %d\n",
                        GetLastError()
                        ));

            bUseLocalAlloc = TRUE;
        } else {
            HeapCompactControl = HEAP_COMPACT_NEVER;
            InternetGetDebugVariable("WininetDebugHeapCompactControl",
                                     (LPDWORD)&HeapCompactControl
                                     );

            HeapValidateControl = HEAP_VALIDATE_NEVER;
            InternetGetDebugVariable("WininetDebugHeapValidateControl",
                                     (LPDWORD)&HeapValidateControl
                                     );

            DEBUG_PUT(("Wininet heap = %#x\n",
                        hDebugHeap
                        ));

        }
    }

    //
    // restore default debug flags
    //

    InternetDebugControlFlags = debugControlFlags;

    //InternetDebugMemTest();
}


VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    )

/*++

Routine Description:

    Frees resources allocated in InternetDebugMemInitialize, after checking that
    all memory is freed

Arguments:

    bReport - TRUE if in-use blocks reported at termination

Return Value:

    None.

--*/

{
    BOOL bOpened = bReport ? InternetDebugMemReport(TRUE, FALSE) : FALSE;

    InternetDebugCheckMemFreed(FALSE);
    DeleteCriticalSection(&MemoryVarsCritSec);
    TerminateSerializedList(&AllocatedBlockList);
    TerminateSerializedList(&DeferredFreeList);

    if (hDebugHeap != NULL) {

        //
        // any future allocations(!) must use process heap
        //

        bUseLocalAlloc = TRUE;

        if (!HeapDestroy(hDebugHeap)) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapDestroy(%#x) returns %s (%d)\n",
                        hDebugHeap,
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    }
    if (bOpened) {
        InternetCloseDebugFile();
    }
    MemoryPackageInitialized = FALSE;
}


HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Debug memory allocator. If this succeeds, then the real block is put on our
    list and has its head & tail (& possibly contents) initialized. The caller
    gets an pointer which is an offset to the user area in the block

Arguments:

    Flags   - controlling flags (normally passed to LocalAlloc)

    Size    - of block to allocate

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to caller's start of allocated block

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugAllocMem(%#x, %d) = ", Flags, Size);
    InterlockedIncrement((LPLONG)&MemoryAllocations);

    //
    // keep these tests separate so we don't have to look up the flags #defines
    //

    INET_ASSERT(!(Flags & LMEM_MOVEABLE));
    INET_ASSERT(!(Flags & LMEM_DISCARDABLE));

    if (Size == 0) {

        DEBUG_PRINT(MEMALLOC,
                    WARNING,
                    ("InternetDebugAllocMem(%#x, %d)\n",
                    Flags,
                    Size
                    ));

        MEMORY_ASSERT(FALSE);

    }

    SIZE_T blockLength;

    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }

    //
    // possible problem: if Size + signatures would overflow UINT. Only really
    // problematic on 16-bit platforms
    //

    if (blockLength < Size) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)Size
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    //
    // BUGBUG - allocating 0 bytes?
    //

    HLOCAL hLocal = InternetAlloc(Flags, blockLength);

    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryAllocations);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    SIZE_T actualLength = InternetSize(hLocal);
    SIZE_T requestedLength;

    if (bNoDebugAlloc) {
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        requestedLength = Size;
        if (actualLength > LargestBlockAllocated) {
            LargestBlockAllocated = actualLength;
        } else if (actualLength < SmallestBlockAllocated) {
            SmallestBlockAllocated = actualLength;
        }
    }

    EnterCriticalSection(&MemoryVarsCritSec);
    TotalActualMemoryAllocated += actualLength;
    TotalBlockMemoryAllocated += blockLength;
    TotalRealMemoryAllocated += requestedLength;
    ActualMemoryAllocated += actualLength;
    BlockLengthAllocated += blockLength;
    RealLengthAllocated += requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);

    if (bNoDebugAlloc || (hLocal == NULL)) {
        if ((hLocal != NULL) && !(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
            DebugFillMem(hLocal, Size, AllocMemoryFiller);
        }
//dprintf("%#x\n", hLocal);
        return hLocal;
    }

    LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

    //InitializeListHead(&lpHeader->List);
    lpHeader->ThreadId = GetCurrentThreadId();
    lpHeader->CreatedFile = File;
    lpHeader->CreatedLine = Line;
    lpHeader->AccessedFile = File;
    lpHeader->AccessedLine = Line;
    lpHeader->RequestedLength = Size;
    lpHeader->BlockLength = blockLength;
    lpHeader->ActualLength = actualLength;
    lpHeader->Signature = HEADER_SIGNATURE;
    lpHeader->Flags = Flags;
    lpHeader->TimeDeferred = 0;
    lpHeader->ClashTest = -1;
    lpHeader->LastAccessOperation = MemAllocate;

#if DUMP_STACK
#if ONE_STACK

    memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
    GET_CALL_STACK(lpHeader->Stack);

#else

    GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                        &lpHeader->CreateStack[1]
                        );

    memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

    GET_CALL_STACK(lpHeader->CreateStack);

    memcpy(lpHeader->LastAccessStack,
           lpHeader->CreateStack,
           sizeof(lpHeader->LastAccessStack)
           );

#endif // ONE_STACK
#endif // DUMP_STACK

    UINT i;

    for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
        lpHeader->Guard[i] = GUARD_DWORD_FILL;
    }

    //
    // BUGBUG - should be using AllocAlignment - could be > sizeof(DWORD)
    //

    if (!(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
        DebugFillMem(lpHeader + 1, Size, AllocMemoryFiller);
    }

    UINT bFillLength2 = (Size % sizeof(DWORD)) ? (sizeof(DWORD) - (Size % sizeof(DWORD))) : 0;
    LPBYTE lpbUserPointer = (LPBYTE)(lpHeader + 1) + Size;

    for (i = 0; i < bFillLength2; ++i) {
        *lpbUserPointer++ = BYTE_ALLOC_FILL_EXTRA;
    }

    LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)lpbUserPointer;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
        lpFooter->Guard[i] = GUARD_DWORD_FILL;
    }

    lpFooter->BlockLength = blockLength;
    lpFooter->Signature = FOOTER_SIGNATURE;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
        lpFooter->Guard2[i] = GUARD_DWORD_FILL;
    }

    if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, FALSE)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x already on list?\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

    }

    //
    // put at the tail of list so we can view unfreed blocks in chronological
    // order
    //

    InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List);

//dprintf("%#x\n", lpHeader + 1);
    return (HLOCAL)(lpHeader + 1);
}


HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Frees a block of memory allocated by InternetDebugAllocMem(). Checks that
    the block is on our allocated block list, and that the header and footer
    areas are still intact

Arguments:

    hLocal  - handle (pointer) of block to free

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugFreeMem(%#x)\n", hLocal);
    InterlockedIncrement((LPLONG)&MemoryFrees);

    if (hLocal == NULL) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(NULL)\n"
                    ));

        MEMORY_ASSERT(FALSE);

        return InternetFree(hLocal);
    }

    HLOCAL hLocalOriginal = hLocal;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T realLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        realLength = actualLength;
    } else {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
        actualLength = InternetSize(hLocal);

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

        if (CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE)) {
            RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List);

            if (!((lpHeader->ActualLength == actualLength)
            && (lpHeader->BlockLength <= actualLength)
            && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
            && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InternetDebugFreeMem(%#x): block lengths mismatch\n",
                            hLocalOriginal
                            ));

                MEMORY_ASSERT(FALSE);
            }
            if (InternetDebugCheckMemBlock(lpHeader)) {
                blockLength = lpHeader->BlockLength;
                realLength = lpHeader->RequestedLength;
            } else {
                blockLength = 0;
                realLength = 0;
            }
            if (bDeferFree) {

#if DUMP_STACK
#if ONE_STACK

                memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
                GET_CALL_STACK(lpHeader->Stack);

#else

                GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                                    &lpHeader->CreateStack[1]
                                    );

                memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

                GET_CALL_STACK(lpHeader->CreateStack);

                memcpy(lpHeader->LastAccessStack,
                       lpHeader->CreateStack,
                       sizeof(lpHeader->LastAccessStack)
                       );

#endif // ONE_STACK
#endif // DUMP_STACK

                InsertAtTailOfSerializedList(&DeferredFreeList, &lpHeader->List);
                hLocal = NULL;
            }
        } else {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugFreeMem(%#x): can't find %#x\n",
                        hLocalOriginal,
                        &lpHeader->List
                        ));

            MEMORY_ASSERT(FALSE);

            FindAndDumpDeferredBlock(hLocal);
        }
    }

    if (hLocal && bFillMemoryOnFree) {
        DebugFillMem(hLocal, actualLength, FreeMemoryFiller);
    }

    hLocal = InternetFree(hLocal);

    if (hLocal == NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryFrees);
        EnterCriticalSection(&MemoryVarsCritSec);
        TotalActualMemoryFreed += actualLength;
        TotalBlockMemoryFreed += blockLength;
        TotalRealMemoryFreed += realLength;
        ActualMemoryAllocated -= actualLength;
        BlockLengthAllocated -= blockLength;
        RealLengthAllocated -= realLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(%#x) failed\n",
                    hLocalOriginal
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = hLocalOriginal;
    }

    return hLocal;
}


HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Reallocates a debug memory block allocated by InternetDebugAllocMem()

Arguments:

    hLocal  - the handle (pointer) of the allocated block

    Size    - requested size of new block; can be larger or smaller than current
              size

    Flags   - controlling flags (normally passed to LocalReAlloc)

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to new block. May be same or different than previous
                  pointer, depending on flags

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugReAllocMem(%#x, %d, %#x)\n", hLocal, Size, Flags);
    InterlockedIncrement((LPLONG)&MemoryReAllocations);

    //
    // we can't handle the following flags
    //

    INET_ASSERT(!(Flags & LMEM_MODIFY));

    //
    // can't handle reallocating down to zero
    //

    if (Size == 0) {

        MEMORY_ASSERT(FALSE);

    }

    HLOCAL hLocalOriginal = hLocal;
    LPDEBUG_MEMORY_HEADER lpHeader;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T requestedLength;
    SIZE_T oldRequestedLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        hLocal = (HLOCAL)lpHeader;
        if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): can't find %#x\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);

            return hLocalOriginal;
        }
        RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List);
        InternetDebugCheckMemBlock(lpHeader);
        actualLength = InternetSize((HLOCAL)lpHeader);
        blockLength = lpHeader->BlockLength;
        requestedLength = lpHeader->RequestedLength;
        oldRequestedLength = requestedLength;
        if (!((lpHeader->ActualLength == actualLength)
        && (lpHeader->BlockLength <= actualLength)
        && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
        && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): block lengths mismatch\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);
        }
    }
    EnterCriticalSection(&MemoryVarsCritSec);
    ActualMemoryAllocated -= actualLength;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);
    requestedLength = Size;
    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }
    hLocal = InternetReAlloc(hLocal, blockLength, Flags);
    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryReAllocations);
        actualLength = InternetSize(hLocal);
        if (bNoDebugAlloc) {
            blockLength = actualLength;
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
            //InitializeListHead(&lpHeader->List);
            lpHeader->ThreadId = GetCurrentThreadId();
            lpHeader->AccessedFile = File;
            lpHeader->AccessedLine = Line;
            lpHeader->RequestedLength = requestedLength;
            lpHeader->BlockLength = blockLength;
            lpHeader->ActualLength = actualLength;
            lpHeader->Flags = Flags;
            lpHeader->TimeDeferred = 0;
            lpHeader->ClashTest = -1;
            lpHeader->LastAccessOperation = MemReallocate;

#if DUMP_STACK
#if ONE_STACK
#else

            //GET_CALLERS_ADDRESS(&lpHeader->LastAccessStack[0],
            //                    &lpHeader->LastAccessStack[1]
            //                    );

            memset(lpHeader->LastAccessStack, 0, sizeof(lpHeader->LastAccessStack));

            GET_CALL_STACK(lpHeader->LastAccessStack);

#endif // ONE_STACK
#endif // DUMP_STACK

            LPBYTE extraPointer;
            UINT dwFillLength;
            UINT i;

            if ((requestedLength > oldRequestedLength)
            && bFillMemoryOnAlloc && !(Flags & LMEM_ZEROINIT)) {

                extraPointer = (LPBYTE)(lpHeader + 1) + oldRequestedLength;

                SIZE_T difference = requestedLength - oldRequestedLength;
                DWORD dwFiller = AllocMemoryFiller;
                SIZE_T syncLength = oldRequestedLength & (sizeof(DWORD) - 1);

                if (syncLength) {
                    syncLength = sizeof(DWORD) - syncLength;
                    syncLength = min(syncLength, difference);
                    difference -= syncLength;
                    for (i = 0; i < syncLength; ++i) {
                        *extraPointer++ = ((LPBYTE)&dwFiller)[i];
                    }
                }

                //dwFillLength = difference / sizeof(DWORD);
                //difference %= sizeof(DWORD);
                //while (dwFillLength--) {
                //    *(LPDWORD)extraPointer = 0;
                //    extraPointer += sizeof(DWORD);
                //}
                //while (difference--) {
                //    *extraPointer++ = 0;
                //}

                if (difference) {
                    DebugFillMem(extraPointer, difference, dwFiller);
                    extraPointer += difference;
                }
            } else {
                extraPointer = (LPBYTE)(lpHeader + 1) + requestedLength;
            }

            SIZE_T bFillLength = (sizeof(DWORD) - (requestedLength % sizeof(DWORD))) & (sizeof(DWORD) - 1);

            while (bFillLength--) {
                *extraPointer++ = BYTE_ALLOC_FILL_EXTRA;
            }

            LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)extraPointer;

            INET_ASSERT(lpFooter == (LPDEBUG_MEMORY_FOOTER)
                ((LPBYTE)(lpHeader + 1) + ROUND_UP_DWORD(requestedLength)));

            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
                lpFooter->Guard[i] = GUARD_DWORD_FILL;
            }
            lpFooter->Signature = FOOTER_SIGNATURE;
            lpFooter->BlockLength = blockLength;
            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
                lpFooter->Guard2[i] = GUARD_DWORD_FILL;
            }
            InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List);
            hLocal = (HLOCAL)(lpHeader + 1);
        }
        EnterCriticalSection(&MemoryVarsCritSec);
        ActualMemoryAllocated += actualLength;
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += requestedLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Returns actual allocated block size

Arguments:

    hLocal  - pointer to allocated block

    File    - from where alloc called

    Line    - in File

Return Value:

    SIZE_T
        size of allocated block

--*/

{
    if (!MemoryPackageInitialized) {
        return 0;
    }

//dprintf("InternetDebugSizeMem(%#x)\n", hLocal);
    SIZE_T size = InternetSize(hLocal);

    if (!bNoDebugAlloc) {

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        SIZE_T sizeInHeader = lpHeader->BlockLength
                          - (sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER));

        INET_ASSERT((sizeInHeader <= size)
                    && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                    && (lpHeader->ActualLength == size)
                    );

        size = sizeInHeader;
    }

    return size;
}


BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    )

/*++

Routine Description:

    Called when we're about to quit. Checks that all allocated memory has been
    cleaned up

Arguments:

    bReport - TRUE if in-use blocks reported

Return Value:

    BOOL
        TRUE    - all allocated memory freed

        FALSE   - we failed to clean up

--*/

{
    if (bReport) {
        if (bReportMemoryUsage) {
            ReportMemoryUsage();
        }
        if (bReportUnfreedBlocks) {
            ReportMemoryBlocks();
        }
    }
    if (ElementsOnSerializedList(&AllocatedBlockList) != 0) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugCheckMemFreed(): %d memory blocks still allocated\n",
                    MemoryAllocations - MemoryFrees
                    ));

        MEMORY_ASSERT(FALSE);

        return FALSE;
    }
    return TRUE;
}


BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    )

/*++

Routine Description:

    Dumps in-use blocks to debugger and/or file

Arguments:

    bTerminateSymbols   - TRUE if we are to terminate symbols here

    bCloseFile          - TRUE if we are to close debug log file here

Return Value:

    BOOL    - TRUE if we opened debug log file

--*/

{
    BOOL bOpened = FALSE;

    if (bDumpToFile) {
        bOpened = InternetOpenDebugFile();
        if (bOpened) {
            InternetDebugResetControlFlags(DBG_NO_DEBUG);
            InternetDebugSetControlFlags(DBG_TO_FILE | DBG_NO_ASSERT_BREAK);
        }
    }
    ReportMemoryUsage();
    ReportMemoryBlocks();
    if (bUseSymbols && bTerminateSymbols) {
        TermSymLib();
    }
    if (bOpened && bCloseFile) {
        InternetCloseDebugFile();
    }
    return bOpened;
}

//
// private functions
//


PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    )

/*++

Routine Description:

    Fills memory with repeating debug pattern. Performs DWORD fill then finishes
    off any remaining bytes with character fill (rep movsd/rep movsb (ideally)
    (x86!))

Arguments:

    Pointer     - memory to fill

    Size        - of Pointer in bytes

    dwFiller    - DWORD value to use

Return Value:

    None.

--*/

{
    INET_ASSERT(((DWORD_PTR)Pointer & (sizeof(DWORD) - 1)) == 0);

    SIZE_T dwFillLength = Size / sizeof(DWORD);
    SIZE_T bFillLength = Size % sizeof(DWORD);

    //
    // assume > 0 DWORDs to fill
    //

    LPDWORD lpdwPointer = (LPDWORD)Pointer;
    SIZE_T i;

    for (i = 0; i < dwFillLength; ++i) {
        *lpdwPointer++ = dwFiller;
    }

    if (bFillLength) {

        LPBYTE lpbPointer = (LPBYTE)lpdwPointer;

        for (i = 0; i < bFillLength; ++i) {
            *lpbPointer++ = ((LPBYTE)&dwFiller)[i];
        }
    }
}


PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalAlloc(Flags, Size);
    } else {
        return InternetHeapAlloc(Flags, Size);
    }
}


PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Deallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to deallocate

Return Value:

    HLOCAL
        Success - NULL

        Failure - pointer to still allocated block

--*/

{
    if (bUseLocalAlloc) {
        return LocalFree(hLocal);
    } else {
        return InternetHeapFree(hLocal);
    }
}


PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to reallocate

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalReAlloc(hLocal, Size, Flags);
    } else {
        return InternetHeapReAlloc(hLocal, Size, Flags);
    }
}


PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Block sizer - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    if (bUseLocalAlloc) {
        return LocalSize(hLocal);
    } else {
        return InternetHeapSize(hLocal);
    }
}


PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocate memory from debug heap

Arguments:

    Flags   - passed to LocalAlloc

    Size    - of block to allocate

Return Value:

    HLOCAL

--*/

{
    HLOCAL hLocal;

    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapAlloc(hDebugHeap,
                                   (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                   | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                   | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                   Size
                                   );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = LocalAlloc(Flags, Size);
    }
    if (hLocal == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocate memory from debug heap

Arguments:

    hLocal  - pointer to block to reallocate

    Size    - new size

    Flags   - to LocalReAlloc

Return Value:

    HLOCAL
        Success - pointer to new block

        Failure - NULL

--*/

{
    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapReAlloc(hDebugHeap,
                                     (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                     | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                     | ((Flags & LMEM_MOVEABLE)
                                        ? 0
                                        : HEAP_REALLOC_IN_PLACE_ONLY)
                                     | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                     (LPVOID)hLocal,
                                     Size
                                     );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapReAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        //
        // block still allocated
        //

        hLocal = NULL;
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Free memory to debug heap

Arguments:

    hLocal  - to free

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    BOOL ok;

    if (hDebugHeap != NULL) {
        ok = HeapFree(hDebugHeap,
                      bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                      (LPVOID)hLocal
                      );
        if (!ok) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapFree() returns %s (%d)\n",
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapFree(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        ok = FALSE;
    }
    return ok ? NULL : hLocal;
}


PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines size of block allocated from debug heap

Arguments:

    hLocal  - handle (pointer) of block for which to get size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    SIZE_T size;

    if (hDebugHeap != NULL) {
        size = HeapSize(hDebugHeap,
                        bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                        (LPCVOID)hLocal
                        );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapSize(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        size = (SIZE_T)-1;
    }
    if (size == (SIZE_T)-1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    } else {
        return size;
    }
}


PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )

/*++

Routine Description:

    Checks the consistency of a debug memory block

Arguments:

    lpHeader    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    BOOL result;

    __try {
        LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)
            ((LPBYTE)lpHeader
                + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)));

        BOOL headerGuardOverrun = FALSE;
        UINT i;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuardOverrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuard2Overrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        LPBYTE lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RequestedLength;
        BOOL extraMemoryOverrun = FALSE;
        SIZE_T byteLength = ROUND_UP_DWORD(lpHeader->RequestedLength) - lpHeader->RequestedLength;

        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_ALLOC_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %#x\n",
                        lpHeader
                        ));

            MEMORY_ASSERT(FALSE);

            result = FALSE;
        } else {
            result = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %#x - exception occurred\n",
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
InternetDebugMemTest(
    VOID
    )
{
    //
    // test
    //

    LPVOID p;

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    *((LPBYTE)p + 1) = 'X';
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    p = (LPVOID)REALLOCATE_MEMORY(p, 1111, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 439, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 720, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 256, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 16, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 128, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 32, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 4, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 63, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 8);
    p = (LPVOID)REALLOCATE_MEMORY(p, 8, LMEM_FIXED);
    p = (LPVOID)REALLOCATE_MEMORY(p, 100000, LMEM_FIXED);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    InternetDebugCheckMemFreed(TRUE);
}


PRIVATE
VOID
ReportMemoryUsage(
    VOID
    )
{
    //
    // make copies of variables in case debug print functions want to allocate
    // debug memory (!)
    //

    SIZE_T totalActualMemoryAllocated;
    SIZE_T totalBlockMemoryAllocated;
    SIZE_T totalRealMemoryAllocated;
    SIZE_T totalActualMemoryFreed;
    SIZE_T totalBlockMemoryFreed;
    SIZE_T totalRealMemoryFreed;
    SIZE_T actualMemoryAllocated;
    SIZE_T blockLengthAllocated;
    SIZE_T realLengthAllocated;
    DWORD memoryAllocations;
    DWORD goodMemoryAllocations;
    DWORD memoryReAllocations;
    DWORD goodMemoryReAllocations;
    DWORD memoryFrees;
    DWORD goodMemoryFrees;
    SIZE_T largestBlockRequested;
    SIZE_T largestBlockAllocated;
    SIZE_T smallestBlockRequested;
    SIZE_T smallestBlockAllocated;

    EnterCriticalSection(&MemoryVarsCritSec);

    totalActualMemoryAllocated = TotalActualMemoryAllocated;
    totalBlockMemoryAllocated = TotalBlockMemoryAllocated;
    totalRealMemoryAllocated = TotalRealMemoryAllocated;
    totalActualMemoryFreed = TotalActualMemoryFreed;
    totalBlockMemoryFreed = TotalBlockMemoryFreed;
    totalRealMemoryFreed = TotalRealMemoryFreed;
    actualMemoryAllocated = ActualMemoryAllocated;
    blockLengthAllocated = BlockLengthAllocated;
    realLengthAllocated = RealLengthAllocated;
    memoryAllocations = MemoryAllocations;
    goodMemoryAllocations = GoodMemoryAllocations;
    memoryReAllocations = MemoryReAllocations;
    goodMemoryReAllocations = GoodMemoryReAllocations;
    memoryFrees = MemoryFrees;
    goodMemoryFrees = GoodMemoryFrees;
    largestBlockRequested = LargestBlockRequested;
    largestBlockAllocated = LargestBlockAllocated;
    smallestBlockRequested = SmallestBlockRequested;
    smallestBlockAllocated = SmallestBlockAllocated;

    LeaveCriticalSection(&MemoryVarsCritSec);

#ifdef _WIN64
    char numBuf[64];
#else
    char numBuf[32];
#endif

    DEBUG_PUT(("********************************************************************************\n"
               "\n"
               "WinInet Debug Memory Usage:\n"
               "\n"
               "\tInternetDebugMemFlags = %#08x\n"
               "\n",
               InternetDebugMemFlags
               ));
    DEBUG_PUT(("\tTotal Memory Allocated. . . , . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Block Length Allocated. . . . . %s\n", NiceNum(numBuf, totalBlockMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal User Length Allocated . . . . . %s\n", NiceNum(numBuf, totalRealMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Memory Freed. . . . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal Block Length Freed. . . . . . . %s\n", NiceNum(numBuf, totalBlockMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal User Length Freed . . . . . . . %s\n", NiceNum(numBuf, totalRealMemoryFreed, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, actualMemoryAllocated, 0)));
    DEBUG_PUT(("\tBlock Length Still Allocated. . . . . %s\n", NiceNum(numBuf, blockLengthAllocated, 0)));
    DEBUG_PUT(("\tUser Length Still Allocated . . . . . %s\n", NiceNum(numBuf, realLengthAllocated, 0)));
    DEBUG_PUT(("\tAttempted Memory Allocations. . . . . %s\n", NiceNum(numBuf, memoryAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Allocations . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Reallocations. . . . %s\n", NiceNum(numBuf, memoryReAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Reallocations . . . . . . %s\n", NiceNum(numBuf, goodMemoryReAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Frees. . . . . . . . %s\n", NiceNum(numBuf, memoryFrees, 0)));
    DEBUG_PUT(("\tGood Memory Frees . . . . . . . . . . %s\n", NiceNum(numBuf, goodMemoryFrees, 0)));
    DEBUG_PUT(("\tLargest Block Requested . . . . . . . %s\n", NiceNum(numBuf, largestBlockRequested, 0)));
    DEBUG_PUT(("\tLargest Block Allocated . . . . . . . %s\n", NiceNum(numBuf, largestBlockAllocated, 0)));
    DEBUG_PUT(("\tLargest Block Requested From. . . . . %s!%d\n", SourceFilename(LargestBlockRequestedFile), LargestBlockRequestedLine));
    DEBUG_PUT(("\tSmallest Block Requested. . . . . . . %s\n", NiceNum(numBuf, smallestBlockRequested, 0)));
    DEBUG_PUT(("\tSmallest Block Allocated. . . . . . . %s\n", NiceNum(numBuf, smallestBlockAllocated, 0)));
    DEBUG_PUT(("\tSmallest Block Requested From . . . . %s!%d\n", SourceFilename(SmallestBlockRequestedFile), SmallestBlockRequestedLine));
    DEBUG_PUT(("\n"
               "\tBlocks Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations - goodMemoryFrees, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated - totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\n"
               "********************************************************************************\n"
               "\n"));
}


PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    )
{
    DEBUG_PUT(("ReportMemoryBlocks\n\n"));

    DEBUG_PUT(("AllocatedBlockList:\n\n"));

    DumpMemoryList(&AllocatedBlockList);
    if (bDeferFree) {
        DumpDeferredFreeList();
    }
}


PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    )
{
    DEBUG_PUT(("DeferredFreeList:\n\n"));

    DumpMemoryList(&DeferredFreeList);
}


PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;
    int counter = 1;

    if (bUseSymbols) {

        //
        // have to load IMAGEHLP.DLL here because we're in DLL_PROCESS_DETACH
        // and if we loaded it earlier, there's a good chance the system has
        // already freed it
        //

        InitSymLib();
    }

    LockSerializedList(lpList);
    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(lpList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(lpList)) {

        DEBUG_PUT(("Block # %d\n", counter));


        if (!DumpBlock(lpHeader)) {
            break;
        }

        DEBUG_PUT(("********************************************************************************\n\n"));

        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
        ++counter;
    }
    UnlockSerializedList(lpList);
}


PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;

    LockSerializedList(&DeferredFreeList);

    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(&DeferredFreeList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(&DeferredFreeList)) {
        if (hLocal == (HLOCAL)lpHeader) {
            DumpBlock(lpHeader);
            break;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
    }

    UnlockSerializedList(&DeferredFreeList);
}


PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    BOOL ok = DumpDebugMemoryHeader(lpHeader);

    if (!ok && bStopDumpIfBadBlock) {

        DEBUG_PUT(("*** stopping block dump: header @ %#x is bad\n", lpHeader));

        return FALSE;
    }
    if (bReportUserData) {
        DumpUserData(lpHeader);
    }
    if (bReportMemoryFooters) {

        LPDEBUG_MEMORY_FOOTER lpFooter;

        lpFooter = (LPDEBUG_MEMORY_FOOTER)
                        ((LPBYTE)lpHeader
                        + sizeof(*lpHeader)
                        + ROUND_UP_DWORD(lpHeader->RequestedLength));
        ok = DumpDebugMemoryFooter(lpFooter);
        if (!ok && bStopDumpIfBadBlock) {

            DEBUG_PUT(("*** stopping block dump: footer @ %#x is bad\n", lpFooter));

            return FALSE;
        }
    }
    return TRUE;
}


PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    char numBuf[32];
    BOOL result;
    LPSTR symbol;
    DWORD offset;
    int i;
    char flagsBuf[256];

    __try {
        DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x:\n"
                   "\n",
                   lpHeader
                   ));
        DEBUG_PUT(("\tList. . . . . . . . . F=%#x B=%#x\n",
                   lpHeader->List.Flink,
                   lpHeader->List.Blink
                   ));
        DEBUG_PUT(("\tThread. . . . . . . . %#x\n",
                   lpHeader->ThreadId
                   ));
        DEBUG_PUT(("\tAllocated From. . . . %s!%d\n",
                   SourceFilename(lpHeader->CreatedFile),
                   lpHeader->CreatedLine
                   ));
        DEBUG_PUT(("\tLast Accessed From. . %s!%d\n",
                   SourceFilename(lpHeader->AccessedFile),
                   lpHeader->AccessedLine
                   ));
        DEBUG_PUT(("\tRequested Length. . . %s\n",
                   NiceNum(numBuf, lpHeader->RequestedLength, 0)
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpHeader->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tActual Length . . . . %s\n",
                   NiceNum(numBuf, lpHeader->ActualLength, 0)
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpHeader->Signature,
                   (lpHeader->Signature == HEADER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tFlags . . . . . . . . %08x %s\n",
                   lpHeader->Flags,
                   MapMemoryFlags(lpHeader->Flags, flagsBuf)
                   ));
        DEBUG_PUT(("\tTime Deferred . . . . %08x\n",
                   lpHeader->TimeDeferred
                   ));
        DEBUG_PUT(("\tClash Test. . . . . . %d\n",
                   lpHeader->ClashTest
                   ));
        DEBUG_PUT(("\tLast Operation. . . . %s\n",
                   MapLastAccessOperation(lpHeader->LastAccessOperation)
                   ));

#if DUMP_STACK
#if ONE_STACK

        if (lpHeader->Stack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tStack . . . . . . . . %08x %s+%#x\n",
                   lpHeader->Stack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->Stack); ++i) {
            //if (!lpHeader->lpHeader->Stack[i]) {
            //    break;
            //}
            if (lpHeader->Stack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->Stack[i],
                       symbol,
                       offset
                       ));
        }

#else

        if (lpHeader->LastAccessStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tLastAccessStack . . . %08x %s+%#x\n",
                   lpHeader->LastAccessStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->LastAccessStack); ++i) {
            //if (!lpHeader->LastAccessStack[i]) {
            //    break;
            //}
            if (lpHeader->LastAccessStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->LastAccessStack[i],
                       symbol,
                       offset
                       ));
        }
        if (lpHeader->CreateStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tCreateStack . . . . . %08x %s+%#x\n",
                   lpHeader->CreateStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->CreateStack); ++i) {
            //if (!lpHeader->lpHeader->CreateStack[i]) {
            //    break;
            //}
            if (lpHeader->CreateStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->CreateStack[i],
                       symbol,
                       offset
                       ));
        }

#endif // ONE_STACK
#endif // DUMP_STACK

        DEBUG_PUT(("\tGuard . . . . . . . . %08x\n"
                   "\n",
                   lpHeader->Guard[0]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x is BAD\n", lpHeader));

        result = FALSE;
    }
    return result;
}


PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    )
{
    char numBuf[32];
    BOOL result;

    _try {
        DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x:\n"
                   "\n",
                   lpFooter
                   ));
        DEBUG_PUT(("\tGuard . . . . . . . . %08x %08x %08x %08x\n",
                   lpFooter->Guard[0],
                   lpFooter->Guard[1],
                   lpFooter->Guard[2],
                   lpFooter->Guard[3]
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpFooter->Signature,
                   (lpFooter->Signature == FOOTER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpFooter->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tGuard2. . . . . . . . %08x %08x\n"
                   "\n",
                   lpFooter->Guard2[0],
                   lpFooter->Guard2[1]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x is BAD\n", lpFooter));

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    static char spaces[] = "                                              ";    // 15 * 3 + 2
    SIZE_T userSize = lpHeader->RequestedLength;
    SIZE_T Size = ROUND_UP_DWORD(userSize);
    LPBYTE Address = (LPBYTE)(lpHeader + 1);

    DEBUG_PUT(("\t%d (%#x) bytes of user data (rounded to %d (%#x)) @ %#x\n\n",
               userSize,
               userSize,
               Size,
               Size,
               Address
               ));

    if (bLimitUserData && (Size > MaxUserDataDumped)) {

        DEBUG_PUT(("*** User data length %d too large: limited to %d (probably bad block)\n",
                   Size,
                   MaxUserDataDumped
                   ));

        Size = MaxUserDataDumped;
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        char buf[128];
        int len;
        int clen;

        rsprintf(buf, "\t%08x  ", Address);

        clen = (int)min(Size, 16);
        if (bDumpAsDwords) {
            len = clen / 4;
        } else {
            len = clen;
        }

        //
        // dump the hex representation of each character - up to 16 per line
        //

        int i;

        for (i = 0; i < len; ++i) {
            if (bDumpAsDwords) {
                rsprintf(&buf[11 + i * 9], "%08x ", ((LPDWORD)Address)[i]);
            } else {
                rsprintf(&buf[11 + i * 3],
                         ((i & 15) == 7) ? "%02.2x-" : "%02.2x ",
                         Address[i] & 0xff
                         );
            }
        }

        //
        // write as many spaces as required to tab to ASCII field
        //

        int offset;

        if (bDumpAsDwords) {
            memcpy(&buf[11 + i * 9], spaces, (4 - len) * 9 + 2);
            offset = 49;
        } else {
            memcpy(&buf[11 + i * 3], spaces, (16 - len) * 3 + 2);
            offset = 60;
        }

        //
        // dump ASCII representation of each character
        //

        for (i = 0; i < clen; ++i) {

            char ch;

            ch = Address[i];
            buf[offset + i] = ((ch < 32) || (ch > 127)) ? '.' : ch;
        }

        buf[offset + i++] = '\r';
        buf[offset + i++] = '\n';
        buf[offset + i] = 0;

        //
        // InternetDebugOut() - no printf expansion (%s in data!), no prefixes
        //

        InternetDebugOut(buf, FALSE);

        Address += clen;
        Size -= clen;
    }

    InternetDebugOut("\r\n", FALSE);
}


PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    )
{
    switch (Action) {
    case MemAllocate:
        return "Alloc";

    case MemReallocate:
        return "Realloc";

    case MemLock:
        return "Lock";

    case MemUnlock:
        return "Unlock";

    case MemFree:
        return "Free";

    case MemSize:
        return "Size";
    }
    return "?";
}


PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    )
{
    LPSTR buf = Buffer;
    int i = 0;

    *buf++ = '(';
    if (Flags & LMEM_DISCARDABLE) {
        buf += wsprintf(buf, "DISCARDABLE");
        ++i;
    }
    if (Flags & LMEM_ZEROINIT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "ZEROINIT");
    }
    if (Flags & LMEM_NODISCARD) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NODISCARD");
    }
    if (Flags & LMEM_NOCOMPACT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NOCOMPACT");
    }
    if (i) {
        buf += wsprintf(buf, ", ");
    }
    ++i;
    buf += wsprintf(buf, (Flags & LMEM_MOVEABLE) ? "MOVEABLE" : "FIXED");
    *buf++ = ')';
    *buf++ = '\0';
    return Buffer;
}


PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    ) {
    //if (!bUseSymbols) {
    //    return "?";
    //}

    //
    // RLF 04/14/98 - IMAGEHLP blowing up probably because we are doing this at
    //                process detach time. Just return offset and run convsym
    //                utility on wininet.log
    //

    //return GetDebugSymbol(Address, Offset);
    *Offset = Address;
    return "";
}

#endif // defined(USE_DEBUG_MEMORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\vdhcpapi.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    vdhcpapi.h

Abstract:

    Worker functions for VDHCP APIs.

Author:

    Madan Appiah (madana)  28-May-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3

typedef struct _DHCP_NIC_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
    DWORD IpAddress;
    DWORD Lease;
    DWORD LeaseObtainedTime;
    DWORD LeaseExpiresTime;
    DWORD DhcpServerAddress;
    DWORD DNSServersLen;
    DWORD OffsetDNSServers;
    DWORD DomainNameLen;
    DWORD OffsetDomainName;
} DHCP_NIC_INFO, *LPDHCP_NIC_INFO;

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

typedef struct _DHCP_QUERYINFO {
    DWORD NumNICs;
    DHCP_NIC_INFO NicInfo[1];
} DHCP_QUERYINFO, *LPDHCP_QUERYINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\common\util.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains utility functions

    Contents:
        new
        delete
        NewString
        CatString
        ResizeBuffer
        _memrchr
        strnistr
        PrivateStrChr
        PlatformType
        PlatformSupport
        GetTimeoutValue
        ProbeReadBuffer
        ProbeWriteBuffer
        ProbeAndSetDword
        ProbeString
        LoadDllEntryPoints
        UnloadDllEntryPoints
        MapInternetError
        CalculateHashValue
        GetCurrentGmtTime
        GetFileExtensionFromUrl
        CheckExpired
        FTtoString
        PrintFileTimeInInternetFormat
        InternetSettingsChanged
        RefreshSslState
        CertHashToStr
        ConvertSecurityInfoIntoCertInfoStruct
        FormatCertInfo
        UnicodeToUtf8
        CountUnicodeToUtf8
        ConvertUnicodeToUtf8
        StringContainsHighAnsi
        IsAddressValidIPString
        IsInGUIModeSetup

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>

#if !defined(PAGE_SIZE)
#define PAGE_SIZE   4096
#endif
#define DEFAULT_MAX_EXTENSION_LENGTH    8

#pragma warning(disable: 4102)

//
// private prototypes
//



//
// functions
//
void * __cdecl operator new(size_t Size) {
    return (void *)ALLOCATE_FIXED_MEMORY((UINT)Size);
}

void __cdecl operator delete(void * Pointer) {
    FREE_MEMORY((HLOCAL)Pointer);
}

LPSTR
NewString(
    IN LPCSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : strlen(lpszIn));
    LPSTR lpszOut;

    if (lpszOut = (LPSTR)ALLOCATE_FIXED_MEMORY(len+1)) {
        memcpy(lpszOut, lpszIn, len);
        *(lpszOut + len) = '\0';
    }
    return lpszOut;
}

LPWSTR
NewStringW(
    IN LPCWSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : lstrlenW(lpszIn));
    LPWSTR lpszOut;

    if (lpszOut = (LPWSTR)ALLOCATE_FIXED_MEMORY((sizeof(WCHAR)*(len+1)))) {
        memcpy(lpszOut, lpszIn, len*sizeof(WCHAR));
        *(lpszOut + len) = L'\0';
    }
    return lpszOut;
}

/*++

Routine Description:

    kind of version of strcat() but using LocalAlloc to allocate memory

Arguments:

    strings to concatenate

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    )
{
    int cbLeft  = strlen(lpszLeft);
    int cbRight = strlen(lpszRight) + 1; // include null termination
    LPSTR lpszOut;

    if (lpszOut = (LPSTR) ALLOCATE_FIXED_MEMORY (cbLeft + cbRight)) {
        memcpy (lpszOut, lpszLeft, cbLeft);
        memcpy (lpszOut + cbLeft, lpszRight, cbRight);
    }
    return lpszOut;
}



HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    )

/*++

Routine Description:

    Allocate, reallocate or free a buffer. If the buffer is moveable memory
    then it must be unlocked. If reallocating, the buffer can be grown or
    shrunk, depending on the current and required sizes

    Caveat Programmer:

    Regardless of whether a pre-existing buffer is moveable or fixed memory,
    it will be reallocated with the LMEM_MOVEABLE flag, possibly causing the
    output pointer to be different from the pre-existing pointer

Arguments:

    BufferHandle    - current handle of memory buffer. If NULL, a buffer will
                      be allocated

    Size            - size of buffer to allocate (or shrink to). If 0, the
                      buffer will be freed

    Moveable        - if TRUE and allocating memory then allocates a moveable
                      memory buffer, else fixed

Return Value:

    HLOCAL
        Success - handle of moveable memory buffer

        Failure - NULL;

--*/

{
    INET_ASSERT(!Moveable);

    if (BufferHandle == NULL) {

        //
        // don't allocate anything if no size - LocalAlloc() will return pointer
        // to memory object marked as discarded if we request a zero-length
        // moveable buffer. But I know that if Size is also 0, I don't want a
        // buffer at all, discarded or otherwise
        //

        if (Size != 0) {
            BufferHandle = ALLOCATE_MEMORY(Moveable ? LMEM_MOVEABLE : LMEM_FIXED, Size);
        }
    } else if (Size == 0) {
        BufferHandle = FREE_MEMORY(BufferHandle);

        INET_ASSERT(BufferHandle == NULL);

    } else {
        HLOCAL hNewBuff = REALLOCATE_MEMORY(BufferHandle, Size, LMEM_MOVEABLE);
        if(!hNewBuff)
        {
            FREE_MEMORY(BufferHandle);
        }
        BufferHandle = hNewBuff;
    }
    return BufferHandle;
}


LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    )

/*++

Routine Description:

    Reverse find character in string

Arguments:

    lpString    - pointer to string in which to locate character

    cTarget     - target character to find

    iLength     - length of string

Return Value:

    LPSTR   - pointer to located character or NULL

--*/

{
    for (--iLength; (iLength >= 0) && (lpString[iLength] != cTarget); --iLength) {

        //
        // empty loop
        //

    }
    return (iLength < 0) ? NULL : &lpString[iLength];
}


LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    )

/*++

Routine Description:

    Case-insensitive search for substring

Arguments:

    str1    - string to search in

    str2    - substring to find

    Length  - of str1

Return Value:

    LPSTR   - pointer to located str2 in str1 or NULL

--*/

{
    if (!*str2) {
        return str1;
    }

    for (LPSTR cp = str1; *cp && Length; ++cp, --Length) {

        LPSTR s1 = cp;
        LPSTR s2 = str2;
        DWORD l2 = Length;

        while (*s1 && *s2 && l2 && (toupper(*s1) == toupper(*s2))) {
            ++s1;
            ++s2;
            --l2;
        }

        if (!*s2) {
            return cp;
        }

        if (!l2) {
            break;
        }
    }

    return NULL;
}

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    )
/*++

Routine Description:

    Find first occurrence of character in string

    Private implimentation of StrChrA, this code is based on
     a code snipet from ShlWapi, but by placing it here,
     we can remove the extra NLS support that was needed
     in SHLWAPI.   This piece of code is over twice as fast
     as the call into SHLWAPI.

Arguments:

    lpStart - points to start of null terminated string

    wMatch  - the character to match

Return Value:

    LPSTR   - ptr to the first occurrence of ch in str, NULL if not found.

--*/
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }

    return (NULL);
}


DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os
    )

/*++

Routine Description:

    Returns the platform type based on the operating system information. We use
    our own platform types

Arguments:

    lpdwVersion5os - optional pointer to value, set to TRUE if we on NT 5

Return Value:

    DWORD
        Failure - PLATFORM_TYPE_UNKNOWN
                    either GetVersionEx() failed, or we are running on an
                    unrecognized operating system

        Success - PLATFORM_TYPE_WIN95
                    The world's favourite desktop O/S

                  PLATFORM_TYPE_WINNT
                    The world's best O/S on top of anything

--*/

{
#ifndef UNIX
    OSVERSIONINFO versionInfo;

    *lpdwVersion5os = FALSE;

    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo)) {
        switch (versionInfo.dwPlatformId) {
        case VER_PLATFORM_WIN32_WINDOWS:
            if(versionInfo.dwMinorVersion >= 90) {
                GlobalPlatformMillennium = TRUE;
            }
            return PLATFORM_TYPE_WIN95;

        case VER_PLATFORM_WIN32_NT:

            if ( lpdwVersion5os && 
                versionInfo.dwMajorVersion >= 5 ) {                
                *lpdwVersion5os = TRUE;

                if (versionInfo.dwMinorVersion >= 1) {
                    GlobalPlatformWhistler = TRUE;
                }
            }
            return PLATFORM_TYPE_WINNT;

        }

    }
    return PLATFORM_TYPE_UNKNOWN;
#else
    return PLATFORM_TYPE_UNIX;
#endif /* UNIX */
}

//
//DWORD
//PlatformSupport(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Returns a bitmap of capabilities supported by this operating system
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    switch (PlatformType()) {
//    case PLATFORM_TYPE_WINNT:
//        return PLATFORM_SUPPORTS_UNICODE;
//    }
//    return 0;
//}


DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    )

/*++

Routine Description:

    Gets a timeout value. The timeout is retrieved from the current handle. If
    it is not available in the current handle then the parent handle is checked
    (actually the current handle is derived from the parent, so this doesn't
    really do anything). If the value is still not available, then the global
    default is used

Arguments:

    TimeoutOption   - INTERNET_OPTION_ value used to specify the timeout value

Return Value:

    DWORD
        Requested timeout value

--*/

{
    HINTERNET hInternet;
    DWORD timeout;
    DWORD error;

    hInternet = InternetGetMappedObjectHandle();
    if (hInternet != NULL) {
        error = RGetTimeout(hInternet, TimeoutOption, &timeout);
    }
    if ((hInternet == NULL) || (error != ERROR_SUCCESS)) {
        switch (TimeoutOption) {
        case INTERNET_OPTION_SEND_TIMEOUT:
            timeout = GlobalSendTimeout;
            break;

        case INTERNET_OPTION_RECEIVE_TIMEOUT:
            timeout = GlobalReceiveTimeout;
            break;

        case INTERNET_OPTION_DATA_SEND_TIMEOUT:
            timeout = GlobalDataSendTimeout;
            break;

        case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
            timeout = GlobalDataReceiveTimeout;
            break;

        case INTERNET_OPTION_CONNECT_TIMEOUT:
            timeout = GlobalConnectTimeout;
            break;

        case INTERNET_OPTION_CONNECT_RETRIES:
            timeout = GlobalConnectRetries;
            break;

        case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
            timeout = GlobalFromCacheTimeout;
            break;
        }
    }
    return timeout;
}


DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for readability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_INVALID_PARAMETER;
    }

    return error;
}


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}


DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    )

/*++

Routine Description:

    Probes a single DWORD buffer for writeability, and as a side-effect sets it
    to a default value. Used as part of API parameter validation

Arguments:

    lpDword - pointer to DWORD buffer to test

    dwValue - default value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    __try {
        *lpDword = dwValue;
        error = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    return error;
}


DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Dynamically loads a DLL and the entry points described in lpDllEntryPoints

    Assumes:    1. Any thread serialization taken care of by caller

                2. Module handle, entry point addresses and reference count
                   already set to 0 if this is first time the DLL_INFO is
                   being used to load the DLL

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and entry points to load

    dwFlags     - flags controlling how this function operates:

                    LDEP_PARTIAL_LOAD_OK
                        - not fatal if we can't load all entry points

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "LoadDllEntryPoints",
                 "%x [%q, %d], %#x",
                 lpDllInfo,
                 lpDllInfo->lpszDllName,
                 lpDllInfo->dwNumberOfEntryPoints,
                 dwFlags
                 ));

    DWORD error = ERROR_SUCCESS;

    if (lpDllInfo->hModule == NULL) {

        DWORD dwMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HMODULE hDll = LoadLibrary(lpDllInfo->lpszDllName);

        if (hDll != NULL) {
            lpDllInfo->hModule = hDll;
            lpDllInfo->LoadCount = 1;

            for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {

                FARPROC proc = GetProcAddress(
                                    hDll,
                                    lpDllInfo->lpEntryPoints[i].lpszProcedureName
                                    );

                *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = proc;
                if ((proc == NULL) && !(dwFlags & LDEP_PARTIAL_LOAD_OK)) {
                    error = GetLastError();
                    UnloadDllEntryPoints(lpDllInfo, TRUE);
                    break;
                }
            }
        } else {
            error = GetLastError();
        }
        SetErrorMode(dwMode);
    } else {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("info for %q already loaded\n",
                    lpDllInfo->lpszDllName
                    ));

        InterlockedIncrement(&lpDllInfo->LoadCount);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    )

/*++

Routine Description:

    Undoes the work of LoadDllEntryPoints()

    Assumes:    1. Any thread serialization taken care of by caller

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and (loaded) entry points

    bForce      - TRUE if the DLL will be unloaded irrespective of the usage
                  count

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "UnloadDllEntryPoints",
                "%x [%q, %d], %B",
                lpDllInfo,
                lpDllInfo->lpszDllName,
                lpDllInfo->dwNumberOfEntryPoints,
                bForce
                ));

    DWORD error = ERROR_SUCCESS;

    if (bForce) {
        lpDllInfo->LoadCount = 0;
    } else if (InterlockedDecrement(&lpDllInfo->LoadCount) == 0) {
        bForce = TRUE;
    }
    if (bForce && (lpDllInfo->hModule != NULL)) {
        if (!FreeLibrary(lpDllInfo->hModule)) {
            error = GetLastError();
        }

        //
        // even if FreeLibrary() failed we clear out the load info
        //

        lpDllInfo->hModule = NULL;
        for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {
            *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = NULL;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE              _HRESULT_TYPEDEF_(0x800B0110)
#endif


DWORD
MapInternetError(
    IN DWORD dwErrorCode
    )

/*++

Routine Description:

    Maps a winsock/RPC/transport error into a more user-friendly WinInet error,
    and stores the original error in the per-thread context so that the app can
    retrieve it if it really cares

    N.B. We should no longer be receiving winsock errors directly at the WinInet
    interface. They are available via InternetGetLastResponseInfo()

Arguments:

    dwErrorCode - original (winsock) error code to map

Return Value:

    DWORD
        Mapped error code, or the orignal error if its not one that we handle

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "MapInternetError",
                "%#x [%s]",
                dwErrorCode,
                InternetMapError(dwErrorCode)
                ));

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo) {
        lpThreadInfo->dwMappedErrorCode = dwErrorCode;
    }

    switch (dwErrorCode) {

    case SEC_E_INSUFFICIENT_MEMORY        :
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case SEC_E_INVALID_HANDLE             :
    case SEC_E_UNSUPPORTED_FUNCTION       :
    case SEC_E_TARGET_UNKNOWN             :
    case SEC_E_INTERNAL_ERROR             :
    case SEC_E_SECPKG_NOT_FOUND           :
    case SEC_E_NOT_OWNER                  :
    case SEC_E_CANNOT_INSTALL             :
    case SEC_E_INVALID_TOKEN              :
    case SEC_E_CANNOT_PACK                :
    case SEC_E_QOP_NOT_SUPPORTED          :
    case SEC_E_NO_IMPERSONATION           :
    case SEC_E_LOGON_DENIED               :
    case SEC_E_UNKNOWN_CREDENTIALS        :
    case SEC_E_NO_CREDENTIALS             :
    case SEC_E_MESSAGE_ALTERED            :
    case SEC_E_OUT_OF_SEQUENCE            :
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
    case SEC_I_CONTINUE_NEEDED            :
    case SEC_I_COMPLETE_NEEDED            :
    case SEC_I_COMPLETE_AND_CONTINUE      :
    case SEC_I_LOCAL_LOGON                :
    case SEC_E_BAD_PKGID                  :
    case SEC_E_CONTEXT_EXPIRED            :
    case SEC_E_INCOMPLETE_MESSAGE         :
        dwErrorCode = ERROR_INTERNET_SECURITY_CHANNEL_ERROR;
        break;

    // Cert and Encryption errors

    case CERT_E_EXPIRED:
    case CERT_E_VALIDITYPERIODNESTING:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_DATE_INVALID;
        break;

    case CERT_E_UNTRUSTEDROOT:
        dwErrorCode = ERROR_INTERNET_INVALID_CA;
        break;

    case CERT_E_CN_NO_MATCH:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_CN_INVALID;
        break;

    case CRYPT_E_REVOKED:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_REVOKED;
        break;

    // ignore revocation if the certificate does not have a CDP
    case CRYPT_E_NO_REVOCATION_CHECK:
        dwErrorCode = ERROR_SUCCESS;
        break;

    case CRYPT_E_REVOCATION_OFFLINE:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_REV_FAILED;
        break;

    case CERT_E_ROLE:
    case CERT_E_PATHLENCONST:
    case CERT_E_CRITICAL:
    case CERT_E_PURPOSE:
    case CERT_E_ISSUERCHAINING:
    case CERT_E_MALFORMED:
    case CERT_E_CHAINING:
    // We can't allow connection if server doesn't have a server auth certificate.
    // To force CERT_E_WRONG_USAGE to error out we map it to the error below.
    // In the future we need to map it to it's own non-recoverable error, so we can 
    // give the user a specific error message.
    case CERT_E_WRONG_USAGE:
        dwErrorCode = ERROR_INTERNET_SEC_INVALID_CERT;
        break;

    case WSAEINTR:
    case WSAEBADF:
    case WSAEACCES:
    case WSAEFAULT:
    case WSAEINVAL:
    case WSAEMFILE:
    case WSAEADDRINUSE:
    case WSAEADDRNOTAVAIL:
        dwErrorCode = ERROR_INTERNET_INTERNAL_ERROR;
        break;

    case WSAENOTSOCK:

        //
        // typically, if we see this error its because we tried to use a closed
        // socket handle
        //
        dwErrorCode = ERROR_INTERNET_OPERATION_CANCELLED;
        break;

    case WSAEWOULDBLOCK:
    case WSAEINPROGRESS:
    case WSAEALREADY:
    case WSAEDESTADDRREQ:
    case WSAEPROTOTYPE:
    case WSAENOPROTOOPT:
    case WSAEPROTONOSUPPORT:
    case WSAESOCKTNOSUPPORT:
    case WSAEOPNOTSUPP:
    case WSAEISCONN:
    case WSAETOOMANYREFS:
    case WSAELOOP:
    case WSAENAMETOOLONG:
    case WSAENOTEMPTY:
    case WSAEPROCLIM:
    case WSAEUSERS:
    case WSAEDQUOT:
    case WSAESTALE:
    case WSAEREMOTE:
    case WSAEDISCON:
    case WSASYSNOTREADY:
    case WSAVERNOTSUPPORTED:
    case WSANOTINITIALISED:

        //
        // currently unmapped errors
        //

        break;

    case WSAEMSGSIZE:
        dwErrorCode = ERROR_INSUFFICIENT_BUFFER;
        break;

    case WSAEPFNOSUPPORT:
    case WSAEAFNOSUPPORT:
        dwErrorCode = ERROR_INTERNET_TCPIP_NOT_INSTALLED;
        break;

    case WSAECONNABORTED:
    case WSAESHUTDOWN:
        dwErrorCode = ERROR_INTERNET_CONNECTION_ABORTED;
        break;

    case WSAECONNRESET:
    case WSAENETRESET:
        dwErrorCode = ERROR_INTERNET_CONNECTION_RESET;
        break;

    case WSAENOBUFS:
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case WSAETIMEDOUT:
        dwErrorCode = ERROR_INTERNET_TIMEOUT;
        break;

    case WSAENETDOWN:
    case WSAECONNREFUSED:
    case WSAENETUNREACH:
    case WSAENOTCONN:
        dwErrorCode = ERROR_INTERNET_CANNOT_CONNECT;
        break;

    case WSAEHOSTDOWN:
    case WSAEHOSTUNREACH:
    case WSAHOST_NOT_FOUND:
    case WSATRY_AGAIN:
    case WSANO_RECOVERY:
    case WSANO_DATA:
        dwErrorCode = ERROR_INTERNET_NAME_NOT_RESOLVED;
        break;

    default:

        DEBUG_PRINT(UTIL,
                    WARNING,
                    ("MapInternetError(): unmapped error code %d [%#x]\n",
                    dwErrorCode,
                    dwErrorCode
                    ));

        break;
    }

    DEBUG_LEAVE(dwErrorCode);

    return dwErrorCode;
}


DWORD
CalculateHashValue(
    IN LPSTR lpszString
    )

/*++

Routine Description:

    Calculate a hash number given a string

Arguments:

    lpszString  - string to hash

Return Value:

    DWORD

--*/

{
    DWORD hashValue = 0;
    DWORD position = 1;

    while (*lpszString) {
        hashValue += *lpszString * position;
        ++lpszString;
        ++position;
    }
    return hashValue;
}



VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    )
/*++

Routine Description:
    This routine returns the current GMT time

Arguments:

    lpFt    FILETIME strucutre in which this is returned

Returns:

Comments:

--*/
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}

///***    DwRemoveDots    - Remove any dots from a path name
//**
//**  Synopsis
//**      DWORD DwRemoveDots (pchPath)
//**      Lifted from win95 kernel.
//**
//**  Input:
//**      pchPath         - A path string
//**
//**
//**  Output:
//**      returns the number of double dot levels removed from front
//**
//**  Errors:
//**      returns dwInvalid if invalid path
//**
//**  Description:
//**      Removes ..\ and .\ sequences from a path string. The path
//**      string should not include the root drive or net name portion.
//**      The return value of is the number of levels removed from the
//**      start of the string. Levels removed from inside the string
//**      will not be returned. For example:
//**
//**          String          Result              Return
//**
//**          ..\..\dir1      dir1                2
//**          dir1\..\dir2    dir2                0
//**          dir1\..\..\dir2 dir2                1
//**          .\dir1          dir1                0
//**          dir1\.\dir2     dir1\dir2           0
//**
//**      A backslash at the start of the string will be ignored.
//*/
//
//// File and path definitions
//
//#define     chExtSep    '.'
//#define     szExtSep    "."
//#define     chNetIni    '\\'
//#define     chDirSep    '\\'
//#define     szDirSep    "\\"
//#define     chDirSep2   '/'
//#define     chDrvSep    ':'
//#define     chRelDir    '.'
//#define     chEnvSep    ';'
//#define     chWldChr    '?'
//#define     chWldSeq    '*'
//#define     chMinDrv    'A'
//#define     chMaxDrv    'Z'
//#define     chMinDrvLow 'a'
//#define     chMaxDrvLow 'z'
//
//DWORD
//DwRemoveDots (
//    char * pchPath
///*++
//
//Routine Description:
//    Removes ./ ../ etc from a path to normalize it
//
//Arguments:
//
//    pchPath path string
//
//Returns:
//
//    Count of levels dealt with
//
//Comments:
//
//    Lifted from win95 kernel
//
//--*/
//)
//    {
//    BOOL            fInside = FALSE;
//    DWORD           cLevel = 0;
//    DWORD           cBackup;
//    register char * pchR;
//    register char * pchL;
//
//#ifdef MAYBE
//    // Check for invalid characters
//    if (!FFixPathChars(pchPath)) {
//        // No code required.
//        return dwInvalid;
//    }
//
//#endif //MAYBE
//    // Skip slashes
//    for (; *pchPath == chDirSep2; pchPath++)
//        ;
//    pchL = pchR = pchPath;
//
//    // Loop through handling each directory part
//    while (*pchR) {
//        // This part starts with dot. Is it one or more?
//        if (*pchR++ == chRelDir) {
//            for (cBackup = 0; *pchR == chRelDir; cBackup++, pchR++)
//                ;
//            if (cBackup) {
//                // More than one dot. Back up the left pointer.
//                if ((*pchR != chDirSep2) && (*pchR != '\0')) {
//                    // we got a [.]+X (X != '\') might be an LFN
//                    // process this as a name
//                    goto name_processing;
//                }
//                // Doesn't advance for ending ..
//                for (; *pchR == chDirSep2; pchR++)
//                    ;
//                if (fInside) {
//                    for (; cBackup; cBackup--) {
//                        if (pchL <= pchPath) {
//                            cLevel += cBackup;
//                            fInside = FALSE;
//                            break;
//                        }
//                        // Remove the previous part
//                        for (pchL -= 2; *pchL != chDirSep2; pchL--) {
//                            if (pchL <= pchPath) {
//                                fInside = FALSE;
//                                pchL--;
//                                break;
//                            }
//                        }
//                        pchL++;
//                    }
//                } else {
//                    cLevel += cBackup;
//                }
//                // Subtract ending backslash if not root
//                if ((*pchR == '\0') && (pchL != pchPath))
//                    pchL--;
//                strcpy(pchL, pchR);
//                pchR = pchL;
//            } else {
//                // This part starts with one dot. Throw it away.
//                if (*pchR != chDirSep2) {
//                    // Special case "\." by converting it to ""
//                    // unless it is a root, when it becomes "\".
//                    if (*pchR == '\0') {
//                        if (pchL == pchPath)
//                            *(pchR-1) = '\0';   // root
//                        else
//                            *(pchR-2) = '\0';   // not root
//                        return cLevel;
//                    }
//                    // we started with a '.' and then there was no '\'
//                    // might be an LFN name
//                    goto name_processing;
//                }
//                pchR++;
//                strcpy(pchL, pchR);
//                pchR = pchL;
//            }
//        } else {
//name_processing:
//            // This part is a name. Skip it.
//            fInside = TRUE;
//            for (; TRUE; pchR++) {
//                if (*pchR == chDirSep2) {
//                    if (*(pchR-1) == chRelDir) {
//                        // This name has one or more dots at the end.
//                        // Remove the last dot (NT3.5 does this).
//                        pchL = pchR-1;
//                        strcpy(pchL, pchR);
//                        pchR = pchL;    // point to chDirSep2 again
//                    }
//                    for (; *pchR == chDirSep2; pchR++)
//                        ;
//                    break;
//                } else if (*pchR == '\0') {
//                    // Remove trailing dots.
//                    // NB Can't fall off the beginning since the first char
//                    // of the current path element was not chRelDir.
//                    for (; *(pchR-1) == chRelDir; pchR--)
//                        ;
//                    // Overstore the first trailing dot, if there is one.
//                    *pchR = '\0';
//                    break;
//                }
//            }
//            pchL = pchR;
//        }
//    }
//    return cLevel;
//}


//#define OLD

#define EXE_EXTENSION   TEXT(".exe")
#define DLL_EXTENSION   TEXT(".dll")
#define CGI_EXTENSION   TEXT(".cgi")

LPSTR GetFileExtensionFromUrl(
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwLength)
/*++

Routine Description:
    This routine returns a possible file extension from a URL
    It does this by walking back from the end till the first  dot.

Arguments:

    lpszUrl         Url to derive the extension from

    lpdwLength      max length of the extension expected

Returns:

    NULL if no dot within the passed in length or a forward slash or a
    backward slash encountered before the dot. Otherwise returns a pointer
    pointing past the dot in the url string

Comments:



--*/
{
    INET_ASSERT(lpszUrl && lpdwLength);

#ifdef OLD
    if (lpszUrl != NULL) {

        LPSTR p;
        DWORD len=0 , lenLimit= *lpdwLength;

        p = lpszUrl + (strlen(lpszUrl) - 1);

        while ((*p != '.') && (p != lpszUrl)) {

            // if this contains a character that the filesystems
            // don't like, then return NULL
            if (strchr(vszInvalidFilenameChars, *p)) {
                return(NULL);
            }

            if ((*p == '/') || (*p == '\\')) {
                break;
            }
            --p;
            ++len;
        }
        if ((*p == '.')
        && (len != 0)
        && (len < lenLimit)) {
            *lpdwLength = len;
            return p + 1;
        }
    }
    return NULL;
#else
    if (!lpszUrl)
    {
        *lpdwLength = 0;
        return NULL;
    }

    LPSTR pszPeriod = NULL;
    BOOL fContinue = TRUE;

    // Scanning from left to right, note where we last saw a period.
    // If we see a character that cannot be in an extension, and we've seen a period, forget
    // about the period.
    // Repeat this until we've reached the end of the url, a question mark (query) or hash (fragment)

    // 1.6.98: _However_, if the file extension we've discovered is either .dll or .exe, 
    //         we'll continue to scan beyond the query mark for a file extension.

    // 1.20.98: And if we find no extension before the question mark, we'll look after it, then.
    
    while (fContinue)
    {
        switch (*lpszUrl)
        {
        case TEXT('.'):
            pszPeriod = lpszUrl;
            break;

        case TEXT('?'):
            if (pszPeriod)
            {
                if ((!StrCmpNI(pszPeriod, EXE_EXTENSION, ARRAY_ELEMENTS(EXE_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, DLL_EXTENSION, ARRAY_ELEMENTS(DLL_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, CGI_EXTENSION, ARRAY_ELEMENTS(CGI_EXTENSION)-1)))
                {
                    pszPeriod = NULL;
                    break;
                }
            }
            else
            {
                break;
            }
            
        case TEXT('#'):
        case TEXT('\0'):
            fContinue = FALSE;
            break;

        default:
            if (pszPeriod && strchr(vszInvalidFilenameChars, *lpszUrl))
            {
                pszPeriod = NULL;
            }        
        }
        lpszUrl++;
    }
    // This will be off by one
    lpszUrl--;
    if (pszPeriod)
    {
        if (*lpdwLength < (DWORD)(lpszUrl-pszPeriod))
        {
            pszPeriod = NULL;
        }
        else
        {
            pszPeriod++;
            *lpdwLength = (DWORD)(lpszUrl-pszPeriod);
        }
    }
    return pszPeriod;
#endif
}


DWORD
CheckExpired(
    HINTERNET           hRequestMapped,
    BOOL*               lpfIsExpired,
    CACHE_ENTRY_INFO*   pInfo,
    LONGLONG            DefaultExpiryDelta
    )
/*++

Routine Description:
    This routine checks whether a cache entry has expired for ftp/gopher.
    It uses the globally set synchronization modes to make that decision

Arguments:

    hRequestMapped      a mapped request handle

    lpfIsExpired        returns TRUE if expired, FALSE otherwise

    lpCacheEntryInfo    cache entry info containing all the timestamps

    DefaultExpiryDelta  time delta to use for default expiry calculation

Returns:

    Windows error code

Comments:

--*/
{
    switch (GlobalUrlCacheSyncMode)
    {
        case WININET_SYNC_MODE_NEVER:
            // Never check, unless the page has expired
            *lpfIsExpired = FALSE;
            break;

        case WININET_SYNC_MODE_ALWAYS:
            *lpfIsExpired = TRUE;
            break;

        default:
            if (FT2LL (pInfo->LastSyncTime) < dwdwSessionStartTime)
                *lpfIsExpired = TRUE;
            else
            {
                FILETIME ftCurrent;
                GetCurrentGmtTime (&ftCurrent);
                *lpfIsExpired = (FT2LL(ftCurrent) - FT2LL (pInfo->LastSyncTime)
                    > DefaultExpiryDelta);
            }
            break;
    }

    return ERROR_SUCCESS;
}



LPTSTR
FTtoString(
    IN FILETIME *pftTime)

/*++

FTtoString:

    This routine converts a given FILETIME structure to a string representing
    the given date and time in the local format.

Arguments:

    pftTime supplies the FILETIME structure to convert.

Return Value:

    NULL - Memory allocation failure.
    Otherwise, the address of the string, allocated via LocalAlloc.

Author:

    Doug Barlow (dbarlow) 4/12/1996

--*/

{
    LONG cchTotal, cchNeeded;
    SYSTEMTIME stTime, stLocal;
    LPTSTR szDateTime = NULL;


    //
    // Convert the FILETIME to a SYSTEMTIME.
    //

    if (!FileTimeToSystemTime(pftTime, &stTime))
        goto ErrorExit;

    //
    // For now, leave it in GMT time, function not implimented in Win'95.
    //

    //if ( IsPlatformWinNT() )
    //{
    //    if (!SystemTimeToTzSpecificLocalTime(NULL, &stTime, &stLocal))
    //        goto ErrorExit;
    //}
    //else
    {
        stLocal = stTime;
    }


    //
    // Calculate how long the date string will be.
    //

    cchTotal =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchTotal)
        goto ErrorExit;
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchNeeded)
        goto ErrorExit;
    cchTotal += cchNeeded;
    cchTotal += 4 * sizeof(TCHAR);  // space, trailing NULL, and two extra.
    szDateTime = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, cchTotal);
    if (NULL == szDateTime)
        goto ErrorExit;


    //
    // Fill in the time string.
    //

    cchNeeded =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            szDateTime,
            cchTotal);
    if (0 >= cchNeeded)
        goto ErrorExit;
    lstrcat(szDateTime, TEXT(" "));
    cchNeeded = lstrlen(szDateTime);
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            &szDateTime[cchNeeded],
            cchTotal - cchNeeded);
    if (0 >= cchNeeded)
        goto ErrorExit;
    return szDateTime;


ErrorExit:
    if (NULL != szDateTime)
        FREE_MEMORY(szDateTime);
    return NULL;
}


BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
)
{
    SYSTEMTIME sSysTime;

    if (dwSize < INTERNET_RFC1123_BUFSIZE) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }
    if (!FileTimeToSystemTime(((CONST FILETIME *)lpft), &sSysTime)) {
        return (FALSE);
    }
    return (InternetTimeFromSystemTime( &sSysTime,
                                        INTERNET_RFC1123_FORMAT,
                                        lpszBuff,
                                        dwSize));

}


BOOL
InternetSettingsChanged(
    VOID
    )

/*++

Routine Description:

    Determines if the global settings have been changed (inter-process)

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Bool,
                 "InternetSettingsChanged",
                 NULL
                 ));

    DWORD dwVer;
    BOOL bChanged = FALSE;

    if (GetCurrentSettingsVersion(&dwVer)) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("current settings version = %d\n",
                    dwVer
                    ));

        if (!GlobalSettingsLoaded || (dwVer != GlobalSettingsVersion)) {
            GlobalSettingsLoaded = TRUE;
            GlobalSettingsVersion = dwVer;
            bChanged = TRUE;
        }
    }

    DEBUG_LEAVE(bChanged);

    return bChanged;
}


BOOL
RefreshSslState(
    VOID
    )
/*++

Routine Description:

    Starting with Whistler, client auth certificates are cached
    for the logon session (not per process).  Inetcpl now contains
    a button that will clear on-demand the SSL state for the session.
    If user cleared the SSL cache, then flush all cached
    client auth certificates in the global cert cache for this process.

    NOTE:  This function leverages a cache header data value.
           Clearing the state affects all processes, and
           using one of these (which was never put into practice)
           prevents the need for another shared registry value.

Arguments:

    None.

Return Value:

    BOOL   If the client auth cert cache was cleared, this function will
           return TRUE.  Otherwise, this will return FALSE.

--*/
{
    DWORD dwCount = 0;
    BOOL bCleared = FALSE;

    DEBUG_ENTER((DBG_UTIL,
                 Bool,
                 "RefreshSslState",
                 NULL
                 ));
    
    if (GlobalPlatformWhistler &&
        GetUrlCacheHeaderData(CACHE_HEADER_DATA_DOWNLOAD_PARTIAL, &dwCount) &&
        dwCount != GlobalSslStateCount)
    {
        GlobalSslStateCount = dwCount;
        PurgeKeepAlives(PKA_NOW);
        GlobalCertCache.ClearClientAuthCertChains();
        bCleared = TRUE;
    }

    DEBUG_LEAVE(bCleared);

    return bCleared;
}


BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    )
/*++

Routine Description:

    Converts a set of bytes into a neatly formated string of ':' (colon) seperated
      hex digits that can be shown to the user.

Arguments:

    lpMD5Hash - ptr to set of hash bytes

    dwMD5HashSize - size of lpMD5Hash

    lplpszHashStr - ptr to ptr where newly allocated return string will be stored.

Return Value:

    BOOL

--*/

{

    DWORD dwStrSize = (2*dwMD5HashSize) + dwMD5HashSize;
    LPSTR lpszHashStr;

    *lplpszHashStr = new CHAR[dwStrSize];

    if ( *lplpszHashStr == NULL )
    {
        return FALSE;
    }

    lpszHashStr = *lplpszHashStr;

    for ( DWORD i = 0 ; i < dwMD5HashSize; i++ )
    {
        unsigned char uHashByte;

        if ( i != 0 )
        {
            *lpszHashStr = ':';
            lpszHashStr++;
        }

        uHashByte = (unsigned char) * ( ((unsigned char * ) lpMD5Hash) + i);

        wsprintf( lpszHashStr, "%02X", uHashByte);

        lpszHashStr += 2;

    }

    INET_ASSERT( *lpszHashStr == '\0' );

    return TRUE;
}


//
// private functions
//

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    )
/*++

Routine Description:

    Converts an X509 Certificate Structure into a WININET struct
    used for storing the same info.

Arguments:

    hContext        - Context handle of the active SSPI session.

    pCertInfo       - Pointer to Structure where info is returned in.

Return Value:

    DWORD
    ERROR_SUCCESS   - if cert cannot be converted

    ERROR_NOT_ENOUGH_MEMORY

--*/

{


    DWORD   error = ERROR_SUCCESS;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbCert = sizeof(INTERNET_CERTIFICATE_INFO),
          cbSubject = 0,
          cbIssuer = 0;

    BOOL fCanAlloc = FALSE;

    if(pSecInfo == NULL)
    {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    if(pCertificate == NULL || *pcbCertificate == 0)
    {
        *pcbCertificate = sizeof(INTERNET_CERTIFICATE_INFO);
        goto quit;
    }

    if(*pcbCertificate < sizeof(INTERNET_CERTIFICATE_INFO) )
    {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    ZeroMemory(pCertificate, sizeof(INTERNET_CERTIFICATE_INFO));
    fCanAlloc = TRUE;

    if(pSecInfo->pCertificate &&
       pSecInfo->pCertificate->pCertInfo )
    {
        pCertInfo = pSecInfo->pCertificate->pCertInfo;

        //
        // Now Convert Structures from SSPI format to WININET style.
        //  While in the process, we'll role them all into one
        //  big structure that we'll return to the user.
        //

        cbSubject = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);


        if ( cbSubject > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszSubjectInfo = (LPSTR) LocalAlloc(LPTR, cbSubject);

            if ( pCertificate->lpszSubjectInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszSubjectInfo,
                                     cbSubject);

        }

        cbIssuer = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        if ( cbIssuer > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszIssuerInfo = (LPSTR) LocalAlloc(LPTR, cbIssuer);

            if ( pCertificate->lpszIssuerInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszIssuerInfo,
                                     cbIssuer);

        }

        CopyMemory(
                (PVOID) &pCertificate->ftStart,
                (PVOID) &pCertInfo->NotBefore,
                sizeof(FILETIME)
                );

        CopyMemory(
                (PVOID) &pCertificate->ftExpiry,
                (PVOID) &pCertInfo->NotAfter,
                sizeof(FILETIME)
                );

    }

    /*if(pSecInfo->dwProtocol)
    {
        DWORD dwProtocolID;
        TCHAR lpszProtocol[100];

        ATTR_MAP ProtocolAttrMap[] =
        {
            {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
            {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
            {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
            {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
        };


        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadString(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {
            pCertificate->lpszProtocolName  = NewString(lpszProtocol);
        }
    } */

    pCertificate->dwKeySize = pSecInfo->dwCipherStrength;

quit:

    if ( error != ERROR_SUCCESS &&
         fCanAlloc
        )
    {

        if ( pCertificate->lpszSubjectInfo )
        {
            LocalFree(pCertificate->lpszSubjectInfo);
            pCertificate->lpszSubjectInfo = NULL;
        }

        if ( pCertificate->lpszIssuerInfo )
        {
            LocalFree(pCertificate->lpszIssuerInfo);
            pCertificate->lpszIssuerInfo = NULL;
        }
    }

    return error;
}

/*++

FormatCertInfo:

    This routine formats the information within a INTERNET_CERTIFICATE_INFO
    structure suitable for display with localization.

Arguments:

    pCertInfo supplies a pointer to the INTERNET_CERTIFICATE_INFO structure to
    be formatted.

Return Value:

    NULL - An error occurred.  Otherwise, a pointer to the formatted string.
        This string must be freed by the caller via LocalFree.

Author:

    Doug Barlow (dbarlow) 4/30/1996

--*/

LPTSTR
FormatCertInfo(
    IN INTERNET_CERTIFICATE_INFO *pCertInfo
    )
{
    LPVOID rgpvParams[9];   // Number of insertable elements in the
                            // plszStrings->szCertInfo resource
                            // string.
    LPTSTR szResult = NULL;
    int i = 0;
    PLOCAL_STRINGSA plszStrings;
    LPTSTR szFrom = NULL;
    LPTSTR szUntil = NULL;


    //
    // Get the Certificate Information.
    //

    plszStrings = FetchLocalStringsA();
    szFrom = FTtoString(&pCertInfo->ftStart);
    szUntil = FTtoString(&pCertInfo->ftExpiry);
    if ((NULL == szUntil) || (NULL == szFrom))
        goto ErrorExit;

    //ChangeCommaSpaceToCRLF(pCertInfo->lpszSubjectInfo);
    //ChangeCommaSpaceToCRLF(pCertInfo->lpszIssuerInfo);

    rgpvParams[i++] = (LPVOID)pCertInfo->lpszSubjectInfo;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszIssuerInfo;
    rgpvParams[i++] = (LPVOID)szFrom;
    rgpvParams[i++] = (LPVOID)szUntil;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszProtocolName;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszSignatureAlgName;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszEncryptionAlgName;
    rgpvParams[i++] = (LPVOID)(DWORD_PTR)pCertInfo->dwKeySize;
    if (96 <= pCertInfo->dwKeySize)  // Recommended Key strength
        rgpvParams[i++] = (LPVOID)plszStrings->szStrengthHigh;
    else if (64 <= pCertInfo->dwKeySize) // Passable key strength
        rgpvParams[i++] = (LPVOID)plszStrings->szStrengthMedium;
    else    // Ick!  Low key strength.
        rgpvParams[i++] = (LPVOID)plszStrings->szStrengthLow;
    INET_ASSERT(i == sizeof(rgpvParams) / sizeof(LPVOID));
    i = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
            | FORMAT_MESSAGE_FROM_STRING
            | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            plszStrings->szCertInfo,
            0, 0,
            (LPTSTR)&szResult,
            0,
            (va_list *)rgpvParams);

ErrorExit:
    if (NULL != szFrom)
        FREE_MEMORY(szFrom);
    if (NULL != szUntil)
        FREE_MEMORY(szUntil);
    return szResult;
}

DWORD
ConvertUnicodeToUTF8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInBufLen,
    OUT LPSTR pszOut,
    OUT DWORD* pdwOutStrLen,
    IN BOOL bEncode
    )

/*++

Routine Description:

    Convert a string of UNICODE characters to UTF-8:

        0000000000000000..0000000001111111: 0xxxxxxx
        0000000010000000..0000011111111111: 110xxxxx 10xxxxxx
        0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx

Arguments:

    pwszIn      - pointer to input wide-character string

    dwInBufLen     - number of CHARACTERS in pwszIn INCLUDING terminating NULL

    pszOut      - pointer to output narrow-character buffer

    pdwOutStrLen    - STRLEN of pszOut (excl. terminating NULL); IN value discarded.

    bEncode     - TRUE if we are to hex encode characters >= 0x80

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - NO ERROR checking done.  Make sure large enuf buffer passed 
in.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "ConvertUnicodeToUtf8",
                "%.100wq, %#x, %#x, %#x, %B",
                pwszIn, dwInBufLen, pszOut, pdwOutStrLen, bEncode
                ));
                
    INET_ASSERT(pwszIn);
    INET_ASSERT((int)dwInBufLen > 0);
    INET_ASSERT(pszOut);

    LPSTR pszStart = pszOut;
    static char hexArray[] = "0123456789ABCDEF";

    while (dwInBufLen--) {

        WORD wchar = *pwszIn++;
        BYTE bchar;

        if (wchar <= 0x007F) {
            *pszOut++ = (BYTE)(wchar);
            continue;
        }

        BYTE lead = ((wchar >= 0x0800) ? 0xE0 : 0xC0);
        int shift = ((wchar >= 0x0800) ? 12 : 6);

        bchar = lead | (BYTE)(wchar >> shift);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;

        if (wchar >= 0x0800) {
            bchar = 0x80 | (BYTE)((wchar >> 6) & 0x003F);
            if (bEncode) {
                *pszOut++ = '%';
                *pszOut++ = hexArray[bchar >> 4];
                bchar = hexArray[bchar & 0x0F];
            }
            *pszOut++ = bchar;
        }
        bchar = 0x80 | (BYTE)(wchar & 0x003F);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;
    }

    *pdwOutStrLen = PtrDiff32(pszOut, pszStart)-1;
    DEBUG_LEAVE(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

LPSTR
ConvertMBCSToUTF8(
    IN LPCSTR lpszMBCSHostName,
    IN DWORD dwMBCSHostNameLength,
    IN DWORD dwCodePage,
    OUT DWORD * pdwUTF8HostNameStrLen,
    IN BOOL bLowerCase
    )
{
    DEBUG_ENTER((DBG_HTTP,
                String,
                "ConvertMBCSToUTF8",
                "%.100q, %#x, %#x, %#x, %B",
                lpszMBCSHostName, dwMBCSHostNameLength, dwCodePage, (pdwUTF8HostNameStrLen ? *pdwUTF8HostNameStrLen : NULL), bLowerCase
                ));

    DEBUG_DUMP(HTTP,
               "lpszMBCSHostName: strlen+1byte\n",
               lpszMBCSHostName,
               (dwMBCSHostNameLength+1)
               );
                           
    LPSTR lpszUTF8HostName = NULL;
    LPWSTR lpwszWideHostName = NULL;

    if (!lpszMBCSHostName || !dwMBCSHostNameLength)
        goto quit;
        
    DWORD dwWideLen = MultiByteToWideChar(dwCodePage, 0, lpszMBCSHostName, dwMBCSHostNameLength, NULL, 0); 
    //IMPORTANT! NULL terminator not included in dwWideLen

    if (dwWideLen)
    {
        lpwszWideHostName = new WCHAR[dwWideLen+1];

        if (lpwszWideHostName
            && (dwWideLen = MultiByteToWideChar(dwCodePage, 0, lpszMBCSHostName, dwMBCSHostNameLength, lpwszWideHostName, dwWideLen))
            && (lpszUTF8HostName = new CHAR[dwWideLen*3+1]))
        {
            // *pdwUTF8HostNameLength = dwWideLen*3+1;
            // Fill in the terminating NULL character since dwMBCSHostNameLength doesn't include NULL.
            lpwszWideHostName[dwWideLen] = L'\0';

            DEBUG_DUMP(HTTP,
                       "Before CharLowerW - lpwszWideHostName: strlen*2+2\n",
                       lpwszWideHostName,
                       (dwWideLen*2+2)
                       );

            if (bLowerCase)
            {
                CharLowerW(lpwszWideHostName);

                DEBUG_DUMP(HTTP,
                           "After CharLowerW - lpwszWideHostName: strlen*2+2\n",
                           lpwszWideHostName,
                           (dwWideLen*2+2)
                           );
            }
            
            DWORD error = ConvertUnicodeToUTF8(lpwszWideHostName, dwWideLen+1, lpszUTF8HostName, pdwUTF8HostNameStrLen, FALSE);

            DEBUG_DUMP(HTTP,
                       "ConvertUnicodeToUTF8 - lpszUTF8HostName: strlen+1\n",
                       lpszUTF8HostName,
                       (*pdwUTF8HostNameStrLen+1)
                       );
            
            // no other error possible
            INET_ASSERT(error == ERROR_SUCCESS);
        }
    }

quit:
    if (lpwszWideHostName)
    {
        delete [] lpwszWideHostName;
    }

    DEBUG_LEAVE(lpszUTF8HostName);
    return lpszUTF8HostName;
}


char *FindNamedValue(char *pszHeader, const char *pszFieldName, unsigned long *pdwValSize) {

    const char ChDblQuote = '\"';

    char *pszBegin, *pszValue;
    BOOL fFound;
    int  cbName;

    char *pch = pszHeader;

ExpectName:
    while (*pch && isspace(*pch))
        pch++;

ParseName:
    pszBegin = pch;

    while (*pch && isalnum(*pch))
        pch++;

    cbName = (int) (pch-pszBegin);
    fFound = (cbName>0) && !strncmp(pszBegin, pszFieldName, cbName);

ExpectEqSign:
    while (*pch && isspace(*pch))
        pch++;

    if (*pch=='=')
        pch++;

ExpectValue:
    while (*pch && isspace(*pch))
        pch++;

    if (*pch=='\"') {
        pch++;
        goto ParseQuotedValue;
    }

ParseValue:
    pszValue = pch;
    while (*pch && *pch!=',')
        pch++;

    goto ExpectComma;

ParseQuotedValue:
    pszValue = pch;
    while (*pch && *pch!=ChDblQuote)
        pch++;

ExpectComma:
    if (fFound) {
        int cbValue = (int) (pch-pszValue);
        *pdwValSize = cbValue;
        return pszValue;
    }

    while (*pch && *pch!=',')
        pch++;

    if (*pch==',') {
        pch++;
        goto ExpectName;
    }

    return NULL;
}


// Helper to determine if we're currently loaded during GUI mode setup
BOOL IsInGUIModeSetup()
{
    // could be called multiple times in wininet
    static DWORD s_dwSystemSetupInProgress = 42;

    if (42 == s_dwSystemSetupInProgress)
    {
        // Rule is that this value will exist and be equal to 1 if in GUI mode setup.
        // Default to NO, and only do this for upgrades because this is potentially
        // needed for unattended clean installs.
        s_dwSystemSetupInProgress = 0;

        HKEY hKeySetup = NULL;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("System\\Setup"),
                                          0,
                                          KEY_READ,
                                          &hKeySetup))
        {
            DWORD dwSize = sizeof(s_dwSystemSetupInProgress);

            if (ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                  TEXT("SystemSetupInProgress"),
                                                  NULL,
                                                  NULL,
                                                  (LPBYTE) &s_dwSystemSetupInProgress,
                                                  &dwSize))
            {
                s_dwSystemSetupInProgress = 0;
            }
            else
            {
                dwSize = sizeof(s_dwSystemSetupInProgress);
                if (s_dwSystemSetupInProgress &&
                    ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                      TEXT("UpgradeInProgress"),
                                                      NULL,
                                                      NULL,
                                                      (LPBYTE) &s_dwSystemSetupInProgress,
                                                      &dwSize))
                {
                    s_dwSystemSetupInProgress = 0;
                }
            }

            RegCloseKey(hKeySetup);
        }
    }
    return s_dwSystemSetupInProgress ? TRUE : FALSE;
}


#ifdef DONT_USE_IERT
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokEx (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
#endif  // DONT_USE_IERT


// We need a DBCS-safe version of StrTokEx. 

char* StrTokEx2(char ** pstring, const char * control)
{
    /*unsigned*/ char *str;
    const /*unsigned*/ char *ctrl = control;
    unsigned char map[32];
    int count;

    char *tokenstr;

    if(*pstring == NULL)
        return NULL;

    /* Clear control map */
    for (count = 0; count < 32; count++)
            map[count] = 0;

    /* Set bits in delimiter table */
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        ctrl++;
    } while (*ctrl);

    /* Initialize str. */
    str = *pstring;

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token if this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ((*str>0) && ((CharNext(str)-str)==1) && (map[*str >> 3] & (1 << (*str & 7))))
        str = CharNext(str);

    tokenstr = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for ( ; *str ; str = CharNext(str))
    {
        if (((CharNext(str)-str)==1) && (*str>0) && (map[*str >> 3] & (1 << (*str & 7))))
        {
            *str++ = '\0';
            break;
        }
    }

    /* string now points to beginning of next token */
    *pstring = str;

    /* Determine if a token has been found. */
    if ( tokenstr == str )
        return NULL;
    else
        return tokenstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\rprintf.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rprintf.cxx

Abstract:

    Contains my own version of printf(), sprintf() and vprintf(). Useful since
    adding new printf escape sequences becomes easy

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Richard L Firth (rfirth) 20-Jun-1995

Revision History:

    29-Aug-1989 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */

int cdecl _sprintf(char* buffer, char* format, va_list args) {

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR;
            }
            *buffer++ = LF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%';
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T';
                        *buffer++ = 'R';
                        *buffer++ = 'U';
                        *buffer++ = 'E';
                    } else {
                        *buffer++ = 'F';
                        *buffer++ = 'A';
                        *buffer++ = 'L';
                        *buffer++ = 'S';
                        *buffer++ = 'E';
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' ';
                        }
                        *buffer++ = (char) va_arg(args, int);
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-';
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+';
                        }
                        convert(&buffer,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {

                        void* p;

                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
                            *buffer++ = ':';
                        }
                        convert(&buffer,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"';
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {

                        char* s;

                        s = va_arg(args, char*);
                        if (s != NULL) {

                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }

                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen == FieldPrecision)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' ';
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.';
                                *buffer++ = '.';
                                *buffer++ = '.';
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '(';
                            *buffer++ = 'n';
                            *buffer++ = 'u';
                            *buffer++ = 'l';
                            *buffer++ = 'l';
                            *buffer++ = ')';
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"';
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0';
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x';
                        }
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format;
        } /* switch <character> */
        ++format;
    } /* while */
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('a'-'9'-1);

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('A'-'9'-1);

    *pn >>= 4;
    return rch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\memalloc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memalloc.cxx

Abstract:

    Debug-only memory allocation routines

    Contents:
        InetInitializeDebugMemoryPackage
        InetTerminateDebugMemoryPackage
        InetAllocateMemory
        InetReallocateMemory
        (InetIsBlockMoveable)
        InetFreeMemory
        (InetCheckBlockConsistency)
        InetLockMemory
        InetUnlockMemory
        InetMemorySize
        InetCheckDebugMemoryFreed
        (x86SleazeCallersAddress)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// manifests
//

#define HEADER_SIGNATURE    0x414d454d  // 'MEMA'
#define FOOTER_SIGNATURE    0x434f4c4c  // 'LLOC'
#define DWORD_FILL          0xa9a9a9a9
#define BYTE_FILL           0xa9
#define BYTE_FILL_EXTRA     0xcb
#define GUARD_DWORD_FILL    0xcccd21f4
#define DWORD_FREE_FILL     0xb7b7b7b7
#define BYTE_FREE_FILL      0xb7

//
// private types
//

typedef struct {

    //
    // hMoveable - local handle of moveable memory that this tag links
    //

    HLOCAL hMoveable;

} DEBUG_MOVEABLE_TAG, *LPDEBUG_MOVEABLE_TAG;

typedef struct {

    //
    // List - maintains a list of allocated blocks
    //

    LIST_ENTRY List;

    //
    // BlockLength - the size of this block, *including* all headers, footers
    // and padding
    //

    UINT BlockLength;

    //
    // RealLength - the original caller request
    //

    UINT RealLength;

    //
    // Signature - just used as a sanity check to ensure that what we are
    // dealing with is actually a block we allocated
    //

    DWORD Signature;

    //
    // LockCount - if this is moveable memory, keeps the number of times this
    // block has been locked
    //

    LONG LockCount;

    //
    // Flags - what type of memory this is, etc.
    //

    DWORD Flags;

    //
    // LastAccessOperation - the operation caller at LastAccessReturnAddress
    // performed
    //

    MEMALLOC_ACTION LastAccessOperation;

    //
    // LastAccessReturnAddress - caller of last function to perform memory
    // function operation (alloc, lock, realloc, unlock, etc) on this block
    //

    LPVOID LastAccessReturnAddress[2];

    //
    // CreatorReturnAddress - return EIP (x86-only) of caller of allocator
    // and caller of caller
    //

    LPVOID CreatorReturnAddress[2];

    //
    // Tag - if this is moveable memory, we can't add this block to the allocated
    // block list, we have to allocate a DEBUG_MOVEABLE_TAG, link that and point
    // to it from here
    //

    LPDEBUG_MOVEABLE_TAG Tag;

    //
    // Guard - just a sentinel to find out if the caller is writing before the
    // start of this block
    //

    DWORD Guard[4];

    //
    // sizeof(MEMORY_SIGNATURE) currently 17 DWORDs
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

typedef struct {

    //
    // Guard - allows us to determine if the end of allocated memory was
    // overwritten
    //

    DWORD Guard[4];

    //
    // Signature - should be the footer signature
    //

    DWORD Signature;

    //
    // BlockLength - should be the same as the header
    //

    DWORD BlockLength;

    //
    // Guard2 - to make sure the end of the block is coherent
    //

    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// data
//

LONG ActualMemoryAllocated = 0;
LONG BlockLengthAllocated = 0;
LONG RealLengthAllocated = 0;
DWORD MemoryAllocations = 0;
DWORD MemoryFrees = 0;
SERIALIZED_LIST AllocatedBlockList;

//
// macros
//

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)

#else

#define GET_CALLERS_ADDRESS(p, pp)

#endif // defined(i386)

//
// private prototypes
//

PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    );

PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    );

PRIVATE
VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// functions
//


VOID
InetInitializeDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Just initializes data items in this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    static BOOL MemoryPackageInitialized = FALSE;

    if (!MemoryPackageInitialized) {
        InitializeSerializedList(&AllocatedBlockList);
        MemoryPackageInitialized = TRUE;
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


VOID
InetTerminateDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Undoes any resource allocation in InetInitializeDebugMemoryPackage, after
    checking that all memory is freed

Arguments:

    None.

Return Value:

    None.

--*/

{
    InetCheckDebugMemoryFreed();
    TerminateSerializedList(&AllocatedBlockList);
}


HLOCAL
InetAllocateMemory(
    IN UINT LocalAllocFlags,
    IN UINT NumberOfBytes
    )

/*++

Routine Description:

    Debug memory allocator: allocates memory with head & tail. Fills memory
    with signature unless otherwise requested. If this is moveable memory
    then the caller must lock the memory with InetLockMemory(), else a pointer
    will be returned to the head of the heap's real start-of-block, and the
    caller will probably nuke the signature contents (but we should discover
    this when the block is freed)

Arguments:

    LocalAllocFlags - flags to be passed on to LocalAlloc
    NumberOfBytes   - to allocate for caller

Return Value:

    LPVOID
        Success - pointer to memory after DEBUG_MEMORY_HEADER
        Failure - NULL

--*/

{
    HLOCAL hLocal;
    UINT blockLength;
    BOOL isMoveable;

    isMoveable = (LocalAllocFlags & LMEM_MOVEABLE) ? TRUE : FALSE;
    blockLength = ROUND_UP_DWORD(NumberOfBytes)
                + sizeof(DEBUG_MEMORY_HEADER)
                + sizeof(DEBUG_MEMORY_FOOTER)
                ;

    //
    // possible problem: if NumberOfBytes + signatures would overflow UINT.
    // Only really problematic on 16-bit platforms
    //

    if (blockLength < NumberOfBytes) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)NumberOfBytes
                    ));

        DEBUG_BREAK(MEMALLOC);

        return (HLOCAL)NULL;
    }

    hLocal = LocalAlloc(LocalAllocFlags, blockLength);
    if (hLocal != NULL) {

        LPVOID lpMem;
        LPDEBUG_MEMORY_HEADER lpHeader;
        DWORD dwFiller;
        BYTE bFiller;
        UINT dwFillLength;
        UINT bFillLength1;
        UINT bFillLength2;
        UINT i;
        LPVOID userPointer;

        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += NumberOfBytes;
        ++MemoryAllocations;

        if (isMoveable) {
            lpMem = (LPVOID)LocalLock(hLocal);
            if (lpMem == NULL) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalLock(%x) failed: %d\n",
                            hLocal,
                            GetLastError()
                            ));

                DEBUG_BREAK(MEMALLOC);

            }
        } else {
            lpMem = (LPVOID)hLocal;
        }

        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMem;
        InitializeListHead(&lpHeader->List);
        lpHeader->BlockLength = blockLength;
        lpHeader->RealLength = NumberOfBytes;
        lpHeader->Signature = HEADER_SIGNATURE;
        lpHeader->LockCount = 0;
        lpHeader->Flags = LocalAllocFlags;

        GET_CALLERS_ADDRESS(&lpHeader->CreatorReturnAddress[0],
                            &lpHeader->CreatorReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemAllocate;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            lpHeader->Guard[i] = GUARD_DWORD_FILL;
        }

        if (LocalAllocFlags & LMEM_ZEROINIT) {
            dwFiller = 0;
            bFiller = 0;
        } else {
            dwFiller = DWORD_FILL;
            bFiller = BYTE_FILL;
        }
        dwFillLength = NumberOfBytes / sizeof(DWORD);
        bFillLength1 = NumberOfBytes % sizeof(DWORD);
        bFillLength2 = bFillLength1 ? (sizeof(DWORD) - bFillLength1) : 0;
        userPointer = (LPVOID)(lpHeader + 1);

        LPDWORD lpdwUserPointer = (LPDWORD)userPointer;

        for (i = 0; i < dwFillLength; ++i) {
            *lpdwUserPointer++ = dwFiller;
        }

        LPBYTE lpbUserPointer = (LPBYTE)lpdwUserPointer;

        for (i = 0; i < bFillLength1; ++i) {
            *lpbUserPointer++ = bFiller;
        }
        for (i = 0; i < bFillLength2; ++i) {
            *lpbUserPointer++ = BYTE_FILL_EXTRA;
        }

        userPointer = (LPVOID)lpbUserPointer;

        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard[i] = GUARD_DWORD_FILL;
        }
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->BlockLength = blockLength;
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->Signature = FOOTER_SIGNATURE;
        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2[i] = GUARD_DWORD_FILL;
        }

        //
        // if this is moveable memory, then we can't link it into the allocated
        // block list because if it moves, the list gets nuked. So we have to
        // allocate a DEBUG_MOVEABLE_TAG, link that and point to it from here
        //

        if (isMoveable) {

            LPDEBUG_MOVEABLE_TAG lpTag;

            lpTag = (LPDEBUG_MOVEABLE_TAG)InetAllocateMemory(LMEM_FIXED, sizeof(DEBUG_MOVEABLE_TAG));

            INET_ASSERT(lpTag != NULL);

            lpTag->hMoveable = hLocal;
            lpHeader->Tag = lpTag;
        } else {
            InsertAtHeadOfSerializedList(&AllocatedBlockList, &lpHeader->List);
        }

        if (isMoveable) {
            if (LocalUnlock(hLocal)) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalUnlock(%x): memory still locked\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);

            } else {

                DWORD err;

                err = GetLastError();
                if (err != NO_ERROR) {

                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("LocalUnlock(%x) returns %d\n",
                                hLocal,
                                err
                                ));

                    DEBUG_BREAK(MEMALLOC);

                }
            }
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


HLOCAL
InetReallocateMemory(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Reallocates previously allocated block

    BUGBUG - this doesn't handle the more exotic LocalReAlloc stuff, like
             DISCARDABLE memory, allocating/freeing through realloc etc

Arguments:

    hLocal      - block to reallocate
    Size        - new size
    Flags       - new flags
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to find out from hLocal whether this
                  memory is moveable or fixed

Return Value:

    HLOCAL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    UINT realLength;
    UINT heapLength;

    //
    // can't handle reallocating down to zero
    //

    INET_ASSERT(Size != 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        heapLength = LocalSize(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        heapLength = LocalSize((HLOCAL)lpHeader);
    }

    InetCheckBlockConsistency((LPVOID)lpHeader);

    if (IsMoveable) {
        LocalUnlock(hLocal);
    }

    realLength = Size;

    Size = ROUND_UP_DWORD(Size)
         + sizeof(DEBUG_MEMORY_HEADER)
         + sizeof(DEBUG_MEMORY_FOOTER)
         ;

    ActualMemoryAllocated -= heapLength;
    BlockLengthAllocated -= lpHeader->BlockLength;
    RealLengthAllocated -= lpHeader->RealLength;

    hLocal = LocalReAlloc(hLocal, Size, Flags);
    if (hLocal != NULL) {

        LPBYTE extraPointer;
        UINT extraLength;
        UINT i;
        LPDEBUG_MEMORY_FOOTER lpFooter;

        if (IsMoveable) {
            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
        }

        lpHeader->BlockLength = Size;
        lpHeader->RealLength = realLength;
        lpHeader->Flags = Flags;

        GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                            &lpHeader->LastAccessReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemReallocate;

        extraPointer = (LPBYTE)(lpHeader + 1) + realLength;
        extraLength = (sizeof(DWORD) - (realLength % sizeof(DWORD)))
                    & (sizeof(DWORD) - 1)
                    ;
        for (i = 0; i < extraLength; ++i) {
            *extraPointer++ = BYTE_FILL_EXTRA;
        }
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)(lpHeader + 1)
                 + ROUND_UP_DWORD(realLength)
                 );
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            lpFooter->Guard[i] = GUARD_DWORD_FILL;
        }
        lpFooter->Signature = FOOTER_SIGNATURE;
        lpFooter->BlockLength = Size;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            lpFooter->Guard2[i] = GUARD_DWORD_FILL;
        }
        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += Size;
        RealLengthAllocated += lpHeader->RealLength;
        if (IsMoveable) {
            LocalUnlock(hLocal);
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines if hLocal is moveable or fixed memory

Arguments:

    hLocal  -

Return Value:

    BOOL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;

    //
    // BUGBUG - this method won't work for Win32s unless it supports SEH. But
    //          there is another method...
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
    __try {
        if (lpHeader->Signature == HEADER_SIGNATURE) {
            isMoveable = FALSE;
        } else {

            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

            INET_ASSERT(lpHeader != NULL);

            isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
            LocalUnlock(hLocal);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // yeowww! hLocal must be a handle to moveable memory. Either that, or
        // it is completely bogus
        //

        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
        LocalUnlock(hLocal);
    }
    return isMoveable;
}


HLOCAL
InetFreeMemory(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Debug memory deallocator: checks memory is already allocated and that the
    head and tail structures are still ok. Fills freed memory with signature

Arguments:

    hLocal  - address/handle of memory to free
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to determine if the memory is moveable
                  or fixed

Return Value:

    HLOCAL
        Success - NULL
        Failure - hLocal

--*/

{
    UINT memFlags;
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;
    UINT memSize;
    UINT blockLength;
    UINT realLength;

    if (!IsMoveable) {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
    }

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) == 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
    }

    memSize = LocalSize(hLocal);

    INET_ASSERT((lpHeader->BlockLength <= memSize)
                && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
                && (lpHeader->RealLength < lpHeader->BlockLength)
                );

    InetCheckBlockConsistency((LPVOID)lpHeader);

    //
    // if this is moveable memory then we didn't link it to the allocated
    // block list, but allocated a DEBUG_MOVEABLE_TAG to do the job. We
    // must remove it
    //

    if (IsMoveable) {

        LPDEBUG_MOVEABLE_TAG lpTag;

        lpTag = lpHeader->Tag;

        INET_ASSERT(lpTag->hMoveable == hLocal);

        InetFreeMemory(lpTag, FALSE);
    } else {
        RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List);
    }

    if (IsMoveable) {

        BOOL stillLocked;

        stillLocked = LocalUnlock(hLocal);

        INET_ASSERT(!stillLocked);
        INET_ASSERT(GetLastError() == NO_ERROR);

    }

    blockLength = lpHeader->BlockLength;
    realLength = lpHeader->RealLength;
    hLocal = LocalFree(hLocal);

    INET_ASSERT(hLocal == NULL);

    ActualMemoryAllocated -= memSize;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= realLength;
    ++MemoryFrees;

    return hLocal;
}


PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    )

/*++

Routine Description:

    Checks that what we think is a valid allocated block (allocated by
    InetAllocateMemory), really is

Arguments:

    lpMemory    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    LPDEBUG_MEMORY_FOOTER lpFooter;
    UINT i;
    BOOL headerGuardOverrun;
    BOOL footerGuardOverrun;
    BOOL footerGuard2Overrun;
    BOOL extraMemoryOverrun;
    LPBYTE lpExtraMemory;
    UINT byteLength;

    __try {
        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMemory;
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)lpMemory
                 + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)))
                 ;

        headerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuard2Overrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RealLength;
        extraMemoryOverrun = FALSE;
        byteLength = ROUND_UP_DWORD(lpHeader->RealLength) - lpHeader->RealLength;
        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %x\n",
                        lpMemory
                        ));

            DEBUG_BREAK(MEMALLOC);

        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %x - exception occurred\n",
                    lpMemory
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


LPVOID
InetLockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Locks a moveable memory block and increments the lock count. Checks block
    consistency

Arguments:

    hLocal  - handle of moveable memory to lock

Return Value:

    LPVOID
        pointer to locked memory

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader = NULL;
    UINT memFlags;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

    INET_ASSERT(lpHeader != NULL);

    InetCheckBlockConsistency((LPVOID)lpHeader);
    ++lpHeader->LockCount;

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemLock;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT((memFlags != LMEM_INVALID_HANDLE)
                && (lpHeader->LockCount == (LONG)(memFlags & LMEM_LOCKCOUNT))
                );

    return ++lpHeader;
}


BOOL
InetUnlockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Unlocks a (locked!) moveable memory block

Arguments:

    hLocal  - handle (pointer) of block to unlock

Return Value:

    None.

--*/

{
    UINT memFlags;
    BOOL stillLocked;
    LPDEBUG_MEMORY_HEADER lpHeader;
    DWORD lockCount;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) >= 1);

    //
    // memory must be locked or LocalFlags would have returned error.
    // Lock memory again to get pointer to block, then unlock it.
    // There should still be at least one lock on the block
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
    LocalUnlock(hLocal);

    InetCheckBlockConsistency((LPVOID)lpHeader);

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemUnlock;

    lockCount = --lpHeader->LockCount;
    stillLocked = LocalUnlock(hLocal);

    INET_ASSERT(stillLocked ? (lockCount > 0) : GetLastError() == NO_ERROR);

    return stillLocked;
}


UINT
InetMemorySize(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Returns allocated block size

Arguments:

    hLocal      - memory handle
    IsMoveable  - TRUE if hLocal is a handle to moveable memory >>> THAT IS NOT
                  LOCKED <<<

Return Value:

    UINT

--*/

{
    UINT size;
    UINT sizeInHeader;
    LPDEBUG_MEMORY_HEADER lpHeader;

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize(hLocal);
        LocalUnlock(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize((HLOCAL)lpHeader);
    }

    INET_ASSERT((sizeInHeader <= size)
                && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                );

    return sizeInHeader;
}


BOOL
InetCheckDebugMemoryFreed(
    VOID
    )

/*++

Routine Description:

    Check that we don't have any memory allocated

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    if (ActualMemoryAllocated || (MemoryFrees != MemoryAllocations)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("MemoryAllocated = %ld, MemoryAllocations = %lu, MemoryFrees = %lu\n",
                    ActualMemoryAllocated,
                    MemoryAllocations,
                    MemoryFrees
                    ));

        DEBUG_BREAK(MEMALLOC);

        return FALSE;
    }
    return TRUE;
}

#if defined(i386)


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\inetdbg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

    Contents:
        InternetDebugInitialize
        InternetDebugTerminate
        InternetGetDebugInfo
        InternetSetDebugInfo
        InternetOpenDebugFile
        InternetReopenDebugFile
        InternetCloseDebugFile
        InternetFlushDebugFile
        InternetDebugSetControlFlags
        InternetDebugResetControlFlags
        InternetDebugEnter
        InternetDebugLeave
        InternetDebugError
        InternetDebugPrint
        (InternetDebugPrintString)
        InternetDebugPrintf
        InternetDebugOut
        InternetDebugDump
        InternetDebugDumpFormat
        InternetAssert
        InternetGetDebugVariable
        (InternetGetDebugVariableString)
        InternetMapError
        InternetMapStatus
        InternetMapOption
        InternetMapHttpOption
        InternetMapHttpState
        InternetMapHttpStateFlag
        InternetMapAsyncRequest
        InternetMapHandleType
        InternetMapScheme
        InternetMapOpenType
        InternetMapService
        (ExtractFileName)
        (SetDebugPrefix)
        SourceFilename
        InitSymLib
        TermSymLib
        GetDebugSymbol
        x86SleazeCallStack
        x86SleazeCallersAddress

Author:

    Richard L Firth (rfirth) 13-Feb-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    13-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <ieverp.h>
#include "rprintf.h"
#include <imagehlp.h>
#include "autodial.h"

#ifdef ENABLE_DEBUG

//
// private manifests
//

#define SWITCH_VARIABLE_NAME        "WininetDebugging"
#define CONTROL_VARIABLE_NAME       "WininetControl"
#define CATEGORY_VARIABLE_NAME      "WininetCategory"
#define ERROR_VARIABLE_NAME         "WininetError"
#define BREAK_VARIABLE_NAME         "WininetBreak"
#define DEFAULT_LOG_VARIABLE_NAME   "WininetLog"
#define CHECK_LIST_VARIABLE_NAME    "WininetCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "WininetLogFile"
#define INDENT_VARIABLE_NAME        "WininetLogIndent"
#define NO_PID_IN_LOG_FILENAME     "WininetNoPidInLogFilename"

#define DEFAULT_LOG_FILE_NAME       "WININET.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  (4 K)

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    );
//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
BOOL UrlcacheDebugEnabled = FALSE;
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//


PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // ensure registry key open (normally done in GlobalDataInitialize() later)
    //

    EnsureInternetSettingsKeyCached();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    //
    // check see if there are any debug variable overrides in the environment
    // or the registry. If "WininetLog=<!0>" is set then we use the flags that
    // are most commonly used to generate WININET.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    BOOL defaultDebugVariables = FALSE;

    InternetGetDebugVariable(DEFAULT_LOG_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );
    DWORD InternetNoPidInLogFilename=0;
    InternetGetDebugVariable(NO_PID_IN_LOG_FILENAME, &InternetNoPidInLogFilename);

    if (!InternetNoPidInLogFilename)
    {
        char szFullPathName[MAX_PATH + 1];
        LPSTR szExecutableName;

        if (GetModuleFileName(NULL, szFullPathName, sizeof(szFullPathName))) 
        {
            szExecutableName = StrRChr(szFullPathName, NULL, '\\');
            if (szExecutableName != NULL)
                ++szExecutableName;
            else
                szExecutableName = szFullPathName;
        } 
        else
            szExecutableName = "";

        DWORD cbFilenameLen = strlen(InternetDebugFilename);
        //                          ".xxxxx.yyy.#########.LOG" 
        DWORD cbProcessInfoLenMax = 1 + strlen(szExecutableName) + 1 + 9 + 1 + 3;

        if (cbProcessInfoLenMax < sizeof(InternetDebugFilename))
            wsprintf(InternetDebugFilename+cbFilenameLen, ".%s.%u.LOG", 
                szExecutableName,
                GetCurrentProcessId());
    };
    
    UrlcacheDebugEnabled = InternetDebugEnabled &&
        (InternetDebugCategoryFlags & DBG_CACHE);

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open WININET.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;
}

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the internal debug variables

Arguments:

    lpBuffer            - pointer to structure that receives the variables

    lpdwBufferLength    - IN: Length of buffer
                          OUT: length of returned data if successful, else
                          required length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS;

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD requiredLength;
    DWORD error;
    int filenameLength;

    filenameLength = ((InternetDebugFileHandle != INVALID_HANDLE_VALUE)
                        ? strlen(InternetDebugFilename) : 0) + 1;

    requiredLength = sizeof(*lpBuffer) + filenameLength;
    if ((lpBuffer != NULL) && (*lpdwBufferLength >= requiredLength)) {
        lpBuffer->ErrorLevel = InternetDebugErrorLevel;
        lpBuffer->ControlFlags = InternetDebugControlFlags;
        lpBuffer->CategoryFlags = InternetDebugCategoryFlags;
        lpBuffer->BreakFlags = InternetDebugBreakFlags;
        lpBuffer->IndentIncrement = InternetDebugIndentIncrement;
        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
            memcpy(lpBuffer->Filename, InternetDebugFilename, filenameLength);
        } else {
            lpBuffer->Filename[0] = '\0';
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the internal debugging variables to the values in the buffer. To make
    incrmental changes, the caller must first read the variables, change the
    bits they're interested in, then change the whole lot at one go

Arguments:

    lpBuffer        - pointer to structure that contains the variables

    dwBufferLength  - size of lpBuffer. Ignored

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    InternetDebugErrorLevel = lpBuffer->ErrorLevel;
    InternetDebugCategoryFlags = lpBuffer->CategoryFlags;
    InternetDebugControlFlags = lpBuffer->ControlFlags;
    InternetDebugBreakFlags = lpBuffer->BreakFlags;
    InternetDebugIndentIncrement = lpBuffer->IndentIncrement;

    //
    // handle the debug file. If we get an empty string, then (if we are logging
    // to a file), close the file.
    //
    // If the filename is exactly the same as we're already using, then the
    // caller doesn't want to change the log file
    //
    // If the filename is different, then we are being asked to create a new log
    // file: close the old and open the new. If we cannot open the new file then
    // set the filename to the NUL string in the debug buffer
    //

    if (lpBuffer->Filename[0]) {
        if (strcmp(InternetDebugFilename, lpBuffer->Filename) != 0) {
            InternetCloseDebugFile();
            InternetReopenDebugFile(lpBuffer->Filename);
            if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
                strcpy(InternetDebugFilename, lpBuffer->Filename);
            } else {
                lpBuffer->Filename[0] = '\0';
            }
        }
    } else {
        InternetCloseDebugFile();
    }
    return ERROR_SUCCESS;
}


BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> WinInet Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
                                VER_PRODUCTVERSION_STRING,
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = NEW(INTERNET_DEBUG_RECORD);

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    pRecord->Stack = pThreadInfo->Stack;
    pRecord->Category = Category;
    pRecord->ReturnType = ReturnType;
    pRecord->Function = Function;
    pRecord->LastTime = GetTickCountWrap();
    pThreadInfo->Stack = pRecord;
    ++pThreadInfo->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

        char buf[4096];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, "%s(", Function);
        if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;

            va_start(parms, ParameterList);
            bufptr += _sprintf(bufptr, (char*)ParameterList, parms);
            va_end(parms);
        }
        rsprintf(bufptr, ")\n");
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        pThreadInfo->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR format;
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    // if (InternetDebugErrorLevel >= DBG_INFO) 
        {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pRecord->Category) {
            switch (pRecord->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;

            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pRecord->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            pThreadInfo->IndentIncrement -= InternetDebugIndentIncrement;
            if (pThreadInfo->IndentIncrement < 0) {
                pThreadInfo->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --pThreadInfo->CallDepth;
    pThreadInfo->Stack = pRecord->Stack;

    DEL(pRecord);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);
    INET_ASSERT(GetLastError() == lastError);

    if (pThreadInfo == NULL) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (pRecord == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pRecord->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    strcpy(bufptr, String);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

    char buf[128];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
    rsprintf(Buffer, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer,
             "\n"
             "*** Wininet Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}


PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN ctToken
    )
{
    switch(ctToken)
    {
        CASE_OF(CHUNK_TOKEN_DIGIT);
        CASE_OF(CHUNK_TOKEN_DATA);
        CASE_OF(CHUNK_TOKEN_COLON);
        CASE_OF(CHUNK_TOKEN_CR);
        CASE_OF(CHUNK_TOKEN_LF);
        CASE_OF(CHUNK_TOKEN_INVALID);

        default:
            return "?";

    }
}

LPSTR
InternetMapChunkState(
    IN CHUNK_STATE csState
    )
{
    switch(csState)
    {
        CASE_OF(CHUNK_STATE_START);
        CASE_OF(CHUNK_STATE_SIZE_PARSE);
        CASE_OF(CHUNK_STATE_SIZE_CRLF);
        CASE_OF(CHUNK_STATE_DATA_PARSE);
        CASE_OF(CHUNK_STATE_DATA_CRLF);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_NAME);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_VALUE);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_CRLF);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF);
        CASE_OF(CHUNK_STATE_FINISHED);

        default:
            return "?";

    }
}


LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WININET errors
    //

    CASE_OF(ERROR_INTERNET_OUT_OF_HANDLES);
    CASE_OF(ERROR_INTERNET_TIMEOUT);
    CASE_OF(ERROR_INTERNET_EXTENDED_ERROR);
    CASE_OF(ERROR_INTERNET_INTERNAL_ERROR);
    CASE_OF(ERROR_INTERNET_INVALID_URL);
    CASE_OF(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_INTERNET_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_INVALID_OPTION);
    CASE_OF(ERROR_INTERNET_BAD_OPTION_LENGTH);
    CASE_OF(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_INTERNET_SHUTDOWN);
    CASE_OF(ERROR_INTERNET_INCORRECT_USER_NAME);
    CASE_OF(ERROR_INTERNET_INCORRECT_PASSWORD);
    CASE_OF(ERROR_INTERNET_LOGIN_FAILURE);
    CASE_OF(ERROR_INTERNET_INVALID_OPERATION);
    CASE_OF(ERROR_INTERNET_OPERATION_CANCELLED);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_INTERNET_NOT_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    CASE_OF(ERROR_INTERNET_NO_DIRECT_ACCESS);
    CASE_OF(ERROR_INTERNET_NO_CONTEXT);
    CASE_OF(ERROR_INTERNET_NO_CALLBACK);
    CASE_OF(ERROR_INTERNET_REQUEST_PENDING);
    CASE_OF(ERROR_INTERNET_INCORRECT_FORMAT);
    CASE_OF(ERROR_INTERNET_ITEM_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_CANNOT_CONNECT);
    CASE_OF(ERROR_INTERNET_CONNECTION_ABORTED);
    CASE_OF(ERROR_INTERNET_CONNECTION_RESET);
    CASE_OF(ERROR_INTERNET_FORCE_RETRY);
    CASE_OF(ERROR_INTERNET_INVALID_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_NEED_UI);
    CASE_OF(ERROR_INTERNET_HANDLE_EXISTS);
    CASE_OF(ERROR_INTERNET_SEC_CERT_DATE_INVALID);
    CASE_OF(ERROR_INTERNET_SEC_CERT_CN_INVALID);
    CASE_OF(ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR);
    CASE_OF(ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR);
    CASE_OF(ERROR_INTERNET_MIXED_SECURITY);
    CASE_OF(ERROR_INTERNET_CHG_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_INTERNET_INVALID_CA);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP);
    CASE_OF(ERROR_INTERNET_ASYNC_THREAD_FAILED);
    CASE_OF(ERROR_INTERNET_REDIRECT_SCHEME_CHANGE);
    CASE_OF(ERROR_INTERNET_DIALOG_PENDING);
    CASE_OF(ERROR_INTERNET_RETRY_DIALOG);
    CASE_OF(ERROR_INTERNET_NO_NEW_CONTAINERS);
    CASE_OF(ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR);
    CASE_OF(ERROR_INTERNET_INSERT_CDROM);
    CASE_OF(ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED);
    CASE_OF(ERROR_INTERNET_SEC_CERT_ERRORS);
    CASE_OF(ERROR_INTERNET_SECURITY_CHANNEL_ERROR);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_CACHE_FILE);
    CASE_OF(ERROR_INTERNET_TCPIP_NOT_INSTALLED);
    CASE_OF(ERROR_INTERNET_OFFLINE);
    CASE_OF(ERROR_INTERNET_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_PROXY_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT);
    CASE_OF(ERROR_INTERNET_SEC_INVALID_CERT);
    CASE_OF(ERROR_INTERNET_SEC_CERT_REVOKED);
    CASE_OF(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
    CASE_OF(ERROR_INTERNET_NOT_INITIALIZED);

    CASE_OF(ERROR_FTP_TRANSFER_IN_PROGRESS);
    CASE_OF(ERROR_FTP_DROPPED);
    CASE_OF(ERROR_FTP_NO_PASSIVE_MODE);

    CASE_OF(ERROR_GOPHER_PROTOCOL_ERROR);
    CASE_OF(ERROR_GOPHER_NOT_FILE);
    CASE_OF(ERROR_GOPHER_DATA_ERROR);
    CASE_OF(ERROR_GOPHER_END_OF_DATA);
    CASE_OF(ERROR_GOPHER_INVALID_LOCATOR);
    CASE_OF(ERROR_GOPHER_INCORRECT_LOCATOR_TYPE);
    CASE_OF(ERROR_GOPHER_NOT_GOPHER_PLUS);
    CASE_OF(ERROR_GOPHER_ATTRIBUTE_NOT_FOUND);
    CASE_OF(ERROR_GOPHER_UNKNOWN_LOCATOR);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_DOWNLEVEL_SERVER);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_HEADER);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);
    CASE_OF(ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION);
    CASE_OF(ERROR_HTTP_COOKIE_DECLINED);
    CASE_OF(ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION);

    //
    // internal WININET errors
    //

    CASE_OF(ERROR_INTERNET_INTERNAL_SOCKET_ERROR);
    CASE_OF(ERROR_INTERNET_CONNECTION_AVAILABLE);
    CASE_OF(ERROR_INTERNET_NO_KNOWN_SERVERS);
    CASE_OF(ERROR_INTERNET_PING_FAILED);
    CASE_OF(ERROR_INTERNET_NO_PING_SUPPORT);
    CASE_OF(ERROR_INTERNET_CACHE_SUCCESS);


    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);
    CASE_OF(SEC_E_WRONG_PRINCIPAL);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

#if 0
    //
    // RAS errors
    //

    CASE_OF(PENDING);
    CASE_OF(ERROR_INVALID_PORT_HANDLE);
    CASE_OF(ERROR_PORT_ALREADY_OPEN);
    CASE_OF(ERROR_BUFFER_TOO_SMALL);
    CASE_OF(ERROR_WRONG_INFO_SPECIFIED);
    CASE_OF(ERROR_CANNOT_SET_PORT_INFO);
    CASE_OF(ERROR_PORT_NOT_CONNECTED);
    CASE_OF(ERROR_EVENT_INVALID);
    CASE_OF(ERROR_DEVICE_DOES_NOT_EXIST);
    CASE_OF(ERROR_BUFFER_INVALID);
    CASE_OF(ERROR_ROUTE_NOT_AVAILABLE);
    CASE_OF(ERROR_ROUTE_NOT_ALLOCATED);
    CASE_OF(ERROR_INVALID_COMPRESSION_SPECIFIED);
    CASE_OF(ERROR_OUT_OF_BUFFERS);
    CASE_OF(ERROR_PORT_NOT_FOUND);
    CASE_OF(ERROR_ASYNC_REQUEST_PENDING);
    CASE_OF(ERROR_ALREADY_DISCONNECTING);
    CASE_OF(ERROR_PORT_NOT_OPEN);
    CASE_OF(ERROR_PORT_DISCONNECTED);
    CASE_OF(ERROR_NO_ENDPOINTS);
    CASE_OF(ERROR_CANNOT_OPEN_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY);
    CASE_OF(ERROR_CANNOT_WRITE_PHONEBOOK);
    CASE_OF(ERROR_CORRUPT_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_STRING);
    CASE_OF(ERROR_KEY_NOT_FOUND);
    CASE_OF(ERROR_DISCONNECTION);
    CASE_OF(ERROR_REMOTE_DISCONNECTION);
    CASE_OF(ERROR_HARDWARE_FAILURE);
    CASE_OF(ERROR_USER_DISCONNECTION);
    CASE_OF(ERROR_INVALID_SIZE);
    CASE_OF(ERROR_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_CANNOT_PROJECT_CLIENT);
    CASE_OF(ERROR_UNKNOWN);
    CASE_OF(ERROR_WRONG_DEVICE_ATTACHED);
    CASE_OF(ERROR_BAD_STRING);
    CASE_OF(ERROR_REQUEST_TIMEOUT);
    CASE_OF(ERROR_CANNOT_GET_LANA);
    CASE_OF(ERROR_NETBIOS_ERROR);
    CASE_OF(ERROR_SERVER_OUT_OF_RESOURCES);
    CASE_OF(ERROR_NAME_EXISTS_ON_NET);
    CASE_OF(ERROR_SERVER_GENERAL_NET_FAILURE);
    CASE_OF(WARNING_MSG_ALIAS_NOT_ADDED);
    CASE_OF(ERROR_AUTH_INTERNAL);
    CASE_OF(ERROR_RESTRICTED_LOGON_HOURS);
    CASE_OF(ERROR_ACCT_DISABLED);
    CASE_OF(ERROR_PASSWD_EXPIRED);
    CASE_OF(ERROR_NO_DIALIN_PERMISSION);
    CASE_OF(ERROR_SERVER_NOT_RESPONDING);
    CASE_OF(ERROR_FROM_DEVICE);
    CASE_OF(ERROR_UNRECOGNIZED_RESPONSE);
    CASE_OF(ERROR_MACRO_NOT_FOUND);
    CASE_OF(ERROR_MACRO_NOT_DEFINED);
    CASE_OF(ERROR_MESSAGE_MACRO_NOT_FOUND);
    CASE_OF(ERROR_DEFAULTOFF_MACRO_NOT_FOUND);
    CASE_OF(ERROR_FILE_COULD_NOT_BE_OPENED);
    CASE_OF(ERROR_DEVICENAME_TOO_LONG);
    CASE_OF(ERROR_DEVICENAME_NOT_FOUND);
    CASE_OF(ERROR_NO_RESPONSES);
    CASE_OF(ERROR_NO_COMMAND_FOUND);
    CASE_OF(ERROR_WRONG_KEY_SPECIFIED);
    CASE_OF(ERROR_UNKNOWN_DEVICE_TYPE);
    CASE_OF(ERROR_ALLOCATING_MEMORY);
    CASE_OF(ERROR_PORT_NOT_CONFIGURED);
    CASE_OF(ERROR_DEVICE_NOT_READY);
    CASE_OF(ERROR_READING_INI_FILE);
    CASE_OF(ERROR_NO_CONNECTION);
    CASE_OF(ERROR_BAD_USAGE_IN_INI_FILE);
    CASE_OF(ERROR_READING_SECTIONNAME);
    CASE_OF(ERROR_READING_DEVICETYPE);
    CASE_OF(ERROR_READING_DEVICENAME);
    CASE_OF(ERROR_READING_USAGE);
    CASE_OF(ERROR_READING_MAXCONNECTBPS);
    CASE_OF(ERROR_READING_MAXCARRIERBPS);
    CASE_OF(ERROR_LINE_BUSY);
    CASE_OF(ERROR_VOICE_ANSWER);
    CASE_OF(ERROR_NO_ANSWER);
    CASE_OF(ERROR_NO_CARRIER);
    CASE_OF(ERROR_NO_DIALTONE);
    CASE_OF(ERROR_IN_COMMAND);
    CASE_OF(ERROR_WRITING_SECTIONNAME);
    CASE_OF(ERROR_WRITING_DEVICETYPE);
    CASE_OF(ERROR_WRITING_DEVICENAME);
    CASE_OF(ERROR_WRITING_MAXCONNECTBPS);
    CASE_OF(ERROR_WRITING_MAXCARRIERBPS);
    CASE_OF(ERROR_WRITING_USAGE);
    CASE_OF(ERROR_WRITING_DEFAULTOFF);
    CASE_OF(ERROR_READING_DEFAULTOFF);
    CASE_OF(ERROR_EMPTY_INI_FILE);
    CASE_OF(ERROR_AUTHENTICATION_FAILURE);
    CASE_OF(ERROR_PORT_OR_DEVICE);
    CASE_OF(ERROR_NOT_BINARY_MACRO);
    CASE_OF(ERROR_DCB_NOT_FOUND);
    CASE_OF(ERROR_STATE_MACHINES_NOT_STARTED);
    CASE_OF(ERROR_STATE_MACHINES_ALREADY_STARTED);
    CASE_OF(ERROR_PARTIAL_RESPONSE_LOOPING);
    CASE_OF(ERROR_UNKNOWN_RESPONSE_KEY);
    CASE_OF(ERROR_RECV_BUF_FULL);
    CASE_OF(ERROR_CMD_TOO_LONG);
    CASE_OF(ERROR_UNSUPPORTED_BPS);
    CASE_OF(ERROR_UNEXPECTED_RESPONSE);
    CASE_OF(ERROR_INTERACTIVE_MODE);
    CASE_OF(ERROR_BAD_CALLBACK_NUMBER);
    CASE_OF(ERROR_INVALID_AUTH_STATE);
    CASE_OF(ERROR_WRITING_INITBPS);
    CASE_OF(ERROR_X25_DIAGNOSTIC);
    CASE_OF(ERROR_ACCT_EXPIRED);
    CASE_OF(ERROR_CHANGING_PASSWORD);
    CASE_OF(ERROR_OVERRUN);
    CASE_OF(ERROR_RASMAN_CANNOT_INITIALIZE);
    CASE_OF(ERROR_BIPLEX_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_NO_ACTIVE_ISDN_LINES);
    CASE_OF(ERROR_NO_ISDN_CHANNELS_AVAILABLE);
    CASE_OF(ERROR_TOO_MANY_LINE_ERRORS);
    CASE_OF(ERROR_IP_CONFIGURATION);
    CASE_OF(ERROR_NO_IP_ADDRESSES);
    CASE_OF(ERROR_PPP_TIMEOUT);
    CASE_OF(ERROR_PPP_REMOTE_TERMINATED);
    CASE_OF(ERROR_PPP_NO_PROTOCOLS_CONFIGURED);
    CASE_OF(ERROR_PPP_NO_RESPONSE);
    CASE_OF(ERROR_PPP_INVALID_PACKET);
    CASE_OF(ERROR_PHONE_NUMBER_TOO_LONG);
    CASE_OF(ERROR_IPXCP_NO_DIALOUT_CONFIGURED);
    CASE_OF(ERROR_IPXCP_NO_DIALIN_CONFIGURED);
    CASE_OF(ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE);
    CASE_OF(ERROR_ACCESSING_TCPCFGDLL);
    CASE_OF(ERROR_NO_IP_RAS_ADAPTER);
    CASE_OF(ERROR_SLIP_REQUIRES_IP);
    CASE_OF(ERROR_PROJECTION_NOT_COMPLETE);
    CASE_OF(ERROR_PROTOCOL_NOT_CONFIGURED);
    CASE_OF(ERROR_PPP_NOT_CONVERGING);
    CASE_OF(ERROR_PPP_CP_REJECTED);
    CASE_OF(ERROR_PPP_LCP_TERMINATED);
    CASE_OF(ERROR_PPP_REQUIRED_ADDRESS_REJECTED);
    CASE_OF(ERROR_PPP_NCP_TERMINATED);
    CASE_OF(ERROR_PPP_LOOPBACK_DETECTED);
    CASE_OF(ERROR_PPP_NO_ADDRESS_ASSIGNED);
    CASE_OF(ERROR_CANNOT_USE_LOGON_CREDENTIALS);
    CASE_OF(ERROR_TAPI_CONFIGURATION);
    CASE_OF(ERROR_NO_LOCAL_ENCRYPTION);
    CASE_OF(ERROR_NO_REMOTE_ENCRYPTION);
    CASE_OF(ERROR_REMOTE_REQUIRES_ENCRYPTION);
    CASE_OF(ERROR_IPXCP_NET_NUMBER_CONFLICT);
    CASE_OF(ERROR_INVALID_SMM);
    CASE_OF(ERROR_SMM_UNINITIALIZED);
    CASE_OF(ERROR_NO_MAC_FOR_PORT);
    CASE_OF(ERROR_SMM_TIMEOUT);
    CASE_OF(ERROR_BAD_PHONE_NUMBER);
    CASE_OF(ERROR_WRONG_MODULE);
    CASE_OF(ERROR_INVALID_CALLBACK_NUMBER);
    CASE_OF(ERROR_SCRIPT_SYNTAX);
#endif // 0
    default:
        return "?";
    }
}


LPSTR
InternetMapStatus(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert INTERNET_STATUS_ value to symbolic name

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {
    CASE_OF(INTERNET_STATUS_RESOLVING_NAME);
    CASE_OF(INTERNET_STATUS_NAME_RESOLVED);
    CASE_OF(INTERNET_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(INTERNET_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(INTERNET_STATUS_SENDING_REQUEST);
    CASE_OF(INTERNET_STATUS_REQUEST_SENT);
    CASE_OF(INTERNET_STATUS_RECEIVING_RESPONSE);
    CASE_OF(INTERNET_STATUS_RESPONSE_RECEIVED);
    CASE_OF(INTERNET_STATUS_CTL_RESPONSE_RECEIVED);
    CASE_OF(INTERNET_STATUS_PREFETCH);
    CASE_OF(INTERNET_STATUS_CLOSING_CONNECTION);
    CASE_OF(INTERNET_STATUS_CONNECTION_CLOSED);
    CASE_OF(INTERNET_STATUS_HANDLE_CREATED);
    CASE_OF(INTERNET_STATUS_HANDLE_CLOSING);
    CASE_OF(INTERNET_STATUS_REQUEST_COMPLETE);
    CASE_OF(INTERNET_STATUS_REDIRECT);
    CASE_OF(INTERNET_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(INTERNET_STATUS_STATE_CHANGE);
    CASE_OF(INTERNET_STATUS_USER_INPUT_REQUIRED);
    }
    return "?";
}


LPSTR
InternetMapSSPIError(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert a SSL/PCT SSPI Error Code to a string.

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {

    CASE_OF(STATUS_SUCCESS);
    CASE_OF(SEC_E_INSUFFICIENT_MEMORY        );
    CASE_OF(SEC_E_INVALID_HANDLE             );
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION       );
    CASE_OF(SEC_E_TARGET_UNKNOWN             );
    CASE_OF(SEC_E_INTERNAL_ERROR             );
    CASE_OF(SEC_E_SECPKG_NOT_FOUND           );
    CASE_OF(SEC_E_NOT_OWNER                  );
    CASE_OF(SEC_E_CANNOT_INSTALL             );
    CASE_OF(SEC_E_INVALID_TOKEN              );
    CASE_OF(SEC_E_CANNOT_PACK                );
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED          );
    CASE_OF(SEC_E_NO_IMPERSONATION           );
    CASE_OF(SEC_E_LOGON_DENIED               );
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS        );
    CASE_OF(SEC_E_NO_CREDENTIALS             );
    CASE_OF(SEC_E_MESSAGE_ALTERED            );
    CASE_OF(SEC_E_OUT_OF_SEQUENCE            );
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE      );
    CASE_OF(SEC_I_LOCAL_LOGON                );
    CASE_OF(SEC_E_BAD_PKGID                  );
    CASE_OF(SEC_E_CONTEXT_EXPIRED            );
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE         );
//    CASE_OF(SEC_E_NO_SPM                     );
//    CASE_OF(SEC_E_NOT_SUPPORTED              );

    }
    return "?";
}




LPSTR
InternetMapOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert INTERNET_OPTION_ value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(INTERNET_OPTION_CALLBACK);
    CASE_OF(INTERNET_OPTION_CONNECT_TIMEOUT);
    CASE_OF(INTERNET_OPTION_CONNECT_RETRIES);
    CASE_OF(INTERNET_OPTION_CONNECT_BACKOFF);
    CASE_OF(INTERNET_OPTION_SEND_TIMEOUT);
    CASE_OF(INTERNET_OPTION_RECEIVE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_DATA_SEND_TIMEOUT);
    CASE_OF(INTERNET_OPTION_DATA_RECEIVE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_HANDLE_TYPE);
    CASE_OF(INTERNET_OPTION_CONTEXT_VALUE_OLD);
    CASE_OF(INTERNET_OPTION_NAME_RES_THREAD);
    CASE_OF(INTERNET_OPTION_READ_BUFFER_SIZE);
    CASE_OF(INTERNET_OPTION_WRITE_BUFFER_SIZE);
    CASE_OF(INTERNET_OPTION_GATEWAY_NAME);
    CASE_OF(INTERNET_OPTION_ASYNC_ID);
    CASE_OF(INTERNET_OPTION_ASYNC_PRIORITY);
    CASE_OF(INTERNET_OPTION_ASYNC_REQUEST_COUNT);
    CASE_OF(INTERNET_OPTION_MAXIMUM_WORKER_THREADS);
    CASE_OF(INTERNET_OPTION_ASYNC_QUEUE_DEPTH);
    CASE_OF(INTERNET_OPTION_WORKER_THREAD_TIMEOUT);
    CASE_OF(INTERNET_OPTION_PARENT_HANDLE);
    CASE_OF(INTERNET_OPTION_KEEP_CONNECTION);
    CASE_OF(INTERNET_OPTION_REQUEST_FLAGS);
    CASE_OF(INTERNET_OPTION_EXTENDED_ERROR);
    CASE_OF(INTERNET_OPTION_RECEIVE_ALL_MODE);
    CASE_OF(INTERNET_OPTION_OFFLINE_MODE);
    CASE_OF(INTERNET_OPTION_CACHE_STREAM_HANDLE);
    CASE_OF(INTERNET_OPTION_USERNAME);
    CASE_OF(INTERNET_OPTION_PASSWORD);
    CASE_OF(INTERNET_OPTION_ASYNC);
    CASE_OF(INTERNET_OPTION_SECURITY_FLAGS);
    CASE_OF(INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT);
    CASE_OF(INTERNET_OPTION_DATAFILE_NAME);
    CASE_OF(INTERNET_OPTION_URL);
    CASE_OF(INTERNET_OPTION_SECURITY_CERTIFICATE);
    CASE_OF(INTERNET_OPTION_SECURITY_KEY_BITNESS);
    CASE_OF(INTERNET_OPTION_REFRESH);
    CASE_OF(INTERNET_OPTION_PROXY);
    CASE_OF(INTERNET_OPTION_SETTINGS_CHANGED);
    CASE_OF(INTERNET_OPTION_VERSION);
    CASE_OF(INTERNET_OPTION_USER_AGENT);
    CASE_OF(INTERNET_OPTION_END_BROWSER_SESSION);
    CASE_OF(INTERNET_OPTION_PROXY_USERNAME);
    CASE_OF(INTERNET_OPTION_PROXY_PASSWORD);
    CASE_OF(INTERNET_OPTION_CONTEXT_VALUE);
    CASE_OF(INTERNET_OPTION_CONNECT_LIMIT);
    CASE_OF(INTERNET_OPTION_SECURITY_SELECT_CLIENT_CERT);
    CASE_OF(INTERNET_OPTION_POLICY);
    CASE_OF(INTERNET_OPTION_OFFLINE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_LINE_STATE);
    CASE_OF(INTERNET_OPTION_IDLE_STATE);
    CASE_OF(INTERNET_OPTION_OFFLINE_SEMANTICS);
    CASE_OF(INTERNET_OPTION_SECONDARY_CACHE_KEY);
    CASE_OF(INTERNET_OPTION_CALLBACK_FILTER);
    CASE_OF(INTERNET_OPTION_CONNECT_TIME);
    CASE_OF(INTERNET_OPTION_SEND_THROUGHPUT);
    CASE_OF(INTERNET_OPTION_REQUEST_PRIORITY);
    CASE_OF(INTERNET_OPTION_HTTP_VERSION);
    CASE_OF(INTERNET_OPTION_RESET_URLCACHE_SESSION);
    CASE_OF(INTERNET_OPTION_NET_SPEED);
    CASE_OF(INTERNET_OPTION_ERROR_MASK);
    CASE_OF(INTERNET_OPTION_FROM_CACHE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_BYPASS_EDITED_ENTRY);
    CASE_OF(INTERNET_OPTION_SECURITY_CONNECTION_INFO);
    CASE_OF(INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO);
    CASE_OF(INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY);
    }
    return "?";
}


LPSTR
InternetMapHttpOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert HTTP_QUERY_ option value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(HTTP_QUERY_MIME_VERSION);               // 0
    CASE_OF(HTTP_QUERY_CONTENT_TYPE);               // 1
    CASE_OF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING);  // 2
    CASE_OF(HTTP_QUERY_CONTENT_ID);                 // 3
    CASE_OF(HTTP_QUERY_CONTENT_DESCRIPTION);        // 4
    CASE_OF(HTTP_QUERY_CONTENT_LENGTH);             // 5
    CASE_OF(HTTP_QUERY_CONTENT_LANGUAGE);           // 6
    CASE_OF(HTTP_QUERY_ALLOW);                      // 7
    CASE_OF(HTTP_QUERY_PUBLIC);                     // 8
    CASE_OF(HTTP_QUERY_DATE);                       // 9
    CASE_OF(HTTP_QUERY_EXPIRES);                    // 10
    CASE_OF(HTTP_QUERY_LAST_MODIFIED);              // 11
    CASE_OF(HTTP_QUERY_MESSAGE_ID);                 // 12
    CASE_OF(HTTP_QUERY_URI);                        // 13
    CASE_OF(HTTP_QUERY_DERIVED_FROM);               // 14
    CASE_OF(HTTP_QUERY_COST);                       // 15
    CASE_OF(HTTP_QUERY_LINK);                       // 16
    CASE_OF(HTTP_QUERY_PRAGMA);                     // 17
    CASE_OF(HTTP_QUERY_VERSION);                    // 18
    CASE_OF(HTTP_QUERY_STATUS_CODE);                // 19
    CASE_OF(HTTP_QUERY_STATUS_TEXT);                // 20
    CASE_OF(HTTP_QUERY_RAW_HEADERS);                // 21
    CASE_OF(HTTP_QUERY_RAW_HEADERS_CRLF);           // 22
    CASE_OF(HTTP_QUERY_CONNECTION);                 // 23
    CASE_OF(HTTP_QUERY_ACCEPT);                     // 24
    CASE_OF(HTTP_QUERY_ACCEPT_CHARSET);             // 25
    CASE_OF(HTTP_QUERY_ACCEPT_ENCODING);            // 26
    CASE_OF(HTTP_QUERY_ACCEPT_LANGUAGE);            // 27
    CASE_OF(HTTP_QUERY_AUTHORIZATION);              // 28
    CASE_OF(HTTP_QUERY_CONTENT_ENCODING);           // 29
    CASE_OF(HTTP_QUERY_FORWARDED);                  // 30
    CASE_OF(HTTP_QUERY_FROM);                       // 31
    CASE_OF(HTTP_QUERY_IF_MODIFIED_SINCE);          // 32
    CASE_OF(HTTP_QUERY_LOCATION);                   // 33
    CASE_OF(HTTP_QUERY_ORIG_URI);                   // 34
    CASE_OF(HTTP_QUERY_REFERER);                    // 35
    CASE_OF(HTTP_QUERY_RETRY_AFTER);                // 36
    CASE_OF(HTTP_QUERY_SERVER);                     // 37
    CASE_OF(HTTP_QUERY_TITLE);                      // 38
    CASE_OF(HTTP_QUERY_USER_AGENT);                 // 39
    CASE_OF(HTTP_QUERY_WWW_AUTHENTICATE);           // 40
    CASE_OF(HTTP_QUERY_PROXY_AUTHENTICATE);         // 41
    CASE_OF(HTTP_QUERY_ACCEPT_RANGES);              // 42
    CASE_OF(HTTP_QUERY_SET_COOKIE);                 // 43
    CASE_OF(HTTP_QUERY_COOKIE);                     // 44
    CASE_OF(HTTP_QUERY_REQUEST_METHOD);             // 45
    CASE_OF(HTTP_QUERY_REFRESH);                    // 46
    CASE_OF(HTTP_QUERY_CONTENT_DISPOSITION);        // 47
    CASE_OF(HTTP_QUERY_AGE);                        // 48
    CASE_OF(HTTP_QUERY_CACHE_CONTROL);              // 49
    CASE_OF(HTTP_QUERY_CONTENT_BASE);               // 50
    CASE_OF(HTTP_QUERY_CONTENT_LOCATION);           // 51
    CASE_OF(HTTP_QUERY_CONTENT_MD5);                // 52
    CASE_OF(HTTP_QUERY_CONTENT_RANGE);              // 53
    CASE_OF(HTTP_QUERY_ETAG);                       // 54
    CASE_OF(HTTP_QUERY_HOST);                       // 55
    CASE_OF(HTTP_QUERY_IF_MATCH);                   // 56
    CASE_OF(HTTP_QUERY_IF_NONE_MATCH);              // 57
    CASE_OF(HTTP_QUERY_IF_RANGE);                   // 58
    CASE_OF(HTTP_QUERY_IF_UNMODIFIED_SINCE);        // 59
    CASE_OF(HTTP_QUERY_MAX_FORWARDS);               // 60
    CASE_OF(HTTP_QUERY_PROXY_AUTHORIZATION);        // 61
    CASE_OF(HTTP_QUERY_RANGE);                      // 62
    CASE_OF(HTTP_QUERY_TRANSFER_ENCODING);          // 63
    CASE_OF(HTTP_QUERY_UPGRADE);                    // 64
    CASE_OF(HTTP_QUERY_VARY);                       // 65
    CASE_OF(HTTP_QUERY_VIA);                        // 66
    CASE_OF(HTTP_QUERY_WARNING);                    // 67
    CASE_OF(HTTP_QUERY_EXPECT);                     // 68
    CASE_OF(HTTP_QUERY_PROXY_CONNECTION);           // 69
    CASE_OF(HTTP_QUERY_UNLESS_MODIFIED_SINCE);      // 70
    CASE_OF(HTTP_QUERY_ECHO_REQUEST);               // 71
    CASE_OF(HTTP_QUERY_ECHO_REPLY);                 // 72
    CASE_OF(HTTP_QUERY_ECHO_HEADERS);               // 73
    CASE_OF(HTTP_QUERY_ECHO_HEADERS_CRLF);          // 74
    CASE_OF(HTTP_QUERY_CUSTOM);                     // 65535
    }
    return "?";
}


LPSTR
InternetMapHttpState(
    IN DWORD State
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State) {
    CASE_OF(HttpRequestStateCreating);
    CASE_OF(HttpRequestStateOpen);
    CASE_OF(HttpRequestStateRequest);
    CASE_OF(HttpRequestStateResponse);
    CASE_OF(HttpRequestStateObjectData);
    CASE_OF(HttpRequestStateError);
    CASE_OF(HttpRequestStateClosing);
    CASE_OF(HttpRequestStateReopen);
    }
    return "?";
}

LPSTR
InternetMapHttpStateFlag(
    IN DWORD Flag
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ flag to symbolic name

Arguments:

    Flag    - to map

Return Value:

    LPSTR

--*/

{
    switch (Flag) {
    case HTTPREQ_STATE_ANYTHING_OK:
        return "ANYTHING";

    case HTTPREQ_STATE_CLOSE_OK:
        return "CLOSE";

    case HTTPREQ_STATE_ADD_OK:
        return "ADD";

    case HTTPREQ_STATE_SEND_OK:
        return "SEND";

    case HTTPREQ_STATE_READ_OK:
        return "READ";

    case HTTPREQ_STATE_QUERY_REQUEST_OK:
        return "QUERY_REQUEST";

    case HTTPREQ_STATE_QUERY_RESPONSE_OK:
        return "QUERY_RESPONSE";

    case HTTPREQ_STATE_REUSE_OK:
        return "REUSE";
    }
    return "?";
}


LPSTR
InternetMapAuthScheme(
    IN DWORD Scheme
    )

/*++

Routine Description:

    Convert AUTHCTX::SCHEME_ to symbolic name

Arguments:

    Scheme   - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {

        CASE_OF(AUTHCTX::SCHEME_BASIC);
        CASE_OF(AUTHCTX::SCHEME_DIGEST);
        CASE_OF(AUTHCTX::SCHEME_NTLM);
        CASE_OF(AUTHCTX::SCHEME_MSN);
        CASE_OF(AUTHCTX::SCHEME_DPA);
        CASE_OF(AUTHCTX::SCHEME_KERBEROS);
        CASE_OF(AUTHCTX::SCHEME_NEGOTIATE);
        CASE_OF(AUTHCTX::SCHEME_UNKNOWN);
    }
    return "?";
}

LPSTR
InternetMapAuthState(
    IN DWORD State
    )

/*++

Routine Description:

    Convert AUTHSTATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State) {
    CASE_OF(AUTHSTATE_NONE);
    CASE_OF(AUTHSTATE_NEGOTIATE);
    CASE_OF(AUTHSTATE_CHALLENGE);
    CASE_OF(AUTHSTATE_NEEDTUNNEL);
    }
    return "?";
}


LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    )

/*++

Routine Description:

    Convert AR_TYPE to symbolic name

Arguments:

    Type    - Async request type

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Type) {
    CASE_OF(AR_INTERNET_CONNECT);
    CASE_OF(AR_INTERNET_OPEN_URL);
    CASE_OF(AR_INTERNET_READ_FILE);
    CASE_OF(AR_INTERNET_WRITE_FILE);
    CASE_OF(AR_INTERNET_QUERY_DATA_AVAILABLE);
    CASE_OF(AR_INTERNET_FIND_NEXT_FILE);
    CASE_OF(AR_FTP_FIND_FIRST_FILE);
    CASE_OF(AR_FTP_GET_FILE);
    CASE_OF(AR_FTP_PUT_FILE);
    CASE_OF(AR_FTP_DELETE_FILE);
    CASE_OF(AR_FTP_RENAME_FILE);
    CASE_OF(AR_FTP_OPEN_FILE);
    CASE_OF(AR_FTP_CREATE_DIRECTORY);
    CASE_OF(AR_FTP_REMOVE_DIRECTORY);
    CASE_OF(AR_FTP_SET_CURRENT_DIRECTORY);
    CASE_OF(AR_FTP_GET_CURRENT_DIRECTORY);
    CASE_OF(AR_GOPHER_FIND_FIRST_FILE);
    CASE_OF(AR_GOPHER_OPEN_FILE);
    CASE_OF(AR_GOPHER_GET_ATTRIBUTE);
    CASE_OF(AR_HTTP_SEND_REQUEST);
    CASE_OF(AR_HTTP_BEGIN_SEND_REQUEST);
    CASE_OF(AR_HTTP_END_SEND_REQUEST);
    CASE_OF(AR_READ_PREFETCH);
    CASE_OF(AR_SYNC_EVENT);
    CASE_OF(AR_TIMER_EVENT);
    CASE_OF(AR_HTTP_REQUEST1);
    CASE_OF(AR_FILE_IO);
    CASE_OF(AR_INTERNET_READ_FILE_EX);
    }
    return "?";
}


LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    )

/*++

Routine Description:

    Map handle type to symbolic name

Arguments:

    HandleType  - from handle object

Return Value:

    LPSTR

--*/

{
    switch (HandleType) {
    CASE_OF(TypeGenericHandle);
    CASE_OF(TypeInternetHandle);
    CASE_OF(TypeFtpConnectHandle);
    CASE_OF(TypeFtpFindHandle);
    CASE_OF(TypeFtpFindHandleHtml);
    CASE_OF(TypeFtpFileHandle);
    CASE_OF(TypeFtpFileHandleHtml);
    CASE_OF(TypeGopherConnectHandle);
    CASE_OF(TypeGopherFindHandle);
    CASE_OF(TypeGopherFindHandleHtml);
    CASE_OF(TypeGopherFileHandle);
    CASE_OF(TypeGopherFileHandleHtml);
    CASE_OF(TypeHttpConnectHandle);
    CASE_OF(TypeHttpRequestHandle);
    CASE_OF(TypeFileRequestHandle);
    CASE_OF(TypeWildHandle);
    }
    return "?";
}


LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps INTERNET_SCHEME_ to symbolic name

Arguments:

    Scheme  - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {
    CASE_OF(INTERNET_SCHEME_UNKNOWN);
    CASE_OF(INTERNET_SCHEME_DEFAULT);
    CASE_OF(INTERNET_SCHEME_FTP);
    CASE_OF(INTERNET_SCHEME_GOPHER);
    CASE_OF(INTERNET_SCHEME_HTTP);
    CASE_OF(INTERNET_SCHEME_HTTPS);
    }
    return "?";
}


LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    )

/*++

Routine Description:

    Maps INTERNET_OPEN_TYPE_ to symbolic name

Arguments:

    OpenType    - to map

Return Value:

    LPSTR

--*/

{
    switch (OpenType) {
    CASE_OF(INTERNET_OPEN_TYPE_DIRECT);
    CASE_OF(INTERNET_OPEN_TYPE_PROXY);
    CASE_OF(INTERNET_OPEN_TYPE_PRECONFIG);
    }
    return "?";
}


LPSTR
InternetMapService(
    IN DWORD Service
    )

/*++

Routine Description:

    Maps INTERNET_SERVICE_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (Service) {
#if 0
    CASE_OF(INTERNET_SERVICE_URL);
#endif
    CASE_OF(INTERNET_SERVICE_FTP);
    CASE_OF(INTERNET_SERVICE_GOPHER);
    CASE_OF(INTERNET_SERVICE_HTTP);
    }
    return "?";
}


LPSTR
InternetMapWinsockCallbackType(
    IN DWORD CallbackType
    )

/*++

Routine Description:

    Maps WINSOCK_CALLBACK_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (CallbackType) {
    CASE_OF(WINSOCK_CALLBACK_CONNECT);
    CASE_OF(WINSOCK_CALLBACK_GETHOSTBYADDR);
    CASE_OF(WINSOCK_CALLBACK_GETHOSTBYNAME);
    CASE_OF(WINSOCK_CALLBACK_LISTEN);
    CASE_OF(WINSOCK_CALLBACK_RECVFROM);
    CASE_OF(WINSOCK_CALLBACK_SENDTO);
    }
    return "?";
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    )
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(lpThreadInfo != NULL);

    if (!lpThreadInfo) {
        return NULL;
    }

    LPINTERNET_DEBUG_RECORD lpRecord;

    lpRecord = lpThreadInfo->Stack;

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if ((InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        && lpRecord) {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : lpRecord->LastTime);

            Buffer += rsprintf(Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                lpRecord->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, "%08x", lpThreadInfo->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo);
        }

        //
        // ARB address
        //

        //if (InternetDebugControlFlags & DBG_ARB_ADDR) {
        //    Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo->lpArb);
        //}

        //
        // FIBER address
        //

        //if (InternetDebugControlFlags & DBG_FIBER_INFO) {
        //
        //    LPVOID p;
        //
        //    p = (lpThreadInfo->lpArb != NULL)
        //      ? lpThreadInfo->lpArb->Header.lpFiber
        //      : NULL
        //      ;
        //    Buffer += rsprintf(Buffer, ":%08x", p);
        //}

        //
        // async ID
        //

        if (InternetDebugControlFlags & DBG_ASYNC_ID) {
            if (lpThreadInfo->IsAsyncWorkerThread) {
                Buffer += rsprintf(Buffer, ":<--->");
            } else if (lpThreadInfo->InCallback) {

                //
                // async worker thread calling back into the app; any WinInet
                // API requests during this time treated as though from the
                // app context
                //

                Buffer += rsprintf(Buffer, ":<c-b>");
            }
            else if (lpThreadInfo->IsAutoProxyProxyThread)
            {

                //
                // this is a specialized Auto-Proxy thread
                //

                Buffer += rsprintf(Buffer, ":<a-p>");
            }
            else
            {

                //
                // this is an app thread
                //

                Buffer += rsprintf(Buffer, ":<app>");
            }
        }

        //
        // request handle
        //

        if (InternetDebugControlFlags & DBG_REQUEST_HANDLE) {
            Buffer += rsprintf(Buffer, ":%6X", lpThreadInfo->hObject);
        }

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, "%03d ", lpThreadInfo->CallDepth);
    }

    for (int i = 0; i < lpThreadInfo->IndentIncrement; ++i) {
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (lpRecord != NULL) {
        if (!(lpRecord->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, "%s(): ", lpRecord->Function);
        }
    }

    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if (p = strrchr(Filespec, '\\')) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}

#if defined(i386)


VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // ENABLE_DEBUG

INTERNETAPI_(BOOL) InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\perfdiag.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfdiag.cxx

Abstract:

    Performance diagnostics

    Contents:
        WininetPerfLog
        PerfSleep
        PerfSelect
        PerfWaitForSingleObject
        (CPerfDiag::get_next_record)
        CPerfDiag::CPerfDiag
        CPerfDiag::~CPerfDiag
        CPerfDiag::Log(DWORD, DWORD)
        CPerfDiag::Log(DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Log(DWORD, DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Dump
        (map_perf_event)
        (map_callback_status)
        (map_async_request)
        (map_thread_pri)
        (map_length)

Author:

    Richard L Firth (rfirth) 24-Jan-1997

Revision History:

    24-Jan-1997 rfirth
        Created

--*/

#include <wininetp.h>

#if defined(USE_PERF_DIAG)

#include <perfdiag.hxx>

//
// global data
//

GLOBAL CPerfDiag * GlobalPerfDiag = NULL;
GLOBAL BOOL GlobalDumpPerfToFile = TRUE;

//
// private prototypes
//

PRIVATE LPSTR map_perf_event(DWORD dwEvent);
PRIVATE LPSTR map_callback_status(DWORD dwStatus);
PRIVATE LPSTR map_async_request(DWORD dwRequest);
PRIVATE LPSTR map_thread_pri(DWORD dwPriority);
PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf);

//
// APIs
//

INTERNETAPI_(void) WininetPerfLog(
    IN DWORD dwEvent,
    IN DWORD dwInfo1,
    IN DWORD dwInfo2,
    IN HINTERNET hInternet
    ) {
    if (!GlobalPerfDiag) {
        GlobalPerfDiag = new CPerfDiag;
    }
    if (GlobalPerfDiag) {
        GlobalPerfDiag->Log(dwEvent, dwInfo1, dwInfo2, GetCurrentThreadId(), hInternet);
    }
}

//
// functions
//

VOID PerfSleep(DWORD dwMilliseconds) {
    PERF_LOG(PE_YIELD_SLEEP_START);
    Sleep(dwMilliseconds);
    PERF_LOG(PE_YIELD_SLEEP_END);
}

int PerfSelect(int nfds,	
    fd_set FAR * readfds,	
    fd_set FAR * writefds,	
    fd_set FAR * exceptfds,	
    const struct timeval FAR * timeout 	
    ) {
    PERF_LOG(PE_YIELD_SELECT_START);

    int n = _I_select(nfds, readfds, writefds, exceptfds, timeout);

    PERF_LOG(PE_YIELD_SELECT_END);
    return n;
}

DWORD PerfWaitForSingleObject(
    HANDLE hObject,
    DWORD dwTimeout
    ) {
    PERF_LOG(PE_YIELD_OBJECT_WAIT_START);

    DWORD result = WaitForSingleObject(hObject, dwTimeout);

    PERF_LOG(PE_YIELD_OBJECT_WAIT_END);

    return result;
}

//
// private methods
//

LPPERF_INFO CPerfDiag::get_next_record(VOID) {

    if (!m_lpbPerfBuffer || m_bFull) {
        return NULL;
    }

    LPBYTE lpbCurrent;
    LPBYTE lpbNext;
    LPBYTE result;

    do {
        lpbCurrent = m_lpbNext;
        lpbNext = lpbCurrent + sizeof(PERF_INFO);
        result = (LPBYTE)InterlockedExchangePointer((PVOID*)&m_lpbNext, lpbNext);
    } while ((result != (LPBYTE)lpbCurrent) && (lpbCurrent < m_lpbEnd));
    if (lpbCurrent >= m_lpbEnd) {
        m_bFull = TRUE;
        OutputDebugString("*** Wininet performance log is full!\n");
        lpbCurrent = NULL;
    }
    return (LPPERF_INFO)lpbCurrent;
}

//
// public methods
//

CPerfDiag::CPerfDiag() {
    m_lpbPerfBuffer = NULL;
    m_dwPerfBufferLen = 0;
    m_lpbEnd = NULL;
    m_lpbNext = NULL;
    m_bFull = FALSE;
    m_bStarted = FALSE;
    m_bStartFinished = FALSE;
    m_liStartTime.QuadPart = 0i64;
    perf_start();
}

CPerfDiag::~CPerfDiag() {
    free_perf_buffer();
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo) {

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo) {
        Log(dwEvent, dwInfo, 0, lpThreadInfo->ThreadId, lpThreadInfo->hObject);
    }
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwThreadId, HINTERNET hInternet) {
    Log(dwEvent, dwInfo, 0, dwThreadId, hInternet);
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwInfo2, DWORD dwThreadId, HINTERNET hInternet) {

    //if (!m_bStarted) {
    //    perf_start();
    //}

    LPPERF_INFO lpInfo = get_next_record();

    if (!lpInfo) {
        return;
    }

    lpInfo->hInternet = hInternet;
    lpInfo->dwThreadId = dwThreadId;
    lpInfo->dwThreadPriority = GetThreadPriority(GetCurrentThread());
    lpInfo->dwEvent = dwEvent;
    lpInfo->dwInfo = dwInfo;
    lpInfo->dwInfo2 = dwInfo2;
    get_time(lpInfo);
}

VOID CPerfDiag::Dump(VOID) {

    HANDLE hFile = INVALID_HANDLE_VALUE;
    static const char PerfFileName[] = "WININET.PRF";

    if (GlobalDumpPerfToFile) {
        hFile = CreateFile((LPCSTR)PerfFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           INVALID_HANDLE_VALUE
                           );
        if (hFile == INVALID_HANDLE_VALUE) {
            OutputDebugString("failed to create perf file ");
            OutputDebugString((LPCSTR)PerfFileName);
            OutputDebugString("\n");
            GlobalDumpPerfToFile = FALSE;
        }
    }

    LARGE_INTEGER liFrequency;
    LONGLONG div1;
    LONGLONG div2;

    QueryPerformanceFrequency(&liFrequency);
    div1 = liFrequency.QuadPart;
    div2 = div1 / 1000000;

    LPPERF_INFO lpInfo;
    int record = 1;

    for (lpInfo = (LPPERF_INFO)m_lpbPerfBuffer; lpInfo != (LPPERF_INFO)m_lpbNext; ++lpInfo) {

        char buf[1024];
        LONGLONG ticks;
        DWORD microseconds;
        DWORD seconds;
        DWORD minutes;

        ticks = lpInfo->liTime.QuadPart - m_liStartTime.QuadPart;
        seconds = (DWORD)(ticks / div1);
        microseconds = (DWORD)((ticks % div1) / div2);

        //
        // don't understand why I have to do this? Win95 only (you could have guessed)
        // rounding error?
        //

        while (microseconds >= 1000000) {
            microseconds -= 1000000;
            ++seconds;
        }
        minutes = seconds / 60;
        seconds = seconds % 60;

        char lenbuf[32];
        char lenbuf2[32];

        int nChars = wsprintf(buf,
                              "%5d: Delta=%.2d:%.2d.%.6d TID=%08x Pri=%-8s hReq=%06x Info=%08x %-24s %-22s %s\r\n",
                              record,
                              minutes,
                              seconds,
                              microseconds,
                              lpInfo->dwThreadId,
                              map_thread_pri(lpInfo->dwThreadPriority),
                              lpInfo->hInternet,
                              lpInfo->dwInfo,
                              map_perf_event(lpInfo->dwEvent),
                              ((lpInfo->dwEvent == PE_APP_CALLBACK_START)
                              || (lpInfo->dwEvent == PE_APP_CALLBACK_END))
                                 ? map_callback_status(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_WORKER_REQUEST_START)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_START)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_QUEUED))
                                 ? map_async_request(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_SEND_END)
                              || (lpInfo->dwEvent == PE_RECEIVE_END))
                                 ? map_length(lpInfo->dwInfo2, lenbuf)
                              : (((lpInfo->dwEvent == PE_ENTER_PATH)
                              || (lpInfo->dwEvent == PE_LEAVE_PATH)
                              || (lpInfo->dwEvent == PE_TRACE_PATH))
                                 ? (LPSTR)lpInfo->dwInfo2
                                 : ""))),
                              (((lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END))
                              && ((lpInfo->dwInfo == AR_INTERNET_READ_FILE)
                              || (lpInfo->dwInfo == AR_INTERNET_QUERY_DATA_AVAILABLE)))
                                 ? map_length(lpInfo->dwInfo2, lenbuf2)
                                 : ""
                             );
        if (GlobalDumpPerfToFile) {

            DWORD nWritten;

            WriteFile(hFile, buf, nChars, &nWritten, NULL);
        } else {
            OutputDebugString(buf);
        }
        ++record;
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


PRIVATE LPSTR map_perf_event(DWORD dwEvent) {
    switch (dwEvent) {
    case PE_START:                      return "START";
    case PE_END:                        return "END";
    case PE_CLIENT_REQUEST_START:       return "CLIENT_REQUEST_START";
    case PE_CLIENT_REQUEST_END:         return "CLIENT_REQUEST_END";
    case PE_CLIENT_REQUEST_QUEUED:      return "CLIENT_REQUEST_QUEUED";
    case PE_WORKER_REQUEST_START:       return "WORKER_REQUEST_START";
    case PE_WORKER_REQUEST_END:         return "WORKER_REQUEST_END";
    case PE_APP_CALLBACK_START:         return "APP_CALLBACK_START";
    case PE_APP_CALLBACK_END:           return "APP_CALLBACK_END";
    case PE_NAMERES_START:              return "NAMERES_START";
    case PE_NAMERES_END:                return "NAMERES_END";
    case PE_CONNECT_START:              return "CONNECT_START";
    case PE_CONNECT_END:                return "CONNECT_END";
    case PE_SEND_START:                 return "SEND_START";
    case PE_SEND_END:                   return "SEND_END";
    case PE_RECEIVE_START:              return "RECEIVE_START";
    case PE_RECEIVE_END:                return "RECEIVE_END";
    case PE_PEEK_RECEIVE_START:         return "PEEK_RECEIVE_START";
    case PE_PEEK_RECEIVE_END:           return "PEEK_RECEIVE_END";
    case PE_SOCKET_CLOSE_START:         return "SOCKET_CLOSE_START";
    case PE_SOCKET_CLOSE_END:           return "SOCKET_CLOSE_END";
    case PE_ACQUIRE_KEEP_ALIVE:         return "ACQUIRE_KEEP_ALIVE";
    case PE_RELEASE_KEEP_ALIVE:         return "RELEASE_KEEP_ALIVE";
    case PE_SOCKET_ERROR:               return "SOCKET_ERROR";
    case PE_CACHE_READ_CHECK_START:     return "CACHE_READ_CHECK_START";
    case PE_CACHE_READ_CHECK_END:       return "CACHE_READ_CHECK_END";
    case PE_CACHE_WRITE_CHECK_START:    return "CACHE_WRITE_CHECK_START";
    case PE_CACHE_WRITE_CHECK_END:      return "CACHE_WRITE_CHECK_END";
    case PE_CACHE_RETRIEVE_START:       return "CACHE_RETRIEVE_START";
    case PE_CACHE_RETRIEVE_END:         return "CACHE_RETRIEVE_END";
    case PE_CACHE_READ_START:           return "CACHE_READ_START";
    case PE_CACHE_READ_END:             return "CACHE_READ_END";
    case PE_CACHE_WRITE_START:          return "CACHE_WRITE_START";
    case PE_CACHE_WRITE_END:            return "CACHE_WRITE_END";
    case PE_CACHE_CREATE_FILE_START:    return "CACHE_CREATE_FILE_START";
    case PE_CACHE_CREATE_FILE_END:      return "CACHE_CREATE_FILE_END";
    case PE_CACHE_CLOSE_FILE_START:     return "CACHE_CLOSE_FILE_START";
    case PE_CACHE_CLOSE_FILE_END:       return "CACHE_CLOSE_FILE_END";
    case PE_CACHE_EXPIRY_CHECK_START:   return "CACHE_EXPIRY_CHECK_START";
    case PE_CACHE_EXPIRY_CHECK_END:     return "CACHE_EXPIRY_CHECK_END";
    case PE_YIELD_SELECT_START:         return "YIELD_SELECT_START";
    case PE_YIELD_SELECT_END:           return "YIELD_SELECT_END";
    case PE_YIELD_OBJECT_WAIT_START:    return "YIELD_OBJECT_WAIT_START";
    case PE_YIELD_OBJECT_WAIT_END:      return "YIELD_OBJECT_WAIT_END";
    case PE_YIELD_SLEEP_START:          return "YIELD_SLEEP_START";
    case PE_YIELD_SLEEP_END:            return "YIELD_SLEEP_END";
    case PE_TRACE:                      return "TRACE";
    case PE_ENTER_PATH:                 return "ENTER_PATH";
    case PE_LEAVE_PATH:                 return "LEAVE_PATH";
    case PE_TRACE_PATH:                 return "TRACE_PATH";
    }
    return "?";
}

PRIVATE LPSTR map_callback_status(DWORD dwStatus) {
    switch (dwStatus) {
    case INTERNET_STATUS_RESOLVING_NAME:        return "RESOLVING_NAME";
    case INTERNET_STATUS_NAME_RESOLVED:         return "NAME_RESOLVED";
    case INTERNET_STATUS_CONNECTING_TO_SERVER:  return "CONNECTING_TO_SERVER";
    case INTERNET_STATUS_CONNECTED_TO_SERVER:   return "CONNECTED_TO_SERVER";
    case INTERNET_STATUS_SENDING_REQUEST:       return "SENDING_REQUEST";
    case INTERNET_STATUS_REQUEST_SENT:          return "REQUEST_SENT";
    case INTERNET_STATUS_RECEIVING_RESPONSE:    return "RECEIVING_RESPONSE";
    case INTERNET_STATUS_RESPONSE_RECEIVED:     return "RESPONSE_RECEIVED";
    case INTERNET_STATUS_CTL_RESPONSE_RECEIVED: return "CTL_RESPONSE_RECEIVED";
    case INTERNET_STATUS_PREFETCH:              return "PREFETCH";
    case INTERNET_STATUS_CLOSING_CONNECTION:    return "CLOSING_CONNECTION";
    case INTERNET_STATUS_CONNECTION_CLOSED:     return "CONNECTION_CLOSED";
    case INTERNET_STATUS_HANDLE_CREATED:        return "HANDLE_CREATED";
    case INTERNET_STATUS_HANDLE_CLOSING:        return "HANDLE_CLOSING";
    case INTERNET_STATUS_REQUEST_COMPLETE:      return "REQUEST_COMPLETE";
    case INTERNET_STATUS_REDIRECT:              return "REDIRECT";
    case INTERNET_STATUS_STATE_CHANGE:          return "STATE_CHANGE";
    }
    return "?";
}

PRIVATE LPSTR map_async_request(DWORD dwRequest) {
    switch (dwRequest) {
    case AR_INTERNET_CONNECT:               return "InternetConnect";
    case AR_INTERNET_OPEN_URL:              return "InternetOpenUrl";
    case AR_INTERNET_READ_FILE:             return "InternetReadFile";
    case AR_INTERNET_WRITE_FILE:            return "InternetWriteFile";
    case AR_INTERNET_QUERY_DATA_AVAILABLE:  return "InternetQueryDataAvailable";
    case AR_INTERNET_FIND_NEXT_FILE:        return "InternetFindNextFile";
    case AR_FTP_FIND_FIRST_FILE:            return "FtpFindFirstFile";
    case AR_FTP_GET_FILE:                   return "FtpGetFile";
    case AR_FTP_PUT_FILE:                   return "FtpPutFile";
    case AR_FTP_DELETE_FILE:                return "FtpDeleteFile";
    case AR_FTP_RENAME_FILE:                return "FtpRenameFile";
    case AR_FTP_OPEN_FILE:                  return "FtpOpenFile";
    case AR_FTP_CREATE_DIRECTORY:           return "FtpCreateDirectory";
    case AR_FTP_REMOVE_DIRECTORY:           return "FtpRemoveDirectory";
    case AR_FTP_SET_CURRENT_DIRECTORY:      return "FtpSetCurrentDirectory";
    case AR_FTP_GET_CURRENT_DIRECTORY:      return "FtpGetCurrentDirectory";
    case AR_GOPHER_FIND_FIRST_FILE:         return "GopherFindFirstFile";
    case AR_GOPHER_OPEN_FILE:               return "GopherOpenFile";
    case AR_GOPHER_GET_ATTRIBUTE:           return "GopherGetAttribute";
    case AR_HTTP_SEND_REQUEST:              return "HttpSendRequest";
    case AR_READ_PREFETCH:                  return "READ_PREFETCH";
    case AR_SYNC_EVENT:                     return "SYNC_EVENT";
    case AR_TIMER_EVENT:                    return "TIMER_EVENT";
    }
    return "?";
}

PRIVATE LPSTR map_thread_pri(DWORD dwPriority) {
    switch (dwPriority) {
    case THREAD_PRIORITY_ABOVE_NORMAL:
        return "ABOVE";

    case THREAD_PRIORITY_BELOW_NORMAL:
        return "BELOW";

    case THREAD_PRIORITY_HIGHEST:
        return "HIGHEST";

    case THREAD_PRIORITY_IDLE:
        return "IDLE";

    case THREAD_PRIORITY_LOWEST:
        return "LOWEST";

    case THREAD_PRIORITY_NORMAL:
        return "NORMAL";

    case THREAD_PRIORITY_TIME_CRITICAL:
        return "TIMECRIT";
    }
    return "?";
}

PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf) {
    wsprintf(lpBuf, "%d", dwLength);
    return lpBuf;
}

#endif // defined(USE_PERF_DIAG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\blocklst.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    blocklst.cxx

Abstract:

    Contains WinInet async support to allow blocking of unknown threads, on auto-proxy events.

    Contents:
        BlockThreadOnEvent
        SignalThreadOnEvent
        AcquireBlockedRequestQueue
        ReleaseBlockedRequestQueue
        (DestroyBlockedThreadEvent)


Author:

    Arthur L Bierer (arthurbi) 15-Feb-1998

Environment:

    Win32 user-mode DLL

Revision History:

    15-Feb-1998 arthurbi
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private data
//

//
// BlockedRequestQueue - when threads need to block on an event they get
// placed in here until their event is signaled. This is needed so threads
// can block on internally kept events without having to be tied
// to keeping track of event handles.
//
// Blocked threads must not be also waiting for a socket to become unblocked
//

GLOBAL SERIALIZED_LIST BlockedRequestQueue = {0};

//
// ARB - information common to all asynchronous blocked events
//

typedef struct {

    //
    // List - requests are queued on doubly-linked list. N.B. Code that deals
    // in ARBs implicitly assumes that List is at offset zero in the ARB. Move
    // this and pick up the pieces...
    //

    LIST_ENTRY List;

    //
    // hEvent - handle to Event that we are blocked on.
    //

    HANDLE      hEvent;

    //
    // dwBlockedOnEvent - contains the event this ARB may be blocked
    // on.  This allows a FIBER to block itself on an Internally kept
    // event. When the event is signalled, it will wakeup, and moved
    // to the Active Pool of fibers.
    //
    // A ZERO value means there is NO event that is being blocked on.
    //

    DWORD_PTR   dwBlockedOnEvent;

    //
    // dwBlockedOnEventReturnCode - contains error code returned from
    //  fiber or main thread that is doing the unblocking.
    //

    DWORD       dwBlockedOnEventReturnCode;

#if INET_DEBUG

    //
    // dwSignature - in the debug version, we maintain a signature in the ARB
    // for sanity checking
    //

    DWORD dwSignature;

#endif // INET_DEBUG

} ARB, * LPARB;

//
// functions...
//

PRIVATE
VOID
DestroyBlockedThreadEvent(
    IN LPARB lpArb
    )

/*++

Routine Description:

    Removes lpArb from the blocked request queue if its still there, and
    destroys it

Arguments:

    lpArb   - pointer to AR_SYNC_EVENT ARB

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "DestroyBlockedThreadEvent",
                 "%#x",
                 lpArb
                 ));

    AcquireBlockedRequestQueue();

    if (lpArb->hEvent != NULL) {
        CloseHandle(lpArb->hEvent);
    }

    if (IsOnSerializedList(&BlockedRequestQueue, &lpArb->List)) {
        RemoveFromSerializedList(&BlockedRequestQueue, &lpArb->List);
    }

    ReleaseBlockedRequestQueue();

    DEBUG_LEAVE(0);
}


DWORD
BlockThreadOnEvent(
    IN DWORD_PTR dwEventId,
    IN DWORD dwTimeout,
    IN BOOL bReleaseLock
    )

/*++

Routine Description:

    Waits for an async event if called in the context of a fiber, else waits for
    an event if called in the context of a sync request

Arguments:

    dwEventId       - event id to wait on

    dwTimeout       - amount of time to wait

    bReleaseLock    - TRUE if we need to release the blocked request queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The request/wait completed successfully

        Failure - ERROR_INTERNET_TIMEOUT
                    The request timed out

                  ERROR_INTERNET_INTERNAL_ERROR
                    We couldn't get the INTERNET_THREAD_INFO

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockThreadOnEvent",
                 "%#x, %d, %B",
                 dwEventId,
                 dwTimeout,
                 bReleaseLock
                 ));

    DWORD error;
    ARB Arb;

    ZeroMemory(&Arb, sizeof(Arb));

    //
    // set up the remaining fields in the ARB - initialize the list pointer,
    // set the priority (to default), and the event id
    //

    Arb.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Arb.hEvent == NULL) {
        error = GetLastError();

        // IE6 BUG #25117
        // if we acquired the blocked request queue before calling this function
        // then we need to release it
        //

        if (bReleaseLock) {
            ReleaseBlockedRequestQueue();
        }

        goto quit;
    }
    Arb.dwBlockedOnEvent = dwEventId;

    //
    // add the request to the blocked request queue
    //

    InsertAtTailOfSerializedList(&BlockedRequestQueue, &Arb.List);

    //
    // if we acquired the blocked request queue before calling this function
    // then we need to release it
    //

    if (bReleaseLock) {
        ReleaseBlockedRequestQueue();
    }

    //
    // now wait here for the event to become signalled
    //

    error = PERF_WaitForSingleObject(Arb.hEvent,
                                     dwTimeout
                                     );

    //
    // if we timed out then we will remove and destroy the ARB, else the thread
    // which signalled the request will have done so
    //

    if (error == WAIT_TIMEOUT) {
        error = ERROR_INTERNET_TIMEOUT;
    } else {
        error = Arb.dwBlockedOnEventReturnCode;
    }

quit:

    //
    // remove the request from the blocked request queue and destroy it
    //

    DestroyBlockedThreadEvent(&Arb);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
SignalThreadOnEvent(
    IN DWORD_PTR dwEventId,
    IN DWORD dwNumberOfWaiters,
    IN DWORD dwReturnCode
    )

/*++

Routine Description:

    Unblocks a number of fibers that may be waiting for an event to be signalled.
    When the fibers unblock they will be rescheduled to the Active Request Queue.
    The 'event' is reset automatically back to unsignalled state.

    If called outside of the worker thread, this function also handles
    interupting the blocked worked thread so it can resume requests.

Arguments:

    dwEventId           - Event ID to wake up on.

    dwNumberOfWaiters   - number of waiters to unblock. Choose a large number
                          to mean 'all'

    dwReturnCode        - Upon waking up fibers, their blocked called will return
                          with this error code.

Return Value:

    DWORD
        Number of waiters unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "SignalThreadOnEvent",
                 "%#x, %d, %d (%s)",
                 dwEventId,
                 dwNumberOfWaiters,
                 dwReturnCode,
                 InternetMapError(dwReturnCode)
                 ));

    INET_ASSERT(dwNumberOfWaiters > 0);

    DWORD dwUnblocked = 0;

    AcquireBlockedRequestQueue();

    LPARB lpArb = (LPARB)HeadOfSerializedList(&BlockedRequestQueue);
    LPARB lpArbPrevious = (LPARB)SlSelf(&BlockedRequestQueue);

    while (lpArb != (LPARB)SlSelf(&BlockedRequestQueue)) {
        if (lpArb->dwBlockedOnEvent == dwEventId) {

            lpArb->dwBlockedOnEventReturnCode = dwReturnCode;

            //
            // if the ARB is really an async request then add it to the end of
            // the async request queue else if it is a sync request then just
            // signal the event. The waiter will free the ARB
            //

            SetEvent(lpArb->hEvent);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("signalled sync request %#x, on %#x\n",
                        lpArb,
                        lpArb->dwBlockedOnEvent
                        ));


            //
            // if we've hit the number of waiters we were to unblock then
            // quit
            //

            ++dwUnblocked;
            if (dwUnblocked == dwNumberOfWaiters) {
                break;
            }

            //
            // we moved the ARB
            //

            lpArb = lpArbPrevious;
        }
        lpArbPrevious = lpArb;
        lpArb = (LPARB)lpArb->List.Flink;
    }

    ReleaseBlockedRequestQueue();

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}



VOID
AcquireBlockedRequestQueue(
    VOID
    )

/*++

Routine Description:

    Synchronizes access to the blocked request queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    LockSerializedList(&BlockedRequestQueue);
}


VOID
ReleaseBlockedRequestQueue(
    VOID
    )

/*++

Routine Description:

    Releases the lock acquired with AcquireBlockedRequestQueue

Arguments:

    None.

Return Value:

    None.

--*/

{
    UnlockSerializedList(&BlockedRequestQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\autodial.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    autodial.cxx

Abstract:

    Contains the implementation of autodial

    Contents:

Author:

    Darren Mitchell (darrenmi) 22-Apr-1997

Environment:

    Win32(s) user-mode DLL

Revision History:

    22-Apr-1997 darrenmi
        Created


--*/

#include "wininetp.h"
#include "autodial.h"
#include "rashelp.h"
#include <sensapi.h>
#include <winsvc.h>
#include <commctrl.h>
#include "millenras.h"
#include <iphlpapi.h>

// Globals.
// In IE4 - there are several situations when these globals are
// accessed simultaneously by different threads and so we need to protect them
// with a mutex

//
// fDontProcessHook - set to TRUE in the following circumstances:
//
// - autodial is not enabled
// - loading the ras dll failed
// - no modem is installed
//
// this flag is only relevant on Win95.
//
BOOL fDontProcessHook = FALSE;

DWORD   g_dwLastTickCount = 0;

// g_hwndWebCheck is currently not protected with a mutex
HWND g_hwndWebCheck = NULL;               // instead of findwindow every time

// have we already checked out the current connection for proxy change?
BOOL g_fConnChecked = FALSE;

// serialize GetConnectedState
HANDLE g_hConnectionMutex = INVALID_HANDLE_VALUE;

// serialize access to RAS
HANDLE g_hRasMutex = INVALID_HANDLE_VALUE;

// serialize access to proxy reg settings
HANDLE g_hProxyRegMutex = INVALID_HANDLE_VALUE;


// Have we upgraded settings?
BOOL g_fCheckedUpgrade = FALSE;

// should we ask user to go offline if no connect?
BOOL g_fAskOffline = TRUE;

// Don't do any callbacks in rnaapp.exe process
BOOL g_fRNAAppProcess = FALSE;

// We use native font control from comctl so we need to call initcommoncontrols
HMODULE hCommctrl = NULL;
typedef BOOL (WINAPI *PFNINITCOMMONCONTROLS)(LPINITCOMMONCONTROLSEX);

// base key for settings, lives in proxreg.cxx
extern CRefdKey* g_prkBase;

//
// Enable sens network checking
//
#ifndef UNIX
/* On Unix we assume we are on a LAN all the time */
#define CHECK_SENS 1
#endif /* UNIX */

#ifdef CHECK_SENS

// prototype for IsNetworkAlive()
typedef BOOL (WINAPI *ISNETWORKALIVE)(LPDWORD);

// handle to sens dll and entry point
BOOL g_fSensInstalled = TRUE;
HINSTANCE g_hSens = NULL;
ISNETWORKALIVE g_pfnIsNetworkAlive = NULL;

// how often to call sens to check state?  Every 15 seconds seems reasonable
#define MIN_SENS_CHECK_INTERVAL 15000
DWORD g_dwLastSensCheck = 0;

// message we send to dialmon to find out if sens is loaded
#define WM_IS_SENSLCE_LOADED    (WM_USER+201)
#endif

// registry strings
const CHAR szRegPathRemoteAccess[] = REGSTR_PATH_REMOTEACCESS;
const CHAR szRegPathInternetSettings[] = REGSTR_PATH_INTERNET_SETTINGS;
const CHAR szRegValEnableAutodial[] = REGSTR_VAL_ENABLEAUTODIAL;
const CHAR szRegValInternetEntry[] = REGSTR_VAL_INTERNETPROFILE;
const CHAR szRegValUnattended[] = REGSTR_VAL_ENABLEUNATTENDED;
static const CHAR szRegPathRNAProfile[] = REGSTR_PATH_REMOTEACCESS "\\Profile";
static const CHAR szRegValAutodialDllName[] = REGSTR_VAL_AUTODIALDLLNAME;
static const CHAR szRegValAutodialFcnName[] = REGSTR_VAL_AUTODIALFCNNAME;
static const CHAR szRegValAutodialFlags[] = "HandlerFlags";
static const CHAR szRegPathRNAService[] = REGSTR_PATH_SERVICES "\\RemoteAccess";
static const CHAR szRegAddresses[] = "RemoteAccess\\Addresses";
static const CHAR szRegPathTCP[] = REGSTR_PATH_VXD "\\MSTCP";
static const CHAR szRegValRemoteConnection[] = "Remote Connection";
static const CHAR szRegValHostName[] = "HostName";
static const CHAR szInetPerformSecurityCheck[] = "InetPerformSecurityCheck";
static const CHAR szRegValEnableSecurityCheck[] = REGSTR_VAL_ENABLESECURITYCHECK;
static const CHAR szAutodialMonitorClass[] = REGSTR_VAL_AUTODIAL_MONITORCLASSNAME;
static const CHAR szWebCheckMonitorClass[] = "MS_WebCheckMonitor";
static const CHAR szRegPathComputerName[] = REGSTR_PATH_COMPUTRNAME;
static const CHAR szRegValComputerName[] = REGSTR_VAL_COMPUTRNAME;
static const CHAR szMigrateProxy[] = "MigrateProxy";
static const CHAR szProxySuspect[] = "ProxySuspect";
static const CHAR szCMDllName[] = "cmdial32.dll";

// wide version of various registry strings
#define TSZMICROSOFTPATHW                   L"Software\\Microsoft"
#define TSZIEPATHW        TSZMICROSOFTPATHW L"\\Internet Explorer"
#define TSZWINCURVERPATHW TSZMICROSOFTPATHW L"\\windows\\CurrentVersion"
#define TSZWININETPATHW   TSZWINCURVERPATHW L"\\Internet Settings"

#define REGSTR_PATH_INTERNETSETTINGSW       TSZWININETPATHW
#define REGSTR_PATH_INTERNET_LAN_SETTINGSW  REGSTR_PATH_INTERNETSETTINGSW L"\\LAN"
#define REGSTR_DIAL_AUTOCONNECTW            L"AutoConnect"
#define REGSTR_VAL_COVEREXCLUDEW            L"CoverExclude"
#define REGSTR_VAL_REDIALATTEMPTSW          L"RedialAttempts"
#define REGSTR_VAL_REDIALINTERVALW          L"RedialWait"
#define REGSTR_VAL_INTERNETENTRYW           L"InternetProfile"
#define REGSTR_VAL_INTERNETPROFILEW         REGSTR_VAL_INTERNETENTRYW
#define REGSTR_PATH_REMOTEACCESSW           L"RemoteAccess"
#define REGSTR_VAL_AUTODIALDLLNAMEW         L"AutodialDllName"
#define REGSTR_VAL_AUTODIALFCNNAMEW         L"AutodialFcnName"

const WCHAR szRegValInternetEntryW[] = REGSTR_VAL_INTERNETPROFILEW;
const WCHAR szRegPathRemoteAccessW[] = REGSTR_PATH_REMOTEACCESSW;
const WCHAR szRegPathRNAProfileW[] = REGSTR_PATH_REMOTEACCESSW L"\\Profile";
const WCHAR szRegValAutodialDllNameW[] = REGSTR_VAL_AUTODIALDLLNAMEW;
const WCHAR szRegValAutodialFcnNameW[] = REGSTR_VAL_AUTODIALFCNNAMEW;
const WCHAR szRegValAutodialFlagsW[] = L"HandlerFlags";
const WCHAR szCMDllNameW[] = L"cmdial32.dll";

// NT reg keys for finding ras phonebook file
static const CHAR szNTRasPhonebookKey[] = "Software\\Microsoft\\RAS Phonebook";
static const CHAR szPhonebookMode[] = "PhonebookMode";

// don't check RNA state more than once every 3 seconds
#define MIN_RNA_BUSY_CHECK_INTERVAL 3000

// Name or reg value we save legacy settings for comparison later
#define LEGACY_MIGRATE_FLAGS        (PROXY_TYPE_PROXY | PROXY_TYPE_AUTO_PROXY_URL)

//
// Current ras connections - used so we don't poll ras every time we're
// interested - only poll every 3 seconds (const. above)
//
RasEnumConnHelp g_RasCon;
DWORD       g_dwConnections = 0;
BOOL        g_fRasInstalled = FALSE;
DWORD       g_dwLastDialupTicks = 0;

//
// API setting for autodial.  Allow individual processes to disable autodial
// using InternetSetOption.
//
// This can override an enabled setting but not a disabled setting.
//
BOOL        g_fAutodialEnableAPISetting = TRUE;

//
// Control of autodial initialization
//
BOOL        g_fAutodialInitialized = FALSE;

//
// Do we know for sure that winsock is loaded?
//
BOOL        g_fWinsockLoaded = FALSE;


HANDLE      g_hDialEvent = NULL;
//
// Structure used to mess about with proxy settings
//
typedef struct _proxy {
    DWORD   dwEnable;
    TCHAR   szServer[INTERNET_MAX_URL_LENGTH];
    TCHAR   szOverride[INTERNET_MAX_URL_LENGTH];
    DWORD   dwSuspect;
} PROXY, *PPROXY;

//
// Need GetBestRoute from iphlpapi -- dynaload it, free on ExitAutodialModule
//
typedef DWORD (WINAPI *GETBESTROUTE)(DWORD, DWORD, PMIB_IPFORWARDROW);

static HINSTANCE g_hIphlpapi = NULL;
static GETBESTROUTE g_pfnGetBestRoute = NULL;

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                         RAS dynaload code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static HINSTANCE g_hRasLib = NULL;
static long g_lRasRefCnt = 0;

static _RASHANGUP               pfnRasHangUp = NULL;

static _RASDIALA                 pfnRasDialA = NULL;
static _RASENUMENTRIESA          pfnRasEnumEntriesA = NULL;
static _RASGETENTRYDIALPARAMSA   pfnRasGetEntryDialParamsA = NULL;
static _RASSETENTRYDIALPARAMSA   pfnRasSetEntryDialParamsA = NULL;
static _RASEDITPHONEBOOKENTRYA   pfnRasEditPhonebookEntryA = NULL;
static _RASCREATEPHONEBOOKENTRYA pfnRasCreatePhonebookEntryA = NULL;
static _RASGETERRORSTRINGA       pfnRasGetErrorStringA = NULL;
static _RASGETCONNECTSTATUSA     pfnRasGetConnectStatusA = NULL;
static _RASENUMCONNECTIONSA      pfnRasEnumConnectionsA = NULL;
static _RASGETENTRYPROPERTIESA   pfnRasGetEntryPropertiesA = NULL;

static _RASDIALW                 pfnRasDialW = NULL;
static _RASENUMENTRIESW          pfnRasEnumEntriesW = NULL;
static _RASGETENTRYDIALPARAMSW   pfnRasGetEntryDialParamsW = NULL;
static _RASSETENTRYDIALPARAMSW   pfnRasSetEntryDialParamsW = NULL;
static _RASEDITPHONEBOOKENTRYW   pfnRasEditPhonebookEntryW = NULL;
static _RASCREATEPHONEBOOKENTRYW pfnRasCreatePhonebookEntryW = NULL;
static _RASGETERRORSTRINGW       pfnRasGetErrorStringW = NULL;
static _RASGETCONNECTSTATUSW     pfnRasGetConnectStatusW = NULL;
static _RASENUMCONNECTIONSW      pfnRasEnumConnectionsW = NULL;
static _RASGETENTRYPROPERTIESW   pfnRasGetEntryPropertiesW = NULL;

// Millennium (DUN 1.4?) RAS exports
static _RASINTERNETDIAL          pfnRasInternetDialA = NULL;
static _RASINTERNETHANGUP        pfnRasInternetHangUpA = NULL;
static _RASINTERNETAUTODIAL      pfnRasInternetAutodialA = NULL;
static _RASINTERNETAUTODIALHANG  pfnRasInternetAutodialHangUpA = NULL;
static _RASINTERNETCONNSTATE     pfnRasInternetGetConnectedStateExA = NULL;
static _RNAGETDEFAULTAUTODIAL    pfnRnaGetDefaultAutodialConnection = NULL;
static _RNASETDEFAULTAUTODIAL    pfnRnaSetDefaultAutodialConnection = NULL;

// RAS entry points to sync up autodial connectoid... used on whistler only
static _RASGETAUTODIALADDRESSA   pfnRasGetAutodialAddressA = NULL;
static _RASSETAUTODIALADDRESSA   pfnRasSetAutodialAddressA = NULL;

static _RASGETCREDENTIALSW       pfnRasGetCredentialsW = NULL;
static _RASSETCREDENTIALSW       pfnRasSetCredentialsW = NULL;

typedef struct _tagAPIMAPENTRY {
    FARPROC* pfn;
    LPSTR pszProc;
} APIMAPENTRY;

APIMAPENTRY rgRasApiMapA[] = {
    { (FARPROC*) &pfnRasDialA,                   "RasDialA" },
    { (FARPROC*) &pfnRasHangUp,                  "RasHangUpA" },
    { (FARPROC*) &pfnRasEnumEntriesA,            "RasEnumEntriesA" },
    { (FARPROC*) &pfnRasGetEntryDialParamsA,     "RasGetEntryDialParamsA" },
    { (FARPROC*) &pfnRasSetEntryDialParamsA,     "RasSetEntryDialParamsA" },
    { (FARPROC*) &pfnRasEditPhonebookEntryA,     "RasEditPhonebookEntryA" },
    { (FARPROC*) &pfnRasCreatePhonebookEntryA,   "RasCreatePhonebookEntryA" },
    { (FARPROC*) &pfnRasGetErrorStringA,         "RasGetErrorStringA" },
    { (FARPROC*) &pfnRasGetConnectStatusA,       "RasGetConnectStatusA" },
    { (FARPROC*) &pfnRasEnumConnectionsA,        "RasEnumConnectionsA" },
    { (FARPROC*) &pfnRasGetEntryPropertiesA,     "RasGetEntryPropertiesA"},
    { (FARPROC*) &pfnRasInternetDialA,           "RasInternetDialA"},
    { (FARPROC*) &pfnRasInternetHangUpA,         "RasInternetHangUpA"},
    { (FARPROC*) &pfnRasInternetAutodialA,       "RasInternetAutodialA"},
    { (FARPROC*) &pfnRasInternetAutodialHangUpA, "RasInternetAutodialHangUpA"},
    { (FARPROC*) &pfnRasInternetGetConnectedStateExA, "RasInternetGetConnectedStateExA"},
    { (FARPROC*) &pfnRnaGetDefaultAutodialConnection, "RnaGetDefaultAutodialConnection"},
    { (FARPROC*) &pfnRnaSetDefaultAutodialConnection, "RnaSetDefaultAutodialConnection"},
    { NULL, NULL },
};

APIMAPENTRY rgRasApiMapW[] = {
    { (FARPROC*) &pfnRasDialW,                   "RasDialW" },
    { (FARPROC*) &pfnRasHangUp,                  "RasHangUpW" },
    { (FARPROC*) &pfnRasEnumEntriesW,            "RasEnumEntriesW" },
    { (FARPROC*) &pfnRasGetEntryDialParamsW,     "RasGetEntryDialParamsW" },
    { (FARPROC*) &pfnRasSetEntryDialParamsW,     "RasSetEntryDialParamsW" },
    { (FARPROC*) &pfnRasEditPhonebookEntryW,     "RasEditPhonebookEntryW" },
    { (FARPROC*) &pfnRasCreatePhonebookEntryW,   "RasCreatePhonebookEntryW" },
    { (FARPROC*) &pfnRasGetErrorStringW,         "RasGetErrorStringW" },
    { (FARPROC*) &pfnRasGetConnectStatusW,       "RasGetConnectStatusW" },
    { (FARPROC*) &pfnRasEnumConnectionsW,        "RasEnumConnectionsW" },
    { (FARPROC*) &pfnRasGetEntryPropertiesW,     "RasGetEntryPropertiesW"},
    { (FARPROC*) &pfnRasGetCredentialsW,         "RasGetCredentialsW"},
    { (FARPROC*) &pfnRasSetCredentialsW,         "RasSetCredentialsW"},

    // following are A in W map on purpose.. used on whistler only, but wininet code has
    // the connectoid in multibyte.. may as well let RAS convert it.
    { (FARPROC*) &pfnRasGetAutodialAddressA,     "RasGetAutodialAddressA"},
    { (FARPROC*) &pfnRasSetAutodialAddressA,     "RasSetAutodialAddressA"},
    { NULL, NULL },
};

#define RASFCN(_fn, _part, _par, _dbge, _dbgl)     \
DWORD _##_fn _part                          \
{                                           \
    DEBUG_ENTER(_dbge);                     \
                                            \
    DWORD dwRet;                            \
    if(NULL == pfn##_fn)                    \
    {                                       \
        _dbgl(ERROR_INVALID_FUNCTION);      \
        return ERROR_INVALID_FUNCTION;      \
    }                                       \
                                            \
    dwRet = (* pfn##_fn) _par;              \
                                            \
    _dbgl(dwRet);                           \
    return dwRet;                           \
}

RASFCN(RasDialA,
    (LPRASDIALEXTENSIONS lpRasDialExtensions, LPSTR lpszPhonebook, LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType, LPVOID lpvNotifier, LPHRASCONN lphRasConn),
    (lpRasDialExtensions, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    (DBG_DIALUP, Dword, "RasDialA", "%#x, %#x (%q), %#x, %d, %#x, %#x", lpRasDialExtensions, lpszPhonebook, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    DEBUG_LEAVE
    );

RASFCN(RasHangUp,
    (HRASCONN hRasConn),
    (hRasConn),
    (DBG_DIALUP, Dword, "RasHangUp", "%#x", hRasConn),
    DEBUG_LEAVE
    );

RASFCN(RasEnumEntriesA,
    (LPSTR lpszReserved, LPSTR lpszPhonebook, LPRASENTRYNAMEA lprasentryname, LPDWORD lpcb, LPDWORD lpcEntries),
    (lpszReserved, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    (DBG_DIALUP, Dword, "RasEnumEntriesA", "%#x (%q), %#x (%q), %#x, %#x, %#x", lpszReserved, lpszReserved, lpszPhonebook, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryDialParamsA,
    (LPCSTR lpszPhonebook, LPRASDIALPARAMS lprasdialparams, LPBOOL lpfPassword),
    (lpszPhonebook, lprasdialparams, lpfPassword),
    (DBG_DIALUP, Dword, "RasGetEntryDialParamsA", "%#x (%q), %#x, %#x", lpszPhonebook, lpszPhonebook, lprasdialparams, lpfPassword),
    DEBUG_LEAVE
    );

RASFCN(RasSetEntryDialParamsA,
    (LPCSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams, BOOL fRemovePassword),
    (lpszPhonebook,lprasdialparams, fRemovePassword),
    (DBG_DIALUP, Dword, "RasSetEntryDialParamsA", "%#x (%q), %#x, %d", lpszPhonebook, lpszPhonebook, lprasdialparams, fRemovePassword),
    DEBUG_LEAVE
    );

RASFCN(RasGetErrorStringA,
    (UINT uError, LPSTR pszBuf, DWORD cBufSize),
    (uError, pszBuf, cBufSize),
    (DBG_DIALUP, Dword, "RasGetErrorStringA", "%d, %#x (%q), %d", uError, pszBuf, cBufSize),
    DEBUG_LEAVE
    );

RASFCN(RasEditPhonebookEntryA,
    (HWND hwnd, LPSTR lpszBook, LPSTR lpszEntry),
    (hwnd, lpszBook, lpszEntry),
    (DBG_DIALUP, Dword, "RasEditPhonebookEntryA", "%#x, %#x (%q), %#x (%q)", hwnd, lpszBook, lpszBook, lpszEntry, lpszEntry),
    DEBUG_LEAVE
    );

RASFCN(RasCreatePhonebookEntryA,
    (HWND hwnd, LPSTR pszBook),
    (hwnd, pszBook),
    (DBG_DIALUP, Dword, "RasCreatePhonebookEntryA", "%#x, %#x (%q)", hwnd, pszBook, pszBook),
    DEBUG_LEAVE
    );

RASFCN(RasGetConnectStatusA,
    (HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus),
    (hrasconn, lprasconnstatus),
    (DBG_DIALUP, Dword, "RasGetConnectStatusA", "%#x, %#x", hrasconn, lprasconnstatus),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryPropertiesA,
    (LPSTR lpszPhonebook, LPSTR lpszEntry, LPRASENTRY lpRasEntry, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhonebook, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    (DBG_DIALUP, Dword, "RasGetEntryPropertiesA", "%#x (%q), %#x (%q), %#x, %#x, %#x %#x", lpszPhonebook, lpszPhonebook, lpszEntry, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    DEBUG_LEAVE
    );

RASFCN(RasEnumConnectionsA,
    (LPRASCONN lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn),
    (lpRasConn, lpdwSize, lpdwConn),
    (DBG_DIALUP, Dword, "RasEnumConnectionsA", "%#x, %#x, %#x", lpRasConn, lpdwSize, lpdwConn),
    DEBUG_LEAVE
    );

RASFCN(RasInternetDialA,
    (HWND hwndParent, LPSTR pszEntryName, DWORD dwFlags, DWORD_PTR *lpdwConnection, DWORD dwReserved),
    (hwndParent, pszEntryName, dwFlags, lpdwConnection, dwReserved),
    (DBG_DIALUP, Dword, "RasInternetDialA", "#x, #x (%q), %x, %x, %x", hwndParent, pszEntryName, pszEntryName, dwFlags, lpdwConnection, dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RasInternetHangUpA,
    (DWORD_PTR dwConnection, DWORD dwReserved),
    (dwConnection, dwReserved),
    (DBG_DIALUP, Dword, "RasInternetHangUpA", "#x, #x", dwConnection, dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RasInternetAutodialA,
    (DWORD dwFlags, HWND hwndParent),
    (dwFlags, hwndParent),
    (DBG_DIALUP, Dword, "RasInterenetAutodialA", "#x, #x", dwFlags, hwndParent),
    DEBUG_LEAVE
    );

RASFCN(RasInternetAutodialHangUpA,
    (DWORD dwReserved),
    (dwReserved),
    (DBG_DIALUP, Dword, "RasInternetAutodialHangUpA", "#x", dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RasInternetGetConnectedStateExA,
    (LPDWORD lpdwFlags, LPSTR lpszConnectionName, DWORD dwBufLen, DWORD dwReserved),
    (lpdwFlags, lpszConnectionName, dwBufLen, dwReserved),
    (DBG_DIALUP, Bool, "RasInternetGetConnectedStateExA", "%x, %x, %x, %x", lpdwFlags, lpszConnectionName, dwBufLen, dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RnaGetDefaultAutodialConnection,
    (LPSTR pszEntry, DWORD dwLen, LPDWORD lpdwFlags),
    (pszEntry, dwLen, lpdwFlags),
    (DBG_DIALUP, Dword, "RnaGetDefaultAutodialConnection", "%#x, %#x, %#x", pszEntry, dwLen, lpdwFlags),
    DEBUG_LEAVE
    );

RASFCN(RnaSetDefaultAutodialConnection,
    (LPSTR pszEntry, DWORD dwFlags),
    (pszEntry, dwFlags),
    (DBG_DIALUP, Dword, "RnaSetDefaultAutodialConnection", "%#x (%q), %#x", pszEntry, pszEntry, dwFlags),
    DEBUG_LEAVE
    );

////////////////////////////////////////////////////
// Wide versions
RASFCN(RasDialW,
    (LPRASDIALEXTENSIONS lpRasDialExtensions, LPWSTR lpszPhonebook,
    LPRASDIALPARAMSW lpRasDialParams, DWORD dwNotifierType, LPVOID lpvNotifier, LPHRASCONN lphRasConn),
    (lpRasDialExtensions, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    (DBG_DIALUP, Dword, "RasDialW", "%#x, %#x (%Q), %#x, %d, %#x, %#x", lpRasDialExtensions, lpszPhonebook, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    DEBUG_LEAVE
    );

RASFCN(RasEnumEntriesW,
    (LPWSTR lpszReserved, LPWSTR lpszPhonebook, LPRASENTRYNAMEW lprasentryname,
    LPDWORD lpcb, LPDWORD lpcEntries),
    (lpszReserved, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    (DBG_DIALUP, Dword, "RasEnumEntriesW", "%#x (%Q), %#x (%Q), %#x, %#x %#x", lpszReserved, lpszReserved, lpszPhonebook, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryDialParamsW,
    (LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, LPBOOL lpfPassword),
    (lpszPhonebook, lprasdialparams, lpfPassword),
    (DBG_DIALUP, Dword, "RasGetEntryDialParamsW", "%#x (%Q), %#x, %#x", lpszPhonebook, lpszPhonebook, lprasdialparams, lpfPassword),
    DEBUG_LEAVE
    );

RASFCN(RasSetEntryDialParamsW,
    (LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, BOOL fRemovePassword),
    (lpszPhonebook,lprasdialparams, fRemovePassword),
    (DBG_DIALUP, Dword, "RasSetEntryDialParamsW", "%#x (%Q), %#x, %d", lpszPhonebook, lpszPhonebook, lprasdialparams, fRemovePassword),
    DEBUG_LEAVE
    );

RASFCN(RasGetErrorStringW,
    (UINT uError, LPWSTR pszBuf, DWORD cBufSize),
    (uError, pszBuf, cBufSize),
    (DBG_DIALUP, Dword, "RasGetErrorStringW", "%d, %#x (%Q), %d", uError, pszBuf, cBufSize),
    DEBUG_LEAVE
    );

RASFCN(RasEditPhonebookEntryW,
    (HWND hwnd, LPWSTR lpszBook, LPWSTR lpszEntry),
    (hwnd, lpszBook, lpszEntry),
    (DBG_DIALUP, Dword, "RasEditPhonebookEntryW", "%#x, %#x (%Q), %#x (%Q)", hwnd, lpszBook, lpszBook, lpszEntry, lpszEntry),
    DEBUG_LEAVE
    );

RASFCN(RasCreatePhonebookEntryW,
    (HWND hwnd, LPWSTR pszBook),
    (hwnd, pszBook),
    (DBG_DIALUP, Dword, "RasCreatePhonebookEntryW", "%#x, %#x (%Q)", hwnd, pszBook, pszBook),
    DEBUG_LEAVE
    );

RASFCN(RasGetConnectStatusW,
    (HRASCONN hrasconn, LPRASCONNSTATUSW lprasconnstatus),
    (hrasconn, lprasconnstatus),
    (DBG_DIALUP, Dword, "RasGetConnectStatusW", "%#x, %#x", hrasconn, lprasconnstatus),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryPropertiesW,
    (LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPRASENTRYW lpRasEntry, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhonebook, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    (DBG_DIALUP, Dword, "RasGetEntryPropertiesW", "%#x (%Q), %#x (%Q), %#x, %#x, %#x %#x", lpszPhonebook, lpszPhonebook, lpszEntry, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    DEBUG_LEAVE
    );

RASFCN(RasEnumConnectionsW,
    (LPRASCONNW lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn),
    (lpRasConn, lpdwSize, lpdwConn),
    (DBG_DIALUP, Dword, "RasEnumConnectionsW", "%#x, %#x, %#x", lpRasConn, lpdwSize, lpdwConn),
    DEBUG_LEAVE
    );

RASFCN(RasGetAutodialAddressA,
    (LPCSTR lpszAddress, LPDWORD lpdwReserved, LPRASAUTODIALENTRYA lpEntries, LPDWORD lpdwBytes, LPDWORD lpdwEntries),
    (lpszAddress, lpdwReserved, lpEntries, lpdwBytes, lpdwEntries),
    (DBG_DIALUP, Dword, "RasGetAutodialAddressA", "%#x (%Q), %#x, %#x, %#x, %#x", lpszAddress, lpszAddress, lpdwReserved, lpEntries, lpdwBytes, lpdwEntries),
    DEBUG_LEAVE
    );

RASFCN(RasSetAutodialAddressA,
    (LPCSTR lpszAddress, DWORD dwReserved, LPRASAUTODIALENTRYA lpEntries, DWORD dwBytes, DWORD dwEntries),
    (lpszAddress, dwReserved, lpEntries, dwBytes, dwEntries),
    (DBG_DIALUP, Dword, "RasSetAutodialAddressA", "%#x (%q), %#x, %#x, %#x, %#x", lpszAddress, lpszAddress, dwReserved, lpEntries, dwBytes, dwEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetCredentialsW,
    (LPCWSTR pszPhonebook, LPCWSTR pszEntry, LPRASCREDENTIALSW pCreds),
    (pszPhonebook, pszEntry, pCreds),
    (DBG_DIALUP, Dword, "RasGetCredentialsW", "%#x (%Q), %#x (%Q), %#x", pszPhonebook, pszPhonebook, pszEntry, pszEntry, pCreds),
    DEBUG_LEAVE
    );

RASFCN(RasSetCredentialsW,
    (LPCWSTR pszPhonebook, LPCWSTR pszEntry, LPRASCREDENTIALSW pCreds, BOOL fNuke),
    (pszPhonebook, pszEntry, pCreds, fNuke),
    (DBG_DIALUP, Dword, "RasSetCredentialsW", "%#x (%Q), %#x (%Q), %#x, %#x", pszPhonebook, pszPhonebook, pszEntry, pszEntry, pCreds, fNuke),
    DEBUG_LEAVE
    );

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
EnsureRasLoaded(
    VOID
    )

/*++

Routine Description:

    Dynaload ras apis

Arguments:

    pfInstalled - return installed state of ras

Return Value:

    BOOL
        TRUE    - Ras loaded
        FALSE   - Ras not loaded

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "EnsureRasLoaded",
                 NULL
                 ));

    //
    // Looks like RAS is installed - try and load it up!
    //
    if(NULL == g_hRasLib) {
        g_hRasLib = LoadLibrary("RASAPI32.DLL");

        if(NULL == g_hRasLib)
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        APIMAPENTRY *prgRasApiMap;
        if(PLATFORM_TYPE_WIN95 == GlobalPlatformType)
            prgRasApiMap = rgRasApiMapA;
        else
            prgRasApiMap = rgRasApiMapW;

        int nIndex = 0;
        while ((prgRasApiMap+nIndex)->pszProc != NULL) {
            // Some functions are only present on some platforms.  Don't
            // assume this succeeds for all functions.
            *(prgRasApiMap+nIndex)->pfn =
                    GetProcAddress(g_hRasLib, (prgRasApiMap+nIndex)->pszProc);
            nIndex++;
        }
    }

    if(g_hRasLib) {
        g_lRasRefCnt++;
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
IsServiceRunning(
    LPSTR   pszServiceName,
    DWORD   dwRequiredState
    )

/*++

Routine Description:

    Determines whether a specified service is running on NT

Arguments:

    pszServiceName  - service to find
    dwRequiredState - state the service has to be in to consider it found

Return Value:

    BOOL
        TRUE        - Service is in required state

        FALSE       - not

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsServiceRunning",
                 "%#x (%q), %#x",
                 pszServiceName,
                 pszServiceName,
                 dwRequiredState
                 ));

    SC_HANDLE   hscm;
    BOOL        fFoundService = FALSE;

    //
    // Sanity check - can only do this on NT
    //
    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // Ask service manager to enumerate all running services
    //
    hscm = OpenSCManager(NULL, NULL, GENERIC_READ);
    if(hscm)
    {
        SC_HANDLE hras;
        ENUM_SERVICE_STATUS essServices[16];
        DWORD dwError, dwResume = 0, i;
        DWORD cbNeeded = 1, csReturned;

        while(FALSE == fFoundService && cbNeeded > 0)
        {
            // Get the next chunk of services
            dwError = 0;
            if(FALSE == EnumServicesStatus(hscm, SERVICE_WIN32, dwRequiredState,
                    essServices, sizeof(essServices), &cbNeeded, &csReturned,
                    &dwResume))
            {
                dwError = GetLastError();
            }

            if(dwError && dwError != ERROR_MORE_DATA)
            {
                // unknown error - bail
                break;
            }

            for(i=0; i<csReturned; i++)
            {
                if(0 == lstrcmpi(essServices[i].lpServiceName, pszServiceName))
                {
                    // found it!
                    fFoundService = TRUE;
                    break;
                }
            }
        }

        CloseServiceHandle(hscm);
    }

    DEBUG_LEAVE(fFoundService);
    return fFoundService;
}


BOOL
IsRasInstalled(
    VOID
    )

/*++

Routine Description:

    Determines whether ras is installed on this machine

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Ras is installed

        FALSE   - Ras is not installed

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "IsRasInstalled",
                 NULL
                 ));

    static fChecked = FALSE;

    //
    // If RAS is already loaded, don't bother doing any work.
    //
    if(g_hRasLib)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if we've already done the check, don't do it again
    //
    if(fChecked)
    {
        DEBUG_LEAVE_API(g_fRasInstalled);
        return g_fRasInstalled;
    }

    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType) {
        //
        // Check Win9x key
        //
        char    szSmall[3]; // there should be a "1" or a "0" only
        DWORD   cb;
        HKEY    hkey;
        long    lRes;

        lRes = REGOPENKEYEX(HKEY_LOCAL_MACHINE, REGSTR_PATH_RNACOMPONENT,
                             NULL, KEY_READ, &hkey);
        if(ERROR_SUCCESS == lRes) {
            cb = sizeof(szSmall);
            //  REGSTR_VAL_RNAINSTALLED is defined with TEXT() macro so
            //  if wininet is ever compiled unicode this will be a compile
            //  error.
            lRes = RegQueryValueExA(hkey, REGSTR_VAL_RNAINSTALLED, NULL,
                    NULL, (LPBYTE)szSmall, &cb);
            if(ERROR_SUCCESS == lRes) {
                if((szSmall[0] == '1') && (szSmall[1] == 0)) {
                    // 1 means ras installed
                    g_fRasInstalled = TRUE;
                }
            }
            REGCLOSEKEY(hkey);
        }
    } else {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osvi);

        if (osvi.dwMajorVersion < 5)
        {
            // on NT4, make sure ras man service is installed
            g_fRasInstalled = IsServiceRunning("RasMan", SERVICE_STATE_ALL);

            if(g_fRasInstalled)
            {
                if(EnsureRasLoaded() && FALSE == GlobalDisableNT4RasCheck)
                {
                    RasEnumHelp *pRasEnum = NULL;
                    __try
                    {
                        // call rasenumentries - if it faults, we're in that
                        // NT4 busted case so return not installed.
                        pRasEnum = new RasEnumHelp;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        // if it faults, don't use ras any more
                        g_fRasInstalled = FALSE;
                    }
                    ENDEXCEPT

                    if (pRasEnum)
                        delete pRasEnum;
                }
            }
        }
        else
        {
            // NT5 and presumably beyond, ras is always installed
            g_fRasInstalled = TRUE;
        }
    }

    fChecked = TRUE;

    DEBUG_LEAVE_API(g_fRasInstalled);
    return g_fRasInstalled;
}


BOOL
DoConnectoidsExist(
    VOID
    )

/*++

Routine Description:

    Determines whether any ras connectoids exist

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Connectoids exist

        FALSE   - No connectoids exist

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "DoConnectoidsExist",
                 NULL
                 ));

    static BOOL fExist = FALSE;

    //
    // If we found connectoids before, don't bother looking again
    //
    if(fExist)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // If RAS is already loaded, ask it
    //
    if(g_hRasLib && FALSE == GlobalDisableNT4RasCheck) {
        DWORD dwRet, dwEntries;

        RasEnumHelp *pRasEnum = new RasEnumHelp;

        if (pRasEnum)
        {
            dwRet = pRasEnum->GetError();
            dwEntries = pRasEnum->GetEntryCount();
            delete pRasEnum;
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }

        // If ras tells us there are none, return none
        if(ERROR_SUCCESS == dwRet && 0 == dwEntries)
        {
            DEBUG_LEAVE_API(FALSE);
            return FALSE;
        }
        // couldn't determine that there aren't any so assume there are.
        fExist = TRUE;
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if ras isn't installed, say no connectoids
    //
    if(FALSE == IsRasInstalled())
    {
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType) {
        // On win95, check for any value in RemoteAccess\Addresses reg key
        HKEY    hkey;
        TCHAR   szName[RAS_MaxEntryName+1];
        DWORD   cbName = RAS_MaxEntryName+1;
        long    lRes;

        if(ERROR_SUCCESS == REGOPENKEYEX(HKEY_CURRENT_USER, szRegAddresses,
                0, KEY_READ, &hkey)) {

            lRes = RegEnumValue(hkey, 0, szName, &cbName, NULL, NULL, NULL, NULL);
            if(ERROR_SUCCESS == lRes) {
                // we managed to get info on a connectoid.
                fExist = TRUE;
            }

            REGCLOSEKEY(hkey);
        }
    } else {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osvi);

        // assume connectoids exist
        fExist = TRUE;

        if (osvi.dwMajorVersion < 5) {
            // On NT4, check for rasphone.pbk size > 0
            TCHAR   szPhonebook[MAX_PATH + 128];
            ULONG   uLen, ulMode, cb;
            HANDLE  hFile = INVALID_HANDLE_VALUE;
            DWORD   dwSize, dwBigSize;
            HKEY    hkey;

            // Ensure system phonebook is the one in use.  If user has switched
            // to another phonebook, don't bother doing anything else and assume
            // connectoids exist.  It's not our job to grope the world trying to
            // find custom phonebooks.
            if(ERROR_SUCCESS == REGOPENKEYEX(HKEY_CURRENT_USER, szNTRasPhonebookKey,
                0, KEY_READ, &hkey))
            {
                *szPhonebook = 0;
                cb = sizeof(ULONG);
                if(ERROR_SUCCESS == RegQueryValueEx(hkey, szPhonebookMode, NULL,
                        NULL, (LPBYTE)&ulMode, &cb) && 0 == ulMode)
                {
                    // system phonebook - rasphone.pbk in ras directory
                    uLen = GetSystemDirectory(szPhonebook, MAX_PATH);
                    if(uLen)
                    {
                        // append \ras\rasphone.pbk
                        LoadString(GlobalDllHandle, IDS_RASPHONEBOOK, szPhonebook + uLen, 128);
                        hFile = CreateFile(szPhonebook, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL, OPEN_EXISTING, 0, NULL);
                        if(INVALID_HANDLE_VALUE == hFile) {
                            // file doesn't exist - no connectoids
                            fExist = FALSE;
                        } else {
                            dwSize = GetFileSize(hFile, &dwBigSize);
                            if(0 == dwSize && 0 == dwBigSize)
                                // zero size system phonebook - no connectoids
                                fExist = FALSE;
                            CloseHandle(hFile);
                        }
                    }
                }
                REGCLOSEKEY(hkey);
            }
        }
    }

    DEBUG_LEAVE_API(fExist);
    return fExist;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                          Helper Functions
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
InitCommCtrl(
    VOID
    )

/*++

Routine Description:

    Initializes common controls for native font control

    Called from InternetDialA which is serialized.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - successly called InitCommonControlsEx
        FALSE   - failed

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "InitCommCtrl",
                 NULL
                 ));

    BOOL fSuccess = FALSE;

    hCommctrl = LoadLibrary("comctl32.dll");
    if(hCommctrl)
    {
        PFNINITCOMMONCONTROLS pfnInit;

        pfnInit = (PFNINITCOMMONCONTROLS)GetProcAddress(hCommctrl, "InitCommonControlsEx");
        if(pfnInit)
        {
            INITCOMMONCONTROLSEX ex;

            ex.dwSize = sizeof(ex);
            ex.dwICC = ICC_NATIVEFNTCTL_CLASS;
            pfnInit(&ex);
            fSuccess = TRUE;
        }
    }

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}


VOID
ExitCommCtrl(
    VOID
    )

/*++

Routine Description:

    Unloads commctrl library

    Called from InternetDialA which is serialized.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ExitCommCtrl",
                 NULL
                 ));

    if(hCommctrl)
    {
        FreeLibrary(hCommctrl);
        hCommctrl = NULL;
    }

    DEBUG_LEAVE(0);
}


BOOL
IsGlobalOffline(
    VOID
    )

/*++

Routine Description:

    Determines whether wininet is in global offline mode

Arguments:

    None

Return Value:

    BOOL
        TRUE    - offline
        FALSE   - online

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsGlobalOffline",
                 NULL
                 ));

    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


VOID
SetOffline(
    IN BOOL fOffline
    )

/*++

Routine Description:

    Sets wininet's offline mode

Arguments:

    fOffline    - online or offline

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "SetOffline",
                 "%B",
                 fOffline
                 ));

    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

    DEBUG_LEAVE(0);
}


VOID
GetConnKeyW(
    IN LPWSTR pszConn,
    IN LPWSTR pszKey,
    IN int iLen
    )

/*++

Routine Description:

    Get registry key for a specific connection

Arguments:

    pszConn     - connection for which key is required
    pszKey      - buffer to put key
    iLen        - buffer size

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "GetConnKeyW",
                 "%#x (%Q), %#x, %d",
                 pszConn,
                 pszConn,
                 pszKey,
                 iLen
                 ));

    if(NULL == pszConn || 0 == *pszConn)
    {
        // lan setting
        StrCpyNW(pszKey, REGSTR_PATH_INTERNET_LAN_SETTINGSW, iLen);
    }
    else
    {
        // connectoid settings
        wnsprintfW(pszKey, iLen, L"%ws\\%ws", szRegPathRNAProfileW, pszConn);
    }

    DEBUG_LEAVE(0);
}

VOID
GetConnKeyA(
    IN LPSTR pszConn,
    IN LPSTR pszKey,
    IN int iLen
    )

/*++

Routine Description:

    Get registry key for a specific connection

Arguments:

    pszConn     - connection for which key is required
    pszKey      - buffer to put key
    iLen        - buffer size

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "GetConnKeyA",
                 "%#x (%q), %#x, %d",
                 pszConn,
                 pszConn,
                 pszKey,
                 iLen
                 ));

    if(NULL == pszConn || 0 == *pszConn)
    {
        // lan setting
        lstrcpynA(pszKey, REGSTR_PATH_INTERNET_LAN_SETTINGS, iLen);
    }
    else
    {
        // connectoid settings
        wnsprintfA(pszKey, iLen, "%s\\%s", szRegPathRNAProfile, pszConn);
    }

    DEBUG_LEAVE(0);
}


VOID
SetAutodialEnable(
    IN BOOL     fEnable
    )

/*++

Routine Description:

    Sets the API setting for controlling autodial.  Called from
    InternetSetOption.

Arguments:

    fEnable     - FALSE means don't autodial for this process
                  TRUE means autodial if configured by the user

Return Value:

    none.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "SetAutodialEnable",
                 "%B",
                 fEnable
                 ));

    g_fAutodialEnableAPISetting = fEnable;

    DEBUG_LEAVE(0);
}


DWORD
GetAutodialMode(
    )

{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "GetAutodialMode",
                NULL
                ));

    DWORD dwMode = AUTODIAL_MODE_NO_NETWORK_PRESENT, dwError, dwData;

    // make sure RAS and Wininet flags match up
    INET_ASSERT(RAS_AUTODIAL_OPT_NEVER  == AUTODIAL_MODE_NEVER);
    INET_ASSERT(RAS_AUTODIAL_OPT_ALWAYS == AUTODIAL_MODE_ALWAYS);
    INET_ASSERT(RAS_AUTODIAL_OPT_DEMAND == AUTODIAL_MODE_NO_NETWORK_PRESENT);

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaGetDefaultAutodialConnection)
    {
        dwError = _RnaGetDefaultAutodialConnection(NULL, 0, &dwMode);

        if(dwError)
        {
            DEBUG_ERROR(DIALUP, dwError);
            dwMode = AUTODIAL_MODE_NEVER;
        }

        dwMode &= (RAS_AUTODIAL_OPT_NEVER | RAS_AUTODIAL_OPT_ALWAYS | RAS_AUTODIAL_OPT_DEMAND);

        DEBUG_LEAVE(dwMode);
        return dwMode;
    }

    if(InternetReadRegistryDword(REGSTR_VAL_ENABLEAUTODIAL, &dwData) ||
        0 == dwData)
    {
        dwMode = AUTODIAL_MODE_NEVER;
    }

    if(AUTODIAL_MODE_NO_NETWORK_PRESENT == dwMode)
    {
        if(InternetReadRegistryDword(REGSTR_VAL_NONETAUTODIAL, &dwData) ||
            0 == dwData)
        {
            dwMode = AUTODIAL_MODE_ALWAYS;
        }
    }

    DEBUG_LEAVE(dwMode);
    return dwMode;
}

DWORD
SetAutodialMode(
    IN DWORD dwMode
    )

{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "SetAutodialMode",
                "%#x",
                dwMode
                ));

    DWORD dwEnable = 0, dwNonet = 0, dwError = 0;

    // make sure RAS and Wininet flags match up
    INET_ASSERT(RAS_AUTODIAL_OPT_NEVER  == AUTODIAL_MODE_NEVER);
    INET_ASSERT(RAS_AUTODIAL_OPT_ALWAYS == AUTODIAL_MODE_ALWAYS);
    INET_ASSERT(RAS_AUTODIAL_OPT_DEMAND == AUTODIAL_MODE_NO_NETWORK_PRESENT);

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaSetDefaultAutodialConnection && pfnRnaGetDefaultAutodialConnection)
    {
        CHAR szOldName[RAS_MaxEntryName+1];
        DWORD dwOldMode;

        // Have to set both name and mode at the same time, so read existing values and change
        // what we need.
        dwError = _RnaGetDefaultAutodialConnection(szOldName, ARRAYSIZE(szOldName), &dwOldMode);
        if(0 == dwError)
        {
            dwError = _RnaSetDefaultAutodialConnection(szOldName, dwMode);
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    switch(dwMode)
    {
    case AUTODIAL_MODE_NEVER:
        break;
    case AUTODIAL_MODE_NO_NETWORK_PRESENT:
        dwNonet = 1;
        // fall through to always
    case AUTODIAL_MODE_ALWAYS:
        dwEnable = 1;
        break;
    default:
        dwError = ERROR_INVALID_PARAMETER;
    }

    if(ERROR_SUCCESS == dwError)
    {
        InternetWriteRegistryDword(REGSTR_VAL_ENABLEAUTODIAL, dwEnable);
        InternetWriteRegistryDword(REGSTR_VAL_NONETAUTODIAL, dwNonet);
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


DWORD
GetAutodialConnection(
    CHAR    *pszBuffer,
    DWORD   dwBufferLength
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "GetAutodialConnection",
                "%#x, %#x",
                pszBuffer,
                dwBufferLength
                ));

    DWORD   dwType, dwHasEntry = FALSE, dwMode, dwError = ERROR_INVALID_NAME;

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaGetDefaultAutodialConnection)
    {
        dwError = _RnaGetDefaultAutodialConnection(pszBuffer, dwBufferLength, &dwMode);

        if(0 == dwError)
        {
            DEBUG_PRINT(DIALUP, INFO, ("Entry=%s, Mode=%x", pszBuffer, dwMode));
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    if(GlobalPlatformWhistler && EnsureRasLoaded() && pfnRasGetAutodialAddressA)
    {
        RASAUTODIALENTRYA adEntry;
        DWORD dwBytes, dwEntries;
 
        ZeroMemory(&adEntry, sizeof(adEntry));
        adEntry.dwSize = sizeof(adEntry);
        dwBytes = sizeof(adEntry);
        dwEntries = 1;
 
        dwError = _RasGetAutodialAddressA(
                    NULL,
                    NULL,
                    &adEntry,
                    &dwBytes,
                    &dwEntries);

        if(NO_ERROR == dwError && dwEntries)
        {
            lstrcpyn(pszBuffer, adEntry.szEntry, dwBufferLength);
        }
        else
        {
            *pszBuffer = 0;
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    if(ERROR_SUCCESS == SHGetValueA(HKEY_CURRENT_USER, szRegPathRemoteAccess,
            szRegValInternetEntry, &dwType, pszBuffer, &dwBufferLength) &&
            lstrlen(pszBuffer))
    {
        dwError = 0;    // success
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


DWORD
SetAutodialConnection(
    CHAR   *pszConnection
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "SetAutodialConnection",
                "%#x (%q)",
                pszConnection,
                pszConnection
                ));

    DWORD   dwError;

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaSetDefaultAutodialConnection && pfnRnaGetDefaultAutodialConnection)
    {
        CHAR szOldName[RAS_MaxEntryName+1];
        DWORD dwOldMode;

        // Have to set both name and mode at the same time, so read existing values and change
        // what we need.
        dwError = _RnaGetDefaultAutodialConnection(szOldName, ARRAYSIZE(szOldName), &dwOldMode);
        if(0 == dwError)
        {
            dwError = _RnaSetDefaultAutodialConnection(pszConnection, dwOldMode);
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    if(GlobalPlatformWhistler && EnsureRasLoaded() && pfnRasSetAutodialAddressA)
    {
        RASAUTODIALENTRYA adEntry;
 
        ZeroMemory(&adEntry, sizeof(adEntry));
        adEntry.dwSize = sizeof(adEntry);
        lstrcpyn(adEntry.szEntry, pszConnection, sizeof(adEntry.szEntry) / sizeof(TCHAR));
 
        dwError = _RasSetAutodialAddressA(
                    NULL,
                    NULL,
                    &adEntry,
                    sizeof(adEntry),
                    1);

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    SHSetValue(HKEY_CURRENT_USER, szRegPathRemoteAccess, szRegValInternetEntry,
                REG_SZ, pszConnection, lstrlen(pszConnection));

    DEBUG_LEAVE(0);
    return 0;
}


BOOL
IsAutodialEnabled(
    OUT BOOL    *pfForceDial,
    IN AUTODIAL *pConfig
    )

/*++

Routine Description:

    Read flags used to control autodial.  Also honors SetOption setting
    to override and not autodial.

    Note: if autodial isn't enabled, the rest of the structure isn't read.

Arguments:

    pConfig     - AUTODIAL struct to store info.  NULL is valid if info
                  isn't required.

Return Value:

    BOOL
        TRUE    - Autodial is enabled
        FALSE   - Autodial is not enabled

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsAutodialEnabled",
                 "%#x, %#x",
                 pfForceDial,
                 pConfig
                 ));

    HKEY    hKey;
    DWORD   dwRes, dwData = 0, dwSize, dwType;
    BOOL    fConfigured, fEnabled;

    //
    // Init out parameter
    //
    if(pfForceDial)
    {
        *pfForceDial = FALSE;
    }

    if(pConfig)
    {
        memset(pConfig, 0, sizeof(AUTODIAL));
    }

    //
    // Get autodial enabled
    //
    fConfigured = fEnabled = TRUE;

    // check registry setting
    if(InternetReadRegistryDword(REGSTR_VAL_ENABLEAUTODIAL, &dwData) ||
        0 == dwData)
    {
        fEnabled = fConfigured = FALSE;
    }

    if(fEnabled)
    {
        if(InternetReadRegistryDword(REGSTR_VAL_NONETAUTODIAL, &dwData) ||
            0 == dwData)
        {
            // don't use sens -- imitate IE4 and before behavior
            if(pConfig)
            {
                pConfig->fForceDial = TRUE;
            }
            if(pfForceDial)
            {
                *pfForceDial = TRUE;
            }
        }

        // update fEnabled based on api setting
        fEnabled = g_fAutodialEnableAPISetting;
    }


    if(NULL == pConfig)
    {
        DEBUG_LEAVE(fEnabled);
        return fEnabled;
    }

    //
    // save enabled to pconfig struct
    //
    pConfig->fEnabled = fEnabled;

    pConfig->fConfigured = fConfigured;


    //
    // read security check
    //
    dwSize = sizeof(dwData);
    if( GlobalPlatformType == PLATFORM_TYPE_WIN95 &&
        InternetReadRegistryDword(szRegValEnableSecurityCheck, &dwData) == ERROR_SUCCESS &&
        dwData)
    {
        pConfig->fSecurity = TRUE;
    }

    if(FALSE == fEnabled)
    {
        // if autodial isn't enabled, no point in reading the rest of the
        // info because it isn't used
        DEBUG_LEAVE(fEnabled);
        return fEnabled;
    }

    //
    // read connectoid name
    //
    CHAR szConnectoidName[RAS_MaxEntryName + 1];
    if(ERROR_SUCCESS == GetAutodialConnection(szConnectoidName, RAS_MaxEntryName))
    {
        MultiByteToWideChar(CP_ACP, 0, szConnectoidName, -1, pConfig->pszEntryName, RAS_MaxEntryName);
    }
    else
    {
        pConfig->pszEntryName[0] = 0;
    }

    if(lstrlenW(pConfig->pszEntryName))
    {
        pConfig->fHasEntry = TRUE;

        // if possible, verify that autodial entry actually exists
        RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

        if (pRasProp)
        {
            if(pRasProp->GetError() == 0)
            {
                DWORD dwRet = pRasProp->GetW(pConfig->pszEntryName);
                if((ERROR_SUCCESS != dwRet) && (ERROR_INVALID_FUNCTION != dwRet))
                {
                    // ras doesn't know about this - blow it away
                    pConfig->fHasEntry = FALSE;
                    *pConfig->pszEntryName = 0;
                }
            }
            delete pRasProp;
        }
    }

    if(FALSE == pConfig->fHasEntry && (FALSE == DoConnectoidsExist()))
    {
        // We expect an entry at this point.  If we don't and none exist at
        // this point, autodial isn't, in fact, enabled.
        pConfig->fEnabled = FALSE;
        pConfig->fForceDial = FALSE;

        if(pfForceDial)
        {
            *pfForceDial = FALSE;
        }
    }

    //
    // read autoconnect for the specified entry
    //
    if(pConfig->fHasEntry)
    {
        WCHAR   szKey[MAX_PATH];

        GetConnKeyW(pConfig->pszEntryName, szKey, ARRAYSIZE(szKey));
        dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey,
                REGSTR_DIAL_AUTOCONNECTW, &dwType, &dwData, &dwSize) &&
                dwData)
        {
            pConfig->fUnattended = TRUE;
        }
    }

    DEBUG_LEAVE(pConfig->fEnabled);
    return pConfig->fEnabled;
}


UINT_PTR
SendDialmonMessage(
    UINT    uMessage,
    BOOL    fPost
    )

/*++

Routine Description:

    Send a message to dialmon

Arguments:

    uMessage    - message to send
    fPost       - post or send

Return Value:

    Return of send or 0 if post

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "SendDialmonMessage",
                 "%x, %B",
                 uMessage,
                 fPost
                 ));

    UINT_PTR    uRet = 0;

    // Send a message to dialmon's monitor window to start monitoring this
    // connectoid
    if(NULL == g_hwndWebCheck) {
        g_hwndWebCheck = FindWindow(szWebCheckMonitorClass,NULL);
    }
    if(g_hwndWebCheck) {
        if(fPost)
        {
            PostMessage(g_hwndWebCheck, uMessage, 0, 0);
        }
        else
        {
            uRet = SendMessage(g_hwndWebCheck, uMessage, 0, 0);
        }
    }

    DEBUG_LEAVE(uRet);
    return uRet;
}


BOOL
GetRedialParameters(
    IN LPWSTR pszConn,
    OUT LPDWORD pdwDialAttempts,
    OUT LPDWORD pdwDialInterval
    )

/*++

Routine Description:

    Get redial information for a specific connectoid

Arguments:

    pszConn         - connection name
    pdwDialAttempts - location to store dial attempts
    pdwDialInterval - location to store dial interval

Return Value:

    BOOL
        TRUE        - success
        FALSE       - failure

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "GetRedialParameters",
                 "%#x (%Q), %x, %x",
                 pszConn,
                 pszConn,
                 pdwDialAttempts,
                 pdwDialInterval
                 ));

    WCHAR   szKey[MAX_PATH];
    DWORD   dwValue, dwSize;
    HKEY    hkey;

    //
    // validate and clear out variables
    //
    if(NULL == pdwDialAttempts || NULL == pdwDialInterval)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // set to defaults
    //
    *pdwDialAttempts = DEFAULT_DIAL_ATTEMPTS;
    *pdwDialInterval = DEFAULT_DIAL_INTERVAL;

    //
    // read values from registry
    //
    GetConnKeyW(pszConn, szKey, ARRAYSIZE(szKey));
    dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALATTEMPTSW, NULL, &dwValue, &dwSize) && dwValue)
    {
        *pdwDialAttempts = dwValue;
    }

    dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALINTERVALW, NULL, &dwValue, &dwSize) && dwValue)
    {
        *pdwDialInterval = dwValue;
    }

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                        Win9x security check
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// stolen from ICW's wizglob.h -- BUGBUG - add to our tree
#define INSTANCE_PPPDRIVER       0x0002
typedef DWORD (WINAPI * ICFGISFILESHARINGTURNEDON  )  (DWORD dwfDriverType, LPBOOL lpfSharingOn);


BOOL
IsSharingEnabled(
    VOID
    )

/*++

Routine Description:

    Silently determine whether sharing is turned on on PPP devices on Win9x

Arguments:

    none

Return Value:

    BOOL
        TRUE    - sharing on
        FALSE   - sharing off (or NT)

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsSharingEnabled",
                 NULL
                 ));

    ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn=NULL;
    HINSTANCE hICFGInst = NULL;
    BOOL fSharingIsOn = FALSE;

    //
    // Bail out on NT
    //
    if(PLATFORM_TYPE_WINNT == GlobalPlatformType)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    else
    {
        hICFGInst = LoadLibraryA("icfg95.dll");
    }

    //
    // Try and get entry point in icfg95.dll to check
    //
    if(hICFGInst)
    {
        DWORD dwRet;
        lpIcfgIsFileSharingTurnedOn = (ICFGISFILESHARINGTURNEDON)GetProcAddress( hICFGInst, "IcfgIsFileSharingTurnedOn");
        if(lpIcfgIsFileSharingTurnedOn)
            dwRet = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingIsOn);

        FreeLibrary(hICFGInst);
    }

    DEBUG_LEAVE(fSharingIsOn);
    return fSharingIsOn;
}


DWORD
PerformSecurityCheck(
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    )

/*++

Routine Description:

    Prompt user to fix sharing on PPP device on Win9x.  Reboot if necessary.

Arguments:

    hwndParent  - parent window for any UI
    dwFlags     - flags possibly containing INTERNET_AUTODIAL_FAILIFSECURITYCHECK

Return Value:

    BOOL
        TRUE    - failed test, may be rebooting
        FALSE   - passed test

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "PerformSecurityCheck",
                 "%#x, %#x",
                 hwndParent,
                 dwFlags
                 ));

    static BOOL fDoneCheckOnce = FALSE;
    BOOL fNeedRestart = FALSE;
    HINSTANCE hinstInetWiz;
    INETPERFORMSECURITYCHECK lpInetPerformSecurityCheck;
    CHAR szFilename[SMALLBUFLEN+1]="";

    // only do this once per session, never on NT
    if(PLATFORM_TYPE_WINNT == GlobalPlatformType || fDoneCheckOnce)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    fDoneCheckOnce = TRUE;

    if(dwFlags & (INTERNET_AUTODIAL_FAILIFSECURITYCHECK | INTERNET_DIAL_UNATTENDED | INTERNET_AUTODIAL_FORCE_UNATTENDED))
    {
        if(IsSharingEnabled())
        {
            // silent check failed
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }

    // get filename out of resource
    LoadString(GlobalDllHandle,IDS_INETCFG_FILENAME,szFilename,
        sizeof(szFilename));

    // load the inetcfg dll
    hinstInetWiz = LoadLibrary(szFilename);
    INET_ASSERT(hinstInetWiz);
    if (hinstInetWiz) {

        // get the proc address
        lpInetPerformSecurityCheck = (INETPERFORMSECURITYCHECK)
            GetProcAddress(hinstInetWiz,szInetPerformSecurityCheck);
        INET_ASSERT(lpInetPerformSecurityCheck);
        if (lpInetPerformSecurityCheck)
        {
            // call the function to do system security check
            (lpInetPerformSecurityCheck) (hwndParent, &fNeedRestart);
        }

        FreeLibrary(hinstInetWiz);

        if(fNeedRestart)
        {
            // call RestartDialog in shell32
            HINSTANCE hShell = LoadLibrary("shell32.dll");
            _RESTARTDIALOG pfnRestart = NULL;

            if(hShell)
            {
                pfnRestart = (_RESTARTDIALOG)GetProcAddress(hShell, (LPTSTR)59);
                if(pfnRestart)
                    (*pfnRestart)(NULL, NULL, EWX_REBOOT);
                FreeLibrary(hShell);
            }
        }
    }

    DEBUG_LEAVE(fNeedRestart);
    return fNeedRestart;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                      Custom Dial Handler code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


BOOL
IsCDH(
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh
    )

/*++

Routine Description:

    Determine whether a connection uses a custom dial handler

Arguments:

    pszEntryName    - connection name
    pcdh            - pointer to structure to hold cdh info

Return Value:

    BOOL
        TRUE    - connection uses custom dial handler
        FALSE   - doesn't

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsCDH",
                 "%#x (%Q), %#x",
                 pszEntryName,
                 pszEntryName,
                 pcdh
                 ));

    //
    // clear out cdhinfo
    //
    memset(pcdh, 0, sizeof(CDHINFO));

    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType)
    {
        //
        // Check registry settings on Win9x
        //

        WCHAR szKey[MAX_PATH];
        DWORD dwType;
        DWORD cbDllName = sizeof(pcdh->pszDllName);
        DWORD cbFcnName = sizeof(pcdh->pszFcnName);
        wnsprintfW(szKey, MAX_PATH, L"%ws\\%ws", szRegPathRNAProfileW, pszEntryName);

        if((ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, szRegValAutodialDllNameW, &dwType, (LPBYTE) pcdh->pszDllName, &cbDllName)) &&
           (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, szRegValAutodialFcnNameW, &dwType, (LPBYTE) pcdh->pszFcnName, &cbFcnName)))
        {
            // try to read flags - not critical if can't find it
            DWORD cbFlags   = sizeof(DWORD);
            SHGetValueW(HKEY_CURRENT_USER, szKey, szRegValAutodialFlagsW, &dwType, (LPBYTE) &(pcdh->dwHandlerFlags), &cbFlags);
            if(0 == cbFlags)
                pcdh->dwHandlerFlags = 0;

            // if we got dll / fcn, we have a handler
            pcdh->fHasHandler = TRUE;

            // ICW's isign32.dll registers itself as a CDH but does no useful work.  Ignore it.
            // Note this could distinguish isign32.dll a little better -- right now it will
            // incorectly find "aolisign32.dll" if such a thing were to exist.
            if( StrStrIW(pcdh->pszDllName, L"isign32.dll") &&
                StrStrIW(pcdh->pszFcnName, L"AutodialLogon"))
            {
                // nuke it
                memset(pcdh, 0, sizeof(CDHINFO));
            }
        }
    }
    else
    {
        //
        // No such this as a "CDH" on Win2k as defined by this mechanism.
        // On Win2K, there's a new field in the rasentry struct specifically
        // for this.  See the function DialIfWin2KCDH.
        //
        // Always return FALSE for CDH on Win2K.
        //
        if(FALSE == GlobalPlatformVersion5)
        {
            //
            // NT4 - this is broken -- we look in the RASENTRY struct for autodial
            // function and dll but these fields are intended for use by NT's
            // autodial code, NOT IE's.  Prototypes are different and we only
            // get by by luck - if NT finds these entries, it tries to find an
            // A or W version of the exported function.  CM is the only guy that
            // does this and they don't export decorated A or W versions.  Since
            // NT can't find the function, it ignores the entries.
            //
            // This problem disappears on NT5 -- CM has thier own connectoid
            // type. (Custom dial handlers in general won't be supported)
            //
            RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

            if (pRasProp)
            {
                if((0 == pRasProp->GetError()) && (0 == pRasProp->GetW(pszEntryName)))
                {
                    // got entry, if there is custom dial fields, copy them to our
                    // struct
                    if(pRasProp->GetAutodiallDllW() && pRasProp->GetAutodialFuncW())
                    {
                        StrCpyNW(pcdh->pszDllName, pRasProp->GetAutodiallDllW(), sizeof(pcdh->pszDllName));
                        StrCpyNW(pcdh->pszFcnName, pRasProp->GetAutodialFuncW(), sizeof(pcdh->pszFcnName));
                        pcdh->fHasHandler = TRUE;
                    }
                }
                delete pRasProp;
            }
        }
    }

    DEBUG_LEAVE(pcdh->fHasHandler);
    return pcdh->fHasHandler;
}

BOOL
CallCDH(
    IN HWND hwndParent,
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh,
    IN DWORD dwOperation,
    OUT LPDWORD lpdwResult
    )

/*++

Routine Description:

    Call a custom dial handler to perform an operation

Arguments:

    hwndParent      - parent window for any ui
    pszEntryName    - connection name
    pcdh            - pointer to structure to hold cdh info
    dwOperation     - a CDH operation to perform, one of the
                        INTERNET_CUSTOMDIAL_* operations.
    lpdwResult      - result of CDH operation

        ERROR_SUCCESS - operation completed
        ERROR_ALREADY_EXISTS - connection already exists (CM only)
        ERROR_USER_DISCONNECTION - user cancelled operation
        ERROR_INVALID_PARAMETER - CDH failed to load or service request

Returns Value:

    BOOL
        TRUE        - CDH handled operation
        FALSE       - didn't

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "CallCDH",
                 "%#x, %#x (%Q), %#x, %#x, %#x",
                 hwndParent,
                 pszEntryName,
                 pszEntryName,
                 pcdh,
                 dwOperation,
                 lpdwResult
                 ));

    BOOL    fRet = FALSE;

    if(pcdh->fHasHandler)
    {
        // FIXME - verify handler supports requested operation by checking
        // it's flags.  Connection Manager has been known to assert if it's
        // called to do something it doesn't understand.

        HINSTANCE hinstDialerDll = LoadLibraryWrapW(pcdh->pszDllName);
        if (hinstDialerDll)
        {
            PFN_DIAL_HANDLER lpInetDialHandler;
            CHAR szFcnName[MAX_PATH + 1];

            WideCharToMultiByte(CP_ACP, 0, pcdh->pszFcnName, -1, szFcnName, MAX_PATH, NULL, NULL);
            lpInetDialHandler = (PFN_DIAL_HANDLER)GetProcAddress(hinstDialerDll, szFcnName);
            if (lpInetDialHandler)
            {
#ifdef _X86_
                // IBM Global Network is busted in that it expects to be called
                // as cdecl when all other CDHs are stdcall.  To get around
                // this bustitude somewhat, restore esp after the call to get
                // our stack frame back to a point where we won't fault.
                DWORD dwSavedEsp;
                _asm { mov [dwSavedEsp], esp }
#endif

                // Thunk entry name to ansi
                CHAR szEntryName[RAS_MaxEntryName + 1];
                WideCharToMultiByte(CP_ACP, 0, pszEntryName, -1, szEntryName, RAS_MaxEntryName, NULL, NULL);
                fRet = (lpInetDialHandler)(hwndParent, szEntryName, dwOperation, lpdwResult);

#ifdef _X86_
                _asm { mov esp, [dwSavedEsp] }
#endif
            }

            FreeLibrary(hinstDialerDll);
        }
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                           Initialization
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

VOID
InitAutodialModule(
    BOOL    fGlobalDataNeeded
    )

/*++

Routine Description:

    Initialize autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "InitAutodialModule",
                 "%B",
                 fGlobalDataNeeded
                 ));

    // check for global data first - will only ever happen once
    if(fGlobalDataNeeded && !GlobalDataInitialized)
    {
        GlobalDataInitialize();
    }

    // only do this once...
    if(g_fAutodialInitialized)
    {
        DEBUG_LEAVE(0);
        return;
    }

    // make sure internet settings key is open
    EnsureInternetSettingsKeyCached();

    // There is really no reason to acquire a crosprocess mutex
    // We are going to creat a perprocess mutex when services are running. SPP
    // wininet folks will explore whether this has to be expanded to include all processes
    // (Shishir Pardikar)
    
    if (FALSE == GlobalIsProcessNtService)
    {
        // create connection mutex
        g_hConnectionMutex = OpenMutex(SYNCHRONIZE, FALSE, CONNECTION_MUTEX);
        if (g_hConnectionMutex == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
        {
            SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
            if (psa)
            {
                g_hConnectionMutex = CreateMutex(psa, FALSE, CONNECTION_MUTEX);
            }
        }
    }
    else
    {
        g_hConnectionMutex = CreateMutex(NULL, FALSE, NULL);
    }
    INET_ASSERT(g_hConnectionMutex != INVALID_HANDLE_VALUE);
    
    

    // create dial mutex to serialize access to RAS (per process)
    g_hRasMutex = CreateMutex(NULL, FALSE, NULL);
    INET_ASSERT(g_hRasMutex != INVALID_HANDLE_VALUE);

    // create proxy registry mutex to serialize access to registry settings across processes
    g_hProxyRegMutex = OpenMutex(SYNCHRONIZE, FALSE, PROXY_REG_MUTEX);
    if (g_hProxyRegMutex == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        if (psa)
        {
            g_hProxyRegMutex = CreateMutex(psa, FALSE, PROXY_REG_MUTEX);
        }
    }

    INET_ASSERT(g_hProxyRegMutex != INVALID_HANDLE_VALUE);




    if(FALSE == IsAutodialEnabled(NULL, NULL)) {
        // if autodial not enabled, then set the fDontProcessHook flag so we
        // exit our hook proc very quickly and don't interfere with Winsock
        fDontProcessHook = TRUE;
    }

    if(GetModuleHandle("rnaapp.exe"))
    {
        // We're in rnaapp!  Bail all winsock callbacks
        g_fRNAAppProcess = TRUE;
    }
    DEBUG_PRINT(DIALUP, INFO, ("g_fRNAAppProcess = %B\n", g_fRNAAppProcess));

    g_fAutodialInitialized = TRUE;

    DEBUG_LEAVE(0);
}


VOID
ExitAutodialModule(
    VOID
    )

/*++

Routine Description:

    Clean up autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ExitAutodialModule",
                 NULL
                 ));

    // don't do anything if not initialized
    if(FALSE == g_fAutodialInitialized)
    {
        DEBUG_LEAVE(0);
        return;
    }

#ifdef CHECK_SENS
    if(g_hSens) {
        FreeLibrary(g_hSens);
        g_hSens = NULL;
        g_pfnIsNetworkAlive = NULL;
    }
#endif

    // close connection mutex
    if(INVALID_HANDLE_VALUE != g_hConnectionMutex)
    {
        CloseHandle(g_hConnectionMutex);
        g_hConnectionMutex = INVALID_HANDLE_VALUE;
    }

    // close RAS mutex
    if(INVALID_HANDLE_VALUE != g_hRasMutex)
    {
        CloseHandle(g_hRasMutex);
        g_hRasMutex = INVALID_HANDLE_VALUE;
    }

    // close proxy registry mutex
    if(INVALID_HANDLE_VALUE != g_hProxyRegMutex)
    {
        CloseHandle(g_hProxyRegMutex);
        g_hProxyRegMutex = INVALID_HANDLE_VALUE;
    }

    // close user's reg key
    CRefdKey* prk = (CRefdKey*)InterlockedExchangePointer((PVOID*)&g_prkBase, NULL);
    CloseBaseProxyKey(prk);

    if (g_hRasLib)
    {
        FreeLibrary(g_hRasLib);
        g_hRasLib = NULL;
    }

    if(g_hIphlpapi)
    {
        FreeLibrary(g_hIphlpapi);
        g_hIphlpapi = NULL;
        g_pfnGetBestRoute = NULL;
    }

    g_fAutodialInitialized = FALSE;

    DEBUG_LEAVE(0);
}


VOID
ResetAutodialModule(
    VOID
    )

/*++

Routine Description:

    Reset certain state when a global reset is called.  Causes settings
    to be reread and some one-time operations to be redone.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ResetAutodialModule",
                 NULL
                 ));

    // global settings have changed - reset hook to look again
    fDontProcessHook = FALSE;

    // refresh proxy info and next connection
    g_fConnChecked = FALSE;

#ifdef CHECK_SENS
    // refresh our sens state
    g_fSensInstalled = TRUE;
#endif

    // beta 1 hack
    g_fCheckedUpgrade = FALSE;

    // check security context again for HKCU settings
    CRefdKey* prk = (CRefdKey*)InterlockedExchangePointer((PVOID*)&g_prkBase, NULL);
    CloseBaseProxyKey(prk);

    DEBUG_LEAVE(0);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                     Connection management code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#ifdef CHECK_SENS


BOOL
GetSensLanState(
    OUT LPDWORD pdwFlags
    )

/*++

Routine Description:

    Load and query sens to see if any packets have moved on the lan.
    Beware of service not started and/or api dll not present.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - Lan is active
        FALSE   - Lan is not active

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "GetSensLanState",
                 "%#x",
                 pdwFlags
                 ));

    BOOL    fConnected = TRUE;

    // initialize out flags parameter to default - lan connectivity
    *pdwFlags = NETWORK_ALIVE_LAN;

    // If sens isn't around to ask, we have to assume the lan is connected
    
    if(FALSE == g_fSensInstalled)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    //
    // Try to load SENS and get our entry point
    //
    if(NULL == g_hSens) {

        INT_PTR fSensRunning;

        if(PLATFORM_TYPE_WINNT == GlobalPlatformType)
        {
            // check for running service on NT
            fSensRunning = IsServiceRunning("Sens", SERVICE_ACTIVE);
        }
        else
        {
            // check for dialmon loaded bits on Win9x

            //
            // Webcheck creates this named event to track the lifetime of Sens.
            // It's created with CreateEventA so we need to open with with
            // OpenEventA.
            //
            HANDLE hEvent;

            fSensRunning = FALSE;

            hEvent = OpenEventA(SYNCHRONIZE, FALSE, "MS_WebcheckExternalsTerminateEvent");
            if(hEvent)
            {
                fSensRunning = TRUE;
                CloseHandle(hEvent);
            }
        }

        // On win9x check with dialmon to see if sens is running before
        // calling it.  If we call it and it isn't loaded, it'll load itself
        // and defeat the purpose of not loading it.
        if(fSensRunning)
        {
            g_hSens = LoadLibrary("sensapi.dll");
            if(g_hSens) {
                g_pfnIsNetworkAlive = (ISNETWORKALIVE)GetProcAddress(g_hSens, "IsNetworkAlive");
            }
        }
    }

    //
    // Call sens to get its state
    //
    if(g_pfnIsNetworkAlive) {
        fConnected = g_pfnIsNetworkAlive(pdwFlags);
        g_fSensInstalled = TRUE;
        if(fConnected) {
            if(ERROR_SUCCESS != GetLastError()) {
                // sens service not running - must assume lan is available
                g_fSensInstalled = FALSE;
            }
            if(0 == (*pdwFlags & (NETWORK_ALIVE_LAN | NETWORK_ALIVE_AOL)))
            {
                // no AOL or LAN flag, so return no lan connectivity
                fConnected = FALSE;
            }
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("g_fSensInstalled = %B\n", g_fSensInstalled));

    //
    // If sens isn't alive but we managed to load the dll, unload it
    // now as it's useless.  Otherwise, hang on to the dll.  No need to
    // load and unload it all the time.
    //
    if(FALSE == g_fSensInstalled && g_hSens) {
        FreeLibrary(g_hSens);
        g_hSens = NULL;
        g_pfnIsNetworkAlive = NULL;
    }

    DEBUG_LEAVE(fConnected);
    return fConnected;
}



#endif // CHECK_SENS


BOOL
IsDialUpConnection(
    IN BOOL fForceRefresh,
    OUT LPDWORD     lpdwConnectionNum
    )

/*++

Routine Description:

    Determines whether there's a dial-up connection.  Refreshes information
    periodically.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - A dial-up connection exists
        FALSE   - No dial-up connection

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsDialUpConnection",
                 "%B, %x",
                 fForceRefresh,
                 lpdwConnectionNum
                 ));

    static BOOL     fRasLoaded = FALSE;
    DWORD           dwNewTickCount, dwElapsed, dwBytes, dwRes, dwConNum = 0;
    BOOL            fProcessedRecently = FALSE, fRet;

    //
    // Initialize out parameter
    //
    if(lpdwConnectionNum)
    {
        *lpdwConnectionNum = 0;
    }

    //
    // serialize
    //
    WaitForSingleObject(g_hRasMutex, INFINITE);

    //
    // Check out how recently we polled ras
    //
    dwNewTickCount = GetTickCountWrap();
    dwElapsed = dwNewTickCount - g_dwLastDialupTicks;

    //
    // Only refresh if more than MIN... ticks has passed
    //
    if((dwElapsed >= MIN_RNA_BUSY_CHECK_INTERVAL) || fForceRefresh) {
        g_dwLastDialupTicks = dwNewTickCount;
        if(DoConnectoidsExist())
        {
            if(FALSE == fRasLoaded)
                fRasLoaded = EnsureRasLoaded();

            if(fRasLoaded)
            {
                g_RasCon.Enum();
                if(g_RasCon.GetError() == 0)
                    g_dwConnections = g_RasCon.GetConnectionsCount();
                else
                    g_dwConnections = 0;
            }
        }
        else
        {
            g_dwConnections = 0;
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("Found %d connections\n", g_dwConnections));

    if(g_dwConnections > 1 && lpdwConnectionNum)
    {
        //
        // We have more than one connection and caller wants to know which one
        // is the interesting one.  Try to find a VPN connectoid.
        //
        // Note: RasGetEntryPropertiesA doesn't exist on Win95 Gold.  However,
        // you need RAS 1.2 (which has it) for the VPN device so we're ok
        // using it.  If we can't dynaload it for some inexplicable reason,
        // we'll just end up not finding a VPN entry and setting proxy
        // settings to the first connection.
        //
        // Note we use an array of 2 rasentry structures because NT wants to
        // a phone number list after the actual struct and we need space for it.
        // An extra RASENTRY struct is 1700+ bytes so it should be sufficient.
        //
        RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

        if (pRasProp)
        {
            for(dwConNum = 0; dwConNum < g_dwConnections; dwConNum++)
            {
                if(0 == pRasProp->GetW(g_RasCon.GetEntryW(dwConNum)))
                {
                    if(0 == lstrcmpiA(pRasProp->GetDeviceTypeA(), RASDT_Vpn))
                    {
                        DEBUG_PRINT(DIALUP, INFO, ("Found VPN entry: %ws\n",
                            g_RasCon.GetEntryW(dwConNum)));
                        *lpdwConnectionNum = dwConNum;
                        break;
                    }
                }
            }
            delete pRasProp;
        }
    }

    fRet = (BOOL)(g_dwConnections != 0);

    //
    // verify status of connection we're interested in is RASCS_Connected.
    //
    if(fRet)
    {
        RasGetConnectStatusHelp RasGetConnectStatus(g_RasCon.GetHandle(dwConNum));
        dwRes = RasGetConnectStatus.GetError();
        if(dwRes || (RasGetConnectStatus.ConnState() != RASCS_Connected))
        {
            fRet = FALSE;
        }

        DEBUG_PRINT(DIALUP, INFO, ("Connect Status: dwRet=%x, connstate=%x\n", dwRes, RasGetConnectStatus.ConnState()));
    }

    ReleaseMutex(g_hRasMutex);

    DEBUG_LEAVE(fRet);
    return fRet;
}


BOOL
IsLanConnection(
    OUT LPDWORD pdwFlags
    )

/*++

Routine Description:

    Determines whether there's a lan connection.  Refreshes information
    periodically.

    When Sens is present, AOL functionality is retuned as TRUE with
    *pdwFlags = NETWORK_ALIVE_AOL.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - A lan connection exists
        FALSE   - No lan connection

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsLanConnection",
                 "%#x",
                 pdwFlags
                 ));

    static DWORD    dwLastSensTicks = 0;
    static BOOL     fSensState = TRUE;
    static DWORD    dwSensFlags = 0;
    DWORD           dwNewTickCount, dwElapsed;
    BOOL            fRet = TRUE;

    // init out parameter
    INET_ASSERT(pdwFlags);
    *pdwFlags = 0;

#ifdef CHECK_SENS
    //
    // Check connectivity apis to see if lan is really present
    //
    if(fRet)
    {
        dwNewTickCount = GetTickCountWrap();
        dwElapsed = dwNewTickCount - dwLastSensTicks;
        if(dwElapsed >= MIN_SENS_CHECK_INTERVAL)
        {
            fSensState = GetSensLanState(&dwSensFlags);
            dwLastSensTicks = dwNewTickCount;
        }
        fRet = fSensState;
        *pdwFlags = dwSensFlags;
    }
#endif

    DEBUG_LEAVE(fRet);
    return fRet;
}


VOID
CheckForUpgrade(
    VOID
    )

/*++

Routine Description:

    Performs processing that needs to happen when we upgrade to IE5.

    - Migrate proxy and dial settings on upgrade
    - Migrate legacy proxy settings when they change

Arguments:

    None

Return Value:

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CheckForUpgrade",
                 NULL
                 ));

    DWORD   dwMigrateState = 1, dwRet, dwEntries = 0;
    char    szUserName[10];
    DWORD   cbUserNameSize = ARRAYSIZE(szUserName);
    CRefdKey* prkBase = FindBaseProxyKey();

    //
    // Bail out right away if we've already done this 
    // Or if we are running in an NT service such as the usermode portion of webdav redir
    // in order to avoid deadlocks

    // Also check to make sure we're not running as .default or SYSTEM
    
    if(prkBase &&
       (FALSE == g_fCheckedUpgrade) &&
       (FALSE == GlobalIsProcessNtService) &&
       !IsInGUIModeSetup() &&
       !(GlobalPlatformWhistler &&
       GlobalUserName.Get(szUserName,&cbUserNameSize) &&
               (0 == lstrcmpi(szUserName, ".Default") ||
                0 == lstrcmpi(szUserName, "SYSTEM"))))
    {
        LONG lResult;
        DWORD dwType, dwExclude, dwSize = sizeof(DWORD), dwDisp;
        RasEnumHelp *pRasEnum = NULL;
        //
        // Check to see if proxy settings have been migrated
        //
        if(ERROR_SUCCESS != SHGetValue(prkBase->GetKey(),
            REGSTR_PATH_INTERNET_SETTINGS, szMigrateProxy, &dwType, &dwMigrateState, &dwSize))
        {
            dwMigrateState = 0;
        }

        DEBUG_PRINT(DIALUP, INFO, ("dwMigrateState=%d\n", dwMigrateState));

        //
        // set up list of connectoids
        //
        if(DoConnectoidsExist() && EnsureRasLoaded() && FALSE == GlobalDisableNT4RasCheck)
        {
            pRasEnum = new RasEnumHelp;
            if(pRasEnum != NULL)
            {
                dwRet = pRasEnum->GetError();
                dwEntries = pRasEnum->GetEntryCount();
            }
        }

        //
        // Migrate legacy proxy settings to all connections
        //
        if(0 == dwMigrateState)
        {
            INTERNET_PROXY_INFO_EX info;

            // start off with clean proxy struct
            memset(&info, 0, sizeof(info));
            info.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);

            // need to migrate settings
            if(ReadLegacyProxyInfo(szRegPathInternetSettings, &info))
            {
#ifndef UNIX
                // make sure autodiscovery is on
                info.dwFlags |= PROXY_TYPE_AUTO_DETECT;
#endif /* !UNIX */

                // Save proxy settings to for lan
                info.lpszConnectionName = NULL;
                WriteProxySettings(&info, TRUE);

                // Save legacy settings to special location so we can check
                // for change later
                info.lpszConnectionName = LEGACY_SAVE_NAME;
                WriteProxySettings(&info, TRUE);

                //
                // If we're not turning on autodiscovery for dialup connections
                // by default, get rid of it at this point
                //
                if(FALSE == EnableAutodiscoverForDialup())
                {
                    info.dwFlags &= ~PROXY_TYPE_AUTO_DETECT;
                }

                // Save settings for each connectoid
                DWORD i;
                for(i=0; i<dwEntries; i++)
                {
                    info.lpszConnectionName = pRasEnum->GetEntryA(i);
                    WriteProxySettings(&info, TRUE);
                }

                // clean memory possibly allocated by ReadLegacyProxyInfo
                info.lpszConnectionName = NULL; // not allocated, don't free
                CleanProxyStruct(&info);
            }
        }

        //
        // Check to see if other dial-up settings have been migrated
        //

        if(0 == dwMigrateState && dwEntries)
        {
            CHAR    szKey[MAX_PATH];
            DWORD   dwMinutes, dwAttempts, dwInterval, dwWait, i;
            DWORD   dwEnable;

            // read dial attempts and wait
            if(InternetReadRegistryDword(REGSTR_VAL_REDIALATTEMPTS, &dwAttempts))
                dwAttempts = DEFAULT_DIAL_ATTEMPTS;
            if(InternetReadRegistryDword(REGSTR_VAL_REDIALINTERVAL, &dwInterval))
                dwInterval = DEFAULT_DIAL_INTERVAL;

            // Get idle enable
            if(InternetReadRegistryDword(REGSTR_VAL_ENABLEAUTODISCONNECT, &dwEnable) ||
                0 == dwEnable)
            {
                dwEnable = 0;
                dwMinutes = 20;
            }

            // if enabled, get minutes
            if(dwEnable &&
               InternetReadRegistryDword(REGSTR_VAL_DISCONNECTIDLETIME, &dwMinutes))
            {
                dwEnable = 0;
                dwMinutes = 20;
            }

            // enumerate ras entries
            for(i=0; i<dwEntries; i++)
            {
                DWORD dwDisposition;
                HKEY hkey;
                long lRes;

                // migrate settings for this connectoid
                GetConnKeyA(pRasEnum->GetEntryA(i), szKey, ARRAYSIZE(szKey));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_ENABLEAUTODISCONNECT, REG_DWORD, (BYTE *)&dwEnable, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_DISCONNECTIDLETIME, REG_DWORD, (BYTE *)&dwMinutes, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_ENABLEEXITDISCONNECT, REG_DWORD, (BYTE *)&dwEnable, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALATTEMPTS, REG_DWORD, (BYTE *)&dwAttempts, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALINTERVAL, REG_DWORD, (BYTE *)&dwInterval, sizeof(DWORD));
            }
        }

        if(pRasEnum)
            delete pRasEnum;

        //
        // mark setings as migrated so we don't do this again next time
        //
        dwDisp = 1;
        SHSetValueA(prkBase->GetKey(), REGSTR_PATH_INTERNET_SETTINGS,
            szMigrateProxy, REG_DWORD, &dwDisp, sizeof(DWORD));

        if(dwMigrateState)
        {
            // We have already migrated settings.  If legacy settings have
            // changed, update current connection.
            INTERNET_PROXY_INFO_EX saved, current, destination;

            memset(&saved, 0, sizeof(saved));
            saved.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);
            saved.lpszConnectionName = LEGACY_SAVE_NAME;

            memset(&current, 0, sizeof(current));
            current.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);

            memset(&destination, 0, sizeof(destination));
            destination.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);

            if( ReadLegacyProxyInfo(szRegPathInternetSettings, &current) &&
                ERROR_SUCCESS == ReadProxySettings(&saved))
            {
                BOOL fChanged = FALSE;

                //
                // see if they've changed
                //
                if((saved.dwFlags & LEGACY_MIGRATE_FLAGS) != (current.dwFlags & LEGACY_MIGRATE_FLAGS))
                {
                    fChanged = TRUE;
                }
                else
                {
                    // Only check for autoconfig url match if setting is the same and on because
                    // legacy saved for no autoconfig url is to delete the url.
                    if((saved.dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
                       (FALSE == IsConnectionMatch(saved.lpszAutoconfigUrl, current.lpszAutoconfigUrl)))
                    {
                        fChanged = TRUE;
                    }
                }
                if(FALSE == IsConnectionMatch(saved.lpszProxy, current.lpszProxy))
                {
                    fChanged = TRUE;
                }
                if(FALSE == IsConnectionMatch(saved.lpszProxyBypass, current.lpszProxyBypass))
                {
                    fChanged = TRUE;
                }

                // if they have, save to current connection
                if(fChanged)
                {
                    DWORD dwIndex;
                    LPCSTR lpszTemp;

                    // save new legacy settings to check again later
                    current.lpszConnectionName = LEGACY_SAVE_NAME;
                    WriteProxySettings(&current, TRUE);

                    // read existing lan settings
                    destination.lpszConnectionName = NULL;
                    ReadProxySettings(&destination);

                    // fix flags
                    destination.dwFlags = (destination.dwFlags & ~LEGACY_MIGRATE_FLAGS) | (current.dwFlags & LEGACY_MIGRATE_FLAGS);

                    // fix proxy server / override
                    lpszTemp = destination.lpszProxy;
                    destination.lpszProxy = current.lpszProxy;
                    current.lpszProxy = lpszTemp;

                    lpszTemp = destination.lpszProxyBypass;
                    destination.lpszProxyBypass = current.lpszProxyBypass;
                    current.lpszProxyBypass = lpszTemp;

                    // fix autoconfig url
                    lpszTemp = destination.lpszAutoconfigUrl;
                    destination.lpszAutoconfigUrl = current.lpszAutoconfigUrl;
                    current.lpszAutoconfigUrl = lpszTemp;

                    // save it
                    WriteProxySettings(&destination, TRUE);
                }
            }

            saved.lpszConnectionName = NULL;
            current.lpszConnectionName = NULL;
            destination.lpszConnectionName = NULL;
            CleanProxyStruct(&saved);
            CleanProxyStruct(&current);
            CleanProxyStruct(&destination);
        }

        // don't run this code again
        g_fCheckedUpgrade = TRUE;
    }

    CloseBaseProxyKey(prkBase);

    DEBUG_LEAVE(0);
}


DWORD
FixProxySettings(
    IN LPWSTR   pszConnW,
    IN BOOL     fForceUpdate,
    IN DWORD    dwLanFlags
    )

/*++

Routine Description:

    Copy lan or dial-up proxy settings to generic key and tell proxy code
    new proxy information

Arguments:

    pszConn         - connection name to switch to
    fForceUpdate    - set regardless of having set before
    dwLanFlags      - distinguish between LAN and AOL connection

Return Value:

    DWORD
        0           - no proxy for this connection
        1           - proxy exists for this connection

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Int,
                 "FixProxySettings",
                 "%#x (%Q), %B, %#x",
                 pszConnW,
                 pszConnW,
                 fForceUpdate,
                 dwLanFlags
                 ));

    static  TCHAR pszLastConn[RAS_MaxEntryName+1];
    static  DWORD dwEnable = 0;
    CHAR szConn[RAS_MaxEntryName + 1];
    LPSTR pszConn = NULL;

    if(pszConnW != NULL)
    {
        *szConn = '\0';
        pszConn = szConn;
        WideCharToMultiByte(CP_ACP, 0, pszConnW, -1, pszConn, RAS_MaxEntryName, NULL, NULL);
    }

    //
    // Make sure we've listened to any global settings changed that happened
    // in other processes
    //
    if (InternetSettingsChanged()) {
        ChangeGlobalSettings();
    }

    //
    // Ensure upgrade stuff is done
    //
    CheckForUpgrade();

    //
    // Is this connection already fixed?
    //
    if(g_fConnChecked && (FALSE == fForceUpdate)) {
        if((NULL == pszConn && 0 == *pszLastConn) ||
            0 == lstrcmp(pszConn, pszLastConn)) {
            // already fixed this connection

            DEBUG_LEAVE(dwEnable);
            return dwEnable;
        }
    }

    //
    // Get proxy struct for proxy object
    //
    INTERNET_PROXY_INFO_EX info;
    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = pszConn;

    //
    // Read proxy settings for this connection unless it's LAN/AOL
    // in which case we want no proxy
    //
    if(pszConn || 0 == (dwLanFlags & NETWORK_ALIVE_AOL))
    {
        if (ReadProxySettings(&info) != ERROR_SUCCESS)
        {
            DEBUG_LEAVE(dwEnable);
            return dwEnable;
        }
    }

    //
    // Save connection we fixed
    //
    if(NULL == pszConn) {
        // lan
        *pszLastConn = 0;
    } else {
        // connectoid
        lstrcpyn(pszLastConn, pszConn, RAS_MaxEntryName + 1);
    }

    // tell caller if proxy is enabled
    if(info.dwFlags & PROXY_TYPE_PROXY)
    {
        dwEnable = 1;
    }
    else
    {
        dwEnable = 0;
    }

    GlobalProxyInfo.SetProxySettings(&info, FALSE);

    //GlobalProxyInfo.RefreshProxySettings(FALSE);

    //
    // Copy current settings to the legacy reg locations so legacy
    // apps can find them.
    //
    info.lpszConnectionName = LEGACY_SAVE_NAME;
    WriteLegacyProxyInfo(szRegPathInternetSettings, &info, TRUE);
    WriteProxySettings(&info, TRUE);

    // free up memory allocated by ReadProxySettings
    info.lpszConnectionName = NULL; // not allocated, don't free
    CleanProxyStruct(&info);

    //
    // Flag we've checked this at least once so in future we can bail out early
    //
    g_fConnChecked = TRUE;

    DEBUG_LEAVE(dwEnable);
    return dwEnable;
}


BOOL
FixProxySettingsForCurrentConnection(
    IN BOOL fForceUpdate
    )

/*++

Routine Description:

    Figure out the current connection and fix proxy settings for it.
    Basically a cheap, return-no-info version of GetConnectedStateEx used
    by the winsock callback.

Arguments:

    none

Return Value:

    BOOL
        TRUE        - connected
        FALSE       - not connected

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "FixProxySettingsForCurrentConnection",
                 "%B",
                 fForceUpdate
                 ));


    BOOL    fRet, fForceDial;
    DWORD   dwFixEntry;

    //
    // Make sure everything's initialized
    //
    InitAutodialModule(TRUE);

    // serialize connection type stuff
    WaitForSingleObject(g_hConnectionMutex, INFINITE);

    //
    // Check to see if we have a dialup connection
    //
    fRet = IsDialUpConnection(FALSE, &dwFixEntry);
    if(fRet)
    {
        FixProxySettings(g_RasCon.GetEntryW(dwFixEntry), fForceUpdate, 0);
    }

    //
    // If dial always isn't set, check lan setting
    //
    IsAutodialEnabled(&fForceDial, NULL);

    if(FALSE == fRet && FALSE == fForceDial)
    {
        //
        // no ras connections - ensure LAN proxy settings are correct
        //
        DWORD dwFlags;
        fRet = IsLanConnection(&dwFlags);

        //
        // Whether we have a lan connection or not, prop lan proxy settings.
        // This allows unknown connections to use lan settings.
        //
        FixProxySettings(NULL, fForceUpdate, dwFlags);
    }

    ReleaseMutex(g_hConnectionMutex);

    DEBUG_LEAVE(fRet);
    return fRet;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                       Win2K Helper Functions
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
BOOL
DialIfWin2KCDH(
    IN LPWSTR           pszEntry,
    IN HWND             hwndParent,
    IN BOOL             fHideParent,
    OUT DWORD           *lpdwResult,
    OUT DWORD_PTR       *lpdwConnection
    )

/*++

Routine Description:

    Check a connectoid to see if it has a Win2K custom dial handler and if
    so, do the voodoo magic to dial it

Arguments:

    lpParams    - dial params
    hwndParent  - parent window
    fHideParent - if true, hide this window if dialing this connectoid
    lpdwResult  - result of dial (set if return is TRUE)

Return Value:

    BOOL
        TRUE    - Attempted to dial Win2K CDH
        FALSE   - didn't

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "DialIfWin2KCDH",
                 "%x (%Q), %x, %B, %x, %x",
                 pszEntry,
                 pszEntry,
                 hwndParent,
                 fHideParent,
                 lpdwResult,
                 lpdwConnection
                 ));

    DWORD dwRet;
    RasEntryPropHelp *pRasProp = new RasEntryPropHelp;
    BOOL fResult = FALSE;

    if (pRasProp == NULL)
    {
        goto Cleanup;
    }

    if(FALSE == GlobalPlatformVersion5)
    {
        // not on win2k, bag
        goto Cleanup;
    }

    // get props for this connectoid and see if it has a custom dial dll

    if(ERROR_SUCCESS != (dwRet = pRasProp->GetW(pszEntry)))
    {
        // error getting rasentry struct
        goto Cleanup;
    }

    if(NULL == pRasProp->GetCustomDialDllW())
    {
        // no custom dial dll
        goto Cleanup;
    }

    // hide parent window if necessary
    if(fHideParent)
    {
        ShowWindow(hwndParent, SW_HIDE);
    }

    // call rasdialdlg to dial the custom dude
    HMODULE hLib;
    RASDIALDLG rdd;
    _RASDIALDLGW pfnRdd;

    hLib = LoadLibrary("rasdlg.dll");
    if(hLib)
    {
        pfnRdd = (_RASDIALDLGW)GetProcAddress(hLib, "RasDialDlgW");
        if(pfnRdd)
        {
            memset(&rdd, 0, sizeof(rdd));
            rdd.dwSize = sizeof(RASDIALDLG);
            rdd.hwndOwner = hwndParent;
            dwRet = (*pfnRdd)(NULL, pszEntry, NULL, &rdd);
        }
        FreeLibrary(hLib);
    }
    else
    {
        // really bad...
        goto Cleanup;
    }

    // figure out how we did
    if(dwRet)
    {
        DWORD dwEntry;

        // success
        *lpdwResult = ERROR_SUCCESS;

        // find hconn for the thing we just dialed
        if(lpdwConnection)
        {
            if(IsDialUpConnection(TRUE, &dwEntry))
            {
                *lpdwConnection = (DWORD_PTR) g_RasCon.GetHandle(dwEntry);
            }
        }
    }
    else
    {
        // error or cancel
        *lpdwResult = ERROR_USER_DISCONNECTION;

        if(rdd.dwError)
        {
            *lpdwResult = rdd.dwError;
        }
    }

    fResult = TRUE;

Cleanup:
    if (pRasProp)
    {
        delete pRasProp;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                      Winsock callback handler
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

DWORD
CheckForNoNetOverride(
    LPSTR pszHostName
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                Bool,
                "CheckForNoNetOverride",
                "%#x (%q)",
                pszHostName,
                pszHostName
                ));

    DWORD   dwAutodialFlags = 0;
    DWORD   dwFlags;

    if(IsOS(OS_WHISTLERORGREATER) && IsLanConnection(&dwFlags) && ERROR_SUCCESS == LoadWinsock())
    {
        DWORD dwIpAddress;
        DWORD dwError;

        // assume no route and we want to override
        dwAutodialFlags = INTERNET_AUTODIAL_OVERRIDE_NET_PRESENT;

        // First check to see if we have an ip address.
        ADDRINFO Hints;
        LPADDRINFO lpAddrInfo;

        memset(&Hints, 0, sizeof(struct addrinfo));
        Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
        Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
        Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
        Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

        dwError = _I_getaddrinfo(pszHostName, NULL, &Hints, &lpAddrInfo);

        if(ERROR_SUCCESS != dwError)
        {
            // not an ip address, try to resolve name
            Hints.ai_flags = AI_CANONNAME;
            dwError = _I_getaddrinfo(pszHostName, NULL, &Hints, &lpAddrInfo);
        }

        //
        // If we got an IP4 address, check to see if we have a route for it
        //
        if(ERROR_SUCCESS == dwError && (AF_INET == lpAddrInfo->ai_family))
        {
            MIB_IPFORWARDROW bestRoute;
            DWORD dwError = 0;

            if(NULL == g_hIphlpapi)
            {
                g_hIphlpapi = LoadLibrary("iphlpapi.dll");
                if(g_hIphlpapi)
                {
                    g_pfnGetBestRoute = (GETBESTROUTE)GetProcAddress(g_hIphlpapi, "GetBestRoute");
                }
            }

            // snag ip address from lpaddr
            SOCKADDR_IN *paddr = (SOCKADDR_IN *)(lpAddrInfo->ai_addr);
            dwIpAddress = *((unsigned long *)(&paddr->sin_addr));

            if(g_pfnGetBestRoute && (ERROR_SUCCESS == g_pfnGetBestRoute(dwIpAddress, 0, &bestRoute)))
            {
                // got a route, no need to override dial semantics
                DEBUG_PRINT(DIALUP, INFO, ("Found a route to %s, no need to override dial\n", pszHostName));
                dwAutodialFlags = 0;
            }
        }

        UnloadWinsock();
    }

    DEBUG_LEAVE(dwAutodialFlags);
    return dwAutodialFlags;
}


BOOL
InternetAutodialIfNotLocalHost(
    IN LPSTR OPTIONAL pszURL,
    IN LPSTR OPTIONAL pszHostName
    )

/*++

Routine Description:

    Dial so long as we're configured for it and the name passed isn't a
    local host alias.

    Finds:
        'localhost'
        '127.0.0.1' and its aliases
        local machine name from registry or winsock

    If a URL is specified, it's cracked to get the host name.

Arguments:

    pszURL          - url to check for
    pszHostName     - hostname to check for

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                Bool,
                "InternetAutodialIfNotLocalHost",
                "%#x (%q), %#x (%q)",
                pszURL,
                pszURL,
                pszHostName,
                pszHostName
                ));

    CHAR    *pszURLCopy = NULL, *pszLocalHostname;
    BOOL    fLocalHost = FALSE;
    BOOL    fAllocatedBuffer = FALSE;
    BOOL    fRet = TRUE;
    BOOL    fNeedToFix = TRUE;
    DWORD   dwAutodialFlags = 0;

    //
    // Make sure we're all initialized
    //
    InitAutodialModule(TRUE);


    // we bypass this activity in an NT service has disabled autodialing. This special cases
    // this behaviour for the webdav redir. 
    // In future wininet folks will look to see whether this shouldn't be done for all
    // apps disabling autodialing. For now we just avoid the testing hit for the
    // browser folks (Shishir Pardikar)

    if((FALSE == fDontProcessHook) && !(GlobalIsProcessNtService && !IsAutodialEnabled(NULL, NULL)))

    {
        //
        // If we were passed a URL, crack it to get host name
        //
        if(NULL == pszHostName && pszURL)
        {
            DWORD   dwHostNameLength;
            long    error;

            // make a copy of url to crack
            pszURLCopy = new (CHAR[INTERNET_MAX_URL_LENGTH+1]);
            if(NULL == pszURLCopy)
            {
                goto quit;
            }
            fAllocatedBuffer = TRUE;
            lstrcpyn(pszURLCopy, pszURL, INTERNET_MAX_URL_LENGTH);

            // crack it
            error = CrackUrl(pszURLCopy,
                             0,
                             FALSE, // don't escape URL-path
                             NULL,  // don't care about scheme
                             NULL,  // don't care about Scheme Name
                             NULL,
                             &pszHostName,
                             &dwHostNameLength,
                             NULL,  // don't care about port
                             NULL,  // don't care about user name
                             NULL,
                             NULL,  // or password
                             NULL,
                             NULL,  // or object
                             NULL,
                             NULL,  // no extra
                             NULL,
                             NULL
                             );

            if ((error != ERROR_SUCCESS) || (pszHostName == NULL))
            {
                goto quit;
            }

            // null-terminate host name (stomps pszURLCopy buffer)
            pszHostName[dwHostNameLength] = 0;
        }

        //
        // We'd better have a host name by now...
        //
        INET_ASSERT(pszHostName);
        if(NULL == pszHostName)
        {
            goto quit;
        }

        //
        // Check for 'localhost'
        //
        if( 0 == lstrcmpi(pszHostName, "localhost"))
        {
            DEBUG_PRINT(DIALUP, INFO, ("Found localhost\n"));
            fLocalHost = TRUE;
            goto quit;
        }

        //
        // check for 127.0.0.1 or its variants -- use inet_addr if winsock loaded
        //
        if(g_fWinsockLoaded || _I_inet_addr)
        {
            if(ERROR_SUCCESS == LoadWinsock())
            {
                if(0x0100007f == _I_inet_addr(pszHostName))
                {
                    fLocalHost = TRUE;
                }
                UnloadWinsock();
            }
        }
        else
        {
            // winsock not loaded, do the best we can
            if(0 == lstrcmpi(pszHostName, "127.0.0.1"))
            {
                fLocalHost = TRUE;
            }
        }

        if(fLocalHost)
        {
            DEBUG_PRINT(DIALUP, INFO, ("Found 127.0.0.1 alias\n"));
            goto quit;
        }

        //
        // check local machine name
        //
        pszLocalHostname = new (CHAR[INTERNET_MAX_HOST_NAME_LENGTH+1]);
        INET_ASSERT(pszLocalHostname);
        if(pszLocalHostname)
        {
            DWORD dwSize = INTERNET_MAX_HOST_NAME_LENGTH;
            DWORD dwValType;

            // check fully qualified name (only if we know winsock is loaded)
            if(g_fWinsockLoaded || _I_gethostname)
            {
                if(ERROR_SUCCESS == LoadWinsock())
                {
                    if(0 == _I_gethostname(pszLocalHostname, INTERNET_MAX_HOST_NAME_LENGTH))
                    {
                        if(0 == lstrcmpi(pszLocalHostname, pszHostName))
                            fLocalHost = TRUE;
                    }
                    UnloadWinsock();
                }
            }

            if (!fLocalHost &&
                SHGetValue(HKEY_LOCAL_MACHINE,szRegPathTCP,
                szRegValHostName,&dwValType,pszLocalHostname,&dwSize) ==
                ERROR_SUCCESS)
            {
                if(0 == lstrcmpi(pszLocalHostname, pszHostName))
                    fLocalHost = TRUE;
            }

            // also against check computer name in registry, RPC
            // will use this if there's no DNS hostname set
            dwSize = INTERNET_MAX_HOST_NAME_LENGTH;
            if (!fLocalHost &&
                SHGetValue(HKEY_LOCAL_MACHINE, szRegPathComputerName,
                szRegValComputerName,&dwValType,pszLocalHostname,&dwSize) ==
                ERROR_SUCCESS)
            {
                if(0 == lstrcmpi(pszLocalHostname, pszHostName))
                    fLocalHost = TRUE;
            }

            delete pszLocalHostname;
        }

        if(fLocalHost)
        {
            DEBUG_PRINT(DIALUP, INFO, ("Found local machine name\n"));
            goto quit;
        }

        // Check for override of "dial if no net" (ICS host is prime example)
        dwAutodialFlags = CheckForNoNetOverride(pszHostName);

        // not localhost, so need to autodial
        fRet = InternetAutodial(dwAutodialFlags, 0);
        fNeedToFix = FALSE;
    }

quit:
    if(fNeedToFix)
    {
        // Since we're not dialing, ensure correct settings
        FixProxySettingsForCurrentConnection(FALSE);
    }

    if(fAllocatedBuffer)
    {
        delete pszURLCopy;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


extern "C"
VOID
InternetAutodialCallback(
    IN DWORD dwOpCode,
    IN LPCVOID lpParam
    )

/*++

Routine Description:

    Possibly establish a connection prior to a winsock operation.  Called
    by winsock before each operation.

Arguments:

    dwOpCode        - Winsock operation about to be done
    lpParam         - Information about operation

Return Value:

    None.

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 None,
                 "InternetAutodialCallback",
                 "%s (%#x), %#x",
                 InternetMapWinsockCallbackType(dwOpCode),
                 dwOpCode,
                 lpParam
                 ));

    //
    // Make sure we're initialized and have done the process check!
    //
    InitAutodialModule(FALSE);

    //
    // If we're in rnaapp.exe process, bail out now!
    //
    if(g_fRNAAppProcess)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Process is rnaapp.exe! Bailing out!\n"));
        DEBUG_LEAVE_API(0);
        return;
    }

    // return as soon as possible if we know there's nothing for us to do here...

    // keep track of the last time we sent winsock activity messages or
    // checked for RNA activity.  We won't do these things more than once
    // every MIN_RNA_BUSY_CHECK_INTERVAL seconds.  Getting the tick count
    // is extremely cheap so this is a worthwhile optimization.


    BOOL fProcessedRecently = FALSE;
    DWORD dwNewTickCount = GetTickCountWrap();
    DWORD dwElapsed = dwNewTickCount - g_dwLastTickCount;
    if (dwElapsed < MIN_RNA_BUSY_CHECK_INTERVAL) {
        fProcessedRecently = TRUE;
    } else {
        g_dwLastTickCount = dwNewTickCount;
    }

    // we're in the winsock callback so it's safe (ie. cheap) to call winsock
    g_fWinsockLoaded = TRUE;

    if (!fProcessedRecently) {
        // if hidden autodisconnect monitor window is around, send it a message to
        // notify it of winsock activity so it knows we're not idle.
        HWND hwndMonitorApp = FindWindow(szAutodialMonitorClass,NULL);
        if (hwndMonitorApp) {
            PostMessage(hwndMonitorApp,WM_WINSOCK_ACTIVITY,0,0);
        }
        if(NULL == g_hwndWebCheck) {
            g_hwndWebCheck = FindWindow(szWebCheckMonitorClass,NULL);
        }
        if(g_hwndWebCheck) {
            PostMessage(g_hwndWebCheck,WM_WINSOCK_ACTIVITY,0,0);
        }
    }

    //
    // Only continue if we have a callback type that we actually do something
    // with
    //
    switch(dwOpCode)
    {
        case WINSOCK_CALLBACK_CONNECT:
        case WINSOCK_CALLBACK_RECVFROM:
            // we do stuff with these so continue...
            break;
        case WINSOCK_CALLBACK_GETHOSTBYNAME:
            // bail out now for gethostbyname(NULL) else do normal
            // gethostbyname processing.
            if(NULL == lpParam)
            {
                DEBUG_PRINT(DIALUP, INFO, ("Not dialing for gethostbyname(NULL)\n"));
                DEBUG_LEAVE_API(0);
                return;
            }
            break;
        default:
            DEBUG_LEAVE_API(0);
            return;
    }

    //
    // if we're EXPLORER or IEXPLORE and in global offline mode, don't dial
    //
    if (GlobalIsProcessExplorer && IsGlobalOffline())
    {
        DEBUG_LEAVE_API(0);
        return;
    }

    //
    // verify proxy settings are correct for current connection and if
    // we're already connected, bail out!
    //
    if(FixProxySettingsForCurrentConnection(FALSE) || fDontProcessHook)
    {
        DEBUG_LEAVE_API(0);
        return;
    }

    //
    // Look at the specific winsock operation we're doing and bail out if
    // we don't want to dial
    //
    switch (dwOpCode)
    {
        case WINSOCK_CALLBACK_CONNECT:
        case WINSOCK_CALLBACK_RECVFROM:
            // these APIs all have a sockaddr struct as the API-specific
            // parameter, look in struct to find address family.  Don't
            // respond if it's non-TCP.
            INET_ASSERT(lpParam);

            if (lpParam) {
                struct sockaddr_in * psa = (struct sockaddr_in *) lpParam;

                if (AF_INET != psa->sin_family) {
                    // not TCP, don't respond
                    DEBUG_PRINT(DIALUP, INFO, ("Not dialing for non TCP connect\n"));
                    DEBUG_LEAVE_API(0);
                    return;
                }

#if defined(UNIX) && defined(ux10)
                DEBUG_PRINT(DIALUP, INFO, ("IP address: %d.%d.%d.%d\n",
                    ((LPBYTE)&(psa->sin_addr))[0],
                    ((LPBYTE)&(psa->sin_addr))[1],
                    ((LPBYTE)&(psa->sin_addr))[2],
                    ((LPBYTE)&(psa->sin_addr))[3]));
#else
                DEBUG_PRINT(DIALUP, INFO, ("IP address: %d.%d.%d.%d\n",
                    psa->sin_addr.S_un.S_un_b.s_b1,
                    psa->sin_addr.S_un.S_un_b.s_b2,
                    psa->sin_addr.S_un.S_un_b.s_b3,
                    psa->sin_addr.S_un.S_un_b.s_b4));
#endif

                if (0x0100007f == psa->sin_addr.s_addr) {
                    // loop back address, don't respond
                    DEBUG_PRINT(DIALUP, INFO, ("Not dialing for 127.0.0.1\n"));
                    DEBUG_LEAVE_API(0);
                    return;
                }

                //
                // Check to make sure this isn't our local address if possible
                //
                // This is a very rare code path and won't be hit in normal
                // browsing.  Also, winsock is already loaded in this process
                // so LoadWinsock is reasonably cheap.
                //
                // This code is here to fix FrontPage and WinCE.  Those are
                // pretty much the only guys that will ever hit it.
                //
                // [darrenmi] don't attempt to do this if we're on the
                // netware client because gethostbyname(NULL) will fault.
                //

                // how many IPs can the local host have?  16 seems like an
                // excessive amount.
                #define MAX_IP_COUNT    16

                if (FALSE == GlobalRunningNovellClient32 &&
                    FALSE == g_fGetHostByNameNULLFails &&
                    ERROR_SUCCESS == LoadWinsock())
                {
                    // get real ip addresses for this host
                    HOSTENT *ph;

                    __try
                    {
                        ph = _I_gethostbyname(NULL);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        g_fGetHostByNameNULLFails = TRUE;
                        ph = NULL;
                    }
                    ENDEXCEPT

                    if(ph)
                    {
                        int iCount = 0;
                        DWORD dwAddress[MAX_IP_COUNT];

                        while((LPDWORD)(ph->h_addr_list[iCount]) && iCount < MAX_IP_COUNT)
                        {
                            dwAddress[iCount] = *((LPDWORD)(ph->h_addr_list[iCount]));

                            //
                            // don't dial if connecting to this host's ip address
                            //
                            // FrontPage does this.
                            //
                            if(dwAddress[iCount] == psa->sin_addr.s_addr) {
                                DEBUG_PRINT(DIALUP, INFO, ("Not dialing for local host IP address\n"));
                                DEBUG_LEAVE_API(0);
                                return;
                            }

                            iCount++;
                        }

                        //
                        // RFC1918 lists 192.168.x.x as 256 class C networks
                        // for use as non-global addresses.  If this address
                        // is one of these guys and we already have an ip on the
                        // same subnet, don't dial
                        //
                        // WinCE device does this.
                        //
                        if((psa->sin_addr.s_addr & 0x0000FFFF) == 0x0000A8C0)
                        {
                            int i;

                            for(i=0; i<iCount; i++)
                            {
                                if((psa->sin_addr.s_addr & 0x00FFFFFF) == (dwAddress[i] & 0x00FFFFFF))
                                {
                                    // connect to a local subnet we're alreay on.  Don't dial.
                                    DEBUG_PRINT(DIALUP, INFO, ("Not dialing for local 192.168.x.x subnet\n"));
                                    DEBUG_LEAVE_API(0);
                                    return;
                                }
                            }
                        }
                    }
                    UnloadWinsock();
                }
            }
            break;

        case WINSOCK_CALLBACK_GETHOSTBYNAME:
            // a lot of apps do a GetHostByName(<local host name>) first
            // thing to get their hands on a hostent struct, this doesn't
            // constitute wanting to hit the net.  If we get a GetHostByName,
            // compare the host name to the local host name in the registry,
            // and if they match then don't respond to this.
            if (lpParam)
            {
                InternetAutodialIfNotLocalHost(NULL, (LPSTR)lpParam);
                DEBUG_LEAVE_API(0);
                return;
            }
    }

    //
    // Dial...
    //
    InternetAutodial(0, 0);

    DEBUG_LEAVE_API(0);
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                            Public APIs
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

VOID
AUTO_PROXY_DLLS::SaveDetectedProxySettings(
    IN LPINTERNET_PROXY_INFO_EX lpProxySettings,
    IN BOOL fNeedHostIPChk
    )
{
    BOOL fRet;
    BOOL fDialupRet;
    BOOL fConnectionMatch = FALSE;

    //
    // Ensure we're initialized
    //

    InitAutodialModule(TRUE);

    WaitForSingleObject(g_hConnectionMutex, INFINITE);

    // remove settting from last time...
    lpProxySettings->dwAutoDiscoveryFlags &= ~(AUTO_PROXY_FLAG_DETECTION_SUSPECT);

    //
    // Check to see if we have a dialup connection
    //

    DWORD dwFixEntry;
    fRet = IsDialUpConnection(TRUE, &dwFixEntry);

    if(fRet)
    {
        // check for match
        if(lpProxySettings->lpszConnectionName &&
            lstrcmpiA(lpProxySettings->lpszConnectionName, g_RasCon.GetEntryA(dwFixEntry)) == 0)
        {
            fConnectionMatch = TRUE;
        }
    }

    fDialupRet = fRet;

    DWORD dwFlags;

    //
    // no ras connections - ensure LAN proxy settings are correct
    //

    fRet = IsLanConnection(&dwFlags);

    if(fRet)
    {
        if (lpProxySettings->lpszConnectionName == NULL)
        {
            fConnectionMatch = TRUE;
        }
        else if (fDialupRet &&
                 (dwFlags & NETWORK_ALIVE_LAN) &&
                 (lpProxySettings->dwDetectedInterfaceIpCount == 1) &&
                 g_fSensInstalled )
        {
            //
            // At this point our detection results are suspect,
            //  because we are claiming to have a DialUp Adapter,
            //  Net Adapter, and only One IP address for the whole
            //  system.
            //

            lpProxySettings->dwAutoDiscoveryFlags |= AUTO_PROXY_FLAG_DETECTION_SUSPECT;
        }
    }

    if ( fConnectionMatch && !(IsGlobalOffline()))
    {
        LockAutoProxy();

        fRet = TRUE;

        //
        // Do Host IP check to confirm we're still ok, ie on the same connection,
        //  that we began on.
        //

        if ( fNeedHostIPChk )
        {
            DWORD error;
            DWORD * pdwDetectedInterfaceIp = NULL;
            DWORD dwDetectedInterfaceIpCount;

            fRet = FALSE;

            error = GetHostAddresses(&pdwDetectedInterfaceIp,
                                     &dwDetectedInterfaceIpCount);  // will this cause problems with auto-dial?

            if ( error == ERROR_SUCCESS &&
                 dwDetectedInterfaceIpCount == lpProxySettings->dwDetectedInterfaceIpCount)
            {
                fRet = TRUE;
                for (DWORD i = 0; i < dwDetectedInterfaceIpCount; i++)
                {
                    if (pdwDetectedInterfaceIp[i] != lpProxySettings->pdwDetectedInterfaceIp[i] ) {
                        fRet = FALSE;
                        break;
                    }
                }
            }

            if ( pdwDetectedInterfaceIp != NULL) {
                FREE_MEMORY(pdwDetectedInterfaceIp);
            }
        }

        //
        // Now save out all our settings, if we can.
        //

        if (fRet)
        {
            SetProxySettings(lpProxySettings,
                             IsModifiedInProcess(),
                             FALSE /*no overwrite*/);

            if ( ! IsModifiedInProcess() )
            {
                // Need to save results to registry, if we succeed,
                //  then make sure to transfer new version stamp
                if ( WriteProxySettings(lpProxySettings, FALSE) == ERROR_SUCCESS )
                {
                    _ProxySettings.dwCurrentSettingsVersion =
                        lpProxySettings->dwCurrentSettingsVersion;
                }
            }

            // stamp version, so we know we've been updated.
            _dwUpdatedProxySettingsVersion = lpProxySettings->dwCurrentSettingsVersion;
        }

        UnlockAutoProxy();
    }

    ReleaseMutex(g_hConnectionMutex);
    return;
}



INTERNETAPI_(BOOL)
InternetGetConnectedStateExW(
    OUT LPDWORD lpdwFlags,
    OUT LPWSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Determine whether any useful connections exist

    On FALSE, will return information about autodial connection if any

Arguments:

    lpdwFlags       - Location to store flags about current connection
        INTERNET_CONNECTION_MODEM   Modem connection
        INTERNET_CONNECTION_LAN     Network connection
        INTERNET_CONNECTION_PROXY   Proxy in use
        INTERNET_RAS_INSTALLED      Ras is installed on machine
    lpszConnectionName
                    - name of current connection
    dwBufLen        - length of name buffer
    dwReserved      - Must be 0

Return Value:

    BOOL
        TRUE        - connection exists
        FALSE       - no connection exists

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetGetConnectedStateExW",
                 "%#x, %#x, %#x, %#x",
                 lpdwFlags,
                 lpszConnectionName,
                 dwBufLen,
                 dwReserved
                 ));

    BOOL        fRet = FALSE, fProcessedRecently = FALSE, fConfigured = FALSE;
    DWORD       dwFlags = 0;
    DWORD       dwRes = 0, dwBytes, dwEnable = 0;
    AUTODIAL    ad;
    BOOL        fAutodialEnabled;
    static BOOL fSensState = TRUE;

    //
    // Ensure we're initialized
    //
    InitAutodialModule(TRUE);

    //
    // Verify parameters
    //
    if((lpdwFlags && ERROR_SUCCESS != ProbeWriteBuffer(lpdwFlags, sizeof(DWORD))) ||
       (lpszConnectionName && ERROR_SUCCESS != ProbeWriteBuffer(lpszConnectionName, dwBufLen)) ||
       dwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    //
    // If on Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetGetConnectedStateExA)
    {
        CHAR szAnsiName[RAS_MaxEntryName + 1];
        DWORD   dwConnFlags = 0;

        //
        // call RAS one first...
        //
        fRet = _RasInternetGetConnectedStateExA(&dwConnFlags, szAnsiName, RAS_MaxEntryName, dwReserved);

        if(lpszConnectionName)
        {
            MultiByteToWideChar(CP_ACP, 0, szAnsiName, -1, lpszConnectionName, dwBufLen);
        }

        //
        // RAS one fills in everything except PROXY and OFFLINE flags.
        //
        if(dwConnFlags & INTERNET_CONNECTION_MODEM)
        {
            dwEnable = FixProxySettings(lpszConnectionName, FALSE, 0);
        }
        else if(dwConnFlags & INTERNET_CONNECTION_LAN)
        {
            dwEnable = FixProxySettings(NULL, FALSE, 0);
        }

        if(dwEnable)
        {
            dwConnFlags |= INTERNET_CONNECTION_PROXY | INTERNET_CONNECTION_CONFIGURED;
        }

        if(IsGlobalOffline())
        {
            dwConnFlags |= INTERNET_CONNECTION_OFFLINE;
        }

        if(fRet)
        {
            // we now have a connection - if we get into a state where we don't,
            // ask user to go offline
            g_fAskOffline = TRUE;
        }

        // set out flags if caller requested it
        if(lpdwFlags)
        {
            *lpdwFlags = dwConnFlags;
        }

        DEBUG_LEAVE_API(fRet);
        return fRet;
    }

    //
    // Initialize out variables
    //
    if(lpdwFlags)
        *lpdwFlags = 0;

    if(lpszConnectionName)
        *lpszConnectionName = 0;


    WaitForSingleObject(g_hConnectionMutex, INFINITE);


    //
    // Check to see if we have a dialup connection
    //
    DWORD dwFixEntry;
    fRet = IsDialUpConnection(FALSE, &dwFixEntry);

    //
    // Tell caller if RAS is installed
    //
    if(g_fRasInstalled)
    {
        dwFlags |= INTERNET_RAS_INSTALLED;
    }

    if(fRet)
    {
        // this connectoid is connected
        dwFlags |= INTERNET_CONNECTION_MODEM;
        fConfigured = TRUE;

        dwEnable = FixProxySettings(g_RasCon.GetEntryW(dwFixEntry), FALSE, 0);

        // copy name for caller
        if(lpszConnectionName && dwBufLen) {
            StrCpyNW(lpszConnectionName, g_RasCon.GetEntryW(dwFixEntry), dwBufLen);
        }
    }

    //
    // autodial configuration is relevant for finding out if lan is present.
    // if autodial.force is set, consider lan NOT present since we're going
    // to dial anyway.
    //
    fAutodialEnabled = IsAutodialEnabled(NULL, &ad);

    if((FALSE == fRet) && (FALSE == ad.fForceDial))
    {
        //
        // no ras connections - ensure LAN proxy settings are correct
        //
        DWORD dwLanFlags;
        fRet = IsLanConnection(&dwLanFlags);

        if(fRet)
        {
            // lan connection is configured and present
            dwFlags |= INTERNET_CONNECTION_LAN;
            dwEnable = FixProxySettings(NULL, FALSE, dwLanFlags);
            // if call wants name, fill in "lan connection"
            if(lpszConnectionName && dwBufLen)
                LoadStringWrapW(GlobalDllHandle, IDS_LAN_CONNECTION, lpszConnectionName, dwBufLen);
        }
    }


    //
    // turn on proxy flag if necessary
    //
    if(dwEnable)
    {
        dwFlags |= INTERNET_CONNECTION_PROXY;

        // we have some kind of configured connection
        fConfigured = TRUE;
    }


    //
    // If no connection found, tell caller about autodial entry
    //
    if(FALSE == fConfigured ||
       0 == (dwFlags & (INTERNET_CONNECTION_LAN | INTERNET_CONNECTION_MODEM)))
    {
        if(ad.fConfigured)
        {
            // we have an autodial connection
            fConfigured = TRUE;

            if(0 == (dwFlags & (INTERNET_CONNECTION_LAN | INTERNET_CONNECTION_MODEM)))
            {
                // autodial is enabled

                // If the caller cares about entry name, find them one
                if(ad.fHasEntry)
                {
                    // use specified one
                    dwFlags |= INTERNET_CONNECTION_MODEM;
                    if(lpszConnectionName && dwBufLen)
                    {
                        StrCpyNW(lpszConnectionName, ad.pszEntryName, dwBufLen);
                    }
                }
                else
                {
                    // None set as default, pick one and set it
                    RasEnumHelp * pre = new RasEnumHelp;

                    if(pre)
                    {
                        if (pre->GetEntryCount())
                        {
                            LPWSTR pwzName = pre->GetEntryW(0);

                            // set this entry to the default
                            SHSetValueW(HKEY_CURRENT_USER, szRegPathRemoteAccessW, szRegValInternetEntryW,
                                    REG_SZ, (BYTE *)pwzName, lstrlenW(pwzName));

                            // return to caller
                            dwFlags |= INTERNET_CONNECTION_MODEM;
                            if(lpszConnectionName && dwBufLen)
                            {
                                StrCpyNW(lpszConnectionName, pwzName, dwBufLen);
                            }
                        }
                        delete pre;
                    }
                }
            }
        }
    }


    //
    // Tell caller if we have a connection configured
    //
    if(fConfigured)
    {
        dwFlags |= INTERNET_CONNECTION_CONFIGURED;
    }


    //
    // Tell caller if we're offline
    //
    if(IsGlobalOffline())
    {
        dwFlags |= INTERNET_CONNECTION_OFFLINE;
    }

    if(lpdwFlags)
        *lpdwFlags = dwFlags;

#if defined(SITARA)

    //
    // IF we're configured to use a modem,
    //  then go ahead an turn on Sitara
    //

    if (fRet && (dwFlags & INTERNET_CONNECTION_MODEM))
    {
        GlobalHasSitaraModemConn = TRUE;
    }
    else
    {
        GlobalHasSitaraModemConn = FALSE;
    }

#endif // SITARA

    if(fRet)
        // we now have a connection - if we get into a state where we don't,
        // ask user to go offline
        g_fAskOffline = TRUE;

    ReleaseMutex(g_hConnectionMutex);

    DEBUG_LEAVE_API(fRet);
    SetLastError(ERROR_SUCCESS);
    return fRet;
}


INTERNETAPI_(BOOL)
InternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Ansi version of InternetGetConnectedStateExW

Arguments:

    Same as InternetGetConnectedStateExW

Return Value:

    Same as InternetGetConnectedStateExW

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetGetConnectedStateExA",
                 "%#x, %#x, %#x, %#x",
                 lpdwFlags,
                 lpszConnectionName,
                 dwBufLen,
                 dwReserved
                 ));

    WCHAR   szWideName[RAS_MaxEntryName + 1];
    BOOL    fRet;

    //
    // call wide version
    //
    *szWideName = 0;
    fRet = InternetGetConnectedStateExW(lpdwFlags, szWideName, RAS_MaxEntryName, dwReserved);

    //
    // convert wide name to ansi
    //
    if(lpszConnectionName)
    {
        if(ERROR_SUCCESS == ProbeWriteBuffer(lpszConnectionName, dwBufLen))
        {
            int i;
            i = WideCharToMultiByte(CP_ACP, 0, szWideName, -1, lpszConnectionName, dwBufLen, NULL, NULL);
            if(0 == i) {
                // truncated - null terminate
                lpszConnectionName[dwBufLen - 1] = 0;
            }
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);
            fRet = FALSE;
        }
    }

    DEBUG_LEAVE_API(fRet);
    return fRet;
}



INTERNETAPI_(BOOL)
InternetGetConnectedState(
    OUT LPDWORD lpdwFlags,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Get simple information about connected state

Arguments:

    lpdwFlags       - Location to store connection flags

                        xxx

    dwReserved      - must be 0

Return Value:

    BOOL
        Connected   - TRUE

        Not         - FALSE

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetGetConnectedState",
                 "%#x, %#x",
                 lpdwFlags,
                 dwReserved
                 ));

    BOOL fRet = InternetGetConnectedStateExW(lpdwFlags, NULL, 0, dwReserved);

    DEBUG_LEAVE_API(fRet);
    return fRet;
}


BOOL
HandleFlagsForRas(
    IN HWND     hwndParent,
    IN BOOL     fAutodialing,
    IN DWORD    dwFlags,
    OUT DWORD   *pdwRasFlags
    )

/*++

Routine Description:

    Convert InternetDial flags to RasInternetDial flags.  Also directly handle
    any flags that Ras doesn't know about.

    Only ever called on Millennium

Arguments:

    hwndParent      Parent window for any UI
    fAutodialing    We're called from InternetAutodial vs. InternetDial
    dwFlags         InternetDial flags
    dwRasFlags      RasInternetDial flags

Return values:

    TRUE            Success

    FALSE           Abort operation

--*/
  
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "HandleFlagsForRas",
                 "%#x, %B, %#x, %#x",
                 hwndParent,
                 fAutodialing,
                 dwFlags,
                 pdwRasFlags
                 ));

    DWORD   dwResult = ERROR_SUCCESS;

    *pdwRasFlags = 0;

    //
    // Convert flags for directly supported options
    //
    if((dwFlags & INTERNET_DIAL_SHOW_OFFLINE) ||
       (GlobalIsProcessExplorer))                       *pdwRasFlags |= RAS_INTERNET_AUTODIAL_ALLOW_OFFLINE;
    if((dwFlags & INTERNET_DIAL_UNATTENDED) ||
       (dwFlags & INTERNET_AUTODIAL_FORCE_UNATTENDED))  *pdwRasFlags |= RAS_INTERNET_AUTODIAL_UNATTENDED;

//  if(dwFlags & INTERNET_DIAL_FORCE_PROMPT)    not supported

    //
    // Handle offline mode
    //
    if(dwFlags & INTERNET_AUTODIAL_FORCE_ONLINE)
    {
        SetOffline(FALSE);
    }

    //
    // Handle security check -- only if not connected and autodial and check is enabled.
    //
    AUTODIAL    ad;
    DWORD       dwState;

    if(!IsDialUpConnection(FALSE, NULL))
    {
        //
        // Perform check if:
        //
        // - Autodial is enabled OR we're not autodialing
        // - and Security check is enabled
        //
        IsAutodialEnabled(NULL, &ad);

        if((ad.fEnabled || !fAutodialing) && ad.fSecurity)
        {
            if(PerformSecurityCheck(hwndParent, dwFlags))
            {
                // non-silent check failed
                dwResult = ERROR_INTERNET_FAILED_DUETOSECURITYCHECK;
            }
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("Ras Flags=0x%x\n", *pdwRasFlags));

    DEBUG_LEAVE(dwResult);
    return dwResult;
}

VOID
HandleUserCancel(
    IN DWORD dwResult,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Check to see if user cancelled dial and fix appropriate states

Arguments:

    dwResult        - Result of dialing operation -- only care about 
                      USER_DISCONNECTION
    dwFlags         - Dialing flags, only care about SHOW_OFFLINE



Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "HandleUserCancel",
                 "%#x, %#x",
                 dwResult,
                 dwFlags
                 ));

    if(ERROR_USER_DISCONNECTION == dwResult)
    {
        if(GlobalIsProcessExplorer || (dwFlags & INTERNET_DIAL_SHOW_OFFLINE))
        {
            // offline semantics - set offline mode
            SetOffline(TRUE);
        }
        else
        {
            // Normal cancel.  Prevent more dialing attempts.
            fDontProcessHook = TRUE;
        }
    }

    DEBUG_LEAVE(0);
}



DWORD
InternetDialW(
    IN HWND hwndParent,
    IN LPWSTR pszEntryName,
    IN DWORD dwFlags,
    OUT DWORD_PTR *lpdwConnection,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Connect to a specified connectoid

Arguments:

    hwndParent      - parent window for dialing ui

    pszEntryName    - string => connectoid to connect to
                    - empty string ("") => let user choose
                    - NULL => connect to autodial connectoid

    dwFlags         - flags controlling operation:

                        xxx

    lpdwConnection  - location to store connection handle

    dwReserved      - must be 0

Return Value:

    DWORD
        Success - 0

        Failure - Ras or windows error code

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Dword,
                 "InternetDialW",
                 "%#x, %#x (%Q), %#x, %#x, %#x",
                 hwndParent,
                 pszEntryName,
                 pszEntryName,
                 dwFlags,
                 lpdwConnection,
                 dwReserved
                 ));

    DIALSTATE   data;
    BOOL        fConn = FALSE;
    DWORD       dwRet = ERROR_SUCCESS, dwTemp;
    WCHAR       szKey[MAX_PATH];
    AUTODIAL    ad;

    //
    // Ensure we're initialized
    //
    InitAutodialModule(TRUE);

    //
    // ensure reserved field is 0
    //
    if(dwReserved)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // ensure we have a lpdwConnection pointer and initialize it
    //
    if(NULL == lpdwConnection ||
       ERROR_SUCCESS != ProbeWriteBuffer(lpdwConnection, sizeof(DWORD)))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto quit;
    }
    *lpdwConnection = 0;

    //
    // ensure we have a valid pszEntryName (NULL is valid - see below)
    //
    if(pszEntryName && ERROR_SUCCESS != ProbeStringW(pszEntryName, &dwTemp))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // On Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetDialA)
    {
        DWORD dwRasFlags;

        dwRet = HandleFlagsForRas(hwndParent, FALSE, dwFlags, &dwRasFlags);
        if(dwRet)
        {
            // error, need to bail out
            DEBUG_LEAVE_API(dwRet);
            return dwRet;
        }

        CHAR szAnsiName[RAS_MaxEntryName+1];
        CHAR *pszNameToUse = NULL;

        if(pszEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, pszEntryName, -1, szAnsiName, RAS_MaxEntryName, NULL, NULL);
            pszNameToUse = szAnsiName;
        }

        dwRet = _RasInternetDialA(hwndParent, pszNameToUse, dwRasFlags, lpdwConnection, dwReserved);

        //
        // Switch to offline mode if necessary
        //
        HandleUserCancel(dwRet, dwFlags);

        //
        // If connected, send message to dialmon
        //
        CDHINFO cdh;
        DWORD   dwEntry = 0;
  
        if(IsDialUpConnection(TRUE, &dwEntry) && !IsCDH(g_RasCon.GetEntryW(dwEntry), &cdh))
        {
            SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);
        }

        //
        // fix proxy information for new connection
        //
        FixProxySettingsForCurrentConnection(FALSE);

        DEBUG_LEAVE_API(dwRet);
        return dwRet;
    }

    //
    // Check config state
    //
    IsAutodialEnabled(NULL, &ad);

    if(ad.fSecurity)
    {
        if(PerformSecurityCheck(hwndParent, dwFlags))
        {
            DEBUG_LEAVE_API(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
            return ERROR_INTERNET_FAILED_DUETOSECURITYCHECK;
        }
    }

    //
    // Save connectoid name
    //
    memset(&data, 0, sizeof(DIALSTATE));
    data.params.dwSize = sizeof(RASDIALPARAMSW);
    if(pszEntryName && *pszEntryName)
    {
        // use passed connection name as one to dial
        StrCpyNW(data.params.szEntryName, pszEntryName, RAS_MaxEntryName + 1);
    }
    else
    {
        // NULL name passed, use autodial entry if any.  If not, use first
        // one in list (data.params.szEntryName == "")

        if(ad.fEnabled && ad.fHasEntry)
        {
            StrCpyNW(data.params.szEntryName, ad.pszEntryName, RAS_MaxEntryName + 1);
        }
    }

    //
    // Check to see if already have a ras connection
    //
    fConn = IsDialUpConnection(FALSE, NULL);

    //
    // Check to see if there's a custom dial handler
    //
    if(FALSE == fConn)
    {
        CDHINFO cdh;

        memset(&cdh, 0, sizeof(CDHINFO));
        if(IsCDH(data.params.szEntryName, &cdh))
        {
            DWORD dwTmpRetVal;

            if(CallCDH(hwndParent, data.params.szEntryName, &cdh, INTERNET_CUSTOMDIAL_CONNECT, &dwTmpRetVal))
            {
                dwRet = dwTmpRetVal;
                if(ERROR_SUCCESS == dwRet || ERROR_ALREADY_EXISTS == dwRet)
                {
                    // successfully connected
                    dwRet = ERROR_SUCCESS;

                    if(lpdwConnection)
                        *lpdwConnection = (DWORD)CDH_HCONN;

                    // reset last ras poll time to force a check next time
                    g_dwLastDialupTicks = 0;

                    // fix proxy information for new connection
                    WaitForSingleObject(g_hConnectionMutex, INFINITE);
                    FixProxySettings(data.params.szEntryName, FALSE, 0);
                    ReleaseMutex(g_hConnectionMutex);
                }
                else
                {
                    // check to see if user cancelled and go to offline if necessary
                    HandleUserCancel(dwRet, dwFlags);
                }
                dwRet = ERROR_SUCCESS;
                goto quit;
            }

            // else CDH didn't actually do anything - fall through
        }
    }

    if(GlobalPlatformVersion5 && *data.params.szEntryName)
    {
        // check to see if it's a win2k CDH
        if(DialIfWin2KCDH(data.params.szEntryName, hwndParent, FALSE, &dwRet, lpdwConnection))
        {
            // check for cancel and offline mode
            HandleUserCancel(dwRet, dwFlags);

            goto quit;
        }
    }


    //
    // If we still don't have a connection, show our UI to make one
    //
    if(FALSE == fConn)
    {
        DWORD   dwType, dwTemp, dwSize;
        BOOL    fDialedCDH = FALSE;

        //
        // serialize access to our UI
        //

        // If we already are displaying the UI, bring it to the foreground

        // get mutex and check connection again - may have to wait for it and
        // connection status could change
        INET_ASSERT(g_hAutodialMutex);
        WaitForSingleObject(g_hAutodialMutex, INFINITE);

        if(IsDialUpConnection(FALSE, NULL))
        {
            // got a connection in the mean time - bail out
            ReleaseMutex(g_hAutodialMutex);
            DEBUG_LEAVE_API(ERROR_SUCCESS);
            return ERROR_SUCCESS;
        }

        if(IsGlobalOffline())
        {
            // we went offline, then bail out without UI
            ReleaseMutex(g_hAutodialMutex);
            DEBUG_LEAVE_API(ERROR_SUCCESS);
            return ERROR_SUCCESS;
        }


        //
        // Make sure ras is happy
        //
        if(FALSE == EnsureRasLoaded())
        {
            ReleaseMutex(g_hAutodialMutex);
            DEBUG_LEAVE_API(ERROR_NO_CONNECTION);
            return ERROR_NO_CONNECTION;
        }

        //
        // Fire up commctrl
        //
        InitCommCtrl();
        
        if(!g_hDialEvent)
        {
            g_hDialEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        }

        if(!g_hDialEvent)
        {
            return E_FAIL;
        }
        //
        // Dial it
        //
        CDialUI *pdui = new CDialUI(hwndParent);

        if(pdui)
        {
            // make sure we have a reference
            pdui->AddRef();
            dwRet = pdui->StartDial(&data, dwFlags);
            fDialedCDH = pdui->DialedCDH();
            pdui->Release();
        }

        //
        // Shut down commtrl
        //
        ExitCommCtrl();

        //
        // Switch to offline mode if necessary
        //
        HandleUserCancel(data.dwResult, dwFlags);

        //
        // reset last ras poll time to force a check next time and release
        // mutex
        //
        g_dwLastDialupTicks = 0;
        ReleaseMutex(g_hAutodialMutex);

        if(!fDialedCDH)
        {
            //
            // Save connect automatically if it wasn't overridden
            //
            if(0 == (dwFlags & INTERNET_DIAL_FORCE_PROMPT))
            {
                GetConnKeyW(data.params.szEntryName, szKey, ARRAYSIZE(szKey));
                dwTemp = (data.dwFlags & CI_AUTO_CONNECT) ? 1 : 0;
                SHSetValueW(HKEY_CURRENT_USER, szKey, REGSTR_DIAL_AUTOCONNECTW,
                    REG_DWORD, &dwTemp, sizeof(DWORD));
            }
            
            //
            // check to see if we're really connected or not
            //
            if(data.dwResult || NULL == data.hConn)
            {
                if(data.hConn)
                    _RasHangUp(data.hConn);
                dwRet = data.dwResult;
                goto quit;
            }
            
            RasGetConnectStatusHelp RasGetConnectStatus(data.hConn);
            dwRet = RasGetConnectStatus.GetError();
            if(dwRet)
            {
                _RasHangUp(data.hConn);
                goto quit;
            }
            
            if(RasGetConnectStatus.ConnState() != RASCS_Connected)
            {
                _RasHangUp(data.hConn);
                dwRet = ERROR_NO_CONNECTION;
                goto quit;
            }
        }
    }

    //
    // fix proxy information for new connection
    //
    WaitForSingleObject(g_hConnectionMutex, INFINITE);
    FixProxySettings(data.params.szEntryName, FALSE, 0);
    ReleaseMutex(g_hConnectionMutex);

    //
    // reset last ras poll time to force a check next time
    //
    g_dwLastDialupTicks = 0;

    //
    // start disconnect monitoring
    //
    SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);


    //
    // return handle to caller if required
    //
    if(lpdwConnection)
        *lpdwConnection = (DWORD_PTR) data.hConn;

quit:
    SetEvent(g_hDialEvent);
    DEBUG_LEAVE_API(dwRet);
    return dwRet;
}


DWORD
InternetDialA(
    IN HWND hwndParent,
    IN LPSTR pszEntryName,
    IN DWORD dwFlags,
    OUT DWORD_PTR *lpdwConnection,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Wide version of InternetDialA

Arguments:

    Same as InternetDialA

Return Value:

    Same as InternetDialA

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "InternetDialA",
                "%#x, %#x (%q), %#x, %#x, %#x",
                hwndParent,
                pszEntryName,
                pszEntryName,
                dwFlags,
                lpdwConnection,
                dwReserved
                ));

    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szWideEntryName[RAS_MaxEntryName + 1];
    WCHAR *pwzNameToUse = NULL;

    if (pszEntryName)
    {
        if (IsBadStringPtr(pszEntryName, RAS_MaxEntryName + 1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        else
        {
            int i;
            i = MultiByteToWideChar(CP_ACP, 0, pszEntryName, -1, szWideEntryName, RAS_MaxEntryName);
            if(0 == i) 
            {
                // truncated - null terminate
                szWideEntryName[RAS_MaxEntryName] = 0;
            }
            pwzNameToUse = szWideEntryName;
        }
    }
    dwErr = InternetDialW(hwndParent, pwzNameToUse, dwFlags, lpdwConnection, dwReserved);

cleanup:
    DEBUG_LEAVE_API(dwErr);
    return dwErr;
}


DWORD
InternetHangUp(
    IN DWORD_PTR dwConnection,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Hangs up a connection established by InternetDial

Arguments:

    dwConnection    - connection obtained from InternetDial

    dwReserved      - must be 0

Return Value:

    DWORD
        Success - 0

        Failure - Ras or windows error code

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "InternetHangUp",
                "%#x, %#x",
                dwConnection,
                dwReserved
                ));

    DWORD dwRet;

    //
    // If on Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetHangUpA)
    {
        dwRet = _RasInternetHangUpA(dwConnection, dwReserved);

        DEBUG_LEAVE_API(dwRet);
        return dwRet;
    }

    // ensure reserved is 0
    if(dwReserved)
    {
        DEBUG_LEAVE_API(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ensure we're initialized
    //
    if(FALSE == g_fAutodialInitialized)
    {
        InitAutodialModule(FALSE);
    }

    //
    // Best we can do for CDH's is post message to the disconnect monitor.
    // Hopefully it'll do the right thing and disconnect.  Works for MSN
    // at least.
    //
    if(CDH_HCONN == dwConnection)
    {
        //
        // Try to find a CM connection to hang up
        //
        if(IsDialUpConnection(FALSE, NULL))
        {
            CDHINFO cdh;
            DWORD i, dwError;

            for(i=0; i < g_dwConnections; i++)
            {
                if(IsCDH(g_RasCon.GetEntryW(i), &cdh))
                {
                    if(StrStrIW(cdh.pszDllName, szCMDllNameW))
                    {
                        DEBUG_PRINT(DIALUP, INFO, ("Found CM connection to hang up\n"));
                        dwError = _RasHangUp(g_RasCon.GetHandle(i));
                        DEBUG_LEAVE_API(dwError);
                        return dwError;
                    }
                }
            }
        }

        HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
        if (hwndMonitorWnd) {
            PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
        }

        DEBUG_LEAVE_API(0);
        return 0;
    }

    //
    // Load ras
    //
    if(FALSE == EnsureRasLoaded())
    {
        DEBUG_LEAVE_API(ERROR_UNKNOWN);
        return ERROR_UNKNOWN;
    }

    //
    // hang up the connection
    //
    dwRet = _RasHangUp((HRASCONN)dwConnection);

    DEBUG_LEAVE_API(dwRet);
    return dwRet;
}


BOOLAPI InternetSetDialStateA(
    IN LPCSTR lpszEntryName,
    IN DWORD dwState,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Sets current state for a custom dial handler.

    This was broken in IE4 and didn't actually do anything.  Rather than
    leave it in this state, the notion of custom dial state has been
    removed. [darrenmi]

Arguments:

    lpszEntryName   - connectiod to set state for

    dwState         - new connection state

    dwReserved      - must be 0

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more information

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetSetDialStateA",
                "%#x (%q), %#x, %#x",
                lpszEntryName,
                lpszEntryName,
                dwState,
                dwReserved
                ));

// NOTE: When this starts using lpszEntryName, remember to define USES_STRING to activate
// unicode conversions for InternetSetDialStateW.

    if(dwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);

        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    // [darrenmi] I do not expect any client to ever call this api - I don't
    // think any were ever written.  Only possible exception may be CM.
    // If it does call it, I want to know.
#ifdef DEBUG
    OutputDebugString("Wininet.DLL: Unexpected use of dead api, contact darrenmi [x34231]\n");
    OutputDebugString("Wininet.DLL: It is safe to continue past this DebugBreak()\n");
    DebugBreak();
#endif

    DEBUG_LEAVE_API(TRUE);
    return TRUE;
}


BOOLAPI InternetSetDialStateW(
    IN LPCWSTR lpszEntryName,
    IN DWORD dwState,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Wide version of InternetSetDialStateA

Arguments:

    Same as InternetSetDialStateA

Return Value:

    Same as InternetSetDialStateA

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetSetDialStateW",
                "%#x (%Q), %#x, %#x",
                lpszEntryName,
                lpszEntryName,
                dwState,
                dwReserved
                ));

    BOOL fRet;

    //
    // Convert and call multibyte version
    //
#ifdef INTERNETSETDIALSTATE_USES_CONNECTOID
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpConnectoid;

    if (lpszEntryName)
    {
        ALLOC_MB(lpszEntryName, 0, mpConnectoid);
        if (!mpConnectoid.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszEntryName, mpConnectoid);
    }
    fRet = InternetSetDialStateA(mpConnectoid.psStr, dwState, dwReserved);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(DIALUP, dwErr);
    }
#else
    fRet = InternetSetDialStateA(NULL, dwState, dwReserved);
#endif

    DEBUG_LEAVE_API(fRet);
    return fRet;
}


BOOLAPI InternetGoOnlineW(
    IN LPWSTR lpszURL,
    IN HWND hwndParent,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Show UI to ask user whether they wish to go back online.  This is
    triggered by clicking a link that isn't available offline.

Arguments:

    lpszURL         - url that triggered switch (currently not used)

    hwndParent      - parent window for dialog

    dwFlags         - operation control flags (currently not used)
                        INTERENT_GOONLINE_REFRESH
                            This was caused by a refresh rather than a click
                            on an unavailable link

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more information

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetGoOnlineW",
                "%#x (%Q), %#x, %#x",
                lpszURL,
                lpszURL,
                hwndParent,
                dwFlags
                ));

    INT_PTR fRet = TRUE;

    //
    // validate flags
    //
    if(dwFlags & ~INTERENT_GOONLINE_REFRESH)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);

        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    //
    // if already online, we're done
    //
    if(IsGlobalOffline())
    {
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        //
        // Show ui to ask user to go online
        //
        fRet = DialogBoxParamWrapW(GlobalDllHandle, MAKEINTRESOURCEW(IDD_GOONLINE),
            hwndParent, OnlineDlgProc, 0);

        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
    }

    if(fRet)
    {
        //
        // Make sure we're connected.
        //
        SetOffline(FALSE);

        MEMORYPACKET mpUrl;
        if (lpszURL)
        {
            ALLOC_MB(lpszURL, 0, mpUrl);
            if (mpUrl.psStr)
            {
                UNICODE_TO_ANSI(lpszURL, mpUrl);
                fRet = InternetAutodialIfNotLocalHost(mpUrl.psStr, NULL);
            }
            else
            {
                fRet = FALSE;
            }
        }
    }

    DEBUG_LEAVE_API(fRet != 0);
    return (fRet != 0);
}


BOOLAPI InternetGoOnlineA(
    IN LPSTR lpszURL,
    IN HWND hwndParent,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Wide version of InternetGoOnlineA

Arguments:

    Same as InternetGoOnlineA

Return Value:

    Same as InternetGoOnlineA

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetGoOnlineA",
                "%#x (%q), %#x, %#x",
                lpszURL,
                lpszURL,
                hwndParent,
                dwFlags
                ));

    BOOL fRet = FALSE;

    //
    // Convert and call multibyte version
    //
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    LPWSTR lpszWideURL = NULL;

    if (lpszURL)
    {
        int i;
        DWORD dwLen = lstrlenA(lpszURL);
        if((lpszWideURL = (LPWSTR)LocalAlloc(LPTR, (dwLen+1) * sizeof(WCHAR))) != NULL)
        {
            i = MultiByteToWideChar(CP_ACP, 0, lpszURL, -1, lpszWideURL, dwLen);
            if(0 == i)
                lpszWideURL[dwLen] = 0; // truncated - null terminate
        }
    }

    fRet = InternetGoOnlineW(lpszWideURL, hwndParent, dwFlags);

    if(lpszWideURL)
    {
        LocalFree(lpszWideURL);
    }

    DEBUG_LEAVE_API(fRet);
    return fRet;
}


BOOL
InternetAutodial(
    IN DWORD dwFlags,
    IN HWND hwndParent
    )

/*++

Routine Description:

    Dials the internet connectoid

Arguments:

    dwFlags         - flags to control operation

                        xxx

    hwndParent      - parent window for any ui that's displayed

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more info

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetAutodial",
                 "%#x, %#x",
                 dwFlags,
                 hwndParent
                 ));

    AUTODIAL    config;
    DWORD       dwErrorCode = ERROR_INTERNET_INTERNAL_ERROR;
    DWORD       dwRet = ERROR_SUCCESS, dwLanFlags;
    HWND        hwnd = GetDesktopWindow();


    //
    // On Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetAutodialA)
    {
        DWORD   dwRasFlags;

        dwRet = HandleFlagsForRas(hwndParent, TRUE, dwFlags, &dwRasFlags);
        if(dwRet)
        {
            // error, need to bail out
            DEBUG_LEAVE_API(dwRet);
            return dwRet;
        }

        dwRet = _RasInternetAutodialA(dwRasFlags, hwndParent);

        //
        // Switch to offline mode if necessary
        //
        HandleUserCancel(dwRet, dwFlags);

        //
        // If connected, send message to dialmon
        //
        CDHINFO cdh;
        DWORD   dwEntry = 0;
  
        if(IsDialUpConnection(TRUE, &dwEntry) && !IsCDH(g_RasCon.GetEntryW(dwEntry), &cdh))
        {
            SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);
        }

        //
        // fix proxy information for new connection
        //
        FixProxySettingsForCurrentConnection(FALSE);

        //
        // Prop return code
        //
        if(dwRet)
        {
            DEBUG_ERROR(DIALUP, dwRet);
            SetLastError(dwRet);
        }

        DEBUG_LEAVE_API(0 == dwRet);
        return (0 == dwRet);
    }

    // dwFlags - only valid flag is INTERNET_AUTODIAL_FORCE_UNATTENDED
    // Keep ISVs honest about this
    if(dwFlags & ~(INTERNET_AUTODIAL_FLAGS_MASK))
    {
        dwErrorCode = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if(FALSE == g_fAutodialInitialized)
    {
        InitAutodialModule(TRUE);
    }

    // if no parent window was passed, use desktop window
    if(NULL == hwndParent)
    {
        hwndParent = GetDesktopWindow();
    }

    //
    // need connection mutex for FixProxySettings and IsLanConnection
    //
    WaitForSingleObject(g_hConnectionMutex, INFINITE);

    //
    // check to see if we're already connected
    //
    if(IsDialUpConnection(FALSE, &dwRet))
    {
        // make sure proxy settings are correct
        FixProxySettings(g_RasCon.GetEntryW(dwRet), FALSE, 0);
        ReleaseMutex(g_hConnectionMutex);

        // If we're connected by modem, ensure online if necessary
        if(dwFlags & INTERNET_AUTODIAL_FORCE_ONLINE)
        {
            SetOffline(FALSE);
        }

        dwErrorCode = ERROR_SUCCESS;
        goto quit;
    }

    // Check config and make sure we have connectoids if we're supposed to
    // dial one
    if(IsAutodialEnabled(NULL, &config))
    {
        if(FALSE == EnsureRasLoaded())
        {
            config.fEnabled = config.fForceDial = FALSE;
        }
        else
        {
            RasEnumHelp *pRasEnum = new RasEnumHelp;

            if (pRasEnum)
            {
                if (pRasEnum->GetEntryCount() == 0)
                {
                    config.fEnabled = config.fForceDial = FALSE;
                }
                delete pRasEnum;
            }
        }
    }

    if(IsLanConnection(&dwLanFlags) && (FALSE == config.fForceDial))
    {
        if(!config.fEnabled || !(dwFlags & INTERNET_AUTODIAL_OVERRIDE_NET_PRESENT))
        {
            // make sure proxy settings are correct
            FixProxySettings(NULL, FALSE, dwLanFlags);
            ReleaseMutex(g_hConnectionMutex);

            // autodial not necessary
            dwErrorCode = ERROR_SUCCESS;
            goto quit;
        }
    }

    //
    // check if offline and can't go online...
    //
    if( GlobalIsProcessExplorer && IsGlobalOffline() &&
        0 == (dwFlags & INTERNET_AUTODIAL_FORCE_ONLINE)) {

        ReleaseMutex(g_hConnectionMutex);
        dwErrorCode = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    // make sure we're online
    SetOffline(FALSE);

    // make sure we're supposed to dial
    if(FALSE == config.fEnabled) {
        fDontProcessHook = TRUE;
        dwErrorCode = ERROR_SUCCESS;

        DEBUG_PRINT(DIALUP, INFO, ("Unable to find a connection\n"));

        // no connections and can't dial.  Prompt to go offline.
        if(g_fAskOffline)
        {
            // IE5 Beta 1 Hack - Throw up this dialog for explorer or IE
            // Only for now. However, we should introduce an API that
            // allows any app to say that it wants to participate in
            // IE's Offline Mode stuff and all such apps would then
            // get this dialog

            if(GlobalIsProcessExplorer)
            {
                ULONG_PTR uCookie = 0;
                SHActivateContext(&uCookie);
                // Throw up this dialog for explorer.exe or iexplore.exe only
                if(DialogBoxParamWrapW(GlobalDllHandle, MAKEINTRESOURCEW(IDD_GOOFFLINE),
                    hwndParent, GoOfflinePromptDlgProc,(LPARAM) 0))
                {
                    SetOffline(TRUE);
                }
                else
                {
                    g_fAskOffline = FALSE;
                }
                if (uCookie)
                {
                    SHDeactivateContext(uCookie);
                }
            }
        }

        //
        // If we try to hit the net at this point, we want to use the lan
        // settings whatever they are.
        //
        // This is the only place settings get propagated when no connection
        // can be found.
        //
        FixProxySettings(NULL, FALSE, 0);
        ReleaseMutex(g_hConnectionMutex);

        goto quit;
    }

    // if no entry, fill in a bogus one - dialing UI will pick the first
    // one
    if(FALSE == config.fHasEntry) {
        config.pszEntryName[0] = 0;
        config.fHasEntry = TRUE;
    }

    ReleaseMutex(g_hConnectionMutex);

    // Load Ras
    if(FALSE == EnsureRasLoaded()) {
        // Load of ras failed - probably not installed
        fDontProcessHook = TRUE;
        dwErrorCode = ERROR_SERVICE_DOES_NOT_EXIST;
        goto quit;
    }

    //
    // Fix dial flags
    //
    if((dwFlags & INTERNET_AUTODIAL_FORCE_UNATTENDED) && (config.fUnattended))
        dwFlags |= INTERNET_DIAL_UNATTENDED;

    //
    // Dial it
    //
    DWORD_PTR dwHandle;
    dwErrorCode = InternetDialW(hwndParent, config.pszEntryName, dwFlags, &dwHandle, 0);

quit:
    if(dwErrorCode != ERROR_SUCCESS)
    {
        SetLastError(dwErrorCode);
        DEBUG_ERROR(DIALUP, dwErrorCode);
    }
    DEBUG_LEAVE_API(dwErrorCode == ERROR_SUCCESS);

    return((dwErrorCode == ERROR_SUCCESS));
}


BOOLAPI InternetAutodialHangup(
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Finds and hangs up the autodial connection

    If the autodial connection is a CDH, call the CDH to hang it up.  This
    may or may not work depending on whether the CDH supports hanging up.

Arguments:

    dwReserved      - must be 0

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more information

--*/

{
    AUTODIAL    config;
    CDHINFO     cdh;

    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetAutodialHangup",
                 "%#x",
                 dwReserved
                 ));

    DWORD       dwErr = ERROR_SUCCESS;
    int         j = 0;

    // ensure reserved is 0
    if(dwReserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    //
    // On Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetAutodialHangUpA)
    {
        dwErr = _RasInternetAutodialHangUpA(dwReserved);

        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    if(FALSE == g_fAutodialInitialized)
    {
        InitAutodialModule(FALSE);
    }

    // read connectoid - if none or autodial not enabled, bail
    if(FALSE == IsAutodialEnabled(NULL, &config) || FALSE == config.fHasEntry)
        goto quit;

    if(IsCDH(config.pszEntryName, &cdh))
    {
        //
        // If this CDH is CM, bail out here so the RasHangup below happens
        //
        if(NULL == StrStrIW(cdh.pszDllName, szCMDllNameW))
        {
            // ask it to hang up - may or may not do it depending on what it
            // supports
            //
            // This isn't going to work.  CM doesn't like getting commands it
            // doesn't understand.  For now, CDHs don't hang up.  Tough.
            //
            // CallCDH(NULL, config.pszEntryName, &cdh, INTERNET_CUSTOMDIAL_DISCONNECT);
            //
            // Actually, post message to CDH's disconnect monitor.  Works for
            // MSN at least.
            HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
            if (hwndMonitorWnd) {
                PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
            }

            goto quit;
        }
    }

    //
    // See if a ras connection matches the autodial connectoid
    //
    if(IsDialUpConnection(FALSE, NULL))
    {
        //
        // See if any current connections match autodial connection
        //
        DWORD i;

        for(i = 0; i < g_dwConnections; i++)
        {
            if(0 == StrCmpIW(g_RasCon.GetEntryW(i), config.pszEntryName))
            {
                _RasHangUp(g_RasCon.GetHandle(i));
                break;
            }
        }
    }

quit:
    DEBUG_LEAVE_API(TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\debug\convsym\convsym.cxx ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

void _CRTAPI1 main(int, char**);
void usage(void);
VOID InitSymLib(VOID);
VOID TermSymLib(VOID);
LPSTR GetDebugSymbol(DWORD Address, LPDWORD Offset);

void _CRTAPI1 main(int argc, char** argv) {

    char * fni = NULL;
    char * fno = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (fno) {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        } else if (fni) {
            fno = *argv;
        } else {
            fni = *argv;
        }
    }

    if (!fni || !fno) {
        usage();
    }

    FILE * fpi = fopen(fni, "rt");

    if (!fpi) {
        printf("error: cannot open file \"%s\" for read\n", fni);
        exit(1);
    }

    FILE * fpo = fopen(fno, "wt");

    if (!fpo) {
        printf("error: cannot open file \"%s\" for write\n", fno);
        exit(1);
    }

    InitSymLib();

    while (!feof(fpi)) {

        char buf[1024];

        if (!fgets(buf, sizeof(buf), fpi)) {
            break;
        }

        char * p = strstr(buf, "+0x");

        if (p) {

            DWORD val = (DWORD)strtoul(p, NULL, 0);
            DWORD offset;
            char * str = GetDebugSymbol(val, &offset);

            if (str) {
                sprintf(p, "%s+%#x\n", str, offset);
            }
        }
        fwrite(buf, strlen(buf), 1, fpo);
    }
    fclose(fpi);
    fclose(fpo);
    TermSymLib();
}

void usage() {
    printf("usage: convsym <input_file> <output_file>\n"
           );
    exit(1);
}

HMODULE hSymLib = NULL;
SYMINITIALIZE pSymInitialize = NULL;
SYMLOADMODULE pSymLoadModule = NULL;
SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
SYMCLEANUP pSymCleanup = NULL;

VOID InitSymLib(VOID) {
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}

VOID TermSymLib(VOID) {
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}

LPSTR GetDebugSymbol(DWORD Address, LPDWORD Offset) {
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\cookexp.cxx ===
#include <wininetp.h>


#define SZ_COOKIE_EXPORT_HEADER "#  Internet Explorer cookie file, exported for Netscape browsers."
#define IE_LOCAL_PREFIX             "~~local~~"
#define IE_COOKIE_PREFIX            "Cookie:"


void FileTimeToDosTime( FILETIME ft, DWORD* pTime_t);


struct CACHE_ENTRY_INFO_BUFFER : public INTERNET_CACHE_ENTRY_INFO
{
    BYTE _ab[MAX_CACHE_ENTRY_INFO_SIZE];
};


//****************************************************
//
//  FileOutputStream - utility
//

class FileOutputStream
{
public:
    FileOutputStream()
    : m_hFile(INVALID_HANDLE_VALUE), m_fError(FALSE), m_dwLastError(0)
    {
    }

    ~FileOutputStream()
    {
        if( m_hFile != INVALID_HANDLE_VALUE)
            CloseHandle( m_hFile);
    }

    BOOL Load( LPCTSTR szFilename, BOOL fAppend)
    {
        m_hFile = CreateFile( szFilename, GENERIC_WRITE | GENERIC_READ, 0, NULL, 
                              fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);

        if( m_hFile == INVALID_HANDLE_VALUE)
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }

        if( fAppend
            && SetFilePointer( m_hFile, 0, NULL, FILE_END) == 0xFFFFFFFF)
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }

        return TRUE;
    }

    BOOL DumpStr( LPCSTR szString, DWORD cbSize)
    {
        DWORD dwTemp;

        if( m_fError == TRUE)
            return FALSE;
        
        if( WriteFile( m_hFile, szString, cbSize, &dwTemp, NULL) == TRUE)
        {
            return TRUE;
        }
        else
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }
    }

    BOOL WriteBool( BOOL fBool)
    {
        if( fBool == TRUE)
            return DumpStr( "TRUE", sizeof("TRUE") - 1);
        else
            return DumpStr( "FALSE", sizeof("FALSE") - 1);
    }

    BOOL WriteTab()
    {
        return DumpStr( "\t", sizeof('\t'));
    }

    BOOL WriteNSNewline()
    {
        return DumpStr( "\r\n\r\n", sizeof("\r\n\r\n") - 1);
    }

    BOOL IsError()
    {
        return m_fError;
    }

private:
    HANDLE m_hFile;
    BOOL m_fError;
    DWORD m_dwLastError;
};


//****************************************************
//
//  ExportCookieFile
//

// per-line format of Netscape cookie file
//DOMAIN \t is_given_domain(TRUE|FALSE) \t PATH \t secure(TRUE|FALSE) \t time_t(EXPIRES) \t NAME \t VALUE

BOOLAPI ExportCookieFileW( IN LPCWSTR szFilename, IN BOOL fAppend)
{
    MEMORYPACKET mpFilename;
    ALLOC_MB(szFilename,0,mpFilename);
    if (!mpFilename.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(szFilename,mpFilename);

    return ExportCookieFileA( mpFilename.psStr, fAppend);
};



BOOLAPI ExportCookieFileA( IN LPCSTR szFilename, IN BOOL fAppend)
{
    BOOL retVal = FALSE;

    CHAR* cursor;
    DWORD dwTemp;

    FileOutputStream outFile;

    CACHE_ENTRY_INFO_BUFFER *pcei = new CACHE_ENTRY_INFO_BUFFER;

    if (pcei == NULL)
        goto doneExportCookieFile;

    DWORD cbCeiSize = sizeof(*pcei);
    HANDLE hEnumeration = FindFirstUrlCacheEntry( IE_COOKIE_PREFIX, pcei, &cbCeiSize);
    if( hEnumeration == NULL)
        goto doneExportCookieFile;

    if( outFile.Load( szFilename, fAppend) != TRUE)
        goto doneExportCookieFile;

    if( !fAppend)
    {
        outFile.DumpStr( SZ_COOKIE_EXPORT_HEADER, sizeof(SZ_COOKIE_EXPORT_HEADER) - 1);
        outFile.WriteNSNewline();
    }
    
    if( outFile.IsError() == TRUE)
        goto doneExportCookieFile;

    //  enumerate over the cookie cache entries.
    //Each cache entry will have a file which contains multiple cookies,
    //so inside this loop we will be enumerating over individual cookies.
    do
    {
        CHAR* pFileBuf = NULL;
        DWORD cbFileBufSize;
        CHAR* pDomain;

        //Generate the DOMAIN for all the cookies in this entry
        // example Urls in pEntry:
        //  "Cookie:t-franks@amazon.com/"
        //  "Cookie:t-franks@~~local~~/c:\local\path\"
        // The correspondingDomain entry in NS cookie.txt:
        //   "amazon.com"
        //   ""  ->  local paths are empty strings to NS
        cursor = pcei->lpszSourceUrlName; 

        while( *cursor != '@' && *cursor != '\0')
            cursor++;
            
        if( *cursor != '@')
            goto doneWithEntryOnExportCookie;

        pDomain = ++cursor;

        if( StrCmpN( pDomain, IE_LOCAL_PREFIX, sizeof(IE_LOCAL_PREFIX) - 1) != 0) 
        {
            //  if we have a non-local domain, clip off the path.
            while( *cursor != '/' && *cursor != '\0')
                cursor++;

            if( *cursor != '/')
                goto doneWithEntryOnExportCookie;

            *cursor = '\0';
        }
        else
        {
            //  Else local cookies have a blank domain in the Netscape cookie files.
            pDomain[0] = '\0';
        }

        // load the attached file and enumerate through the contained cookies.
        if( (pcei->lpszLocalFileName == NULL)
            || (ReadFileToBuffer( pcei->lpszLocalFileName, (BYTE**)&pFileBuf, &cbFileBufSize) 
                != TRUE))
        {
            goto doneWithEntryOnExportCookie;           
        }
        
        CHAR* pFileCursor;
        pFileCursor = pFileBuf;
        while( pFileCursor < pFileBuf + cbFileBufSize)
        {
            CHAR *pszName, *pszValue, *pszHash, *pszFlags,
                 *pszExpireTimeLow, *pszExpireTimeHigh,
                 *pszLastTimeHigh,  *pszLastTimeLow,
                 *pszDelimiter;
            FILETIME ftExpire;
            DWORD dwFlags;
       
            // Get the first token (cookie name).
            pszName           = StrTokEx(&pFileCursor, "\n");
            if (!pszName)                               // Cookie name.
            {
                // Normal termination of the parse.
                goto doneWithEntryOnExportCookie;
            }

            // Parse the rest of the cookie
            if( *pFileCursor == '\n')
            {
                pszValue = pFileCursor;
                *pszValue = '\0';
                pFileCursor++;
            }
            else
                pszValue          = StrTokEx(&pFileCursor, "\n");      // Cookie value.

            pszHash           = StrTokEx(&pFileCursor, "\n");      // Combo of domain and path.
            pszFlags          = StrTokEx(&pFileCursor, "\n");      // Cookie flags.
            pszExpireTimeLow  = StrTokEx(&pFileCursor, "\n");      // Expire time.
            pszExpireTimeHigh = StrTokEx(&pFileCursor, "\n");             
            pszLastTimeLow    = StrTokEx(&pFileCursor, "\n");      // Last Modified time.
            pszLastTimeHigh   = StrTokEx(&pFileCursor, "\n");
            pszDelimiter      = StrTokEx(&pFileCursor, "\n");      // Delimiter should be "*"

            // Abnormal termination of parse.
            if (!pszDelimiter || pszDelimiter[0] != '*')
            {
                INET_ASSERT(FALSE);
                goto doneWithEntryOnExportCookie;
            }

            // Get the expire time.
            ftExpire.dwLowDateTime  = atoi(pszExpireTimeLow);
            ftExpire.dwHighDateTime = atoi(pszExpireTimeHigh);

            // Get the flags
            dwFlags = atoi(pszFlags);

            //  If this is a session cookie, its non-persistent
            //and shouldn't be saved to file.
            //  (session cookies shouldn't be in the index file, anyhow)
            INET_ASSERT( (dwFlags & COOKIE_SESSION) == 0 ? TRUE : FALSE);
            if( (dwFlags & COOKIE_SESSION) != 0)
                continue;
                
            //  process parsed contents.
            CHAR* pszNSPath;
            DWORD timetExpire;

            // Example IE cookie file:
            // pszHash = "amazon.com/main/"
            // pszHash = "~~local~~/c:\local\path\"
            // corresponding Netscape path format:
            // pszNSPath = "/main/"
            // pszNSPath = "/c|/local/path/"
            cursor = pszHash;

            // move to the first '/'
            while( *cursor != '/' && *cursor != '\0')
                cursor++;
            if( *cursor != '/')
                continue;

            pszNSPath = cursor;
                
            //  If this is a path on the Hard Disk, turn the '\\'s to '/'s
            //and ':'s to '|'s.  (to conform with funky NS format)
            if( StrCmpN( pszHash, IE_LOCAL_PREFIX, sizeof(IE_LOCAL_PREFIX) - 1) == 0)
            {
                while( *cursor != '\0')
                {
                    if( *cursor == '\\')
                        *cursor = '/';

                    if( *cursor == ':')
                        *cursor = '|';

                    cursor++;
                }
            }

            //  convert to Netscape time format
            FileTimeToDosTime( ftExpire, &timetExpire);

            outFile.DumpStr( pDomain, lstrlen( pDomain));
            outFile.WriteTab();
            outFile.WriteBool( TRUE);
            outFile.WriteTab();
            outFile.DumpStr( pszNSPath, lstrlen( pszNSPath));
            outFile.WriteTab();
            outFile.WriteBool( (dwFlags & COOKIE_SECURE) != 0 ? TRUE : FALSE);
            outFile.WriteTab();

            CHAR expireBuffer[16];
            wsprintf( expireBuffer, "%lu", timetExpire);
            outFile.DumpStr( expireBuffer, lstrlen( expireBuffer));
            outFile.WriteTab();

            outFile.DumpStr( pszName, lstrlen( pszName));
            outFile.WriteTab();
            outFile.DumpStr( pszValue, lstrlen( pszValue));
            outFile.WriteNSNewline();
        }
        
    doneWithEntryOnExportCookie:
        if( pFileBuf != NULL)
            delete [] pFileBuf;

        if( outFile.IsError() == TRUE)
            goto doneExportCookieFile;
    }
    while( FindNextUrlCacheEntry( hEnumeration, pcei, &(cbCeiSize = sizeof(*pcei))));

    retVal = TRUE;
    
doneExportCookieFile:

    if (pcei)
        delete pcei;

    if( hEnumeration != NULL)
        FindCloseUrlCache( hEnumeration);

    return retVal;
}

// reverse of part of transformation in InternetTimeFromTime_t
//  A filetime is the numbers of 100 ns since Jan 1, 1601, while
//a dostime is the number of seconds since Jan 1, 1970.
void FileTimeToDosTime( FILETIME ft, DWORD* pTime_t)
{
    //dwl1970Offset is the number of ns from 1601 to 1970
    const DWORDLONG dwl1970Offset = 0x019dae9064bafa80;

    DWORDLONG lVal;
    
    lVal = ft.dwLowDateTime;
    lVal |= Int64ShllMod32( Int64ShllMod32( ft.dwHighDateTime, 16), 16 );

    *pTime_t = (DWORD)((lVal - dwl1970Offset) / 10000000);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\cliauth.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cliauth.cxx

Abstract:

    Contains Schannel/SSPI specific code for handling Client Authenication
    multiplexed between several asynchronous requests using fibers

    Contents:
        CliAuthRefreshCredential
        CliAuthSelectCredential

Author:

    Arthur L Bierer (arthurbi) 13-Jun-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Jun-1996 arthurbi
        Created, based on orginal code from a-petesk.

--*/

#include <wininetp.h>


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

}


CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY()
{
    _error           = ERROR_SUCCESS;
    _iSelected  = -1;
    _ppCertContexts    = (PCCERT_CONTEXT *)
                        ALLOCATE_MEMORY(LMEM_FIXED,
                            sizeof(PCERT_CONTEXT)* CERT_CONTEXT_ARRAY_ALLOC_UNIT);

    if ( _ppCertContexts == NULL ) {
        _error = GetLastError();
    }

    _cAlloced  = CERT_CONTEXT_ARRAY_ALLOC_UNIT;
    _cCertContexts     = 0;

    ClearCreds(_hCreds);
    InitializeCriticalSection(&_cs);
}

void CERT_CONTEXT_ARRAY::Reset(void)
{
    if ( _ppCertContexts )
    {
        for ( DWORD i = 0; i < _cCertContexts; i++ )
        {
            INET_ASSERT(_ppCertContexts[i]);
            CertFreeCertificateContext(_ppCertContexts[i]);
        }
    }
    _cCertContexts = 0;
    
    // It is important that this Free is guarded by a try except.
    // These objects get freed up at dll unload time and there is a circular
    // dependency between winient and schannel which can cause schannel to 
    // get unloaded. If that is the case we could fault here.
    if (!IsCredClear(_hCreds))
    {
        __try 
        {
            g_FreeCredentialsHandle(&_hCreds);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            // do nothing.
        }
    }
}


CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY()
{
    Reset();

    FREE_MEMORY(_ppCertContexts);
    DeleteCriticalSection(&_cs);
}

DWORD
CliAuthSelectCredential(
    IN PCtxtHandle        phContext,
    IN LPTSTR             pszPackageName,
    IN CERT_CONTEXT_ARRAY*  pCertContextArray,
    OUT PCredHandle       phCredential)

/*++

Routine Description:

    Uses a selected Certificate Chain to produce a Credential handle.

    The credential handle will be used by SCHANNEL to produce a valid Client
    Auth session with a server.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    pSelectedCert   - Cert that User wishes us to use for Client Auth with this server.
                       (BUGBUG who should free this? )

    phCredential    - Outgoing SSPI Credential handle that we may generate
                    IMPORTANT: Do not free the credential handle returned by this function.
                    These have to be cached for the lifetime of the process so the user 
                    doesn't get prompted forthe password over and over. Unfortunately there is
                    no ref-counting mechanism on CredHandle's so callers of this function need to 
                    make sure they don't free the handle.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_INTERNET_SECURITY_CHANNEL_ERROR -
                        Call Down to SSPI or WinTrust failed.

                  ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP -
                        Client Auth is not setup on this machine.

--*/

{

     SCHANNEL_CRED CredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     DEFAULT_SECURE_PROTOCOLS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                     };
    SECURITY_STATUS scRet;


    DWORD           i;
    PCERT_BLOB      pBlob;
    DWORD           index;
    DWORD           error;
    PCCERT_CONTEXT  pCert;
    CredHandle      hCreds;

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthSelectCredential",
                 "%#x, %s, %x, %x",
                 phContext,
                 pszPackageName,
                 pCertContextArray,
                 phCredential
                 ));


    INET_ASSERT(phContext);
    INET_ASSERT(pCertContextArray);
    INET_ASSERT(pszPackageName);


    pCertContextArray->LockCredHandle( );

    if ( pCertContextArray->GetArraySize() == 0 )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    // First check and see if the Cert context already has a CredHandle associated with it.
    hCreds = pCertContextArray->GetCredHandle( );

    if (!IsCredClear(hCreds))
    {
        *phCredential = hCreds;
        error = ERROR_SUCCESS;
        goto quit;
    }

    pCert =         pCertContextArray->GetSelectedCertContext();


    //
    // Setup strucutres for AcquireCredentialsHandle call.
    //

    if ( pCert )
    {

        CredData.cCreds = 1;
        CredData.paCred = &pCert;
    }
    InternetReadRegistryDword("SecureProtocols",
                          (LPDWORD)&CredData.grbitEnabledProtocols
                          );

    scRet = g_AcquireCredentialsHandle(
        NULL,
        pszPackageName,
        SECPKG_CRED_OUTBOUND,
        NULL,
        &CredData,
        NULL,
        NULL,
        phCredential,
        NULL);

    error = MapInternetError((DWORD)scRet);
    if (error == ERROR_SUCCESS)
    {
        pCertContextArray->SetCredHandle(*phCredential);
    }

quit:
    pCertContextArray->UnlockCredHandle();
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CliAuthAcquireCertContexts(
    IN  PCtxtHandle        phContext,
    IN  LPTSTR             pszPackageName,
    OUT CERT_CONTEXT_ARRAY** ppCertContextArray
    )

/*++

Routine Description:

    Acquires a List of valid Certificate Chains for use in Client Authentication.

    Gathers an issuer list from the current context, and uses CAPI stored Certificates
    to build a list which will be selected from by the user at a later point.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    phCredential    - Outgoing SSPI Credential handle that we may generate

    ppCertContextArray  - Outgoing List of Certifcate Contexts that can be selected
                        among to generate a Context.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_INTERNET_SECURITY_CHANNEL_ERROR -
                        Call Down to SSPI or WinTrust failed.

                  ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP -
                        Client Auth is not setup on this machine.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthAcquireCertContexts",
                 "%#x, %s, %x",
                 phContext,
                 pszPackageName,
                 ppCertContextArray
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    SECURITY_STATUS scRet;
    DWORD           cCerts;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    PCCERT_CONTEXT pCertContext;
    DWORD error;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    INET_ASSERT(ppCertContextArray);


    INET_ASSERT(*ppCertContextArray == NULL );
    *ppCertContextArray = NULL;

    IssuerListInfo.cIssuers = 0;
    IssuerListInfo.aIssuers = NULL;

    if ( phContext == NULL )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // Attempt to find out whether we have any issuers
    //  from this connection that the Server might have
    //  told us about.
    //
    
    scRet = g_QueryContextAttributes(phContext,
                                   SECPKG_ATTR_ISSUER_LIST_EX,
                                   &IssuerListInfo);

    if(FAILED(scRet))
    {
        error = MapInternetError((DWORD) scRet);
        goto quit;
    }

    cCerts = 0;

    //
    // Create our CertChain Array for keeping CertChains around
    //

    *ppCertContextArray = new CERT_CONTEXT_ARRAY();

    if ( *ppCertContextArray == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = (*ppCertContextArray)->GetError();

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if (g_CertFindChainInStore == NULL || g_CertFreeCertificateChain == NULL)
    {
        // We don't support client-auth unless we have the new crypto dlls
        error = ERROR_CALL_NOT_IMPLEMENTED;
        goto quit;
    }

    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    while (TRUE)
    {
        // Find a certificate chain.
        if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
           ReopenMyCertStore();
        pChainContext = g_CertFindChainInStore(g_hMyCertStore,
                                             X509_ASN_ENCODING,
                                             0,
                                             CERT_CHAIN_FIND_BY_ISSUER,
                                             &FindByIssuerPara,
                                             pChainContext);

        if (pChainContext == NULL)
            break;

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // This could only happen if there is a bug in the crypto code. But we will deal with
        // that and continue looking in any case.
        if (pCertContext == NULL)
        {
            INET_ASSERT(FALSE);
            continue;
        }

        BOOL AcceptCert=FALSE;

        // retrieve key usage field
        BYTE KeyUsage;
        BOOL BKeyUsage = CertGetIntendedKeyUsage(pCertContext->dwCertEncodingType, pCertContext->pCertInfo, &KeyUsage, sizeof(KeyUsage));

        // if there is no key usage field (BKeyUsage is FALSE) or key usage is set to CERT_DIGITAL_SIGNATURE_KEY_USAGE, then accept certificate 
        // as client certificate for SSL auth
        if ( !BKeyUsage || (KeyUsage & CERT_DIGITAL_SIGNATURE_KEY_USAGE))
            AcceptCert = TRUE;         

        if (AcceptCert)
            error = (*ppCertContextArray)->AddCertContext(pCertContext);

        if (error != ERROR_SUCCESS)
        {
            g_CertFreeCertificateChain(pChainContext);
            goto quit;
        }
    }

quit:

    if ( error != ERROR_SUCCESS &&
         *ppCertContextArray != NULL )
    {
        delete *ppCertContextArray;
        *ppCertContextArray = NULL;
    }

    if (IssuerListInfo.aIssuers != NULL)
    {
        g_FreeContextBuffer(IssuerListInfo.aIssuers);
    }

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\cookimp.cxx ===
#include <wininetp.h>
#include <wininet.h>

//#include "..\inc\cookimp.h"

#define NS_COOKIE_IMPORT_KEY        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\NSCookieUpgrade")
#define NS_COOKIE_IMPORT_VERSION    TEXT("Version")
#define NS_COOKIE_IMPORT_FLAG       TEXT("DisableUpgrade")

#define HTML_FILE_EXTENSION         TEXT(".htm")
#define NS_EXE_FILENAME             TEXT("Netscape.exe")
#define NS_COOKIE_FILENAME          TEXT("cookies.txt")

#define OPEN_COMMAND_OF_APP         TEXT("\\shell\\open\\command")
#define NS_APP_PATHS_REG            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Netscape.exe")

#define NS3_COOKIE_REG_PATH         TEXT("Software\\Netscape\\Netscape Navigator\\Cookies")
#define NS3_COOKIE_REG_KEY          TEXT("Cookie File")
#define NS4_USERS_REG_PATH          TEXT("Software\\Netscape\\Netscape Navigator\\Users")
#define NS4_USERPATH_REG_KEY        TEXT("DirRoot")

//  note:  LENGTHOFSTR()'s result includes terminating character
#define LENGTHOFTSTR( x ) (sizeof(x) / sizeof(TCHAR))

bool EndOfLine( CHAR chr );
BOOL InternetTimeFromTime_tA( IN DWORD dwTime, OUT LPSTR lpszTime, /* in-out */ DWORD cbBufferSize );


//--------------------------------------------------------------------
//
//  ImportCookieFile
//

//  parses a Netscape 'cookies.txt' file and adds each cookie using InternetSetCookie
BOOLAPI ImportCookieFileW( IN LPCWSTR szFilename)
{
    MEMORYPACKET mpFilename;
    ALLOC_MB(szFilename,0,mpFilename);
    if (!mpFilename.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(szFilename,mpFilename);

    return ImportCookieFileA( mpFilename.psStr);
};


BOOLAPI ImportCookieFileA( IN LPCSTR szFilename )
{
    BOOL retVal = FALSE;

    HANDLE hFile = (HKEY) INVALID_HANDLE_VALUE;
    LPSTR szFile = NULL;
    DWORD cbFileSize;

    if( ReadFileToBuffer( szFilename, (BYTE**)&szFile, &cbFileSize) != TRUE)
        goto doneImportFile;

    // parse file line by line
    DWORD iPosition;
    iPosition = 0;
    while( iPosition < cbFileSize )
    {
        LPSTR szValue = NULL;
        LPSTR szURL = NULL;

        //   blank lines are ignored
        if( EndOfLine( szFile[iPosition]))
        {
            iPosition++;
            continue;
        }

        //   lines beginning with # are comments
        if( szFile[iPosition] == '#')
        {
            while ( iPosition < cbFileSize && !EndOfLine( szFile[iPosition]))
                iPosition++;

            iPosition++;
            continue;
        }

        //   see CookieFormat text file for the spec of a Netscape 'cookies.txt'
        const DWORD iArgCount = 7;
        enum eArgTypes { DOMAIN=0,UNUSED=1,PATH=2,SECURE=3,EXPIRES=4,NAME=5,VALUE=6 };

        //  parse cookie into 7 fields (szArg[0..6]) with lengths stored in cbArgLength[0..6]
        LPSTR szArg[iArgCount];
        DWORD cbArgLength[iArgCount];

        // Continue parsing fields only if end of line/file hasn't been hit.
        // 'for' is re-entered when the end of each cookie is found:
        //      On re-entry, null terminate the cookie found.
        for( DWORD iArgIndex = 0;
                iPosition < cbFileSize && !EndOfLine( szFile[iPosition]);
                iArgIndex++, szFile[iPosition++] = '\0')
        {
            //  sanity check: are there really only 7 fields?
            if( iArgIndex >= iArgCount )
            {
                INET_ASSERT(FALSE);

                // if there are more than 7 fields, move to where a new cookie should start
                while ( iPosition < cbFileSize && !EndOfLine( szFile[iPosition]))
                    iPosition++;

                // end of invalid cookie found, now increment to next cookie.
                iPosition++;

                goto doneImportCookie;
            }

            //  Mark the beginning of the field.
            szArg[iArgIndex] = &szFile[iPosition];

            //  Find the end of the field.
            while( iPosition < cbFileSize && szFile[iPosition] != '\t' && !EndOfLine( szFile[iPosition]) )
                iPosition++;

            // Calculate the length of the cookie.
            cbArgLength[iArgIndex] = (unsigned long) (&szFile[iPosition] - szArg[iArgIndex]);
        }

        if( iArgIndex < iArgCount )
        {
            //sanity check: Are there enough fields?
            INET_ASSERT(FALSE);
            goto doneImportCookie;
        }

        // build HTTP cookie string in szValue
        DWORD cbValueSize;
        cbValueSize =  cbArgLength[NAME]
                    + cbArgLength[VALUE]
                    + cbArgLength[DOMAIN]
                    + sizeof("=;secure;expires=;domain=")
                    + INTERNET_RFC1123_BUFSIZE
                    + 1;
        szValue = new CHAR[ cbValueSize];

        if( szValue == NULL )
            goto doneImportCookie;

        LPSTR pValueIterator;
        pValueIterator = szValue;

        // add 'name=value' pair
        memcpy( pValueIterator, szArg[NAME], cbArgLength[NAME] );
        pValueIterator += cbArgLength[NAME];
        pValueIterator[0] = '=';
        pValueIterator++;
        memcpy( pValueIterator, szArg[VALUE], cbArgLength[VALUE] );
        pValueIterator += cbArgLength[VALUE];

        //  set security information
        if( szArg[SECURE][0] == 'T' || szArg[SECURE][0] == 't' )
        {
            memcpy( pValueIterator, ";secure", sizeof(";secure") - 1);
            pValueIterator += sizeof(";secure") - 1;
        }

        //  In a path that is on the HD, Netscape's path is like "/c|/directory/filename.ext"
        //  I need the path to read as "/c:\directory\filename.ext".
        if( cbArgLength[DOMAIN] == 0 )
            for( LPSTR pchr = szArg[PATH]; *pchr != '\0'; pchr++ )
            {
                if( *pchr == '|' )
                    *pchr = ':';
                if( *pchr == '/' && pchr != szArg[PATH] )
                    *pchr = '\\';
            }

        //  InternetSetCookie accepts files with a local domain if it isn't
        // explicitly declared.. which related to a bug in InternetSetCookie.
        if( cbArgLength[DOMAIN] != 0 )
        {
            //  add the domain=DOMAIN pair
            memcpy( pValueIterator, ";domain=", sizeof(";domain=") - 1);
            pValueIterator += sizeof(";domain=") - 1;
            memcpy( pValueIterator, szArg[DOMAIN], cbArgLength[DOMAIN]);
            pValueIterator += cbArgLength[DOMAIN];
        }

        //  InternetSetCookie doesn't work right if the path ends in a filename.
        //so I'll stick the path in the szURL parameter (which accepts filenames)
        ////  add the path=PATH pair
        //memcpy( pValueIterator, ";path=", sizeof(";path=") - 1);
        //pValueIterator += sizeof(";path=") - 1;
        //memcpy( pValueIterator, szArg[PATH], cbArgLength[PATH]);
        //pValueIterator += cbArgLength[PATH];

        //  set expiration info
        memcpy( pValueIterator,";expires=", sizeof(";expires=") - 1);
        pValueIterator += sizeof(";expires=") - 1;

        if( InternetTimeFromTime_tA( StrToLong( szArg[EXPIRES]), pValueIterator, INTERNET_RFC1123_BUFSIZE ) != TRUE )
            goto doneImportCookie;

        //  InternetSetCookie requires an URL.. There isn't a complete url in the netscape cookie, but it can
        //be fudged.  The path in the URL will become the path stored for the cookie, the rest is checked for
        //legality then ignored.
        DWORD cbURLSize;
        cbURLSize = sizeof("nnnn://")
            + cbArgLength[DOMAIN]
            + cbArgLength[PATH]
            + 1;
        szURL = new CHAR[ cbURLSize];

        if( szURL == NULL )
            goto doneImportCookie;

        LPSTR pURLIterator;
        pURLIterator = szURL;

        if( szArg[DOMAIN][0] == '\0')
        {
            memcpy( pURLIterator, "file:/", sizeof("file:/") - 1);
            pURLIterator += sizeof("file:/") - 1;
            memcpy( pURLIterator, szArg[PATH], cbArgLength[PATH]);
            pURLIterator += cbArgLength[PATH];
        }
        else
        {
            memcpy( pURLIterator, "http://", sizeof("http://") - 1);
            pURLIterator += sizeof("http://") - 1;
            memcpy( pURLIterator, szArg[DOMAIN], cbArgLength[DOMAIN]);
            pURLIterator += cbArgLength[DOMAIN];
            memcpy( pURLIterator, szArg[PATH], cbArgLength[PATH]);
            pURLIterator += cbArgLength[PATH];
        }
        pURLIterator[0] = '\0';

        //  don't overwrite exisiting cookies.
        DWORD dwTemp;
        CHAR szNullTerminatedName[ MAX_PATH];
        memcpy( szNullTerminatedName, szArg[NAME], cbArgLength[NAME]);
        szNullTerminatedName[ cbArgLength[NAME]] = '\0';
        if( InternetGetCookieEx( szURL, szNullTerminatedName,
            NULL, &dwTemp, 0, NULL) == TRUE)
        {
            // this cookie exists!  don't import.
            goto doneImportCookie;
        }

        DEBUG_PUT(( "\n\nCalled InternetSetCookie with\nUrl:%s\nValue:%s", szURL,  szValue));

#ifdef UNICODE
#error "ImportCookieFile(): InternetSetCookieA needs to be called directly from here."
#endif
        if( InternalInternetSetCookie( szURL, NULL, szValue, COOKIE_NOUI, NULL ) == FALSE )
        {
            DWORD temp = GetLastError();
            DEBUG_PUT(("\n Cookie Rejected!  Error code: %x", temp));
        }

    // If we got this far, we're done.
    retVal = TRUE;

    doneImportCookie:
        if( szValue != NULL)
            delete [] szValue;
        if( szURL != NULL)
            delete [] szURL;
    }



doneImportFile:
    if( hFile != (HKEY) INVALID_HANDLE_VALUE)
        CloseHandle( hFile);

    if( szFile != NULL)
        delete [] szFile;


    return retVal;
}


//--------------------------------------------------------------------
//
//  FindNetscapeCookieFile
//

//  Gets the cookie file and stores it in buffer szFilename.
//lpnBufSize contains the buffer's size on the way in, and the amount used on the way out (in characters)
//If FindNetscapeCookieFile succeeds, it returns TRUE, else it returns FALSE.
//If it fails, information may be written to the buffer with error information,
//  look at RegQueryValueEx for details.
BOOL FindNetscapeCookieFile( IN DWORD dwNSVer, OUT LPTSTR szFilename, /* in-out */ LPDWORD lpnBufSize)
{
    BOOL retVal = FALSE;

    //  for Version<MS_NAVI4
    HKEY hCookieKey, hUserRootKey, hProfileKey;

    //  for MS_NAVI4 >= Version < MS_NAVI5
    hCookieKey = (HKEY) INVALID_HANDLE_VALUE;
    hUserRootKey = (HKEY) INVALID_HANDLE_VALUE;
    hProfileKey = (HKEY) INVALID_HANDLE_VALUE;

    INET_ASSERT( dwNSVer != 0x0000);

    if( dwNSVer < NS_NAVI4)
    {
        if( REGOPENKEYEX( HKEY_CURRENT_USER, NS3_COOKIE_REG_PATH, 0, KEY_READ, &hCookieKey) != ERROR_SUCCESS)
        {
            hCookieKey = (HKEY) INVALID_HANDLE_VALUE;
            goto doneFindNetscapeCookieFile;
        }

        DWORD dwType;  //  should be REG_SZ when returned from QueryValue
        DWORD cbBufSize;
        cbBufSize = *lpnBufSize * sizeof(TCHAR);
        if( RegQueryValueEx( hCookieKey, NS3_COOKIE_REG_KEY, NULL,  &dwType, (LPBYTE)szFilename, &cbBufSize) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            *lpnBufSize = cbBufSize / sizeof(TCHAR);
            goto doneFindNetscapeCookieFile;
        }
        *lpnBufSize = cbBufSize / sizeof(TCHAR);

        retVal = TRUE;
    }
    else if ( dwNSVer < NS_NAVI5)
    {
        if( REGOPENKEYEX( HKEY_LOCAL_MACHINE, NS4_USERS_REG_PATH, 0, KEY_READ, &hUserRootKey) != ERROR_SUCCESS)
        {
            hUserRootKey = (HKEY) INVALID_HANDLE_VALUE;
            goto doneFindNetscapeCookieFile;
        }

        DWORD dwNumberOfProfiles;
        if( RegQueryInfoKey( hUserRootKey, NULL, NULL, NULL, &dwNumberOfProfiles,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS
            || dwNumberOfProfiles != 1)
        {
            goto doneFindNetscapeCookieFile;
        }

        TCHAR szProfileName[MAX_PATH];
        DWORD nProfileNameBufferSize;
        nProfileNameBufferSize = sizeof(szProfileName);
        if( RegEnumKeyEx( hUserRootKey, 0, szProfileName, &nProfileNameBufferSize, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        {
            goto doneFindNetscapeCookieFile;
        }

        if( REGOPENKEYEX( hUserRootKey, szProfileName, 0, KEY_READ, &hProfileKey) != ERROR_SUCCESS)
        {
            hProfileKey = (HKEY) INVALID_HANDLE_VALUE;
            goto doneFindNetscapeCookieFile;
        }

        DWORD dwType;  //  should be REG_SZ when returned from QueryValue
        DWORD cbBufSize;
        cbBufSize = *lpnBufSize * sizeof(TCHAR);
        if( RegQueryValueEx( hProfileKey, NS4_USERPATH_REG_KEY, NULL, &dwType, (LPBYTE)szFilename, &cbBufSize) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            *lpnBufSize = (cbBufSize / sizeof(TCHAR) - 1) + LENGTHOFTSTR( NS_COOKIE_FILENAME);
            goto doneFindNetscapeCookieFile;
        }

        if( (*lpnBufSize - (cbBufSize / sizeof(TCHAR) - 1)) < LENGTHOFTSTR( NS_COOKIE_FILENAME))
        {
            *lpnBufSize = (cbBufSize / sizeof(TCHAR) - 1) + LENGTHOFTSTR( NS_COOKIE_FILENAME);
            goto doneFindNetscapeCookieFile;
        }

        *lpnBufSize = cbBufSize / sizeof(TCHAR) - 1;
        szFilename[(*lpnBufSize)++] = TCHAR('\\');
        memcpy( szFilename + *lpnBufSize, NS_COOKIE_FILENAME, sizeof(NS_COOKIE_FILENAME));
        *lpnBufSize += LENGTHOFTSTR( NS_COOKIE_FILENAME);

        retVal = TRUE;
    }

doneFindNetscapeCookieFile:

    if( hCookieKey != (HKEY) INVALID_HANDLE_VALUE )
        REGCLOSEKEY( hCookieKey);

    if( hUserRootKey != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hUserRootKey);

    if( hProfileKey != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hProfileKey);

    return retVal;
}


//--------------------------------------------------------------------
//
//  GetActiveNetscapeVersion
//

BOOL GetActiveNetscapeVersion( LPDWORD lpVersion)
{
    BOOL retVal = FALSE;

    TCHAR szFilename[MAX_PATH];
    DWORD cFilenameSize = MAX_PATH;
    BYTE* pVerBuffer = NULL;

    //  If the application currently associated with .htm files is NS,
    //thats the active version.  If it isn't, we grab the last installed
    //version of NS and say thats the active version.

    LPTSTR pFilenameSubstring;
    if( GetExecuteableFromExtension( HTML_FILE_EXTENSION, szFilename, &cFilenameSize, &pFilenameSubstring) == FALSE
        || StrCmpI( pFilenameSubstring, NS_EXE_FILENAME) != 0 )
    {
        goto doneGetActiveNetscapeVersion;
    }

    DWORD cbFileVersionBufSize;
    DWORD dwTemp;
    if( (cbFileVersionBufSize = GetFileVersionInfoSize( szFilename, &dwTemp)) == 0 )
        goto doneGetActiveNetscapeVersion;

    pVerBuffer = new BYTE[cbFileVersionBufSize];
    if( pVerBuffer == NULL)
        goto doneGetActiveNetscapeVersion;

    if( GetFileVersionInfo( szFilename, 0, cbFileVersionBufSize, pVerBuffer) == 0 )
        goto doneGetActiveNetscapeVersion;

    VS_FIXEDFILEINFO *lpVSFixedFileInfo;

    unsigned uiLength;
    if( VerQueryValue( pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) == 0
        || uiLength == 0)
        goto doneGetActiveNetscapeVersion;

    *lpVersion = lpVSFixedFileInfo->dwFileVersionMS;
    retVal = TRUE;

doneGetActiveNetscapeVersion:
    if( pVerBuffer != NULL)
        delete [] pVerBuffer;

    return retVal;
}


//--------------------------------------------------------------------
//
//  ImportCookieFile
//

//  Retrieves the executable file associated with the open command for
//a particular file extension.
//
//  Parsing the open command for the path\file can be ambiguous.
//If there is a '\' in a prefixed file argument of the open command
//the returned string will contain everying up to and including
//that argument
//
//example:
//""c:\program files\argy.exe \load file" -postfix"
//will give you
//"c:\program files\ argv.exe \load"
//
//typical case:
//""c:\program files\exec.exe -prearg" -postarg"
//will give you
//"c:\program files\exec.exe"
//
//pcFilenameSubstring will point one char past the last '\' to allow
//immediate checking of that last word.
//
BOOL GetExecuteableFromExtension(
    IN LPCTSTR szExtension,
    OUT LPTSTR szFilepath,
    /* in-out */ LPDWORD pcFilenameSize,
    OUT LPTSTR* ppFilenameSubstring)
{
    DWORD dwType;   // rewritten often, temporary values
    TCHAR szBuffer[MAX_PATH];   // reused as szCommandKeyPath and szOpenCommand
    DWORD cBufSize;

    BOOL retVal = FALSE;

    HKEY hHtmlEntry = (HKEY) INVALID_HANDLE_VALUE;
    HKEY hOpenCmd = (HKEY) INVALID_HANDLE_VALUE;

    if( REGOPENKEYEX( HKEY_CLASSES_ROOT, szExtension, 0, KEY_READ, &hHtmlEntry) != ERROR_SUCCESS)
    {
        hHtmlEntry = (HKEY) INVALID_HANDLE_VALUE;
        goto doneGetExecuteableFromExtension;
    }

    // to build a registry key in szCommandKeyPath, we first retrieve
    // the filetype (e.g. htmlfile) and then attach the registry path
    // for the 'open' command in HKEY_CLASSES_ROOT

    LPTSTR szCommandKeyPath;
    szCommandKeyPath = szBuffer;

    //  retrieve filetype
    cBufSize = MAX_PATH * sizeof(TCHAR);
    if( RegQueryValueEx( hHtmlEntry, NULL, NULL, &dwType, (BYTE*)szCommandKeyPath, &cBufSize) != ERROR_SUCCESS
        || dwType != REG_SZ )
    {
        goto doneGetExecuteableFromExtension;
    }

    //  append path ('htmlfile' -> 'htmlfile\\shell\\open\\command')
    StrCatBuff(szCommandKeyPath, OPEN_COMMAND_OF_APP, MAX_PATH);

    //  get the open command from the registry
    if( REGOPENKEYEX( HKEY_CLASSES_ROOT, szCommandKeyPath, 0, KEY_READ, &hOpenCmd) != ERROR_SUCCESS)
    {
        hOpenCmd = (HKEY) INVALID_HANDLE_VALUE;
        goto doneGetExecuteableFromExtension;
    }

    LPTSTR szOpenCommand;
    szOpenCommand = szBuffer;
    cBufSize = MAX_PATH * sizeof(TCHAR);
    if( RegQueryValueEx( hOpenCmd, "", NULL, &dwType, (BYTE*)szOpenCommand, &cBufSize) != ERROR_SUCCESS
        || dwType != REG_SZ)
    {
        goto doneGetExecuteableFromExtension;
    }

    // we now have a command line entry with the netscape filename.
    // typical format:  ""path\filename -prefixed args" -postfixed arguments"

    LPTSTR pSubstring;
    LPTSTR pRightmostWhack;
    // Now, too build a return value, point to the path\filename within the
    // command line entry and null-terminate it.
    pSubstring = szOpenCommand;
    while( *pSubstring == TCHAR('\"') || *pSubstring == TCHAR(' '))
    {
        // move beginning past any prefixed quotes or spaces
        pSubstring++;
    }

    pRightmostWhack = StrRChr(pSubstring, NULL, TCHAR('\\'));

    if (!pRightmostWhack)
    {
        // couldn't find a "\" so just set it equal to the substring
        pRightmostWhack = pSubstring;
    }
    else
    {
        // move to the the beginning of the last token (a filename, we assume)
        pRightmostWhack++;
    }

    // save the location of the filename
    *ppFilenameSubstring = pRightmostWhack;

    // move right end past the last token
    while(*pRightmostWhack != TCHAR('\"')    &&
          *pRightmostWhack != TCHAR(' ')     &&
          *pRightmostWhack != TCHAR('\0'))
    {
        pRightmostWhack++;
    }

    // null terminate the substring
    *pRightmostWhack = TCHAR('\0');

    // strictly > since lstrlen dosen't count space for NULL terminator
    if(*pcFilenameSize > (DWORD)lstrlen(pSubstring))
    {
        lstrcpyn(szFilepath, pSubstring, *pcFilenameSize);
        retVal = TRUE;
    }

    *pcFilenameSize = lstrlen(pSubstring);

doneGetExecuteableFromExtension:
    if( hHtmlEntry != (HKEY) INVALID_HANDLE_VALUE)
    {
        REGCLOSEKEY( hHtmlEntry);
    }

    if( hOpenCmd != (HKEY) INVALID_HANDLE_VALUE)
    {
        REGCLOSEKEY( hOpenCmd);
    }

    return retVal;
}






//***********************************************************************************
//    registry functions to store which version of Netscape is to be imported from


//--------------------------------------------------------------------
//
//  SetNetscapeImportVersion
//

//  Store version of Netscape to import cookies from in the registry
BOOL SetNetscapeImportVersion( IN DWORD dwNSVersion)
{
    BOOL retVal = FALSE;

    HKEY hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;

    DWORD dwDisposition;  // ignored output parameter
    if( REGCREATEKEYEX( HKEY_LOCAL_MACHINE, NS_COOKIE_IMPORT_KEY, 0, TEXT("REG_SZ"),
                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hNSVersionKey, &dwDisposition) != ERROR_SUCCESS)
    {
        hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;
        goto doneSetNetscapeImportVersion;
    }

    if( RegSetValueEx( hNSVersionKey, NS_COOKIE_IMPORT_VERSION, 0, REG_DWORD, (BYTE*)&dwNSVersion, sizeof(DWORD)) != ERROR_SUCCESS )
        goto doneSetNetscapeImportVersion;

    retVal = TRUE;

doneSetNetscapeImportVersion:
    if( hNSVersionKey != (HKEY) INVALID_HANDLE_VALUE )
        REGCLOSEKEY( hNSVersionKey);

    return retVal;
}


//--------------------------------------------------------------------
//
//  GetNetscapeImportVersion
//

//  Retrieves version of Netscape to import coookies from in the registry
BOOL GetNetscapeImportVersion( OUT DWORD* pNSVersion)
{
    BOOL retVal = FALSE;

    HKEY hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;

    TCHAR szNSFilename[MAX_PATH];
    DWORD cNSFilenameSize = MAX_PATH;

    if( REGOPENKEYEX( HKEY_LOCAL_MACHINE, NS_COOKIE_IMPORT_KEY, 0, KEY_READ, &hNSVersionKey) != ERROR_SUCCESS)
    {
        hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;
        goto doneGetNetscapeImportVersion;
    }

    DWORD dwType;
    DWORD dwBufSize;
    dwBufSize = sizeof(DWORD);
    if( RegQueryValueEx( hNSVersionKey, NS_COOKIE_IMPORT_VERSION, 0, &dwType, (BYTE*)pNSVersion, &dwBufSize) != ERROR_SUCCESS
        || dwType != REG_DWORD)
    {
        goto doneGetNetscapeImportVersion;
    }

    //  if the "DisableImport" key has been set to a non-FALSE value,
    //fail to find a version to import from.
    DWORD fDontImport;
    if( (RegQueryValueEx( hNSVersionKey, NS_COOKIE_IMPORT_FLAG, 0, &dwType,
                        (BYTE*)&fDontImport, &(dwBufSize = sizeof(fDontImport)))
           == ERROR_SUCCESS)
        && dwType == REG_DWORD
        && fDontImport != FALSE)
    {
        goto doneGetNetscapeImportVersion;
    }

    retVal = TRUE;

doneGetNetscapeImportVersion:
    if( hNSVersionKey != (HKEY) INVALID_HANDLE_VALUE )
        REGCLOSEKEY( hNSVersionKey);

    return retVal;

}


//***************************************************************************
//  utility functions internal to cookimp.cxx


//  indicates if a character is an endofline character in a Netscape cookie file.
bool EndOfLine( CHAR chr )
{
    return chr == '\n' || chr == '\r';
}


//--------------------------------------------------------------------
//
//  InternetTimeFromTime_tA
//

//  InternetTimeFromTime_T takes a time value formatted to the run-time library's time_t
//and gives a formatted time string formatted to the RFC format in HTTP spec 1.0
//
//  dwTime is the number of seconds since Jan 1, 1970 00:00:00.
BOOL InternetTimeFromTime_tA( IN DWORD dwTime, OUT LPSTR lpszTime, DWORD cbBufferSize )
{
    if( cbBufferSize < INTERNET_RFC1123_BUFSIZE )
        return false;

//    FILETIME ft2;
//    DosTime2FileTime( dwTime, &ft2);

    //  First create a FILETIME value, to convert to SYSTEMTIME.

    //  i19700Offset is the FILETIME offset of Jan 1, 1970 at 00:00:00...
    const DWORDLONG dwl1970Offset = 0x019dae9064bafa80;

    DWORDLONG dwlTime = dwl1970Offset + (DWORDLONG)dwTime * (DWORDLONG)10000000;
    FILETIME ft;
    ft.dwLowDateTime  = (DWORD)( dwlTime & 0x00000000FFFFFFFF);
    ft.dwHighDateTime = (DWORD)Int64ShrlMod32( Int64ShrlMod32( dwlTime & 0xFFFFFFFF00000000, 16), 16 );

    //  Second I convert the FILETIME to a SYSTEMTIME   
    SYSTEMTIME st;

    if( FileTimeToSystemTime( &ft, &st ) == 0)
        return FALSE;

#ifdef UNICODE
#error "InternetTimeFromTime_tA(): InternetTimeFromSystemTimeA needs to be called directly from here."
#endif
    //  Finally I use SYSTEMTIME to produce the formatted string.
    return InternetTimeFromSystemTime( &st, INTERNET_RFC1123_FORMAT, lpszTime, cbBufferSize );
}


//--------------------------------------------------------------------
//
//  ReadFileToBuffer
//

//  opens a file and spits it out to memory.
//  if *ppBuf originally points to NULL, memory is allocated for the file
//      and cbBufSize contains the number of bytes allocated.
//      (use delete [] *ppBuf when done)
//  if *ppBuf is not NULL, it is assumed to point to a target buffer of
//      size *lpcbBufSize, and size used is then recorded in *lpcbBufSize.
//  returns TRUE if successful.
//  on FALSE return, *lpcbBufSize contains the size needed to be allocated
//      or 0xFFFFFFFF on total failure
BOOL ReadFileToBuffer( IN LPCTSTR szFilename, LPBYTE* ppBuf, LPDWORD lpcbBufSize)
{
    BOOL retVal = FALSE;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    hFile = CreateFile( szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);

    if( hFile == INVALID_HANDLE_VALUE )
    {
        //  notify failure and exit
        *lpcbBufSize = 0xFFFFFFFF;
        goto doneReadFileToBuffer;
    }

    DWORD dwHighOrderedBitsOfFileSize;
    DWORD cbFileSize;
    cbFileSize = GetFileSize( hFile, &dwHighOrderedBitsOfFileSize );
    if(  cbFileSize == 0xFFFFFFFF || dwHighOrderedBitsOfFileSize != 0 )
    {
        //  notify file was too big and exit
        *lpcbBufSize = 0xFFFFFFFF;
        goto doneReadFileToBuffer;
    }

    if( *ppBuf != NULL )
    {
        //  verify passed buffer is large enough
        if( *lpcbBufSize < cbFileSize)
        {
            //  set needed filesize and exit
            *lpcbBufSize = cbFileSize;
            goto doneReadFileToBuffer;
        }
    }
    else
    {
        *ppBuf = new BYTE[cbFileSize];

        if( *ppBuf == NULL)
        {
            //  notify failure and exit
            *lpcbBufSize = 0xFFFFFFFF;
            goto doneReadFileToBuffer;
        }
    }

    //  set output result
    *lpcbBufSize = cbFileSize;

    DWORD cbRead;
    if( ReadFile( hFile, *ppBuf, cbFileSize, &cbRead, NULL) != TRUE
        || cbRead != cbFileSize)
    {
        //  notify failure and exit
        *lpcbBufSize = 0xFFFFFFFF;
        goto doneReadFileToBuffer;
    }

    CloseHandle( hFile );
    hFile = INVALID_HANDLE_VALUE;

    retVal = TRUE;

doneReadFileToBuffer:

    if( hFile != INVALID_HANDLE_VALUE)
        CloseHandle( hFile);

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\certcach.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certcach.cxx

Abstract:

    Contains class implementation for certificate cache object.
    This object will hold various Certificate entries.

    Contents:
        SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::AddRef
        SECURITY_CACHE_LIST_ENTRY::Release
        SECURITY_CACHE_LIST_ENTRY::Clear
        SECURITY_CACHE_LIST::Find
        SECURITY_CACHE_LIST::Add
        SECURITY_CACHE_LIST::ClearList
        SECURITY_CACHE_LIST::ClearClientAuthCertChains

    TODO:  Add Cert validation.  What if Cert is given but different?

Author:

    Arthur L Bierer (arthurbi) 20-Apr-1996

Revision History:

    20-Apr-1996 arthurbi
        Created

--*/
#include <wininetp.h>

//
// private manifests
//

#define MAX_CERT_CACHE_CERTS    16

//
// private types
//

//
// SECURITY_CACHE_LIST_ENTRY member functions
//


SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY constructor. Create object; don't add it to list

Arguments:

    lpszHostName    - name of host for which this cache entry created

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY",
                 "%q",
                 lpszHostName
                 ));

#if INET_DEBUG
    _List.Flink = _List.Blink = NULL;
#endif
    _cRef = 1;
    _fInCache = FALSE;
    _ServerName = lpszHostName;
    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _dwSecurityFlags = 0;
    _pCertContextArray = NULL;
    _fForceNewSession = FALSE;
    _fValidateAll = FALSE;

#if INET_DEBUG
    m_Signature = 0x454c4353;   // 'SCLE'
#endif

    DEBUG_LEAVE(0);
}


SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY()

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "~SECURITY_CACHE_LIST_ENTRY",
                 "{%#x [%q]}",
                 this,
                 _ServerName.StringAddress()
                 ));

    INET_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    Clear();

    DEBUG_LEAVE(0);
}


LONG
SECURITY_CACHE_LIST_ENTRY::AddRef(
    VOID
    )

/*++

Routine Description:

    Increment reference count of SECURITY_CACHE_LIST_ENTRY

Arguments:

    None.

Return Value:

    LONG    - reference count after increment

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::AddRef",
                 "{%#x [%q, %d]}",
                 this,
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    InterlockedIncrement(&_cRef);

    DEBUG_LEAVE(_cRef);

    return _cRef;
}


LONG
SECURITY_CACHE_LIST_ENTRY::Release(
    VOID
    )

/*++

Routine Description:

    Decrement reference count and destroy object if (<=) zero

Arguments:

    None.

Return Value:

    LONG    - reference count after decrement

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::Release",
                 "{%q [%d]}",
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    LONG cRet;

    if (0 >= (cRet = InterlockedDecrement(&_cRef))) {
        delete this;
    }

    DEBUG_LEAVE(cRet);

    return cRet;
}


VOID
SECURITY_CACHE_LIST_ENTRY::Clear()

/*++

Routine Description:

    Clear out SECURITY_CACHE_LIST_ENTRY

Arguments:

    Clear   -

Return Value:

    None.

--*/

{
    if (_CertInfo.pCertificate != NULL) {
        __try {
            CertFreeCertificateContext(_CertInfo.pCertificate);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
        }
        ENDEXCEPT
        _CertInfo.pCertificate = NULL;
    }

    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _CertInfo.dwSize = sizeof(_CertInfo);

    _dwSecurityFlags = 0;
    _ServerName = NULL;
    _pCertContextArray = NULL;
    if( _pCertContextArray )
    {
        delete _pCertContextArray;
        _pCertContextArray = NULL;
    }
}

//
// SECURITY_CACHE_LIST member functions
//


VOID
SECURITY_CACHE_LIST::ClearList(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::ClearList",
                 NULL
                 ));

    LockSerializedList(&_List);

    while (!IsSerializedListEmpty(&_List)) {

        SECURITY_CACHE_LIST_ENTRY * CacheEntry;

        //
        // remove the PROXY_SERVER_LIST_ENTRY at the head of the serialized
        // list
        //

        LPVOID entry = SlDequeueHead(&_List);

        //
        // entry should not be NULL - IsSerializedListEmpty() told us we
        // could expect something
        //

        INET_ASSERT(entry != NULL);

        //
        // get the address of the object (should be the same as entry) and
        // delete it
        //

        CacheEntry = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("releasing %q (%d)\n",
                    CacheEntry->_ServerName.StringAddress(),
                    CacheEntry->_cRef
                    ));

        CacheEntry->Release();
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(0);
}


DWORD
SECURITY_CACHE_LIST::Add(
    IN SECURITY_CACHE_LIST_ENTRY * entry
    )

/*++

Routine Description:

    Adds a CertInfo Structure to the list front of the list.

Arguments:

    lpszHost    - Hostname to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "SECURITY_CACHE_LIST::Add",
                 "%#x [%q, %d]",
                 entry,
                 entry ? entry->_ServerName.StringAddress() : "",
                 entry ? entry->_cRef : 0
                 ));

    DWORD error = ERROR_SUCCESS;

    INET_ASSERT(entry != NULL);

    if (entry != NULL) {
        LockSerializedList(&_List);

        //
        // If we've grown too much, nuke the oldest one.
        //

        if (ElementsOnSerializedList(&_List) >= MAX_CERT_CACHE_CERTS) {

            SECURITY_CACHE_LIST_ENTRY *pOld;
            LPVOID old_entry = SlDequeueTail(&_List);

            INET_ASSERT(old_entry != NULL);

            pOld = CONTAINING_RECORD(old_entry, SECURITY_CACHE_LIST_ENTRY, _List);

            //
            // entry should not be NULL - IsSerializedListEmpty() told us we
            // could expect something
            //

            pOld->_fInCache = FALSE;

            //
            // Clean Our old object, and reinstatiate with a new name.
            //

            pOld->Release();
        }
        InsertAtHeadOfSerializedList(&_List, &entry->_List);
        entry->AddRef();
        entry->_fInCache = TRUE;
        UnlockSerializedList(&_List);
    }

    DEBUG_LEAVE(error);

    return error;
}


SECURITY_CACHE_LIST_ENTRY *
SECURITY_CACHE_LIST::Find(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and returns
    the found entry, or NULL if not found.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    CERT_CACHE_LIST_ENTRY *
        Success - Pointer to found entry.

        Failure - NULL, not found.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Find",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;

    //
    // BUGBUG need to validate against Server Certifcate on every
    //  connection, this Find only validates by Hostname.
    //  What about DNS spoofing?  Won't we be hosed?
    //

    //
    // TODO if found, need to push to front of list.
    //

    LockSerializedList(&_List);
    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        //
        // check to see if they match.
        //

        if (info->_ServerName.Stricmp(lpszHost) == 0) {
            info->AddRef();
            break; // match.
        }
        info = NULL;
    }
    UnlockSerializedList(&_List);

    DEBUG_LEAVE(info);

    return info;
}


VOID
SECURITY_CACHE_LIST::Remove(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and removes
    the entry.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Remove",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;


    LockSerializedList(&_List);
    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        //
        // check to see if they match.
        //

        if (info->_ServerName.Stricmp(lpszHost) == 0) {
            RemoveFromSerializedList(&_List, entry);
            break; // match.
        }
        info->_fInCache = FALSE;
        info = NULL;
    }
    UnlockSerializedList(&_List);

    DEBUG_LEAVE(0);

}


VOID
SECURITY_CACHE_LIST::ClearClientAuthCertChains(
    VOID
    )
/*++

Routine Description:

    This function walks the cache and releases any client
    auth chains associated with each entry.  This method
    is called in response to the "Clear SSL State" button
    being pressed in inetcpl.  Starting with Whistler,
    client certificates are cached for the logon session,
    rather than the process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "SECURITY_CACHE_LIST::ClearClientAuthCertChains",
                 NULL
                 ));

    SECURITY_CACHE_LIST_ENTRY * pInfo = NULL;

    LockSerializedList(&_List);
    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        pInfo = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        // This will delete and NULL the array
        pInfo->SetCertContextArray(NULL);

        // Ensure new session is negotiated for next SSL connection to server
        pInfo->SetForceNewSession(TRUE);
    }
    UnlockSerializedList(&_List);

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\event.cxx ===
//
// event.cxx - simple eventing mechanism for ras/offline/logon events
//
#include "wininetp.h"
#include <docobj.h>

//
// Globals
//
static const TCHAR szEventKey[] = REGSTR_PATH_INETEVENTS;

CLSID clsidEventGroup = { /* ab8ed004-b86a-11d1-b1f8-00c04fa357fa */
    0xab8ed004,
    0xb86a,
    0x11d1,
    {0xb1, 0xf8, 0x00, 0xc0, 0x4f, 0xa3, 0x57, 0xfa}
  };

//
// remember events so we don't repeat them
//
static DWORD g_dwOffline = 0;

//
// SendEvent - deliver an event to a single client
//
BOOL SendEvent(DWORD dwEvent, VARIANTARG *pva, LPTSTR pszValue)
{
    CLSID               clsid;
    IOleCommandTarget   *poct;
    HRESULT             hr = E_FAIL;

#ifdef UNICODE
    if(FAILED(CLSIDFromString(pszValue, &clsid)))
        return FALSE;
#else
    WCHAR wszCLSID[80];
    MultiByteToWideChar(CP_ACP, 0, pszValue, -1, wszCLSID, sizeof(wszCLSID) / sizeof(WCHAR));
    if(FAILED(CLSIDFromString(wszCLSID, &clsid)))
        return FALSE;
#endif


    hr = (CoCreateInstance(clsid, NULL, CLSCTX_ALL,
                            IID_IOleCommandTarget, (void **)&poct));
    if(SUCCEEDED(hr))
    {
        // ensure client likes our group
        hr = poct->Exec(&clsidEventGroup, dwEvent, 0, pva, NULL);
        poct->Release();
    }

    return SUCCEEDED(hr);
}


//
// EnumClients - send all events to clients in a reg key
//
DWORD EnumClients(HKEY hkey, DWORD dwEvent, LPWSTR pwsEventDesc, DWORD dwEventData)
{
    DWORD cbData, cbValue, dwType, i, dwMask;
    TCHAR szValueName[80];
    VARIANTARG  va;

    va.vt = VT_EMPTY;

    //
    // Enumerate everyone
    //
    for (i = 0; ; i++)
    {
        LONG lEnum;

        cbValue = sizeof(szValueName) / sizeof(TCHAR);
        cbData = sizeof(DWORD);

        // BUGBUG (Unicode, Davepl) I'm assuming that the data is UNICODE,
        // but I'm not sure who put it there yet... double check.

        if( ( lEnum = RegEnumValue( hkey, i, szValueName, &cbValue, NULL,
                                    &dwType, (LPBYTE)&dwMask, &cbData ) ) == ERROR_MORE_DATA )
        {
            // ERROR_MORE_DATA means the value name or data was too large
            // skip to the next item
            continue;
        }
        else if( lEnum != ERROR_SUCCESS )
        {
            // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
            // we can't recover from any other registry problem, anyway
            break;
        }

        if(0 != (dwMask & dwEvent)) {
            // this guy wants this event
            SendEvent(dwEvent, &va, szValueName);
        }
    }

    return 0;
}



//
// DispatchEvent - enumerate all clients and deliver the event to them
//

DWORD InternetDispatchEvent(DWORD dwEvent, LPWSTR pwsEventDesc, DWORD dwEventData)
{
    HKEY hkey;

    // get rid of repeated events here
    switch(dwEvent) {
    case INETEVT_OFFLINE:
        if(g_dwOffline == dwEvent)
            return 0;
        g_dwOffline = dwEvent;
        break;
    case INETEVT_ONLINE:
        if(g_dwOffline == dwEvent)
            return 0;
        g_dwOffline = dwEvent;
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    // fire up com
    if(SUCCEEDED(CoInitialize(NULL))) {

        if (REGOPENKEY(HKEY_CURRENT_USER, szEventKey, &hkey) == ERROR_SUCCESS) {
            EnumClients(hkey, dwEvent, pwsEventDesc, dwEventData);
            REGCLOSEKEY(hkey);
        }

        if (REGOPENKEY(HKEY_LOCAL_MACHINE, szEventKey, &hkey) == ERROR_SUCCESS) {
            EnumClients(hkey, dwEvent, pwsEventDesc, dwEventData);
            REGCLOSEKEY(hkey);
        }

        CoUninitialize();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\globals.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains global data items for WININET.DLL and initialization function

    Contents:
        GlobalDllInitialize
        GlobalDllTerminate
        GlobalDataInitialize
        GlobalTruncateFileName;
        GlobalDataTerminate
        IsHttp1_1
        IsOffline
        SetOfflineUserState
        FetchLocalStrings
        GetWininetUserName
        ChangeGlobalSettings
        RefreshOfflineFromRegistry
        PerformStartupProcessing

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

    07-Oct-1998 joshco
        updated minor version number 1->2

--*/

#include <wininetp.h>
#include <ntverp.h>
#include <autodial.h>       // InitAutodialModule, ExitAutodialModule
#include <schnlsp.h>
#include <persist.h>

//
// WinInet major & minor versions - allow to be defined externally
//

// JOSHCO

#if !defined(WININET_MAJOR_VERSION)
#define WININET_MAJOR_VERSION   1
#endif
#if !defined(WININET_MINOR_VERSION)
#define WININET_MINOR_VERSION   2
#endif

//
// external functions
//

void RefreshP3PSettings();

STDAPI_(void) UrlZonesDetach (void);

#if INET_DEBUG

VOID
InitDebugSock(
    VOID
    );

#endif

//
// private prototypes
//

#if defined(SITARA)

PRIVATE
VOID
OpenIeMainKey(
    VOID
    );

PRIVATE
VOID
CloseIeMainKey(
    VOID
    );

PRIVATE
BOOL
CheckABS(
    VOID
    );

PRIVATE
BOOL
ReadIeMainDwordValue(
    IN LPSTR pszValueName,
    OUT LPDWORD pdwValue
    );

#endif // SITARA

//
// global DLL state data
//

GLOBAL HINSTANCE GlobalDllHandle = NULL;
GLOBAL DWORD GlobalPlatformType;
GLOBAL DWORD Globa